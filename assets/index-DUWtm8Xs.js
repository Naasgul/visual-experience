(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const d of document.querySelectorAll('link[rel="modulepreload"]'))s(d);new MutationObserver(d=>{for(const c of d)if(c.type==="childList")for(const h of c.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&s(h)}).observe(document,{childList:!0,subtree:!0});function o(d){const c={};return d.integrity&&(c.integrity=d.integrity),d.referrerPolicy&&(c.referrerPolicy=d.referrerPolicy),d.crossOrigin==="use-credentials"?c.credentials="include":d.crossOrigin==="anonymous"?c.credentials="omit":c.credentials="same-origin",c}function s(d){if(d.ep)return;d.ep=!0;const c=o(d);fetch(d.href,c)}})();function getDefaultExportFromCjs(a){return a&&a.__esModule&&Object.prototype.hasOwnProperty.call(a,"default")?a.default:a}var jsxRuntime={exports:{}},reactJsxRuntime_production_min={},react={exports:{}},react_production_min={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var l$1=Symbol.for("react.element"),n$1=Symbol.for("react.portal"),p$2=Symbol.for("react.fragment"),q$3=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v$1=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x$1=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z$2=Symbol.iterator;function A$1(a){return a===null||typeof a!="object"?null:(a=z$2&&a[z$2]||a["@@iterator"],typeof a=="function"?a:null)}var B$1={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C$1=Object.assign,D$2={};function E$2(a,e,o){this.props=a,this.context=e,this.refs=D$2,this.updater=o||B$1}E$2.prototype.isReactComponent={};E$2.prototype.setState=function(a,e){if(typeof a!="object"&&typeof a!="function"&&a!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,e,"setState")};E$2.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function F$1(){}F$1.prototype=E$2.prototype;function G$1(a,e,o){this.props=a,this.context=e,this.refs=D$2,this.updater=o||B$1}var H$1=G$1.prototype=new F$1;H$1.constructor=G$1;C$1(H$1,E$2.prototype);H$1.isPureReactComponent=!0;var I$1=Array.isArray,J=Object.prototype.hasOwnProperty,K$2={current:null},L$1={key:!0,ref:!0,__self:!0,__source:!0};function M$2(a,e,o){var s,d={},c=null,h=null;if(e!=null)for(s in e.ref!==void 0&&(h=e.ref),e.key!==void 0&&(c=""+e.key),e)J.call(e,s)&&!L$1.hasOwnProperty(s)&&(d[s]=e[s]);var _=arguments.length-2;if(_===1)d.children=o;else if(1<_){for(var bt=Array(_),g=0;g<_;g++)bt[g]=arguments[g+2];d.children=bt}if(a&&a.defaultProps)for(s in _=a.defaultProps,_)d[s]===void 0&&(d[s]=_[s]);return{$$typeof:l$1,type:a,key:c,ref:h,props:d,_owner:K$2.current}}function N$1(a,e){return{$$typeof:l$1,type:a.type,key:e,ref:a.ref,props:a.props,_owner:a._owner}}function O$2(a){return typeof a=="object"&&a!==null&&a.$$typeof===l$1}function escape$1(a){var e={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(o){return e[o]})}var P$1=/\/+/g;function Q$1(a,e){return typeof a=="object"&&a!==null&&a.key!=null?escape$1(""+a.key):e.toString(36)}function R$2(a,e,o,s,d){var c=typeof a;(c==="undefined"||c==="boolean")&&(a=null);var h=!1;if(a===null)h=!0;else switch(c){case"string":case"number":h=!0;break;case"object":switch(a.$$typeof){case l$1:case n$1:h=!0}}if(h)return h=a,d=d(h),a=s===""?"."+Q$1(h,0):s,I$1(d)?(o="",a!=null&&(o=a.replace(P$1,"$&/")+"/"),R$2(d,e,o,"",function(g){return g})):d!=null&&(O$2(d)&&(d=N$1(d,o+(!d.key||h&&h.key===d.key?"":(""+d.key).replace(P$1,"$&/")+"/")+a)),e.push(d)),1;if(h=0,s=s===""?".":s+":",I$1(a))for(var _=0;_<a.length;_++){c=a[_];var bt=s+Q$1(c,_);h+=R$2(c,e,o,bt,d)}else if(bt=A$1(a),typeof bt=="function")for(a=bt.call(a),_=0;!(c=a.next()).done;)c=c.value,bt=s+Q$1(c,_++),h+=R$2(c,e,o,bt,d);else if(c==="object")throw e=String(a),Error("Objects are not valid as a React child (found: "+(e==="[object Object]"?"object with keys {"+Object.keys(a).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return h}function S$1(a,e,o){if(a==null)return a;var s=[],d=0;return R$2(a,s,"","",function(c){return e.call(o,c,d++)}),s}function T$1(a){if(a._status===-1){var e=a._result;e=e(),e.then(function(o){(a._status===0||a._status===-1)&&(a._status=1,a._result=o)},function(o){(a._status===0||a._status===-1)&&(a._status=2,a._result=o)}),a._status===-1&&(a._status=0,a._result=e)}if(a._status===1)return a._result.default;throw a._result}var U$2={current:null},V$1={transition:null},W$2={ReactCurrentDispatcher:U$2,ReactCurrentBatchConfig:V$1,ReactCurrentOwner:K$2};react_production_min.Children={map:S$1,forEach:function(a,e,o){S$1(a,function(){e.apply(this,arguments)},o)},count:function(a){var e=0;return S$1(a,function(){e++}),e},toArray:function(a){return S$1(a,function(e){return e})||[]},only:function(a){if(!O$2(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};react_production_min.Component=E$2;react_production_min.Fragment=p$2;react_production_min.Profiler=r;react_production_min.PureComponent=G$1;react_production_min.StrictMode=q$3;react_production_min.Suspense=w;react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W$2;react_production_min.cloneElement=function(a,e,o){if(a==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var s=C$1({},a.props),d=a.key,c=a.ref,h=a._owner;if(e!=null){if(e.ref!==void 0&&(c=e.ref,h=K$2.current),e.key!==void 0&&(d=""+e.key),a.type&&a.type.defaultProps)var _=a.type.defaultProps;for(bt in e)J.call(e,bt)&&!L$1.hasOwnProperty(bt)&&(s[bt]=e[bt]===void 0&&_!==void 0?_[bt]:e[bt])}var bt=arguments.length-2;if(bt===1)s.children=o;else if(1<bt){_=Array(bt);for(var g=0;g<bt;g++)_[g]=arguments[g+2];s.children=_}return{$$typeof:l$1,type:a.type,key:d,ref:c,props:s,_owner:h}};react_production_min.createContext=function(a){return a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},a.Provider={$$typeof:t,_context:a},a.Consumer=a};react_production_min.createElement=M$2;react_production_min.createFactory=function(a){var e=M$2.bind(null,a);return e.type=a,e};react_production_min.createRef=function(){return{current:null}};react_production_min.forwardRef=function(a){return{$$typeof:v$1,render:a}};react_production_min.isValidElement=O$2;react_production_min.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T$1}};react_production_min.memo=function(a,e){return{$$typeof:x$1,type:a,compare:e===void 0?null:e}};react_production_min.startTransition=function(a){var e=V$1.transition;V$1.transition={};try{a()}finally{V$1.transition=e}};react_production_min.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")};react_production_min.useCallback=function(a,e){return U$2.current.useCallback(a,e)};react_production_min.useContext=function(a){return U$2.current.useContext(a)};react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(a){return U$2.current.useDeferredValue(a)};react_production_min.useEffect=function(a,e){return U$2.current.useEffect(a,e)};react_production_min.useId=function(){return U$2.current.useId()};react_production_min.useImperativeHandle=function(a,e,o){return U$2.current.useImperativeHandle(a,e,o)};react_production_min.useInsertionEffect=function(a,e){return U$2.current.useInsertionEffect(a,e)};react_production_min.useLayoutEffect=function(a,e){return U$2.current.useLayoutEffect(a,e)};react_production_min.useMemo=function(a,e){return U$2.current.useMemo(a,e)};react_production_min.useReducer=function(a,e,o){return U$2.current.useReducer(a,e,o)};react_production_min.useRef=function(a){return U$2.current.useRef(a)};react_production_min.useState=function(a){return U$2.current.useState(a)};react_production_min.useSyncExternalStore=function(a,e,o){return U$2.current.useSyncExternalStore(a,e,o)};react_production_min.useTransition=function(){return U$2.current.useTransition()};react_production_min.version="18.2.0";react.exports=react_production_min;var reactExports=react.exports;const React=getDefaultExportFromCjs(reactExports);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var f=reactExports,k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m$1=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p$1={key:!0,ref:!0,__self:!0,__source:!0};function q$2(a,e,o){var s,d={},c=null,h=null;o!==void 0&&(c=""+o),e.key!==void 0&&(c=""+e.key),e.ref!==void 0&&(h=e.ref);for(s in e)m$1.call(e,s)&&!p$1.hasOwnProperty(s)&&(d[s]=e[s]);if(a&&a.defaultProps)for(s in e=a.defaultProps,e)d[s]===void 0&&(d[s]=e[s]);return{$$typeof:k,type:a,key:c,ref:h,props:d,_owner:n.current}}reactJsxRuntime_production_min.Fragment=l;reactJsxRuntime_production_min.jsx=q$2;reactJsxRuntime_production_min.jsxs=q$2;jsxRuntime.exports=reactJsxRuntime_production_min;var jsxRuntimeExports=jsxRuntime.exports,client={},reactDom={exports:{}},reactDom_production_min={},scheduler$1={exports:{}},scheduler_production_min$1={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(a){function e(w0,L0){var k0=w0.length;w0.push(L0);e:for(;0<k0;){var T0=k0-1>>>1,q0=w0[T0];if(0<d(q0,L0))w0[T0]=L0,w0[k0]=q0,k0=T0;else break e}}function o(w0){return w0.length===0?null:w0[0]}function s(w0){if(w0.length===0)return null;var L0=w0[0],k0=w0.pop();if(k0!==L0){w0[0]=k0;e:for(var T0=0,q0=w0.length,vy=q0>>>1;T0<vy;){var J0=2*(T0+1)-1,cy=w0[J0],Ty=J0+1,Uy=w0[Ty];if(0>d(cy,k0))Ty<q0&&0>d(Uy,cy)?(w0[T0]=Uy,w0[Ty]=k0,T0=Ty):(w0[T0]=cy,w0[J0]=k0,T0=J0);else if(Ty<q0&&0>d(Uy,k0))w0[T0]=Uy,w0[Ty]=k0,T0=Ty;else break e}}return L0}function d(w0,L0){var k0=w0.sortIndex-L0.sortIndex;return k0!==0?k0:w0.id-L0.id}if(typeof performance=="object"&&typeof performance.now=="function"){var c=performance;a.unstable_now=function(){return c.now()}}else{var h=Date,_=h.now();a.unstable_now=function(){return h.now()-_}}var bt=[],g=[],j=1,b=null,Et=3,It=!1,zt=!1,er=!1,Hn=typeof setTimeout=="function"?setTimeout:null,Qt=typeof clearTimeout=="function"?clearTimeout:null,cr=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function fr(w0){for(var L0=o(g);L0!==null;){if(L0.callback===null)s(g);else if(L0.startTime<=w0)s(g),L0.sortIndex=L0.expirationTime,e(bt,L0);else break;L0=o(g)}}function jr(w0){if(er=!1,fr(w0),!zt)if(o(bt)!==null)zt=!0,H0(e0);else{var L0=o(g);L0!==null&&ty(jr,L0.startTime-w0)}}function e0(w0,L0){zt=!1,er&&(er=!1,Qt(l0),l0=-1),It=!0;var k0=Et;try{for(fr(L0),b=o(bt);b!==null&&(!(b.expirationTime>L0)||w0&&!f0());){var T0=b.callback;if(typeof T0=="function"){b.callback=null,Et=b.priorityLevel;var q0=T0(b.expirationTime<=L0);L0=a.unstable_now(),typeof q0=="function"?b.callback=q0:b===o(bt)&&s(bt),fr(L0)}else s(bt);b=o(bt)}if(b!==null)var vy=!0;else{var J0=o(g);J0!==null&&ty(jr,J0.startTime-L0),vy=!1}return vy}finally{b=null,Et=k0,It=!1}}var t0=!1,o0=null,l0=-1,g0=5,i0=-1;function f0(){return!(a.unstable_now()-i0<g0)}function C0(){if(o0!==null){var w0=a.unstable_now();i0=w0;var L0=!0;try{L0=o0(!0,w0)}finally{L0?Z0():(t0=!1,o0=null)}}else t0=!1}var Z0;if(typeof cr=="function")Z0=function(){cr(C0)};else if(typeof MessageChannel<"u"){var R0=new MessageChannel,Y0=R0.port2;R0.port1.onmessage=C0,Z0=function(){Y0.postMessage(null)}}else Z0=function(){Hn(C0,0)};function H0(w0){o0=w0,t0||(t0=!0,Z0())}function ty(w0,L0){l0=Hn(function(){w0(a.unstable_now())},L0)}a.unstable_IdlePriority=5,a.unstable_ImmediatePriority=1,a.unstable_LowPriority=4,a.unstable_NormalPriority=3,a.unstable_Profiling=null,a.unstable_UserBlockingPriority=2,a.unstable_cancelCallback=function(w0){w0.callback=null},a.unstable_continueExecution=function(){zt||It||(zt=!0,H0(e0))},a.unstable_forceFrameRate=function(w0){0>w0||125<w0?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):g0=0<w0?Math.floor(1e3/w0):5},a.unstable_getCurrentPriorityLevel=function(){return Et},a.unstable_getFirstCallbackNode=function(){return o(bt)},a.unstable_next=function(w0){switch(Et){case 1:case 2:case 3:var L0=3;break;default:L0=Et}var k0=Et;Et=L0;try{return w0()}finally{Et=k0}},a.unstable_pauseExecution=function(){},a.unstable_requestPaint=function(){},a.unstable_runWithPriority=function(w0,L0){switch(w0){case 1:case 2:case 3:case 4:case 5:break;default:w0=3}var k0=Et;Et=w0;try{return L0()}finally{Et=k0}},a.unstable_scheduleCallback=function(w0,L0,k0){var T0=a.unstable_now();switch(typeof k0=="object"&&k0!==null?(k0=k0.delay,k0=typeof k0=="number"&&0<k0?T0+k0:T0):k0=T0,w0){case 1:var q0=-1;break;case 2:q0=250;break;case 5:q0=1073741823;break;case 4:q0=1e4;break;default:q0=5e3}return q0=k0+q0,w0={id:j++,callback:L0,priorityLevel:w0,startTime:k0,expirationTime:q0,sortIndex:-1},k0>T0?(w0.sortIndex=k0,e(g,w0),o(bt)===null&&w0===o(g)&&(er?(Qt(l0),l0=-1):er=!0,ty(jr,k0-T0))):(w0.sortIndex=q0,e(bt,w0),zt||It||(zt=!0,H0(e0))),w0},a.unstable_shouldYield=f0,a.unstable_wrapCallback=function(w0){var L0=Et;return function(){var k0=Et;Et=L0;try{return w0.apply(this,arguments)}finally{Et=k0}}}})(scheduler_production_min$1);scheduler$1.exports=scheduler_production_min$1;var schedulerExports$1=scheduler$1.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var aa$2=reactExports,ca$2=schedulerExports$1;function p(a){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+a,o=1;o<arguments.length;o++)e+="&args[]="+encodeURIComponent(arguments[o]);return"Minified React error #"+a+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da$2=new Set,ea$1={};function fa$2(a,e){ha$2(a,e),ha$2(a+"Capture",e)}function ha$2(a,e){for(ea$1[a]=e,a=0;a<e.length;a++)da$2.add(e[a])}var ia$1=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),ja$1=Object.prototype.hasOwnProperty,ka$1=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la$2={},ma$2={};function oa$1(a){return ja$1.call(ma$2,a)?!0:ja$1.call(la$2,a)?!1:ka$1.test(a)?ma$2[a]=!0:(la$2[a]=!0,!1)}function pa$2(a,e,o,s){if(o!==null&&o.type===0)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return s?!1:o!==null?!o.acceptsBooleans:(a=a.toLowerCase().slice(0,5),a!=="data-"&&a!=="aria-");default:return!1}}function qa$1(a,e,o,s){if(e===null||typeof e>"u"||pa$2(a,e,o,s))return!0;if(s)return!1;if(o!==null)switch(o.type){case 3:return!e;case 4:return e===!1;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}function v(a,e,o,s,d,c,h){this.acceptsBooleans=e===2||e===3||e===4,this.attributeName=s,this.attributeNamespace=d,this.mustUseProperty=o,this.propertyName=a,this.type=e,this.sanitizeURL=c,this.removeEmptyString=h}var z$1={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){z$1[a]=new v(a,0,!1,a,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var e=a[0];z$1[e]=new v(e,1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){z$1[a]=new v(a,2,!1,a.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){z$1[a]=new v(a,2,!1,a,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){z$1[a]=new v(a,3,!1,a.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(a){z$1[a]=new v(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){z$1[a]=new v(a,4,!1,a,null,!1,!1)});["cols","rows","size","span"].forEach(function(a){z$1[a]=new v(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){z$1[a]=new v(a,5,!1,a.toLowerCase(),null,!1,!1)});var ra$2=/[\-:]([a-z])/g;function sa$2(a){return a[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var e=a.replace(ra$2,sa$2);z$1[e]=new v(e,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var e=a.replace(ra$2,sa$2);z$1[e]=new v(e,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var e=a.replace(ra$2,sa$2);z$1[e]=new v(e,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){z$1[a]=new v(a,1,!1,a.toLowerCase(),null,!1,!1)});z$1.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){z$1[a]=new v(a,1,!1,a.toLowerCase(),null,!0,!0)});function ta$1(a,e,o,s){var d=z$1.hasOwnProperty(e)?z$1[e]:null;(d!==null?d.type!==0:s||!(2<e.length)||e[0]!=="o"&&e[0]!=="O"||e[1]!=="n"&&e[1]!=="N")&&(qa$1(e,o,d,s)&&(o=null),s||d===null?oa$1(e)&&(o===null?a.removeAttribute(e):a.setAttribute(e,""+o)):d.mustUseProperty?a[d.propertyName]=o===null?d.type===3?!1:"":o:(e=d.attributeName,s=d.attributeNamespace,o===null?a.removeAttribute(e):(d=d.type,o=d===3||d===4&&o===!0?"":""+o,s?a.setAttributeNS(s,e,o):a.setAttribute(e,o))))}var ua$2=aa$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va$1=Symbol.for("react.element"),wa$1=Symbol.for("react.portal"),ya$1=Symbol.for("react.fragment"),za$1=Symbol.for("react.strict_mode"),Aa$1=Symbol.for("react.profiler"),Ba$1=Symbol.for("react.provider"),Ca$1=Symbol.for("react.context"),Da$1=Symbol.for("react.forward_ref"),Ea$1=Symbol.for("react.suspense"),Fa=Symbol.for("react.suspense_list"),Ga=Symbol.for("react.memo"),Ha$1=Symbol.for("react.lazy"),Ia$1=Symbol.for("react.offscreen"),Ja$1=Symbol.iterator;function Ka$1(a){return a===null||typeof a!="object"?null:(a=Ja$1&&a[Ja$1]||a["@@iterator"],typeof a=="function"?a:null)}var A=Object.assign,La;function Ma$1(a){if(La===void 0)try{throw Error()}catch(o){var e=o.stack.trim().match(/\n( *(at )?)/);La=e&&e[1]||""}return`
`+La+a}var Na=!1;function Oa$1(a,e){if(!a||Na)return"";Na=!0;var o=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(e,[])}catch(g){var s=g}Reflect.construct(a,[],e)}else{try{e.call()}catch(g){s=g}a.call(e.prototype)}else{try{throw Error()}catch(g){s=g}a()}}catch(g){if(g&&s&&typeof g.stack=="string"){for(var d=g.stack.split(`
`),c=s.stack.split(`
`),h=d.length-1,_=c.length-1;1<=h&&0<=_&&d[h]!==c[_];)_--;for(;1<=h&&0<=_;h--,_--)if(d[h]!==c[_]){if(h!==1||_!==1)do if(h--,_--,0>_||d[h]!==c[_]){var bt=`
`+d[h].replace(" at new "," at ");return a.displayName&&bt.includes("<anonymous>")&&(bt=bt.replace("<anonymous>",a.displayName)),bt}while(1<=h&&0<=_);break}}}finally{Na=!1,Error.prepareStackTrace=o}return(a=a?a.displayName||a.name:"")?Ma$1(a):""}function Pa$1(a){switch(a.tag){case 5:return Ma$1(a.type);case 16:return Ma$1("Lazy");case 13:return Ma$1("Suspense");case 19:return Ma$1("SuspenseList");case 0:case 2:case 15:return a=Oa$1(a.type,!1),a;case 11:return a=Oa$1(a.type.render,!1),a;case 1:return a=Oa$1(a.type,!0),a;default:return""}}function Qa$1(a){if(a==null)return null;if(typeof a=="function")return a.displayName||a.name||null;if(typeof a=="string")return a;switch(a){case ya$1:return"Fragment";case wa$1:return"Portal";case Aa$1:return"Profiler";case za$1:return"StrictMode";case Ea$1:return"Suspense";case Fa:return"SuspenseList"}if(typeof a=="object")switch(a.$$typeof){case Ca$1:return(a.displayName||"Context")+".Consumer";case Ba$1:return(a._context.displayName||"Context")+".Provider";case Da$1:var e=a.render;return a=a.displayName,a||(a=e.displayName||e.name||"",a=a!==""?"ForwardRef("+a+")":"ForwardRef"),a;case Ga:return e=a.displayName||null,e!==null?e:Qa$1(a.type)||"Memo";case Ha$1:e=a._payload,a=a._init;try{return Qa$1(a(e))}catch{}}return null}function Ra$1(a){var e=a.type;switch(a.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return a=e.render,a=a.displayName||a.name||"",e.displayName||(a!==""?"ForwardRef("+a+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Qa$1(e);case 8:return e===za$1?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e}return null}function Sa$1(a){switch(typeof a){case"boolean":case"number":case"string":case"undefined":return a;case"object":return a;default:return""}}function Ta$1(a){var e=a.type;return(a=a.nodeName)&&a.toLowerCase()==="input"&&(e==="checkbox"||e==="radio")}function Ua(a){var e=Ta$1(a)?"checked":"value",o=Object.getOwnPropertyDescriptor(a.constructor.prototype,e),s=""+a[e];if(!a.hasOwnProperty(e)&&typeof o<"u"&&typeof o.get=="function"&&typeof o.set=="function"){var d=o.get,c=o.set;return Object.defineProperty(a,e,{configurable:!0,get:function(){return d.call(this)},set:function(h){s=""+h,c.call(this,h)}}),Object.defineProperty(a,e,{enumerable:o.enumerable}),{getValue:function(){return s},setValue:function(h){s=""+h},stopTracking:function(){a._valueTracker=null,delete a[e]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var e=a._valueTracker;if(!e)return!0;var o=e.getValue(),s="";return a&&(s=Ta$1(a)?a.checked?"true":"false":a.value),a=s,a!==o?(e.setValue(a),!0):!1}function Xa$1(a){if(a=a||(typeof document<"u"?document:void 0),typeof a>"u")return null;try{return a.activeElement||a.body}catch{return a.body}}function Ya$1(a,e){var o=e.checked;return A({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:o??a._wrapperState.initialChecked})}function Za$1(a,e){var o=e.defaultValue==null?"":e.defaultValue,s=e.checked!=null?e.checked:e.defaultChecked;o=Sa$1(e.value!=null?e.value:o),a._wrapperState={initialChecked:s,initialValue:o,controlled:e.type==="checkbox"||e.type==="radio"?e.checked!=null:e.value!=null}}function ab$1(a,e){e=e.checked,e!=null&&ta$1(a,"checked",e,!1)}function bb$1(a,e){ab$1(a,e);var o=Sa$1(e.value),s=e.type;if(o!=null)s==="number"?(o===0&&a.value===""||a.value!=o)&&(a.value=""+o):a.value!==""+o&&(a.value=""+o);else if(s==="submit"||s==="reset"){a.removeAttribute("value");return}e.hasOwnProperty("value")?cb$1(a,e.type,o):e.hasOwnProperty("defaultValue")&&cb$1(a,e.type,Sa$1(e.defaultValue)),e.checked==null&&e.defaultChecked!=null&&(a.defaultChecked=!!e.defaultChecked)}function db$1(a,e,o){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var s=e.type;if(!(s!=="submit"&&s!=="reset"||e.value!==void 0&&e.value!==null))return;e=""+a._wrapperState.initialValue,o||e===a.value||(a.value=e),a.defaultValue=e}o=a.name,o!==""&&(a.name=""),a.defaultChecked=!!a._wrapperState.initialChecked,o!==""&&(a.name=o)}function cb$1(a,e,o){(e!=="number"||Xa$1(a.ownerDocument)!==a)&&(o==null?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+o&&(a.defaultValue=""+o))}var eb$1=Array.isArray;function fb$1(a,e,o,s){if(a=a.options,e){e={};for(var d=0;d<o.length;d++)e["$"+o[d]]=!0;for(o=0;o<a.length;o++)d=e.hasOwnProperty("$"+a[o].value),a[o].selected!==d&&(a[o].selected=d),d&&s&&(a[o].defaultSelected=!0)}else{for(o=""+Sa$1(o),e=null,d=0;d<a.length;d++){if(a[d].value===o){a[d].selected=!0,s&&(a[d].defaultSelected=!0);return}e!==null||a[d].disabled||(e=a[d])}e!==null&&(e.selected=!0)}}function gb$1(a,e){if(e.dangerouslySetInnerHTML!=null)throw Error(p(91));return A({},e,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function hb$1(a,e){var o=e.value;if(o==null){if(o=e.children,e=e.defaultValue,o!=null){if(e!=null)throw Error(p(92));if(eb$1(o)){if(1<o.length)throw Error(p(93));o=o[0]}e=o}e==null&&(e=""),o=e}a._wrapperState={initialValue:Sa$1(o)}}function ib$1(a,e){var o=Sa$1(e.value),s=Sa$1(e.defaultValue);o!=null&&(o=""+o,o!==a.value&&(a.value=o),e.defaultValue==null&&a.defaultValue!==o&&(a.defaultValue=o)),s!=null&&(a.defaultValue=""+s)}function jb$1(a){var e=a.textContent;e===a._wrapperState.initialValue&&e!==""&&e!==null&&(a.value=e)}function kb$1(a){switch(a){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function lb$1(a,e){return a==null||a==="http://www.w3.org/1999/xhtml"?kb$1(e):a==="http://www.w3.org/2000/svg"&&e==="foreignObject"?"http://www.w3.org/1999/xhtml":a}var mb$1,nb$1=function(a){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(e,o,s,d){MSApp.execUnsafeLocalFunction(function(){return a(e,o,s,d)})}:a}(function(a,e){if(a.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in a)a.innerHTML=e;else{for(mb$1=mb$1||document.createElement("div"),mb$1.innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=mb$1.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;e.firstChild;)a.appendChild(e.firstChild)}});function ob$1(a,e){if(e){var o=a.firstChild;if(o&&o===a.lastChild&&o.nodeType===3){o.nodeValue=e;return}}a.textContent=e}var pb$1={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb$1=["Webkit","ms","Moz","O"];Object.keys(pb$1).forEach(function(a){qb$1.forEach(function(e){e=e+a.charAt(0).toUpperCase()+a.substring(1),pb$1[e]=pb$1[a]})});function rb$1(a,e,o){return e==null||typeof e=="boolean"||e===""?"":o||typeof e!="number"||e===0||pb$1.hasOwnProperty(a)&&pb$1[a]?(""+e).trim():e+"px"}function sb$1(a,e){a=a.style;for(var o in e)if(e.hasOwnProperty(o)){var s=o.indexOf("--")===0,d=rb$1(o,e[o],s);o==="float"&&(o="cssFloat"),s?a.setProperty(o,d):a[o]=d}}var tb$1=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ub$1(a,e){if(e){if(tb$1[a]&&(e.children!=null||e.dangerouslySetInnerHTML!=null))throw Error(p(137,a));if(e.dangerouslySetInnerHTML!=null){if(e.children!=null)throw Error(p(60));if(typeof e.dangerouslySetInnerHTML!="object"||!("__html"in e.dangerouslySetInnerHTML))throw Error(p(61))}if(e.style!=null&&typeof e.style!="object")throw Error(p(62))}}function vb$1(a,e){if(a.indexOf("-")===-1)return typeof e.is=="string";switch(a){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var wb$1=null;function xb$1(a){return a=a.target||a.srcElement||window,a.correspondingUseElement&&(a=a.correspondingUseElement),a.nodeType===3?a.parentNode:a}var yb$1=null,zb$1=null,Ab$1=null;function Bb$1(a){if(a=Cb$1(a)){if(typeof yb$1!="function")throw Error(p(280));var e=a.stateNode;e&&(e=Db$1(e),yb$1(a.stateNode,a.type,e))}}function Eb$1(a){zb$1?Ab$1?Ab$1.push(a):Ab$1=[a]:zb$1=a}function Fb$1(){if(zb$1){var a=zb$1,e=Ab$1;if(Ab$1=zb$1=null,Bb$1(a),e)for(a=0;a<e.length;a++)Bb$1(e[a])}}function Gb$1(a,e){return a(e)}function Hb$1(){}var Ib$1=!1;function Jb$1(a,e,o){if(Ib$1)return a(e,o);Ib$1=!0;try{return Gb$1(a,e,o)}finally{Ib$1=!1,(zb$1!==null||Ab$1!==null)&&(Hb$1(),Fb$1())}}function Kb$1(a,e){var o=a.stateNode;if(o===null)return null;var s=Db$1(o);if(s===null)return null;o=s[e];e:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(s=!s.disabled)||(a=a.type,s=!(a==="button"||a==="input"||a==="select"||a==="textarea")),a=!s;break e;default:a=!1}if(a)return null;if(o&&typeof o!="function")throw Error(p(231,e,typeof o));return o}var Lb$1=!1;if(ia$1)try{var Mb$1={};Object.defineProperty(Mb$1,"passive",{get:function(){Lb$1=!0}}),window.addEventListener("test",Mb$1,Mb$1),window.removeEventListener("test",Mb$1,Mb$1)}catch{Lb$1=!1}function Nb$1(a,e,o,s,d,c,h,_,bt){var g=Array.prototype.slice.call(arguments,3);try{e.apply(o,g)}catch(j){this.onError(j)}}var Ob$1=!1,Pb$1=null,Qb$1=!1,Rb$1=null,Sb$1={onError:function(a){Ob$1=!0,Pb$1=a}};function Tb$1(a,e,o,s,d,c,h,_,bt){Ob$1=!1,Pb$1=null,Nb$1.apply(Sb$1,arguments)}function Ub$1(a,e,o,s,d,c,h,_,bt){if(Tb$1.apply(this,arguments),Ob$1){if(Ob$1){var g=Pb$1;Ob$1=!1,Pb$1=null}else throw Error(p(198));Qb$1||(Qb$1=!0,Rb$1=g)}}function Vb$1(a){var e=a,o=a;if(a.alternate)for(;e.return;)e=e.return;else{a=e;do e=a,e.flags&4098&&(o=e.return),a=e.return;while(a)}return e.tag===3?o:null}function Wb$1(a){if(a.tag===13){var e=a.memoizedState;if(e===null&&(a=a.alternate,a!==null&&(e=a.memoizedState)),e!==null)return e.dehydrated}return null}function Xb$1(a){if(Vb$1(a)!==a)throw Error(p(188))}function Yb$1(a){var e=a.alternate;if(!e){if(e=Vb$1(a),e===null)throw Error(p(188));return e!==a?null:a}for(var o=a,s=e;;){var d=o.return;if(d===null)break;var c=d.alternate;if(c===null){if(s=d.return,s!==null){o=s;continue}break}if(d.child===c.child){for(c=d.child;c;){if(c===o)return Xb$1(d),a;if(c===s)return Xb$1(d),e;c=c.sibling}throw Error(p(188))}if(o.return!==s.return)o=d,s=c;else{for(var h=!1,_=d.child;_;){if(_===o){h=!0,o=d,s=c;break}if(_===s){h=!0,s=d,o=c;break}_=_.sibling}if(!h){for(_=c.child;_;){if(_===o){h=!0,o=c,s=d;break}if(_===s){h=!0,s=c,o=d;break}_=_.sibling}if(!h)throw Error(p(189))}}if(o.alternate!==s)throw Error(p(190))}if(o.tag!==3)throw Error(p(188));return o.stateNode.current===o?a:e}function Zb$1(a){return a=Yb$1(a),a!==null?$b$1(a):null}function $b$1(a){if(a.tag===5||a.tag===6)return a;for(a=a.child;a!==null;){var e=$b$1(a);if(e!==null)return e;a=a.sibling}return null}var ac$2=ca$2.unstable_scheduleCallback,bc$2=ca$2.unstable_cancelCallback,cc$2=ca$2.unstable_shouldYield,dc$2=ca$2.unstable_requestPaint,B=ca$2.unstable_now,ec$2=ca$2.unstable_getCurrentPriorityLevel,fc$2=ca$2.unstable_ImmediatePriority,gc$2=ca$2.unstable_UserBlockingPriority,hc$2=ca$2.unstable_NormalPriority,ic$2=ca$2.unstable_LowPriority,jc$2=ca$2.unstable_IdlePriority,kc$2=null,lc$2=null;function mc$2(a){if(lc$2&&typeof lc$2.onCommitFiberRoot=="function")try{lc$2.onCommitFiberRoot(kc$2,a,void 0,(a.current.flags&128)===128)}catch{}}var oc$2=Math.clz32?Math.clz32:nc$2,pc$2=Math.log,qc$2=Math.LN2;function nc$2(a){return a>>>=0,a===0?32:31-(pc$2(a)/qc$2|0)|0}var rc$2=64,sc$2=4194304;function tc$2(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return a}}function uc$2(a,e){var o=a.pendingLanes;if(o===0)return 0;var s=0,d=a.suspendedLanes,c=a.pingedLanes,h=o&268435455;if(h!==0){var _=h&~d;_!==0?s=tc$2(_):(c&=h,c!==0&&(s=tc$2(c)))}else h=o&~d,h!==0?s=tc$2(h):c!==0&&(s=tc$2(c));if(s===0)return 0;if(e!==0&&e!==s&&!(e&d)&&(d=s&-s,c=e&-e,d>=c||d===16&&(c&4194240)!==0))return e;if(s&4&&(s|=o&16),e=a.entangledLanes,e!==0)for(a=a.entanglements,e&=s;0<e;)o=31-oc$2(e),d=1<<o,s|=a[o],e&=~d;return s}function vc$1(a,e){switch(a){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function wc$2(a,e){for(var o=a.suspendedLanes,s=a.pingedLanes,d=a.expirationTimes,c=a.pendingLanes;0<c;){var h=31-oc$2(c),_=1<<h,bt=d[h];bt===-1?(!(_&o)||_&s)&&(d[h]=vc$1(_,e)):bt<=e&&(a.expiredLanes|=_),c&=~_}}function xc$2(a){return a=a.pendingLanes&-1073741825,a!==0?a:a&1073741824?1073741824:0}function yc$2(){var a=rc$2;return rc$2<<=1,!(rc$2&4194240)&&(rc$2=64),a}function zc$2(a){for(var e=[],o=0;31>o;o++)e.push(a);return e}function Ac$2(a,e,o){a.pendingLanes|=e,e!==536870912&&(a.suspendedLanes=0,a.pingedLanes=0),a=a.eventTimes,e=31-oc$2(e),a[e]=o}function Bc$2(a,e){var o=a.pendingLanes&~e;a.pendingLanes=e,a.suspendedLanes=0,a.pingedLanes=0,a.expiredLanes&=e,a.mutableReadLanes&=e,a.entangledLanes&=e,e=a.entanglements;var s=a.eventTimes;for(a=a.expirationTimes;0<o;){var d=31-oc$2(o),c=1<<d;e[d]=0,s[d]=-1,a[d]=-1,o&=~c}}function Cc$2(a,e){var o=a.entangledLanes|=e;for(a=a.entanglements;o;){var s=31-oc$2(o),d=1<<s;d&e|a[s]&e&&(a[s]|=e),o&=~d}}var C=0;function Dc$2(a){return a&=-a,1<a?4<a?a&268435455?16:536870912:4:1}var Ec$2,Fc$2,Gc$2,Hc$2,Ic$2,Jc$2=!1,Kc$2=[],Lc$2=null,Mc$2=null,Nc$2=null,Oc$2=new Map,Pc$2=new Map,Qc$2=[],Rc$2="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Sc$2(a,e){switch(a){case"focusin":case"focusout":Lc$2=null;break;case"dragenter":case"dragleave":Mc$2=null;break;case"mouseover":case"mouseout":Nc$2=null;break;case"pointerover":case"pointerout":Oc$2.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":Pc$2.delete(e.pointerId)}}function Tc$2(a,e,o,s,d,c){return a===null||a.nativeEvent!==c?(a={blockedOn:e,domEventName:o,eventSystemFlags:s,nativeEvent:c,targetContainers:[d]},e!==null&&(e=Cb$1(e),e!==null&&Fc$2(e)),a):(a.eventSystemFlags|=s,e=a.targetContainers,d!==null&&e.indexOf(d)===-1&&e.push(d),a)}function Uc$2(a,e,o,s,d){switch(e){case"focusin":return Lc$2=Tc$2(Lc$2,a,e,o,s,d),!0;case"dragenter":return Mc$2=Tc$2(Mc$2,a,e,o,s,d),!0;case"mouseover":return Nc$2=Tc$2(Nc$2,a,e,o,s,d),!0;case"pointerover":var c=d.pointerId;return Oc$2.set(c,Tc$2(Oc$2.get(c)||null,a,e,o,s,d)),!0;case"gotpointercapture":return c=d.pointerId,Pc$2.set(c,Tc$2(Pc$2.get(c)||null,a,e,o,s,d)),!0}return!1}function Vc$2(a){var e=Wc$2(a.target);if(e!==null){var o=Vb$1(e);if(o!==null){if(e=o.tag,e===13){if(e=Wb$1(o),e!==null){a.blockedOn=e,Ic$2(a.priority,function(){Gc$2(o)});return}}else if(e===3&&o.stateNode.current.memoizedState.isDehydrated){a.blockedOn=o.tag===3?o.stateNode.containerInfo:null;return}}}a.blockedOn=null}function Xc$2(a){if(a.blockedOn!==null)return!1;for(var e=a.targetContainers;0<e.length;){var o=Yc$2(a.domEventName,a.eventSystemFlags,e[0],a.nativeEvent);if(o===null){o=a.nativeEvent;var s=new o.constructor(o.type,o);wb$1=s,o.target.dispatchEvent(s),wb$1=null}else return e=Cb$1(o),e!==null&&Fc$2(e),a.blockedOn=o,!1;e.shift()}return!0}function Zc$2(a,e,o){Xc$2(a)&&o.delete(e)}function $c$2(){Jc$2=!1,Lc$2!==null&&Xc$2(Lc$2)&&(Lc$2=null),Mc$2!==null&&Xc$2(Mc$2)&&(Mc$2=null),Nc$2!==null&&Xc$2(Nc$2)&&(Nc$2=null),Oc$2.forEach(Zc$2),Pc$2.forEach(Zc$2)}function ad$1(a,e){a.blockedOn===e&&(a.blockedOn=null,Jc$2||(Jc$2=!0,ca$2.unstable_scheduleCallback(ca$2.unstable_NormalPriority,$c$2)))}function bd$2(a){function e(d){return ad$1(d,a)}if(0<Kc$2.length){ad$1(Kc$2[0],a);for(var o=1;o<Kc$2.length;o++){var s=Kc$2[o];s.blockedOn===a&&(s.blockedOn=null)}}for(Lc$2!==null&&ad$1(Lc$2,a),Mc$2!==null&&ad$1(Mc$2,a),Nc$2!==null&&ad$1(Nc$2,a),Oc$2.forEach(e),Pc$2.forEach(e),o=0;o<Qc$2.length;o++)s=Qc$2[o],s.blockedOn===a&&(s.blockedOn=null);for(;0<Qc$2.length&&(o=Qc$2[0],o.blockedOn===null);)Vc$2(o),o.blockedOn===null&&Qc$2.shift()}var cd$2=ua$2.ReactCurrentBatchConfig,dd$2=!0;function ed$1(a,e,o,s){var d=C,c=cd$2.transition;cd$2.transition=null;try{C=1,fd$3(a,e,o,s)}finally{C=d,cd$2.transition=c}}function gd$2(a,e,o,s){var d=C,c=cd$2.transition;cd$2.transition=null;try{C=4,fd$3(a,e,o,s)}finally{C=d,cd$2.transition=c}}function fd$3(a,e,o,s){if(dd$2){var d=Yc$2(a,e,o,s);if(d===null)hd$2(a,e,s,id$1,o),Sc$2(a,s);else if(Uc$2(d,a,e,o,s))s.stopPropagation();else if(Sc$2(a,s),e&4&&-1<Rc$2.indexOf(a)){for(;d!==null;){var c=Cb$1(d);if(c!==null&&Ec$2(c),c=Yc$2(a,e,o,s),c===null&&hd$2(a,e,s,id$1,o),c===d)break;d=c}d!==null&&s.stopPropagation()}else hd$2(a,e,s,null,o)}}var id$1=null;function Yc$2(a,e,o,s){if(id$1=null,a=xb$1(s),a=Wc$2(a),a!==null)if(e=Vb$1(a),e===null)a=null;else if(o=e.tag,o===13){if(a=Wb$1(e),a!==null)return a;a=null}else if(o===3){if(e.stateNode.current.memoizedState.isDehydrated)return e.tag===3?e.stateNode.containerInfo:null;a=null}else e!==a&&(a=null);return id$1=a,null}function jd$2(a){switch(a){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(ec$2()){case fc$2:return 1;case gc$2:return 4;case hc$2:case ic$2:return 16;case jc$2:return 536870912;default:return 16}default:return 16}}var kd$2=null,ld$2=null,md$2=null;function nd$1(){if(md$2)return md$2;var a,e=ld$2,o=e.length,s,d="value"in kd$2?kd$2.value:kd$2.textContent,c=d.length;for(a=0;a<o&&e[a]===d[a];a++);var h=o-a;for(s=1;s<=h&&e[o-s]===d[c-s];s++);return md$2=d.slice(a,1<s?1-s:void 0)}function od$1(a){var e=a.keyCode;return"charCode"in a?(a=a.charCode,a===0&&e===13&&(a=13)):a=e,a===10&&(a=13),32<=a||a===13?a:0}function pd$2(){return!0}function qd$1(){return!1}function rd$1(a){function e(o,s,d,c,h){this._reactName=o,this._targetInst=d,this.type=s,this.nativeEvent=c,this.target=h,this.currentTarget=null;for(var _ in a)a.hasOwnProperty(_)&&(o=a[_],this[_]=o?o(c):c[_]);return this.isDefaultPrevented=(c.defaultPrevented!=null?c.defaultPrevented:c.returnValue===!1)?pd$2:qd$1,this.isPropagationStopped=qd$1,this}return A(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var o=this.nativeEvent;o&&(o.preventDefault?o.preventDefault():typeof o.returnValue!="unknown"&&(o.returnValue=!1),this.isDefaultPrevented=pd$2)},stopPropagation:function(){var o=this.nativeEvent;o&&(o.stopPropagation?o.stopPropagation():typeof o.cancelBubble!="unknown"&&(o.cancelBubble=!0),this.isPropagationStopped=pd$2)},persist:function(){},isPersistent:pd$2}),e}var sd$1={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td$2=rd$1(sd$1),ud$1=A({},sd$1,{view:0,detail:0}),vd$1=rd$1(ud$1),wd$1,xd$1,yd$1,Ad$2=A({},ud$1,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd$1,button:0,buttons:0,relatedTarget:function(a){return a.relatedTarget===void 0?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){return"movementX"in a?a.movementX:(a!==yd$1&&(yd$1&&a.type==="mousemove"?(wd$1=a.screenX-yd$1.screenX,xd$1=a.screenY-yd$1.screenY):xd$1=wd$1=0,yd$1=a),wd$1)},movementY:function(a){return"movementY"in a?a.movementY:xd$1}}),Bd$1=rd$1(Ad$2),Cd$2=A({},Ad$2,{dataTransfer:0}),Dd$2=rd$1(Cd$2),Ed$2=A({},ud$1,{relatedTarget:0}),Fd$2=rd$1(Ed$2),Gd$1=A({},sd$1,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd$1=rd$1(Gd$1),Id$2=A({},sd$1,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Jd$2=rd$1(Id$2),Kd$2=A({},sd$1,{data:0}),Ld$2=rd$1(Kd$2),Md$1={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd$2={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od$2={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd$2(a){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(a):(a=Od$2[a])?!!e[a]:!1}function zd$1(){return Pd$2}var Qd$2=A({},ud$1,{key:function(a){if(a.key){var e=Md$1[a.key]||a.key;if(e!=="Unidentified")return e}return a.type==="keypress"?(a=od$1(a),a===13?"Enter":String.fromCharCode(a)):a.type==="keydown"||a.type==="keyup"?Nd$2[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd$1,charCode:function(a){return a.type==="keypress"?od$1(a):0},keyCode:function(a){return a.type==="keydown"||a.type==="keyup"?a.keyCode:0},which:function(a){return a.type==="keypress"?od$1(a):a.type==="keydown"||a.type==="keyup"?a.keyCode:0}}),Rd$1=rd$1(Qd$2),Sd$2=A({},Ad$2,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td$1=rd$1(Sd$2),Ud$1=A({},ud$1,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd$1}),Vd$1=rd$1(Ud$1),Wd$1=A({},sd$1,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd$2=rd$1(Wd$1),Yd$2=A({},Ad$2,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd$2=rd$1(Yd$2),$d$1=[9,13,27,32],ae$1=ia$1&&"CompositionEvent"in window,be$2=null;ia$1&&"documentMode"in document&&(be$2=document.documentMode);var ce$1=ia$1&&"TextEvent"in window&&!be$2,de=ia$1&&(!ae$1||be$2&&8<be$2&&11>=be$2),ee$1=" ",fe$1=!1;function ge(a,e){switch(a){case"keyup":return $d$1.indexOf(e.keyCode)!==-1;case"keydown":return e.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function he(a){return a=a.detail,typeof a=="object"&&"data"in a?a.data:null}var ie$1=!1;function je$1(a,e){switch(a){case"compositionend":return he(e);case"keypress":return e.which!==32?null:(fe$1=!0,ee$1);case"textInput":return a=e.data,a===ee$1&&fe$1?null:a;default:return null}}function ke$1(a,e){if(ie$1)return a==="compositionend"||!ae$1&&ge(a,e)?(a=nd$1(),md$2=ld$2=kd$2=null,ie$1=!1,a):null;switch(a){case"paste":return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return de&&e.locale!=="ko"?null:e.data;default:return null}}var le$1={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me$1(a){var e=a&&a.nodeName&&a.nodeName.toLowerCase();return e==="input"?!!le$1[a.type]:e==="textarea"}function ne(a,e,o,s){Eb$1(s),e=oe$1(e,"onChange"),0<e.length&&(o=new td$2("onChange","change",null,o,s),a.push({event:o,listeners:e}))}var pe=null,qe=null;function re$2(a){se(a,0)}function te(a){var e=ue(a);if(Wa(e))return a}function ve(a,e){if(a==="change")return e}var we=!1;if(ia$1){var xe$1;if(ia$1){var ye$1="oninput"in document;if(!ye$1){var ze=document.createElement("div");ze.setAttribute("oninput","return;"),ye$1=typeof ze.oninput=="function"}xe$1=ye$1}else xe$1=!1;we=xe$1&&(!document.documentMode||9<document.documentMode)}function Ae$1(){pe&&(pe.detachEvent("onpropertychange",Be$1),qe=pe=null)}function Be$1(a){if(a.propertyName==="value"&&te(qe)){var e=[];ne(e,qe,a,xb$1(a)),Jb$1(re$2,e)}}function Ce$1(a,e,o){a==="focusin"?(Ae$1(),pe=e,qe=o,pe.attachEvent("onpropertychange",Be$1)):a==="focusout"&&Ae$1()}function De$2(a){if(a==="selectionchange"||a==="keyup"||a==="keydown")return te(qe)}function Ee(a,e){if(a==="click")return te(e)}function Fe(a,e){if(a==="input"||a==="change")return te(e)}function Ge$2(a,e){return a===e&&(a!==0||1/a===1/e)||a!==a&&e!==e}var He$1=typeof Object.is=="function"?Object.is:Ge$2;function Ie(a,e){if(He$1(a,e))return!0;if(typeof a!="object"||a===null||typeof e!="object"||e===null)return!1;var o=Object.keys(a),s=Object.keys(e);if(o.length!==s.length)return!1;for(s=0;s<o.length;s++){var d=o[s];if(!ja$1.call(e,d)||!He$1(a[d],e[d]))return!1}return!0}function Je$1(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function Ke$1(a,e){var o=Je$1(a);a=0;for(var s;o;){if(o.nodeType===3){if(s=a+o.textContent.length,a<=e&&s>=e)return{node:o,offset:e-a};a=s}e:{for(;o;){if(o.nextSibling){o=o.nextSibling;break e}o=o.parentNode}o=void 0}o=Je$1(o)}}function Le$1(a,e){return a&&e?a===e?!0:a&&a.nodeType===3?!1:e&&e.nodeType===3?Le$1(a,e.parentNode):"contains"in a?a.contains(e):a.compareDocumentPosition?!!(a.compareDocumentPosition(e)&16):!1:!1}function Me$1(){for(var a=window,e=Xa$1();e instanceof a.HTMLIFrameElement;){try{var o=typeof e.contentWindow.location.href=="string"}catch{o=!1}if(o)a=e.contentWindow;else break;e=Xa$1(a.document)}return e}function Ne(a){var e=a&&a.nodeName&&a.nodeName.toLowerCase();return e&&(e==="input"&&(a.type==="text"||a.type==="search"||a.type==="tel"||a.type==="url"||a.type==="password")||e==="textarea"||a.contentEditable==="true")}function Oe$2(a){var e=Me$1(),o=a.focusedElem,s=a.selectionRange;if(e!==o&&o&&o.ownerDocument&&Le$1(o.ownerDocument.documentElement,o)){if(s!==null&&Ne(o)){if(e=s.start,a=s.end,a===void 0&&(a=e),"selectionStart"in o)o.selectionStart=e,o.selectionEnd=Math.min(a,o.value.length);else if(a=(e=o.ownerDocument||document)&&e.defaultView||window,a.getSelection){a=a.getSelection();var d=o.textContent.length,c=Math.min(s.start,d);s=s.end===void 0?c:Math.min(s.end,d),!a.extend&&c>s&&(d=s,s=c,c=d),d=Ke$1(o,c);var h=Ke$1(o,s);d&&h&&(a.rangeCount!==1||a.anchorNode!==d.node||a.anchorOffset!==d.offset||a.focusNode!==h.node||a.focusOffset!==h.offset)&&(e=e.createRange(),e.setStart(d.node,d.offset),a.removeAllRanges(),c>s?(a.addRange(e),a.extend(h.node,h.offset)):(e.setEnd(h.node,h.offset),a.addRange(e)))}}for(e=[],a=o;a=a.parentNode;)a.nodeType===1&&e.push({element:a,left:a.scrollLeft,top:a.scrollTop});for(typeof o.focus=="function"&&o.focus(),o=0;o<e.length;o++)a=e[o],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}var Pe=ia$1&&"documentMode"in document&&11>=document.documentMode,Qe$1=null,Re$1=null,Se=null,Te=!1;function Ue(a,e,o){var s=o.window===o?o.document:o.nodeType===9?o:o.ownerDocument;Te||Qe$1==null||Qe$1!==Xa$1(s)||(s=Qe$1,"selectionStart"in s&&Ne(s)?s={start:s.selectionStart,end:s.selectionEnd}:(s=(s.ownerDocument&&s.ownerDocument.defaultView||window).getSelection(),s={anchorNode:s.anchorNode,anchorOffset:s.anchorOffset,focusNode:s.focusNode,focusOffset:s.focusOffset}),Se&&Ie(Se,s)||(Se=s,s=oe$1(Re$1,"onSelect"),0<s.length&&(e=new td$2("onSelect","select",null,e,o),a.push({event:e,listeners:s}),e.target=Qe$1)))}function Ve$1(a,e){var o={};return o[a.toLowerCase()]=e.toLowerCase(),o["Webkit"+a]="webkit"+e,o["Moz"+a]="moz"+e,o}var We={animationend:Ve$1("Animation","AnimationEnd"),animationiteration:Ve$1("Animation","AnimationIteration"),animationstart:Ve$1("Animation","AnimationStart"),transitionend:Ve$1("Transition","TransitionEnd")},Xe$2={},Ye$1={};ia$1&&(Ye$1=document.createElement("div").style,"AnimationEvent"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),"TransitionEvent"in window||delete We.transitionend.transition);function Ze$1(a){if(Xe$2[a])return Xe$2[a];if(!We[a])return a;var e=We[a],o;for(o in e)if(e.hasOwnProperty(o)&&o in Ye$1)return Xe$2[a]=e[o];return a}var $e$1=Ze$1("animationend"),af$2=Ze$1("animationiteration"),bf$1=Ze$1("animationstart"),cf$1=Ze$1("transitionend"),df$2=new Map,ef$2="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function ff$2(a,e){df$2.set(a,e),fa$2(e,[a])}for(var gf$2=0;gf$2<ef$2.length;gf$2++){var hf$2=ef$2[gf$2],jf$1=hf$2.toLowerCase(),kf$1=hf$2[0].toUpperCase()+hf$2.slice(1);ff$2(jf$1,"on"+kf$1)}ff$2($e$1,"onAnimationEnd");ff$2(af$2,"onAnimationIteration");ff$2(bf$1,"onAnimationStart");ff$2("dblclick","onDoubleClick");ff$2("focusin","onFocus");ff$2("focusout","onBlur");ff$2(cf$1,"onTransitionEnd");ha$2("onMouseEnter",["mouseout","mouseover"]);ha$2("onMouseLeave",["mouseout","mouseover"]);ha$2("onPointerEnter",["pointerout","pointerover"]);ha$2("onPointerLeave",["pointerout","pointerover"]);fa$2("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa$2("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa$2("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa$2("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa$2("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));fa$2("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf$2="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf$2=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf$2));function nf$2(a,e,o){var s=a.type||"unknown-event";a.currentTarget=o,Ub$1(s,e,void 0,a),a.currentTarget=null}function se(a,e){e=(e&4)!==0;for(var o=0;o<a.length;o++){var s=a[o],d=s.event;s=s.listeners;e:{var c=void 0;if(e)for(var h=s.length-1;0<=h;h--){var _=s[h],bt=_.instance,g=_.currentTarget;if(_=_.listener,bt!==c&&d.isPropagationStopped())break e;nf$2(d,_,g),c=bt}else for(h=0;h<s.length;h++){if(_=s[h],bt=_.instance,g=_.currentTarget,_=_.listener,bt!==c&&d.isPropagationStopped())break e;nf$2(d,_,g),c=bt}}}if(Qb$1)throw a=Rb$1,Qb$1=!1,Rb$1=null,a}function D$1(a,e){var o=e[of$2];o===void 0&&(o=e[of$2]=new Set);var s=a+"__bubble";o.has(s)||(pf$1(e,a,2,!1),o.add(s))}function qf$1(a,e,o){var s=0;e&&(s|=4),pf$1(o,a,s,e)}var rf$2="_reactListening"+Math.random().toString(36).slice(2);function sf$2(a){if(!a[rf$2]){a[rf$2]=!0,da$2.forEach(function(o){o!=="selectionchange"&&(mf$2.has(o)||qf$1(o,!1,a),qf$1(o,!0,a))});var e=a.nodeType===9?a:a.ownerDocument;e===null||e[rf$2]||(e[rf$2]=!0,qf$1("selectionchange",!1,e))}}function pf$1(a,e,o,s){switch(jd$2(e)){case 1:var d=ed$1;break;case 4:d=gd$2;break;default:d=fd$3}o=d.bind(null,e,o,a),d=void 0,!Lb$1||e!=="touchstart"&&e!=="touchmove"&&e!=="wheel"||(d=!0),s?d!==void 0?a.addEventListener(e,o,{capture:!0,passive:d}):a.addEventListener(e,o,!0):d!==void 0?a.addEventListener(e,o,{passive:d}):a.addEventListener(e,o,!1)}function hd$2(a,e,o,s,d){var c=s;if(!(e&1)&&!(e&2)&&s!==null)e:for(;;){if(s===null)return;var h=s.tag;if(h===3||h===4){var _=s.stateNode.containerInfo;if(_===d||_.nodeType===8&&_.parentNode===d)break;if(h===4)for(h=s.return;h!==null;){var bt=h.tag;if((bt===3||bt===4)&&(bt=h.stateNode.containerInfo,bt===d||bt.nodeType===8&&bt.parentNode===d))return;h=h.return}for(;_!==null;){if(h=Wc$2(_),h===null)return;if(bt=h.tag,bt===5||bt===6){s=c=h;continue e}_=_.parentNode}}s=s.return}Jb$1(function(){var g=c,j=xb$1(o),b=[];e:{var Et=df$2.get(a);if(Et!==void 0){var It=td$2,zt=a;switch(a){case"keypress":if(od$1(o)===0)break e;case"keydown":case"keyup":It=Rd$1;break;case"focusin":zt="focus",It=Fd$2;break;case"focusout":zt="blur",It=Fd$2;break;case"beforeblur":case"afterblur":It=Fd$2;break;case"click":if(o.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":It=Bd$1;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":It=Dd$2;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":It=Vd$1;break;case $e$1:case af$2:case bf$1:It=Hd$1;break;case cf$1:It=Xd$2;break;case"scroll":It=vd$1;break;case"wheel":It=Zd$2;break;case"copy":case"cut":case"paste":It=Jd$2;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":It=Td$1}var er=(e&4)!==0,Hn=!er&&a==="scroll",Qt=er?Et!==null?Et+"Capture":null:Et;er=[];for(var cr=g,fr;cr!==null;){fr=cr;var jr=fr.stateNode;if(fr.tag===5&&jr!==null&&(fr=jr,Qt!==null&&(jr=Kb$1(cr,Qt),jr!=null&&er.push(tf$2(cr,jr,fr)))),Hn)break;cr=cr.return}0<er.length&&(Et=new It(Et,zt,null,o,j),b.push({event:Et,listeners:er}))}}if(!(e&7)){e:{if(Et=a==="mouseover"||a==="pointerover",It=a==="mouseout"||a==="pointerout",Et&&o!==wb$1&&(zt=o.relatedTarget||o.fromElement)&&(Wc$2(zt)||zt[uf$2]))break e;if((It||Et)&&(Et=j.window===j?j:(Et=j.ownerDocument)?Et.defaultView||Et.parentWindow:window,It?(zt=o.relatedTarget||o.toElement,It=g,zt=zt?Wc$2(zt):null,zt!==null&&(Hn=Vb$1(zt),zt!==Hn||zt.tag!==5&&zt.tag!==6)&&(zt=null)):(It=null,zt=g),It!==zt)){if(er=Bd$1,jr="onMouseLeave",Qt="onMouseEnter",cr="mouse",(a==="pointerout"||a==="pointerover")&&(er=Td$1,jr="onPointerLeave",Qt="onPointerEnter",cr="pointer"),Hn=It==null?Et:ue(It),fr=zt==null?Et:ue(zt),Et=new er(jr,cr+"leave",It,o,j),Et.target=Hn,Et.relatedTarget=fr,jr=null,Wc$2(j)===g&&(er=new er(Qt,cr+"enter",zt,o,j),er.target=fr,er.relatedTarget=Hn,jr=er),Hn=jr,It&&zt)t:{for(er=It,Qt=zt,cr=0,fr=er;fr;fr=vf$1(fr))cr++;for(fr=0,jr=Qt;jr;jr=vf$1(jr))fr++;for(;0<cr-fr;)er=vf$1(er),cr--;for(;0<fr-cr;)Qt=vf$1(Qt),fr--;for(;cr--;){if(er===Qt||Qt!==null&&er===Qt.alternate)break t;er=vf$1(er),Qt=vf$1(Qt)}er=null}else er=null;It!==null&&wf$1(b,Et,It,er,!1),zt!==null&&Hn!==null&&wf$1(b,Hn,zt,er,!0)}}e:{if(Et=g?ue(g):window,It=Et.nodeName&&Et.nodeName.toLowerCase(),It==="select"||It==="input"&&Et.type==="file")var e0=ve;else if(me$1(Et))if(we)e0=Fe;else{e0=De$2;var t0=Ce$1}else(It=Et.nodeName)&&It.toLowerCase()==="input"&&(Et.type==="checkbox"||Et.type==="radio")&&(e0=Ee);if(e0&&(e0=e0(a,g))){ne(b,e0,o,j);break e}t0&&t0(a,Et,g),a==="focusout"&&(t0=Et._wrapperState)&&t0.controlled&&Et.type==="number"&&cb$1(Et,"number",Et.value)}switch(t0=g?ue(g):window,a){case"focusin":(me$1(t0)||t0.contentEditable==="true")&&(Qe$1=t0,Re$1=g,Se=null);break;case"focusout":Se=Re$1=Qe$1=null;break;case"mousedown":Te=!0;break;case"contextmenu":case"mouseup":case"dragend":Te=!1,Ue(b,o,j);break;case"selectionchange":if(Pe)break;case"keydown":case"keyup":Ue(b,o,j)}var o0;if(ae$1)e:{switch(a){case"compositionstart":var l0="onCompositionStart";break e;case"compositionend":l0="onCompositionEnd";break e;case"compositionupdate":l0="onCompositionUpdate";break e}l0=void 0}else ie$1?ge(a,o)&&(l0="onCompositionEnd"):a==="keydown"&&o.keyCode===229&&(l0="onCompositionStart");l0&&(de&&o.locale!=="ko"&&(ie$1||l0!=="onCompositionStart"?l0==="onCompositionEnd"&&ie$1&&(o0=nd$1()):(kd$2=j,ld$2="value"in kd$2?kd$2.value:kd$2.textContent,ie$1=!0)),t0=oe$1(g,l0),0<t0.length&&(l0=new Ld$2(l0,a,null,o,j),b.push({event:l0,listeners:t0}),o0?l0.data=o0:(o0=he(o),o0!==null&&(l0.data=o0)))),(o0=ce$1?je$1(a,o):ke$1(a,o))&&(g=oe$1(g,"onBeforeInput"),0<g.length&&(j=new Ld$2("onBeforeInput","beforeinput",null,o,j),b.push({event:j,listeners:g}),j.data=o0))}se(b,e)})}function tf$2(a,e,o){return{instance:a,listener:e,currentTarget:o}}function oe$1(a,e){for(var o=e+"Capture",s=[];a!==null;){var d=a,c=d.stateNode;d.tag===5&&c!==null&&(d=c,c=Kb$1(a,o),c!=null&&s.unshift(tf$2(a,c,d)),c=Kb$1(a,e),c!=null&&s.push(tf$2(a,c,d))),a=a.return}return s}function vf$1(a){if(a===null)return null;do a=a.return;while(a&&a.tag!==5);return a||null}function wf$1(a,e,o,s,d){for(var c=e._reactName,h=[];o!==null&&o!==s;){var _=o,bt=_.alternate,g=_.stateNode;if(bt!==null&&bt===s)break;_.tag===5&&g!==null&&(_=g,d?(bt=Kb$1(o,c),bt!=null&&h.unshift(tf$2(o,bt,_))):d||(bt=Kb$1(o,c),bt!=null&&h.push(tf$2(o,bt,_)))),o=o.return}h.length!==0&&a.push({event:e,listeners:h})}var xf$1=/\r\n?/g,yf$1=/\u0000|\uFFFD/g;function zf$1(a){return(typeof a=="string"?a:""+a).replace(xf$1,`
`).replace(yf$1,"")}function Af$1(a,e,o){if(e=zf$1(e),zf$1(a)!==e&&o)throw Error(p(425))}function Bf$1(){}var Cf$1=null,Df$1=null;function Ef$1(a,e){return a==="textarea"||a==="noscript"||typeof e.children=="string"||typeof e.children=="number"||typeof e.dangerouslySetInnerHTML=="object"&&e.dangerouslySetInnerHTML!==null&&e.dangerouslySetInnerHTML.__html!=null}var Ff$1=typeof setTimeout=="function"?setTimeout:void 0,Gf$1=typeof clearTimeout=="function"?clearTimeout:void 0,Hf$1=typeof Promise=="function"?Promise:void 0,Jf$1=typeof queueMicrotask=="function"?queueMicrotask:typeof Hf$1<"u"?function(a){return Hf$1.resolve(null).then(a).catch(If$1)}:Ff$1;function If$1(a){setTimeout(function(){throw a})}function Kf$1(a,e){var o=e,s=0;do{var d=o.nextSibling;if(a.removeChild(o),d&&d.nodeType===8)if(o=d.data,o==="/$"){if(s===0){a.removeChild(d),bd$2(e);return}s--}else o!=="$"&&o!=="$?"&&o!=="$!"||s++;o=d}while(o);bd$2(e)}function Lf$1(a){for(;a!=null;a=a.nextSibling){var e=a.nodeType;if(e===1||e===3)break;if(e===8){if(e=a.data,e==="$"||e==="$!"||e==="$?")break;if(e==="/$")return null}}return a}function Mf$1(a){a=a.previousSibling;for(var e=0;a;){if(a.nodeType===8){var o=a.data;if(o==="$"||o==="$!"||o==="$?"){if(e===0)return a;e--}else o==="/$"&&e++}a=a.previousSibling}return null}var Nf$1=Math.random().toString(36).slice(2),Of$1="__reactFiber$"+Nf$1,Pf$1="__reactProps$"+Nf$1,uf$2="__reactContainer$"+Nf$1,of$2="__reactEvents$"+Nf$1,Qf$1="__reactListeners$"+Nf$1,Rf$1="__reactHandles$"+Nf$1;function Wc$2(a){var e=a[Of$1];if(e)return e;for(var o=a.parentNode;o;){if(e=o[uf$2]||o[Of$1]){if(o=e.alternate,e.child!==null||o!==null&&o.child!==null)for(a=Mf$1(a);a!==null;){if(o=a[Of$1])return o;a=Mf$1(a)}return e}a=o,o=a.parentNode}return null}function Cb$1(a){return a=a[Of$1]||a[uf$2],!a||a.tag!==5&&a.tag!==6&&a.tag!==13&&a.tag!==3?null:a}function ue(a){if(a.tag===5||a.tag===6)return a.stateNode;throw Error(p(33))}function Db$1(a){return a[Pf$1]||null}var Sf$1=[],Tf$1=-1;function Uf$1(a){return{current:a}}function E$1(a){0>Tf$1||(a.current=Sf$1[Tf$1],Sf$1[Tf$1]=null,Tf$1--)}function G(a,e){Tf$1++,Sf$1[Tf$1]=a.current,a.current=e}var Vf$1={},H=Uf$1(Vf$1),Wf$1=Uf$1(!1),Xf$1=Vf$1;function Yf$1(a,e){var o=a.type.contextTypes;if(!o)return Vf$1;var s=a.stateNode;if(s&&s.__reactInternalMemoizedUnmaskedChildContext===e)return s.__reactInternalMemoizedMaskedChildContext;var d={},c;for(c in o)d[c]=e[c];return s&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=d),d}function Zf$1(a){return a=a.childContextTypes,a!=null}function $f$1(){E$1(Wf$1),E$1(H)}function ag$1(a,e,o){if(H.current!==Vf$1)throw Error(p(168));G(H,e),G(Wf$1,o)}function bg$1(a,e,o){var s=a.stateNode;if(e=e.childContextTypes,typeof s.getChildContext!="function")return o;s=s.getChildContext();for(var d in s)if(!(d in e))throw Error(p(108,Ra$1(a)||"Unknown",d));return A({},o,s)}function cg$1(a){return a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Vf$1,Xf$1=H.current,G(H,a),G(Wf$1,Wf$1.current),!0}function dg$1(a,e,o){var s=a.stateNode;if(!s)throw Error(p(169));o?(a=bg$1(a,e,Xf$1),s.__reactInternalMemoizedMergedChildContext=a,E$1(Wf$1),E$1(H),G(H,a)):E$1(Wf$1),G(Wf$1,o)}var eg$1=null,fg$1=!1,gg$1=!1;function hg$1(a){eg$1===null?eg$1=[a]:eg$1.push(a)}function ig$1(a){fg$1=!0,hg$1(a)}function jg(){if(!gg$1&&eg$1!==null){gg$1=!0;var a=0,e=C;try{var o=eg$1;for(C=1;a<o.length;a++){var s=o[a];do s=s(!0);while(s!==null)}eg$1=null,fg$1=!1}catch(d){throw eg$1!==null&&(eg$1=eg$1.slice(a+1)),ac$2(fc$2,jg),d}finally{C=e,gg$1=!1}}return null}var kg=[],lg$1=0,mg$1=null,ng$1=0,og$1=[],pg$1=0,qg=null,rg=1,sg$1="";function tg$1(a,e){kg[lg$1++]=ng$1,kg[lg$1++]=mg$1,mg$1=a,ng$1=e}function ug(a,e,o){og$1[pg$1++]=rg,og$1[pg$1++]=sg$1,og$1[pg$1++]=qg,qg=a;var s=rg;a=sg$1;var d=32-oc$2(s)-1;s&=~(1<<d),o+=1;var c=32-oc$2(e)+d;if(30<c){var h=d-d%5;c=(s&(1<<h)-1).toString(32),s>>=h,d-=h,rg=1<<32-oc$2(e)+d|o<<d|s,sg$1=c+a}else rg=1<<c|o<<d|s,sg$1=a}function vg$1(a){a.return!==null&&(tg$1(a,1),ug(a,1,0))}function wg$1(a){for(;a===mg$1;)mg$1=kg[--lg$1],kg[lg$1]=null,ng$1=kg[--lg$1],kg[lg$1]=null;for(;a===qg;)qg=og$1[--pg$1],og$1[pg$1]=null,sg$1=og$1[--pg$1],og$1[pg$1]=null,rg=og$1[--pg$1],og$1[pg$1]=null}var xg=null,yg$1=null,I=!1,zg=null;function Ag(a,e){var o=Bg(5,null,null,0);o.elementType="DELETED",o.stateNode=e,o.return=a,e=a.deletions,e===null?(a.deletions=[o],a.flags|=16):e.push(o)}function Cg(a,e){switch(a.tag){case 5:var o=a.type;return e=e.nodeType!==1||o.toLowerCase()!==e.nodeName.toLowerCase()?null:e,e!==null?(a.stateNode=e,xg=a,yg$1=Lf$1(e.firstChild),!0):!1;case 6:return e=a.pendingProps===""||e.nodeType!==3?null:e,e!==null?(a.stateNode=e,xg=a,yg$1=null,!0):!1;case 13:return e=e.nodeType!==8?null:e,e!==null?(o=qg!==null?{id:rg,overflow:sg$1}:null,a.memoizedState={dehydrated:e,treeContext:o,retryLane:1073741824},o=Bg(18,null,null,0),o.stateNode=e,o.return=a,a.child=o,xg=a,yg$1=null,!0):!1;default:return!1}}function Dg(a){return(a.mode&1)!==0&&(a.flags&128)===0}function Eg(a){if(I){var e=yg$1;if(e){var o=e;if(!Cg(a,e)){if(Dg(a))throw Error(p(418));e=Lf$1(o.nextSibling);var s=xg;e&&Cg(a,e)?Ag(s,o):(a.flags=a.flags&-4097|2,I=!1,xg=a)}}else{if(Dg(a))throw Error(p(418));a.flags=a.flags&-4097|2,I=!1,xg=a}}}function Fg(a){for(a=a.return;a!==null&&a.tag!==5&&a.tag!==3&&a.tag!==13;)a=a.return;xg=a}function Gg(a){if(a!==xg)return!1;if(!I)return Fg(a),I=!0,!1;var e;if((e=a.tag!==3)&&!(e=a.tag!==5)&&(e=a.type,e=e!=="head"&&e!=="body"&&!Ef$1(a.type,a.memoizedProps)),e&&(e=yg$1)){if(Dg(a))throw Hg(),Error(p(418));for(;e;)Ag(a,e),e=Lf$1(e.nextSibling)}if(Fg(a),a.tag===13){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(p(317));e:{for(a=a.nextSibling,e=0;a;){if(a.nodeType===8){var o=a.data;if(o==="/$"){if(e===0){yg$1=Lf$1(a.nextSibling);break e}e--}else o!=="$"&&o!=="$!"&&o!=="$?"||e++}a=a.nextSibling}yg$1=null}}else yg$1=xg?Lf$1(a.stateNode.nextSibling):null;return!0}function Hg(){for(var a=yg$1;a;)a=Lf$1(a.nextSibling)}function Ig(){yg$1=xg=null,I=!1}function Jg(a){zg===null?zg=[a]:zg.push(a)}var Kg=ua$2.ReactCurrentBatchConfig;function Lg(a,e){if(a&&a.defaultProps){e=A({},e),a=a.defaultProps;for(var o in a)e[o]===void 0&&(e[o]=a[o]);return e}return e}var Mg=Uf$1(null),Ng=null,Og$1=null,Pg=null;function Qg(){Pg=Og$1=Ng=null}function Rg(a){var e=Mg.current;E$1(Mg),a._currentValue=e}function Sg(a,e,o){for(;a!==null;){var s=a.alternate;if((a.childLanes&e)!==e?(a.childLanes|=e,s!==null&&(s.childLanes|=e)):s!==null&&(s.childLanes&e)!==e&&(s.childLanes|=e),a===o)break;a=a.return}}function Tg(a,e){Ng=a,Pg=Og$1=null,a=a.dependencies,a!==null&&a.firstContext!==null&&(a.lanes&e&&(Ug=!0),a.firstContext=null)}function Vg(a){var e=a._currentValue;if(Pg!==a)if(a={context:a,memoizedValue:e,next:null},Og$1===null){if(Ng===null)throw Error(p(308));Og$1=a,Ng.dependencies={lanes:0,firstContext:a}}else Og$1=Og$1.next=a;return e}var Wg=null;function Xg(a){Wg===null?Wg=[a]:Wg.push(a)}function Yg(a,e,o,s){var d=e.interleaved;return d===null?(o.next=o,Xg(e)):(o.next=d.next,d.next=o),e.interleaved=o,Zg(a,s)}function Zg(a,e){a.lanes|=e;var o=a.alternate;for(o!==null&&(o.lanes|=e),o=a,a=a.return;a!==null;)a.childLanes|=e,o=a.alternate,o!==null&&(o.childLanes|=e),o=a,a=a.return;return o.tag===3?o.stateNode:null}var $g=!1;function ah$1(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function bh$1(a,e){a=a.updateQueue,e.updateQueue===a&&(e.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function ch$1(a,e){return{eventTime:a,lane:e,tag:0,payload:null,callback:null,next:null}}function dh$1(a,e,o){var s=a.updateQueue;if(s===null)return null;if(s=s.shared,K$1&2){var d=s.pending;return d===null?e.next=e:(e.next=d.next,d.next=e),s.pending=e,Zg(a,o)}return d=s.interleaved,d===null?(e.next=e,Xg(s)):(e.next=d.next,d.next=e),s.interleaved=e,Zg(a,o)}function eh$1(a,e,o){if(e=e.updateQueue,e!==null&&(e=e.shared,(o&4194240)!==0)){var s=e.lanes;s&=a.pendingLanes,o|=s,e.lanes=o,Cc$2(a,o)}}function fh$1(a,e){var o=a.updateQueue,s=a.alternate;if(s!==null&&(s=s.updateQueue,o===s)){var d=null,c=null;if(o=o.firstBaseUpdate,o!==null){do{var h={eventTime:o.eventTime,lane:o.lane,tag:o.tag,payload:o.payload,callback:o.callback,next:null};c===null?d=c=h:c=c.next=h,o=o.next}while(o!==null);c===null?d=c=e:c=c.next=e}else d=c=e;o={baseState:s.baseState,firstBaseUpdate:d,lastBaseUpdate:c,shared:s.shared,effects:s.effects},a.updateQueue=o;return}a=o.lastBaseUpdate,a===null?o.firstBaseUpdate=e:a.next=e,o.lastBaseUpdate=e}function gh$1(a,e,o,s){var d=a.updateQueue;$g=!1;var c=d.firstBaseUpdate,h=d.lastBaseUpdate,_=d.shared.pending;if(_!==null){d.shared.pending=null;var bt=_,g=bt.next;bt.next=null,h===null?c=g:h.next=g,h=bt;var j=a.alternate;j!==null&&(j=j.updateQueue,_=j.lastBaseUpdate,_!==h&&(_===null?j.firstBaseUpdate=g:_.next=g,j.lastBaseUpdate=bt))}if(c!==null){var b=d.baseState;h=0,j=g=bt=null,_=c;do{var Et=_.lane,It=_.eventTime;if((s&Et)===Et){j!==null&&(j=j.next={eventTime:It,lane:0,tag:_.tag,payload:_.payload,callback:_.callback,next:null});e:{var zt=a,er=_;switch(Et=e,It=o,er.tag){case 1:if(zt=er.payload,typeof zt=="function"){b=zt.call(It,b,Et);break e}b=zt;break e;case 3:zt.flags=zt.flags&-65537|128;case 0:if(zt=er.payload,Et=typeof zt=="function"?zt.call(It,b,Et):zt,Et==null)break e;b=A({},b,Et);break e;case 2:$g=!0}}_.callback!==null&&_.lane!==0&&(a.flags|=64,Et=d.effects,Et===null?d.effects=[_]:Et.push(_))}else It={eventTime:It,lane:Et,tag:_.tag,payload:_.payload,callback:_.callback,next:null},j===null?(g=j=It,bt=b):j=j.next=It,h|=Et;if(_=_.next,_===null){if(_=d.shared.pending,_===null)break;Et=_,_=Et.next,Et.next=null,d.lastBaseUpdate=Et,d.shared.pending=null}}while(!0);if(j===null&&(bt=b),d.baseState=bt,d.firstBaseUpdate=g,d.lastBaseUpdate=j,e=d.shared.interleaved,e!==null){d=e;do h|=d.lane,d=d.next;while(d!==e)}else c===null&&(d.shared.lanes=0);hh$1|=h,a.lanes=h,a.memoizedState=b}}function ih$1(a,e,o){if(a=e.effects,e.effects=null,a!==null)for(e=0;e<a.length;e++){var s=a[e],d=s.callback;if(d!==null){if(s.callback=null,s=o,typeof d!="function")throw Error(p(191,d));d.call(s)}}}var jh$1=new aa$2.Component().refs;function kh$1(a,e,o,s){e=a.memoizedState,o=o(s,e),o=o==null?e:A({},e,o),a.memoizedState=o,a.lanes===0&&(a.updateQueue.baseState=o)}var nh$1={isMounted:function(a){return(a=a._reactInternals)?Vb$1(a)===a:!1},enqueueSetState:function(a,e,o){a=a._reactInternals;var s=L(),d=lh$1(a),c=ch$1(s,d);c.payload=e,o!=null&&(c.callback=o),e=dh$1(a,c,d),e!==null&&(mh$1(e,a,d,s),eh$1(e,a,d))},enqueueReplaceState:function(a,e,o){a=a._reactInternals;var s=L(),d=lh$1(a),c=ch$1(s,d);c.tag=1,c.payload=e,o!=null&&(c.callback=o),e=dh$1(a,c,d),e!==null&&(mh$1(e,a,d,s),eh$1(e,a,d))},enqueueForceUpdate:function(a,e){a=a._reactInternals;var o=L(),s=lh$1(a),d=ch$1(o,s);d.tag=2,e!=null&&(d.callback=e),e=dh$1(a,d,s),e!==null&&(mh$1(e,a,s,o),eh$1(e,a,s))}};function oh$1(a,e,o,s,d,c,h){return a=a.stateNode,typeof a.shouldComponentUpdate=="function"?a.shouldComponentUpdate(s,c,h):e.prototype&&e.prototype.isPureReactComponent?!Ie(o,s)||!Ie(d,c):!0}function ph(a,e,o){var s=!1,d=Vf$1,c=e.contextType;return typeof c=="object"&&c!==null?c=Vg(c):(d=Zf$1(e)?Xf$1:H.current,s=e.contextTypes,c=(s=s!=null)?Yf$1(a,d):Vf$1),e=new e(o,c),a.memoizedState=e.state!==null&&e.state!==void 0?e.state:null,e.updater=nh$1,a.stateNode=e,e._reactInternals=a,s&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=d,a.__reactInternalMemoizedMaskedChildContext=c),e}function qh$1(a,e,o,s){a=e.state,typeof e.componentWillReceiveProps=="function"&&e.componentWillReceiveProps(o,s),typeof e.UNSAFE_componentWillReceiveProps=="function"&&e.UNSAFE_componentWillReceiveProps(o,s),e.state!==a&&nh$1.enqueueReplaceState(e,e.state,null)}function rh$1(a,e,o,s){var d=a.stateNode;d.props=o,d.state=a.memoizedState,d.refs=jh$1,ah$1(a);var c=e.contextType;typeof c=="object"&&c!==null?d.context=Vg(c):(c=Zf$1(e)?Xf$1:H.current,d.context=Yf$1(a,c)),d.state=a.memoizedState,c=e.getDerivedStateFromProps,typeof c=="function"&&(kh$1(a,e,c,o),d.state=a.memoizedState),typeof e.getDerivedStateFromProps=="function"||typeof d.getSnapshotBeforeUpdate=="function"||typeof d.UNSAFE_componentWillMount!="function"&&typeof d.componentWillMount!="function"||(e=d.state,typeof d.componentWillMount=="function"&&d.componentWillMount(),typeof d.UNSAFE_componentWillMount=="function"&&d.UNSAFE_componentWillMount(),e!==d.state&&nh$1.enqueueReplaceState(d,d.state,null),gh$1(a,o,d,s),d.state=a.memoizedState),typeof d.componentDidMount=="function"&&(a.flags|=4194308)}function sh$1(a,e,o){if(a=o.ref,a!==null&&typeof a!="function"&&typeof a!="object"){if(o._owner){if(o=o._owner,o){if(o.tag!==1)throw Error(p(309));var s=o.stateNode}if(!s)throw Error(p(147,a));var d=s,c=""+a;return e!==null&&e.ref!==null&&typeof e.ref=="function"&&e.ref._stringRef===c?e.ref:(e=function(h){var _=d.refs;_===jh$1&&(_=d.refs={}),h===null?delete _[c]:_[c]=h},e._stringRef=c,e)}if(typeof a!="string")throw Error(p(284));if(!o._owner)throw Error(p(290,a))}return a}function th$1(a,e){throw a=Object.prototype.toString.call(e),Error(p(31,a==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":a))}function uh(a){var e=a._init;return e(a._payload)}function vh$1(a){function e(Qt,cr){if(a){var fr=Qt.deletions;fr===null?(Qt.deletions=[cr],Qt.flags|=16):fr.push(cr)}}function o(Qt,cr){if(!a)return null;for(;cr!==null;)e(Qt,cr),cr=cr.sibling;return null}function s(Qt,cr){for(Qt=new Map;cr!==null;)cr.key!==null?Qt.set(cr.key,cr):Qt.set(cr.index,cr),cr=cr.sibling;return Qt}function d(Qt,cr){return Qt=wh$1(Qt,cr),Qt.index=0,Qt.sibling=null,Qt}function c(Qt,cr,fr){return Qt.index=fr,a?(fr=Qt.alternate,fr!==null?(fr=fr.index,fr<cr?(Qt.flags|=2,cr):fr):(Qt.flags|=2,cr)):(Qt.flags|=1048576,cr)}function h(Qt){return a&&Qt.alternate===null&&(Qt.flags|=2),Qt}function _(Qt,cr,fr,jr){return cr===null||cr.tag!==6?(cr=xh$1(fr,Qt.mode,jr),cr.return=Qt,cr):(cr=d(cr,fr),cr.return=Qt,cr)}function bt(Qt,cr,fr,jr){var e0=fr.type;return e0===ya$1?j(Qt,cr,fr.props.children,jr,fr.key):cr!==null&&(cr.elementType===e0||typeof e0=="object"&&e0!==null&&e0.$$typeof===Ha$1&&uh(e0)===cr.type)?(jr=d(cr,fr.props),jr.ref=sh$1(Qt,cr,fr),jr.return=Qt,jr):(jr=yh$1(fr.type,fr.key,fr.props,null,Qt.mode,jr),jr.ref=sh$1(Qt,cr,fr),jr.return=Qt,jr)}function g(Qt,cr,fr,jr){return cr===null||cr.tag!==4||cr.stateNode.containerInfo!==fr.containerInfo||cr.stateNode.implementation!==fr.implementation?(cr=zh$1(fr,Qt.mode,jr),cr.return=Qt,cr):(cr=d(cr,fr.children||[]),cr.return=Qt,cr)}function j(Qt,cr,fr,jr,e0){return cr===null||cr.tag!==7?(cr=Ah(fr,Qt.mode,jr,e0),cr.return=Qt,cr):(cr=d(cr,fr),cr.return=Qt,cr)}function b(Qt,cr,fr){if(typeof cr=="string"&&cr!==""||typeof cr=="number")return cr=xh$1(""+cr,Qt.mode,fr),cr.return=Qt,cr;if(typeof cr=="object"&&cr!==null){switch(cr.$$typeof){case va$1:return fr=yh$1(cr.type,cr.key,cr.props,null,Qt.mode,fr),fr.ref=sh$1(Qt,null,cr),fr.return=Qt,fr;case wa$1:return cr=zh$1(cr,Qt.mode,fr),cr.return=Qt,cr;case Ha$1:var jr=cr._init;return b(Qt,jr(cr._payload),fr)}if(eb$1(cr)||Ka$1(cr))return cr=Ah(cr,Qt.mode,fr,null),cr.return=Qt,cr;th$1(Qt,cr)}return null}function Et(Qt,cr,fr,jr){var e0=cr!==null?cr.key:null;if(typeof fr=="string"&&fr!==""||typeof fr=="number")return e0!==null?null:_(Qt,cr,""+fr,jr);if(typeof fr=="object"&&fr!==null){switch(fr.$$typeof){case va$1:return fr.key===e0?bt(Qt,cr,fr,jr):null;case wa$1:return fr.key===e0?g(Qt,cr,fr,jr):null;case Ha$1:return e0=fr._init,Et(Qt,cr,e0(fr._payload),jr)}if(eb$1(fr)||Ka$1(fr))return e0!==null?null:j(Qt,cr,fr,jr,null);th$1(Qt,fr)}return null}function It(Qt,cr,fr,jr,e0){if(typeof jr=="string"&&jr!==""||typeof jr=="number")return Qt=Qt.get(fr)||null,_(cr,Qt,""+jr,e0);if(typeof jr=="object"&&jr!==null){switch(jr.$$typeof){case va$1:return Qt=Qt.get(jr.key===null?fr:jr.key)||null,bt(cr,Qt,jr,e0);case wa$1:return Qt=Qt.get(jr.key===null?fr:jr.key)||null,g(cr,Qt,jr,e0);case Ha$1:var t0=jr._init;return It(Qt,cr,fr,t0(jr._payload),e0)}if(eb$1(jr)||Ka$1(jr))return Qt=Qt.get(fr)||null,j(cr,Qt,jr,e0,null);th$1(cr,jr)}return null}function zt(Qt,cr,fr,jr){for(var e0=null,t0=null,o0=cr,l0=cr=0,g0=null;o0!==null&&l0<fr.length;l0++){o0.index>l0?(g0=o0,o0=null):g0=o0.sibling;var i0=Et(Qt,o0,fr[l0],jr);if(i0===null){o0===null&&(o0=g0);break}a&&o0&&i0.alternate===null&&e(Qt,o0),cr=c(i0,cr,l0),t0===null?e0=i0:t0.sibling=i0,t0=i0,o0=g0}if(l0===fr.length)return o(Qt,o0),I&&tg$1(Qt,l0),e0;if(o0===null){for(;l0<fr.length;l0++)o0=b(Qt,fr[l0],jr),o0!==null&&(cr=c(o0,cr,l0),t0===null?e0=o0:t0.sibling=o0,t0=o0);return I&&tg$1(Qt,l0),e0}for(o0=s(Qt,o0);l0<fr.length;l0++)g0=It(o0,Qt,l0,fr[l0],jr),g0!==null&&(a&&g0.alternate!==null&&o0.delete(g0.key===null?l0:g0.key),cr=c(g0,cr,l0),t0===null?e0=g0:t0.sibling=g0,t0=g0);return a&&o0.forEach(function(f0){return e(Qt,f0)}),I&&tg$1(Qt,l0),e0}function er(Qt,cr,fr,jr){var e0=Ka$1(fr);if(typeof e0!="function")throw Error(p(150));if(fr=e0.call(fr),fr==null)throw Error(p(151));for(var t0=e0=null,o0=cr,l0=cr=0,g0=null,i0=fr.next();o0!==null&&!i0.done;l0++,i0=fr.next()){o0.index>l0?(g0=o0,o0=null):g0=o0.sibling;var f0=Et(Qt,o0,i0.value,jr);if(f0===null){o0===null&&(o0=g0);break}a&&o0&&f0.alternate===null&&e(Qt,o0),cr=c(f0,cr,l0),t0===null?e0=f0:t0.sibling=f0,t0=f0,o0=g0}if(i0.done)return o(Qt,o0),I&&tg$1(Qt,l0),e0;if(o0===null){for(;!i0.done;l0++,i0=fr.next())i0=b(Qt,i0.value,jr),i0!==null&&(cr=c(i0,cr,l0),t0===null?e0=i0:t0.sibling=i0,t0=i0);return I&&tg$1(Qt,l0),e0}for(o0=s(Qt,o0);!i0.done;l0++,i0=fr.next())i0=It(o0,Qt,l0,i0.value,jr),i0!==null&&(a&&i0.alternate!==null&&o0.delete(i0.key===null?l0:i0.key),cr=c(i0,cr,l0),t0===null?e0=i0:t0.sibling=i0,t0=i0);return a&&o0.forEach(function(C0){return e(Qt,C0)}),I&&tg$1(Qt,l0),e0}function Hn(Qt,cr,fr,jr){if(typeof fr=="object"&&fr!==null&&fr.type===ya$1&&fr.key===null&&(fr=fr.props.children),typeof fr=="object"&&fr!==null){switch(fr.$$typeof){case va$1:e:{for(var e0=fr.key,t0=cr;t0!==null;){if(t0.key===e0){if(e0=fr.type,e0===ya$1){if(t0.tag===7){o(Qt,t0.sibling),cr=d(t0,fr.props.children),cr.return=Qt,Qt=cr;break e}}else if(t0.elementType===e0||typeof e0=="object"&&e0!==null&&e0.$$typeof===Ha$1&&uh(e0)===t0.type){o(Qt,t0.sibling),cr=d(t0,fr.props),cr.ref=sh$1(Qt,t0,fr),cr.return=Qt,Qt=cr;break e}o(Qt,t0);break}else e(Qt,t0);t0=t0.sibling}fr.type===ya$1?(cr=Ah(fr.props.children,Qt.mode,jr,fr.key),cr.return=Qt,Qt=cr):(jr=yh$1(fr.type,fr.key,fr.props,null,Qt.mode,jr),jr.ref=sh$1(Qt,cr,fr),jr.return=Qt,Qt=jr)}return h(Qt);case wa$1:e:{for(t0=fr.key;cr!==null;){if(cr.key===t0)if(cr.tag===4&&cr.stateNode.containerInfo===fr.containerInfo&&cr.stateNode.implementation===fr.implementation){o(Qt,cr.sibling),cr=d(cr,fr.children||[]),cr.return=Qt,Qt=cr;break e}else{o(Qt,cr);break}else e(Qt,cr);cr=cr.sibling}cr=zh$1(fr,Qt.mode,jr),cr.return=Qt,Qt=cr}return h(Qt);case Ha$1:return t0=fr._init,Hn(Qt,cr,t0(fr._payload),jr)}if(eb$1(fr))return zt(Qt,cr,fr,jr);if(Ka$1(fr))return er(Qt,cr,fr,jr);th$1(Qt,fr)}return typeof fr=="string"&&fr!==""||typeof fr=="number"?(fr=""+fr,cr!==null&&cr.tag===6?(o(Qt,cr.sibling),cr=d(cr,fr),cr.return=Qt,Qt=cr):(o(Qt,cr),cr=xh$1(fr,Qt.mode,jr),cr.return=Qt,Qt=cr),h(Qt)):o(Qt,cr)}return Hn}var Bh$1=vh$1(!0),Ch$1=vh$1(!1),Dh$1={},Eh$1=Uf$1(Dh$1),Fh$1=Uf$1(Dh$1),Gh$1=Uf$1(Dh$1);function Hh$1(a){if(a===Dh$1)throw Error(p(174));return a}function Ih$1(a,e){switch(G(Gh$1,e),G(Fh$1,a),G(Eh$1,Dh$1),a=e.nodeType,a){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:lb$1(null,"");break;default:a=a===8?e.parentNode:e,e=a.namespaceURI||null,a=a.tagName,e=lb$1(e,a)}E$1(Eh$1),G(Eh$1,e)}function Jh$1(){E$1(Eh$1),E$1(Fh$1),E$1(Gh$1)}function Kh$1(a){Hh$1(Gh$1.current);var e=Hh$1(Eh$1.current),o=lb$1(e,a.type);e!==o&&(G(Fh$1,a),G(Eh$1,o))}function Lh$1(a){Fh$1.current===a&&(E$1(Eh$1),E$1(Fh$1))}var M$1=Uf$1(0);function Mh$1(a){for(var e=a;e!==null;){if(e.tag===13){var o=e.memoizedState;if(o!==null&&(o=o.dehydrated,o===null||o.data==="$?"||o.data==="$!"))return e}else if(e.tag===19&&e.memoizedProps.revealOrder!==void 0){if(e.flags&128)return e}else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===a)break;for(;e.sibling===null;){if(e.return===null||e.return===a)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var Nh$1=[];function Oh$1(){for(var a=0;a<Nh$1.length;a++)Nh$1[a]._workInProgressVersionPrimary=null;Nh$1.length=0}var Ph$1=ua$2.ReactCurrentDispatcher,Qh$1=ua$2.ReactCurrentBatchConfig,Rh$1=0,N=null,O$1=null,P=null,Sh$1=!1,Th$1=!1,Uh$1=0,Vh$1=0;function Q(){throw Error(p(321))}function Wh$1(a,e){if(e===null)return!1;for(var o=0;o<e.length&&o<a.length;o++)if(!He$1(a[o],e[o]))return!1;return!0}function Xh$1(a,e,o,s,d,c){if(Rh$1=c,N=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,Ph$1.current=a===null||a.memoizedState===null?Yh$1:Zh$1,a=o(s,d),Th$1){c=0;do{if(Th$1=!1,Uh$1=0,25<=c)throw Error(p(301));c+=1,P=O$1=null,e.updateQueue=null,Ph$1.current=$h$1,a=o(s,d)}while(Th$1)}if(Ph$1.current=ai,e=O$1!==null&&O$1.next!==null,Rh$1=0,P=O$1=N=null,Sh$1=!1,e)throw Error(p(300));return a}function bi$2(){var a=Uh$1!==0;return Uh$1=0,a}function ci$1(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return P===null?N.memoizedState=P=a:P=P.next=a,P}function di$1(){if(O$1===null){var a=N.alternate;a=a!==null?a.memoizedState:null}else a=O$1.next;var e=P===null?N.memoizedState:P.next;if(e!==null)P=e,O$1=a;else{if(a===null)throw Error(p(310));O$1=a,a={memoizedState:O$1.memoizedState,baseState:O$1.baseState,baseQueue:O$1.baseQueue,queue:O$1.queue,next:null},P===null?N.memoizedState=P=a:P=P.next=a}return P}function ei$1(a,e){return typeof e=="function"?e(a):e}function fi$1(a){var e=di$1(),o=e.queue;if(o===null)throw Error(p(311));o.lastRenderedReducer=a;var s=O$1,d=s.baseQueue,c=o.pending;if(c!==null){if(d!==null){var h=d.next;d.next=c.next,c.next=h}s.baseQueue=d=c,o.pending=null}if(d!==null){c=d.next,s=s.baseState;var _=h=null,bt=null,g=c;do{var j=g.lane;if((Rh$1&j)===j)bt!==null&&(bt=bt.next={lane:0,action:g.action,hasEagerState:g.hasEagerState,eagerState:g.eagerState,next:null}),s=g.hasEagerState?g.eagerState:a(s,g.action);else{var b={lane:j,action:g.action,hasEagerState:g.hasEagerState,eagerState:g.eagerState,next:null};bt===null?(_=bt=b,h=s):bt=bt.next=b,N.lanes|=j,hh$1|=j}g=g.next}while(g!==null&&g!==c);bt===null?h=s:bt.next=_,He$1(s,e.memoizedState)||(Ug=!0),e.memoizedState=s,e.baseState=h,e.baseQueue=bt,o.lastRenderedState=s}if(a=o.interleaved,a!==null){d=a;do c=d.lane,N.lanes|=c,hh$1|=c,d=d.next;while(d!==a)}else d===null&&(o.lanes=0);return[e.memoizedState,o.dispatch]}function gi$2(a){var e=di$1(),o=e.queue;if(o===null)throw Error(p(311));o.lastRenderedReducer=a;var s=o.dispatch,d=o.pending,c=e.memoizedState;if(d!==null){o.pending=null;var h=d=d.next;do c=a(c,h.action),h=h.next;while(h!==d);He$1(c,e.memoizedState)||(Ug=!0),e.memoizedState=c,e.baseQueue===null&&(e.baseState=c),o.lastRenderedState=c}return[c,s]}function hi$2(){}function ii$1(a,e){var o=N,s=di$1(),d=e(),c=!He$1(s.memoizedState,d);if(c&&(s.memoizedState=d,Ug=!0),s=s.queue,ji$2(ki$2.bind(null,o,s,a),[a]),s.getSnapshot!==e||c||P!==null&&P.memoizedState.tag&1){if(o.flags|=2048,li$2(9,mi$2.bind(null,o,s,d,e),void 0,null),R$1===null)throw Error(p(349));Rh$1&30||ni(o,e,d)}return d}function ni(a,e,o){a.flags|=16384,a={getSnapshot:e,value:o},e=N.updateQueue,e===null?(e={lastEffect:null,stores:null},N.updateQueue=e,e.stores=[a]):(o=e.stores,o===null?e.stores=[a]:o.push(a))}function mi$2(a,e,o,s){e.value=o,e.getSnapshot=s,oi$1(e)&&pi$2(a)}function ki$2(a,e,o){return o(function(){oi$1(e)&&pi$2(a)})}function oi$1(a){var e=a.getSnapshot;a=a.value;try{var o=e();return!He$1(a,o)}catch{return!0}}function pi$2(a){var e=Zg(a,1);e!==null&&mh$1(e,a,1,-1)}function qi$2(a){var e=ci$1();return typeof a=="function"&&(a=a()),e.memoizedState=e.baseState=a,a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:ei$1,lastRenderedState:a},e.queue=a,a=a.dispatch=ri.bind(null,N,a),[e.memoizedState,a]}function li$2(a,e,o,s){return a={tag:a,create:e,destroy:o,deps:s,next:null},e=N.updateQueue,e===null?(e={lastEffect:null,stores:null},N.updateQueue=e,e.lastEffect=a.next=a):(o=e.lastEffect,o===null?e.lastEffect=a.next=a:(s=o.next,o.next=a,a.next=s,e.lastEffect=a)),a}function si$1(){return di$1().memoizedState}function ti(a,e,o,s){var d=ci$1();N.flags|=a,d.memoizedState=li$2(1|e,o,void 0,s===void 0?null:s)}function ui$1(a,e,o,s){var d=di$1();s=s===void 0?null:s;var c=void 0;if(O$1!==null){var h=O$1.memoizedState;if(c=h.destroy,s!==null&&Wh$1(s,h.deps)){d.memoizedState=li$2(e,o,c,s);return}}N.flags|=a,d.memoizedState=li$2(1|e,o,c,s)}function vi$2(a,e){return ti(8390656,8,a,e)}function ji$2(a,e){return ui$1(2048,8,a,e)}function wi$2(a,e){return ui$1(4,2,a,e)}function xi$2(a,e){return ui$1(4,4,a,e)}function yi$2(a,e){if(typeof e=="function")return a=a(),e(a),function(){e(null)};if(e!=null)return a=a(),e.current=a,function(){e.current=null}}function zi$2(a,e,o){return o=o!=null?o.concat([a]):null,ui$1(4,4,yi$2.bind(null,e,a),o)}function Ai$2(){}function Bi$1(a,e){var o=di$1();e=e===void 0?null:e;var s=o.memoizedState;return s!==null&&e!==null&&Wh$1(e,s[1])?s[0]:(o.memoizedState=[a,e],a)}function Ci$2(a,e){var o=di$1();e=e===void 0?null:e;var s=o.memoizedState;return s!==null&&e!==null&&Wh$1(e,s[1])?s[0]:(a=a(),o.memoizedState=[a,e],a)}function Di$1(a,e,o){return Rh$1&21?(He$1(o,e)||(o=yc$2(),N.lanes|=o,hh$1|=o,a.baseState=!0),e):(a.baseState&&(a.baseState=!1,Ug=!0),a.memoizedState=o)}function Ei$2(a,e){var o=C;C=o!==0&&4>o?o:4,a(!0);var s=Qh$1.transition;Qh$1.transition={};try{a(!1),e()}finally{C=o,Qh$1.transition=s}}function Fi$2(){return di$1().memoizedState}function Gi$1(a,e,o){var s=lh$1(a);if(o={lane:s,action:o,hasEagerState:!1,eagerState:null,next:null},Hi$1(a))Ii$2(e,o);else if(o=Yg(a,e,o,s),o!==null){var d=L();mh$1(o,a,s,d),Ji$2(o,e,s)}}function ri(a,e,o){var s=lh$1(a),d={lane:s,action:o,hasEagerState:!1,eagerState:null,next:null};if(Hi$1(a))Ii$2(e,d);else{var c=a.alternate;if(a.lanes===0&&(c===null||c.lanes===0)&&(c=e.lastRenderedReducer,c!==null))try{var h=e.lastRenderedState,_=c(h,o);if(d.hasEagerState=!0,d.eagerState=_,He$1(_,h)){var bt=e.interleaved;bt===null?(d.next=d,Xg(e)):(d.next=bt.next,bt.next=d),e.interleaved=d;return}}catch{}finally{}o=Yg(a,e,d,s),o!==null&&(d=L(),mh$1(o,a,s,d),Ji$2(o,e,s))}}function Hi$1(a){var e=a.alternate;return a===N||e!==null&&e===N}function Ii$2(a,e){Th$1=Sh$1=!0;var o=a.pending;o===null?e.next=e:(e.next=o.next,o.next=e),a.pending=e}function Ji$2(a,e,o){if(o&4194240){var s=e.lanes;s&=a.pendingLanes,o|=s,e.lanes=o,Cc$2(a,o)}}var ai={readContext:Vg,useCallback:Q,useContext:Q,useEffect:Q,useImperativeHandle:Q,useInsertionEffect:Q,useLayoutEffect:Q,useMemo:Q,useReducer:Q,useRef:Q,useState:Q,useDebugValue:Q,useDeferredValue:Q,useTransition:Q,useMutableSource:Q,useSyncExternalStore:Q,useId:Q,unstable_isNewReconciler:!1},Yh$1={readContext:Vg,useCallback:function(a,e){return ci$1().memoizedState=[a,e===void 0?null:e],a},useContext:Vg,useEffect:vi$2,useImperativeHandle:function(a,e,o){return o=o!=null?o.concat([a]):null,ti(4194308,4,yi$2.bind(null,e,a),o)},useLayoutEffect:function(a,e){return ti(4194308,4,a,e)},useInsertionEffect:function(a,e){return ti(4,2,a,e)},useMemo:function(a,e){var o=ci$1();return e=e===void 0?null:e,a=a(),o.memoizedState=[a,e],a},useReducer:function(a,e,o){var s=ci$1();return e=o!==void 0?o(e):e,s.memoizedState=s.baseState=e,a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:e},s.queue=a,a=a.dispatch=Gi$1.bind(null,N,a),[s.memoizedState,a]},useRef:function(a){var e=ci$1();return a={current:a},e.memoizedState=a},useState:qi$2,useDebugValue:Ai$2,useDeferredValue:function(a){return ci$1().memoizedState=a},useTransition:function(){var a=qi$2(!1),e=a[0];return a=Ei$2.bind(null,a[1]),ci$1().memoizedState=a,[e,a]},useMutableSource:function(){},useSyncExternalStore:function(a,e,o){var s=N,d=ci$1();if(I){if(o===void 0)throw Error(p(407));o=o()}else{if(o=e(),R$1===null)throw Error(p(349));Rh$1&30||ni(s,e,o)}d.memoizedState=o;var c={value:o,getSnapshot:e};return d.queue=c,vi$2(ki$2.bind(null,s,c,a),[a]),s.flags|=2048,li$2(9,mi$2.bind(null,s,c,o,e),void 0,null),o},useId:function(){var a=ci$1(),e=R$1.identifierPrefix;if(I){var o=sg$1,s=rg;o=(s&~(1<<32-oc$2(s)-1)).toString(32)+o,e=":"+e+"R"+o,o=Uh$1++,0<o&&(e+="H"+o.toString(32)),e+=":"}else o=Vh$1++,e=":"+e+"r"+o.toString(32)+":";return a.memoizedState=e},unstable_isNewReconciler:!1},Zh$1={readContext:Vg,useCallback:Bi$1,useContext:Vg,useEffect:ji$2,useImperativeHandle:zi$2,useInsertionEffect:wi$2,useLayoutEffect:xi$2,useMemo:Ci$2,useReducer:fi$1,useRef:si$1,useState:function(){return fi$1(ei$1)},useDebugValue:Ai$2,useDeferredValue:function(a){var e=di$1();return Di$1(e,O$1.memoizedState,a)},useTransition:function(){var a=fi$1(ei$1)[0],e=di$1().memoizedState;return[a,e]},useMutableSource:hi$2,useSyncExternalStore:ii$1,useId:Fi$2,unstable_isNewReconciler:!1},$h$1={readContext:Vg,useCallback:Bi$1,useContext:Vg,useEffect:ji$2,useImperativeHandle:zi$2,useInsertionEffect:wi$2,useLayoutEffect:xi$2,useMemo:Ci$2,useReducer:gi$2,useRef:si$1,useState:function(){return gi$2(ei$1)},useDebugValue:Ai$2,useDeferredValue:function(a){var e=di$1();return O$1===null?e.memoizedState=a:Di$1(e,O$1.memoizedState,a)},useTransition:function(){var a=gi$2(ei$1)[0],e=di$1().memoizedState;return[a,e]},useMutableSource:hi$2,useSyncExternalStore:ii$1,useId:Fi$2,unstable_isNewReconciler:!1};function Ki$2(a,e){try{var o="",s=e;do o+=Pa$1(s),s=s.return;while(s);var d=o}catch(c){d=`
Error generating stack: `+c.message+`
`+c.stack}return{value:a,source:e,stack:d,digest:null}}function Li$2(a,e,o){return{value:a,source:null,stack:o??null,digest:e??null}}function Mi$2(a,e){try{console.error(e.value)}catch(o){setTimeout(function(){throw o})}}var Ni$2=typeof WeakMap=="function"?WeakMap:Map;function Oi$2(a,e,o){o=ch$1(-1,o),o.tag=3,o.payload={element:null};var s=e.value;return o.callback=function(){Pi$2||(Pi$2=!0,Qi$2=s),Mi$2(a,e)},o}function Ri$2(a,e,o){o=ch$1(-1,o),o.tag=3;var s=a.type.getDerivedStateFromError;if(typeof s=="function"){var d=e.value;o.payload=function(){return s(d)},o.callback=function(){Mi$2(a,e)}}var c=a.stateNode;return c!==null&&typeof c.componentDidCatch=="function"&&(o.callback=function(){Mi$2(a,e),typeof s!="function"&&(Si$2===null?Si$2=new Set([this]):Si$2.add(this));var h=e.stack;this.componentDidCatch(e.value,{componentStack:h!==null?h:""})}),o}function Ti$2(a,e,o){var s=a.pingCache;if(s===null){s=a.pingCache=new Ni$2;var d=new Set;s.set(e,d)}else d=s.get(e),d===void 0&&(d=new Set,s.set(e,d));d.has(o)||(d.add(o),a=Ui$2.bind(null,a,e,o),e.then(a,a))}function Vi$2(a){do{var e;if((e=a.tag===13)&&(e=a.memoizedState,e=e!==null?e.dehydrated!==null:!0),e)return a;a=a.return}while(a!==null);return null}function Wi$2(a,e,o,s,d){return a.mode&1?(a.flags|=65536,a.lanes=d,a):(a===e?a.flags|=65536:(a.flags|=128,o.flags|=131072,o.flags&=-52805,o.tag===1&&(o.alternate===null?o.tag=17:(e=ch$1(-1,1),e.tag=2,dh$1(o,e,1))),o.lanes|=1),a)}var Xi$2=ua$2.ReactCurrentOwner,Ug=!1;function Yi$2(a,e,o,s){e.child=a===null?Ch$1(e,null,o,s):Bh$1(e,a.child,o,s)}function Zi$2(a,e,o,s,d){o=o.render;var c=e.ref;return Tg(e,d),s=Xh$1(a,e,o,s,c,d),o=bi$2(),a!==null&&!Ug?(e.updateQueue=a.updateQueue,e.flags&=-2053,a.lanes&=~d,$i$2(a,e,d)):(I&&o&&vg$1(e),e.flags|=1,Yi$2(a,e,s,d),e.child)}function aj(a,e,o,s,d){if(a===null){var c=o.type;return typeof c=="function"&&!bj(c)&&c.defaultProps===void 0&&o.compare===null&&o.defaultProps===void 0?(e.tag=15,e.type=c,cj(a,e,c,s,d)):(a=yh$1(o.type,null,s,e,e.mode,d),a.ref=e.ref,a.return=e,e.child=a)}if(c=a.child,!(a.lanes&d)){var h=c.memoizedProps;if(o=o.compare,o=o!==null?o:Ie,o(h,s)&&a.ref===e.ref)return $i$2(a,e,d)}return e.flags|=1,a=wh$1(c,s),a.ref=e.ref,a.return=e,e.child=a}function cj(a,e,o,s,d){if(a!==null){var c=a.memoizedProps;if(Ie(c,s)&&a.ref===e.ref)if(Ug=!1,e.pendingProps=s=c,(a.lanes&d)!==0)a.flags&131072&&(Ug=!0);else return e.lanes=a.lanes,$i$2(a,e,d)}return dj(a,e,o,s,d)}function ej(a,e,o){var s=e.pendingProps,d=s.children,c=a!==null?a.memoizedState:null;if(s.mode==="hidden")if(!(e.mode&1))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(fj,gj),gj|=o;else{if(!(o&1073741824))return a=c!==null?c.baseLanes|o:o,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:a,cachePool:null,transitions:null},e.updateQueue=null,G(fj,gj),gj|=a,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},s=c!==null?c.baseLanes:o,G(fj,gj),gj|=s}else c!==null?(s=c.baseLanes|o,e.memoizedState=null):s=o,G(fj,gj),gj|=s;return Yi$2(a,e,d,o),e.child}function hj(a,e){var o=e.ref;(a===null&&o!==null||a!==null&&a.ref!==o)&&(e.flags|=512,e.flags|=2097152)}function dj(a,e,o,s,d){var c=Zf$1(o)?Xf$1:H.current;return c=Yf$1(e,c),Tg(e,d),o=Xh$1(a,e,o,s,c,d),s=bi$2(),a!==null&&!Ug?(e.updateQueue=a.updateQueue,e.flags&=-2053,a.lanes&=~d,$i$2(a,e,d)):(I&&s&&vg$1(e),e.flags|=1,Yi$2(a,e,o,d),e.child)}function ij(a,e,o,s,d){if(Zf$1(o)){var c=!0;cg$1(e)}else c=!1;if(Tg(e,d),e.stateNode===null)jj(a,e),ph(e,o,s),rh$1(e,o,s,d),s=!0;else if(a===null){var h=e.stateNode,_=e.memoizedProps;h.props=_;var bt=h.context,g=o.contextType;typeof g=="object"&&g!==null?g=Vg(g):(g=Zf$1(o)?Xf$1:H.current,g=Yf$1(e,g));var j=o.getDerivedStateFromProps,b=typeof j=="function"||typeof h.getSnapshotBeforeUpdate=="function";b||typeof h.UNSAFE_componentWillReceiveProps!="function"&&typeof h.componentWillReceiveProps!="function"||(_!==s||bt!==g)&&qh$1(e,h,s,g),$g=!1;var Et=e.memoizedState;h.state=Et,gh$1(e,s,h,d),bt=e.memoizedState,_!==s||Et!==bt||Wf$1.current||$g?(typeof j=="function"&&(kh$1(e,o,j,s),bt=e.memoizedState),(_=$g||oh$1(e,o,_,s,Et,bt,g))?(b||typeof h.UNSAFE_componentWillMount!="function"&&typeof h.componentWillMount!="function"||(typeof h.componentWillMount=="function"&&h.componentWillMount(),typeof h.UNSAFE_componentWillMount=="function"&&h.UNSAFE_componentWillMount()),typeof h.componentDidMount=="function"&&(e.flags|=4194308)):(typeof h.componentDidMount=="function"&&(e.flags|=4194308),e.memoizedProps=s,e.memoizedState=bt),h.props=s,h.state=bt,h.context=g,s=_):(typeof h.componentDidMount=="function"&&(e.flags|=4194308),s=!1)}else{h=e.stateNode,bh$1(a,e),_=e.memoizedProps,g=e.type===e.elementType?_:Lg(e.type,_),h.props=g,b=e.pendingProps,Et=h.context,bt=o.contextType,typeof bt=="object"&&bt!==null?bt=Vg(bt):(bt=Zf$1(o)?Xf$1:H.current,bt=Yf$1(e,bt));var It=o.getDerivedStateFromProps;(j=typeof It=="function"||typeof h.getSnapshotBeforeUpdate=="function")||typeof h.UNSAFE_componentWillReceiveProps!="function"&&typeof h.componentWillReceiveProps!="function"||(_!==b||Et!==bt)&&qh$1(e,h,s,bt),$g=!1,Et=e.memoizedState,h.state=Et,gh$1(e,s,h,d);var zt=e.memoizedState;_!==b||Et!==zt||Wf$1.current||$g?(typeof It=="function"&&(kh$1(e,o,It,s),zt=e.memoizedState),(g=$g||oh$1(e,o,g,s,Et,zt,bt)||!1)?(j||typeof h.UNSAFE_componentWillUpdate!="function"&&typeof h.componentWillUpdate!="function"||(typeof h.componentWillUpdate=="function"&&h.componentWillUpdate(s,zt,bt),typeof h.UNSAFE_componentWillUpdate=="function"&&h.UNSAFE_componentWillUpdate(s,zt,bt)),typeof h.componentDidUpdate=="function"&&(e.flags|=4),typeof h.getSnapshotBeforeUpdate=="function"&&(e.flags|=1024)):(typeof h.componentDidUpdate!="function"||_===a.memoizedProps&&Et===a.memoizedState||(e.flags|=4),typeof h.getSnapshotBeforeUpdate!="function"||_===a.memoizedProps&&Et===a.memoizedState||(e.flags|=1024),e.memoizedProps=s,e.memoizedState=zt),h.props=s,h.state=zt,h.context=bt,s=g):(typeof h.componentDidUpdate!="function"||_===a.memoizedProps&&Et===a.memoizedState||(e.flags|=4),typeof h.getSnapshotBeforeUpdate!="function"||_===a.memoizedProps&&Et===a.memoizedState||(e.flags|=1024),s=!1)}return kj(a,e,o,s,c,d)}function kj(a,e,o,s,d,c){hj(a,e);var h=(e.flags&128)!==0;if(!s&&!h)return d&&dg$1(e,o,!1),$i$2(a,e,c);s=e.stateNode,Xi$2.current=e;var _=h&&typeof o.getDerivedStateFromError!="function"?null:s.render();return e.flags|=1,a!==null&&h?(e.child=Bh$1(e,a.child,null,c),e.child=Bh$1(e,null,_,c)):Yi$2(a,e,_,c),e.memoizedState=s.state,d&&dg$1(e,o,!0),e.child}function lj(a){var e=a.stateNode;e.pendingContext?ag$1(a,e.pendingContext,e.pendingContext!==e.context):e.context&&ag$1(a,e.context,!1),Ih$1(a,e.containerInfo)}function mj(a,e,o,s,d){return Ig(),Jg(d),e.flags|=256,Yi$2(a,e,o,s),e.child}var nj={dehydrated:null,treeContext:null,retryLane:0};function oj(a){return{baseLanes:a,cachePool:null,transitions:null}}function pj(a,e,o){var s=e.pendingProps,d=M$1.current,c=!1,h=(e.flags&128)!==0,_;if((_=h)||(_=a!==null&&a.memoizedState===null?!1:(d&2)!==0),_?(c=!0,e.flags&=-129):(a===null||a.memoizedState!==null)&&(d|=1),G(M$1,d&1),a===null)return Eg(e),a=e.memoizedState,a!==null&&(a=a.dehydrated,a!==null)?(e.mode&1?a.data==="$!"?e.lanes=8:e.lanes=1073741824:e.lanes=1,null):(h=s.children,a=s.fallback,c?(s=e.mode,c=e.child,h={mode:"hidden",children:h},!(s&1)&&c!==null?(c.childLanes=0,c.pendingProps=h):c=qj(h,s,0,null),a=Ah(a,s,o,null),c.return=e,a.return=e,c.sibling=a,e.child=c,e.child.memoizedState=oj(o),e.memoizedState=nj,a):rj(e,h));if(d=a.memoizedState,d!==null&&(_=d.dehydrated,_!==null))return sj(a,e,h,s,_,d,o);if(c){c=s.fallback,h=e.mode,d=a.child,_=d.sibling;var bt={mode:"hidden",children:s.children};return!(h&1)&&e.child!==d?(s=e.child,s.childLanes=0,s.pendingProps=bt,e.deletions=null):(s=wh$1(d,bt),s.subtreeFlags=d.subtreeFlags&14680064),_!==null?c=wh$1(_,c):(c=Ah(c,h,o,null),c.flags|=2),c.return=e,s.return=e,s.sibling=c,e.child=s,s=c,c=e.child,h=a.child.memoizedState,h=h===null?oj(o):{baseLanes:h.baseLanes|o,cachePool:null,transitions:h.transitions},c.memoizedState=h,c.childLanes=a.childLanes&~o,e.memoizedState=nj,s}return c=a.child,a=c.sibling,s=wh$1(c,{mode:"visible",children:s.children}),!(e.mode&1)&&(s.lanes=o),s.return=e,s.sibling=null,a!==null&&(o=e.deletions,o===null?(e.deletions=[a],e.flags|=16):o.push(a)),e.child=s,e.memoizedState=null,s}function rj(a,e){return e=qj({mode:"visible",children:e},a.mode,0,null),e.return=a,a.child=e}function tj(a,e,o,s){return s!==null&&Jg(s),Bh$1(e,a.child,null,o),a=rj(e,e.pendingProps.children),a.flags|=2,e.memoizedState=null,a}function sj(a,e,o,s,d,c,h){if(o)return e.flags&256?(e.flags&=-257,s=Li$2(Error(p(422))),tj(a,e,h,s)):e.memoizedState!==null?(e.child=a.child,e.flags|=128,null):(c=s.fallback,d=e.mode,s=qj({mode:"visible",children:s.children},d,0,null),c=Ah(c,d,h,null),c.flags|=2,s.return=e,c.return=e,s.sibling=c,e.child=s,e.mode&1&&Bh$1(e,a.child,null,h),e.child.memoizedState=oj(h),e.memoizedState=nj,c);if(!(e.mode&1))return tj(a,e,h,null);if(d.data==="$!"){if(s=d.nextSibling&&d.nextSibling.dataset,s)var _=s.dgst;return s=_,c=Error(p(419)),s=Li$2(c,s,void 0),tj(a,e,h,s)}if(_=(h&a.childLanes)!==0,Ug||_){if(s=R$1,s!==null){switch(h&-h){case 4:d=2;break;case 16:d=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:d=32;break;case 536870912:d=268435456;break;default:d=0}d=d&(s.suspendedLanes|h)?0:d,d!==0&&d!==c.retryLane&&(c.retryLane=d,Zg(a,d),mh$1(s,a,d,-1))}return uj(),s=Li$2(Error(p(421))),tj(a,e,h,s)}return d.data==="$?"?(e.flags|=128,e.child=a.child,e=vj.bind(null,a),d._reactRetry=e,null):(a=c.treeContext,yg$1=Lf$1(d.nextSibling),xg=e,I=!0,zg=null,a!==null&&(og$1[pg$1++]=rg,og$1[pg$1++]=sg$1,og$1[pg$1++]=qg,rg=a.id,sg$1=a.overflow,qg=e),e=rj(e,s.children),e.flags|=4096,e)}function wj(a,e,o){a.lanes|=e;var s=a.alternate;s!==null&&(s.lanes|=e),Sg(a.return,e,o)}function xj(a,e,o,s,d){var c=a.memoizedState;c===null?a.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:s,tail:o,tailMode:d}:(c.isBackwards=e,c.rendering=null,c.renderingStartTime=0,c.last=s,c.tail=o,c.tailMode=d)}function yj(a,e,o){var s=e.pendingProps,d=s.revealOrder,c=s.tail;if(Yi$2(a,e,s.children,o),s=M$1.current,s&2)s=s&1|2,e.flags|=128;else{if(a!==null&&a.flags&128)e:for(a=e.child;a!==null;){if(a.tag===13)a.memoizedState!==null&&wj(a,o,e);else if(a.tag===19)wj(a,o,e);else if(a.child!==null){a.child.return=a,a=a.child;continue}if(a===e)break e;for(;a.sibling===null;){if(a.return===null||a.return===e)break e;a=a.return}a.sibling.return=a.return,a=a.sibling}s&=1}if(G(M$1,s),!(e.mode&1))e.memoizedState=null;else switch(d){case"forwards":for(o=e.child,d=null;o!==null;)a=o.alternate,a!==null&&Mh$1(a)===null&&(d=o),o=o.sibling;o=d,o===null?(d=e.child,e.child=null):(d=o.sibling,o.sibling=null),xj(e,!1,d,o,c);break;case"backwards":for(o=null,d=e.child,e.child=null;d!==null;){if(a=d.alternate,a!==null&&Mh$1(a)===null){e.child=d;break}a=d.sibling,d.sibling=o,o=d,d=a}xj(e,!0,o,null,c);break;case"together":xj(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function jj(a,e){!(e.mode&1)&&a!==null&&(a.alternate=null,e.alternate=null,e.flags|=2)}function $i$2(a,e,o){if(a!==null&&(e.dependencies=a.dependencies),hh$1|=e.lanes,!(o&e.childLanes))return null;if(a!==null&&e.child!==a.child)throw Error(p(153));if(e.child!==null){for(a=e.child,o=wh$1(a,a.pendingProps),e.child=o,o.return=e;a.sibling!==null;)a=a.sibling,o=o.sibling=wh$1(a,a.pendingProps),o.return=e;o.sibling=null}return e.child}function zj(a,e,o){switch(e.tag){case 3:lj(e),Ig();break;case 5:Kh$1(e);break;case 1:Zf$1(e.type)&&cg$1(e);break;case 4:Ih$1(e,e.stateNode.containerInfo);break;case 10:var s=e.type._context,d=e.memoizedProps.value;G(Mg,s._currentValue),s._currentValue=d;break;case 13:if(s=e.memoizedState,s!==null)return s.dehydrated!==null?(G(M$1,M$1.current&1),e.flags|=128,null):o&e.child.childLanes?pj(a,e,o):(G(M$1,M$1.current&1),a=$i$2(a,e,o),a!==null?a.sibling:null);G(M$1,M$1.current&1);break;case 19:if(s=(o&e.childLanes)!==0,a.flags&128){if(s)return yj(a,e,o);e.flags|=128}if(d=e.memoizedState,d!==null&&(d.rendering=null,d.tail=null,d.lastEffect=null),G(M$1,M$1.current),s)break;return null;case 22:case 23:return e.lanes=0,ej(a,e,o)}return $i$2(a,e,o)}var Aj,Bj,Cj,Dj;Aj=function(a,e){for(var o=e.child;o!==null;){if(o.tag===5||o.tag===6)a.appendChild(o.stateNode);else if(o.tag!==4&&o.child!==null){o.child.return=o,o=o.child;continue}if(o===e)break;for(;o.sibling===null;){if(o.return===null||o.return===e)return;o=o.return}o.sibling.return=o.return,o=o.sibling}};Bj=function(){};Cj=function(a,e,o,s){var d=a.memoizedProps;if(d!==s){a=e.stateNode,Hh$1(Eh$1.current);var c=null;switch(o){case"input":d=Ya$1(a,d),s=Ya$1(a,s),c=[];break;case"select":d=A({},d,{value:void 0}),s=A({},s,{value:void 0}),c=[];break;case"textarea":d=gb$1(a,d),s=gb$1(a,s),c=[];break;default:typeof d.onClick!="function"&&typeof s.onClick=="function"&&(a.onclick=Bf$1)}ub$1(o,s);var h;o=null;for(g in d)if(!s.hasOwnProperty(g)&&d.hasOwnProperty(g)&&d[g]!=null)if(g==="style"){var _=d[g];for(h in _)_.hasOwnProperty(h)&&(o||(o={}),o[h]="")}else g!=="dangerouslySetInnerHTML"&&g!=="children"&&g!=="suppressContentEditableWarning"&&g!=="suppressHydrationWarning"&&g!=="autoFocus"&&(ea$1.hasOwnProperty(g)?c||(c=[]):(c=c||[]).push(g,null));for(g in s){var bt=s[g];if(_=d!=null?d[g]:void 0,s.hasOwnProperty(g)&&bt!==_&&(bt!=null||_!=null))if(g==="style")if(_){for(h in _)!_.hasOwnProperty(h)||bt&&bt.hasOwnProperty(h)||(o||(o={}),o[h]="");for(h in bt)bt.hasOwnProperty(h)&&_[h]!==bt[h]&&(o||(o={}),o[h]=bt[h])}else o||(c||(c=[]),c.push(g,o)),o=bt;else g==="dangerouslySetInnerHTML"?(bt=bt?bt.__html:void 0,_=_?_.__html:void 0,bt!=null&&_!==bt&&(c=c||[]).push(g,bt)):g==="children"?typeof bt!="string"&&typeof bt!="number"||(c=c||[]).push(g,""+bt):g!=="suppressContentEditableWarning"&&g!=="suppressHydrationWarning"&&(ea$1.hasOwnProperty(g)?(bt!=null&&g==="onScroll"&&D$1("scroll",a),c||_===bt||(c=[])):(c=c||[]).push(g,bt))}o&&(c=c||[]).push("style",o);var g=c;(e.updateQueue=g)&&(e.flags|=4)}};Dj=function(a,e,o,s){o!==s&&(e.flags|=4)};function Ej(a,e){if(!I)switch(a.tailMode){case"hidden":e=a.tail;for(var o=null;e!==null;)e.alternate!==null&&(o=e),e=e.sibling;o===null?a.tail=null:o.sibling=null;break;case"collapsed":o=a.tail;for(var s=null;o!==null;)o.alternate!==null&&(s=o),o=o.sibling;s===null?e||a.tail===null?a.tail=null:a.tail.sibling=null:s.sibling=null}}function S(a){var e=a.alternate!==null&&a.alternate.child===a.child,o=0,s=0;if(e)for(var d=a.child;d!==null;)o|=d.lanes|d.childLanes,s|=d.subtreeFlags&14680064,s|=d.flags&14680064,d.return=a,d=d.sibling;else for(d=a.child;d!==null;)o|=d.lanes|d.childLanes,s|=d.subtreeFlags,s|=d.flags,d.return=a,d=d.sibling;return a.subtreeFlags|=s,a.childLanes=o,e}function Fj(a,e,o){var s=e.pendingProps;switch(wg$1(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(e),null;case 1:return Zf$1(e.type)&&$f$1(),S(e),null;case 3:return s=e.stateNode,Jh$1(),E$1(Wf$1),E$1(H),Oh$1(),s.pendingContext&&(s.context=s.pendingContext,s.pendingContext=null),(a===null||a.child===null)&&(Gg(e)?e.flags|=4:a===null||a.memoizedState.isDehydrated&&!(e.flags&256)||(e.flags|=1024,zg!==null&&(Gj(zg),zg=null))),Bj(a,e),S(e),null;case 5:Lh$1(e);var d=Hh$1(Gh$1.current);if(o=e.type,a!==null&&e.stateNode!=null)Cj(a,e,o,s,d),a.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!s){if(e.stateNode===null)throw Error(p(166));return S(e),null}if(a=Hh$1(Eh$1.current),Gg(e)){s=e.stateNode,o=e.type;var c=e.memoizedProps;switch(s[Of$1]=e,s[Pf$1]=c,a=(e.mode&1)!==0,o){case"dialog":D$1("cancel",s),D$1("close",s);break;case"iframe":case"object":case"embed":D$1("load",s);break;case"video":case"audio":for(d=0;d<lf$2.length;d++)D$1(lf$2[d],s);break;case"source":D$1("error",s);break;case"img":case"image":case"link":D$1("error",s),D$1("load",s);break;case"details":D$1("toggle",s);break;case"input":Za$1(s,c),D$1("invalid",s);break;case"select":s._wrapperState={wasMultiple:!!c.multiple},D$1("invalid",s);break;case"textarea":hb$1(s,c),D$1("invalid",s)}ub$1(o,c),d=null;for(var h in c)if(c.hasOwnProperty(h)){var _=c[h];h==="children"?typeof _=="string"?s.textContent!==_&&(c.suppressHydrationWarning!==!0&&Af$1(s.textContent,_,a),d=["children",_]):typeof _=="number"&&s.textContent!==""+_&&(c.suppressHydrationWarning!==!0&&Af$1(s.textContent,_,a),d=["children",""+_]):ea$1.hasOwnProperty(h)&&_!=null&&h==="onScroll"&&D$1("scroll",s)}switch(o){case"input":Va(s),db$1(s,c,!0);break;case"textarea":Va(s),jb$1(s);break;case"select":case"option":break;default:typeof c.onClick=="function"&&(s.onclick=Bf$1)}s=d,e.updateQueue=s,s!==null&&(e.flags|=4)}else{h=d.nodeType===9?d:d.ownerDocument,a==="http://www.w3.org/1999/xhtml"&&(a=kb$1(o)),a==="http://www.w3.org/1999/xhtml"?o==="script"?(a=h.createElement("div"),a.innerHTML="<script><\/script>",a=a.removeChild(a.firstChild)):typeof s.is=="string"?a=h.createElement(o,{is:s.is}):(a=h.createElement(o),o==="select"&&(h=a,s.multiple?h.multiple=!0:s.size&&(h.size=s.size))):a=h.createElementNS(a,o),a[Of$1]=e,a[Pf$1]=s,Aj(a,e,!1,!1),e.stateNode=a;e:{switch(h=vb$1(o,s),o){case"dialog":D$1("cancel",a),D$1("close",a),d=s;break;case"iframe":case"object":case"embed":D$1("load",a),d=s;break;case"video":case"audio":for(d=0;d<lf$2.length;d++)D$1(lf$2[d],a);d=s;break;case"source":D$1("error",a),d=s;break;case"img":case"image":case"link":D$1("error",a),D$1("load",a),d=s;break;case"details":D$1("toggle",a),d=s;break;case"input":Za$1(a,s),d=Ya$1(a,s),D$1("invalid",a);break;case"option":d=s;break;case"select":a._wrapperState={wasMultiple:!!s.multiple},d=A({},s,{value:void 0}),D$1("invalid",a);break;case"textarea":hb$1(a,s),d=gb$1(a,s),D$1("invalid",a);break;default:d=s}ub$1(o,d),_=d;for(c in _)if(_.hasOwnProperty(c)){var bt=_[c];c==="style"?sb$1(a,bt):c==="dangerouslySetInnerHTML"?(bt=bt?bt.__html:void 0,bt!=null&&nb$1(a,bt)):c==="children"?typeof bt=="string"?(o!=="textarea"||bt!=="")&&ob$1(a,bt):typeof bt=="number"&&ob$1(a,""+bt):c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&c!=="autoFocus"&&(ea$1.hasOwnProperty(c)?bt!=null&&c==="onScroll"&&D$1("scroll",a):bt!=null&&ta$1(a,c,bt,h))}switch(o){case"input":Va(a),db$1(a,s,!1);break;case"textarea":Va(a),jb$1(a);break;case"option":s.value!=null&&a.setAttribute("value",""+Sa$1(s.value));break;case"select":a.multiple=!!s.multiple,c=s.value,c!=null?fb$1(a,!!s.multiple,c,!1):s.defaultValue!=null&&fb$1(a,!!s.multiple,s.defaultValue,!0);break;default:typeof d.onClick=="function"&&(a.onclick=Bf$1)}switch(o){case"button":case"input":case"select":case"textarea":s=!!s.autoFocus;break e;case"img":s=!0;break e;default:s=!1}}s&&(e.flags|=4)}e.ref!==null&&(e.flags|=512,e.flags|=2097152)}return S(e),null;case 6:if(a&&e.stateNode!=null)Dj(a,e,a.memoizedProps,s);else{if(typeof s!="string"&&e.stateNode===null)throw Error(p(166));if(o=Hh$1(Gh$1.current),Hh$1(Eh$1.current),Gg(e)){if(s=e.stateNode,o=e.memoizedProps,s[Of$1]=e,(c=s.nodeValue!==o)&&(a=xg,a!==null))switch(a.tag){case 3:Af$1(s.nodeValue,o,(a.mode&1)!==0);break;case 5:a.memoizedProps.suppressHydrationWarning!==!0&&Af$1(s.nodeValue,o,(a.mode&1)!==0)}c&&(e.flags|=4)}else s=(o.nodeType===9?o:o.ownerDocument).createTextNode(s),s[Of$1]=e,e.stateNode=s}return S(e),null;case 13:if(E$1(M$1),s=e.memoizedState,a===null||a.memoizedState!==null&&a.memoizedState.dehydrated!==null){if(I&&yg$1!==null&&e.mode&1&&!(e.flags&128))Hg(),Ig(),e.flags|=98560,c=!1;else if(c=Gg(e),s!==null&&s.dehydrated!==null){if(a===null){if(!c)throw Error(p(318));if(c=e.memoizedState,c=c!==null?c.dehydrated:null,!c)throw Error(p(317));c[Of$1]=e}else Ig(),!(e.flags&128)&&(e.memoizedState=null),e.flags|=4;S(e),c=!1}else zg!==null&&(Gj(zg),zg=null),c=!0;if(!c)return e.flags&65536?e:null}return e.flags&128?(e.lanes=o,e):(s=s!==null,s!==(a!==null&&a.memoizedState!==null)&&s&&(e.child.flags|=8192,e.mode&1&&(a===null||M$1.current&1?T===0&&(T=3):uj())),e.updateQueue!==null&&(e.flags|=4),S(e),null);case 4:return Jh$1(),Bj(a,e),a===null&&sf$2(e.stateNode.containerInfo),S(e),null;case 10:return Rg(e.type._context),S(e),null;case 17:return Zf$1(e.type)&&$f$1(),S(e),null;case 19:if(E$1(M$1),c=e.memoizedState,c===null)return S(e),null;if(s=(e.flags&128)!==0,h=c.rendering,h===null)if(s)Ej(c,!1);else{if(T!==0||a!==null&&a.flags&128)for(a=e.child;a!==null;){if(h=Mh$1(a),h!==null){for(e.flags|=128,Ej(c,!1),s=h.updateQueue,s!==null&&(e.updateQueue=s,e.flags|=4),e.subtreeFlags=0,s=o,o=e.child;o!==null;)c=o,a=s,c.flags&=14680066,h=c.alternate,h===null?(c.childLanes=0,c.lanes=a,c.child=null,c.subtreeFlags=0,c.memoizedProps=null,c.memoizedState=null,c.updateQueue=null,c.dependencies=null,c.stateNode=null):(c.childLanes=h.childLanes,c.lanes=h.lanes,c.child=h.child,c.subtreeFlags=0,c.deletions=null,c.memoizedProps=h.memoizedProps,c.memoizedState=h.memoizedState,c.updateQueue=h.updateQueue,c.type=h.type,a=h.dependencies,c.dependencies=a===null?null:{lanes:a.lanes,firstContext:a.firstContext}),o=o.sibling;return G(M$1,M$1.current&1|2),e.child}a=a.sibling}c.tail!==null&&B()>Hj&&(e.flags|=128,s=!0,Ej(c,!1),e.lanes=4194304)}else{if(!s)if(a=Mh$1(h),a!==null){if(e.flags|=128,s=!0,o=a.updateQueue,o!==null&&(e.updateQueue=o,e.flags|=4),Ej(c,!0),c.tail===null&&c.tailMode==="hidden"&&!h.alternate&&!I)return S(e),null}else 2*B()-c.renderingStartTime>Hj&&o!==1073741824&&(e.flags|=128,s=!0,Ej(c,!1),e.lanes=4194304);c.isBackwards?(h.sibling=e.child,e.child=h):(o=c.last,o!==null?o.sibling=h:e.child=h,c.last=h)}return c.tail!==null?(e=c.tail,c.rendering=e,c.tail=e.sibling,c.renderingStartTime=B(),e.sibling=null,o=M$1.current,G(M$1,s?o&1|2:o&1),e):(S(e),null);case 22:case 23:return Ij(),s=e.memoizedState!==null,a!==null&&a.memoizedState!==null!==s&&(e.flags|=8192),s&&e.mode&1?gj&1073741824&&(S(e),e.subtreeFlags&6&&(e.flags|=8192)):S(e),null;case 24:return null;case 25:return null}throw Error(p(156,e.tag))}function Jj(a,e){switch(wg$1(e),e.tag){case 1:return Zf$1(e.type)&&$f$1(),a=e.flags,a&65536?(e.flags=a&-65537|128,e):null;case 3:return Jh$1(),E$1(Wf$1),E$1(H),Oh$1(),a=e.flags,a&65536&&!(a&128)?(e.flags=a&-65537|128,e):null;case 5:return Lh$1(e),null;case 13:if(E$1(M$1),a=e.memoizedState,a!==null&&a.dehydrated!==null){if(e.alternate===null)throw Error(p(340));Ig()}return a=e.flags,a&65536?(e.flags=a&-65537|128,e):null;case 19:return E$1(M$1),null;case 4:return Jh$1(),null;case 10:return Rg(e.type._context),null;case 22:case 23:return Ij(),null;case 24:return null;default:return null}}var Kj=!1,U$1=!1,Lj=typeof WeakSet=="function"?WeakSet:Set,V=null;function Mj(a,e){var o=a.ref;if(o!==null)if(typeof o=="function")try{o(null)}catch(s){W$1(a,e,s)}else o.current=null}function Nj(a,e,o){try{o()}catch(s){W$1(a,e,s)}}var Oj=!1;function Pj(a,e){if(Cf$1=dd$2,a=Me$1(),Ne(a)){if("selectionStart"in a)var o={start:a.selectionStart,end:a.selectionEnd};else e:{o=(o=a.ownerDocument)&&o.defaultView||window;var s=o.getSelection&&o.getSelection();if(s&&s.rangeCount!==0){o=s.anchorNode;var d=s.anchorOffset,c=s.focusNode;s=s.focusOffset;try{o.nodeType,c.nodeType}catch{o=null;break e}var h=0,_=-1,bt=-1,g=0,j=0,b=a,Et=null;t:for(;;){for(var It;b!==o||d!==0&&b.nodeType!==3||(_=h+d),b!==c||s!==0&&b.nodeType!==3||(bt=h+s),b.nodeType===3&&(h+=b.nodeValue.length),(It=b.firstChild)!==null;)Et=b,b=It;for(;;){if(b===a)break t;if(Et===o&&++g===d&&(_=h),Et===c&&++j===s&&(bt=h),(It=b.nextSibling)!==null)break;b=Et,Et=b.parentNode}b=It}o=_===-1||bt===-1?null:{start:_,end:bt}}else o=null}o=o||{start:0,end:0}}else o=null;for(Df$1={focusedElem:a,selectionRange:o},dd$2=!1,V=e;V!==null;)if(e=V,a=e.child,(e.subtreeFlags&1028)!==0&&a!==null)a.return=e,V=a;else for(;V!==null;){e=V;try{var zt=e.alternate;if(e.flags&1024)switch(e.tag){case 0:case 11:case 15:break;case 1:if(zt!==null){var er=zt.memoizedProps,Hn=zt.memoizedState,Qt=e.stateNode,cr=Qt.getSnapshotBeforeUpdate(e.elementType===e.type?er:Lg(e.type,er),Hn);Qt.__reactInternalSnapshotBeforeUpdate=cr}break;case 3:var fr=e.stateNode.containerInfo;fr.nodeType===1?fr.textContent="":fr.nodeType===9&&fr.documentElement&&fr.removeChild(fr.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163))}}catch(jr){W$1(e,e.return,jr)}if(a=e.sibling,a!==null){a.return=e.return,V=a;break}V=e.return}return zt=Oj,Oj=!1,zt}function Qj(a,e,o){var s=e.updateQueue;if(s=s!==null?s.lastEffect:null,s!==null){var d=s=s.next;do{if((d.tag&a)===a){var c=d.destroy;d.destroy=void 0,c!==void 0&&Nj(e,o,c)}d=d.next}while(d!==s)}}function Rj(a,e){if(e=e.updateQueue,e=e!==null?e.lastEffect:null,e!==null){var o=e=e.next;do{if((o.tag&a)===a){var s=o.create;o.destroy=s()}o=o.next}while(o!==e)}}function Sj(a){var e=a.ref;if(e!==null){var o=a.stateNode;switch(a.tag){case 5:a=o;break;default:a=o}typeof e=="function"?e(a):e.current=a}}function Tj(a){var e=a.alternate;e!==null&&(a.alternate=null,Tj(e)),a.child=null,a.deletions=null,a.sibling=null,a.tag===5&&(e=a.stateNode,e!==null&&(delete e[Of$1],delete e[Pf$1],delete e[of$2],delete e[Qf$1],delete e[Rf$1])),a.stateNode=null,a.return=null,a.dependencies=null,a.memoizedProps=null,a.memoizedState=null,a.pendingProps=null,a.stateNode=null,a.updateQueue=null}function Uj(a){return a.tag===5||a.tag===3||a.tag===4}function Vj(a){e:for(;;){for(;a.sibling===null;){if(a.return===null||Uj(a.return))return null;a=a.return}for(a.sibling.return=a.return,a=a.sibling;a.tag!==5&&a.tag!==6&&a.tag!==18;){if(a.flags&2||a.child===null||a.tag===4)continue e;a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}function Wj(a,e,o){var s=a.tag;if(s===5||s===6)a=a.stateNode,e?o.nodeType===8?o.parentNode.insertBefore(a,e):o.insertBefore(a,e):(o.nodeType===8?(e=o.parentNode,e.insertBefore(a,o)):(e=o,e.appendChild(a)),o=o._reactRootContainer,o!=null||e.onclick!==null||(e.onclick=Bf$1));else if(s!==4&&(a=a.child,a!==null))for(Wj(a,e,o),a=a.sibling;a!==null;)Wj(a,e,o),a=a.sibling}function Xj(a,e,o){var s=a.tag;if(s===5||s===6)a=a.stateNode,e?o.insertBefore(a,e):o.appendChild(a);else if(s!==4&&(a=a.child,a!==null))for(Xj(a,e,o),a=a.sibling;a!==null;)Xj(a,e,o),a=a.sibling}var X=null,Yj=!1;function Zj(a,e,o){for(o=o.child;o!==null;)ak(a,e,o),o=o.sibling}function ak(a,e,o){if(lc$2&&typeof lc$2.onCommitFiberUnmount=="function")try{lc$2.onCommitFiberUnmount(kc$2,o)}catch{}switch(o.tag){case 5:U$1||Mj(o,e);case 6:var s=X,d=Yj;X=null,Zj(a,e,o),X=s,Yj=d,X!==null&&(Yj?(a=X,o=o.stateNode,a.nodeType===8?a.parentNode.removeChild(o):a.removeChild(o)):X.removeChild(o.stateNode));break;case 18:X!==null&&(Yj?(a=X,o=o.stateNode,a.nodeType===8?Kf$1(a.parentNode,o):a.nodeType===1&&Kf$1(a,o),bd$2(a)):Kf$1(X,o.stateNode));break;case 4:s=X,d=Yj,X=o.stateNode.containerInfo,Yj=!0,Zj(a,e,o),X=s,Yj=d;break;case 0:case 11:case 14:case 15:if(!U$1&&(s=o.updateQueue,s!==null&&(s=s.lastEffect,s!==null))){d=s=s.next;do{var c=d,h=c.destroy;c=c.tag,h!==void 0&&(c&2||c&4)&&Nj(o,e,h),d=d.next}while(d!==s)}Zj(a,e,o);break;case 1:if(!U$1&&(Mj(o,e),s=o.stateNode,typeof s.componentWillUnmount=="function"))try{s.props=o.memoizedProps,s.state=o.memoizedState,s.componentWillUnmount()}catch(_){W$1(o,e,_)}Zj(a,e,o);break;case 21:Zj(a,e,o);break;case 22:o.mode&1?(U$1=(s=U$1)||o.memoizedState!==null,Zj(a,e,o),U$1=s):Zj(a,e,o);break;default:Zj(a,e,o)}}function bk(a){var e=a.updateQueue;if(e!==null){a.updateQueue=null;var o=a.stateNode;o===null&&(o=a.stateNode=new Lj),e.forEach(function(s){var d=ck.bind(null,a,s);o.has(s)||(o.add(s),s.then(d,d))})}}function dk(a,e){var o=e.deletions;if(o!==null)for(var s=0;s<o.length;s++){var d=o[s];try{var c=a,h=e,_=h;e:for(;_!==null;){switch(_.tag){case 5:X=_.stateNode,Yj=!1;break e;case 3:X=_.stateNode.containerInfo,Yj=!0;break e;case 4:X=_.stateNode.containerInfo,Yj=!0;break e}_=_.return}if(X===null)throw Error(p(160));ak(c,h,d),X=null,Yj=!1;var bt=d.alternate;bt!==null&&(bt.return=null),d.return=null}catch(g){W$1(d,e,g)}}if(e.subtreeFlags&12854)for(e=e.child;e!==null;)ek(e,a),e=e.sibling}function ek(a,e){var o=a.alternate,s=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:if(dk(e,a),fk(a),s&4){try{Qj(3,a,a.return),Rj(3,a)}catch(er){W$1(a,a.return,er)}try{Qj(5,a,a.return)}catch(er){W$1(a,a.return,er)}}break;case 1:dk(e,a),fk(a),s&512&&o!==null&&Mj(o,o.return);break;case 5:if(dk(e,a),fk(a),s&512&&o!==null&&Mj(o,o.return),a.flags&32){var d=a.stateNode;try{ob$1(d,"")}catch(er){W$1(a,a.return,er)}}if(s&4&&(d=a.stateNode,d!=null)){var c=a.memoizedProps,h=o!==null?o.memoizedProps:c,_=a.type,bt=a.updateQueue;if(a.updateQueue=null,bt!==null)try{_==="input"&&c.type==="radio"&&c.name!=null&&ab$1(d,c),vb$1(_,h);var g=vb$1(_,c);for(h=0;h<bt.length;h+=2){var j=bt[h],b=bt[h+1];j==="style"?sb$1(d,b):j==="dangerouslySetInnerHTML"?nb$1(d,b):j==="children"?ob$1(d,b):ta$1(d,j,b,g)}switch(_){case"input":bb$1(d,c);break;case"textarea":ib$1(d,c);break;case"select":var Et=d._wrapperState.wasMultiple;d._wrapperState.wasMultiple=!!c.multiple;var It=c.value;It!=null?fb$1(d,!!c.multiple,It,!1):Et!==!!c.multiple&&(c.defaultValue!=null?fb$1(d,!!c.multiple,c.defaultValue,!0):fb$1(d,!!c.multiple,c.multiple?[]:"",!1))}d[Pf$1]=c}catch(er){W$1(a,a.return,er)}}break;case 6:if(dk(e,a),fk(a),s&4){if(a.stateNode===null)throw Error(p(162));d=a.stateNode,c=a.memoizedProps;try{d.nodeValue=c}catch(er){W$1(a,a.return,er)}}break;case 3:if(dk(e,a),fk(a),s&4&&o!==null&&o.memoizedState.isDehydrated)try{bd$2(e.containerInfo)}catch(er){W$1(a,a.return,er)}break;case 4:dk(e,a),fk(a);break;case 13:dk(e,a),fk(a),d=a.child,d.flags&8192&&(c=d.memoizedState!==null,d.stateNode.isHidden=c,!c||d.alternate!==null&&d.alternate.memoizedState!==null||(gk=B())),s&4&&bk(a);break;case 22:if(j=o!==null&&o.memoizedState!==null,a.mode&1?(U$1=(g=U$1)||j,dk(e,a),U$1=g):dk(e,a),fk(a),s&8192){if(g=a.memoizedState!==null,(a.stateNode.isHidden=g)&&!j&&a.mode&1)for(V=a,j=a.child;j!==null;){for(b=V=j;V!==null;){switch(Et=V,It=Et.child,Et.tag){case 0:case 11:case 14:case 15:Qj(4,Et,Et.return);break;case 1:Mj(Et,Et.return);var zt=Et.stateNode;if(typeof zt.componentWillUnmount=="function"){s=Et,o=Et.return;try{e=s,zt.props=e.memoizedProps,zt.state=e.memoizedState,zt.componentWillUnmount()}catch(er){W$1(s,o,er)}}break;case 5:Mj(Et,Et.return);break;case 22:if(Et.memoizedState!==null){hk(b);continue}}It!==null?(It.return=Et,V=It):hk(b)}j=j.sibling}e:for(j=null,b=a;;){if(b.tag===5){if(j===null){j=b;try{d=b.stateNode,g?(c=d.style,typeof c.setProperty=="function"?c.setProperty("display","none","important"):c.display="none"):(_=b.stateNode,bt=b.memoizedProps.style,h=bt!=null&&bt.hasOwnProperty("display")?bt.display:null,_.style.display=rb$1("display",h))}catch(er){W$1(a,a.return,er)}}}else if(b.tag===6){if(j===null)try{b.stateNode.nodeValue=g?"":b.memoizedProps}catch(er){W$1(a,a.return,er)}}else if((b.tag!==22&&b.tag!==23||b.memoizedState===null||b===a)&&b.child!==null){b.child.return=b,b=b.child;continue}if(b===a)break e;for(;b.sibling===null;){if(b.return===null||b.return===a)break e;j===b&&(j=null),b=b.return}j===b&&(j=null),b.sibling.return=b.return,b=b.sibling}}break;case 19:dk(e,a),fk(a),s&4&&bk(a);break;case 21:break;default:dk(e,a),fk(a)}}function fk(a){var e=a.flags;if(e&2){try{e:{for(var o=a.return;o!==null;){if(Uj(o)){var s=o;break e}o=o.return}throw Error(p(160))}switch(s.tag){case 5:var d=s.stateNode;s.flags&32&&(ob$1(d,""),s.flags&=-33);var c=Vj(a);Xj(a,c,d);break;case 3:case 4:var h=s.stateNode.containerInfo,_=Vj(a);Wj(a,_,h);break;default:throw Error(p(161))}}catch(bt){W$1(a,a.return,bt)}a.flags&=-3}e&4096&&(a.flags&=-4097)}function ik(a,e,o){V=a,jk(a)}function jk(a,e,o){for(var s=(a.mode&1)!==0;V!==null;){var d=V,c=d.child;if(d.tag===22&&s){var h=d.memoizedState!==null||Kj;if(!h){var _=d.alternate,bt=_!==null&&_.memoizedState!==null||U$1;_=Kj;var g=U$1;if(Kj=h,(U$1=bt)&&!g)for(V=d;V!==null;)h=V,bt=h.child,h.tag===22&&h.memoizedState!==null?kk(d):bt!==null?(bt.return=h,V=bt):kk(d);for(;c!==null;)V=c,jk(c),c=c.sibling;V=d,Kj=_,U$1=g}lk(a)}else d.subtreeFlags&8772&&c!==null?(c.return=d,V=c):lk(a)}}function lk(a){for(;V!==null;){var e=V;if(e.flags&8772){var o=e.alternate;try{if(e.flags&8772)switch(e.tag){case 0:case 11:case 15:U$1||Rj(5,e);break;case 1:var s=e.stateNode;if(e.flags&4&&!U$1)if(o===null)s.componentDidMount();else{var d=e.elementType===e.type?o.memoizedProps:Lg(e.type,o.memoizedProps);s.componentDidUpdate(d,o.memoizedState,s.__reactInternalSnapshotBeforeUpdate)}var c=e.updateQueue;c!==null&&ih$1(e,c,s);break;case 3:var h=e.updateQueue;if(h!==null){if(o=null,e.child!==null)switch(e.child.tag){case 5:o=e.child.stateNode;break;case 1:o=e.child.stateNode}ih$1(e,h,o)}break;case 5:var _=e.stateNode;if(o===null&&e.flags&4){o=_;var bt=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":bt.autoFocus&&o.focus();break;case"img":bt.src&&(o.src=bt.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(e.memoizedState===null){var g=e.alternate;if(g!==null){var j=g.memoizedState;if(j!==null){var b=j.dehydrated;b!==null&&bd$2(b)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(p(163))}U$1||e.flags&512&&Sj(e)}catch(Et){W$1(e,e.return,Et)}}if(e===a){V=null;break}if(o=e.sibling,o!==null){o.return=e.return,V=o;break}V=e.return}}function hk(a){for(;V!==null;){var e=V;if(e===a){V=null;break}var o=e.sibling;if(o!==null){o.return=e.return,V=o;break}V=e.return}}function kk(a){for(;V!==null;){var e=V;try{switch(e.tag){case 0:case 11:case 15:var o=e.return;try{Rj(4,e)}catch(bt){W$1(e,o,bt)}break;case 1:var s=e.stateNode;if(typeof s.componentDidMount=="function"){var d=e.return;try{s.componentDidMount()}catch(bt){W$1(e,d,bt)}}var c=e.return;try{Sj(e)}catch(bt){W$1(e,c,bt)}break;case 5:var h=e.return;try{Sj(e)}catch(bt){W$1(e,h,bt)}}}catch(bt){W$1(e,e.return,bt)}if(e===a){V=null;break}var _=e.sibling;if(_!==null){_.return=e.return,V=_;break}V=e.return}}var mk=Math.ceil,nk=ua$2.ReactCurrentDispatcher,ok=ua$2.ReactCurrentOwner,pk=ua$2.ReactCurrentBatchConfig,K$1=0,R$1=null,Y=null,Z$1=0,gj=0,fj=Uf$1(0),T=0,qk=null,hh$1=0,rk=0,sk=0,tk=null,uk=null,gk=0,Hj=1/0,vk=null,Pi$2=!1,Qi$2=null,Si$2=null,wk=!1,xk=null,yk=0,zk=0,Ak=null,Bk=-1,Ck=0;function L(){return K$1&6?B():Bk!==-1?Bk:Bk=B()}function lh$1(a){return a.mode&1?K$1&2&&Z$1!==0?Z$1&-Z$1:Kg.transition!==null?(Ck===0&&(Ck=yc$2()),Ck):(a=C,a!==0||(a=window.event,a=a===void 0?16:jd$2(a.type)),a):1}function mh$1(a,e,o,s){if(50<zk)throw zk=0,Ak=null,Error(p(185));Ac$2(a,o,s),(!(K$1&2)||a!==R$1)&&(a===R$1&&(!(K$1&2)&&(rk|=o),T===4&&Dk(a,Z$1)),Ek(a,s),o===1&&K$1===0&&!(e.mode&1)&&(Hj=B()+500,fg$1&&jg()))}function Ek(a,e){var o=a.callbackNode;wc$2(a,e);var s=uc$2(a,a===R$1?Z$1:0);if(s===0)o!==null&&bc$2(o),a.callbackNode=null,a.callbackPriority=0;else if(e=s&-s,a.callbackPriority!==e){if(o!=null&&bc$2(o),e===1)a.tag===0?ig$1(Fk.bind(null,a)):hg$1(Fk.bind(null,a)),Jf$1(function(){!(K$1&6)&&jg()}),o=null;else{switch(Dc$2(s)){case 1:o=fc$2;break;case 4:o=gc$2;break;case 16:o=hc$2;break;case 536870912:o=jc$2;break;default:o=hc$2}o=Gk(o,Hk.bind(null,a))}a.callbackPriority=e,a.callbackNode=o}}function Hk(a,e){if(Bk=-1,Ck=0,K$1&6)throw Error(p(327));var o=a.callbackNode;if(Ik()&&a.callbackNode!==o)return null;var s=uc$2(a,a===R$1?Z$1:0);if(s===0)return null;if(s&30||s&a.expiredLanes||e)e=Jk(a,s);else{e=s;var d=K$1;K$1|=2;var c=Kk();(R$1!==a||Z$1!==e)&&(vk=null,Hj=B()+500,Lk(a,e));do try{Mk();break}catch(_){Nk(a,_)}while(!0);Qg(),nk.current=c,K$1=d,Y!==null?e=0:(R$1=null,Z$1=0,e=T)}if(e!==0){if(e===2&&(d=xc$2(a),d!==0&&(s=d,e=Ok(a,d))),e===1)throw o=qk,Lk(a,0),Dk(a,s),Ek(a,B()),o;if(e===6)Dk(a,s);else{if(d=a.current.alternate,!(s&30)&&!Pk(d)&&(e=Jk(a,s),e===2&&(c=xc$2(a),c!==0&&(s=c,e=Ok(a,c))),e===1))throw o=qk,Lk(a,0),Dk(a,s),Ek(a,B()),o;switch(a.finishedWork=d,a.finishedLanes=s,e){case 0:case 1:throw Error(p(345));case 2:Qk(a,uk,vk);break;case 3:if(Dk(a,s),(s&130023424)===s&&(e=gk+500-B(),10<e)){if(uc$2(a,0)!==0)break;if(d=a.suspendedLanes,(d&s)!==s){L(),a.pingedLanes|=a.suspendedLanes&d;break}a.timeoutHandle=Ff$1(Qk.bind(null,a,uk,vk),e);break}Qk(a,uk,vk);break;case 4:if(Dk(a,s),(s&4194240)===s)break;for(e=a.eventTimes,d=-1;0<s;){var h=31-oc$2(s);c=1<<h,h=e[h],h>d&&(d=h),s&=~c}if(s=d,s=B()-s,s=(120>s?120:480>s?480:1080>s?1080:1920>s?1920:3e3>s?3e3:4320>s?4320:1960*mk(s/1960))-s,10<s){a.timeoutHandle=Ff$1(Qk.bind(null,a,uk,vk),s);break}Qk(a,uk,vk);break;case 5:Qk(a,uk,vk);break;default:throw Error(p(329))}}}return Ek(a,B()),a.callbackNode===o?Hk.bind(null,a):null}function Ok(a,e){var o=tk;return a.current.memoizedState.isDehydrated&&(Lk(a,e).flags|=256),a=Jk(a,e),a!==2&&(e=uk,uk=o,e!==null&&Gj(e)),a}function Gj(a){uk===null?uk=a:uk.push.apply(uk,a)}function Pk(a){for(var e=a;;){if(e.flags&16384){var o=e.updateQueue;if(o!==null&&(o=o.stores,o!==null))for(var s=0;s<o.length;s++){var d=o[s],c=d.getSnapshot;d=d.value;try{if(!He$1(c(),d))return!1}catch{return!1}}}if(o=e.child,e.subtreeFlags&16384&&o!==null)o.return=e,e=o;else{if(e===a)break;for(;e.sibling===null;){if(e.return===null||e.return===a)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}function Dk(a,e){for(e&=~sk,e&=~rk,a.suspendedLanes|=e,a.pingedLanes&=~e,a=a.expirationTimes;0<e;){var o=31-oc$2(e),s=1<<o;a[o]=-1,e&=~s}}function Fk(a){if(K$1&6)throw Error(p(327));Ik();var e=uc$2(a,0);if(!(e&1))return Ek(a,B()),null;var o=Jk(a,e);if(a.tag!==0&&o===2){var s=xc$2(a);s!==0&&(e=s,o=Ok(a,s))}if(o===1)throw o=qk,Lk(a,0),Dk(a,e),Ek(a,B()),o;if(o===6)throw Error(p(345));return a.finishedWork=a.current.alternate,a.finishedLanes=e,Qk(a,uk,vk),Ek(a,B()),null}function Rk(a,e){var o=K$1;K$1|=1;try{return a(e)}finally{K$1=o,K$1===0&&(Hj=B()+500,fg$1&&jg())}}function Sk(a){xk!==null&&xk.tag===0&&!(K$1&6)&&Ik();var e=K$1;K$1|=1;var o=pk.transition,s=C;try{if(pk.transition=null,C=1,a)return a()}finally{C=s,pk.transition=o,K$1=e,!(K$1&6)&&jg()}}function Ij(){gj=fj.current,E$1(fj)}function Lk(a,e){a.finishedWork=null,a.finishedLanes=0;var o=a.timeoutHandle;if(o!==-1&&(a.timeoutHandle=-1,Gf$1(o)),Y!==null)for(o=Y.return;o!==null;){var s=o;switch(wg$1(s),s.tag){case 1:s=s.type.childContextTypes,s!=null&&$f$1();break;case 3:Jh$1(),E$1(Wf$1),E$1(H),Oh$1();break;case 5:Lh$1(s);break;case 4:Jh$1();break;case 13:E$1(M$1);break;case 19:E$1(M$1);break;case 10:Rg(s.type._context);break;case 22:case 23:Ij()}o=o.return}if(R$1=a,Y=a=wh$1(a.current,null),Z$1=gj=e,T=0,qk=null,sk=rk=hh$1=0,uk=tk=null,Wg!==null){for(e=0;e<Wg.length;e++)if(o=Wg[e],s=o.interleaved,s!==null){o.interleaved=null;var d=s.next,c=o.pending;if(c!==null){var h=c.next;c.next=d,s.next=h}o.pending=s}Wg=null}return a}function Nk(a,e){do{var o=Y;try{if(Qg(),Ph$1.current=ai,Sh$1){for(var s=N.memoizedState;s!==null;){var d=s.queue;d!==null&&(d.pending=null),s=s.next}Sh$1=!1}if(Rh$1=0,P=O$1=N=null,Th$1=!1,Uh$1=0,ok.current=null,o===null||o.return===null){T=1,qk=e,Y=null;break}e:{var c=a,h=o.return,_=o,bt=e;if(e=Z$1,_.flags|=32768,bt!==null&&typeof bt=="object"&&typeof bt.then=="function"){var g=bt,j=_,b=j.tag;if(!(j.mode&1)&&(b===0||b===11||b===15)){var Et=j.alternate;Et?(j.updateQueue=Et.updateQueue,j.memoizedState=Et.memoizedState,j.lanes=Et.lanes):(j.updateQueue=null,j.memoizedState=null)}var It=Vi$2(h);if(It!==null){It.flags&=-257,Wi$2(It,h,_,c,e),It.mode&1&&Ti$2(c,g,e),e=It,bt=g;var zt=e.updateQueue;if(zt===null){var er=new Set;er.add(bt),e.updateQueue=er}else zt.add(bt);break e}else{if(!(e&1)){Ti$2(c,g,e),uj();break e}bt=Error(p(426))}}else if(I&&_.mode&1){var Hn=Vi$2(h);if(Hn!==null){!(Hn.flags&65536)&&(Hn.flags|=256),Wi$2(Hn,h,_,c,e),Jg(Ki$2(bt,_));break e}}c=bt=Ki$2(bt,_),T!==4&&(T=2),tk===null?tk=[c]:tk.push(c),c=h;do{switch(c.tag){case 3:c.flags|=65536,e&=-e,c.lanes|=e;var Qt=Oi$2(c,bt,e);fh$1(c,Qt);break e;case 1:_=bt;var cr=c.type,fr=c.stateNode;if(!(c.flags&128)&&(typeof cr.getDerivedStateFromError=="function"||fr!==null&&typeof fr.componentDidCatch=="function"&&(Si$2===null||!Si$2.has(fr)))){c.flags|=65536,e&=-e,c.lanes|=e;var jr=Ri$2(c,_,e);fh$1(c,jr);break e}}c=c.return}while(c!==null)}Tk(o)}catch(e0){e=e0,Y===o&&o!==null&&(Y=o=o.return);continue}break}while(!0)}function Kk(){var a=nk.current;return nk.current=ai,a===null?ai:a}function uj(){(T===0||T===3||T===2)&&(T=4),R$1===null||!(hh$1&268435455)&&!(rk&268435455)||Dk(R$1,Z$1)}function Jk(a,e){var o=K$1;K$1|=2;var s=Kk();(R$1!==a||Z$1!==e)&&(vk=null,Lk(a,e));do try{Uk();break}catch(d){Nk(a,d)}while(!0);if(Qg(),K$1=o,nk.current=s,Y!==null)throw Error(p(261));return R$1=null,Z$1=0,T}function Uk(){for(;Y!==null;)Vk(Y)}function Mk(){for(;Y!==null&&!cc$2();)Vk(Y)}function Vk(a){var e=Wk(a.alternate,a,gj);a.memoizedProps=a.pendingProps,e===null?Tk(a):Y=e,ok.current=null}function Tk(a){var e=a;do{var o=e.alternate;if(a=e.return,e.flags&32768){if(o=Jj(o,e),o!==null){o.flags&=32767,Y=o;return}if(a!==null)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else{T=6,Y=null;return}}else if(o=Fj(o,e,gj),o!==null){Y=o;return}if(e=e.sibling,e!==null){Y=e;return}Y=e=a}while(e!==null);T===0&&(T=5)}function Qk(a,e,o){var s=C,d=pk.transition;try{pk.transition=null,C=1,Xk(a,e,o,s)}finally{pk.transition=d,C=s}return null}function Xk(a,e,o,s){do Ik();while(xk!==null);if(K$1&6)throw Error(p(327));o=a.finishedWork;var d=a.finishedLanes;if(o===null)return null;if(a.finishedWork=null,a.finishedLanes=0,o===a.current)throw Error(p(177));a.callbackNode=null,a.callbackPriority=0;var c=o.lanes|o.childLanes;if(Bc$2(a,c),a===R$1&&(Y=R$1=null,Z$1=0),!(o.subtreeFlags&2064)&&!(o.flags&2064)||wk||(wk=!0,Gk(hc$2,function(){return Ik(),null})),c=(o.flags&15990)!==0,o.subtreeFlags&15990||c){c=pk.transition,pk.transition=null;var h=C;C=1;var _=K$1;K$1|=4,ok.current=null,Pj(a,o),ek(o,a),Oe$2(Df$1),dd$2=!!Cf$1,Df$1=Cf$1=null,a.current=o,ik(o),dc$2(),K$1=_,C=h,pk.transition=c}else a.current=o;if(wk&&(wk=!1,xk=a,yk=d),c=a.pendingLanes,c===0&&(Si$2=null),mc$2(o.stateNode),Ek(a,B()),e!==null)for(s=a.onRecoverableError,o=0;o<e.length;o++)d=e[o],s(d.value,{componentStack:d.stack,digest:d.digest});if(Pi$2)throw Pi$2=!1,a=Qi$2,Qi$2=null,a;return yk&1&&a.tag!==0&&Ik(),c=a.pendingLanes,c&1?a===Ak?zk++:(zk=0,Ak=a):zk=0,jg(),null}function Ik(){if(xk!==null){var a=Dc$2(yk),e=pk.transition,o=C;try{if(pk.transition=null,C=16>a?16:a,xk===null)var s=!1;else{if(a=xk,xk=null,yk=0,K$1&6)throw Error(p(331));var d=K$1;for(K$1|=4,V=a.current;V!==null;){var c=V,h=c.child;if(V.flags&16){var _=c.deletions;if(_!==null){for(var bt=0;bt<_.length;bt++){var g=_[bt];for(V=g;V!==null;){var j=V;switch(j.tag){case 0:case 11:case 15:Qj(8,j,c)}var b=j.child;if(b!==null)b.return=j,V=b;else for(;V!==null;){j=V;var Et=j.sibling,It=j.return;if(Tj(j),j===g){V=null;break}if(Et!==null){Et.return=It,V=Et;break}V=It}}}var zt=c.alternate;if(zt!==null){var er=zt.child;if(er!==null){zt.child=null;do{var Hn=er.sibling;er.sibling=null,er=Hn}while(er!==null)}}V=c}}if(c.subtreeFlags&2064&&h!==null)h.return=c,V=h;else e:for(;V!==null;){if(c=V,c.flags&2048)switch(c.tag){case 0:case 11:case 15:Qj(9,c,c.return)}var Qt=c.sibling;if(Qt!==null){Qt.return=c.return,V=Qt;break e}V=c.return}}var cr=a.current;for(V=cr;V!==null;){h=V;var fr=h.child;if(h.subtreeFlags&2064&&fr!==null)fr.return=h,V=fr;else e:for(h=cr;V!==null;){if(_=V,_.flags&2048)try{switch(_.tag){case 0:case 11:case 15:Rj(9,_)}}catch(e0){W$1(_,_.return,e0)}if(_===h){V=null;break e}var jr=_.sibling;if(jr!==null){jr.return=_.return,V=jr;break e}V=_.return}}if(K$1=d,jg(),lc$2&&typeof lc$2.onPostCommitFiberRoot=="function")try{lc$2.onPostCommitFiberRoot(kc$2,a)}catch{}s=!0}return s}finally{C=o,pk.transition=e}}return!1}function Yk(a,e,o){e=Ki$2(o,e),e=Oi$2(a,e,1),a=dh$1(a,e,1),e=L(),a!==null&&(Ac$2(a,1,e),Ek(a,e))}function W$1(a,e,o){if(a.tag===3)Yk(a,a,o);else for(;e!==null;){if(e.tag===3){Yk(e,a,o);break}else if(e.tag===1){var s=e.stateNode;if(typeof e.type.getDerivedStateFromError=="function"||typeof s.componentDidCatch=="function"&&(Si$2===null||!Si$2.has(s))){a=Ki$2(o,a),a=Ri$2(e,a,1),e=dh$1(e,a,1),a=L(),e!==null&&(Ac$2(e,1,a),Ek(e,a));break}}e=e.return}}function Ui$2(a,e,o){var s=a.pingCache;s!==null&&s.delete(e),e=L(),a.pingedLanes|=a.suspendedLanes&o,R$1===a&&(Z$1&o)===o&&(T===4||T===3&&(Z$1&130023424)===Z$1&&500>B()-gk?Lk(a,0):sk|=o),Ek(a,e)}function Zk(a,e){e===0&&(a.mode&1?(e=sc$2,sc$2<<=1,!(sc$2&130023424)&&(sc$2=4194304)):e=1);var o=L();a=Zg(a,e),a!==null&&(Ac$2(a,e,o),Ek(a,o))}function vj(a){var e=a.memoizedState,o=0;e!==null&&(o=e.retryLane),Zk(a,o)}function ck(a,e){var o=0;switch(a.tag){case 13:var s=a.stateNode,d=a.memoizedState;d!==null&&(o=d.retryLane);break;case 19:s=a.stateNode;break;default:throw Error(p(314))}s!==null&&s.delete(e),Zk(a,o)}var Wk;Wk=function(a,e,o){if(a!==null)if(a.memoizedProps!==e.pendingProps||Wf$1.current)Ug=!0;else{if(!(a.lanes&o)&&!(e.flags&128))return Ug=!1,zj(a,e,o);Ug=!!(a.flags&131072)}else Ug=!1,I&&e.flags&1048576&&ug(e,ng$1,e.index);switch(e.lanes=0,e.tag){case 2:var s=e.type;jj(a,e),a=e.pendingProps;var d=Yf$1(e,H.current);Tg(e,o),d=Xh$1(null,e,s,a,d,o);var c=bi$2();return e.flags|=1,typeof d=="object"&&d!==null&&typeof d.render=="function"&&d.$$typeof===void 0?(e.tag=1,e.memoizedState=null,e.updateQueue=null,Zf$1(s)?(c=!0,cg$1(e)):c=!1,e.memoizedState=d.state!==null&&d.state!==void 0?d.state:null,ah$1(e),d.updater=nh$1,e.stateNode=d,d._reactInternals=e,rh$1(e,s,a,o),e=kj(null,e,s,!0,c,o)):(e.tag=0,I&&c&&vg$1(e),Yi$2(null,e,d,o),e=e.child),e;case 16:s=e.elementType;e:{switch(jj(a,e),a=e.pendingProps,d=s._init,s=d(s._payload),e.type=s,d=e.tag=$k(s),a=Lg(s,a),d){case 0:e=dj(null,e,s,a,o);break e;case 1:e=ij(null,e,s,a,o);break e;case 11:e=Zi$2(null,e,s,a,o);break e;case 14:e=aj(null,e,s,Lg(s.type,a),o);break e}throw Error(p(306,s,""))}return e;case 0:return s=e.type,d=e.pendingProps,d=e.elementType===s?d:Lg(s,d),dj(a,e,s,d,o);case 1:return s=e.type,d=e.pendingProps,d=e.elementType===s?d:Lg(s,d),ij(a,e,s,d,o);case 3:e:{if(lj(e),a===null)throw Error(p(387));s=e.pendingProps,c=e.memoizedState,d=c.element,bh$1(a,e),gh$1(e,s,null,o);var h=e.memoizedState;if(s=h.element,c.isDehydrated)if(c={element:s,isDehydrated:!1,cache:h.cache,pendingSuspenseBoundaries:h.pendingSuspenseBoundaries,transitions:h.transitions},e.updateQueue.baseState=c,e.memoizedState=c,e.flags&256){d=Ki$2(Error(p(423)),e),e=mj(a,e,s,o,d);break e}else if(s!==d){d=Ki$2(Error(p(424)),e),e=mj(a,e,s,o,d);break e}else for(yg$1=Lf$1(e.stateNode.containerInfo.firstChild),xg=e,I=!0,zg=null,o=Ch$1(e,null,s,o),e.child=o;o;)o.flags=o.flags&-3|4096,o=o.sibling;else{if(Ig(),s===d){e=$i$2(a,e,o);break e}Yi$2(a,e,s,o)}e=e.child}return e;case 5:return Kh$1(e),a===null&&Eg(e),s=e.type,d=e.pendingProps,c=a!==null?a.memoizedProps:null,h=d.children,Ef$1(s,d)?h=null:c!==null&&Ef$1(s,c)&&(e.flags|=32),hj(a,e),Yi$2(a,e,h,o),e.child;case 6:return a===null&&Eg(e),null;case 13:return pj(a,e,o);case 4:return Ih$1(e,e.stateNode.containerInfo),s=e.pendingProps,a===null?e.child=Bh$1(e,null,s,o):Yi$2(a,e,s,o),e.child;case 11:return s=e.type,d=e.pendingProps,d=e.elementType===s?d:Lg(s,d),Zi$2(a,e,s,d,o);case 7:return Yi$2(a,e,e.pendingProps,o),e.child;case 8:return Yi$2(a,e,e.pendingProps.children,o),e.child;case 12:return Yi$2(a,e,e.pendingProps.children,o),e.child;case 10:e:{if(s=e.type._context,d=e.pendingProps,c=e.memoizedProps,h=d.value,G(Mg,s._currentValue),s._currentValue=h,c!==null)if(He$1(c.value,h)){if(c.children===d.children&&!Wf$1.current){e=$i$2(a,e,o);break e}}else for(c=e.child,c!==null&&(c.return=e);c!==null;){var _=c.dependencies;if(_!==null){h=c.child;for(var bt=_.firstContext;bt!==null;){if(bt.context===s){if(c.tag===1){bt=ch$1(-1,o&-o),bt.tag=2;var g=c.updateQueue;if(g!==null){g=g.shared;var j=g.pending;j===null?bt.next=bt:(bt.next=j.next,j.next=bt),g.pending=bt}}c.lanes|=o,bt=c.alternate,bt!==null&&(bt.lanes|=o),Sg(c.return,o,e),_.lanes|=o;break}bt=bt.next}}else if(c.tag===10)h=c.type===e.type?null:c.child;else if(c.tag===18){if(h=c.return,h===null)throw Error(p(341));h.lanes|=o,_=h.alternate,_!==null&&(_.lanes|=o),Sg(h,o,e),h=c.sibling}else h=c.child;if(h!==null)h.return=c;else for(h=c;h!==null;){if(h===e){h=null;break}if(c=h.sibling,c!==null){c.return=h.return,h=c;break}h=h.return}c=h}Yi$2(a,e,d.children,o),e=e.child}return e;case 9:return d=e.type,s=e.pendingProps.children,Tg(e,o),d=Vg(d),s=s(d),e.flags|=1,Yi$2(a,e,s,o),e.child;case 14:return s=e.type,d=Lg(s,e.pendingProps),d=Lg(s.type,d),aj(a,e,s,d,o);case 15:return cj(a,e,e.type,e.pendingProps,o);case 17:return s=e.type,d=e.pendingProps,d=e.elementType===s?d:Lg(s,d),jj(a,e),e.tag=1,Zf$1(s)?(a=!0,cg$1(e)):a=!1,Tg(e,o),ph(e,s,d),rh$1(e,s,d,o),kj(null,e,s,!0,a,o);case 19:return yj(a,e,o);case 22:return ej(a,e,o)}throw Error(p(156,e.tag))};function Gk(a,e){return ac$2(a,e)}function al$2(a,e,o,s){this.tag=a,this.key=o,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=s,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Bg(a,e,o,s){return new al$2(a,e,o,s)}function bj(a){return a=a.prototype,!(!a||!a.isReactComponent)}function $k(a){if(typeof a=="function")return bj(a)?1:0;if(a!=null){if(a=a.$$typeof,a===Da$1)return 11;if(a===Ga)return 14}return 2}function wh$1(a,e){var o=a.alternate;return o===null?(o=Bg(a.tag,e,a.key,a.mode),o.elementType=a.elementType,o.type=a.type,o.stateNode=a.stateNode,o.alternate=a,a.alternate=o):(o.pendingProps=e,o.type=a.type,o.flags=0,o.subtreeFlags=0,o.deletions=null),o.flags=a.flags&14680064,o.childLanes=a.childLanes,o.lanes=a.lanes,o.child=a.child,o.memoizedProps=a.memoizedProps,o.memoizedState=a.memoizedState,o.updateQueue=a.updateQueue,e=a.dependencies,o.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext},o.sibling=a.sibling,o.index=a.index,o.ref=a.ref,o}function yh$1(a,e,o,s,d,c){var h=2;if(s=a,typeof a=="function")bj(a)&&(h=1);else if(typeof a=="string")h=5;else e:switch(a){case ya$1:return Ah(o.children,d,c,e);case za$1:h=8,d|=8;break;case Aa$1:return a=Bg(12,o,e,d|2),a.elementType=Aa$1,a.lanes=c,a;case Ea$1:return a=Bg(13,o,e,d),a.elementType=Ea$1,a.lanes=c,a;case Fa:return a=Bg(19,o,e,d),a.elementType=Fa,a.lanes=c,a;case Ia$1:return qj(o,d,c,e);default:if(typeof a=="object"&&a!==null)switch(a.$$typeof){case Ba$1:h=10;break e;case Ca$1:h=9;break e;case Da$1:h=11;break e;case Ga:h=14;break e;case Ha$1:h=16,s=null;break e}throw Error(p(130,a==null?a:typeof a,""))}return e=Bg(h,o,e,d),e.elementType=a,e.type=s,e.lanes=c,e}function Ah(a,e,o,s){return a=Bg(7,a,s,e),a.lanes=o,a}function qj(a,e,o,s){return a=Bg(22,a,s,e),a.elementType=Ia$1,a.lanes=o,a.stateNode={isHidden:!1},a}function xh$1(a,e,o){return a=Bg(6,a,null,e),a.lanes=o,a}function zh$1(a,e,o){return e=Bg(4,a.children!==null?a.children:[],a.key,e),e.lanes=o,e.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation},e}function bl$2(a,e,o,s,d){this.tag=e,this.containerInfo=a,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=zc$2(0),this.expirationTimes=zc$2(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=zc$2(0),this.identifierPrefix=s,this.onRecoverableError=d,this.mutableSourceEagerHydrationData=null}function cl$2(a,e,o,s,d,c,h,_,bt){return a=new bl$2(a,e,o,_,bt),e===1?(e=1,c===!0&&(e|=8)):e=0,c=Bg(3,null,null,e),a.current=c,c.stateNode=a,c.memoizedState={element:s,isDehydrated:o,cache:null,transitions:null,pendingSuspenseBoundaries:null},ah$1(c),a}function dl$2(a,e,o){var s=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:wa$1,key:s==null?null:""+s,children:a,containerInfo:e,implementation:o}}function el$2(a){if(!a)return Vf$1;a=a._reactInternals;e:{if(Vb$1(a)!==a||a.tag!==1)throw Error(p(170));var e=a;do{switch(e.tag){case 3:e=e.stateNode.context;break e;case 1:if(Zf$1(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break e}}e=e.return}while(e!==null);throw Error(p(171))}if(a.tag===1){var o=a.type;if(Zf$1(o))return bg$1(a,o,e)}return e}function fl$3(a,e,o,s,d,c,h,_,bt){return a=cl$2(o,s,!0,a,d,c,h,_,bt),a.context=el$2(null),o=a.current,s=L(),d=lh$1(o),c=ch$1(s,d),c.callback=e??null,dh$1(o,c,d),a.current.lanes=d,Ac$2(a,d,s),Ek(a,s),a}function gl$2(a,e,o,s){var d=e.current,c=L(),h=lh$1(d);return o=el$2(o),e.context===null?e.context=o:e.pendingContext=o,e=ch$1(c,h),e.payload={element:a},s=s===void 0?null:s,s!==null&&(e.callback=s),a=dh$1(d,e,h),a!==null&&(mh$1(a,d,h,c),eh$1(a,d,h)),h}function hl$2(a){if(a=a.current,!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function il$2(a,e){if(a=a.memoizedState,a!==null&&a.dehydrated!==null){var o=a.retryLane;a.retryLane=o!==0&&o<e?o:e}}function jl$2(a,e){il$2(a,e),(a=a.alternate)&&il$2(a,e)}function kl$2(){return null}var ll$2=typeof reportError=="function"?reportError:function(a){console.error(a)};function ml$2(a){this._internalRoot=a}nl$2.prototype.render=ml$2.prototype.render=function(a){var e=this._internalRoot;if(e===null)throw Error(p(409));gl$2(a,e,null,null)};nl$2.prototype.unmount=ml$2.prototype.unmount=function(){var a=this._internalRoot;if(a!==null){this._internalRoot=null;var e=a.containerInfo;Sk(function(){gl$2(null,a,null,null)}),e[uf$2]=null}};function nl$2(a){this._internalRoot=a}nl$2.prototype.unstable_scheduleHydration=function(a){if(a){var e=Hc$2();a={blockedOn:null,target:a,priority:e};for(var o=0;o<Qc$2.length&&e!==0&&e<Qc$2[o].priority;o++);Qc$2.splice(o,0,a),o===0&&Vc$2(a)}};function ol$2(a){return!(!a||a.nodeType!==1&&a.nodeType!==9&&a.nodeType!==11)}function pl$2(a){return!(!a||a.nodeType!==1&&a.nodeType!==9&&a.nodeType!==11&&(a.nodeType!==8||a.nodeValue!==" react-mount-point-unstable "))}function ql$2(){}function rl$2(a,e,o,s,d){if(d){if(typeof s=="function"){var c=s;s=function(){var g=hl$2(h);c.call(g)}}var h=fl$3(e,s,a,0,null,!1,!1,"",ql$2);return a._reactRootContainer=h,a[uf$2]=h.current,sf$2(a.nodeType===8?a.parentNode:a),Sk(),h}for(;d=a.lastChild;)a.removeChild(d);if(typeof s=="function"){var _=s;s=function(){var g=hl$2(bt);_.call(g)}}var bt=cl$2(a,0,!1,null,null,!1,!1,"",ql$2);return a._reactRootContainer=bt,a[uf$2]=bt.current,sf$2(a.nodeType===8?a.parentNode:a),Sk(function(){gl$2(e,bt,o,s)}),bt}function sl$2(a,e,o,s,d){var c=o._reactRootContainer;if(c){var h=c;if(typeof d=="function"){var _=d;d=function(){var bt=hl$2(h);_.call(bt)}}gl$2(e,h,a,d)}else h=rl$2(o,e,a,d,s);return hl$2(h)}Ec$2=function(a){switch(a.tag){case 3:var e=a.stateNode;if(e.current.memoizedState.isDehydrated){var o=tc$2(e.pendingLanes);o!==0&&(Cc$2(e,o|1),Ek(e,B()),!(K$1&6)&&(Hj=B()+500,jg()))}break;case 13:Sk(function(){var s=Zg(a,1);if(s!==null){var d=L();mh$1(s,a,1,d)}}),jl$2(a,1)}};Fc$2=function(a){if(a.tag===13){var e=Zg(a,134217728);if(e!==null){var o=L();mh$1(e,a,134217728,o)}jl$2(a,134217728)}};Gc$2=function(a){if(a.tag===13){var e=lh$1(a),o=Zg(a,e);if(o!==null){var s=L();mh$1(o,a,e,s)}jl$2(a,e)}};Hc$2=function(){return C};Ic$2=function(a,e){var o=C;try{return C=a,e()}finally{C=o}};yb$1=function(a,e,o){switch(e){case"input":if(bb$1(a,o),e=o.name,o.type==="radio"&&e!=null){for(o=a;o.parentNode;)o=o.parentNode;for(o=o.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<o.length;e++){var s=o[e];if(s!==a&&s.form===a.form){var d=Db$1(s);if(!d)throw Error(p(90));Wa(s),bb$1(s,d)}}}break;case"textarea":ib$1(a,o);break;case"select":e=o.value,e!=null&&fb$1(a,!!o.multiple,e,!1)}};Gb$1=Rk;Hb$1=Sk;var tl$1={usingClientEntryPoint:!1,Events:[Cb$1,ue,Db$1,Eb$1,Fb$1,Rk]},ul$2={findFiberByHostInstance:Wc$2,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},vl$2={bundleType:ul$2.bundleType,version:ul$2.version,rendererPackageName:ul$2.rendererPackageName,rendererConfig:ul$2.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua$2.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){return a=Zb$1(a),a===null?null:a.stateNode},findFiberByHostInstance:ul$2.findFiberByHostInstance||kl$2,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var wl$2=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!wl$2.isDisabled&&wl$2.supportsFiber)try{kc$2=wl$2.inject(vl$2),lc$2=wl$2}catch{}}reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=tl$1;reactDom_production_min.createPortal=function(a,e){var o=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!ol$2(e))throw Error(p(200));return dl$2(a,e,null,o)};reactDom_production_min.createRoot=function(a,e){if(!ol$2(a))throw Error(p(299));var o=!1,s="",d=ll$2;return e!=null&&(e.unstable_strictMode===!0&&(o=!0),e.identifierPrefix!==void 0&&(s=e.identifierPrefix),e.onRecoverableError!==void 0&&(d=e.onRecoverableError)),e=cl$2(a,1,!1,null,null,o,!1,s,d),a[uf$2]=e.current,sf$2(a.nodeType===8?a.parentNode:a),new ml$2(e)};reactDom_production_min.findDOMNode=function(a){if(a==null)return null;if(a.nodeType===1)return a;var e=a._reactInternals;if(e===void 0)throw typeof a.render=="function"?Error(p(188)):(a=Object.keys(a).join(","),Error(p(268,a)));return a=Zb$1(e),a=a===null?null:a.stateNode,a};reactDom_production_min.flushSync=function(a){return Sk(a)};reactDom_production_min.hydrate=function(a,e,o){if(!pl$2(e))throw Error(p(200));return sl$2(null,a,e,!0,o)};reactDom_production_min.hydrateRoot=function(a,e,o){if(!ol$2(a))throw Error(p(405));var s=o!=null&&o.hydratedSources||null,d=!1,c="",h=ll$2;if(o!=null&&(o.unstable_strictMode===!0&&(d=!0),o.identifierPrefix!==void 0&&(c=o.identifierPrefix),o.onRecoverableError!==void 0&&(h=o.onRecoverableError)),e=fl$3(e,null,a,1,o??null,d,!1,c,h),a[uf$2]=e.current,sf$2(a),s)for(a=0;a<s.length;a++)o=s[a],d=o._getVersion,d=d(o._source),e.mutableSourceEagerHydrationData==null?e.mutableSourceEagerHydrationData=[o,d]:e.mutableSourceEagerHydrationData.push(o,d);return new nl$2(e)};reactDom_production_min.render=function(a,e,o){if(!pl$2(e))throw Error(p(200));return sl$2(null,a,e,!1,o)};reactDom_production_min.unmountComponentAtNode=function(a){if(!pl$2(a))throw Error(p(40));return a._reactRootContainer?(Sk(function(){sl$2(null,null,a,!1,function(){a._reactRootContainer=null,a[uf$2]=null})}),!0):!1};reactDom_production_min.unstable_batchedUpdates=Rk;reactDom_production_min.unstable_renderSubtreeIntoContainer=function(a,e,o,s){if(!pl$2(o))throw Error(p(200));if(a==null||a._reactInternals===void 0)throw Error(p(38));return sl$2(a,e,o,!1,s)};reactDom_production_min.version="18.2.0-next-9e3b772b8-20220608";function checkDCE(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)}catch(a){console.error(a)}}checkDCE(),reactDom.exports=reactDom_production_min;var reactDomExports=reactDom.exports,m=reactDomExports;client.createRoot=m.createRoot,client.hydrateRoot=m.hydrateRoot;/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const REVISION="162",MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},CullFaceNone=0,CullFaceBack=1,CullFaceFront=2,CullFaceFrontBack=3,BasicShadowMap=0,PCFShadowMap=1,PCFSoftShadowMap=2,VSMShadowMap=3,FrontSide=0,BackSide=1,DoubleSide=2,NoBlending=0,NormalBlending=1,AdditiveBlending=2,SubtractiveBlending=3,MultiplyBlending=4,CustomBlending=5,AddEquation=100,SubtractEquation=101,ReverseSubtractEquation=102,MinEquation=103,MaxEquation=104,ZeroFactor=200,OneFactor=201,SrcColorFactor=202,OneMinusSrcColorFactor=203,SrcAlphaFactor=204,OneMinusSrcAlphaFactor=205,DstAlphaFactor=206,OneMinusDstAlphaFactor=207,DstColorFactor=208,OneMinusDstColorFactor=209,SrcAlphaSaturateFactor=210,ConstantColorFactor=211,OneMinusConstantColorFactor=212,ConstantAlphaFactor=213,OneMinusConstantAlphaFactor=214,NeverDepth=0,AlwaysDepth=1,LessDepth=2,LessEqualDepth=3,EqualDepth=4,GreaterEqualDepth=5,GreaterDepth=6,NotEqualDepth=7,MultiplyOperation=0,MixOperation=1,AddOperation=2,NoToneMapping=0,LinearToneMapping=1,ReinhardToneMapping=2,CineonToneMapping=3,ACESFilmicToneMapping=4,CustomToneMapping=5,AgXToneMapping=6,NeutralToneMapping=7,AttachedBindMode="attached",DetachedBindMode="detached",UVMapping=300,CubeReflectionMapping=301,CubeRefractionMapping=302,EquirectangularReflectionMapping=303,EquirectangularRefractionMapping=304,CubeUVReflectionMapping=306,RepeatWrapping=1e3,ClampToEdgeWrapping=1001,MirroredRepeatWrapping=1002,NearestFilter=1003,NearestMipmapNearestFilter=1004,NearestMipMapNearestFilter=1004,NearestMipmapLinearFilter=1005,NearestMipMapLinearFilter=1005,LinearFilter=1006,LinearMipmapNearestFilter=1007,LinearMipMapNearestFilter=1007,LinearMipmapLinearFilter=1008,LinearMipMapLinearFilter=1008,UnsignedByteType=1009,ByteType=1010,ShortType=1011,UnsignedShortType=1012,IntType=1013,UnsignedIntType=1014,FloatType=1015,HalfFloatType=1016,UnsignedShort4444Type=1017,UnsignedShort5551Type=1018,UnsignedInt248Type=1020,AlphaFormat=1021,RGBAFormat=1023,LuminanceFormat=1024,LuminanceAlphaFormat=1025,DepthFormat=1026,DepthStencilFormat=1027,RedFormat=1028,RedIntegerFormat=1029,RGFormat=1030,RGIntegerFormat=1031,RGBAIntegerFormat=1033,RGB_S3TC_DXT1_Format=33776,RGBA_S3TC_DXT1_Format=33777,RGBA_S3TC_DXT3_Format=33778,RGBA_S3TC_DXT5_Format=33779,RGB_PVRTC_4BPPV1_Format=35840,RGB_PVRTC_2BPPV1_Format=35841,RGBA_PVRTC_4BPPV1_Format=35842,RGBA_PVRTC_2BPPV1_Format=35843,RGB_ETC1_Format=36196,RGB_ETC2_Format=37492,RGBA_ETC2_EAC_Format=37496,RGBA_ASTC_4x4_Format=37808,RGBA_ASTC_5x4_Format=37809,RGBA_ASTC_5x5_Format=37810,RGBA_ASTC_6x5_Format=37811,RGBA_ASTC_6x6_Format=37812,RGBA_ASTC_8x5_Format=37813,RGBA_ASTC_8x6_Format=37814,RGBA_ASTC_8x8_Format=37815,RGBA_ASTC_10x5_Format=37816,RGBA_ASTC_10x6_Format=37817,RGBA_ASTC_10x8_Format=37818,RGBA_ASTC_10x10_Format=37819,RGBA_ASTC_12x10_Format=37820,RGBA_ASTC_12x12_Format=37821,RGBA_BPTC_Format=36492,RGB_BPTC_SIGNED_Format=36494,RGB_BPTC_UNSIGNED_Format=36495,RED_RGTC1_Format=36283,SIGNED_RED_RGTC1_Format=36284,RED_GREEN_RGTC2_Format=36285,SIGNED_RED_GREEN_RGTC2_Format=36286,LoopOnce=2200,LoopRepeat=2201,LoopPingPong=2202,InterpolateDiscrete=2300,InterpolateLinear=2301,InterpolateSmooth=2302,ZeroCurvatureEnding=2400,ZeroSlopeEnding=2401,WrapAroundEnding=2402,NormalAnimationBlendMode=2500,AdditiveAnimationBlendMode=2501,TrianglesDrawMode=0,TriangleStripDrawMode=1,TriangleFanDrawMode=2,BasicDepthPacking=3200,RGBADepthPacking=3201,TangentSpaceNormalMap=0,ObjectSpaceNormalMap=1,NoColorSpace="",SRGBColorSpace="srgb",LinearSRGBColorSpace="srgb-linear",DisplayP3ColorSpace="display-p3",LinearDisplayP3ColorSpace="display-p3-linear",LinearTransfer="linear",SRGBTransfer="srgb",Rec709Primaries="rec709",P3Primaries="p3",ZeroStencilOp=0,KeepStencilOp=7680,ReplaceStencilOp=7681,IncrementStencilOp=7682,DecrementStencilOp=7683,IncrementWrapStencilOp=34055,DecrementWrapStencilOp=34056,InvertStencilOp=5386,NeverStencilFunc=512,LessStencilFunc=513,EqualStencilFunc=514,LessEqualStencilFunc=515,GreaterStencilFunc=516,NotEqualStencilFunc=517,GreaterEqualStencilFunc=518,AlwaysStencilFunc=519,NeverCompare=512,LessCompare=513,EqualCompare=514,LessEqualCompare=515,GreaterCompare=516,NotEqualCompare=517,GreaterEqualCompare=518,AlwaysCompare=519,StaticDrawUsage=35044,DynamicDrawUsage=35048,StreamDrawUsage=35040,StaticReadUsage=35045,DynamicReadUsage=35049,StreamReadUsage=35041,StaticCopyUsage=35046,DynamicCopyUsage=35050,StreamCopyUsage=35042,GLSL1="100",GLSL3="300 es",_SRGBAFormat=1035,WebGLCoordinateSystem=2e3,WebGPUCoordinateSystem=2001;class EventDispatcher{addEventListener(e,o){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(o)===-1&&s[e].push(o)}hasEventListener(e,o){if(this._listeners===void 0)return!1;const s=this._listeners;return s[e]!==void 0&&s[e].indexOf(o)!==-1}removeEventListener(e,o){if(this._listeners===void 0)return;const d=this._listeners[e];if(d!==void 0){const c=d.indexOf(o);c!==-1&&d.splice(c,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const s=this._listeners[e.type];if(s!==void 0){e.target=this;const d=s.slice(0);for(let c=0,h=d.length;c<h;c++)d[c].call(this,e);e.target=null}}}const _lut=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let _seed=1234567;const DEG2RAD=Math.PI/180,RAD2DEG=180/Math.PI;function generateUUID(){const a=Math.random()*4294967295|0,e=Math.random()*4294967295|0,o=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(_lut[a&255]+_lut[a>>8&255]+_lut[a>>16&255]+_lut[a>>24&255]+"-"+_lut[e&255]+_lut[e>>8&255]+"-"+_lut[e>>16&15|64]+_lut[e>>24&255]+"-"+_lut[o&63|128]+_lut[o>>8&255]+"-"+_lut[o>>16&255]+_lut[o>>24&255]+_lut[s&255]+_lut[s>>8&255]+_lut[s>>16&255]+_lut[s>>24&255]).toLowerCase()}function clamp(a,e,o){return Math.max(e,Math.min(o,a))}function euclideanModulo(a,e){return(a%e+e)%e}function mapLinear(a,e,o,s,d){return s+(a-e)*(d-s)/(o-e)}function inverseLerp(a,e,o){return a!==e?(o-a)/(e-a):0}function lerp(a,e,o){return(1-o)*a+o*e}function damp(a,e,o,s){return lerp(a,e,1-Math.exp(-o*s))}function pingpong(a,e=1){return e-Math.abs(euclideanModulo(a,e*2)-e)}function smoothstep(a,e,o){return a<=e?0:a>=o?1:(a=(a-e)/(o-e),a*a*(3-2*a))}function smootherstep(a,e,o){return a<=e?0:a>=o?1:(a=(a-e)/(o-e),a*a*a*(a*(a*6-15)+10))}function randInt(a,e){return a+Math.floor(Math.random()*(e-a+1))}function randFloat(a,e){return a+Math.random()*(e-a)}function randFloatSpread(a){return a*(.5-Math.random())}function seededRandom(a){a!==void 0&&(_seed=a);let e=_seed+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function degToRad(a){return a*DEG2RAD}function radToDeg(a){return a*RAD2DEG}function isPowerOfTwo(a){return(a&a-1)===0&&a!==0}function ceilPowerOfTwo(a){return Math.pow(2,Math.ceil(Math.log(a)/Math.LN2))}function floorPowerOfTwo(a){return Math.pow(2,Math.floor(Math.log(a)/Math.LN2))}function setQuaternionFromProperEuler(a,e,o,s,d){const c=Math.cos,h=Math.sin,_=c(o/2),bt=h(o/2),g=c((e+s)/2),j=h((e+s)/2),b=c((e-s)/2),Et=h((e-s)/2),It=c((s-e)/2),zt=h((s-e)/2);switch(d){case"XYX":a.set(_*j,bt*b,bt*Et,_*g);break;case"YZY":a.set(bt*Et,_*j,bt*b,_*g);break;case"ZXZ":a.set(bt*b,bt*Et,_*j,_*g);break;case"XZX":a.set(_*j,bt*zt,bt*It,_*g);break;case"YXY":a.set(bt*It,_*j,bt*zt,_*g);break;case"ZYZ":a.set(bt*zt,bt*It,_*j,_*g);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+d)}}function denormalize(a,e){switch(e.constructor){case Float32Array:return a;case Uint32Array:return a/4294967295;case Uint16Array:return a/65535;case Uint8Array:return a/255;case Int32Array:return Math.max(a/2147483647,-1);case Int16Array:return Math.max(a/32767,-1);case Int8Array:return Math.max(a/127,-1);default:throw new Error("Invalid component type.")}}function normalize(a,e){switch(e.constructor){case Float32Array:return a;case Uint32Array:return Math.round(a*4294967295);case Uint16Array:return Math.round(a*65535);case Uint8Array:return Math.round(a*255);case Int32Array:return Math.round(a*2147483647);case Int16Array:return Math.round(a*32767);case Int8Array:return Math.round(a*127);default:throw new Error("Invalid component type.")}}const MathUtils={DEG2RAD,RAD2DEG,generateUUID,clamp,euclideanModulo,mapLinear,inverseLerp,lerp,damp,pingpong,smoothstep,smootherstep,randInt,randFloat,randFloatSpread,seededRandom,degToRad,radToDeg,isPowerOfTwo,ceilPowerOfTwo,floorPowerOfTwo,setQuaternionFromProperEuler,normalize,denormalize};class Vector2{constructor(e=0,o=0){Vector2.prototype.isVector2=!0,this.x=e,this.y=o}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,o){return this.x=e,this.y=o,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,o){switch(e){case 0:this.x=o;break;case 1:this.y=o;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,o){return this.x=e.x+o.x,this.y=e.y+o.y,this}addScaledVector(e,o){return this.x+=e.x*o,this.y+=e.y*o,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,o){return this.x=e.x-o.x,this.y=e.y-o.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const o=this.x,s=this.y,d=e.elements;return this.x=d[0]*o+d[3]*s+d[6],this.y=d[1]*o+d[4]*s+d[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,o){return this.x=Math.max(e.x,Math.min(o.x,this.x)),this.y=Math.max(e.y,Math.min(o.y,this.y)),this}clampScalar(e,o){return this.x=Math.max(e,Math.min(o,this.x)),this.y=Math.max(e,Math.min(o,this.y)),this}clampLength(e,o){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(o,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const o=Math.sqrt(this.lengthSq()*e.lengthSq());if(o===0)return Math.PI/2;const s=this.dot(e)/o;return Math.acos(clamp(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const o=this.x-e.x,s=this.y-e.y;return o*o+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,o){return this.x+=(e.x-this.x)*o,this.y+=(e.y-this.y)*o,this}lerpVectors(e,o,s){return this.x=e.x+(o.x-e.x)*s,this.y=e.y+(o.y-e.y)*s,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,o=0){return this.x=e[o],this.y=e[o+1],this}toArray(e=[],o=0){return e[o]=this.x,e[o+1]=this.y,e}fromBufferAttribute(e,o){return this.x=e.getX(o),this.y=e.getY(o),this}rotateAround(e,o){const s=Math.cos(o),d=Math.sin(o),c=this.x-e.x,h=this.y-e.y;return this.x=c*s-h*d+e.x,this.y=c*d+h*s+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Matrix3{constructor(e,o,s,d,c,h,_,bt,g){Matrix3.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,o,s,d,c,h,_,bt,g)}set(e,o,s,d,c,h,_,bt,g){const j=this.elements;return j[0]=e,j[1]=d,j[2]=_,j[3]=o,j[4]=c,j[5]=bt,j[6]=s,j[7]=h,j[8]=g,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const o=this.elements,s=e.elements;return o[0]=s[0],o[1]=s[1],o[2]=s[2],o[3]=s[3],o[4]=s[4],o[5]=s[5],o[6]=s[6],o[7]=s[7],o[8]=s[8],this}extractBasis(e,o,s){return e.setFromMatrix3Column(this,0),o.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const o=e.elements;return this.set(o[0],o[4],o[8],o[1],o[5],o[9],o[2],o[6],o[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,o){const s=e.elements,d=o.elements,c=this.elements,h=s[0],_=s[3],bt=s[6],g=s[1],j=s[4],b=s[7],Et=s[2],It=s[5],zt=s[8],er=d[0],Hn=d[3],Qt=d[6],cr=d[1],fr=d[4],jr=d[7],e0=d[2],t0=d[5],o0=d[8];return c[0]=h*er+_*cr+bt*e0,c[3]=h*Hn+_*fr+bt*t0,c[6]=h*Qt+_*jr+bt*o0,c[1]=g*er+j*cr+b*e0,c[4]=g*Hn+j*fr+b*t0,c[7]=g*Qt+j*jr+b*o0,c[2]=Et*er+It*cr+zt*e0,c[5]=Et*Hn+It*fr+zt*t0,c[8]=Et*Qt+It*jr+zt*o0,this}multiplyScalar(e){const o=this.elements;return o[0]*=e,o[3]*=e,o[6]*=e,o[1]*=e,o[4]*=e,o[7]*=e,o[2]*=e,o[5]*=e,o[8]*=e,this}determinant(){const e=this.elements,o=e[0],s=e[1],d=e[2],c=e[3],h=e[4],_=e[5],bt=e[6],g=e[7],j=e[8];return o*h*j-o*_*g-s*c*j+s*_*bt+d*c*g-d*h*bt}invert(){const e=this.elements,o=e[0],s=e[1],d=e[2],c=e[3],h=e[4],_=e[5],bt=e[6],g=e[7],j=e[8],b=j*h-_*g,Et=_*bt-j*c,It=g*c-h*bt,zt=o*b+s*Et+d*It;if(zt===0)return this.set(0,0,0,0,0,0,0,0,0);const er=1/zt;return e[0]=b*er,e[1]=(d*g-j*s)*er,e[2]=(_*s-d*h)*er,e[3]=Et*er,e[4]=(j*o-d*bt)*er,e[5]=(d*c-_*o)*er,e[6]=It*er,e[7]=(s*bt-g*o)*er,e[8]=(h*o-s*c)*er,this}transpose(){let e;const o=this.elements;return e=o[1],o[1]=o[3],o[3]=e,e=o[2],o[2]=o[6],o[6]=e,e=o[5],o[5]=o[7],o[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const o=this.elements;return e[0]=o[0],e[1]=o[3],e[2]=o[6],e[3]=o[1],e[4]=o[4],e[5]=o[7],e[6]=o[2],e[7]=o[5],e[8]=o[8],this}setUvTransform(e,o,s,d,c,h,_){const bt=Math.cos(c),g=Math.sin(c);return this.set(s*bt,s*g,-s*(bt*h+g*_)+h+e,-d*g,d*bt,-d*(-g*h+bt*_)+_+o,0,0,1),this}scale(e,o){return this.premultiply(_m3.makeScale(e,o)),this}rotate(e){return this.premultiply(_m3.makeRotation(-e)),this}translate(e,o){return this.premultiply(_m3.makeTranslation(e,o)),this}makeTranslation(e,o){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,o,0,0,1),this}makeRotation(e){const o=Math.cos(e),s=Math.sin(e);return this.set(o,-s,0,s,o,0,0,0,1),this}makeScale(e,o){return this.set(e,0,0,0,o,0,0,0,1),this}equals(e){const o=this.elements,s=e.elements;for(let d=0;d<9;d++)if(o[d]!==s[d])return!1;return!0}fromArray(e,o=0){for(let s=0;s<9;s++)this.elements[s]=e[s+o];return this}toArray(e=[],o=0){const s=this.elements;return e[o]=s[0],e[o+1]=s[1],e[o+2]=s[2],e[o+3]=s[3],e[o+4]=s[4],e[o+5]=s[5],e[o+6]=s[6],e[o+7]=s[7],e[o+8]=s[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const _m3=new Matrix3;function arrayNeedsUint32(a){for(let e=a.length-1;e>=0;--e)if(a[e]>=65535)return!0;return!1}const TYPED_ARRAYS={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function getTypedArray(a,e){return new TYPED_ARRAYS[a](e)}function createElementNS(a){return document.createElementNS("http://www.w3.org/1999/xhtml",a)}function createCanvasElement(){const a=createElementNS("canvas");return a.style.display="block",a}const _cache={};function warnOnce(a){a in _cache||(_cache[a]=!0,console.warn(a))}const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3=new Matrix3().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),LINEAR_DISPLAY_P3_TO_LINEAR_SRGB=new Matrix3().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),COLOR_SPACES={[LinearSRGBColorSpace]:{transfer:LinearTransfer,primaries:Rec709Primaries,toReference:a=>a,fromReference:a=>a},[SRGBColorSpace]:{transfer:SRGBTransfer,primaries:Rec709Primaries,toReference:a=>a.convertSRGBToLinear(),fromReference:a=>a.convertLinearToSRGB()},[LinearDisplayP3ColorSpace]:{transfer:LinearTransfer,primaries:P3Primaries,toReference:a=>a.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),fromReference:a=>a.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)},[DisplayP3ColorSpace]:{transfer:SRGBTransfer,primaries:P3Primaries,toReference:a=>a.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),fromReference:a=>a.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()}},SUPPORTED_WORKING_COLOR_SPACES=new Set([LinearSRGBColorSpace,LinearDisplayP3ColorSpace]),ColorManagement={enabled:!0,_workingColorSpace:LinearSRGBColorSpace,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(a){if(!SUPPORTED_WORKING_COLOR_SPACES.has(a))throw new Error(`Unsupported working color space, "${a}".`);this._workingColorSpace=a},convert:function(a,e,o){if(this.enabled===!1||e===o||!e||!o)return a;const s=COLOR_SPACES[e].toReference,d=COLOR_SPACES[o].fromReference;return d(s(a))},fromWorkingColorSpace:function(a,e){return this.convert(a,this._workingColorSpace,e)},toWorkingColorSpace:function(a,e){return this.convert(a,e,this._workingColorSpace)},getPrimaries:function(a){return COLOR_SPACES[a].primaries},getTransfer:function(a){return a===NoColorSpace?LinearTransfer:COLOR_SPACES[a].transfer}};function SRGBToLinear(a){return a<.04045?a*.0773993808:Math.pow(a*.9478672986+.0521327014,2.4)}function LinearToSRGB(a){return a<.0031308?a*12.92:1.055*Math.pow(a,.41666)-.055}let _canvas;class ImageUtils{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let o;if(e instanceof HTMLCanvasElement)o=e;else{_canvas===void 0&&(_canvas=createElementNS("canvas")),_canvas.width=e.width,_canvas.height=e.height;const s=_canvas.getContext("2d");e instanceof ImageData?s.putImageData(e,0,0):s.drawImage(e,0,0,e.width,e.height),o=_canvas}return o.width>2048||o.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),o.toDataURL("image/jpeg",.6)):o.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const o=createElementNS("canvas");o.width=e.width,o.height=e.height;const s=o.getContext("2d");s.drawImage(e,0,0,e.width,e.height);const d=s.getImageData(0,0,e.width,e.height),c=d.data;for(let h=0;h<c.length;h++)c[h]=SRGBToLinear(c[h]/255)*255;return s.putImageData(d,0,0),o}else if(e.data){const o=e.data.slice(0);for(let s=0;s<o.length;s++)o instanceof Uint8Array||o instanceof Uint8ClampedArray?o[s]=Math.floor(SRGBToLinear(o[s]/255)*255):o[s]=SRGBToLinear(o[s]);return{data:o,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let _sourceId=0;class Source{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:_sourceId++}),this.uuid=generateUUID(),this.data=e,this.dataReady=!0,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const o=e===void 0||typeof e=="string";if(!o&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const s={uuid:this.uuid,url:""},d=this.data;if(d!==null){let c;if(Array.isArray(d)){c=[];for(let h=0,_=d.length;h<_;h++)d[h].isDataTexture?c.push(serializeImage(d[h].image)):c.push(serializeImage(d[h]))}else c=serializeImage(d);s.url=c}return o||(e.images[this.uuid]=s),s}}function serializeImage(a){return typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&a instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&a instanceof ImageBitmap?ImageUtils.getDataURL(a):a.data?{data:Array.from(a.data),width:a.width,height:a.height,type:a.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let _textureId=0;class Texture extends EventDispatcher{constructor(e=Texture.DEFAULT_IMAGE,o=Texture.DEFAULT_MAPPING,s=ClampToEdgeWrapping,d=ClampToEdgeWrapping,c=LinearFilter,h=LinearMipmapLinearFilter,_=RGBAFormat,bt=UnsignedByteType,g=Texture.DEFAULT_ANISOTROPY,j=NoColorSpace){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:_textureId++}),this.uuid=generateUUID(),this.name="",this.source=new Source(e),this.mipmaps=[],this.mapping=o,this.channel=0,this.wrapS=s,this.wrapT=d,this.magFilter=c,this.minFilter=h,this.anisotropy=g,this.format=_,this.internalFormat=null,this.type=bt,this.offset=new Vector2(0,0),this.repeat=new Vector2(1,1),this.center=new Vector2(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Matrix3,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=j,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const o=e===void 0||typeof e=="string";if(!o&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const s={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),o||(e.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==UVMapping)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case RepeatWrapping:e.x=e.x-Math.floor(e.x);break;case ClampToEdgeWrapping:e.x=e.x<0?0:1;break;case MirroredRepeatWrapping:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case RepeatWrapping:e.y=e.y-Math.floor(e.y);break;case ClampToEdgeWrapping:e.y=e.y<0?0:1;break;case MirroredRepeatWrapping:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}}Texture.DEFAULT_IMAGE=null;Texture.DEFAULT_MAPPING=UVMapping;Texture.DEFAULT_ANISOTROPY=1;class Vector4{constructor(e=0,o=0,s=0,d=1){Vector4.prototype.isVector4=!0,this.x=e,this.y=o,this.z=s,this.w=d}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,o,s,d){return this.x=e,this.y=o,this.z=s,this.w=d,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,o){switch(e){case 0:this.x=o;break;case 1:this.y=o;break;case 2:this.z=o;break;case 3:this.w=o;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,o){return this.x=e.x+o.x,this.y=e.y+o.y,this.z=e.z+o.z,this.w=e.w+o.w,this}addScaledVector(e,o){return this.x+=e.x*o,this.y+=e.y*o,this.z+=e.z*o,this.w+=e.w*o,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,o){return this.x=e.x-o.x,this.y=e.y-o.y,this.z=e.z-o.z,this.w=e.w-o.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const o=this.x,s=this.y,d=this.z,c=this.w,h=e.elements;return this.x=h[0]*o+h[4]*s+h[8]*d+h[12]*c,this.y=h[1]*o+h[5]*s+h[9]*d+h[13]*c,this.z=h[2]*o+h[6]*s+h[10]*d+h[14]*c,this.w=h[3]*o+h[7]*s+h[11]*d+h[15]*c,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const o=Math.sqrt(1-e.w*e.w);return o<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/o,this.y=e.y/o,this.z=e.z/o),this}setAxisAngleFromRotationMatrix(e){let o,s,d,c;const bt=e.elements,g=bt[0],j=bt[4],b=bt[8],Et=bt[1],It=bt[5],zt=bt[9],er=bt[2],Hn=bt[6],Qt=bt[10];if(Math.abs(j-Et)<.01&&Math.abs(b-er)<.01&&Math.abs(zt-Hn)<.01){if(Math.abs(j+Et)<.1&&Math.abs(b+er)<.1&&Math.abs(zt+Hn)<.1&&Math.abs(g+It+Qt-3)<.1)return this.set(1,0,0,0),this;o=Math.PI;const fr=(g+1)/2,jr=(It+1)/2,e0=(Qt+1)/2,t0=(j+Et)/4,o0=(b+er)/4,l0=(zt+Hn)/4;return fr>jr&&fr>e0?fr<.01?(s=0,d=.707106781,c=.707106781):(s=Math.sqrt(fr),d=t0/s,c=o0/s):jr>e0?jr<.01?(s=.707106781,d=0,c=.707106781):(d=Math.sqrt(jr),s=t0/d,c=l0/d):e0<.01?(s=.707106781,d=.707106781,c=0):(c=Math.sqrt(e0),s=o0/c,d=l0/c),this.set(s,d,c,o),this}let cr=Math.sqrt((Hn-zt)*(Hn-zt)+(b-er)*(b-er)+(Et-j)*(Et-j));return Math.abs(cr)<.001&&(cr=1),this.x=(Hn-zt)/cr,this.y=(b-er)/cr,this.z=(Et-j)/cr,this.w=Math.acos((g+It+Qt-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,o){return this.x=Math.max(e.x,Math.min(o.x,this.x)),this.y=Math.max(e.y,Math.min(o.y,this.y)),this.z=Math.max(e.z,Math.min(o.z,this.z)),this.w=Math.max(e.w,Math.min(o.w,this.w)),this}clampScalar(e,o){return this.x=Math.max(e,Math.min(o,this.x)),this.y=Math.max(e,Math.min(o,this.y)),this.z=Math.max(e,Math.min(o,this.z)),this.w=Math.max(e,Math.min(o,this.w)),this}clampLength(e,o){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(o,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,o){return this.x+=(e.x-this.x)*o,this.y+=(e.y-this.y)*o,this.z+=(e.z-this.z)*o,this.w+=(e.w-this.w)*o,this}lerpVectors(e,o,s){return this.x=e.x+(o.x-e.x)*s,this.y=e.y+(o.y-e.y)*s,this.z=e.z+(o.z-e.z)*s,this.w=e.w+(o.w-e.w)*s,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,o=0){return this.x=e[o],this.y=e[o+1],this.z=e[o+2],this.w=e[o+3],this}toArray(e=[],o=0){return e[o]=this.x,e[o+1]=this.y,e[o+2]=this.z,e[o+3]=this.w,e}fromBufferAttribute(e,o){return this.x=e.getX(o),this.y=e.getY(o),this.z=e.getZ(o),this.w=e.getW(o),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class RenderTarget extends EventDispatcher{constructor(e=1,o=1,s={}){super(),this.isRenderTarget=!0,this.width=e,this.height=o,this.depth=1,this.scissor=new Vector4(0,0,e,o),this.scissorTest=!1,this.viewport=new Vector4(0,0,e,o);const d={width:e,height:o,depth:1};s=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:LinearFilter,depthBuffer:!0,stencilBuffer:!1,depthTexture:null,samples:0,count:1},s);const c=new Texture(d,s.mapping,s.wrapS,s.wrapT,s.magFilter,s.minFilter,s.format,s.type,s.anisotropy,s.colorSpace);c.flipY=!1,c.generateMipmaps=s.generateMipmaps,c.internalFormat=s.internalFormat,this.textures=[];const h=s.count;for(let _=0;_<h;_++)this.textures[_]=c.clone(),this.textures[_].isRenderTargetTexture=!0;this.depthBuffer=s.depthBuffer,this.stencilBuffer=s.stencilBuffer,this.depthTexture=s.depthTexture,this.samples=s.samples}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}setSize(e,o,s=1){if(this.width!==e||this.height!==o||this.depth!==s){this.width=e,this.height=o,this.depth=s;for(let d=0,c=this.textures.length;d<c;d++)this.textures[d].image.width=e,this.textures[d].image.height=o,this.textures[d].image.depth=s;this.dispose()}this.viewport.set(0,0,e,o),this.scissor.set(0,0,e,o)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let s=0,d=e.textures.length;s<d;s++)this.textures[s]=e.textures[s].clone(),this.textures[s].isRenderTargetTexture=!0;const o=Object.assign({},e.texture.image);return this.texture.source=new Source(o),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class WebGLRenderTarget extends RenderTarget{constructor(e=1,o=1,s={}){super(e,o,s),this.isWebGLRenderTarget=!0}}class DataArrayTexture extends Texture{constructor(e=null,o=1,s=1,d=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:o,height:s,depth:d},this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.wrapR=ClampToEdgeWrapping,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class WebGLArrayRenderTarget extends WebGLRenderTarget{constructor(e=1,o=1,s=1,d={}){super(e,o,d),this.isWebGLArrayRenderTarget=!0,this.depth=s,this.texture=new DataArrayTexture(null,e,o,s),this.texture.isRenderTargetTexture=!0}}class Data3DTexture extends Texture{constructor(e=null,o=1,s=1,d=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:o,height:s,depth:d},this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.wrapR=ClampToEdgeWrapping,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class WebGL3DRenderTarget extends WebGLRenderTarget{constructor(e=1,o=1,s=1,d={}){super(e,o,d),this.isWebGL3DRenderTarget=!0,this.depth=s,this.texture=new Data3DTexture(null,e,o,s),this.texture.isRenderTargetTexture=!0}}class Quaternion{constructor(e=0,o=0,s=0,d=1){this.isQuaternion=!0,this._x=e,this._y=o,this._z=s,this._w=d}static slerpFlat(e,o,s,d,c,h,_){let bt=s[d+0],g=s[d+1],j=s[d+2],b=s[d+3];const Et=c[h+0],It=c[h+1],zt=c[h+2],er=c[h+3];if(_===0){e[o+0]=bt,e[o+1]=g,e[o+2]=j,e[o+3]=b;return}if(_===1){e[o+0]=Et,e[o+1]=It,e[o+2]=zt,e[o+3]=er;return}if(b!==er||bt!==Et||g!==It||j!==zt){let Hn=1-_;const Qt=bt*Et+g*It+j*zt+b*er,cr=Qt>=0?1:-1,fr=1-Qt*Qt;if(fr>Number.EPSILON){const e0=Math.sqrt(fr),t0=Math.atan2(e0,Qt*cr);Hn=Math.sin(Hn*t0)/e0,_=Math.sin(_*t0)/e0}const jr=_*cr;if(bt=bt*Hn+Et*jr,g=g*Hn+It*jr,j=j*Hn+zt*jr,b=b*Hn+er*jr,Hn===1-_){const e0=1/Math.sqrt(bt*bt+g*g+j*j+b*b);bt*=e0,g*=e0,j*=e0,b*=e0}}e[o]=bt,e[o+1]=g,e[o+2]=j,e[o+3]=b}static multiplyQuaternionsFlat(e,o,s,d,c,h){const _=s[d],bt=s[d+1],g=s[d+2],j=s[d+3],b=c[h],Et=c[h+1],It=c[h+2],zt=c[h+3];return e[o]=_*zt+j*b+bt*It-g*Et,e[o+1]=bt*zt+j*Et+g*b-_*It,e[o+2]=g*zt+j*It+_*Et-bt*b,e[o+3]=j*zt-_*b-bt*Et-g*It,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,o,s,d){return this._x=e,this._y=o,this._z=s,this._w=d,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,o=!0){const s=e._x,d=e._y,c=e._z,h=e._order,_=Math.cos,bt=Math.sin,g=_(s/2),j=_(d/2),b=_(c/2),Et=bt(s/2),It=bt(d/2),zt=bt(c/2);switch(h){case"XYZ":this._x=Et*j*b+g*It*zt,this._y=g*It*b-Et*j*zt,this._z=g*j*zt+Et*It*b,this._w=g*j*b-Et*It*zt;break;case"YXZ":this._x=Et*j*b+g*It*zt,this._y=g*It*b-Et*j*zt,this._z=g*j*zt-Et*It*b,this._w=g*j*b+Et*It*zt;break;case"ZXY":this._x=Et*j*b-g*It*zt,this._y=g*It*b+Et*j*zt,this._z=g*j*zt+Et*It*b,this._w=g*j*b-Et*It*zt;break;case"ZYX":this._x=Et*j*b-g*It*zt,this._y=g*It*b+Et*j*zt,this._z=g*j*zt-Et*It*b,this._w=g*j*b+Et*It*zt;break;case"YZX":this._x=Et*j*b+g*It*zt,this._y=g*It*b+Et*j*zt,this._z=g*j*zt-Et*It*b,this._w=g*j*b-Et*It*zt;break;case"XZY":this._x=Et*j*b-g*It*zt,this._y=g*It*b-Et*j*zt,this._z=g*j*zt+Et*It*b,this._w=g*j*b+Et*It*zt;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+h)}return o===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,o){const s=o/2,d=Math.sin(s);return this._x=e.x*d,this._y=e.y*d,this._z=e.z*d,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(e){const o=e.elements,s=o[0],d=o[4],c=o[8],h=o[1],_=o[5],bt=o[9],g=o[2],j=o[6],b=o[10],Et=s+_+b;if(Et>0){const It=.5/Math.sqrt(Et+1);this._w=.25/It,this._x=(j-bt)*It,this._y=(c-g)*It,this._z=(h-d)*It}else if(s>_&&s>b){const It=2*Math.sqrt(1+s-_-b);this._w=(j-bt)/It,this._x=.25*It,this._y=(d+h)/It,this._z=(c+g)/It}else if(_>b){const It=2*Math.sqrt(1+_-s-b);this._w=(c-g)/It,this._x=(d+h)/It,this._y=.25*It,this._z=(bt+j)/It}else{const It=2*Math.sqrt(1+b-s-_);this._w=(h-d)/It,this._x=(c+g)/It,this._y=(bt+j)/It,this._z=.25*It}return this._onChangeCallback(),this}setFromUnitVectors(e,o){let s=e.dot(o)+1;return s<Number.EPSILON?(s=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=s):(this._x=0,this._y=-e.z,this._z=e.y,this._w=s)):(this._x=e.y*o.z-e.z*o.y,this._y=e.z*o.x-e.x*o.z,this._z=e.x*o.y-e.y*o.x,this._w=s),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(clamp(this.dot(e),-1,1)))}rotateTowards(e,o){const s=this.angleTo(e);if(s===0)return this;const d=Math.min(1,o/s);return this.slerp(e,d),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,o){const s=e._x,d=e._y,c=e._z,h=e._w,_=o._x,bt=o._y,g=o._z,j=o._w;return this._x=s*j+h*_+d*g-c*bt,this._y=d*j+h*bt+c*_-s*g,this._z=c*j+h*g+s*bt-d*_,this._w=h*j-s*_-d*bt-c*g,this._onChangeCallback(),this}slerp(e,o){if(o===0)return this;if(o===1)return this.copy(e);const s=this._x,d=this._y,c=this._z,h=this._w;let _=h*e._w+s*e._x+d*e._y+c*e._z;if(_<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,_=-_):this.copy(e),_>=1)return this._w=h,this._x=s,this._y=d,this._z=c,this;const bt=1-_*_;if(bt<=Number.EPSILON){const It=1-o;return this._w=It*h+o*this._w,this._x=It*s+o*this._x,this._y=It*d+o*this._y,this._z=It*c+o*this._z,this.normalize(),this}const g=Math.sqrt(bt),j=Math.atan2(g,_),b=Math.sin((1-o)*j)/g,Et=Math.sin(o*j)/g;return this._w=h*b+this._w*Et,this._x=s*b+this._x*Et,this._y=d*b+this._y*Et,this._z=c*b+this._z*Et,this._onChangeCallback(),this}slerpQuaternions(e,o,s){return this.copy(e).slerp(o,s)}random(){const e=2*Math.PI*Math.random(),o=2*Math.PI*Math.random(),s=Math.random(),d=Math.sqrt(1-s),c=Math.sqrt(s);return this.set(d*Math.sin(e),d*Math.cos(e),c*Math.sin(o),c*Math.cos(o))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,o=0){return this._x=e[o],this._y=e[o+1],this._z=e[o+2],this._w=e[o+3],this._onChangeCallback(),this}toArray(e=[],o=0){return e[o]=this._x,e[o+1]=this._y,e[o+2]=this._z,e[o+3]=this._w,e}fromBufferAttribute(e,o){return this._x=e.getX(o),this._y=e.getY(o),this._z=e.getZ(o),this._w=e.getW(o),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Vector3{constructor(e=0,o=0,s=0){Vector3.prototype.isVector3=!0,this.x=e,this.y=o,this.z=s}set(e,o,s){return s===void 0&&(s=this.z),this.x=e,this.y=o,this.z=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,o){switch(e){case 0:this.x=o;break;case 1:this.y=o;break;case 2:this.z=o;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,o){return this.x=e.x+o.x,this.y=e.y+o.y,this.z=e.z+o.z,this}addScaledVector(e,o){return this.x+=e.x*o,this.y+=e.y*o,this.z+=e.z*o,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,o){return this.x=e.x-o.x,this.y=e.y-o.y,this.z=e.z-o.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,o){return this.x=e.x*o.x,this.y=e.y*o.y,this.z=e.z*o.z,this}applyEuler(e){return this.applyQuaternion(_quaternion$4.setFromEuler(e))}applyAxisAngle(e,o){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(e,o))}applyMatrix3(e){const o=this.x,s=this.y,d=this.z,c=e.elements;return this.x=c[0]*o+c[3]*s+c[6]*d,this.y=c[1]*o+c[4]*s+c[7]*d,this.z=c[2]*o+c[5]*s+c[8]*d,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const o=this.x,s=this.y,d=this.z,c=e.elements,h=1/(c[3]*o+c[7]*s+c[11]*d+c[15]);return this.x=(c[0]*o+c[4]*s+c[8]*d+c[12])*h,this.y=(c[1]*o+c[5]*s+c[9]*d+c[13])*h,this.z=(c[2]*o+c[6]*s+c[10]*d+c[14])*h,this}applyQuaternion(e){const o=this.x,s=this.y,d=this.z,c=e.x,h=e.y,_=e.z,bt=e.w,g=2*(h*d-_*s),j=2*(_*o-c*d),b=2*(c*s-h*o);return this.x=o+bt*g+h*b-_*j,this.y=s+bt*j+_*g-c*b,this.z=d+bt*b+c*j-h*g,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const o=this.x,s=this.y,d=this.z,c=e.elements;return this.x=c[0]*o+c[4]*s+c[8]*d,this.y=c[1]*o+c[5]*s+c[9]*d,this.z=c[2]*o+c[6]*s+c[10]*d,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,o){return this.x=Math.max(e.x,Math.min(o.x,this.x)),this.y=Math.max(e.y,Math.min(o.y,this.y)),this.z=Math.max(e.z,Math.min(o.z,this.z)),this}clampScalar(e,o){return this.x=Math.max(e,Math.min(o,this.x)),this.y=Math.max(e,Math.min(o,this.y)),this.z=Math.max(e,Math.min(o,this.z)),this}clampLength(e,o){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(o,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,o){return this.x+=(e.x-this.x)*o,this.y+=(e.y-this.y)*o,this.z+=(e.z-this.z)*o,this}lerpVectors(e,o,s){return this.x=e.x+(o.x-e.x)*s,this.y=e.y+(o.y-e.y)*s,this.z=e.z+(o.z-e.z)*s,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,o){const s=e.x,d=e.y,c=e.z,h=o.x,_=o.y,bt=o.z;return this.x=d*bt-c*_,this.y=c*h-s*bt,this.z=s*_-d*h,this}projectOnVector(e){const o=e.lengthSq();if(o===0)return this.set(0,0,0);const s=e.dot(this)/o;return this.copy(e).multiplyScalar(s)}projectOnPlane(e){return _vector$c.copy(this).projectOnVector(e),this.sub(_vector$c)}reflect(e){return this.sub(_vector$c.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const o=Math.sqrt(this.lengthSq()*e.lengthSq());if(o===0)return Math.PI/2;const s=this.dot(e)/o;return Math.acos(clamp(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const o=this.x-e.x,s=this.y-e.y,d=this.z-e.z;return o*o+s*s+d*d}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,o,s){const d=Math.sin(o)*e;return this.x=d*Math.sin(s),this.y=Math.cos(o)*e,this.z=d*Math.cos(s),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,o,s){return this.x=e*Math.sin(o),this.y=s,this.z=e*Math.cos(o),this}setFromMatrixPosition(e){const o=e.elements;return this.x=o[12],this.y=o[13],this.z=o[14],this}setFromMatrixScale(e){const o=this.setFromMatrixColumn(e,0).length(),s=this.setFromMatrixColumn(e,1).length(),d=this.setFromMatrixColumn(e,2).length();return this.x=o,this.y=s,this.z=d,this}setFromMatrixColumn(e,o){return this.fromArray(e.elements,o*4)}setFromMatrix3Column(e,o){return this.fromArray(e.elements,o*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,o=0){return this.x=e[o],this.y=e[o+1],this.z=e[o+2],this}toArray(e=[],o=0){return e[o]=this.x,e[o+1]=this.y,e[o+2]=this.z,e}fromBufferAttribute(e,o){return this.x=e.getX(o),this.y=e.getY(o),this.z=e.getZ(o),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,o=Math.random()*2-1,s=Math.sqrt(1-o*o);return this.x=s*Math.cos(e),this.y=o,this.z=s*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const _vector$c=new Vector3,_quaternion$4=new Quaternion;class Box3{constructor(e=new Vector3(1/0,1/0,1/0),o=new Vector3(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=o}set(e,o){return this.min.copy(e),this.max.copy(o),this}setFromArray(e){this.makeEmpty();for(let o=0,s=e.length;o<s;o+=3)this.expandByPoint(_vector$b.fromArray(e,o));return this}setFromBufferAttribute(e){this.makeEmpty();for(let o=0,s=e.count;o<s;o++)this.expandByPoint(_vector$b.fromBufferAttribute(e,o));return this}setFromPoints(e){this.makeEmpty();for(let o=0,s=e.length;o<s;o++)this.expandByPoint(e[o]);return this}setFromCenterAndSize(e,o){const s=_vector$b.copy(o).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}setFromObject(e,o=!1){return this.makeEmpty(),this.expandByObject(e,o)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,o=!1){e.updateWorldMatrix(!1,!1);const s=e.geometry;if(s!==void 0){const c=s.getAttribute("position");if(o===!0&&c!==void 0&&e.isInstancedMesh!==!0)for(let h=0,_=c.count;h<_;h++)e.isMesh===!0?e.getVertexPosition(h,_vector$b):_vector$b.fromBufferAttribute(c,h),_vector$b.applyMatrix4(e.matrixWorld),this.expandByPoint(_vector$b);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),_box$4.copy(e.boundingBox)):(s.boundingBox===null&&s.computeBoundingBox(),_box$4.copy(s.boundingBox)),_box$4.applyMatrix4(e.matrixWorld),this.union(_box$4)}const d=e.children;for(let c=0,h=d.length;c<h;c++)this.expandByObject(d[c],o);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,o){return o.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,_vector$b),_vector$b.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let o,s;return e.normal.x>0?(o=e.normal.x*this.min.x,s=e.normal.x*this.max.x):(o=e.normal.x*this.max.x,s=e.normal.x*this.min.x),e.normal.y>0?(o+=e.normal.y*this.min.y,s+=e.normal.y*this.max.y):(o+=e.normal.y*this.max.y,s+=e.normal.y*this.min.y),e.normal.z>0?(o+=e.normal.z*this.min.z,s+=e.normal.z*this.max.z):(o+=e.normal.z*this.max.z,s+=e.normal.z*this.min.z),o<=-e.constant&&s>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(_center),_extents.subVectors(this.max,_center),_v0$2.subVectors(e.a,_center),_v1$7.subVectors(e.b,_center),_v2$4.subVectors(e.c,_center),_f0.subVectors(_v1$7,_v0$2),_f1.subVectors(_v2$4,_v1$7),_f2.subVectors(_v0$2,_v2$4);let o=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];return!satForAxes(o,_v0$2,_v1$7,_v2$4,_extents)||(o=[1,0,0,0,1,0,0,0,1],!satForAxes(o,_v0$2,_v1$7,_v2$4,_extents))?!1:(_triangleNormal.crossVectors(_f0,_f1),o=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z],satForAxes(o,_v0$2,_v1$7,_v2$4,_extents))}clampPoint(e,o){return o.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,_vector$b).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(_vector$b).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(_points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),_points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),_points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),_points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),_points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),_points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),_points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),_points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(_points),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const _points=[new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3],_vector$b=new Vector3,_box$4=new Box3,_v0$2=new Vector3,_v1$7=new Vector3,_v2$4=new Vector3,_f0=new Vector3,_f1=new Vector3,_f2=new Vector3,_center=new Vector3,_extents=new Vector3,_triangleNormal=new Vector3,_testAxis=new Vector3;function satForAxes(a,e,o,s,d){for(let c=0,h=a.length-3;c<=h;c+=3){_testAxis.fromArray(a,c);const _=d.x*Math.abs(_testAxis.x)+d.y*Math.abs(_testAxis.y)+d.z*Math.abs(_testAxis.z),bt=e.dot(_testAxis),g=o.dot(_testAxis),j=s.dot(_testAxis);if(Math.max(-Math.max(bt,g,j),Math.min(bt,g,j))>_)return!1}return!0}const _box$3=new Box3,_v1$6=new Vector3,_v2$3=new Vector3;class Sphere{constructor(e=new Vector3,o=-1){this.isSphere=!0,this.center=e,this.radius=o}set(e,o){return this.center.copy(e),this.radius=o,this}setFromPoints(e,o){const s=this.center;o!==void 0?s.copy(o):_box$3.setFromPoints(e).getCenter(s);let d=0;for(let c=0,h=e.length;c<h;c++)d=Math.max(d,s.distanceToSquared(e[c]));return this.radius=Math.sqrt(d),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const o=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=o*o}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,o){const s=this.center.distanceToSquared(e);return o.copy(e),s>this.radius*this.radius&&(o.sub(this.center).normalize(),o.multiplyScalar(this.radius).add(this.center)),o}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;_v1$6.subVectors(e,this.center);const o=_v1$6.lengthSq();if(o>this.radius*this.radius){const s=Math.sqrt(o),d=(s-this.radius)*.5;this.center.addScaledVector(_v1$6,d/s),this.radius+=d}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(_v2$3.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(_v1$6.copy(e.center).add(_v2$3)),this.expandByPoint(_v1$6.copy(e.center).sub(_v2$3))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const _vector$a=new Vector3,_segCenter=new Vector3,_segDir=new Vector3,_diff=new Vector3,_edge1=new Vector3,_edge2=new Vector3,_normal$1=new Vector3;class Ray{constructor(e=new Vector3,o=new Vector3(0,0,-1)){this.origin=e,this.direction=o}set(e,o){return this.origin.copy(e),this.direction.copy(o),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,o){return o.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,_vector$a)),this}closestPointToPoint(e,o){o.subVectors(e,this.origin);const s=o.dot(this.direction);return s<0?o.copy(this.origin):o.copy(this.origin).addScaledVector(this.direction,s)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const o=_vector$a.subVectors(e,this.origin).dot(this.direction);return o<0?this.origin.distanceToSquared(e):(_vector$a.copy(this.origin).addScaledVector(this.direction,o),_vector$a.distanceToSquared(e))}distanceSqToSegment(e,o,s,d){_segCenter.copy(e).add(o).multiplyScalar(.5),_segDir.copy(o).sub(e).normalize(),_diff.copy(this.origin).sub(_segCenter);const c=e.distanceTo(o)*.5,h=-this.direction.dot(_segDir),_=_diff.dot(this.direction),bt=-_diff.dot(_segDir),g=_diff.lengthSq(),j=Math.abs(1-h*h);let b,Et,It,zt;if(j>0)if(b=h*bt-_,Et=h*_-bt,zt=c*j,b>=0)if(Et>=-zt)if(Et<=zt){const er=1/j;b*=er,Et*=er,It=b*(b+h*Et+2*_)+Et*(h*b+Et+2*bt)+g}else Et=c,b=Math.max(0,-(h*Et+_)),It=-b*b+Et*(Et+2*bt)+g;else Et=-c,b=Math.max(0,-(h*Et+_)),It=-b*b+Et*(Et+2*bt)+g;else Et<=-zt?(b=Math.max(0,-(-h*c+_)),Et=b>0?-c:Math.min(Math.max(-c,-bt),c),It=-b*b+Et*(Et+2*bt)+g):Et<=zt?(b=0,Et=Math.min(Math.max(-c,-bt),c),It=Et*(Et+2*bt)+g):(b=Math.max(0,-(h*c+_)),Et=b>0?c:Math.min(Math.max(-c,-bt),c),It=-b*b+Et*(Et+2*bt)+g);else Et=h>0?-c:c,b=Math.max(0,-(h*Et+_)),It=-b*b+Et*(Et+2*bt)+g;return s&&s.copy(this.origin).addScaledVector(this.direction,b),d&&d.copy(_segCenter).addScaledVector(_segDir,Et),It}intersectSphere(e,o){_vector$a.subVectors(e.center,this.origin);const s=_vector$a.dot(this.direction),d=_vector$a.dot(_vector$a)-s*s,c=e.radius*e.radius;if(d>c)return null;const h=Math.sqrt(c-d),_=s-h,bt=s+h;return bt<0?null:_<0?this.at(bt,o):this.at(_,o)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const o=e.normal.dot(this.direction);if(o===0)return e.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(e.normal)+e.constant)/o;return s>=0?s:null}intersectPlane(e,o){const s=this.distanceToPlane(e);return s===null?null:this.at(s,o)}intersectsPlane(e){const o=e.distanceToPoint(this.origin);return o===0||e.normal.dot(this.direction)*o<0}intersectBox(e,o){let s,d,c,h,_,bt;const g=1/this.direction.x,j=1/this.direction.y,b=1/this.direction.z,Et=this.origin;return g>=0?(s=(e.min.x-Et.x)*g,d=(e.max.x-Et.x)*g):(s=(e.max.x-Et.x)*g,d=(e.min.x-Et.x)*g),j>=0?(c=(e.min.y-Et.y)*j,h=(e.max.y-Et.y)*j):(c=(e.max.y-Et.y)*j,h=(e.min.y-Et.y)*j),s>h||c>d||((c>s||isNaN(s))&&(s=c),(h<d||isNaN(d))&&(d=h),b>=0?(_=(e.min.z-Et.z)*b,bt=(e.max.z-Et.z)*b):(_=(e.max.z-Et.z)*b,bt=(e.min.z-Et.z)*b),s>bt||_>d)||((_>s||s!==s)&&(s=_),(bt<d||d!==d)&&(d=bt),d<0)?null:this.at(s>=0?s:d,o)}intersectsBox(e){return this.intersectBox(e,_vector$a)!==null}intersectTriangle(e,o,s,d,c){_edge1.subVectors(o,e),_edge2.subVectors(s,e),_normal$1.crossVectors(_edge1,_edge2);let h=this.direction.dot(_normal$1),_;if(h>0){if(d)return null;_=1}else if(h<0)_=-1,h=-h;else return null;_diff.subVectors(this.origin,e);const bt=_*this.direction.dot(_edge2.crossVectors(_diff,_edge2));if(bt<0)return null;const g=_*this.direction.dot(_edge1.cross(_diff));if(g<0||bt+g>h)return null;const j=-_*_diff.dot(_normal$1);return j<0?null:this.at(j/h,c)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Matrix4{constructor(e,o,s,d,c,h,_,bt,g,j,b,Et,It,zt,er,Hn){Matrix4.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,o,s,d,c,h,_,bt,g,j,b,Et,It,zt,er,Hn)}set(e,o,s,d,c,h,_,bt,g,j,b,Et,It,zt,er,Hn){const Qt=this.elements;return Qt[0]=e,Qt[4]=o,Qt[8]=s,Qt[12]=d,Qt[1]=c,Qt[5]=h,Qt[9]=_,Qt[13]=bt,Qt[2]=g,Qt[6]=j,Qt[10]=b,Qt[14]=Et,Qt[3]=It,Qt[7]=zt,Qt[11]=er,Qt[15]=Hn,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Matrix4().fromArray(this.elements)}copy(e){const o=this.elements,s=e.elements;return o[0]=s[0],o[1]=s[1],o[2]=s[2],o[3]=s[3],o[4]=s[4],o[5]=s[5],o[6]=s[6],o[7]=s[7],o[8]=s[8],o[9]=s[9],o[10]=s[10],o[11]=s[11],o[12]=s[12],o[13]=s[13],o[14]=s[14],o[15]=s[15],this}copyPosition(e){const o=this.elements,s=e.elements;return o[12]=s[12],o[13]=s[13],o[14]=s[14],this}setFromMatrix3(e){const o=e.elements;return this.set(o[0],o[3],o[6],0,o[1],o[4],o[7],0,o[2],o[5],o[8],0,0,0,0,1),this}extractBasis(e,o,s){return e.setFromMatrixColumn(this,0),o.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(e,o,s){return this.set(e.x,o.x,s.x,0,e.y,o.y,s.y,0,e.z,o.z,s.z,0,0,0,0,1),this}extractRotation(e){const o=this.elements,s=e.elements,d=1/_v1$5.setFromMatrixColumn(e,0).length(),c=1/_v1$5.setFromMatrixColumn(e,1).length(),h=1/_v1$5.setFromMatrixColumn(e,2).length();return o[0]=s[0]*d,o[1]=s[1]*d,o[2]=s[2]*d,o[3]=0,o[4]=s[4]*c,o[5]=s[5]*c,o[6]=s[6]*c,o[7]=0,o[8]=s[8]*h,o[9]=s[9]*h,o[10]=s[10]*h,o[11]=0,o[12]=0,o[13]=0,o[14]=0,o[15]=1,this}makeRotationFromEuler(e){const o=this.elements,s=e.x,d=e.y,c=e.z,h=Math.cos(s),_=Math.sin(s),bt=Math.cos(d),g=Math.sin(d),j=Math.cos(c),b=Math.sin(c);if(e.order==="XYZ"){const Et=h*j,It=h*b,zt=_*j,er=_*b;o[0]=bt*j,o[4]=-bt*b,o[8]=g,o[1]=It+zt*g,o[5]=Et-er*g,o[9]=-_*bt,o[2]=er-Et*g,o[6]=zt+It*g,o[10]=h*bt}else if(e.order==="YXZ"){const Et=bt*j,It=bt*b,zt=g*j,er=g*b;o[0]=Et+er*_,o[4]=zt*_-It,o[8]=h*g,o[1]=h*b,o[5]=h*j,o[9]=-_,o[2]=It*_-zt,o[6]=er+Et*_,o[10]=h*bt}else if(e.order==="ZXY"){const Et=bt*j,It=bt*b,zt=g*j,er=g*b;o[0]=Et-er*_,o[4]=-h*b,o[8]=zt+It*_,o[1]=It+zt*_,o[5]=h*j,o[9]=er-Et*_,o[2]=-h*g,o[6]=_,o[10]=h*bt}else if(e.order==="ZYX"){const Et=h*j,It=h*b,zt=_*j,er=_*b;o[0]=bt*j,o[4]=zt*g-It,o[8]=Et*g+er,o[1]=bt*b,o[5]=er*g+Et,o[9]=It*g-zt,o[2]=-g,o[6]=_*bt,o[10]=h*bt}else if(e.order==="YZX"){const Et=h*bt,It=h*g,zt=_*bt,er=_*g;o[0]=bt*j,o[4]=er-Et*b,o[8]=zt*b+It,o[1]=b,o[5]=h*j,o[9]=-_*j,o[2]=-g*j,o[6]=It*b+zt,o[10]=Et-er*b}else if(e.order==="XZY"){const Et=h*bt,It=h*g,zt=_*bt,er=_*g;o[0]=bt*j,o[4]=-b,o[8]=g*j,o[1]=Et*b+er,o[5]=h*j,o[9]=It*b-zt,o[2]=zt*b-It,o[6]=_*j,o[10]=er*b+Et}return o[3]=0,o[7]=0,o[11]=0,o[12]=0,o[13]=0,o[14]=0,o[15]=1,this}makeRotationFromQuaternion(e){return this.compose(_zero,e,_one)}lookAt(e,o,s){const d=this.elements;return _z.subVectors(e,o),_z.lengthSq()===0&&(_z.z=1),_z.normalize(),_x.crossVectors(s,_z),_x.lengthSq()===0&&(Math.abs(s.z)===1?_z.x+=1e-4:_z.z+=1e-4,_z.normalize(),_x.crossVectors(s,_z)),_x.normalize(),_y.crossVectors(_z,_x),d[0]=_x.x,d[4]=_y.x,d[8]=_z.x,d[1]=_x.y,d[5]=_y.y,d[9]=_z.y,d[2]=_x.z,d[6]=_y.z,d[10]=_z.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,o){const s=e.elements,d=o.elements,c=this.elements,h=s[0],_=s[4],bt=s[8],g=s[12],j=s[1],b=s[5],Et=s[9],It=s[13],zt=s[2],er=s[6],Hn=s[10],Qt=s[14],cr=s[3],fr=s[7],jr=s[11],e0=s[15],t0=d[0],o0=d[4],l0=d[8],g0=d[12],i0=d[1],f0=d[5],C0=d[9],Z0=d[13],R0=d[2],Y0=d[6],H0=d[10],ty=d[14],w0=d[3],L0=d[7],k0=d[11],T0=d[15];return c[0]=h*t0+_*i0+bt*R0+g*w0,c[4]=h*o0+_*f0+bt*Y0+g*L0,c[8]=h*l0+_*C0+bt*H0+g*k0,c[12]=h*g0+_*Z0+bt*ty+g*T0,c[1]=j*t0+b*i0+Et*R0+It*w0,c[5]=j*o0+b*f0+Et*Y0+It*L0,c[9]=j*l0+b*C0+Et*H0+It*k0,c[13]=j*g0+b*Z0+Et*ty+It*T0,c[2]=zt*t0+er*i0+Hn*R0+Qt*w0,c[6]=zt*o0+er*f0+Hn*Y0+Qt*L0,c[10]=zt*l0+er*C0+Hn*H0+Qt*k0,c[14]=zt*g0+er*Z0+Hn*ty+Qt*T0,c[3]=cr*t0+fr*i0+jr*R0+e0*w0,c[7]=cr*o0+fr*f0+jr*Y0+e0*L0,c[11]=cr*l0+fr*C0+jr*H0+e0*k0,c[15]=cr*g0+fr*Z0+jr*ty+e0*T0,this}multiplyScalar(e){const o=this.elements;return o[0]*=e,o[4]*=e,o[8]*=e,o[12]*=e,o[1]*=e,o[5]*=e,o[9]*=e,o[13]*=e,o[2]*=e,o[6]*=e,o[10]*=e,o[14]*=e,o[3]*=e,o[7]*=e,o[11]*=e,o[15]*=e,this}determinant(){const e=this.elements,o=e[0],s=e[4],d=e[8],c=e[12],h=e[1],_=e[5],bt=e[9],g=e[13],j=e[2],b=e[6],Et=e[10],It=e[14],zt=e[3],er=e[7],Hn=e[11],Qt=e[15];return zt*(+c*bt*b-d*g*b-c*_*Et+s*g*Et+d*_*It-s*bt*It)+er*(+o*bt*It-o*g*Et+c*h*Et-d*h*It+d*g*j-c*bt*j)+Hn*(+o*g*b-o*_*It-c*h*b+s*h*It+c*_*j-s*g*j)+Qt*(-d*_*j-o*bt*b+o*_*Et+d*h*b-s*h*Et+s*bt*j)}transpose(){const e=this.elements;let o;return o=e[1],e[1]=e[4],e[4]=o,o=e[2],e[2]=e[8],e[8]=o,o=e[6],e[6]=e[9],e[9]=o,o=e[3],e[3]=e[12],e[12]=o,o=e[7],e[7]=e[13],e[13]=o,o=e[11],e[11]=e[14],e[14]=o,this}setPosition(e,o,s){const d=this.elements;return e.isVector3?(d[12]=e.x,d[13]=e.y,d[14]=e.z):(d[12]=e,d[13]=o,d[14]=s),this}invert(){const e=this.elements,o=e[0],s=e[1],d=e[2],c=e[3],h=e[4],_=e[5],bt=e[6],g=e[7],j=e[8],b=e[9],Et=e[10],It=e[11],zt=e[12],er=e[13],Hn=e[14],Qt=e[15],cr=b*Hn*g-er*Et*g+er*bt*It-_*Hn*It-b*bt*Qt+_*Et*Qt,fr=zt*Et*g-j*Hn*g-zt*bt*It+h*Hn*It+j*bt*Qt-h*Et*Qt,jr=j*er*g-zt*b*g+zt*_*It-h*er*It-j*_*Qt+h*b*Qt,e0=zt*b*bt-j*er*bt-zt*_*Et+h*er*Et+j*_*Hn-h*b*Hn,t0=o*cr+s*fr+d*jr+c*e0;if(t0===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const o0=1/t0;return e[0]=cr*o0,e[1]=(er*Et*c-b*Hn*c-er*d*It+s*Hn*It+b*d*Qt-s*Et*Qt)*o0,e[2]=(_*Hn*c-er*bt*c+er*d*g-s*Hn*g-_*d*Qt+s*bt*Qt)*o0,e[3]=(b*bt*c-_*Et*c-b*d*g+s*Et*g+_*d*It-s*bt*It)*o0,e[4]=fr*o0,e[5]=(j*Hn*c-zt*Et*c+zt*d*It-o*Hn*It-j*d*Qt+o*Et*Qt)*o0,e[6]=(zt*bt*c-h*Hn*c-zt*d*g+o*Hn*g+h*d*Qt-o*bt*Qt)*o0,e[7]=(h*Et*c-j*bt*c+j*d*g-o*Et*g-h*d*It+o*bt*It)*o0,e[8]=jr*o0,e[9]=(zt*b*c-j*er*c-zt*s*It+o*er*It+j*s*Qt-o*b*Qt)*o0,e[10]=(h*er*c-zt*_*c+zt*s*g-o*er*g-h*s*Qt+o*_*Qt)*o0,e[11]=(j*_*c-h*b*c-j*s*g+o*b*g+h*s*It-o*_*It)*o0,e[12]=e0*o0,e[13]=(j*er*d-zt*b*d+zt*s*Et-o*er*Et-j*s*Hn+o*b*Hn)*o0,e[14]=(zt*_*d-h*er*d-zt*s*bt+o*er*bt+h*s*Hn-o*_*Hn)*o0,e[15]=(h*b*d-j*_*d+j*s*bt-o*b*bt-h*s*Et+o*_*Et)*o0,this}scale(e){const o=this.elements,s=e.x,d=e.y,c=e.z;return o[0]*=s,o[4]*=d,o[8]*=c,o[1]*=s,o[5]*=d,o[9]*=c,o[2]*=s,o[6]*=d,o[10]*=c,o[3]*=s,o[7]*=d,o[11]*=c,this}getMaxScaleOnAxis(){const e=this.elements,o=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],s=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],d=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(o,s,d))}makeTranslation(e,o,s){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,o,0,0,1,s,0,0,0,1),this}makeRotationX(e){const o=Math.cos(e),s=Math.sin(e);return this.set(1,0,0,0,0,o,-s,0,0,s,o,0,0,0,0,1),this}makeRotationY(e){const o=Math.cos(e),s=Math.sin(e);return this.set(o,0,s,0,0,1,0,0,-s,0,o,0,0,0,0,1),this}makeRotationZ(e){const o=Math.cos(e),s=Math.sin(e);return this.set(o,-s,0,0,s,o,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,o){const s=Math.cos(o),d=Math.sin(o),c=1-s,h=e.x,_=e.y,bt=e.z,g=c*h,j=c*_;return this.set(g*h+s,g*_-d*bt,g*bt+d*_,0,g*_+d*bt,j*_+s,j*bt-d*h,0,g*bt-d*_,j*bt+d*h,c*bt*bt+s,0,0,0,0,1),this}makeScale(e,o,s){return this.set(e,0,0,0,0,o,0,0,0,0,s,0,0,0,0,1),this}makeShear(e,o,s,d,c,h){return this.set(1,s,c,0,e,1,h,0,o,d,1,0,0,0,0,1),this}compose(e,o,s){const d=this.elements,c=o._x,h=o._y,_=o._z,bt=o._w,g=c+c,j=h+h,b=_+_,Et=c*g,It=c*j,zt=c*b,er=h*j,Hn=h*b,Qt=_*b,cr=bt*g,fr=bt*j,jr=bt*b,e0=s.x,t0=s.y,o0=s.z;return d[0]=(1-(er+Qt))*e0,d[1]=(It+jr)*e0,d[2]=(zt-fr)*e0,d[3]=0,d[4]=(It-jr)*t0,d[5]=(1-(Et+Qt))*t0,d[6]=(Hn+cr)*t0,d[7]=0,d[8]=(zt+fr)*o0,d[9]=(Hn-cr)*o0,d[10]=(1-(Et+er))*o0,d[11]=0,d[12]=e.x,d[13]=e.y,d[14]=e.z,d[15]=1,this}decompose(e,o,s){const d=this.elements;let c=_v1$5.set(d[0],d[1],d[2]).length();const h=_v1$5.set(d[4],d[5],d[6]).length(),_=_v1$5.set(d[8],d[9],d[10]).length();this.determinant()<0&&(c=-c),e.x=d[12],e.y=d[13],e.z=d[14],_m1$4.copy(this);const g=1/c,j=1/h,b=1/_;return _m1$4.elements[0]*=g,_m1$4.elements[1]*=g,_m1$4.elements[2]*=g,_m1$4.elements[4]*=j,_m1$4.elements[5]*=j,_m1$4.elements[6]*=j,_m1$4.elements[8]*=b,_m1$4.elements[9]*=b,_m1$4.elements[10]*=b,o.setFromRotationMatrix(_m1$4),s.x=c,s.y=h,s.z=_,this}makePerspective(e,o,s,d,c,h,_=WebGLCoordinateSystem){const bt=this.elements,g=2*c/(o-e),j=2*c/(s-d),b=(o+e)/(o-e),Et=(s+d)/(s-d);let It,zt;if(_===WebGLCoordinateSystem)It=-(h+c)/(h-c),zt=-2*h*c/(h-c);else if(_===WebGPUCoordinateSystem)It=-h/(h-c),zt=-h*c/(h-c);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+_);return bt[0]=g,bt[4]=0,bt[8]=b,bt[12]=0,bt[1]=0,bt[5]=j,bt[9]=Et,bt[13]=0,bt[2]=0,bt[6]=0,bt[10]=It,bt[14]=zt,bt[3]=0,bt[7]=0,bt[11]=-1,bt[15]=0,this}makeOrthographic(e,o,s,d,c,h,_=WebGLCoordinateSystem){const bt=this.elements,g=1/(o-e),j=1/(s-d),b=1/(h-c),Et=(o+e)*g,It=(s+d)*j;let zt,er;if(_===WebGLCoordinateSystem)zt=(h+c)*b,er=-2*b;else if(_===WebGPUCoordinateSystem)zt=c*b,er=-1*b;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+_);return bt[0]=2*g,bt[4]=0,bt[8]=0,bt[12]=-Et,bt[1]=0,bt[5]=2*j,bt[9]=0,bt[13]=-It,bt[2]=0,bt[6]=0,bt[10]=er,bt[14]=-zt,bt[3]=0,bt[7]=0,bt[11]=0,bt[15]=1,this}equals(e){const o=this.elements,s=e.elements;for(let d=0;d<16;d++)if(o[d]!==s[d])return!1;return!0}fromArray(e,o=0){for(let s=0;s<16;s++)this.elements[s]=e[s+o];return this}toArray(e=[],o=0){const s=this.elements;return e[o]=s[0],e[o+1]=s[1],e[o+2]=s[2],e[o+3]=s[3],e[o+4]=s[4],e[o+5]=s[5],e[o+6]=s[6],e[o+7]=s[7],e[o+8]=s[8],e[o+9]=s[9],e[o+10]=s[10],e[o+11]=s[11],e[o+12]=s[12],e[o+13]=s[13],e[o+14]=s[14],e[o+15]=s[15],e}}const _v1$5=new Vector3,_m1$4=new Matrix4,_zero=new Vector3(0,0,0),_one=new Vector3(1,1,1),_x=new Vector3,_y=new Vector3,_z=new Vector3,_matrix$2=new Matrix4,_quaternion$3=new Quaternion;class Euler{constructor(e=0,o=0,s=0,d=Euler.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=o,this._z=s,this._order=d}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,o,s,d=this._order){return this._x=e,this._y=o,this._z=s,this._order=d,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,o=this._order,s=!0){const d=e.elements,c=d[0],h=d[4],_=d[8],bt=d[1],g=d[5],j=d[9],b=d[2],Et=d[6],It=d[10];switch(o){case"XYZ":this._y=Math.asin(clamp(_,-1,1)),Math.abs(_)<.9999999?(this._x=Math.atan2(-j,It),this._z=Math.atan2(-h,c)):(this._x=Math.atan2(Et,g),this._z=0);break;case"YXZ":this._x=Math.asin(-clamp(j,-1,1)),Math.abs(j)<.9999999?(this._y=Math.atan2(_,It),this._z=Math.atan2(bt,g)):(this._y=Math.atan2(-b,c),this._z=0);break;case"ZXY":this._x=Math.asin(clamp(Et,-1,1)),Math.abs(Et)<.9999999?(this._y=Math.atan2(-b,It),this._z=Math.atan2(-h,g)):(this._y=0,this._z=Math.atan2(bt,c));break;case"ZYX":this._y=Math.asin(-clamp(b,-1,1)),Math.abs(b)<.9999999?(this._x=Math.atan2(Et,It),this._z=Math.atan2(bt,c)):(this._x=0,this._z=Math.atan2(-h,g));break;case"YZX":this._z=Math.asin(clamp(bt,-1,1)),Math.abs(bt)<.9999999?(this._x=Math.atan2(-j,g),this._y=Math.atan2(-b,c)):(this._x=0,this._y=Math.atan2(_,It));break;case"XZY":this._z=Math.asin(-clamp(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(Et,g),this._y=Math.atan2(_,c)):(this._x=Math.atan2(-j,It),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+o)}return this._order=o,s===!0&&this._onChangeCallback(),this}setFromQuaternion(e,o,s){return _matrix$2.makeRotationFromQuaternion(e),this.setFromRotationMatrix(_matrix$2,o,s)}setFromVector3(e,o=this._order){return this.set(e.x,e.y,e.z,o)}reorder(e){return _quaternion$3.setFromEuler(this),this.setFromQuaternion(_quaternion$3,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],o=0){return e[o]=this._x,e[o+1]=this._y,e[o+2]=this._z,e[o+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Euler.DEFAULT_ORDER="XYZ";class Layers{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let _object3DId=0;const _v1$4=new Vector3,_q1=new Quaternion,_m1$3=new Matrix4,_target=new Vector3,_position$3=new Vector3,_scale$2=new Vector3,_quaternion$2=new Quaternion,_xAxis=new Vector3(1,0,0),_yAxis=new Vector3(0,1,0),_zAxis=new Vector3(0,0,1),_addedEvent={type:"added"},_removedEvent={type:"removed"},_childaddedEvent={type:"childadded",child:null},_childremovedEvent={type:"childremoved",child:null};class Object3D extends EventDispatcher{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:_object3DId++}),this.uuid=generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Object3D.DEFAULT_UP.clone();const e=new Vector3,o=new Euler,s=new Quaternion,d=new Vector3(1,1,1);function c(){s.setFromEuler(o,!1)}function h(){o.setFromQuaternion(s,void 0,!1)}o._onChange(c),s._onChange(h),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:o},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:d},modelViewMatrix:{value:new Matrix4},normalMatrix:{value:new Matrix3}}),this.matrix=new Matrix4,this.matrixWorld=new Matrix4,this.matrixAutoUpdate=Object3D.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Layers,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,o){this.quaternion.setFromAxisAngle(e,o)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,o){return _q1.setFromAxisAngle(e,o),this.quaternion.multiply(_q1),this}rotateOnWorldAxis(e,o){return _q1.setFromAxisAngle(e,o),this.quaternion.premultiply(_q1),this}rotateX(e){return this.rotateOnAxis(_xAxis,e)}rotateY(e){return this.rotateOnAxis(_yAxis,e)}rotateZ(e){return this.rotateOnAxis(_zAxis,e)}translateOnAxis(e,o){return _v1$4.copy(e).applyQuaternion(this.quaternion),this.position.add(_v1$4.multiplyScalar(o)),this}translateX(e){return this.translateOnAxis(_xAxis,e)}translateY(e){return this.translateOnAxis(_yAxis,e)}translateZ(e){return this.translateOnAxis(_zAxis,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(_m1$3.copy(this.matrixWorld).invert())}lookAt(e,o,s){e.isVector3?_target.copy(e):_target.set(e,o,s);const d=this.parent;this.updateWorldMatrix(!0,!1),_position$3.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?_m1$3.lookAt(_position$3,_target,this.up):_m1$3.lookAt(_target,_position$3,this.up),this.quaternion.setFromRotationMatrix(_m1$3),d&&(_m1$3.extractRotation(d.matrixWorld),_q1.setFromRotationMatrix(_m1$3),this.quaternion.premultiply(_q1.invert()))}add(e){if(arguments.length>1){for(let o=0;o<arguments.length;o++)this.add(arguments[o]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(_addedEvent),_childaddedEvent.child=e,this.dispatchEvent(_childaddedEvent),_childaddedEvent.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const o=this.children.indexOf(e);return o!==-1&&(e.parent=null,this.children.splice(o,1),e.dispatchEvent(_removedEvent),_childremovedEvent.child=e,this.dispatchEvent(_childremovedEvent),_childremovedEvent.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),_m1$3.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),_m1$3.multiply(e.parent.matrixWorld)),e.applyMatrix4(_m1$3),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,o){if(this[e]===o)return this;for(let s=0,d=this.children.length;s<d;s++){const h=this.children[s].getObjectByProperty(e,o);if(h!==void 0)return h}}getObjectsByProperty(e,o,s=[]){this[e]===o&&s.push(this);const d=this.children;for(let c=0,h=d.length;c<h;c++)d[c].getObjectsByProperty(e,o,s);return s}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$3,e,_scale$2),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$3,_quaternion$2,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const o=this.matrixWorld.elements;return e.set(o[8],o[9],o[10]).normalize()}raycast(){}traverse(e){e(this);const o=this.children;for(let s=0,d=o.length;s<d;s++)o[s].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const o=this.children;for(let s=0,d=o.length;s<d;s++)o[s].traverseVisible(e)}traverseAncestors(e){const o=this.parent;o!==null&&(e(o),o.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const o=this.children;for(let s=0,d=o.length;s<d;s++){const c=o[s];(c.matrixWorldAutoUpdate===!0||e===!0)&&c.updateMatrixWorld(e)}}updateWorldMatrix(e,o){const s=this.parent;if(e===!0&&s!==null&&s.matrixWorldAutoUpdate===!0&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),o===!0){const d=this.children;for(let c=0,h=d.length;c<h;c++){const _=d[c];_.matrixWorldAutoUpdate===!0&&_.updateWorldMatrix(!1,!0)}}}toJSON(e){const o=e===void 0||typeof e=="string",s={};o&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const d={};d.uuid=this.uuid,d.type=this.type,this.name!==""&&(d.name=this.name),this.castShadow===!0&&(d.castShadow=!0),this.receiveShadow===!0&&(d.receiveShadow=!0),this.visible===!1&&(d.visible=!1),this.frustumCulled===!1&&(d.frustumCulled=!1),this.renderOrder!==0&&(d.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(d.userData=this.userData),d.layers=this.layers.mask,d.matrix=this.matrix.toArray(),d.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(d.matrixAutoUpdate=!1),this.isInstancedMesh&&(d.type="InstancedMesh",d.count=this.count,d.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(d.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(d.type="BatchedMesh",d.perObjectFrustumCulled=this.perObjectFrustumCulled,d.sortObjects=this.sortObjects,d.drawRanges=this._drawRanges,d.reservedRanges=this._reservedRanges,d.visibility=this._visibility,d.active=this._active,d.bounds=this._bounds.map(_=>({boxInitialized:_.boxInitialized,boxMin:_.box.min.toArray(),boxMax:_.box.max.toArray(),sphereInitialized:_.sphereInitialized,sphereRadius:_.sphere.radius,sphereCenter:_.sphere.center.toArray()})),d.maxGeometryCount=this._maxGeometryCount,d.maxVertexCount=this._maxVertexCount,d.maxIndexCount=this._maxIndexCount,d.geometryInitialized=this._geometryInitialized,d.geometryCount=this._geometryCount,d.matricesTexture=this._matricesTexture.toJSON(e),this.boundingSphere!==null&&(d.boundingSphere={center:d.boundingSphere.center.toArray(),radius:d.boundingSphere.radius}),this.boundingBox!==null&&(d.boundingBox={min:d.boundingBox.min.toArray(),max:d.boundingBox.max.toArray()}));function c(_,bt){return _[bt.uuid]===void 0&&(_[bt.uuid]=bt.toJSON(e)),bt.uuid}if(this.isScene)this.background&&(this.background.isColor?d.background=this.background.toJSON():this.background.isTexture&&(d.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(d.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){d.geometry=c(e.geometries,this.geometry);const _=this.geometry.parameters;if(_!==void 0&&_.shapes!==void 0){const bt=_.shapes;if(Array.isArray(bt))for(let g=0,j=bt.length;g<j;g++){const b=bt[g];c(e.shapes,b)}else c(e.shapes,bt)}}if(this.isSkinnedMesh&&(d.bindMode=this.bindMode,d.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(c(e.skeletons,this.skeleton),d.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const _=[];for(let bt=0,g=this.material.length;bt<g;bt++)_.push(c(e.materials,this.material[bt]));d.material=_}else d.material=c(e.materials,this.material);if(this.children.length>0){d.children=[];for(let _=0;_<this.children.length;_++)d.children.push(this.children[_].toJSON(e).object)}if(this.animations.length>0){d.animations=[];for(let _=0;_<this.animations.length;_++){const bt=this.animations[_];d.animations.push(c(e.animations,bt))}}if(o){const _=h(e.geometries),bt=h(e.materials),g=h(e.textures),j=h(e.images),b=h(e.shapes),Et=h(e.skeletons),It=h(e.animations),zt=h(e.nodes);_.length>0&&(s.geometries=_),bt.length>0&&(s.materials=bt),g.length>0&&(s.textures=g),j.length>0&&(s.images=j),b.length>0&&(s.shapes=b),Et.length>0&&(s.skeletons=Et),It.length>0&&(s.animations=It),zt.length>0&&(s.nodes=zt)}return s.object=d,s;function h(_){const bt=[];for(const g in _){const j=_[g];delete j.metadata,bt.push(j)}return bt}}clone(e){return new this.constructor().copy(this,e)}copy(e,o=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),o===!0)for(let s=0;s<e.children.length;s++){const d=e.children[s];this.add(d.clone())}return this}}Object3D.DEFAULT_UP=new Vector3(0,1,0);Object3D.DEFAULT_MATRIX_AUTO_UPDATE=!0;Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const _v0$1=new Vector3,_v1$3=new Vector3,_v2$2=new Vector3,_v3$2=new Vector3,_vab=new Vector3,_vac=new Vector3,_vbc=new Vector3,_vap=new Vector3,_vbp=new Vector3,_vcp=new Vector3;class Triangle{constructor(e=new Vector3,o=new Vector3,s=new Vector3){this.a=e,this.b=o,this.c=s}static getNormal(e,o,s,d){d.subVectors(s,o),_v0$1.subVectors(e,o),d.cross(_v0$1);const c=d.lengthSq();return c>0?d.multiplyScalar(1/Math.sqrt(c)):d.set(0,0,0)}static getBarycoord(e,o,s,d,c){_v0$1.subVectors(d,o),_v1$3.subVectors(s,o),_v2$2.subVectors(e,o);const h=_v0$1.dot(_v0$1),_=_v0$1.dot(_v1$3),bt=_v0$1.dot(_v2$2),g=_v1$3.dot(_v1$3),j=_v1$3.dot(_v2$2),b=h*g-_*_;if(b===0)return c.set(0,0,0),null;const Et=1/b,It=(g*bt-_*j)*Et,zt=(h*j-_*bt)*Et;return c.set(1-It-zt,zt,It)}static containsPoint(e,o,s,d){return this.getBarycoord(e,o,s,d,_v3$2)===null?!1:_v3$2.x>=0&&_v3$2.y>=0&&_v3$2.x+_v3$2.y<=1}static getInterpolation(e,o,s,d,c,h,_,bt){return this.getBarycoord(e,o,s,d,_v3$2)===null?(bt.x=0,bt.y=0,"z"in bt&&(bt.z=0),"w"in bt&&(bt.w=0),null):(bt.setScalar(0),bt.addScaledVector(c,_v3$2.x),bt.addScaledVector(h,_v3$2.y),bt.addScaledVector(_,_v3$2.z),bt)}static isFrontFacing(e,o,s,d){return _v0$1.subVectors(s,o),_v1$3.subVectors(e,o),_v0$1.cross(_v1$3).dot(d)<0}set(e,o,s){return this.a.copy(e),this.b.copy(o),this.c.copy(s),this}setFromPointsAndIndices(e,o,s,d){return this.a.copy(e[o]),this.b.copy(e[s]),this.c.copy(e[d]),this}setFromAttributeAndIndices(e,o,s,d){return this.a.fromBufferAttribute(e,o),this.b.fromBufferAttribute(e,s),this.c.fromBufferAttribute(e,d),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return _v0$1.subVectors(this.c,this.b),_v1$3.subVectors(this.a,this.b),_v0$1.cross(_v1$3).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Triangle.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,o){return Triangle.getBarycoord(e,this.a,this.b,this.c,o)}getInterpolation(e,o,s,d,c){return Triangle.getInterpolation(e,this.a,this.b,this.c,o,s,d,c)}containsPoint(e){return Triangle.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Triangle.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,o){const s=this.a,d=this.b,c=this.c;let h,_;_vab.subVectors(d,s),_vac.subVectors(c,s),_vap.subVectors(e,s);const bt=_vab.dot(_vap),g=_vac.dot(_vap);if(bt<=0&&g<=0)return o.copy(s);_vbp.subVectors(e,d);const j=_vab.dot(_vbp),b=_vac.dot(_vbp);if(j>=0&&b<=j)return o.copy(d);const Et=bt*b-j*g;if(Et<=0&&bt>=0&&j<=0)return h=bt/(bt-j),o.copy(s).addScaledVector(_vab,h);_vcp.subVectors(e,c);const It=_vab.dot(_vcp),zt=_vac.dot(_vcp);if(zt>=0&&It<=zt)return o.copy(c);const er=It*g-bt*zt;if(er<=0&&g>=0&&zt<=0)return _=g/(g-zt),o.copy(s).addScaledVector(_vac,_);const Hn=j*zt-It*b;if(Hn<=0&&b-j>=0&&It-zt>=0)return _vbc.subVectors(c,d),_=(b-j)/(b-j+(It-zt)),o.copy(d).addScaledVector(_vbc,_);const Qt=1/(Hn+er+Et);return h=er*Qt,_=Et*Qt,o.copy(s).addScaledVector(_vab,h).addScaledVector(_vac,_)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const _colorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},_hslA={h:0,s:0,l:0},_hslB={h:0,s:0,l:0};function hue2rgb(a,e,o){return o<0&&(o+=1),o>1&&(o-=1),o<1/6?a+(e-a)*6*o:o<1/2?e:o<2/3?a+(e-a)*6*(2/3-o):a}class Color{constructor(e,o,s){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,o,s)}set(e,o,s){if(o===void 0&&s===void 0){const d=e;d&&d.isColor?this.copy(d):typeof d=="number"?this.setHex(d):typeof d=="string"&&this.setStyle(d)}else this.setRGB(e,o,s);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,o=SRGBColorSpace){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,ColorManagement.toWorkingColorSpace(this,o),this}setRGB(e,o,s,d=ColorManagement.workingColorSpace){return this.r=e,this.g=o,this.b=s,ColorManagement.toWorkingColorSpace(this,d),this}setHSL(e,o,s,d=ColorManagement.workingColorSpace){if(e=euclideanModulo(e,1),o=clamp(o,0,1),s=clamp(s,0,1),o===0)this.r=this.g=this.b=s;else{const c=s<=.5?s*(1+o):s+o-s*o,h=2*s-c;this.r=hue2rgb(h,c,e+1/3),this.g=hue2rgb(h,c,e),this.b=hue2rgb(h,c,e-1/3)}return ColorManagement.toWorkingColorSpace(this,d),this}setStyle(e,o=SRGBColorSpace){function s(c){c!==void 0&&parseFloat(c)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let d;if(d=/^(\w+)\(([^\)]*)\)/.exec(e)){let c;const h=d[1],_=d[2];switch(h){case"rgb":case"rgba":if(c=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(_))return s(c[4]),this.setRGB(Math.min(255,parseInt(c[1],10))/255,Math.min(255,parseInt(c[2],10))/255,Math.min(255,parseInt(c[3],10))/255,o);if(c=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(_))return s(c[4]),this.setRGB(Math.min(100,parseInt(c[1],10))/100,Math.min(100,parseInt(c[2],10))/100,Math.min(100,parseInt(c[3],10))/100,o);break;case"hsl":case"hsla":if(c=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(_))return s(c[4]),this.setHSL(parseFloat(c[1])/360,parseFloat(c[2])/100,parseFloat(c[3])/100,o);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(d=/^\#([A-Fa-f\d]+)$/.exec(e)){const c=d[1],h=c.length;if(h===3)return this.setRGB(parseInt(c.charAt(0),16)/15,parseInt(c.charAt(1),16)/15,parseInt(c.charAt(2),16)/15,o);if(h===6)return this.setHex(parseInt(c,16),o);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,o);return this}setColorName(e,o=SRGBColorSpace){const s=_colorKeywords[e.toLowerCase()];return s!==void 0?this.setHex(s,o):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=SRGBToLinear(e.r),this.g=SRGBToLinear(e.g),this.b=SRGBToLinear(e.b),this}copyLinearToSRGB(e){return this.r=LinearToSRGB(e.r),this.g=LinearToSRGB(e.g),this.b=LinearToSRGB(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=SRGBColorSpace){return ColorManagement.fromWorkingColorSpace(_color.copy(this),e),Math.round(clamp(_color.r*255,0,255))*65536+Math.round(clamp(_color.g*255,0,255))*256+Math.round(clamp(_color.b*255,0,255))}getHexString(e=SRGBColorSpace){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,o=ColorManagement.workingColorSpace){ColorManagement.fromWorkingColorSpace(_color.copy(this),o);const s=_color.r,d=_color.g,c=_color.b,h=Math.max(s,d,c),_=Math.min(s,d,c);let bt,g;const j=(_+h)/2;if(_===h)bt=0,g=0;else{const b=h-_;switch(g=j<=.5?b/(h+_):b/(2-h-_),h){case s:bt=(d-c)/b+(d<c?6:0);break;case d:bt=(c-s)/b+2;break;case c:bt=(s-d)/b+4;break}bt/=6}return e.h=bt,e.s=g,e.l=j,e}getRGB(e,o=ColorManagement.workingColorSpace){return ColorManagement.fromWorkingColorSpace(_color.copy(this),o),e.r=_color.r,e.g=_color.g,e.b=_color.b,e}getStyle(e=SRGBColorSpace){ColorManagement.fromWorkingColorSpace(_color.copy(this),e);const o=_color.r,s=_color.g,d=_color.b;return e!==SRGBColorSpace?`color(${e} ${o.toFixed(3)} ${s.toFixed(3)} ${d.toFixed(3)})`:`rgb(${Math.round(o*255)},${Math.round(s*255)},${Math.round(d*255)})`}offsetHSL(e,o,s){return this.getHSL(_hslA),this.setHSL(_hslA.h+e,_hslA.s+o,_hslA.l+s)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,o){return this.r=e.r+o.r,this.g=e.g+o.g,this.b=e.b+o.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,o){return this.r+=(e.r-this.r)*o,this.g+=(e.g-this.g)*o,this.b+=(e.b-this.b)*o,this}lerpColors(e,o,s){return this.r=e.r+(o.r-e.r)*s,this.g=e.g+(o.g-e.g)*s,this.b=e.b+(o.b-e.b)*s,this}lerpHSL(e,o){this.getHSL(_hslA),e.getHSL(_hslB);const s=lerp(_hslA.h,_hslB.h,o),d=lerp(_hslA.s,_hslB.s,o),c=lerp(_hslA.l,_hslB.l,o);return this.setHSL(s,d,c),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const o=this.r,s=this.g,d=this.b,c=e.elements;return this.r=c[0]*o+c[3]*s+c[6]*d,this.g=c[1]*o+c[4]*s+c[7]*d,this.b=c[2]*o+c[5]*s+c[8]*d,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,o=0){return this.r=e[o],this.g=e[o+1],this.b=e[o+2],this}toArray(e=[],o=0){return e[o]=this.r,e[o+1]=this.g,e[o+2]=this.b,e}fromBufferAttribute(e,o){return this.r=e.getX(o),this.g=e.getY(o),this.b=e.getZ(o),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const _color=new Color;Color.NAMES=_colorKeywords;let _materialId=0;class Material extends EventDispatcher{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:_materialId++}),this.uuid=generateUUID(),this.name="",this.type="Material",this.blending=NormalBlending,this.side=FrontSide,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=SrcAlphaFactor,this.blendDst=OneMinusSrcAlphaFactor,this.blendEquation=AddEquation,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Color(0,0,0),this.blendAlpha=0,this.depthFunc=LessEqualDepth,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=AlwaysStencilFunc,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=KeepStencilOp,this.stencilZFail=KeepStencilOp,this.stencilZPass=KeepStencilOp,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const o in e){const s=e[o];if(s===void 0){console.warn(`THREE.Material: parameter '${o}' has value of undefined.`);continue}const d=this[o];if(d===void 0){console.warn(`THREE.Material: '${o}' is not a property of THREE.${this.type}.`);continue}d&&d.isColor?d.set(s):d&&d.isVector3&&s&&s.isVector3?d.copy(s):this[o]=s}}toJSON(e){const o=e===void 0||typeof e=="string";o&&(e={textures:{},images:{}});const s={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(s.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(s.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(s.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(s.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(s.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(s.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(s.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(e).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(e).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(e).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(e).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(e).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapRotation!==void 0&&(s.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(s.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==NormalBlending&&(s.blending=this.blending),this.side!==FrontSide&&(s.side=this.side),this.vertexColors===!0&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.transparent===!0&&(s.transparent=!0),this.blendSrc!==SrcAlphaFactor&&(s.blendSrc=this.blendSrc),this.blendDst!==OneMinusSrcAlphaFactor&&(s.blendDst=this.blendDst),this.blendEquation!==AddEquation&&(s.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(s.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(s.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(s.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(s.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(s.blendAlpha=this.blendAlpha),this.depthFunc!==LessEqualDepth&&(s.depthFunc=this.depthFunc),this.depthTest===!1&&(s.depthTest=this.depthTest),this.depthWrite===!1&&(s.depthWrite=this.depthWrite),this.colorWrite===!1&&(s.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(s.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==AlwaysStencilFunc&&(s.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(s.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(s.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==KeepStencilOp&&(s.stencilFail=this.stencilFail),this.stencilZFail!==KeepStencilOp&&(s.stencilZFail=this.stencilZFail),this.stencilZPass!==KeepStencilOp&&(s.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(s.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaHash===!0&&(s.alphaHash=!0),this.alphaToCoverage===!0&&(s.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=!0),this.forceSinglePass===!0&&(s.forceSinglePass=!0),this.wireframe===!0&&(s.wireframe=!0),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=!0),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),this.fog===!1&&(s.fog=!1),Object.keys(this.userData).length>0&&(s.userData=this.userData);function d(c){const h=[];for(const _ in c){const bt=c[_];delete bt.metadata,h.push(bt)}return h}if(o){const c=d(e.textures),h=d(e.images);c.length>0&&(s.textures=c),h.length>0&&(s.images=h)}return s}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const o=e.clippingPlanes;let s=null;if(o!==null){const d=o.length;s=new Array(d);for(let c=0;c!==d;++c)s[c]=o[c].clone()}return this.clippingPlanes=s,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class MeshBasicMaterial extends Material{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const _tables=_generateTables();function _generateTables(){const a=new ArrayBuffer(4),e=new Float32Array(a),o=new Uint32Array(a),s=new Uint32Array(512),d=new Uint32Array(512);for(let bt=0;bt<256;++bt){const g=bt-127;g<-27?(s[bt]=0,s[bt|256]=32768,d[bt]=24,d[bt|256]=24):g<-14?(s[bt]=1024>>-g-14,s[bt|256]=1024>>-g-14|32768,d[bt]=-g-1,d[bt|256]=-g-1):g<=15?(s[bt]=g+15<<10,s[bt|256]=g+15<<10|32768,d[bt]=13,d[bt|256]=13):g<128?(s[bt]=31744,s[bt|256]=64512,d[bt]=24,d[bt|256]=24):(s[bt]=31744,s[bt|256]=64512,d[bt]=13,d[bt|256]=13)}const c=new Uint32Array(2048),h=new Uint32Array(64),_=new Uint32Array(64);for(let bt=1;bt<1024;++bt){let g=bt<<13,j=0;for(;!(g&8388608);)g<<=1,j-=8388608;g&=-8388609,j+=947912704,c[bt]=g|j}for(let bt=1024;bt<2048;++bt)c[bt]=939524096+(bt-1024<<13);for(let bt=1;bt<31;++bt)h[bt]=bt<<23;h[31]=1199570944,h[32]=2147483648;for(let bt=33;bt<63;++bt)h[bt]=2147483648+(bt-32<<23);h[63]=3347054592;for(let bt=1;bt<64;++bt)bt!==32&&(_[bt]=1024);return{floatView:e,uint32View:o,baseTable:s,shiftTable:d,mantissaTable:c,exponentTable:h,offsetTable:_}}function toHalfFloat(a){Math.abs(a)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),a=clamp(a,-65504,65504),_tables.floatView[0]=a;const e=_tables.uint32View[0],o=e>>23&511;return _tables.baseTable[o]+((e&8388607)>>_tables.shiftTable[o])}function fromHalfFloat(a){const e=a>>10;return _tables.uint32View[0]=_tables.mantissaTable[_tables.offsetTable[e]+(a&1023)]+_tables.exponentTable[e],_tables.floatView[0]}const DataUtils={toHalfFloat,fromHalfFloat},_vector$9=new Vector3,_vector2$1=new Vector2;class BufferAttribute{constructor(e,o,s=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=o,this.count=e!==void 0?e.length/o:0,this.normalized=s,this.usage=StaticDrawUsage,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=FloatType,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return warnOnce("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,o){this.updateRanges.push({start:e,count:o})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,o,s){e*=this.itemSize,s*=o.itemSize;for(let d=0,c=this.itemSize;d<c;d++)this.array[e+d]=o.array[s+d];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let o=0,s=this.count;o<s;o++)_vector2$1.fromBufferAttribute(this,o),_vector2$1.applyMatrix3(e),this.setXY(o,_vector2$1.x,_vector2$1.y);else if(this.itemSize===3)for(let o=0,s=this.count;o<s;o++)_vector$9.fromBufferAttribute(this,o),_vector$9.applyMatrix3(e),this.setXYZ(o,_vector$9.x,_vector$9.y,_vector$9.z);return this}applyMatrix4(e){for(let o=0,s=this.count;o<s;o++)_vector$9.fromBufferAttribute(this,o),_vector$9.applyMatrix4(e),this.setXYZ(o,_vector$9.x,_vector$9.y,_vector$9.z);return this}applyNormalMatrix(e){for(let o=0,s=this.count;o<s;o++)_vector$9.fromBufferAttribute(this,o),_vector$9.applyNormalMatrix(e),this.setXYZ(o,_vector$9.x,_vector$9.y,_vector$9.z);return this}transformDirection(e){for(let o=0,s=this.count;o<s;o++)_vector$9.fromBufferAttribute(this,o),_vector$9.transformDirection(e),this.setXYZ(o,_vector$9.x,_vector$9.y,_vector$9.z);return this}set(e,o=0){return this.array.set(e,o),this}getComponent(e,o){let s=this.array[e*this.itemSize+o];return this.normalized&&(s=denormalize(s,this.array)),s}setComponent(e,o,s){return this.normalized&&(s=normalize(s,this.array)),this.array[e*this.itemSize+o]=s,this}getX(e){let o=this.array[e*this.itemSize];return this.normalized&&(o=denormalize(o,this.array)),o}setX(e,o){return this.normalized&&(o=normalize(o,this.array)),this.array[e*this.itemSize]=o,this}getY(e){let o=this.array[e*this.itemSize+1];return this.normalized&&(o=denormalize(o,this.array)),o}setY(e,o){return this.normalized&&(o=normalize(o,this.array)),this.array[e*this.itemSize+1]=o,this}getZ(e){let o=this.array[e*this.itemSize+2];return this.normalized&&(o=denormalize(o,this.array)),o}setZ(e,o){return this.normalized&&(o=normalize(o,this.array)),this.array[e*this.itemSize+2]=o,this}getW(e){let o=this.array[e*this.itemSize+3];return this.normalized&&(o=denormalize(o,this.array)),o}setW(e,o){return this.normalized&&(o=normalize(o,this.array)),this.array[e*this.itemSize+3]=o,this}setXY(e,o,s){return e*=this.itemSize,this.normalized&&(o=normalize(o,this.array),s=normalize(s,this.array)),this.array[e+0]=o,this.array[e+1]=s,this}setXYZ(e,o,s,d){return e*=this.itemSize,this.normalized&&(o=normalize(o,this.array),s=normalize(s,this.array),d=normalize(d,this.array)),this.array[e+0]=o,this.array[e+1]=s,this.array[e+2]=d,this}setXYZW(e,o,s,d,c){return e*=this.itemSize,this.normalized&&(o=normalize(o,this.array),s=normalize(s,this.array),d=normalize(d,this.array),c=normalize(c,this.array)),this.array[e+0]=o,this.array[e+1]=s,this.array[e+2]=d,this.array[e+3]=c,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==StaticDrawUsage&&(e.usage=this.usage),e}}class Int8BufferAttribute extends BufferAttribute{constructor(e,o,s){super(new Int8Array(e),o,s)}}class Uint8BufferAttribute extends BufferAttribute{constructor(e,o,s){super(new Uint8Array(e),o,s)}}class Uint8ClampedBufferAttribute extends BufferAttribute{constructor(e,o,s){super(new Uint8ClampedArray(e),o,s)}}class Int16BufferAttribute extends BufferAttribute{constructor(e,o,s){super(new Int16Array(e),o,s)}}class Uint16BufferAttribute extends BufferAttribute{constructor(e,o,s){super(new Uint16Array(e),o,s)}}class Int32BufferAttribute extends BufferAttribute{constructor(e,o,s){super(new Int32Array(e),o,s)}}class Uint32BufferAttribute extends BufferAttribute{constructor(e,o,s){super(new Uint32Array(e),o,s)}}class Float16BufferAttribute extends BufferAttribute{constructor(e,o,s){super(new Uint16Array(e),o,s),this.isFloat16BufferAttribute=!0}getX(e){let o=fromHalfFloat(this.array[e*this.itemSize]);return this.normalized&&(o=denormalize(o,this.array)),o}setX(e,o){return this.normalized&&(o=normalize(o,this.array)),this.array[e*this.itemSize]=toHalfFloat(o),this}getY(e){let o=fromHalfFloat(this.array[e*this.itemSize+1]);return this.normalized&&(o=denormalize(o,this.array)),o}setY(e,o){return this.normalized&&(o=normalize(o,this.array)),this.array[e*this.itemSize+1]=toHalfFloat(o),this}getZ(e){let o=fromHalfFloat(this.array[e*this.itemSize+2]);return this.normalized&&(o=denormalize(o,this.array)),o}setZ(e,o){return this.normalized&&(o=normalize(o,this.array)),this.array[e*this.itemSize+2]=toHalfFloat(o),this}getW(e){let o=fromHalfFloat(this.array[e*this.itemSize+3]);return this.normalized&&(o=denormalize(o,this.array)),o}setW(e,o){return this.normalized&&(o=normalize(o,this.array)),this.array[e*this.itemSize+3]=toHalfFloat(o),this}setXY(e,o,s){return e*=this.itemSize,this.normalized&&(o=normalize(o,this.array),s=normalize(s,this.array)),this.array[e+0]=toHalfFloat(o),this.array[e+1]=toHalfFloat(s),this}setXYZ(e,o,s,d){return e*=this.itemSize,this.normalized&&(o=normalize(o,this.array),s=normalize(s,this.array),d=normalize(d,this.array)),this.array[e+0]=toHalfFloat(o),this.array[e+1]=toHalfFloat(s),this.array[e+2]=toHalfFloat(d),this}setXYZW(e,o,s,d,c){return e*=this.itemSize,this.normalized&&(o=normalize(o,this.array),s=normalize(s,this.array),d=normalize(d,this.array),c=normalize(c,this.array)),this.array[e+0]=toHalfFloat(o),this.array[e+1]=toHalfFloat(s),this.array[e+2]=toHalfFloat(d),this.array[e+3]=toHalfFloat(c),this}}class Float32BufferAttribute extends BufferAttribute{constructor(e,o,s){super(new Float32Array(e),o,s)}}let _id$2=0;const _m1$2=new Matrix4,_obj=new Object3D,_offset=new Vector3,_box$2=new Box3,_boxMorphTargets=new Box3,_vector$8=new Vector3;class BufferGeometry extends EventDispatcher{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:_id$2++}),this.uuid=generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(arrayNeedsUint32(e)?Uint32BufferAttribute:Uint16BufferAttribute)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,o){return this.attributes[e]=o,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,o,s=0){this.groups.push({start:e,count:o,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(e,o){this.drawRange.start=e,this.drawRange.count=o}applyMatrix4(e){const o=this.attributes.position;o!==void 0&&(o.applyMatrix4(e),o.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const c=new Matrix3().getNormalMatrix(e);s.applyNormalMatrix(c),s.needsUpdate=!0}const d=this.attributes.tangent;return d!==void 0&&(d.transformDirection(e),d.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return _m1$2.makeRotationFromQuaternion(e),this.applyMatrix4(_m1$2),this}rotateX(e){return _m1$2.makeRotationX(e),this.applyMatrix4(_m1$2),this}rotateY(e){return _m1$2.makeRotationY(e),this.applyMatrix4(_m1$2),this}rotateZ(e){return _m1$2.makeRotationZ(e),this.applyMatrix4(_m1$2),this}translate(e,o,s){return _m1$2.makeTranslation(e,o,s),this.applyMatrix4(_m1$2),this}scale(e,o,s){return _m1$2.makeScale(e,o,s),this.applyMatrix4(_m1$2),this}lookAt(e){return _obj.lookAt(e),_obj.updateMatrix(),this.applyMatrix4(_obj.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(_offset).negate(),this.translate(_offset.x,_offset.y,_offset.z),this}setFromPoints(e){const o=[];for(let s=0,d=e.length;s<d;s++){const c=e[s];o.push(c.x,c.y,c.z||0)}return this.setAttribute("position",new Float32BufferAttribute(o,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Box3);const e=this.attributes.position,o=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new Vector3(-1/0,-1/0,-1/0),new Vector3(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),o)for(let s=0,d=o.length;s<d;s++){const c=o[s];_box$2.setFromBufferAttribute(c),this.morphTargetsRelative?(_vector$8.addVectors(this.boundingBox.min,_box$2.min),this.boundingBox.expandByPoint(_vector$8),_vector$8.addVectors(this.boundingBox.max,_box$2.max),this.boundingBox.expandByPoint(_vector$8)):(this.boundingBox.expandByPoint(_box$2.min),this.boundingBox.expandByPoint(_box$2.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Sphere);const e=this.attributes.position,o=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new Vector3,1/0);return}if(e){const s=this.boundingSphere.center;if(_box$2.setFromBufferAttribute(e),o)for(let c=0,h=o.length;c<h;c++){const _=o[c];_boxMorphTargets.setFromBufferAttribute(_),this.morphTargetsRelative?(_vector$8.addVectors(_box$2.min,_boxMorphTargets.min),_box$2.expandByPoint(_vector$8),_vector$8.addVectors(_box$2.max,_boxMorphTargets.max),_box$2.expandByPoint(_vector$8)):(_box$2.expandByPoint(_boxMorphTargets.min),_box$2.expandByPoint(_boxMorphTargets.max))}_box$2.getCenter(s);let d=0;for(let c=0,h=e.count;c<h;c++)_vector$8.fromBufferAttribute(e,c),d=Math.max(d,s.distanceToSquared(_vector$8));if(o)for(let c=0,h=o.length;c<h;c++){const _=o[c],bt=this.morphTargetsRelative;for(let g=0,j=_.count;g<j;g++)_vector$8.fromBufferAttribute(_,g),bt&&(_offset.fromBufferAttribute(e,g),_vector$8.add(_offset)),d=Math.max(d,s.distanceToSquared(_vector$8))}this.boundingSphere.radius=Math.sqrt(d),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,o=this.attributes;if(e===null||o.position===void 0||o.normal===void 0||o.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=o.position,d=o.normal,c=o.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new BufferAttribute(new Float32Array(4*s.count),4));const h=this.getAttribute("tangent"),_=[],bt=[];for(let l0=0;l0<s.count;l0++)_[l0]=new Vector3,bt[l0]=new Vector3;const g=new Vector3,j=new Vector3,b=new Vector3,Et=new Vector2,It=new Vector2,zt=new Vector2,er=new Vector3,Hn=new Vector3;function Qt(l0,g0,i0){g.fromBufferAttribute(s,l0),j.fromBufferAttribute(s,g0),b.fromBufferAttribute(s,i0),Et.fromBufferAttribute(c,l0),It.fromBufferAttribute(c,g0),zt.fromBufferAttribute(c,i0),j.sub(g),b.sub(g),It.sub(Et),zt.sub(Et);const f0=1/(It.x*zt.y-zt.x*It.y);isFinite(f0)&&(er.copy(j).multiplyScalar(zt.y).addScaledVector(b,-It.y).multiplyScalar(f0),Hn.copy(b).multiplyScalar(It.x).addScaledVector(j,-zt.x).multiplyScalar(f0),_[l0].add(er),_[g0].add(er),_[i0].add(er),bt[l0].add(Hn),bt[g0].add(Hn),bt[i0].add(Hn))}let cr=this.groups;cr.length===0&&(cr=[{start:0,count:e.count}]);for(let l0=0,g0=cr.length;l0<g0;++l0){const i0=cr[l0],f0=i0.start,C0=i0.count;for(let Z0=f0,R0=f0+C0;Z0<R0;Z0+=3)Qt(e.getX(Z0+0),e.getX(Z0+1),e.getX(Z0+2))}const fr=new Vector3,jr=new Vector3,e0=new Vector3,t0=new Vector3;function o0(l0){e0.fromBufferAttribute(d,l0),t0.copy(e0);const g0=_[l0];fr.copy(g0),fr.sub(e0.multiplyScalar(e0.dot(g0))).normalize(),jr.crossVectors(t0,g0);const f0=jr.dot(bt[l0])<0?-1:1;h.setXYZW(l0,fr.x,fr.y,fr.z,f0)}for(let l0=0,g0=cr.length;l0<g0;++l0){const i0=cr[l0],f0=i0.start,C0=i0.count;for(let Z0=f0,R0=f0+C0;Z0<R0;Z0+=3)o0(e.getX(Z0+0)),o0(e.getX(Z0+1)),o0(e.getX(Z0+2))}}computeVertexNormals(){const e=this.index,o=this.getAttribute("position");if(o!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new BufferAttribute(new Float32Array(o.count*3),3),this.setAttribute("normal",s);else for(let Et=0,It=s.count;Et<It;Et++)s.setXYZ(Et,0,0,0);const d=new Vector3,c=new Vector3,h=new Vector3,_=new Vector3,bt=new Vector3,g=new Vector3,j=new Vector3,b=new Vector3;if(e)for(let Et=0,It=e.count;Et<It;Et+=3){const zt=e.getX(Et+0),er=e.getX(Et+1),Hn=e.getX(Et+2);d.fromBufferAttribute(o,zt),c.fromBufferAttribute(o,er),h.fromBufferAttribute(o,Hn),j.subVectors(h,c),b.subVectors(d,c),j.cross(b),_.fromBufferAttribute(s,zt),bt.fromBufferAttribute(s,er),g.fromBufferAttribute(s,Hn),_.add(j),bt.add(j),g.add(j),s.setXYZ(zt,_.x,_.y,_.z),s.setXYZ(er,bt.x,bt.y,bt.z),s.setXYZ(Hn,g.x,g.y,g.z)}else for(let Et=0,It=o.count;Et<It;Et+=3)d.fromBufferAttribute(o,Et+0),c.fromBufferAttribute(o,Et+1),h.fromBufferAttribute(o,Et+2),j.subVectors(h,c),b.subVectors(d,c),j.cross(b),s.setXYZ(Et+0,j.x,j.y,j.z),s.setXYZ(Et+1,j.x,j.y,j.z),s.setXYZ(Et+2,j.x,j.y,j.z);this.normalizeNormals(),s.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let o=0,s=e.count;o<s;o++)_vector$8.fromBufferAttribute(e,o),_vector$8.normalize(),e.setXYZ(o,_vector$8.x,_vector$8.y,_vector$8.z)}toNonIndexed(){function e(_,bt){const g=_.array,j=_.itemSize,b=_.normalized,Et=new g.constructor(bt.length*j);let It=0,zt=0;for(let er=0,Hn=bt.length;er<Hn;er++){_.isInterleavedBufferAttribute?It=bt[er]*_.data.stride+_.offset:It=bt[er]*j;for(let Qt=0;Qt<j;Qt++)Et[zt++]=g[It++]}return new BufferAttribute(Et,j,b)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const o=new BufferGeometry,s=this.index.array,d=this.attributes;for(const _ in d){const bt=d[_],g=e(bt,s);o.setAttribute(_,g)}const c=this.morphAttributes;for(const _ in c){const bt=[],g=c[_];for(let j=0,b=g.length;j<b;j++){const Et=g[j],It=e(Et,s);bt.push(It)}o.morphAttributes[_]=bt}o.morphTargetsRelative=this.morphTargetsRelative;const h=this.groups;for(let _=0,bt=h.length;_<bt;_++){const g=h[_];o.addGroup(g.start,g.count,g.materialIndex)}return o}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const bt=this.parameters;for(const g in bt)bt[g]!==void 0&&(e[g]=bt[g]);return e}e.data={attributes:{}};const o=this.index;o!==null&&(e.data.index={type:o.array.constructor.name,array:Array.prototype.slice.call(o.array)});const s=this.attributes;for(const bt in s){const g=s[bt];e.data.attributes[bt]=g.toJSON(e.data)}const d={};let c=!1;for(const bt in this.morphAttributes){const g=this.morphAttributes[bt],j=[];for(let b=0,Et=g.length;b<Et;b++){const It=g[b];j.push(It.toJSON(e.data))}j.length>0&&(d[bt]=j,c=!0)}c&&(e.data.morphAttributes=d,e.data.morphTargetsRelative=this.morphTargetsRelative);const h=this.groups;h.length>0&&(e.data.groups=JSON.parse(JSON.stringify(h)));const _=this.boundingSphere;return _!==null&&(e.data.boundingSphere={center:_.center.toArray(),radius:_.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const o={};this.name=e.name;const s=e.index;s!==null&&this.setIndex(s.clone(o));const d=e.attributes;for(const g in d){const j=d[g];this.setAttribute(g,j.clone(o))}const c=e.morphAttributes;for(const g in c){const j=[],b=c[g];for(let Et=0,It=b.length;Et<It;Et++)j.push(b[Et].clone(o));this.morphAttributes[g]=j}this.morphTargetsRelative=e.morphTargetsRelative;const h=e.groups;for(let g=0,j=h.length;g<j;g++){const b=h[g];this.addGroup(b.start,b.count,b.materialIndex)}const _=e.boundingBox;_!==null&&(this.boundingBox=_.clone());const bt=e.boundingSphere;return bt!==null&&(this.boundingSphere=bt.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const _inverseMatrix$3=new Matrix4,_ray$3=new Ray,_sphere$6=new Sphere,_sphereHitAt=new Vector3,_vA$1=new Vector3,_vB$1=new Vector3,_vC$1=new Vector3,_tempA=new Vector3,_morphA=new Vector3,_uvA$1=new Vector2,_uvB$1=new Vector2,_uvC$1=new Vector2,_normalA=new Vector3,_normalB=new Vector3,_normalC=new Vector3,_intersectionPoint=new Vector3,_intersectionPointWorld=new Vector3;class Mesh extends Object3D{constructor(e=new BufferGeometry,o=new MeshBasicMaterial){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=o,this.updateMorphTargets()}copy(e,o){return super.copy(e,o),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const o=this.geometry.morphAttributes,s=Object.keys(o);if(s.length>0){const d=o[s[0]];if(d!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let c=0,h=d.length;c<h;c++){const _=d[c].name||String(c);this.morphTargetInfluences.push(0),this.morphTargetDictionary[_]=c}}}}getVertexPosition(e,o){const s=this.geometry,d=s.attributes.position,c=s.morphAttributes.position,h=s.morphTargetsRelative;o.fromBufferAttribute(d,e);const _=this.morphTargetInfluences;if(c&&_){_morphA.set(0,0,0);for(let bt=0,g=c.length;bt<g;bt++){const j=_[bt],b=c[bt];j!==0&&(_tempA.fromBufferAttribute(b,e),h?_morphA.addScaledVector(_tempA,j):_morphA.addScaledVector(_tempA.sub(o),j))}o.add(_morphA)}return o}raycast(e,o){const s=this.geometry,d=this.material,c=this.matrixWorld;d!==void 0&&(s.boundingSphere===null&&s.computeBoundingSphere(),_sphere$6.copy(s.boundingSphere),_sphere$6.applyMatrix4(c),_ray$3.copy(e.ray).recast(e.near),!(_sphere$6.containsPoint(_ray$3.origin)===!1&&(_ray$3.intersectSphere(_sphere$6,_sphereHitAt)===null||_ray$3.origin.distanceToSquared(_sphereHitAt)>(e.far-e.near)**2))&&(_inverseMatrix$3.copy(c).invert(),_ray$3.copy(e.ray).applyMatrix4(_inverseMatrix$3),!(s.boundingBox!==null&&_ray$3.intersectsBox(s.boundingBox)===!1)&&this._computeIntersections(e,o,_ray$3)))}_computeIntersections(e,o,s){let d;const c=this.geometry,h=this.material,_=c.index,bt=c.attributes.position,g=c.attributes.uv,j=c.attributes.uv1,b=c.attributes.normal,Et=c.groups,It=c.drawRange;if(_!==null)if(Array.isArray(h))for(let zt=0,er=Et.length;zt<er;zt++){const Hn=Et[zt],Qt=h[Hn.materialIndex],cr=Math.max(Hn.start,It.start),fr=Math.min(_.count,Math.min(Hn.start+Hn.count,It.start+It.count));for(let jr=cr,e0=fr;jr<e0;jr+=3){const t0=_.getX(jr),o0=_.getX(jr+1),l0=_.getX(jr+2);d=checkGeometryIntersection(this,Qt,e,s,g,j,b,t0,o0,l0),d&&(d.faceIndex=Math.floor(jr/3),d.face.materialIndex=Hn.materialIndex,o.push(d))}}else{const zt=Math.max(0,It.start),er=Math.min(_.count,It.start+It.count);for(let Hn=zt,Qt=er;Hn<Qt;Hn+=3){const cr=_.getX(Hn),fr=_.getX(Hn+1),jr=_.getX(Hn+2);d=checkGeometryIntersection(this,h,e,s,g,j,b,cr,fr,jr),d&&(d.faceIndex=Math.floor(Hn/3),o.push(d))}}else if(bt!==void 0)if(Array.isArray(h))for(let zt=0,er=Et.length;zt<er;zt++){const Hn=Et[zt],Qt=h[Hn.materialIndex],cr=Math.max(Hn.start,It.start),fr=Math.min(bt.count,Math.min(Hn.start+Hn.count,It.start+It.count));for(let jr=cr,e0=fr;jr<e0;jr+=3){const t0=jr,o0=jr+1,l0=jr+2;d=checkGeometryIntersection(this,Qt,e,s,g,j,b,t0,o0,l0),d&&(d.faceIndex=Math.floor(jr/3),d.face.materialIndex=Hn.materialIndex,o.push(d))}}else{const zt=Math.max(0,It.start),er=Math.min(bt.count,It.start+It.count);for(let Hn=zt,Qt=er;Hn<Qt;Hn+=3){const cr=Hn,fr=Hn+1,jr=Hn+2;d=checkGeometryIntersection(this,h,e,s,g,j,b,cr,fr,jr),d&&(d.faceIndex=Math.floor(Hn/3),o.push(d))}}}}function checkIntersection(a,e,o,s,d,c,h,_){let bt;if(e.side===BackSide?bt=s.intersectTriangle(h,c,d,!0,_):bt=s.intersectTriangle(d,c,h,e.side===FrontSide,_),bt===null)return null;_intersectionPointWorld.copy(_),_intersectionPointWorld.applyMatrix4(a.matrixWorld);const g=o.ray.origin.distanceTo(_intersectionPointWorld);return g<o.near||g>o.far?null:{distance:g,point:_intersectionPointWorld.clone(),object:a}}function checkGeometryIntersection(a,e,o,s,d,c,h,_,bt,g){a.getVertexPosition(_,_vA$1),a.getVertexPosition(bt,_vB$1),a.getVertexPosition(g,_vC$1);const j=checkIntersection(a,e,o,s,_vA$1,_vB$1,_vC$1,_intersectionPoint);if(j){d&&(_uvA$1.fromBufferAttribute(d,_),_uvB$1.fromBufferAttribute(d,bt),_uvC$1.fromBufferAttribute(d,g),j.uv=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2)),c&&(_uvA$1.fromBufferAttribute(c,_),_uvB$1.fromBufferAttribute(c,bt),_uvC$1.fromBufferAttribute(c,g),j.uv1=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2)),h&&(_normalA.fromBufferAttribute(h,_),_normalB.fromBufferAttribute(h,bt),_normalC.fromBufferAttribute(h,g),j.normal=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_normalA,_normalB,_normalC,new Vector3),j.normal.dot(s.direction)>0&&j.normal.multiplyScalar(-1));const b={a:_,b:bt,c:g,normal:new Vector3,materialIndex:0};Triangle.getNormal(_vA$1,_vB$1,_vC$1,b.normal),j.face=b}return j}class BoxGeometry extends BufferGeometry{constructor(e=1,o=1,s=1,d=1,c=1,h=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:o,depth:s,widthSegments:d,heightSegments:c,depthSegments:h};const _=this;d=Math.floor(d),c=Math.floor(c),h=Math.floor(h);const bt=[],g=[],j=[],b=[];let Et=0,It=0;zt("z","y","x",-1,-1,s,o,e,h,c,0),zt("z","y","x",1,-1,s,o,-e,h,c,1),zt("x","z","y",1,1,e,s,o,d,h,2),zt("x","z","y",1,-1,e,s,-o,d,h,3),zt("x","y","z",1,-1,e,o,s,d,c,4),zt("x","y","z",-1,-1,e,o,-s,d,c,5),this.setIndex(bt),this.setAttribute("position",new Float32BufferAttribute(g,3)),this.setAttribute("normal",new Float32BufferAttribute(j,3)),this.setAttribute("uv",new Float32BufferAttribute(b,2));function zt(er,Hn,Qt,cr,fr,jr,e0,t0,o0,l0,g0){const i0=jr/o0,f0=e0/l0,C0=jr/2,Z0=e0/2,R0=t0/2,Y0=o0+1,H0=l0+1;let ty=0,w0=0;const L0=new Vector3;for(let k0=0;k0<H0;k0++){const T0=k0*f0-Z0;for(let q0=0;q0<Y0;q0++){const vy=q0*i0-C0;L0[er]=vy*cr,L0[Hn]=T0*fr,L0[Qt]=R0,g.push(L0.x,L0.y,L0.z),L0[er]=0,L0[Hn]=0,L0[Qt]=t0>0?1:-1,j.push(L0.x,L0.y,L0.z),b.push(q0/o0),b.push(1-k0/l0),ty+=1}}for(let k0=0;k0<l0;k0++)for(let T0=0;T0<o0;T0++){const q0=Et+T0+Y0*k0,vy=Et+T0+Y0*(k0+1),J0=Et+(T0+1)+Y0*(k0+1),cy=Et+(T0+1)+Y0*k0;bt.push(q0,vy,cy),bt.push(vy,J0,cy),w0+=6}_.addGroup(It,w0,g0),It+=w0,Et+=ty}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new BoxGeometry(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function cloneUniforms(a){const e={};for(const o in a){e[o]={};for(const s in a[o]){const d=a[o][s];d&&(d.isColor||d.isMatrix3||d.isMatrix4||d.isVector2||d.isVector3||d.isVector4||d.isTexture||d.isQuaternion)?d.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[o][s]=null):e[o][s]=d.clone():Array.isArray(d)?e[o][s]=d.slice():e[o][s]=d}}return e}function mergeUniforms(a){const e={};for(let o=0;o<a.length;o++){const s=cloneUniforms(a[o]);for(const d in s)e[d]=s[d]}return e}function cloneUniformsGroups(a){const e=[];for(let o=0;o<a.length;o++)e.push(a[o].clone());return e}function getUnlitUniformColorSpace(a){return a.getRenderTarget()===null?a.outputColorSpace:ColorManagement.workingColorSpace}const UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};var default_vertex=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,default_fragment=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ShaderMaterial extends Material{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=default_vertex,this.fragmentShader=default_fragment,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1,clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=cloneUniforms(e.uniforms),this.uniformsGroups=cloneUniformsGroups(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const o=super.toJSON(e);o.glslVersion=this.glslVersion,o.uniforms={};for(const d in this.uniforms){const h=this.uniforms[d].value;h&&h.isTexture?o.uniforms[d]={type:"t",value:h.toJSON(e).uuid}:h&&h.isColor?o.uniforms[d]={type:"c",value:h.getHex()}:h&&h.isVector2?o.uniforms[d]={type:"v2",value:h.toArray()}:h&&h.isVector3?o.uniforms[d]={type:"v3",value:h.toArray()}:h&&h.isVector4?o.uniforms[d]={type:"v4",value:h.toArray()}:h&&h.isMatrix3?o.uniforms[d]={type:"m3",value:h.toArray()}:h&&h.isMatrix4?o.uniforms[d]={type:"m4",value:h.toArray()}:o.uniforms[d]={value:h}}Object.keys(this.defines).length>0&&(o.defines=this.defines),o.vertexShader=this.vertexShader,o.fragmentShader=this.fragmentShader,o.lights=this.lights,o.clipping=this.clipping;const s={};for(const d in this.extensions)this.extensions[d]===!0&&(s[d]=!0);return Object.keys(s).length>0&&(o.extensions=s),o}}class Camera extends Object3D{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Matrix4,this.projectionMatrix=new Matrix4,this.projectionMatrixInverse=new Matrix4,this.coordinateSystem=WebGLCoordinateSystem}copy(e,o){return super.copy(e,o),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,o){super.updateWorldMatrix(e,o),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const _v3$1=new Vector3,_minTarget=new Vector2,_maxTarget=new Vector2;class PerspectiveCamera extends Camera{constructor(e=50,o=1,s=.1,d=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=s,this.far=d,this.focus=10,this.aspect=o,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,o){return super.copy(e,o),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const o=.5*this.getFilmHeight()/e;this.fov=RAD2DEG*2*Math.atan(o),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return RAD2DEG*2*Math.atan(Math.tan(DEG2RAD*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,o,s){_v3$1.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),o.set(_v3$1.x,_v3$1.y).multiplyScalar(-e/_v3$1.z),_v3$1.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),s.set(_v3$1.x,_v3$1.y).multiplyScalar(-e/_v3$1.z)}getViewSize(e,o){return this.getViewBounds(e,_minTarget,_maxTarget),o.subVectors(_maxTarget,_minTarget)}setViewOffset(e,o,s,d,c,h){this.aspect=e/o,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=o,this.view.offsetX=s,this.view.offsetY=d,this.view.width=c,this.view.height=h,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let o=e*Math.tan(DEG2RAD*.5*this.fov)/this.zoom,s=2*o,d=this.aspect*s,c=-.5*d;const h=this.view;if(this.view!==null&&this.view.enabled){const bt=h.fullWidth,g=h.fullHeight;c+=h.offsetX*d/bt,o-=h.offsetY*s/g,d*=h.width/bt,s*=h.height/g}const _=this.filmOffset;_!==0&&(c+=e*_/this.getFilmWidth()),this.projectionMatrix.makePerspective(c,c+d,o,o-s,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const o=super.toJSON(e);return o.object.fov=this.fov,o.object.zoom=this.zoom,o.object.near=this.near,o.object.far=this.far,o.object.focus=this.focus,o.object.aspect=this.aspect,this.view!==null&&(o.object.view=Object.assign({},this.view)),o.object.filmGauge=this.filmGauge,o.object.filmOffset=this.filmOffset,o}}const fov=-90,aspect=1;class CubeCamera extends Object3D{constructor(e,o,s){super(),this.type="CubeCamera",this.renderTarget=s,this.coordinateSystem=null,this.activeMipmapLevel=0;const d=new PerspectiveCamera(fov,aspect,e,o);d.layers=this.layers,this.add(d);const c=new PerspectiveCamera(fov,aspect,e,o);c.layers=this.layers,this.add(c);const h=new PerspectiveCamera(fov,aspect,e,o);h.layers=this.layers,this.add(h);const _=new PerspectiveCamera(fov,aspect,e,o);_.layers=this.layers,this.add(_);const bt=new PerspectiveCamera(fov,aspect,e,o);bt.layers=this.layers,this.add(bt);const g=new PerspectiveCamera(fov,aspect,e,o);g.layers=this.layers,this.add(g)}updateCoordinateSystem(){const e=this.coordinateSystem,o=this.children.concat(),[s,d,c,h,_,bt]=o;for(const g of o)this.remove(g);if(e===WebGLCoordinateSystem)s.up.set(0,1,0),s.lookAt(1,0,0),d.up.set(0,1,0),d.lookAt(-1,0,0),c.up.set(0,0,-1),c.lookAt(0,1,0),h.up.set(0,0,1),h.lookAt(0,-1,0),_.up.set(0,1,0),_.lookAt(0,0,1),bt.up.set(0,1,0),bt.lookAt(0,0,-1);else if(e===WebGPUCoordinateSystem)s.up.set(0,-1,0),s.lookAt(-1,0,0),d.up.set(0,-1,0),d.lookAt(1,0,0),c.up.set(0,0,1),c.lookAt(0,1,0),h.up.set(0,0,-1),h.lookAt(0,-1,0),_.up.set(0,-1,0),_.lookAt(0,0,1),bt.up.set(0,-1,0),bt.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const g of o)this.add(g),g.updateMatrixWorld()}update(e,o){this.parent===null&&this.updateMatrixWorld();const{renderTarget:s,activeMipmapLevel:d}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[c,h,_,bt,g,j]=this.children,b=e.getRenderTarget(),Et=e.getActiveCubeFace(),It=e.getActiveMipmapLevel(),zt=e.xr.enabled;e.xr.enabled=!1;const er=s.texture.generateMipmaps;s.texture.generateMipmaps=!1,e.setRenderTarget(s,0,d),e.render(o,c),e.setRenderTarget(s,1,d),e.render(o,h),e.setRenderTarget(s,2,d),e.render(o,_),e.setRenderTarget(s,3,d),e.render(o,bt),e.setRenderTarget(s,4,d),e.render(o,g),s.texture.generateMipmaps=er,e.setRenderTarget(s,5,d),e.render(o,j),e.setRenderTarget(b,Et,It),e.xr.enabled=zt,s.texture.needsPMREMUpdate=!0}}class CubeTexture extends Texture{constructor(e,o,s,d,c,h,_,bt,g,j){e=e!==void 0?e:[],o=o!==void 0?o:CubeReflectionMapping,super(e,o,s,d,c,h,_,bt,g,j),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class WebGLCubeRenderTarget extends WebGLRenderTarget{constructor(e=1,o={}){super(e,e,o),this.isWebGLCubeRenderTarget=!0;const s={width:e,height:e,depth:1},d=[s,s,s,s,s,s];this.texture=new CubeTexture(d,o.mapping,o.wrapS,o.wrapT,o.magFilter,o.minFilter,o.format,o.type,o.anisotropy,o.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=o.generateMipmaps!==void 0?o.generateMipmaps:!1,this.texture.minFilter=o.minFilter!==void 0?o.minFilter:LinearFilter}fromEquirectangularTexture(e,o){this.texture.type=o.type,this.texture.colorSpace=o.colorSpace,this.texture.generateMipmaps=o.generateMipmaps,this.texture.minFilter=o.minFilter,this.texture.magFilter=o.magFilter;const s={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},d=new BoxGeometry(5,5,5),c=new ShaderMaterial({name:"CubemapFromEquirect",uniforms:cloneUniforms(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,side:BackSide,blending:NoBlending});c.uniforms.tEquirect.value=o;const h=new Mesh(d,c),_=o.minFilter;return o.minFilter===LinearMipmapLinearFilter&&(o.minFilter=LinearFilter),new CubeCamera(1,10,this).update(e,h),o.minFilter=_,h.geometry.dispose(),h.material.dispose(),this}clear(e,o,s,d){const c=e.getRenderTarget();for(let h=0;h<6;h++)e.setRenderTarget(this,h),e.clear(o,s,d);e.setRenderTarget(c)}}const _vector1=new Vector3,_vector2=new Vector3,_normalMatrix=new Matrix3;class Plane{constructor(e=new Vector3(1,0,0),o=0){this.isPlane=!0,this.normal=e,this.constant=o}set(e,o){return this.normal.copy(e),this.constant=o,this}setComponents(e,o,s,d){return this.normal.set(e,o,s),this.constant=d,this}setFromNormalAndCoplanarPoint(e,o){return this.normal.copy(e),this.constant=-o.dot(this.normal),this}setFromCoplanarPoints(e,o,s){const d=_vector1.subVectors(s,o).cross(_vector2.subVectors(e,o)).normalize();return this.setFromNormalAndCoplanarPoint(d,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,o){return o.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,o){const s=e.delta(_vector1),d=this.normal.dot(s);if(d===0)return this.distanceToPoint(e.start)===0?o.copy(e.start):null;const c=-(e.start.dot(this.normal)+this.constant)/d;return c<0||c>1?null:o.copy(e.start).addScaledVector(s,c)}intersectsLine(e){const o=this.distanceToPoint(e.start),s=this.distanceToPoint(e.end);return o<0&&s>0||s<0&&o>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,o){const s=o||_normalMatrix.getNormalMatrix(e),d=this.coplanarPoint(_vector1).applyMatrix4(e),c=this.normal.applyMatrix3(s).normalize();return this.constant=-d.dot(c),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const _sphere$5=new Sphere,_vector$7=new Vector3;class Frustum{constructor(e=new Plane,o=new Plane,s=new Plane,d=new Plane,c=new Plane,h=new Plane){this.planes=[e,o,s,d,c,h]}set(e,o,s,d,c,h){const _=this.planes;return _[0].copy(e),_[1].copy(o),_[2].copy(s),_[3].copy(d),_[4].copy(c),_[5].copy(h),this}copy(e){const o=this.planes;for(let s=0;s<6;s++)o[s].copy(e.planes[s]);return this}setFromProjectionMatrix(e,o=WebGLCoordinateSystem){const s=this.planes,d=e.elements,c=d[0],h=d[1],_=d[2],bt=d[3],g=d[4],j=d[5],b=d[6],Et=d[7],It=d[8],zt=d[9],er=d[10],Hn=d[11],Qt=d[12],cr=d[13],fr=d[14],jr=d[15];if(s[0].setComponents(bt-c,Et-g,Hn-It,jr-Qt).normalize(),s[1].setComponents(bt+c,Et+g,Hn+It,jr+Qt).normalize(),s[2].setComponents(bt+h,Et+j,Hn+zt,jr+cr).normalize(),s[3].setComponents(bt-h,Et-j,Hn-zt,jr-cr).normalize(),s[4].setComponents(bt-_,Et-b,Hn-er,jr-fr).normalize(),o===WebGLCoordinateSystem)s[5].setComponents(bt+_,Et+b,Hn+er,jr+fr).normalize();else if(o===WebGPUCoordinateSystem)s[5].setComponents(_,b,er,fr).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+o);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),_sphere$5.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const o=e.geometry;o.boundingSphere===null&&o.computeBoundingSphere(),_sphere$5.copy(o.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(_sphere$5)}intersectsSprite(e){return _sphere$5.center.set(0,0,0),_sphere$5.radius=.7071067811865476,_sphere$5.applyMatrix4(e.matrixWorld),this.intersectsSphere(_sphere$5)}intersectsSphere(e){const o=this.planes,s=e.center,d=-e.radius;for(let c=0;c<6;c++)if(o[c].distanceToPoint(s)<d)return!1;return!0}intersectsBox(e){const o=this.planes;for(let s=0;s<6;s++){const d=o[s];if(_vector$7.x=d.normal.x>0?e.max.x:e.min.x,_vector$7.y=d.normal.y>0?e.max.y:e.min.y,_vector$7.z=d.normal.z>0?e.max.z:e.min.z,d.distanceToPoint(_vector$7)<0)return!1}return!0}containsPoint(e){const o=this.planes;for(let s=0;s<6;s++)if(o[s].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function WebGLAnimation(){let a=null,e=!1,o=null,s=null;function d(c,h){o(c,h),s=a.requestAnimationFrame(d)}return{start:function(){e!==!0&&o!==null&&(s=a.requestAnimationFrame(d),e=!0)},stop:function(){a.cancelAnimationFrame(s),e=!1},setAnimationLoop:function(c){o=c},setContext:function(c){a=c}}}function WebGLAttributes(a,e){const o=e.isWebGL2,s=new WeakMap;function d(g,j){const b=g.array,Et=g.usage,It=b.byteLength,zt=a.createBuffer();a.bindBuffer(j,zt),a.bufferData(j,b,Et),g.onUploadCallback();let er;if(b instanceof Float32Array)er=a.FLOAT;else if(b instanceof Uint16Array)if(g.isFloat16BufferAttribute)if(o)er=a.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else er=a.UNSIGNED_SHORT;else if(b instanceof Int16Array)er=a.SHORT;else if(b instanceof Uint32Array)er=a.UNSIGNED_INT;else if(b instanceof Int32Array)er=a.INT;else if(b instanceof Int8Array)er=a.BYTE;else if(b instanceof Uint8Array)er=a.UNSIGNED_BYTE;else if(b instanceof Uint8ClampedArray)er=a.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+b);return{buffer:zt,type:er,bytesPerElement:b.BYTES_PER_ELEMENT,version:g.version,size:It}}function c(g,j,b){const Et=j.array,It=j._updateRange,zt=j.updateRanges;if(a.bindBuffer(b,g),It.count===-1&&zt.length===0&&a.bufferSubData(b,0,Et),zt.length!==0){for(let er=0,Hn=zt.length;er<Hn;er++){const Qt=zt[er];o?a.bufferSubData(b,Qt.start*Et.BYTES_PER_ELEMENT,Et,Qt.start,Qt.count):a.bufferSubData(b,Qt.start*Et.BYTES_PER_ELEMENT,Et.subarray(Qt.start,Qt.start+Qt.count))}j.clearUpdateRanges()}It.count!==-1&&(o?a.bufferSubData(b,It.offset*Et.BYTES_PER_ELEMENT,Et,It.offset,It.count):a.bufferSubData(b,It.offset*Et.BYTES_PER_ELEMENT,Et.subarray(It.offset,It.offset+It.count)),It.count=-1),j.onUploadCallback()}function h(g){return g.isInterleavedBufferAttribute&&(g=g.data),s.get(g)}function _(g){g.isInterleavedBufferAttribute&&(g=g.data);const j=s.get(g);j&&(a.deleteBuffer(j.buffer),s.delete(g))}function bt(g,j){if(g.isGLBufferAttribute){const Et=s.get(g);(!Et||Et.version<g.version)&&s.set(g,{buffer:g.buffer,type:g.type,bytesPerElement:g.elementSize,version:g.version});return}g.isInterleavedBufferAttribute&&(g=g.data);const b=s.get(g);if(b===void 0)s.set(g,d(g,j));else if(b.version<g.version){if(b.size!==g.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");c(b.buffer,g,j),b.version=g.version}}return{get:h,remove:_,update:bt}}class PlaneGeometry extends BufferGeometry{constructor(e=1,o=1,s=1,d=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:o,widthSegments:s,heightSegments:d};const c=e/2,h=o/2,_=Math.floor(s),bt=Math.floor(d),g=_+1,j=bt+1,b=e/_,Et=o/bt,It=[],zt=[],er=[],Hn=[];for(let Qt=0;Qt<j;Qt++){const cr=Qt*Et-h;for(let fr=0;fr<g;fr++){const jr=fr*b-c;zt.push(jr,-cr,0),er.push(0,0,1),Hn.push(fr/_),Hn.push(1-Qt/bt)}}for(let Qt=0;Qt<bt;Qt++)for(let cr=0;cr<_;cr++){const fr=cr+g*Qt,jr=cr+g*(Qt+1),e0=cr+1+g*(Qt+1),t0=cr+1+g*Qt;It.push(fr,jr,t0),It.push(jr,e0,t0)}this.setIndex(It),this.setAttribute("position",new Float32BufferAttribute(zt,3)),this.setAttribute("normal",new Float32BufferAttribute(er,3)),this.setAttribute("uv",new Float32BufferAttribute(Hn,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new PlaneGeometry(e.width,e.height,e.widthSegments,e.heightSegments)}}var alphahash_fragment=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,alphahash_pars_fragment=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,alphamap_fragment=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,alphamap_pars_fragment=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,alphatest_fragment=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,alphatest_pars_fragment=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,aomap_fragment=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,aomap_pars_fragment=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,batching_pars_vertex=`#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,batching_vertex=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,begin_vertex=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,beginnormal_vertex=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bsdfs=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,iridescence_fragment=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,bumpmap_pars_fragment=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,clipping_planes_fragment=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,clipping_planes_pars_fragment=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,clipping_planes_pars_vertex=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,clipping_planes_vertex=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,color_fragment=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,color_pars_fragment=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,color_pars_vertex=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,color_vertex=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,common=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,cube_uv_reflection_fragment=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,defaultnormal_vertex=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,displacementmap_pars_vertex=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,displacementmap_vertex=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,emissivemap_fragment=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,emissivemap_pars_fragment=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,colorspace_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,envmap_fragment=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,envmap_common_pars_fragment=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,envmap_pars_fragment=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,envmap_pars_vertex=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,envmap_vertex=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fog_vertex=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,fog_pars_vertex=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,fog_fragment=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fog_pars_fragment=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gradientmap_pars_fragment=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,lightmap_fragment=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,lightmap_pars_fragment=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,lights_lambert_fragment=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,lights_lambert_pars_fragment=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,lights_pars_begin=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,envmap_physical_pars_fragment=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,lights_toon_fragment=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lights_toon_pars_fragment=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,lights_phong_fragment=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lights_phong_pars_fragment=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,lights_physical_fragment=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,lights_physical_pars_fragment=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lights_fragment_begin=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lights_fragment_maps=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,lights_fragment_end=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,logdepthbuf_fragment=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,logdepthbuf_pars_fragment=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_pars_vertex=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,logdepthbuf_vertex=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,map_fragment=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,map_pars_fragment=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,map_particle_fragment=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,map_particle_pars_fragment=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,metalnessmap_fragment=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,metalnessmap_pars_fragment=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,morphinstance_vertex=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,morphcolor_vertex=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,morphnormal_vertex=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,morphtarget_pars_vertex=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,morphtarget_vertex=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,normal_fragment_begin=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,normal_fragment_maps=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,normal_pars_fragment=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_pars_vertex=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_vertex=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,normalmap_pars_fragment=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,clearcoat_normal_fragment_begin=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,clearcoat_normal_fragment_maps=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,clearcoat_pars_fragment=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,iridescence_pars_fragment=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,opaque_fragment=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,packing=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,premultiplied_alpha_fragment=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,project_vertex=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,dithering_fragment=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,dithering_pars_fragment=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,roughnessmap_fragment=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,roughnessmap_pars_fragment=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,shadowmap_pars_fragment=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,shadowmap_pars_vertex=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,shadowmap_vertex=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,shadowmask_pars_fragment=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,skinbase_vertex=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,skinning_pars_vertex=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,skinning_vertex=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,skinnormal_vertex=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,specularmap_fragment=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,specularmap_pars_fragment=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tonemapping_fragment=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tonemapping_pars_fragment=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	float startCompression = 0.8 - 0.04;
	float desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min(color.r, min(color.g, color.b));
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max(color.r, max(color.g, color.b));
	if (peak < startCompression) return color;
	float d = 1. - startCompression;
	float newPeak = 1. - d * d / (peak + d - startCompression);
	color *= newPeak / peak;
	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
	return mix(color, vec3(1, 1, 1), g);
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,transmission_fragment=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,transmission_pars_fragment=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,uv_pars_fragment=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uv_pars_vertex=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uv_vertex=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,worldpos_vertex=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const vertex$h=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,fragment$h=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$g=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fragment$g=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$f=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fragment$f=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$e=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,fragment$e=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,vertex$d=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,fragment$d=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,vertex$c=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,fragment$c=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$b=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fragment$b=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vertex$a=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,fragment$a=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$9=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$9=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$8=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,fragment$8=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$7=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,fragment$7=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,vertex$6=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$6=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$5=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,fragment$5=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$4=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$4=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$3=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,fragment$3=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vertex$2=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$2=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,vertex$1=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fragment$1=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,ShaderChunk={alphahash_fragment,alphahash_pars_fragment,alphamap_fragment,alphamap_pars_fragment,alphatest_fragment,alphatest_pars_fragment,aomap_fragment,aomap_pars_fragment,batching_pars_vertex,batching_vertex,begin_vertex,beginnormal_vertex,bsdfs,iridescence_fragment,bumpmap_pars_fragment,clipping_planes_fragment,clipping_planes_pars_fragment,clipping_planes_pars_vertex,clipping_planes_vertex,color_fragment,color_pars_fragment,color_pars_vertex,color_vertex,common,cube_uv_reflection_fragment,defaultnormal_vertex,displacementmap_pars_vertex,displacementmap_vertex,emissivemap_fragment,emissivemap_pars_fragment,colorspace_fragment,colorspace_pars_fragment,envmap_fragment,envmap_common_pars_fragment,envmap_pars_fragment,envmap_pars_vertex,envmap_physical_pars_fragment,envmap_vertex,fog_vertex,fog_pars_vertex,fog_fragment,fog_pars_fragment,gradientmap_pars_fragment,lightmap_fragment,lightmap_pars_fragment,lights_lambert_fragment,lights_lambert_pars_fragment,lights_pars_begin,lights_toon_fragment,lights_toon_pars_fragment,lights_phong_fragment,lights_phong_pars_fragment,lights_physical_fragment,lights_physical_pars_fragment,lights_fragment_begin,lights_fragment_maps,lights_fragment_end,logdepthbuf_fragment,logdepthbuf_pars_fragment,logdepthbuf_pars_vertex,logdepthbuf_vertex,map_fragment,map_pars_fragment,map_particle_fragment,map_particle_pars_fragment,metalnessmap_fragment,metalnessmap_pars_fragment,morphinstance_vertex,morphcolor_vertex,morphnormal_vertex,morphtarget_pars_vertex,morphtarget_vertex,normal_fragment_begin,normal_fragment_maps,normal_pars_fragment,normal_pars_vertex,normal_vertex,normalmap_pars_fragment,clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps,clearcoat_pars_fragment,iridescence_pars_fragment,opaque_fragment,packing,premultiplied_alpha_fragment,project_vertex,dithering_fragment,dithering_pars_fragment,roughnessmap_fragment,roughnessmap_pars_fragment,shadowmap_pars_fragment,shadowmap_pars_vertex,shadowmap_vertex,shadowmask_pars_fragment,skinbase_vertex,skinning_pars_vertex,skinning_vertex,skinnormal_vertex,specularmap_fragment,specularmap_pars_fragment,tonemapping_fragment,tonemapping_pars_fragment,transmission_fragment,transmission_pars_fragment,uv_pars_fragment,uv_pars_vertex,uv_vertex,worldpos_vertex,background_vert:vertex$h,background_frag:fragment$h,backgroundCube_vert:vertex$g,backgroundCube_frag:fragment$g,cube_vert:vertex$f,cube_frag:fragment$f,depth_vert:vertex$e,depth_frag:fragment$e,distanceRGBA_vert:vertex$d,distanceRGBA_frag:fragment$d,equirect_vert:vertex$c,equirect_frag:fragment$c,linedashed_vert:vertex$b,linedashed_frag:fragment$b,meshbasic_vert:vertex$a,meshbasic_frag:fragment$a,meshlambert_vert:vertex$9,meshlambert_frag:fragment$9,meshmatcap_vert:vertex$8,meshmatcap_frag:fragment$8,meshnormal_vert:vertex$7,meshnormal_frag:fragment$7,meshphong_vert:vertex$6,meshphong_frag:fragment$6,meshphysical_vert:vertex$5,meshphysical_frag:fragment$5,meshtoon_vert:vertex$4,meshtoon_frag:fragment$4,points_vert:vertex$3,points_frag:fragment$3,shadow_vert:vertex$2,shadow_frag:fragment$2,sprite_vert:vertex$1,sprite_frag:fragment$1},UniformsLib={common:{diffuse:{value:new Color(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Matrix3},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Matrix3}},envmap:{envMap:{value:null},envMapRotation:{value:new Matrix3},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Matrix3}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Matrix3}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Matrix3},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Matrix3},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Matrix3},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Matrix3}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Matrix3}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Matrix3}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Color(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Color(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0},uvTransform:{value:new Matrix3}},sprite:{diffuse:{value:new Color(16777215)},opacity:{value:1},center:{value:new Vector2(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Matrix3},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0}}},ShaderLib={basic:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)},specular:{value:new Color(1118481)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:mergeUniforms([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1}}]),vertexShader:ShaderChunk.meshnormal_vert,fragmentShader:ShaderChunk.meshnormal_frag},sprite:{uniforms:mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Matrix3}},vertexShader:ShaderChunk.backgroundCube_vert,fragmentShader:ShaderChunk.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:new Vector3},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:new Color(0)},opacity:{value:1}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Matrix3},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Matrix3},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Matrix3},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Matrix3},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Matrix3},sheen:{value:0},sheenColor:{value:new Color(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Matrix3},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Matrix3},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Matrix3},transmissionSamplerSize:{value:new Vector2},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Matrix3},attenuationDistance:{value:0},attenuationColor:{value:new Color(0)},specularColor:{value:new Color(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Matrix3},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Matrix3},anisotropyVector:{value:new Vector2},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Matrix3}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};const _rgb={r:0,b:0,g:0},_e1$1=new Euler,_m1$1=new Matrix4;function WebGLBackground(a,e,o,s,d,c,h){const _=new Color(0);let bt=c===!0?0:1,g,j,b=null,Et=0,It=null;function zt(Hn,Qt){let cr=!1,fr=Qt.isScene===!0?Qt.background:null;fr&&fr.isTexture&&(fr=(Qt.backgroundBlurriness>0?o:e).get(fr)),fr===null?er(_,bt):fr&&fr.isColor&&(er(fr,1),cr=!0);const jr=a.xr.getEnvironmentBlendMode();jr==="additive"?s.buffers.color.setClear(0,0,0,1,h):jr==="alpha-blend"&&s.buffers.color.setClear(0,0,0,0,h),(a.autoClear||cr)&&a.clear(a.autoClearColor,a.autoClearDepth,a.autoClearStencil),fr&&(fr.isCubeTexture||fr.mapping===CubeUVReflectionMapping)?(j===void 0&&(j=new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({name:"BackgroundCubeMaterial",uniforms:cloneUniforms(ShaderLib.backgroundCube.uniforms),vertexShader:ShaderLib.backgroundCube.vertexShader,fragmentShader:ShaderLib.backgroundCube.fragmentShader,side:BackSide,depthTest:!1,depthWrite:!1,fog:!1})),j.geometry.deleteAttribute("normal"),j.geometry.deleteAttribute("uv"),j.onBeforeRender=function(e0,t0,o0){this.matrixWorld.copyPosition(o0.matrixWorld)},Object.defineProperty(j.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),d.update(j)),_e1$1.copy(Qt.backgroundRotation),_e1$1.x*=-1,_e1$1.y*=-1,_e1$1.z*=-1,fr.isCubeTexture&&fr.isRenderTargetTexture===!1&&(_e1$1.y*=-1,_e1$1.z*=-1),j.material.uniforms.envMap.value=fr,j.material.uniforms.flipEnvMap.value=fr.isCubeTexture&&fr.isRenderTargetTexture===!1?-1:1,j.material.uniforms.backgroundBlurriness.value=Qt.backgroundBlurriness,j.material.uniforms.backgroundIntensity.value=Qt.backgroundIntensity,j.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1)),j.material.toneMapped=ColorManagement.getTransfer(fr.colorSpace)!==SRGBTransfer,(b!==fr||Et!==fr.version||It!==a.toneMapping)&&(j.material.needsUpdate=!0,b=fr,Et=fr.version,It=a.toneMapping),j.layers.enableAll(),Hn.unshift(j,j.geometry,j.material,0,0,null)):fr&&fr.isTexture&&(g===void 0&&(g=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:"BackgroundMaterial",uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:FrontSide,depthTest:!1,depthWrite:!1,fog:!1})),g.geometry.deleteAttribute("normal"),Object.defineProperty(g.material,"map",{get:function(){return this.uniforms.t2D.value}}),d.update(g)),g.material.uniforms.t2D.value=fr,g.material.uniforms.backgroundIntensity.value=Qt.backgroundIntensity,g.material.toneMapped=ColorManagement.getTransfer(fr.colorSpace)!==SRGBTransfer,fr.matrixAutoUpdate===!0&&fr.updateMatrix(),g.material.uniforms.uvTransform.value.copy(fr.matrix),(b!==fr||Et!==fr.version||It!==a.toneMapping)&&(g.material.needsUpdate=!0,b=fr,Et=fr.version,It=a.toneMapping),g.layers.enableAll(),Hn.unshift(g,g.geometry,g.material,0,0,null))}function er(Hn,Qt){Hn.getRGB(_rgb,getUnlitUniformColorSpace(a)),s.buffers.color.setClear(_rgb.r,_rgb.g,_rgb.b,Qt,h)}return{getClearColor:function(){return _},setClearColor:function(Hn,Qt=1){_.set(Hn),bt=Qt,er(_,bt)},getClearAlpha:function(){return bt},setClearAlpha:function(Hn){bt=Hn,er(_,bt)},render:zt}}function WebGLBindingStates(a,e,o,s){const d=a.getParameter(a.MAX_VERTEX_ATTRIBS),c=s.isWebGL2?null:e.get("OES_vertex_array_object"),h=s.isWebGL2||c!==null,_={},bt=Hn(null);let g=bt,j=!1;function b(R0,Y0,H0,ty,w0){let L0=!1;if(h){const k0=er(ty,H0,Y0);g!==k0&&(g=k0,It(g.object)),L0=Qt(R0,ty,H0,w0),L0&&cr(R0,ty,H0,w0)}else{const k0=Y0.wireframe===!0;(g.geometry!==ty.id||g.program!==H0.id||g.wireframe!==k0)&&(g.geometry=ty.id,g.program=H0.id,g.wireframe=k0,L0=!0)}w0!==null&&o.update(w0,a.ELEMENT_ARRAY_BUFFER),(L0||j)&&(j=!1,l0(R0,Y0,H0,ty),w0!==null&&a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,o.get(w0).buffer))}function Et(){return s.isWebGL2?a.createVertexArray():c.createVertexArrayOES()}function It(R0){return s.isWebGL2?a.bindVertexArray(R0):c.bindVertexArrayOES(R0)}function zt(R0){return s.isWebGL2?a.deleteVertexArray(R0):c.deleteVertexArrayOES(R0)}function er(R0,Y0,H0){const ty=H0.wireframe===!0;let w0=_[R0.id];w0===void 0&&(w0={},_[R0.id]=w0);let L0=w0[Y0.id];L0===void 0&&(L0={},w0[Y0.id]=L0);let k0=L0[ty];return k0===void 0&&(k0=Hn(Et()),L0[ty]=k0),k0}function Hn(R0){const Y0=[],H0=[],ty=[];for(let w0=0;w0<d;w0++)Y0[w0]=0,H0[w0]=0,ty[w0]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:Y0,enabledAttributes:H0,attributeDivisors:ty,object:R0,attributes:{},index:null}}function Qt(R0,Y0,H0,ty){const w0=g.attributes,L0=Y0.attributes;let k0=0;const T0=H0.getAttributes();for(const q0 in T0)if(T0[q0].location>=0){const J0=w0[q0];let cy=L0[q0];if(cy===void 0&&(q0==="instanceMatrix"&&R0.instanceMatrix&&(cy=R0.instanceMatrix),q0==="instanceColor"&&R0.instanceColor&&(cy=R0.instanceColor)),J0===void 0||J0.attribute!==cy||cy&&J0.data!==cy.data)return!0;k0++}return g.attributesNum!==k0||g.index!==ty}function cr(R0,Y0,H0,ty){const w0={},L0=Y0.attributes;let k0=0;const T0=H0.getAttributes();for(const q0 in T0)if(T0[q0].location>=0){let J0=L0[q0];J0===void 0&&(q0==="instanceMatrix"&&R0.instanceMatrix&&(J0=R0.instanceMatrix),q0==="instanceColor"&&R0.instanceColor&&(J0=R0.instanceColor));const cy={};cy.attribute=J0,J0&&J0.data&&(cy.data=J0.data),w0[q0]=cy,k0++}g.attributes=w0,g.attributesNum=k0,g.index=ty}function fr(){const R0=g.newAttributes;for(let Y0=0,H0=R0.length;Y0<H0;Y0++)R0[Y0]=0}function jr(R0){e0(R0,0)}function e0(R0,Y0){const H0=g.newAttributes,ty=g.enabledAttributes,w0=g.attributeDivisors;H0[R0]=1,ty[R0]===0&&(a.enableVertexAttribArray(R0),ty[R0]=1),w0[R0]!==Y0&&((s.isWebGL2?a:e.get("ANGLE_instanced_arrays"))[s.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](R0,Y0),w0[R0]=Y0)}function t0(){const R0=g.newAttributes,Y0=g.enabledAttributes;for(let H0=0,ty=Y0.length;H0<ty;H0++)Y0[H0]!==R0[H0]&&(a.disableVertexAttribArray(H0),Y0[H0]=0)}function o0(R0,Y0,H0,ty,w0,L0,k0){k0===!0?a.vertexAttribIPointer(R0,Y0,H0,w0,L0):a.vertexAttribPointer(R0,Y0,H0,ty,w0,L0)}function l0(R0,Y0,H0,ty){if(s.isWebGL2===!1&&(R0.isInstancedMesh||ty.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;fr();const w0=ty.attributes,L0=H0.getAttributes(),k0=Y0.defaultAttributeValues;for(const T0 in L0){const q0=L0[T0];if(q0.location>=0){let vy=w0[T0];if(vy===void 0&&(T0==="instanceMatrix"&&R0.instanceMatrix&&(vy=R0.instanceMatrix),T0==="instanceColor"&&R0.instanceColor&&(vy=R0.instanceColor)),vy!==void 0){const J0=vy.normalized,cy=vy.itemSize,Ty=o.get(vy);if(Ty===void 0)continue;const Uy=Ty.buffer,Qy=Ty.type,Zy=Ty.bytesPerElement,iv=s.isWebGL2===!0&&(Qy===a.INT||Qy===a.UNSIGNED_INT||vy.gpuType===IntType);if(vy.isInterleavedBufferAttribute){const zy=vy.data,B0=zy.stride,Ay=vy.offset;if(zy.isInstancedInterleavedBuffer){for(let hy=0;hy<q0.locationSize;hy++)e0(q0.location+hy,zy.meshPerAttribute);R0.isInstancedMesh!==!0&&ty._maxInstanceCount===void 0&&(ty._maxInstanceCount=zy.meshPerAttribute*zy.count)}else for(let hy=0;hy<q0.locationSize;hy++)jr(q0.location+hy);a.bindBuffer(a.ARRAY_BUFFER,Uy);for(let hy=0;hy<q0.locationSize;hy++)o0(q0.location+hy,cy/q0.locationSize,Qy,J0,B0*Zy,(Ay+cy/q0.locationSize*hy)*Zy,iv)}else{if(vy.isInstancedBufferAttribute){for(let zy=0;zy<q0.locationSize;zy++)e0(q0.location+zy,vy.meshPerAttribute);R0.isInstancedMesh!==!0&&ty._maxInstanceCount===void 0&&(ty._maxInstanceCount=vy.meshPerAttribute*vy.count)}else for(let zy=0;zy<q0.locationSize;zy++)jr(q0.location+zy);a.bindBuffer(a.ARRAY_BUFFER,Uy);for(let zy=0;zy<q0.locationSize;zy++)o0(q0.location+zy,cy/q0.locationSize,Qy,J0,cy*Zy,cy/q0.locationSize*zy*Zy,iv)}}else if(k0!==void 0){const J0=k0[T0];if(J0!==void 0)switch(J0.length){case 2:a.vertexAttrib2fv(q0.location,J0);break;case 3:a.vertexAttrib3fv(q0.location,J0);break;case 4:a.vertexAttrib4fv(q0.location,J0);break;default:a.vertexAttrib1fv(q0.location,J0)}}}}t0()}function g0(){C0();for(const R0 in _){const Y0=_[R0];for(const H0 in Y0){const ty=Y0[H0];for(const w0 in ty)zt(ty[w0].object),delete ty[w0];delete Y0[H0]}delete _[R0]}}function i0(R0){if(_[R0.id]===void 0)return;const Y0=_[R0.id];for(const H0 in Y0){const ty=Y0[H0];for(const w0 in ty)zt(ty[w0].object),delete ty[w0];delete Y0[H0]}delete _[R0.id]}function f0(R0){for(const Y0 in _){const H0=_[Y0];if(H0[R0.id]===void 0)continue;const ty=H0[R0.id];for(const w0 in ty)zt(ty[w0].object),delete ty[w0];delete H0[R0.id]}}function C0(){Z0(),j=!0,g!==bt&&(g=bt,It(g.object))}function Z0(){bt.geometry=null,bt.program=null,bt.wireframe=!1}return{setup:b,reset:C0,resetDefaultState:Z0,dispose:g0,releaseStatesOfGeometry:i0,releaseStatesOfProgram:f0,initAttributes:fr,enableAttribute:jr,disableUnusedAttributes:t0}}function WebGLBufferRenderer(a,e,o,s){const d=s.isWebGL2;let c;function h(j){c=j}function _(j,b){a.drawArrays(c,j,b),o.update(b,c,1)}function bt(j,b,Et){if(Et===0)return;let It,zt;if(d)It=a,zt="drawArraysInstanced";else if(It=e.get("ANGLE_instanced_arrays"),zt="drawArraysInstancedANGLE",It===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}It[zt](c,j,b,Et),o.update(b,c,Et)}function g(j,b,Et){if(Et===0)return;const It=e.get("WEBGL_multi_draw");if(It===null)for(let zt=0;zt<Et;zt++)this.render(j[zt],b[zt]);else{It.multiDrawArraysWEBGL(c,j,0,b,0,Et);let zt=0;for(let er=0;er<Et;er++)zt+=b[er];o.update(zt,c,1)}}this.setMode=h,this.render=_,this.renderInstances=bt,this.renderMultiDraw=g}function WebGLCapabilities(a,e,o){let s;function d(){if(s!==void 0)return s;if(e.has("EXT_texture_filter_anisotropic")===!0){const o0=e.get("EXT_texture_filter_anisotropic");s=a.getParameter(o0.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s}function c(o0){if(o0==="highp"){if(a.getShaderPrecisionFormat(a.VERTEX_SHADER,a.HIGH_FLOAT).precision>0&&a.getShaderPrecisionFormat(a.FRAGMENT_SHADER,a.HIGH_FLOAT).precision>0)return"highp";o0="mediump"}return o0==="mediump"&&a.getShaderPrecisionFormat(a.VERTEX_SHADER,a.MEDIUM_FLOAT).precision>0&&a.getShaderPrecisionFormat(a.FRAGMENT_SHADER,a.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const h=typeof WebGL2RenderingContext<"u"&&a.constructor.name==="WebGL2RenderingContext";let _=o.precision!==void 0?o.precision:"highp";const bt=c(_);bt!==_&&(console.warn("THREE.WebGLRenderer:",_,"not supported, using",bt,"instead."),_=bt);const g=h||e.has("WEBGL_draw_buffers"),j=o.logarithmicDepthBuffer===!0,b=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),Et=a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS),It=a.getParameter(a.MAX_TEXTURE_SIZE),zt=a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE),er=a.getParameter(a.MAX_VERTEX_ATTRIBS),Hn=a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS),Qt=a.getParameter(a.MAX_VARYING_VECTORS),cr=a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS),fr=Et>0,jr=h||e.has("OES_texture_float"),e0=fr&&jr,t0=h?a.getParameter(a.MAX_SAMPLES):0;return{isWebGL2:h,drawBuffers:g,getMaxAnisotropy:d,getMaxPrecision:c,precision:_,logarithmicDepthBuffer:j,maxTextures:b,maxVertexTextures:Et,maxTextureSize:It,maxCubemapSize:zt,maxAttributes:er,maxVertexUniforms:Hn,maxVaryings:Qt,maxFragmentUniforms:cr,vertexTextures:fr,floatFragmentTextures:jr,floatVertexTextures:e0,maxSamples:t0}}function WebGLClipping(a){const e=this;let o=null,s=0,d=!1,c=!1;const h=new Plane,_=new Matrix3,bt={value:null,needsUpdate:!1};this.uniform=bt,this.numPlanes=0,this.numIntersection=0,this.init=function(b,Et){const It=b.length!==0||Et||s!==0||d;return d=Et,s=b.length,It},this.beginShadows=function(){c=!0,j(null)},this.endShadows=function(){c=!1},this.setGlobalState=function(b,Et){o=j(b,Et,0)},this.setState=function(b,Et,It){const zt=b.clippingPlanes,er=b.clipIntersection,Hn=b.clipShadows,Qt=a.get(b);if(!d||zt===null||zt.length===0||c&&!Hn)c?j(null):g();else{const cr=c?0:s,fr=cr*4;let jr=Qt.clippingState||null;bt.value=jr,jr=j(zt,Et,fr,It);for(let e0=0;e0!==fr;++e0)jr[e0]=o[e0];Qt.clippingState=jr,this.numIntersection=er?this.numPlanes:0,this.numPlanes+=cr}};function g(){bt.value!==o&&(bt.value=o,bt.needsUpdate=s>0),e.numPlanes=s,e.numIntersection=0}function j(b,Et,It,zt){const er=b!==null?b.length:0;let Hn=null;if(er!==0){if(Hn=bt.value,zt!==!0||Hn===null){const Qt=It+er*4,cr=Et.matrixWorldInverse;_.getNormalMatrix(cr),(Hn===null||Hn.length<Qt)&&(Hn=new Float32Array(Qt));for(let fr=0,jr=It;fr!==er;++fr,jr+=4)h.copy(b[fr]).applyMatrix4(cr,_),h.normal.toArray(Hn,jr),Hn[jr+3]=h.constant}bt.value=Hn,bt.needsUpdate=!0}return e.numPlanes=er,e.numIntersection=0,Hn}}function WebGLCubeMaps(a){let e=new WeakMap;function o(h,_){return _===EquirectangularReflectionMapping?h.mapping=CubeReflectionMapping:_===EquirectangularRefractionMapping&&(h.mapping=CubeRefractionMapping),h}function s(h){if(h&&h.isTexture){const _=h.mapping;if(_===EquirectangularReflectionMapping||_===EquirectangularRefractionMapping)if(e.has(h)){const bt=e.get(h).texture;return o(bt,h.mapping)}else{const bt=h.image;if(bt&&bt.height>0){const g=new WebGLCubeRenderTarget(bt.height);return g.fromEquirectangularTexture(a,h),e.set(h,g),h.addEventListener("dispose",d),o(g.texture,h.mapping)}else return null}}return h}function d(h){const _=h.target;_.removeEventListener("dispose",d);const bt=e.get(_);bt!==void 0&&(e.delete(_),bt.dispose())}function c(){e=new WeakMap}return{get:s,dispose:c}}class OrthographicCamera extends Camera{constructor(e=-1,o=1,s=1,d=-1,c=.1,h=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=o,this.top=s,this.bottom=d,this.near=c,this.far=h,this.updateProjectionMatrix()}copy(e,o){return super.copy(e,o),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,o,s,d,c,h){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=o,this.view.offsetX=s,this.view.offsetY=d,this.view.width=c,this.view.height=h,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),o=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,d=(this.top+this.bottom)/2;let c=s-e,h=s+e,_=d+o,bt=d-o;if(this.view!==null&&this.view.enabled){const g=(this.right-this.left)/this.view.fullWidth/this.zoom,j=(this.top-this.bottom)/this.view.fullHeight/this.zoom;c+=g*this.view.offsetX,h=c+g*this.view.width,_-=j*this.view.offsetY,bt=_-j*this.view.height}this.projectionMatrix.makeOrthographic(c,h,_,bt,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const o=super.toJSON(e);return o.object.zoom=this.zoom,o.object.left=this.left,o.object.right=this.right,o.object.top=this.top,o.object.bottom=this.bottom,o.object.near=this.near,o.object.far=this.far,this.view!==null&&(o.object.view=Object.assign({},this.view)),o}}const LOD_MIN=4,EXTRA_LOD_SIGMA=[.125,.215,.35,.446,.526,.582],MAX_SAMPLES=20,_flatCamera=new OrthographicCamera,_clearColor=new Color;let _oldTarget=null,_oldActiveCubeFace=0,_oldActiveMipmapLevel=0;const PHI=(1+Math.sqrt(5))/2,INV_PHI=1/PHI,_axisDirections=[new Vector3(1,1,1),new Vector3(-1,1,1),new Vector3(1,1,-1),new Vector3(-1,1,-1),new Vector3(0,PHI,INV_PHI),new Vector3(0,PHI,-INV_PHI),new Vector3(INV_PHI,0,PHI),new Vector3(-INV_PHI,0,PHI),new Vector3(PHI,INV_PHI,0),new Vector3(-PHI,INV_PHI,0)];class PMREMGenerator{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,o=0,s=.1,d=100){_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel(),this._setSize(256);const c=this._allocateTargets();return c.depthBuffer=!0,this._sceneToCubeUV(e,s,d,c),o>0&&this._blur(c,0,0,o),this._applyPMREM(c),this._cleanup(c),c}fromEquirectangular(e,o=null){return this._fromTexture(e,o)}fromCubemap(e,o=null){return this._fromTexture(e,o)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=_getCubemapMaterial(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=_getEquirectMaterial(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(_oldTarget,_oldActiveCubeFace,_oldActiveMipmapLevel),e.scissorTest=!1,_setViewport(e,0,0,e.width,e.height)}_fromTexture(e,o){e.mapping===CubeReflectionMapping||e.mapping===CubeRefractionMapping?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel();const s=o||this._allocateTargets();return this._textureToCubeUV(e,s),this._applyPMREM(s),this._cleanup(s),s}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),o=4*this._cubeSize,s={magFilter:LinearFilter,minFilter:LinearFilter,generateMipmaps:!1,type:HalfFloatType,format:RGBAFormat,colorSpace:LinearSRGBColorSpace,depthBuffer:!1},d=_createRenderTarget(e,o,s);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==o){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=_createRenderTarget(e,o,s);const{_lodMax:c}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=_createPlanes(c)),this._blurMaterial=_getBlurShader(c,e,o)}return d}_compileMaterial(e){const o=new Mesh(this._lodPlanes[0],e);this._renderer.compile(o,_flatCamera)}_sceneToCubeUV(e,o,s,d){const _=new PerspectiveCamera(90,1,o,s),bt=[1,-1,1,1,1,1],g=[1,1,1,-1,-1,-1],j=this._renderer,b=j.autoClear,Et=j.toneMapping;j.getClearColor(_clearColor),j.toneMapping=NoToneMapping,j.autoClear=!1;const It=new MeshBasicMaterial({name:"PMREM.Background",side:BackSide,depthWrite:!1,depthTest:!1}),zt=new Mesh(new BoxGeometry,It);let er=!1;const Hn=e.background;Hn?Hn.isColor&&(It.color.copy(Hn),e.background=null,er=!0):(It.color.copy(_clearColor),er=!0);for(let Qt=0;Qt<6;Qt++){const cr=Qt%3;cr===0?(_.up.set(0,bt[Qt],0),_.lookAt(g[Qt],0,0)):cr===1?(_.up.set(0,0,bt[Qt]),_.lookAt(0,g[Qt],0)):(_.up.set(0,bt[Qt],0),_.lookAt(0,0,g[Qt]));const fr=this._cubeSize;_setViewport(d,cr*fr,Qt>2?fr:0,fr,fr),j.setRenderTarget(d),er&&j.render(zt,_),j.render(e,_)}zt.geometry.dispose(),zt.material.dispose(),j.toneMapping=Et,j.autoClear=b,e.background=Hn}_textureToCubeUV(e,o){const s=this._renderer,d=e.mapping===CubeReflectionMapping||e.mapping===CubeRefractionMapping;d?(this._cubemapMaterial===null&&(this._cubemapMaterial=_getCubemapMaterial()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=_getEquirectMaterial());const c=d?this._cubemapMaterial:this._equirectMaterial,h=new Mesh(this._lodPlanes[0],c),_=c.uniforms;_.envMap.value=e;const bt=this._cubeSize;_setViewport(o,0,0,3*bt,2*bt),s.setRenderTarget(o),s.render(h,_flatCamera)}_applyPMREM(e){const o=this._renderer,s=o.autoClear;o.autoClear=!1;for(let d=1;d<this._lodPlanes.length;d++){const c=Math.sqrt(this._sigmas[d]*this._sigmas[d]-this._sigmas[d-1]*this._sigmas[d-1]),h=_axisDirections[(d-1)%_axisDirections.length];this._blur(e,d-1,d,c,h)}o.autoClear=s}_blur(e,o,s,d,c){const h=this._pingPongRenderTarget;this._halfBlur(e,h,o,s,d,"latitudinal",c),this._halfBlur(h,e,s,s,d,"longitudinal",c)}_halfBlur(e,o,s,d,c,h,_){const bt=this._renderer,g=this._blurMaterial;h!=="latitudinal"&&h!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const j=3,b=new Mesh(this._lodPlanes[d],g),Et=g.uniforms,It=this._sizeLods[s]-1,zt=isFinite(c)?Math.PI/(2*It):2*Math.PI/(2*MAX_SAMPLES-1),er=c/zt,Hn=isFinite(c)?1+Math.floor(j*er):MAX_SAMPLES;Hn>MAX_SAMPLES&&console.warn(`sigmaRadians, ${c}, is too large and will clip, as it requested ${Hn} samples when the maximum is set to ${MAX_SAMPLES}`);const Qt=[];let cr=0;for(let o0=0;o0<MAX_SAMPLES;++o0){const l0=o0/er,g0=Math.exp(-l0*l0/2);Qt.push(g0),o0===0?cr+=g0:o0<Hn&&(cr+=2*g0)}for(let o0=0;o0<Qt.length;o0++)Qt[o0]=Qt[o0]/cr;Et.envMap.value=e.texture,Et.samples.value=Hn,Et.weights.value=Qt,Et.latitudinal.value=h==="latitudinal",_&&(Et.poleAxis.value=_);const{_lodMax:fr}=this;Et.dTheta.value=zt,Et.mipInt.value=fr-s;const jr=this._sizeLods[d],e0=3*jr*(d>fr-LOD_MIN?d-fr+LOD_MIN:0),t0=4*(this._cubeSize-jr);_setViewport(o,e0,t0,3*jr,2*jr),bt.setRenderTarget(o),bt.render(b,_flatCamera)}}function _createPlanes(a){const e=[],o=[],s=[];let d=a;const c=a-LOD_MIN+1+EXTRA_LOD_SIGMA.length;for(let h=0;h<c;h++){const _=Math.pow(2,d);o.push(_);let bt=1/_;h>a-LOD_MIN?bt=EXTRA_LOD_SIGMA[h-a+LOD_MIN-1]:h===0&&(bt=0),s.push(bt);const g=1/(_-2),j=-g,b=1+g,Et=[j,j,b,j,b,b,j,j,b,b,j,b],It=6,zt=6,er=3,Hn=2,Qt=1,cr=new Float32Array(er*zt*It),fr=new Float32Array(Hn*zt*It),jr=new Float32Array(Qt*zt*It);for(let t0=0;t0<It;t0++){const o0=t0%3*2/3-1,l0=t0>2?0:-1,g0=[o0,l0,0,o0+2/3,l0,0,o0+2/3,l0+1,0,o0,l0,0,o0+2/3,l0+1,0,o0,l0+1,0];cr.set(g0,er*zt*t0),fr.set(Et,Hn*zt*t0);const i0=[t0,t0,t0,t0,t0,t0];jr.set(i0,Qt*zt*t0)}const e0=new BufferGeometry;e0.setAttribute("position",new BufferAttribute(cr,er)),e0.setAttribute("uv",new BufferAttribute(fr,Hn)),e0.setAttribute("faceIndex",new BufferAttribute(jr,Qt)),e.push(e0),d>LOD_MIN&&d--}return{lodPlanes:e,sizeLods:o,sigmas:s}}function _createRenderTarget(a,e,o){const s=new WebGLRenderTarget(a,e,o);return s.texture.mapping=CubeUVReflectionMapping,s.texture.name="PMREM.cubeUv",s.scissorTest=!0,s}function _setViewport(a,e,o,s,d){a.viewport.set(e,o,s,d),a.scissor.set(e,o,s,d)}function _getBlurShader(a,e,o){const s=new Float32Array(MAX_SAMPLES),d=new Vector3(0,1,0);return new ShaderMaterial({name:"SphericalGaussianBlur",defines:{n:MAX_SAMPLES,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/o,CUBEUV_MAX_MIP:`${a}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:s},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:d}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getEquirectMaterial(){return new ShaderMaterial({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getCubemapMaterial(){return new ShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getCommonVertexShader(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function WebGLCubeUVMaps(a){let e=new WeakMap,o=null;function s(_){if(_&&_.isTexture){const bt=_.mapping,g=bt===EquirectangularReflectionMapping||bt===EquirectangularRefractionMapping,j=bt===CubeReflectionMapping||bt===CubeRefractionMapping;if(g||j)if(_.isRenderTargetTexture&&_.needsPMREMUpdate===!0){_.needsPMREMUpdate=!1;let b=e.get(_);return o===null&&(o=new PMREMGenerator(a)),b=g?o.fromEquirectangular(_,b):o.fromCubemap(_,b),e.set(_,b),b.texture}else{if(e.has(_))return e.get(_).texture;{const b=_.image;if(g&&b&&b.height>0||j&&b&&d(b)){o===null&&(o=new PMREMGenerator(a));const Et=g?o.fromEquirectangular(_):o.fromCubemap(_);return e.set(_,Et),_.addEventListener("dispose",c),Et.texture}else return null}}}return _}function d(_){let bt=0;const g=6;for(let j=0;j<g;j++)_[j]!==void 0&&bt++;return bt===g}function c(_){const bt=_.target;bt.removeEventListener("dispose",c);const g=e.get(bt);g!==void 0&&(e.delete(bt),g.dispose())}function h(){e=new WeakMap,o!==null&&(o.dispose(),o=null)}return{get:s,dispose:h}}function WebGLExtensions(a){const e={};function o(s){if(e[s]!==void 0)return e[s];let d;switch(s){case"WEBGL_depth_texture":d=a.getExtension("WEBGL_depth_texture")||a.getExtension("MOZ_WEBGL_depth_texture")||a.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":d=a.getExtension("EXT_texture_filter_anisotropic")||a.getExtension("MOZ_EXT_texture_filter_anisotropic")||a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":d=a.getExtension("WEBGL_compressed_texture_s3tc")||a.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":d=a.getExtension("WEBGL_compressed_texture_pvrtc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:d=a.getExtension(s)}return e[s]=d,d}return{has:function(s){return o(s)!==null},init:function(s){s.isWebGL2?(o("EXT_color_buffer_float"),o("WEBGL_clip_cull_distance")):(o("WEBGL_depth_texture"),o("OES_texture_float"),o("OES_texture_half_float"),o("OES_texture_half_float_linear"),o("OES_standard_derivatives"),o("OES_element_index_uint"),o("OES_vertex_array_object"),o("ANGLE_instanced_arrays")),o("OES_texture_float_linear"),o("EXT_color_buffer_half_float"),o("WEBGL_multisampled_render_to_texture")},get:function(s){const d=o(s);return d===null&&console.warn("THREE.WebGLRenderer: "+s+" extension not supported."),d}}}function WebGLGeometries(a,e,o,s){const d={},c=new WeakMap;function h(b){const Et=b.target;Et.index!==null&&e.remove(Et.index);for(const zt in Et.attributes)e.remove(Et.attributes[zt]);for(const zt in Et.morphAttributes){const er=Et.morphAttributes[zt];for(let Hn=0,Qt=er.length;Hn<Qt;Hn++)e.remove(er[Hn])}Et.removeEventListener("dispose",h),delete d[Et.id];const It=c.get(Et);It&&(e.remove(It),c.delete(Et)),s.releaseStatesOfGeometry(Et),Et.isInstancedBufferGeometry===!0&&delete Et._maxInstanceCount,o.memory.geometries--}function _(b,Et){return d[Et.id]===!0||(Et.addEventListener("dispose",h),d[Et.id]=!0,o.memory.geometries++),Et}function bt(b){const Et=b.attributes;for(const zt in Et)e.update(Et[zt],a.ARRAY_BUFFER);const It=b.morphAttributes;for(const zt in It){const er=It[zt];for(let Hn=0,Qt=er.length;Hn<Qt;Hn++)e.update(er[Hn],a.ARRAY_BUFFER)}}function g(b){const Et=[],It=b.index,zt=b.attributes.position;let er=0;if(It!==null){const cr=It.array;er=It.version;for(let fr=0,jr=cr.length;fr<jr;fr+=3){const e0=cr[fr+0],t0=cr[fr+1],o0=cr[fr+2];Et.push(e0,t0,t0,o0,o0,e0)}}else if(zt!==void 0){const cr=zt.array;er=zt.version;for(let fr=0,jr=cr.length/3-1;fr<jr;fr+=3){const e0=fr+0,t0=fr+1,o0=fr+2;Et.push(e0,t0,t0,o0,o0,e0)}}else return;const Hn=new(arrayNeedsUint32(Et)?Uint32BufferAttribute:Uint16BufferAttribute)(Et,1);Hn.version=er;const Qt=c.get(b);Qt&&e.remove(Qt),c.set(b,Hn)}function j(b){const Et=c.get(b);if(Et){const It=b.index;It!==null&&Et.version<It.version&&g(b)}else g(b);return c.get(b)}return{get:_,update:bt,getWireframeAttribute:j}}function WebGLIndexedBufferRenderer(a,e,o,s){const d=s.isWebGL2;let c;function h(It){c=It}let _,bt;function g(It){_=It.type,bt=It.bytesPerElement}function j(It,zt){a.drawElements(c,zt,_,It*bt),o.update(zt,c,1)}function b(It,zt,er){if(er===0)return;let Hn,Qt;if(d)Hn=a,Qt="drawElementsInstanced";else if(Hn=e.get("ANGLE_instanced_arrays"),Qt="drawElementsInstancedANGLE",Hn===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}Hn[Qt](c,zt,_,It*bt,er),o.update(zt,c,er)}function Et(It,zt,er){if(er===0)return;const Hn=e.get("WEBGL_multi_draw");if(Hn===null)for(let Qt=0;Qt<er;Qt++)this.render(It[Qt]/bt,zt[Qt]);else{Hn.multiDrawElementsWEBGL(c,zt,0,_,It,0,er);let Qt=0;for(let cr=0;cr<er;cr++)Qt+=zt[cr];o.update(Qt,c,1)}}this.setMode=h,this.setIndex=g,this.render=j,this.renderInstances=b,this.renderMultiDraw=Et}function WebGLInfo(a){const e={geometries:0,textures:0},o={frame:0,calls:0,triangles:0,points:0,lines:0};function s(c,h,_){switch(o.calls++,h){case a.TRIANGLES:o.triangles+=_*(c/3);break;case a.LINES:o.lines+=_*(c/2);break;case a.LINE_STRIP:o.lines+=_*(c-1);break;case a.LINE_LOOP:o.lines+=_*c;break;case a.POINTS:o.points+=_*c;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",h);break}}function d(){o.calls=0,o.triangles=0,o.points=0,o.lines=0}return{memory:e,render:o,programs:null,autoReset:!0,reset:d,update:s}}function numericalSort(a,e){return a[0]-e[0]}function absNumericalSort(a,e){return Math.abs(e[1])-Math.abs(a[1])}function WebGLMorphtargets(a,e,o){const s={},d=new Float32Array(8),c=new WeakMap,h=new Vector4,_=[];for(let g=0;g<8;g++)_[g]=[g,0];function bt(g,j,b){const Et=g.morphTargetInfluences;if(e.isWebGL2===!0){const zt=j.morphAttributes.position||j.morphAttributes.normal||j.morphAttributes.color,er=zt!==void 0?zt.length:0;let Hn=c.get(j);if(Hn===void 0||Hn.count!==er){let Z0=function(){f0.dispose(),c.delete(j),j.removeEventListener("dispose",Z0)};var It=Z0;Hn!==void 0&&Hn.texture.dispose();const Qt=j.morphAttributes.position!==void 0,cr=j.morphAttributes.normal!==void 0,fr=j.morphAttributes.color!==void 0,jr=j.morphAttributes.position||[],e0=j.morphAttributes.normal||[],t0=j.morphAttributes.color||[];let o0=0;Qt===!0&&(o0=1),cr===!0&&(o0=2),fr===!0&&(o0=3);let l0=j.attributes.position.count*o0,g0=1;l0>e.maxTextureSize&&(g0=Math.ceil(l0/e.maxTextureSize),l0=e.maxTextureSize);const i0=new Float32Array(l0*g0*4*er),f0=new DataArrayTexture(i0,l0,g0,er);f0.type=FloatType,f0.needsUpdate=!0;const C0=o0*4;for(let R0=0;R0<er;R0++){const Y0=jr[R0],H0=e0[R0],ty=t0[R0],w0=l0*g0*4*R0;for(let L0=0;L0<Y0.count;L0++){const k0=L0*C0;Qt===!0&&(h.fromBufferAttribute(Y0,L0),i0[w0+k0+0]=h.x,i0[w0+k0+1]=h.y,i0[w0+k0+2]=h.z,i0[w0+k0+3]=0),cr===!0&&(h.fromBufferAttribute(H0,L0),i0[w0+k0+4]=h.x,i0[w0+k0+5]=h.y,i0[w0+k0+6]=h.z,i0[w0+k0+7]=0),fr===!0&&(h.fromBufferAttribute(ty,L0),i0[w0+k0+8]=h.x,i0[w0+k0+9]=h.y,i0[w0+k0+10]=h.z,i0[w0+k0+11]=ty.itemSize===4?h.w:1)}}Hn={count:er,texture:f0,size:new Vector2(l0,g0)},c.set(j,Hn),j.addEventListener("dispose",Z0)}if(g.isInstancedMesh===!0&&g.morphTexture!==null)b.getUniforms().setValue(a,"morphTexture",g.morphTexture,o);else{let Qt=0;for(let fr=0;fr<Et.length;fr++)Qt+=Et[fr];const cr=j.morphTargetsRelative?1:1-Qt;b.getUniforms().setValue(a,"morphTargetBaseInfluence",cr),b.getUniforms().setValue(a,"morphTargetInfluences",Et)}b.getUniforms().setValue(a,"morphTargetsTexture",Hn.texture,o),b.getUniforms().setValue(a,"morphTargetsTextureSize",Hn.size)}else{const zt=Et===void 0?0:Et.length;let er=s[j.id];if(er===void 0||er.length!==zt){er=[];for(let jr=0;jr<zt;jr++)er[jr]=[jr,0];s[j.id]=er}for(let jr=0;jr<zt;jr++){const e0=er[jr];e0[0]=jr,e0[1]=Et[jr]}er.sort(absNumericalSort);for(let jr=0;jr<8;jr++)jr<zt&&er[jr][1]?(_[jr][0]=er[jr][0],_[jr][1]=er[jr][1]):(_[jr][0]=Number.MAX_SAFE_INTEGER,_[jr][1]=0);_.sort(numericalSort);const Hn=j.morphAttributes.position,Qt=j.morphAttributes.normal;let cr=0;for(let jr=0;jr<8;jr++){const e0=_[jr],t0=e0[0],o0=e0[1];t0!==Number.MAX_SAFE_INTEGER&&o0?(Hn&&j.getAttribute("morphTarget"+jr)!==Hn[t0]&&j.setAttribute("morphTarget"+jr,Hn[t0]),Qt&&j.getAttribute("morphNormal"+jr)!==Qt[t0]&&j.setAttribute("morphNormal"+jr,Qt[t0]),d[jr]=o0,cr+=o0):(Hn&&j.hasAttribute("morphTarget"+jr)===!0&&j.deleteAttribute("morphTarget"+jr),Qt&&j.hasAttribute("morphNormal"+jr)===!0&&j.deleteAttribute("morphNormal"+jr),d[jr]=0)}const fr=j.morphTargetsRelative?1:1-cr;b.getUniforms().setValue(a,"morphTargetBaseInfluence",fr),b.getUniforms().setValue(a,"morphTargetInfluences",d)}}return{update:bt}}function WebGLObjects(a,e,o,s){let d=new WeakMap;function c(bt){const g=s.render.frame,j=bt.geometry,b=e.get(bt,j);if(d.get(b)!==g&&(e.update(b),d.set(b,g)),bt.isInstancedMesh&&(bt.hasEventListener("dispose",_)===!1&&bt.addEventListener("dispose",_),d.get(bt)!==g&&(o.update(bt.instanceMatrix,a.ARRAY_BUFFER),bt.instanceColor!==null&&o.update(bt.instanceColor,a.ARRAY_BUFFER),d.set(bt,g))),bt.isSkinnedMesh){const Et=bt.skeleton;d.get(Et)!==g&&(Et.update(),d.set(Et,g))}return b}function h(){d=new WeakMap}function _(bt){const g=bt.target;g.removeEventListener("dispose",_),o.remove(g.instanceMatrix),g.instanceColor!==null&&o.remove(g.instanceColor)}return{update:c,dispose:h}}class DepthTexture extends Texture{constructor(e,o,s,d,c,h,_,bt,g,j){if(j=j!==void 0?j:DepthFormat,j!==DepthFormat&&j!==DepthStencilFormat)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");s===void 0&&j===DepthFormat&&(s=UnsignedIntType),s===void 0&&j===DepthStencilFormat&&(s=UnsignedInt248Type),super(null,d,c,h,_,bt,j,s,g),this.isDepthTexture=!0,this.image={width:e,height:o},this.magFilter=_!==void 0?_:NearestFilter,this.minFilter=bt!==void 0?bt:NearestFilter,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const o=super.toJSON(e);return this.compareFunction!==null&&(o.compareFunction=this.compareFunction),o}}const emptyTexture=new Texture,emptyShadowTexture=new DepthTexture(1,1);emptyShadowTexture.compareFunction=LessEqualCompare;const emptyArrayTexture=new DataArrayTexture,empty3dTexture=new Data3DTexture,emptyCubeTexture=new CubeTexture,arrayCacheF32=[],arrayCacheI32=[],mat4array=new Float32Array(16),mat3array=new Float32Array(9),mat2array=new Float32Array(4);function flatten(a,e,o){const s=a[0];if(s<=0||s>0)return a;const d=e*o;let c=arrayCacheF32[d];if(c===void 0&&(c=new Float32Array(d),arrayCacheF32[d]=c),e!==0){s.toArray(c,0);for(let h=1,_=0;h!==e;++h)_+=o,a[h].toArray(c,_)}return c}function arraysEqual(a,e){if(a.length!==e.length)return!1;for(let o=0,s=a.length;o<s;o++)if(a[o]!==e[o])return!1;return!0}function copyArray(a,e){for(let o=0,s=e.length;o<s;o++)a[o]=e[o]}function allocTexUnits(a,e){let o=arrayCacheI32[e];o===void 0&&(o=new Int32Array(e),arrayCacheI32[e]=o);for(let s=0;s!==e;++s)o[s]=a.allocateTextureUnit();return o}function setValueV1f(a,e){const o=this.cache;o[0]!==e&&(a.uniform1f(this.addr,e),o[0]=e)}function setValueV2f(a,e){const o=this.cache;if(e.x!==void 0)(o[0]!==e.x||o[1]!==e.y)&&(a.uniform2f(this.addr,e.x,e.y),o[0]=e.x,o[1]=e.y);else{if(arraysEqual(o,e))return;a.uniform2fv(this.addr,e),copyArray(o,e)}}function setValueV3f(a,e){const o=this.cache;if(e.x!==void 0)(o[0]!==e.x||o[1]!==e.y||o[2]!==e.z)&&(a.uniform3f(this.addr,e.x,e.y,e.z),o[0]=e.x,o[1]=e.y,o[2]=e.z);else if(e.r!==void 0)(o[0]!==e.r||o[1]!==e.g||o[2]!==e.b)&&(a.uniform3f(this.addr,e.r,e.g,e.b),o[0]=e.r,o[1]=e.g,o[2]=e.b);else{if(arraysEqual(o,e))return;a.uniform3fv(this.addr,e),copyArray(o,e)}}function setValueV4f(a,e){const o=this.cache;if(e.x!==void 0)(o[0]!==e.x||o[1]!==e.y||o[2]!==e.z||o[3]!==e.w)&&(a.uniform4f(this.addr,e.x,e.y,e.z,e.w),o[0]=e.x,o[1]=e.y,o[2]=e.z,o[3]=e.w);else{if(arraysEqual(o,e))return;a.uniform4fv(this.addr,e),copyArray(o,e)}}function setValueM2(a,e){const o=this.cache,s=e.elements;if(s===void 0){if(arraysEqual(o,e))return;a.uniformMatrix2fv(this.addr,!1,e),copyArray(o,e)}else{if(arraysEqual(o,s))return;mat2array.set(s),a.uniformMatrix2fv(this.addr,!1,mat2array),copyArray(o,s)}}function setValueM3(a,e){const o=this.cache,s=e.elements;if(s===void 0){if(arraysEqual(o,e))return;a.uniformMatrix3fv(this.addr,!1,e),copyArray(o,e)}else{if(arraysEqual(o,s))return;mat3array.set(s),a.uniformMatrix3fv(this.addr,!1,mat3array),copyArray(o,s)}}function setValueM4(a,e){const o=this.cache,s=e.elements;if(s===void 0){if(arraysEqual(o,e))return;a.uniformMatrix4fv(this.addr,!1,e),copyArray(o,e)}else{if(arraysEqual(o,s))return;mat4array.set(s),a.uniformMatrix4fv(this.addr,!1,mat4array),copyArray(o,s)}}function setValueV1i(a,e){const o=this.cache;o[0]!==e&&(a.uniform1i(this.addr,e),o[0]=e)}function setValueV2i(a,e){const o=this.cache;if(e.x!==void 0)(o[0]!==e.x||o[1]!==e.y)&&(a.uniform2i(this.addr,e.x,e.y),o[0]=e.x,o[1]=e.y);else{if(arraysEqual(o,e))return;a.uniform2iv(this.addr,e),copyArray(o,e)}}function setValueV3i(a,e){const o=this.cache;if(e.x!==void 0)(o[0]!==e.x||o[1]!==e.y||o[2]!==e.z)&&(a.uniform3i(this.addr,e.x,e.y,e.z),o[0]=e.x,o[1]=e.y,o[2]=e.z);else{if(arraysEqual(o,e))return;a.uniform3iv(this.addr,e),copyArray(o,e)}}function setValueV4i(a,e){const o=this.cache;if(e.x!==void 0)(o[0]!==e.x||o[1]!==e.y||o[2]!==e.z||o[3]!==e.w)&&(a.uniform4i(this.addr,e.x,e.y,e.z,e.w),o[0]=e.x,o[1]=e.y,o[2]=e.z,o[3]=e.w);else{if(arraysEqual(o,e))return;a.uniform4iv(this.addr,e),copyArray(o,e)}}function setValueV1ui(a,e){const o=this.cache;o[0]!==e&&(a.uniform1ui(this.addr,e),o[0]=e)}function setValueV2ui(a,e){const o=this.cache;if(e.x!==void 0)(o[0]!==e.x||o[1]!==e.y)&&(a.uniform2ui(this.addr,e.x,e.y),o[0]=e.x,o[1]=e.y);else{if(arraysEqual(o,e))return;a.uniform2uiv(this.addr,e),copyArray(o,e)}}function setValueV3ui(a,e){const o=this.cache;if(e.x!==void 0)(o[0]!==e.x||o[1]!==e.y||o[2]!==e.z)&&(a.uniform3ui(this.addr,e.x,e.y,e.z),o[0]=e.x,o[1]=e.y,o[2]=e.z);else{if(arraysEqual(o,e))return;a.uniform3uiv(this.addr,e),copyArray(o,e)}}function setValueV4ui(a,e){const o=this.cache;if(e.x!==void 0)(o[0]!==e.x||o[1]!==e.y||o[2]!==e.z||o[3]!==e.w)&&(a.uniform4ui(this.addr,e.x,e.y,e.z,e.w),o[0]=e.x,o[1]=e.y,o[2]=e.z,o[3]=e.w);else{if(arraysEqual(o,e))return;a.uniform4uiv(this.addr,e),copyArray(o,e)}}function setValueT1(a,e,o){const s=this.cache,d=o.allocateTextureUnit();s[0]!==d&&(a.uniform1i(this.addr,d),s[0]=d);const c=this.type===a.SAMPLER_2D_SHADOW?emptyShadowTexture:emptyTexture;o.setTexture2D(e||c,d)}function setValueT3D1(a,e,o){const s=this.cache,d=o.allocateTextureUnit();s[0]!==d&&(a.uniform1i(this.addr,d),s[0]=d),o.setTexture3D(e||empty3dTexture,d)}function setValueT6(a,e,o){const s=this.cache,d=o.allocateTextureUnit();s[0]!==d&&(a.uniform1i(this.addr,d),s[0]=d),o.setTextureCube(e||emptyCubeTexture,d)}function setValueT2DArray1(a,e,o){const s=this.cache,d=o.allocateTextureUnit();s[0]!==d&&(a.uniform1i(this.addr,d),s[0]=d),o.setTexture2DArray(e||emptyArrayTexture,d)}function getSingularSetter(a){switch(a){case 5126:return setValueV1f;case 35664:return setValueV2f;case 35665:return setValueV3f;case 35666:return setValueV4f;case 35674:return setValueM2;case 35675:return setValueM3;case 35676:return setValueM4;case 5124:case 35670:return setValueV1i;case 35667:case 35671:return setValueV2i;case 35668:case 35672:return setValueV3i;case 35669:case 35673:return setValueV4i;case 5125:return setValueV1ui;case 36294:return setValueV2ui;case 36295:return setValueV3ui;case 36296:return setValueV4ui;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1;case 35679:case 36299:case 36307:return setValueT3D1;case 35680:case 36300:case 36308:case 36293:return setValueT6;case 36289:case 36303:case 36311:case 36292:return setValueT2DArray1}}function setValueV1fArray(a,e){a.uniform1fv(this.addr,e)}function setValueV2fArray(a,e){const o=flatten(e,this.size,2);a.uniform2fv(this.addr,o)}function setValueV3fArray(a,e){const o=flatten(e,this.size,3);a.uniform3fv(this.addr,o)}function setValueV4fArray(a,e){const o=flatten(e,this.size,4);a.uniform4fv(this.addr,o)}function setValueM2Array(a,e){const o=flatten(e,this.size,4);a.uniformMatrix2fv(this.addr,!1,o)}function setValueM3Array(a,e){const o=flatten(e,this.size,9);a.uniformMatrix3fv(this.addr,!1,o)}function setValueM4Array(a,e){const o=flatten(e,this.size,16);a.uniformMatrix4fv(this.addr,!1,o)}function setValueV1iArray(a,e){a.uniform1iv(this.addr,e)}function setValueV2iArray(a,e){a.uniform2iv(this.addr,e)}function setValueV3iArray(a,e){a.uniform3iv(this.addr,e)}function setValueV4iArray(a,e){a.uniform4iv(this.addr,e)}function setValueV1uiArray(a,e){a.uniform1uiv(this.addr,e)}function setValueV2uiArray(a,e){a.uniform2uiv(this.addr,e)}function setValueV3uiArray(a,e){a.uniform3uiv(this.addr,e)}function setValueV4uiArray(a,e){a.uniform4uiv(this.addr,e)}function setValueT1Array(a,e,o){const s=this.cache,d=e.length,c=allocTexUnits(o,d);arraysEqual(s,c)||(a.uniform1iv(this.addr,c),copyArray(s,c));for(let h=0;h!==d;++h)o.setTexture2D(e[h]||emptyTexture,c[h])}function setValueT3DArray(a,e,o){const s=this.cache,d=e.length,c=allocTexUnits(o,d);arraysEqual(s,c)||(a.uniform1iv(this.addr,c),copyArray(s,c));for(let h=0;h!==d;++h)o.setTexture3D(e[h]||empty3dTexture,c[h])}function setValueT6Array(a,e,o){const s=this.cache,d=e.length,c=allocTexUnits(o,d);arraysEqual(s,c)||(a.uniform1iv(this.addr,c),copyArray(s,c));for(let h=0;h!==d;++h)o.setTextureCube(e[h]||emptyCubeTexture,c[h])}function setValueT2DArrayArray(a,e,o){const s=this.cache,d=e.length,c=allocTexUnits(o,d);arraysEqual(s,c)||(a.uniform1iv(this.addr,c),copyArray(s,c));for(let h=0;h!==d;++h)o.setTexture2DArray(e[h]||emptyArrayTexture,c[h])}function getPureArraySetter(a){switch(a){case 5126:return setValueV1fArray;case 35664:return setValueV2fArray;case 35665:return setValueV3fArray;case 35666:return setValueV4fArray;case 35674:return setValueM2Array;case 35675:return setValueM3Array;case 35676:return setValueM4Array;case 5124:case 35670:return setValueV1iArray;case 35667:case 35671:return setValueV2iArray;case 35668:case 35672:return setValueV3iArray;case 35669:case 35673:return setValueV4iArray;case 5125:return setValueV1uiArray;case 36294:return setValueV2uiArray;case 36295:return setValueV3uiArray;case 36296:return setValueV4uiArray;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1Array;case 35679:case 36299:case 36307:return setValueT3DArray;case 35680:case 36300:case 36308:case 36293:return setValueT6Array;case 36289:case 36303:case 36311:case 36292:return setValueT2DArrayArray}}class SingleUniform{constructor(e,o,s){this.id=e,this.addr=s,this.cache=[],this.type=o.type,this.setValue=getSingularSetter(o.type)}}class PureArrayUniform{constructor(e,o,s){this.id=e,this.addr=s,this.cache=[],this.type=o.type,this.size=o.size,this.setValue=getPureArraySetter(o.type)}}class StructuredUniform{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,o,s){const d=this.seq;for(let c=0,h=d.length;c!==h;++c){const _=d[c];_.setValue(e,o[_.id],s)}}}const RePathPart=/(\w+)(\])?(\[|\.)?/g;function addUniform(a,e){a.seq.push(e),a.map[e.id]=e}function parseUniform(a,e,o){const s=a.name,d=s.length;for(RePathPart.lastIndex=0;;){const c=RePathPart.exec(s),h=RePathPart.lastIndex;let _=c[1];const bt=c[2]==="]",g=c[3];if(bt&&(_=_|0),g===void 0||g==="["&&h+2===d){addUniform(o,g===void 0?new SingleUniform(_,a,e):new PureArrayUniform(_,a,e));break}else{let b=o.map[_];b===void 0&&(b=new StructuredUniform(_),addUniform(o,b)),o=b}}}class WebGLUniforms{constructor(e,o){this.seq=[],this.map={};const s=e.getProgramParameter(o,e.ACTIVE_UNIFORMS);for(let d=0;d<s;++d){const c=e.getActiveUniform(o,d),h=e.getUniformLocation(o,c.name);parseUniform(c,h,this)}}setValue(e,o,s,d){const c=this.map[o];c!==void 0&&c.setValue(e,s,d)}setOptional(e,o,s){const d=o[s];d!==void 0&&this.setValue(e,s,d)}static upload(e,o,s,d){for(let c=0,h=o.length;c!==h;++c){const _=o[c],bt=s[_.id];bt.needsUpdate!==!1&&_.setValue(e,bt.value,d)}}static seqWithValue(e,o){const s=[];for(let d=0,c=e.length;d!==c;++d){const h=e[d];h.id in o&&s.push(h)}return s}}function WebGLShader(a,e,o){const s=a.createShader(e);return a.shaderSource(s,o),a.compileShader(s),s}const COMPLETION_STATUS_KHR=37297;let programIdCount=0;function handleSource(a,e){const o=a.split(`
`),s=[],d=Math.max(e-6,0),c=Math.min(e+6,o.length);for(let h=d;h<c;h++){const _=h+1;s.push(`${_===e?">":" "} ${_}: ${o[h]}`)}return s.join(`
`)}function getEncodingComponents(a){const e=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),o=ColorManagement.getPrimaries(a);let s;switch(e===o?s="":e===P3Primaries&&o===Rec709Primaries?s="LinearDisplayP3ToLinearSRGB":e===Rec709Primaries&&o===P3Primaries&&(s="LinearSRGBToLinearDisplayP3"),a){case LinearSRGBColorSpace:case LinearDisplayP3ColorSpace:return[s,"LinearTransferOETF"];case SRGBColorSpace:case DisplayP3ColorSpace:return[s,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",a),[s,"LinearTransferOETF"]}}function getShaderErrors(a,e,o){const s=a.getShaderParameter(e,a.COMPILE_STATUS),d=a.getShaderInfoLog(e).trim();if(s&&d==="")return"";const c=/ERROR: 0:(\d+)/.exec(d);if(c){const h=parseInt(c[1]);return o.toUpperCase()+`

`+d+`

`+handleSource(a.getShaderSource(e),h)}else return d}function getTexelEncodingFunction(a,e){const o=getEncodingComponents(e);return`vec4 ${a}( vec4 value ) { return ${o[0]}( ${o[1]}( value ) ); }`}function getToneMappingFunction(a,e){let o;switch(e){case LinearToneMapping:o="Linear";break;case ReinhardToneMapping:o="Reinhard";break;case CineonToneMapping:o="OptimizedCineon";break;case ACESFilmicToneMapping:o="ACESFilmic";break;case AgXToneMapping:o="AgX";break;case NeutralToneMapping:o="Neutral";break;case CustomToneMapping:o="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),o="Linear"}return"vec3 "+a+"( vec3 color ) { return "+o+"ToneMapping( color ); }"}function generateExtensions(a){return[a.extensionDerivatives||a.envMapCubeUVHeight||a.bumpMap||a.normalMapTangentSpace||a.clearcoatNormalMap||a.flatShading||a.alphaToCoverage||a.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(a.extensionFragDepth||a.logarithmicDepthBuffer)&&a.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",a.extensionDrawBuffers&&a.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(a.extensionShaderTextureLOD||a.envMap||a.transmission)&&a.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(filterEmptyLine).join(`
`)}function generateVertexExtensions(a){return[a.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",a.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(filterEmptyLine).join(`
`)}function generateDefines(a){const e=[];for(const o in a){const s=a[o];s!==!1&&e.push("#define "+o+" "+s)}return e.join(`
`)}function fetchAttributeLocations(a,e){const o={},s=a.getProgramParameter(e,a.ACTIVE_ATTRIBUTES);for(let d=0;d<s;d++){const c=a.getActiveAttrib(e,d),h=c.name;let _=1;c.type===a.FLOAT_MAT2&&(_=2),c.type===a.FLOAT_MAT3&&(_=3),c.type===a.FLOAT_MAT4&&(_=4),o[h]={type:c.type,location:a.getAttribLocation(e,h),locationSize:_}}return o}function filterEmptyLine(a){return a!==""}function replaceLightNums(a,e){const o=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return a.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,o).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function replaceClippingPlaneNums(a,e){return a.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(a){return a.replace(includePattern,includeReplacer)}const shaderChunkMap=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function includeReplacer(a,e){let o=ShaderChunk[e];if(o===void 0){const s=shaderChunkMap.get(e);if(s!==void 0)o=ShaderChunk[s],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,s);else throw new Error("Can not resolve #include <"+e+">")}return resolveIncludes(o)}const unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(a){return a.replace(unrollLoopPattern,loopReplacer)}function loopReplacer(a,e,o,s){let d="";for(let c=parseInt(e);c<parseInt(o);c++)d+=s.replace(/\[\s*i\s*\]/g,"[ "+c+" ]").replace(/UNROLLED_LOOP_INDEX/g,c);return d}function generatePrecision(a){let e=`precision ${a.precision} float;
	precision ${a.precision} int;
	precision ${a.precision} sampler2D;
	precision ${a.precision} samplerCube;
	`;return a.isWebGL2&&(e+=`precision ${a.precision} sampler3D;
		precision ${a.precision} sampler2DArray;
		precision ${a.precision} sampler2DShadow;
		precision ${a.precision} samplerCubeShadow;
		precision ${a.precision} sampler2DArrayShadow;
		precision ${a.precision} isampler2D;
		precision ${a.precision} isampler3D;
		precision ${a.precision} isamplerCube;
		precision ${a.precision} isampler2DArray;
		precision ${a.precision} usampler2D;
		precision ${a.precision} usampler3D;
		precision ${a.precision} usamplerCube;
		precision ${a.precision} usampler2DArray;
		`),a.precision==="highp"?e+=`
#define HIGH_PRECISION`:a.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:a.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function generateShadowMapTypeDefine(a){let e="SHADOWMAP_TYPE_BASIC";return a.shadowMapType===PCFShadowMap?e="SHADOWMAP_TYPE_PCF":a.shadowMapType===PCFSoftShadowMap?e="SHADOWMAP_TYPE_PCF_SOFT":a.shadowMapType===VSMShadowMap&&(e="SHADOWMAP_TYPE_VSM"),e}function generateEnvMapTypeDefine(a){let e="ENVMAP_TYPE_CUBE";if(a.envMap)switch(a.envMapMode){case CubeReflectionMapping:case CubeRefractionMapping:e="ENVMAP_TYPE_CUBE";break;case CubeUVReflectionMapping:e="ENVMAP_TYPE_CUBE_UV";break}return e}function generateEnvMapModeDefine(a){let e="ENVMAP_MODE_REFLECTION";if(a.envMap)switch(a.envMapMode){case CubeRefractionMapping:e="ENVMAP_MODE_REFRACTION";break}return e}function generateEnvMapBlendingDefine(a){let e="ENVMAP_BLENDING_NONE";if(a.envMap)switch(a.combine){case MultiplyOperation:e="ENVMAP_BLENDING_MULTIPLY";break;case MixOperation:e="ENVMAP_BLENDING_MIX";break;case AddOperation:e="ENVMAP_BLENDING_ADD";break}return e}function generateCubeUVSize(a){const e=a.envMapCubeUVHeight;if(e===null)return null;const o=Math.log2(e)-2,s=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,o),7*16)),texelHeight:s,maxMip:o}}function WebGLProgram(a,e,o,s){const d=a.getContext(),c=o.defines;let h=o.vertexShader,_=o.fragmentShader;const bt=generateShadowMapTypeDefine(o),g=generateEnvMapTypeDefine(o),j=generateEnvMapModeDefine(o),b=generateEnvMapBlendingDefine(o),Et=generateCubeUVSize(o),It=o.isWebGL2?"":generateExtensions(o),zt=generateVertexExtensions(o),er=generateDefines(c),Hn=d.createProgram();let Qt,cr,fr=o.glslVersion?"#version "+o.glslVersion+`
`:"";o.isRawShaderMaterial?(Qt=["#define SHADER_TYPE "+o.shaderType,"#define SHADER_NAME "+o.shaderName,er].filter(filterEmptyLine).join(`
`),Qt.length>0&&(Qt+=`
`),cr=[It,"#define SHADER_TYPE "+o.shaderType,"#define SHADER_NAME "+o.shaderName,er].filter(filterEmptyLine).join(`
`),cr.length>0&&(cr+=`
`)):(Qt=[generatePrecision(o),"#define SHADER_TYPE "+o.shaderType,"#define SHADER_NAME "+o.shaderName,er,o.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",o.batching?"#define USE_BATCHING":"",o.instancing?"#define USE_INSTANCING":"",o.instancingColor?"#define USE_INSTANCING_COLOR":"",o.instancingMorph?"#define USE_INSTANCING_MORPH":"",o.useFog&&o.fog?"#define USE_FOG":"",o.useFog&&o.fogExp2?"#define FOG_EXP2":"",o.map?"#define USE_MAP":"",o.envMap?"#define USE_ENVMAP":"",o.envMap?"#define "+j:"",o.lightMap?"#define USE_LIGHTMAP":"",o.aoMap?"#define USE_AOMAP":"",o.bumpMap?"#define USE_BUMPMAP":"",o.normalMap?"#define USE_NORMALMAP":"",o.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",o.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",o.displacementMap?"#define USE_DISPLACEMENTMAP":"",o.emissiveMap?"#define USE_EMISSIVEMAP":"",o.anisotropy?"#define USE_ANISOTROPY":"",o.anisotropyMap?"#define USE_ANISOTROPYMAP":"",o.clearcoatMap?"#define USE_CLEARCOATMAP":"",o.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",o.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",o.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",o.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",o.specularMap?"#define USE_SPECULARMAP":"",o.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",o.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",o.roughnessMap?"#define USE_ROUGHNESSMAP":"",o.metalnessMap?"#define USE_METALNESSMAP":"",o.alphaMap?"#define USE_ALPHAMAP":"",o.alphaHash?"#define USE_ALPHAHASH":"",o.transmission?"#define USE_TRANSMISSION":"",o.transmissionMap?"#define USE_TRANSMISSIONMAP":"",o.thicknessMap?"#define USE_THICKNESSMAP":"",o.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",o.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",o.mapUv?"#define MAP_UV "+o.mapUv:"",o.alphaMapUv?"#define ALPHAMAP_UV "+o.alphaMapUv:"",o.lightMapUv?"#define LIGHTMAP_UV "+o.lightMapUv:"",o.aoMapUv?"#define AOMAP_UV "+o.aoMapUv:"",o.emissiveMapUv?"#define EMISSIVEMAP_UV "+o.emissiveMapUv:"",o.bumpMapUv?"#define BUMPMAP_UV "+o.bumpMapUv:"",o.normalMapUv?"#define NORMALMAP_UV "+o.normalMapUv:"",o.displacementMapUv?"#define DISPLACEMENTMAP_UV "+o.displacementMapUv:"",o.metalnessMapUv?"#define METALNESSMAP_UV "+o.metalnessMapUv:"",o.roughnessMapUv?"#define ROUGHNESSMAP_UV "+o.roughnessMapUv:"",o.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+o.anisotropyMapUv:"",o.clearcoatMapUv?"#define CLEARCOATMAP_UV "+o.clearcoatMapUv:"",o.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+o.clearcoatNormalMapUv:"",o.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+o.clearcoatRoughnessMapUv:"",o.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+o.iridescenceMapUv:"",o.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+o.iridescenceThicknessMapUv:"",o.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+o.sheenColorMapUv:"",o.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+o.sheenRoughnessMapUv:"",o.specularMapUv?"#define SPECULARMAP_UV "+o.specularMapUv:"",o.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+o.specularColorMapUv:"",o.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+o.specularIntensityMapUv:"",o.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+o.transmissionMapUv:"",o.thicknessMapUv?"#define THICKNESSMAP_UV "+o.thicknessMapUv:"",o.vertexTangents&&o.flatShading===!1?"#define USE_TANGENT":"",o.vertexColors?"#define USE_COLOR":"",o.vertexAlphas?"#define USE_COLOR_ALPHA":"",o.vertexUv1s?"#define USE_UV1":"",o.vertexUv2s?"#define USE_UV2":"",o.vertexUv3s?"#define USE_UV3":"",o.pointsUvs?"#define USE_POINTS_UV":"",o.flatShading?"#define FLAT_SHADED":"",o.skinning?"#define USE_SKINNING":"",o.morphTargets?"#define USE_MORPHTARGETS":"",o.morphNormals&&o.flatShading===!1?"#define USE_MORPHNORMALS":"",o.morphColors&&o.isWebGL2?"#define USE_MORPHCOLORS":"",o.morphTargetsCount>0&&o.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",o.morphTargetsCount>0&&o.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+o.morphTextureStride:"",o.morphTargetsCount>0&&o.isWebGL2?"#define MORPHTARGETS_COUNT "+o.morphTargetsCount:"",o.doubleSided?"#define DOUBLE_SIDED":"",o.flipSided?"#define FLIP_SIDED":"",o.shadowMapEnabled?"#define USE_SHADOWMAP":"",o.shadowMapEnabled?"#define "+bt:"",o.sizeAttenuation?"#define USE_SIZEATTENUATION":"",o.numLightProbes>0?"#define USE_LIGHT_PROBES":"",o.useLegacyLights?"#define LEGACY_LIGHTS":"",o.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",o.logarithmicDepthBuffer&&o.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(filterEmptyLine).join(`
`),cr=[It,generatePrecision(o),"#define SHADER_TYPE "+o.shaderType,"#define SHADER_NAME "+o.shaderName,er,o.useFog&&o.fog?"#define USE_FOG":"",o.useFog&&o.fogExp2?"#define FOG_EXP2":"",o.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",o.map?"#define USE_MAP":"",o.matcap?"#define USE_MATCAP":"",o.envMap?"#define USE_ENVMAP":"",o.envMap?"#define "+g:"",o.envMap?"#define "+j:"",o.envMap?"#define "+b:"",Et?"#define CUBEUV_TEXEL_WIDTH "+Et.texelWidth:"",Et?"#define CUBEUV_TEXEL_HEIGHT "+Et.texelHeight:"",Et?"#define CUBEUV_MAX_MIP "+Et.maxMip+".0":"",o.lightMap?"#define USE_LIGHTMAP":"",o.aoMap?"#define USE_AOMAP":"",o.bumpMap?"#define USE_BUMPMAP":"",o.normalMap?"#define USE_NORMALMAP":"",o.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",o.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",o.emissiveMap?"#define USE_EMISSIVEMAP":"",o.anisotropy?"#define USE_ANISOTROPY":"",o.anisotropyMap?"#define USE_ANISOTROPYMAP":"",o.clearcoat?"#define USE_CLEARCOAT":"",o.clearcoatMap?"#define USE_CLEARCOATMAP":"",o.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",o.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",o.iridescence?"#define USE_IRIDESCENCE":"",o.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",o.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",o.specularMap?"#define USE_SPECULARMAP":"",o.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",o.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",o.roughnessMap?"#define USE_ROUGHNESSMAP":"",o.metalnessMap?"#define USE_METALNESSMAP":"",o.alphaMap?"#define USE_ALPHAMAP":"",o.alphaTest?"#define USE_ALPHATEST":"",o.alphaHash?"#define USE_ALPHAHASH":"",o.sheen?"#define USE_SHEEN":"",o.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",o.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",o.transmission?"#define USE_TRANSMISSION":"",o.transmissionMap?"#define USE_TRANSMISSIONMAP":"",o.thicknessMap?"#define USE_THICKNESSMAP":"",o.vertexTangents&&o.flatShading===!1?"#define USE_TANGENT":"",o.vertexColors||o.instancingColor?"#define USE_COLOR":"",o.vertexAlphas?"#define USE_COLOR_ALPHA":"",o.vertexUv1s?"#define USE_UV1":"",o.vertexUv2s?"#define USE_UV2":"",o.vertexUv3s?"#define USE_UV3":"",o.pointsUvs?"#define USE_POINTS_UV":"",o.gradientMap?"#define USE_GRADIENTMAP":"",o.flatShading?"#define FLAT_SHADED":"",o.doubleSided?"#define DOUBLE_SIDED":"",o.flipSided?"#define FLIP_SIDED":"",o.shadowMapEnabled?"#define USE_SHADOWMAP":"",o.shadowMapEnabled?"#define "+bt:"",o.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",o.numLightProbes>0?"#define USE_LIGHT_PROBES":"",o.useLegacyLights?"#define LEGACY_LIGHTS":"",o.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",o.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",o.logarithmicDepthBuffer&&o.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",o.toneMapping!==NoToneMapping?"#define TONE_MAPPING":"",o.toneMapping!==NoToneMapping?ShaderChunk.tonemapping_pars_fragment:"",o.toneMapping!==NoToneMapping?getToneMappingFunction("toneMapping",o.toneMapping):"",o.dithering?"#define DITHERING":"",o.opaque?"#define OPAQUE":"",ShaderChunk.colorspace_pars_fragment,getTexelEncodingFunction("linearToOutputTexel",o.outputColorSpace),o.useDepthPacking?"#define DEPTH_PACKING "+o.depthPacking:"",`
`].filter(filterEmptyLine).join(`
`)),h=resolveIncludes(h),h=replaceLightNums(h,o),h=replaceClippingPlaneNums(h,o),_=resolveIncludes(_),_=replaceLightNums(_,o),_=replaceClippingPlaneNums(_,o),h=unrollLoops(h),_=unrollLoops(_),o.isWebGL2&&o.isRawShaderMaterial!==!0&&(fr=`#version 300 es
`,Qt=[zt,"precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+Qt,cr=["precision mediump sampler2DArray;","#define varying in",o.glslVersion===GLSL3?"":"layout(location = 0) out highp vec4 pc_fragColor;",o.glslVersion===GLSL3?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+cr);const jr=fr+Qt+h,e0=fr+cr+_,t0=WebGLShader(d,d.VERTEX_SHADER,jr),o0=WebGLShader(d,d.FRAGMENT_SHADER,e0);d.attachShader(Hn,t0),d.attachShader(Hn,o0),o.index0AttributeName!==void 0?d.bindAttribLocation(Hn,0,o.index0AttributeName):o.morphTargets===!0&&d.bindAttribLocation(Hn,0,"position"),d.linkProgram(Hn);function l0(C0){if(a.debug.checkShaderErrors){const Z0=d.getProgramInfoLog(Hn).trim(),R0=d.getShaderInfoLog(t0).trim(),Y0=d.getShaderInfoLog(o0).trim();let H0=!0,ty=!0;if(d.getProgramParameter(Hn,d.LINK_STATUS)===!1)if(H0=!1,typeof a.debug.onShaderError=="function")a.debug.onShaderError(d,Hn,t0,o0);else{const w0=getShaderErrors(d,t0,"vertex"),L0=getShaderErrors(d,o0,"fragment");console.error("THREE.WebGLProgram: Shader Error "+d.getError()+" - VALIDATE_STATUS "+d.getProgramParameter(Hn,d.VALIDATE_STATUS)+`

Material Name: `+C0.name+`
Material Type: `+C0.type+`

Program Info Log: `+Z0+`
`+w0+`
`+L0)}else Z0!==""?console.warn("THREE.WebGLProgram: Program Info Log:",Z0):(R0===""||Y0==="")&&(ty=!1);ty&&(C0.diagnostics={runnable:H0,programLog:Z0,vertexShader:{log:R0,prefix:Qt},fragmentShader:{log:Y0,prefix:cr}})}d.deleteShader(t0),d.deleteShader(o0),g0=new WebGLUniforms(d,Hn),i0=fetchAttributeLocations(d,Hn)}let g0;this.getUniforms=function(){return g0===void 0&&l0(this),g0};let i0;this.getAttributes=function(){return i0===void 0&&l0(this),i0};let f0=o.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return f0===!1&&(f0=d.getProgramParameter(Hn,COMPLETION_STATUS_KHR)),f0},this.destroy=function(){s.releaseStatesOfProgram(this),d.deleteProgram(Hn),this.program=void 0},this.type=o.shaderType,this.name=o.shaderName,this.id=programIdCount++,this.cacheKey=e,this.usedTimes=1,this.program=Hn,this.vertexShader=t0,this.fragmentShader=o0,this}let _id$1=0;class WebGLShaderCache{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const o=e.vertexShader,s=e.fragmentShader,d=this._getShaderStage(o),c=this._getShaderStage(s),h=this._getShaderCacheForMaterial(e);return h.has(d)===!1&&(h.add(d),d.usedTimes++),h.has(c)===!1&&(h.add(c),c.usedTimes++),this}remove(e){const o=this.materialCache.get(e);for(const s of o)s.usedTimes--,s.usedTimes===0&&this.shaderCache.delete(s.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const o=this.materialCache;let s=o.get(e);return s===void 0&&(s=new Set,o.set(e,s)),s}_getShaderStage(e){const o=this.shaderCache;let s=o.get(e);return s===void 0&&(s=new WebGLShaderStage(e),o.set(e,s)),s}}class WebGLShaderStage{constructor(e){this.id=_id$1++,this.code=e,this.usedTimes=0}}function WebGLPrograms(a,e,o,s,d,c,h){const _=new Layers,bt=new WebGLShaderCache,g=new Set,j=[],b=d.isWebGL2,Et=d.logarithmicDepthBuffer,It=d.vertexTextures;let zt=d.precision;const er={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function Hn(i0){return g.add(i0),i0===0?"uv":`uv${i0}`}function Qt(i0,f0,C0,Z0,R0){const Y0=Z0.fog,H0=R0.geometry,ty=i0.isMeshStandardMaterial?Z0.environment:null,w0=(i0.isMeshStandardMaterial?o:e).get(i0.envMap||ty),L0=w0&&w0.mapping===CubeUVReflectionMapping?w0.image.height:null,k0=er[i0.type];i0.precision!==null&&(zt=d.getMaxPrecision(i0.precision),zt!==i0.precision&&console.warn("THREE.WebGLProgram.getParameters:",i0.precision,"not supported, using",zt,"instead."));const T0=H0.morphAttributes.position||H0.morphAttributes.normal||H0.morphAttributes.color,q0=T0!==void 0?T0.length:0;let vy=0;H0.morphAttributes.position!==void 0&&(vy=1),H0.morphAttributes.normal!==void 0&&(vy=2),H0.morphAttributes.color!==void 0&&(vy=3);let J0,cy,Ty,Uy;if(k0){const Sv=ShaderLib[k0];J0=Sv.vertexShader,cy=Sv.fragmentShader}else J0=i0.vertexShader,cy=i0.fragmentShader,bt.update(i0),Ty=bt.getVertexShaderID(i0),Uy=bt.getFragmentShaderID(i0);const Qy=a.getRenderTarget(),Zy=R0.isInstancedMesh===!0,iv=R0.isBatchedMesh===!0,zy=!!i0.map,B0=!!i0.matcap,Ay=!!w0,hy=!!i0.aoMap,Ly=!!i0.lightMap,Iy=!!i0.bumpMap,Jy=!!i0.normalMap,Gy=!!i0.displacementMap,sv=!!i0.emissiveMap,yv=!!i0.metalnessMap,I0=!!i0.roughnessMap,b0=i0.anisotropy>0,uy=i0.clearcoat>0,Ey=i0.iridescence>0,Dy=i0.sheen>0,By=i0.transmission>0,bv=b0&&!!i0.anisotropyMap,av=uy&&!!i0.clearcoatMap,Wy=uy&&!!i0.clearcoatNormalMap,my=uy&&!!i0.clearcoatRoughnessMap,uv=Ey&&!!i0.iridescenceMap,Hy=Ey&&!!i0.iridescenceThicknessMap,wv=Dy&&!!i0.sheenColorMap,mv=Dy&&!!i0.sheenRoughnessMap,cv=!!i0.specularMap,O0=!!i0.specularColorMap,oy=!!i0.specularIntensityMap,Py=By&&!!i0.transmissionMap,nv=By&&!!i0.thicknessMap,d0=!!i0.gradientMap,v0=!!i0.alphaMap,N0=i0.alphaTest>0,F0=!!i0.alphaHash,sy=!!i0.extensions;let xy=NoToneMapping;i0.toneMapped&&(Qy===null||Qy.isXRRenderTarget===!0)&&(xy=a.toneMapping);const ev={isWebGL2:b,shaderID:k0,shaderType:i0.type,shaderName:i0.name,vertexShader:J0,fragmentShader:cy,defines:i0.defines,customVertexShaderID:Ty,customFragmentShaderID:Uy,isRawShaderMaterial:i0.isRawShaderMaterial===!0,glslVersion:i0.glslVersion,precision:zt,batching:iv,instancing:Zy,instancingColor:Zy&&R0.instanceColor!==null,instancingMorph:Zy&&R0.morphTexture!==null,supportsVertexTextures:It,outputColorSpace:Qy===null?a.outputColorSpace:Qy.isXRRenderTarget===!0?Qy.texture.colorSpace:LinearSRGBColorSpace,alphaToCoverage:!!i0.alphaToCoverage,map:zy,matcap:B0,envMap:Ay,envMapMode:Ay&&w0.mapping,envMapCubeUVHeight:L0,aoMap:hy,lightMap:Ly,bumpMap:Iy,normalMap:Jy,displacementMap:It&&Gy,emissiveMap:sv,normalMapObjectSpace:Jy&&i0.normalMapType===ObjectSpaceNormalMap,normalMapTangentSpace:Jy&&i0.normalMapType===TangentSpaceNormalMap,metalnessMap:yv,roughnessMap:I0,anisotropy:b0,anisotropyMap:bv,clearcoat:uy,clearcoatMap:av,clearcoatNormalMap:Wy,clearcoatRoughnessMap:my,iridescence:Ey,iridescenceMap:uv,iridescenceThicknessMap:Hy,sheen:Dy,sheenColorMap:wv,sheenRoughnessMap:mv,specularMap:cv,specularColorMap:O0,specularIntensityMap:oy,transmission:By,transmissionMap:Py,thicknessMap:nv,gradientMap:d0,opaque:i0.transparent===!1&&i0.blending===NormalBlending&&i0.alphaToCoverage===!1,alphaMap:v0,alphaTest:N0,alphaHash:F0,combine:i0.combine,mapUv:zy&&Hn(i0.map.channel),aoMapUv:hy&&Hn(i0.aoMap.channel),lightMapUv:Ly&&Hn(i0.lightMap.channel),bumpMapUv:Iy&&Hn(i0.bumpMap.channel),normalMapUv:Jy&&Hn(i0.normalMap.channel),displacementMapUv:Gy&&Hn(i0.displacementMap.channel),emissiveMapUv:sv&&Hn(i0.emissiveMap.channel),metalnessMapUv:yv&&Hn(i0.metalnessMap.channel),roughnessMapUv:I0&&Hn(i0.roughnessMap.channel),anisotropyMapUv:bv&&Hn(i0.anisotropyMap.channel),clearcoatMapUv:av&&Hn(i0.clearcoatMap.channel),clearcoatNormalMapUv:Wy&&Hn(i0.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:my&&Hn(i0.clearcoatRoughnessMap.channel),iridescenceMapUv:uv&&Hn(i0.iridescenceMap.channel),iridescenceThicknessMapUv:Hy&&Hn(i0.iridescenceThicknessMap.channel),sheenColorMapUv:wv&&Hn(i0.sheenColorMap.channel),sheenRoughnessMapUv:mv&&Hn(i0.sheenRoughnessMap.channel),specularMapUv:cv&&Hn(i0.specularMap.channel),specularColorMapUv:O0&&Hn(i0.specularColorMap.channel),specularIntensityMapUv:oy&&Hn(i0.specularIntensityMap.channel),transmissionMapUv:Py&&Hn(i0.transmissionMap.channel),thicknessMapUv:nv&&Hn(i0.thicknessMap.channel),alphaMapUv:v0&&Hn(i0.alphaMap.channel),vertexTangents:!!H0.attributes.tangent&&(Jy||b0),vertexColors:i0.vertexColors,vertexAlphas:i0.vertexColors===!0&&!!H0.attributes.color&&H0.attributes.color.itemSize===4,pointsUvs:R0.isPoints===!0&&!!H0.attributes.uv&&(zy||v0),fog:!!Y0,useFog:i0.fog===!0,fogExp2:!!Y0&&Y0.isFogExp2,flatShading:i0.flatShading===!0,sizeAttenuation:i0.sizeAttenuation===!0,logarithmicDepthBuffer:Et,skinning:R0.isSkinnedMesh===!0,morphTargets:H0.morphAttributes.position!==void 0,morphNormals:H0.morphAttributes.normal!==void 0,morphColors:H0.morphAttributes.color!==void 0,morphTargetsCount:q0,morphTextureStride:vy,numDirLights:f0.directional.length,numPointLights:f0.point.length,numSpotLights:f0.spot.length,numSpotLightMaps:f0.spotLightMap.length,numRectAreaLights:f0.rectArea.length,numHemiLights:f0.hemi.length,numDirLightShadows:f0.directionalShadowMap.length,numPointLightShadows:f0.pointShadowMap.length,numSpotLightShadows:f0.spotShadowMap.length,numSpotLightShadowsWithMaps:f0.numSpotLightShadowsWithMaps,numLightProbes:f0.numLightProbes,numClippingPlanes:h.numPlanes,numClipIntersection:h.numIntersection,dithering:i0.dithering,shadowMapEnabled:a.shadowMap.enabled&&C0.length>0,shadowMapType:a.shadowMap.type,toneMapping:xy,useLegacyLights:a._useLegacyLights,decodeVideoTexture:zy&&i0.map.isVideoTexture===!0&&ColorManagement.getTransfer(i0.map.colorSpace)===SRGBTransfer,premultipliedAlpha:i0.premultipliedAlpha,doubleSided:i0.side===DoubleSide,flipSided:i0.side===BackSide,useDepthPacking:i0.depthPacking>=0,depthPacking:i0.depthPacking||0,index0AttributeName:i0.index0AttributeName,extensionDerivatives:sy&&i0.extensions.derivatives===!0,extensionFragDepth:sy&&i0.extensions.fragDepth===!0,extensionDrawBuffers:sy&&i0.extensions.drawBuffers===!0,extensionShaderTextureLOD:sy&&i0.extensions.shaderTextureLOD===!0,extensionClipCullDistance:sy&&i0.extensions.clipCullDistance===!0&&s.has("WEBGL_clip_cull_distance"),extensionMultiDraw:sy&&i0.extensions.multiDraw===!0&&s.has("WEBGL_multi_draw"),rendererExtensionFragDepth:b||s.has("EXT_frag_depth"),rendererExtensionDrawBuffers:b||s.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:b||s.has("EXT_shader_texture_lod"),rendererExtensionParallelShaderCompile:s.has("KHR_parallel_shader_compile"),customProgramCacheKey:i0.customProgramCacheKey()};return ev.vertexUv1s=g.has(1),ev.vertexUv2s=g.has(2),ev.vertexUv3s=g.has(3),g.clear(),ev}function cr(i0){const f0=[];if(i0.shaderID?f0.push(i0.shaderID):(f0.push(i0.customVertexShaderID),f0.push(i0.customFragmentShaderID)),i0.defines!==void 0)for(const C0 in i0.defines)f0.push(C0),f0.push(i0.defines[C0]);return i0.isRawShaderMaterial===!1&&(fr(f0,i0),jr(f0,i0),f0.push(a.outputColorSpace)),f0.push(i0.customProgramCacheKey),f0.join()}function fr(i0,f0){i0.push(f0.precision),i0.push(f0.outputColorSpace),i0.push(f0.envMapMode),i0.push(f0.envMapCubeUVHeight),i0.push(f0.mapUv),i0.push(f0.alphaMapUv),i0.push(f0.lightMapUv),i0.push(f0.aoMapUv),i0.push(f0.bumpMapUv),i0.push(f0.normalMapUv),i0.push(f0.displacementMapUv),i0.push(f0.emissiveMapUv),i0.push(f0.metalnessMapUv),i0.push(f0.roughnessMapUv),i0.push(f0.anisotropyMapUv),i0.push(f0.clearcoatMapUv),i0.push(f0.clearcoatNormalMapUv),i0.push(f0.clearcoatRoughnessMapUv),i0.push(f0.iridescenceMapUv),i0.push(f0.iridescenceThicknessMapUv),i0.push(f0.sheenColorMapUv),i0.push(f0.sheenRoughnessMapUv),i0.push(f0.specularMapUv),i0.push(f0.specularColorMapUv),i0.push(f0.specularIntensityMapUv),i0.push(f0.transmissionMapUv),i0.push(f0.thicknessMapUv),i0.push(f0.combine),i0.push(f0.fogExp2),i0.push(f0.sizeAttenuation),i0.push(f0.morphTargetsCount),i0.push(f0.morphAttributeCount),i0.push(f0.numDirLights),i0.push(f0.numPointLights),i0.push(f0.numSpotLights),i0.push(f0.numSpotLightMaps),i0.push(f0.numHemiLights),i0.push(f0.numRectAreaLights),i0.push(f0.numDirLightShadows),i0.push(f0.numPointLightShadows),i0.push(f0.numSpotLightShadows),i0.push(f0.numSpotLightShadowsWithMaps),i0.push(f0.numLightProbes),i0.push(f0.shadowMapType),i0.push(f0.toneMapping),i0.push(f0.numClippingPlanes),i0.push(f0.numClipIntersection),i0.push(f0.depthPacking)}function jr(i0,f0){_.disableAll(),f0.isWebGL2&&_.enable(0),f0.supportsVertexTextures&&_.enable(1),f0.instancing&&_.enable(2),f0.instancingColor&&_.enable(3),f0.instancingMorph&&_.enable(4),f0.matcap&&_.enable(5),f0.envMap&&_.enable(6),f0.normalMapObjectSpace&&_.enable(7),f0.normalMapTangentSpace&&_.enable(8),f0.clearcoat&&_.enable(9),f0.iridescence&&_.enable(10),f0.alphaTest&&_.enable(11),f0.vertexColors&&_.enable(12),f0.vertexAlphas&&_.enable(13),f0.vertexUv1s&&_.enable(14),f0.vertexUv2s&&_.enable(15),f0.vertexUv3s&&_.enable(16),f0.vertexTangents&&_.enable(17),f0.anisotropy&&_.enable(18),f0.alphaHash&&_.enable(19),f0.batching&&_.enable(20),i0.push(_.mask),_.disableAll(),f0.fog&&_.enable(0),f0.useFog&&_.enable(1),f0.flatShading&&_.enable(2),f0.logarithmicDepthBuffer&&_.enable(3),f0.skinning&&_.enable(4),f0.morphTargets&&_.enable(5),f0.morphNormals&&_.enable(6),f0.morphColors&&_.enable(7),f0.premultipliedAlpha&&_.enable(8),f0.shadowMapEnabled&&_.enable(9),f0.useLegacyLights&&_.enable(10),f0.doubleSided&&_.enable(11),f0.flipSided&&_.enable(12),f0.useDepthPacking&&_.enable(13),f0.dithering&&_.enable(14),f0.transmission&&_.enable(15),f0.sheen&&_.enable(16),f0.opaque&&_.enable(17),f0.pointsUvs&&_.enable(18),f0.decodeVideoTexture&&_.enable(19),f0.alphaToCoverage&&_.enable(20),i0.push(_.mask)}function e0(i0){const f0=er[i0.type];let C0;if(f0){const Z0=ShaderLib[f0];C0=UniformsUtils.clone(Z0.uniforms)}else C0=i0.uniforms;return C0}function t0(i0,f0){let C0;for(let Z0=0,R0=j.length;Z0<R0;Z0++){const Y0=j[Z0];if(Y0.cacheKey===f0){C0=Y0,++C0.usedTimes;break}}return C0===void 0&&(C0=new WebGLProgram(a,f0,i0,c),j.push(C0)),C0}function o0(i0){if(--i0.usedTimes===0){const f0=j.indexOf(i0);j[f0]=j[j.length-1],j.pop(),i0.destroy()}}function l0(i0){bt.remove(i0)}function g0(){bt.dispose()}return{getParameters:Qt,getProgramCacheKey:cr,getUniforms:e0,acquireProgram:t0,releaseProgram:o0,releaseShaderCache:l0,programs:j,dispose:g0}}function WebGLProperties(){let a=new WeakMap;function e(c){let h=a.get(c);return h===void 0&&(h={},a.set(c,h)),h}function o(c){a.delete(c)}function s(c,h,_){a.get(c)[h]=_}function d(){a=new WeakMap}return{get:e,remove:o,update:s,dispose:d}}function painterSortStable(a,e){return a.groupOrder!==e.groupOrder?a.groupOrder-e.groupOrder:a.renderOrder!==e.renderOrder?a.renderOrder-e.renderOrder:a.material.id!==e.material.id?a.material.id-e.material.id:a.z!==e.z?a.z-e.z:a.id-e.id}function reversePainterSortStable(a,e){return a.groupOrder!==e.groupOrder?a.groupOrder-e.groupOrder:a.renderOrder!==e.renderOrder?a.renderOrder-e.renderOrder:a.z!==e.z?e.z-a.z:a.id-e.id}function WebGLRenderList(){const a=[];let e=0;const o=[],s=[],d=[];function c(){e=0,o.length=0,s.length=0,d.length=0}function h(b,Et,It,zt,er,Hn){let Qt=a[e];return Qt===void 0?(Qt={id:b.id,object:b,geometry:Et,material:It,groupOrder:zt,renderOrder:b.renderOrder,z:er,group:Hn},a[e]=Qt):(Qt.id=b.id,Qt.object=b,Qt.geometry=Et,Qt.material=It,Qt.groupOrder=zt,Qt.renderOrder=b.renderOrder,Qt.z=er,Qt.group=Hn),e++,Qt}function _(b,Et,It,zt,er,Hn){const Qt=h(b,Et,It,zt,er,Hn);It.transmission>0?s.push(Qt):It.transparent===!0?d.push(Qt):o.push(Qt)}function bt(b,Et,It,zt,er,Hn){const Qt=h(b,Et,It,zt,er,Hn);It.transmission>0?s.unshift(Qt):It.transparent===!0?d.unshift(Qt):o.unshift(Qt)}function g(b,Et){o.length>1&&o.sort(b||painterSortStable),s.length>1&&s.sort(Et||reversePainterSortStable),d.length>1&&d.sort(Et||reversePainterSortStable)}function j(){for(let b=e,Et=a.length;b<Et;b++){const It=a[b];if(It.id===null)break;It.id=null,It.object=null,It.geometry=null,It.material=null,It.group=null}}return{opaque:o,transmissive:s,transparent:d,init:c,push:_,unshift:bt,finish:j,sort:g}}function WebGLRenderLists(){let a=new WeakMap;function e(s,d){const c=a.get(s);let h;return c===void 0?(h=new WebGLRenderList,a.set(s,[h])):d>=c.length?(h=new WebGLRenderList,c.push(h)):h=c[d],h}function o(){a=new WeakMap}return{get:e,dispose:o}}function UniformsCache(){const a={};return{get:function(e){if(a[e.id]!==void 0)return a[e.id];let o;switch(e.type){case"DirectionalLight":o={direction:new Vector3,color:new Color};break;case"SpotLight":o={position:new Vector3,direction:new Vector3,color:new Color,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":o={position:new Vector3,color:new Color,distance:0,decay:0};break;case"HemisphereLight":o={direction:new Vector3,skyColor:new Color,groundColor:new Color};break;case"RectAreaLight":o={color:new Color,position:new Vector3,halfWidth:new Vector3,halfHeight:new Vector3};break}return a[e.id]=o,o}}}function ShadowUniformsCache(){const a={};return{get:function(e){if(a[e.id]!==void 0)return a[e.id];let o;switch(e.type){case"DirectionalLight":o={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"SpotLight":o={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"PointLight":o={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2,shadowCameraNear:1,shadowCameraFar:1e3};break}return a[e.id]=o,o}}}let nextVersion=0;function shadowCastingAndTexturingLightsFirst(a,e){return(e.castShadow?2:0)-(a.castShadow?2:0)+(e.map?1:0)-(a.map?1:0)}function WebGLLights(a,e){const o=new UniformsCache,s=ShadowUniformsCache(),d={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let j=0;j<9;j++)d.probe.push(new Vector3);const c=new Vector3,h=new Matrix4,_=new Matrix4;function bt(j,b){let Et=0,It=0,zt=0;for(let C0=0;C0<9;C0++)d.probe[C0].set(0,0,0);let er=0,Hn=0,Qt=0,cr=0,fr=0,jr=0,e0=0,t0=0,o0=0,l0=0,g0=0;j.sort(shadowCastingAndTexturingLightsFirst);const i0=b===!0?Math.PI:1;for(let C0=0,Z0=j.length;C0<Z0;C0++){const R0=j[C0],Y0=R0.color,H0=R0.intensity,ty=R0.distance,w0=R0.shadow&&R0.shadow.map?R0.shadow.map.texture:null;if(R0.isAmbientLight)Et+=Y0.r*H0*i0,It+=Y0.g*H0*i0,zt+=Y0.b*H0*i0;else if(R0.isLightProbe){for(let L0=0;L0<9;L0++)d.probe[L0].addScaledVector(R0.sh.coefficients[L0],H0);g0++}else if(R0.isDirectionalLight){const L0=o.get(R0);if(L0.color.copy(R0.color).multiplyScalar(R0.intensity*i0),R0.castShadow){const k0=R0.shadow,T0=s.get(R0);T0.shadowBias=k0.bias,T0.shadowNormalBias=k0.normalBias,T0.shadowRadius=k0.radius,T0.shadowMapSize=k0.mapSize,d.directionalShadow[er]=T0,d.directionalShadowMap[er]=w0,d.directionalShadowMatrix[er]=R0.shadow.matrix,jr++}d.directional[er]=L0,er++}else if(R0.isSpotLight){const L0=o.get(R0);L0.position.setFromMatrixPosition(R0.matrixWorld),L0.color.copy(Y0).multiplyScalar(H0*i0),L0.distance=ty,L0.coneCos=Math.cos(R0.angle),L0.penumbraCos=Math.cos(R0.angle*(1-R0.penumbra)),L0.decay=R0.decay,d.spot[Qt]=L0;const k0=R0.shadow;if(R0.map&&(d.spotLightMap[o0]=R0.map,o0++,k0.updateMatrices(R0),R0.castShadow&&l0++),d.spotLightMatrix[Qt]=k0.matrix,R0.castShadow){const T0=s.get(R0);T0.shadowBias=k0.bias,T0.shadowNormalBias=k0.normalBias,T0.shadowRadius=k0.radius,T0.shadowMapSize=k0.mapSize,d.spotShadow[Qt]=T0,d.spotShadowMap[Qt]=w0,t0++}Qt++}else if(R0.isRectAreaLight){const L0=o.get(R0);L0.color.copy(Y0).multiplyScalar(H0),L0.halfWidth.set(R0.width*.5,0,0),L0.halfHeight.set(0,R0.height*.5,0),d.rectArea[cr]=L0,cr++}else if(R0.isPointLight){const L0=o.get(R0);if(L0.color.copy(R0.color).multiplyScalar(R0.intensity*i0),L0.distance=R0.distance,L0.decay=R0.decay,R0.castShadow){const k0=R0.shadow,T0=s.get(R0);T0.shadowBias=k0.bias,T0.shadowNormalBias=k0.normalBias,T0.shadowRadius=k0.radius,T0.shadowMapSize=k0.mapSize,T0.shadowCameraNear=k0.camera.near,T0.shadowCameraFar=k0.camera.far,d.pointShadow[Hn]=T0,d.pointShadowMap[Hn]=w0,d.pointShadowMatrix[Hn]=R0.shadow.matrix,e0++}d.point[Hn]=L0,Hn++}else if(R0.isHemisphereLight){const L0=o.get(R0);L0.skyColor.copy(R0.color).multiplyScalar(H0*i0),L0.groundColor.copy(R0.groundColor).multiplyScalar(H0*i0),d.hemi[fr]=L0,fr++}}cr>0&&(e.isWebGL2?a.has("OES_texture_float_linear")===!0?(d.rectAreaLTC1=UniformsLib.LTC_FLOAT_1,d.rectAreaLTC2=UniformsLib.LTC_FLOAT_2):(d.rectAreaLTC1=UniformsLib.LTC_HALF_1,d.rectAreaLTC2=UniformsLib.LTC_HALF_2):a.has("OES_texture_float_linear")===!0?(d.rectAreaLTC1=UniformsLib.LTC_FLOAT_1,d.rectAreaLTC2=UniformsLib.LTC_FLOAT_2):a.has("OES_texture_half_float_linear")===!0?(d.rectAreaLTC1=UniformsLib.LTC_HALF_1,d.rectAreaLTC2=UniformsLib.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),d.ambient[0]=Et,d.ambient[1]=It,d.ambient[2]=zt;const f0=d.hash;(f0.directionalLength!==er||f0.pointLength!==Hn||f0.spotLength!==Qt||f0.rectAreaLength!==cr||f0.hemiLength!==fr||f0.numDirectionalShadows!==jr||f0.numPointShadows!==e0||f0.numSpotShadows!==t0||f0.numSpotMaps!==o0||f0.numLightProbes!==g0)&&(d.directional.length=er,d.spot.length=Qt,d.rectArea.length=cr,d.point.length=Hn,d.hemi.length=fr,d.directionalShadow.length=jr,d.directionalShadowMap.length=jr,d.pointShadow.length=e0,d.pointShadowMap.length=e0,d.spotShadow.length=t0,d.spotShadowMap.length=t0,d.directionalShadowMatrix.length=jr,d.pointShadowMatrix.length=e0,d.spotLightMatrix.length=t0+o0-l0,d.spotLightMap.length=o0,d.numSpotLightShadowsWithMaps=l0,d.numLightProbes=g0,f0.directionalLength=er,f0.pointLength=Hn,f0.spotLength=Qt,f0.rectAreaLength=cr,f0.hemiLength=fr,f0.numDirectionalShadows=jr,f0.numPointShadows=e0,f0.numSpotShadows=t0,f0.numSpotMaps=o0,f0.numLightProbes=g0,d.version=nextVersion++)}function g(j,b){let Et=0,It=0,zt=0,er=0,Hn=0;const Qt=b.matrixWorldInverse;for(let cr=0,fr=j.length;cr<fr;cr++){const jr=j[cr];if(jr.isDirectionalLight){const e0=d.directional[Et];e0.direction.setFromMatrixPosition(jr.matrixWorld),c.setFromMatrixPosition(jr.target.matrixWorld),e0.direction.sub(c),e0.direction.transformDirection(Qt),Et++}else if(jr.isSpotLight){const e0=d.spot[zt];e0.position.setFromMatrixPosition(jr.matrixWorld),e0.position.applyMatrix4(Qt),e0.direction.setFromMatrixPosition(jr.matrixWorld),c.setFromMatrixPosition(jr.target.matrixWorld),e0.direction.sub(c),e0.direction.transformDirection(Qt),zt++}else if(jr.isRectAreaLight){const e0=d.rectArea[er];e0.position.setFromMatrixPosition(jr.matrixWorld),e0.position.applyMatrix4(Qt),_.identity(),h.copy(jr.matrixWorld),h.premultiply(Qt),_.extractRotation(h),e0.halfWidth.set(jr.width*.5,0,0),e0.halfHeight.set(0,jr.height*.5,0),e0.halfWidth.applyMatrix4(_),e0.halfHeight.applyMatrix4(_),er++}else if(jr.isPointLight){const e0=d.point[It];e0.position.setFromMatrixPosition(jr.matrixWorld),e0.position.applyMatrix4(Qt),It++}else if(jr.isHemisphereLight){const e0=d.hemi[Hn];e0.direction.setFromMatrixPosition(jr.matrixWorld),e0.direction.transformDirection(Qt),Hn++}}}return{setup:bt,setupView:g,state:d}}function WebGLRenderState(a,e){const o=new WebGLLights(a,e),s=[],d=[];function c(){s.length=0,d.length=0}function h(b){s.push(b)}function _(b){d.push(b)}function bt(b){o.setup(s,b)}function g(b){o.setupView(s,b)}return{init:c,state:{lightsArray:s,shadowsArray:d,lights:o},setupLights:bt,setupLightsView:g,pushLight:h,pushShadow:_}}function WebGLRenderStates(a,e){let o=new WeakMap;function s(c,h=0){const _=o.get(c);let bt;return _===void 0?(bt=new WebGLRenderState(a,e),o.set(c,[bt])):h>=_.length?(bt=new WebGLRenderState(a,e),_.push(bt)):bt=_[h],bt}function d(){o=new WeakMap}return{get:s,dispose:d}}class MeshDepthMaterial extends Material{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=BasicDepthPacking,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class MeshDistanceMaterial extends Material{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const vertex=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,fragment=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function WebGLShadowMap(a,e,o){let s=new Frustum;const d=new Vector2,c=new Vector2,h=new Vector4,_=new MeshDepthMaterial({depthPacking:RGBADepthPacking}),bt=new MeshDistanceMaterial,g={},j=o.maxTextureSize,b={[FrontSide]:BackSide,[BackSide]:FrontSide,[DoubleSide]:DoubleSide},Et=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2},radius:{value:4}},vertexShader:vertex,fragmentShader:fragment}),It=Et.clone();It.defines.HORIZONTAL_PASS=1;const zt=new BufferGeometry;zt.setAttribute("position",new BufferAttribute(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const er=new Mesh(zt,Et),Hn=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=PCFShadowMap;let Qt=this.type;this.render=function(t0,o0,l0){if(Hn.enabled===!1||Hn.autoUpdate===!1&&Hn.needsUpdate===!1||t0.length===0)return;const g0=a.getRenderTarget(),i0=a.getActiveCubeFace(),f0=a.getActiveMipmapLevel(),C0=a.state;C0.setBlending(NoBlending),C0.buffers.color.setClear(1,1,1,1),C0.buffers.depth.setTest(!0),C0.setScissorTest(!1);const Z0=Qt!==VSMShadowMap&&this.type===VSMShadowMap,R0=Qt===VSMShadowMap&&this.type!==VSMShadowMap;for(let Y0=0,H0=t0.length;Y0<H0;Y0++){const ty=t0[Y0],w0=ty.shadow;if(w0===void 0){console.warn("THREE.WebGLShadowMap:",ty,"has no shadow.");continue}if(w0.autoUpdate===!1&&w0.needsUpdate===!1)continue;d.copy(w0.mapSize);const L0=w0.getFrameExtents();if(d.multiply(L0),c.copy(w0.mapSize),(d.x>j||d.y>j)&&(d.x>j&&(c.x=Math.floor(j/L0.x),d.x=c.x*L0.x,w0.mapSize.x=c.x),d.y>j&&(c.y=Math.floor(j/L0.y),d.y=c.y*L0.y,w0.mapSize.y=c.y)),w0.map===null||Z0===!0||R0===!0){const T0=this.type!==VSMShadowMap?{minFilter:NearestFilter,magFilter:NearestFilter}:{};w0.map!==null&&w0.map.dispose(),w0.map=new WebGLRenderTarget(d.x,d.y,T0),w0.map.texture.name=ty.name+".shadowMap",w0.camera.updateProjectionMatrix()}a.setRenderTarget(w0.map),a.clear();const k0=w0.getViewportCount();for(let T0=0;T0<k0;T0++){const q0=w0.getViewport(T0);h.set(c.x*q0.x,c.y*q0.y,c.x*q0.z,c.y*q0.w),C0.viewport(h),w0.updateMatrices(ty,T0),s=w0.getFrustum(),jr(o0,l0,w0.camera,ty,this.type)}w0.isPointLightShadow!==!0&&this.type===VSMShadowMap&&cr(w0,l0),w0.needsUpdate=!1}Qt=this.type,Hn.needsUpdate=!1,a.setRenderTarget(g0,i0,f0)};function cr(t0,o0){const l0=e.update(er);Et.defines.VSM_SAMPLES!==t0.blurSamples&&(Et.defines.VSM_SAMPLES=t0.blurSamples,It.defines.VSM_SAMPLES=t0.blurSamples,Et.needsUpdate=!0,It.needsUpdate=!0),t0.mapPass===null&&(t0.mapPass=new WebGLRenderTarget(d.x,d.y)),Et.uniforms.shadow_pass.value=t0.map.texture,Et.uniforms.resolution.value=t0.mapSize,Et.uniforms.radius.value=t0.radius,a.setRenderTarget(t0.mapPass),a.clear(),a.renderBufferDirect(o0,null,l0,Et,er,null),It.uniforms.shadow_pass.value=t0.mapPass.texture,It.uniforms.resolution.value=t0.mapSize,It.uniforms.radius.value=t0.radius,a.setRenderTarget(t0.map),a.clear(),a.renderBufferDirect(o0,null,l0,It,er,null)}function fr(t0,o0,l0,g0){let i0=null;const f0=l0.isPointLight===!0?t0.customDistanceMaterial:t0.customDepthMaterial;if(f0!==void 0)i0=f0;else if(i0=l0.isPointLight===!0?bt:_,a.localClippingEnabled&&o0.clipShadows===!0&&Array.isArray(o0.clippingPlanes)&&o0.clippingPlanes.length!==0||o0.displacementMap&&o0.displacementScale!==0||o0.alphaMap&&o0.alphaTest>0||o0.map&&o0.alphaTest>0){const C0=i0.uuid,Z0=o0.uuid;let R0=g[C0];R0===void 0&&(R0={},g[C0]=R0);let Y0=R0[Z0];Y0===void 0&&(Y0=i0.clone(),R0[Z0]=Y0,o0.addEventListener("dispose",e0)),i0=Y0}if(i0.visible=o0.visible,i0.wireframe=o0.wireframe,g0===VSMShadowMap?i0.side=o0.shadowSide!==null?o0.shadowSide:o0.side:i0.side=o0.shadowSide!==null?o0.shadowSide:b[o0.side],i0.alphaMap=o0.alphaMap,i0.alphaTest=o0.alphaTest,i0.map=o0.map,i0.clipShadows=o0.clipShadows,i0.clippingPlanes=o0.clippingPlanes,i0.clipIntersection=o0.clipIntersection,i0.displacementMap=o0.displacementMap,i0.displacementScale=o0.displacementScale,i0.displacementBias=o0.displacementBias,i0.wireframeLinewidth=o0.wireframeLinewidth,i0.linewidth=o0.linewidth,l0.isPointLight===!0&&i0.isMeshDistanceMaterial===!0){const C0=a.properties.get(i0);C0.light=l0}return i0}function jr(t0,o0,l0,g0,i0){if(t0.visible===!1)return;if(t0.layers.test(o0.layers)&&(t0.isMesh||t0.isLine||t0.isPoints)&&(t0.castShadow||t0.receiveShadow&&i0===VSMShadowMap)&&(!t0.frustumCulled||s.intersectsObject(t0))){t0.modelViewMatrix.multiplyMatrices(l0.matrixWorldInverse,t0.matrixWorld);const Z0=e.update(t0),R0=t0.material;if(Array.isArray(R0)){const Y0=Z0.groups;for(let H0=0,ty=Y0.length;H0<ty;H0++){const w0=Y0[H0],L0=R0[w0.materialIndex];if(L0&&L0.visible){const k0=fr(t0,L0,g0,i0);t0.onBeforeShadow(a,t0,o0,l0,Z0,k0,w0),a.renderBufferDirect(l0,null,Z0,k0,t0,w0),t0.onAfterShadow(a,t0,o0,l0,Z0,k0,w0)}}}else if(R0.visible){const Y0=fr(t0,R0,g0,i0);t0.onBeforeShadow(a,t0,o0,l0,Z0,Y0,null),a.renderBufferDirect(l0,null,Z0,Y0,t0,null),t0.onAfterShadow(a,t0,o0,l0,Z0,Y0,null)}}const C0=t0.children;for(let Z0=0,R0=C0.length;Z0<R0;Z0++)jr(C0[Z0],o0,l0,g0,i0)}function e0(t0){t0.target.removeEventListener("dispose",e0);for(const l0 in g){const g0=g[l0],i0=t0.target.uuid;i0 in g0&&(g0[i0].dispose(),delete g0[i0])}}}function WebGLState(a,e,o){const s=o.isWebGL2;function d(){let v0=!1;const N0=new Vector4;let F0=null;const sy=new Vector4(0,0,0,0);return{setMask:function(xy){F0!==xy&&!v0&&(a.colorMask(xy,xy,xy,xy),F0=xy)},setLocked:function(xy){v0=xy},setClear:function(xy,ev,Sv,kv,Vv){Vv===!0&&(xy*=kv,ev*=kv,Sv*=kv),N0.set(xy,ev,Sv,kv),sy.equals(N0)===!1&&(a.clearColor(xy,ev,Sv,kv),sy.copy(N0))},reset:function(){v0=!1,F0=null,sy.set(-1,0,0,0)}}}function c(){let v0=!1,N0=null,F0=null,sy=null;return{setTest:function(xy){xy?Zy(a.DEPTH_TEST):iv(a.DEPTH_TEST)},setMask:function(xy){N0!==xy&&!v0&&(a.depthMask(xy),N0=xy)},setFunc:function(xy){if(F0!==xy){switch(xy){case NeverDepth:a.depthFunc(a.NEVER);break;case AlwaysDepth:a.depthFunc(a.ALWAYS);break;case LessDepth:a.depthFunc(a.LESS);break;case LessEqualDepth:a.depthFunc(a.LEQUAL);break;case EqualDepth:a.depthFunc(a.EQUAL);break;case GreaterEqualDepth:a.depthFunc(a.GEQUAL);break;case GreaterDepth:a.depthFunc(a.GREATER);break;case NotEqualDepth:a.depthFunc(a.NOTEQUAL);break;default:a.depthFunc(a.LEQUAL)}F0=xy}},setLocked:function(xy){v0=xy},setClear:function(xy){sy!==xy&&(a.clearDepth(xy),sy=xy)},reset:function(){v0=!1,N0=null,F0=null,sy=null}}}function h(){let v0=!1,N0=null,F0=null,sy=null,xy=null,ev=null,Sv=null,kv=null,Vv=null;return{setTest:function($v){v0||($v?Zy(a.STENCIL_TEST):iv(a.STENCIL_TEST))},setMask:function($v){N0!==$v&&!v0&&(a.stencilMask($v),N0=$v)},setFunc:function($v,ov,C_){(F0!==$v||sy!==ov||xy!==C_)&&(a.stencilFunc($v,ov,C_),F0=$v,sy=ov,xy=C_)},setOp:function($v,ov,C_){(ev!==$v||Sv!==ov||kv!==C_)&&(a.stencilOp($v,ov,C_),ev=$v,Sv=ov,kv=C_)},setLocked:function($v){v0=$v},setClear:function($v){Vv!==$v&&(a.clearStencil($v),Vv=$v)},reset:function(){v0=!1,N0=null,F0=null,sy=null,xy=null,ev=null,Sv=null,kv=null,Vv=null}}}const _=new d,bt=new c,g=new h,j=new WeakMap,b=new WeakMap;let Et={},It={},zt=new WeakMap,er=[],Hn=null,Qt=!1,cr=null,fr=null,jr=null,e0=null,t0=null,o0=null,l0=null,g0=new Color(0,0,0),i0=0,f0=!1,C0=null,Z0=null,R0=null,Y0=null,H0=null;const ty=a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let w0=!1,L0=0;const k0=a.getParameter(a.VERSION);k0.indexOf("WebGL")!==-1?(L0=parseFloat(/^WebGL (\d)/.exec(k0)[1]),w0=L0>=1):k0.indexOf("OpenGL ES")!==-1&&(L0=parseFloat(/^OpenGL ES (\d)/.exec(k0)[1]),w0=L0>=2);let T0=null,q0={};const vy=a.getParameter(a.SCISSOR_BOX),J0=a.getParameter(a.VIEWPORT),cy=new Vector4().fromArray(vy),Ty=new Vector4().fromArray(J0);function Uy(v0,N0,F0,sy){const xy=new Uint8Array(4),ev=a.createTexture();a.bindTexture(v0,ev),a.texParameteri(v0,a.TEXTURE_MIN_FILTER,a.NEAREST),a.texParameteri(v0,a.TEXTURE_MAG_FILTER,a.NEAREST);for(let Sv=0;Sv<F0;Sv++)s&&(v0===a.TEXTURE_3D||v0===a.TEXTURE_2D_ARRAY)?a.texImage3D(N0,0,a.RGBA,1,1,sy,0,a.RGBA,a.UNSIGNED_BYTE,xy):a.texImage2D(N0+Sv,0,a.RGBA,1,1,0,a.RGBA,a.UNSIGNED_BYTE,xy);return ev}const Qy={};Qy[a.TEXTURE_2D]=Uy(a.TEXTURE_2D,a.TEXTURE_2D,1),Qy[a.TEXTURE_CUBE_MAP]=Uy(a.TEXTURE_CUBE_MAP,a.TEXTURE_CUBE_MAP_POSITIVE_X,6),s&&(Qy[a.TEXTURE_2D_ARRAY]=Uy(a.TEXTURE_2D_ARRAY,a.TEXTURE_2D_ARRAY,1,1),Qy[a.TEXTURE_3D]=Uy(a.TEXTURE_3D,a.TEXTURE_3D,1,1)),_.setClear(0,0,0,1),bt.setClear(1),g.setClear(0),Zy(a.DEPTH_TEST),bt.setFunc(LessEqualDepth),Gy(!1),sv(CullFaceBack),Zy(a.CULL_FACE),Iy(NoBlending);function Zy(v0){Et[v0]!==!0&&(a.enable(v0),Et[v0]=!0)}function iv(v0){Et[v0]!==!1&&(a.disable(v0),Et[v0]=!1)}function zy(v0,N0){return It[v0]!==N0?(a.bindFramebuffer(v0,N0),It[v0]=N0,s&&(v0===a.DRAW_FRAMEBUFFER&&(It[a.FRAMEBUFFER]=N0),v0===a.FRAMEBUFFER&&(It[a.DRAW_FRAMEBUFFER]=N0)),!0):!1}function B0(v0,N0){let F0=er,sy=!1;if(v0){F0=zt.get(N0),F0===void 0&&(F0=[],zt.set(N0,F0));const xy=v0.textures;if(F0.length!==xy.length||F0[0]!==a.COLOR_ATTACHMENT0){for(let ev=0,Sv=xy.length;ev<Sv;ev++)F0[ev]=a.COLOR_ATTACHMENT0+ev;F0.length=xy.length,sy=!0}}else F0[0]!==a.BACK&&(F0[0]=a.BACK,sy=!0);if(sy)if(o.isWebGL2)a.drawBuffers(F0);else if(e.has("WEBGL_draw_buffers")===!0)e.get("WEBGL_draw_buffers").drawBuffersWEBGL(F0);else throw new Error("THREE.WebGLState: Usage of gl.drawBuffers() require WebGL2 or WEBGL_draw_buffers extension")}function Ay(v0){return Hn!==v0?(a.useProgram(v0),Hn=v0,!0):!1}const hy={[AddEquation]:a.FUNC_ADD,[SubtractEquation]:a.FUNC_SUBTRACT,[ReverseSubtractEquation]:a.FUNC_REVERSE_SUBTRACT};if(s)hy[MinEquation]=a.MIN,hy[MaxEquation]=a.MAX;else{const v0=e.get("EXT_blend_minmax");v0!==null&&(hy[MinEquation]=v0.MIN_EXT,hy[MaxEquation]=v0.MAX_EXT)}const Ly={[ZeroFactor]:a.ZERO,[OneFactor]:a.ONE,[SrcColorFactor]:a.SRC_COLOR,[SrcAlphaFactor]:a.SRC_ALPHA,[SrcAlphaSaturateFactor]:a.SRC_ALPHA_SATURATE,[DstColorFactor]:a.DST_COLOR,[DstAlphaFactor]:a.DST_ALPHA,[OneMinusSrcColorFactor]:a.ONE_MINUS_SRC_COLOR,[OneMinusSrcAlphaFactor]:a.ONE_MINUS_SRC_ALPHA,[OneMinusDstColorFactor]:a.ONE_MINUS_DST_COLOR,[OneMinusDstAlphaFactor]:a.ONE_MINUS_DST_ALPHA,[ConstantColorFactor]:a.CONSTANT_COLOR,[OneMinusConstantColorFactor]:a.ONE_MINUS_CONSTANT_COLOR,[ConstantAlphaFactor]:a.CONSTANT_ALPHA,[OneMinusConstantAlphaFactor]:a.ONE_MINUS_CONSTANT_ALPHA};function Iy(v0,N0,F0,sy,xy,ev,Sv,kv,Vv,$v){if(v0===NoBlending){Qt===!0&&(iv(a.BLEND),Qt=!1);return}if(Qt===!1&&(Zy(a.BLEND),Qt=!0),v0!==CustomBlending){if(v0!==cr||$v!==f0){if((fr!==AddEquation||t0!==AddEquation)&&(a.blendEquation(a.FUNC_ADD),fr=AddEquation,t0=AddEquation),$v)switch(v0){case NormalBlending:a.blendFuncSeparate(a.ONE,a.ONE_MINUS_SRC_ALPHA,a.ONE,a.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:a.blendFunc(a.ONE,a.ONE);break;case SubtractiveBlending:a.blendFuncSeparate(a.ZERO,a.ONE_MINUS_SRC_COLOR,a.ZERO,a.ONE);break;case MultiplyBlending:a.blendFuncSeparate(a.ZERO,a.SRC_COLOR,a.ZERO,a.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",v0);break}else switch(v0){case NormalBlending:a.blendFuncSeparate(a.SRC_ALPHA,a.ONE_MINUS_SRC_ALPHA,a.ONE,a.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:a.blendFunc(a.SRC_ALPHA,a.ONE);break;case SubtractiveBlending:a.blendFuncSeparate(a.ZERO,a.ONE_MINUS_SRC_COLOR,a.ZERO,a.ONE);break;case MultiplyBlending:a.blendFunc(a.ZERO,a.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",v0);break}jr=null,e0=null,o0=null,l0=null,g0.set(0,0,0),i0=0,cr=v0,f0=$v}return}xy=xy||N0,ev=ev||F0,Sv=Sv||sy,(N0!==fr||xy!==t0)&&(a.blendEquationSeparate(hy[N0],hy[xy]),fr=N0,t0=xy),(F0!==jr||sy!==e0||ev!==o0||Sv!==l0)&&(a.blendFuncSeparate(Ly[F0],Ly[sy],Ly[ev],Ly[Sv]),jr=F0,e0=sy,o0=ev,l0=Sv),(kv.equals(g0)===!1||Vv!==i0)&&(a.blendColor(kv.r,kv.g,kv.b,Vv),g0.copy(kv),i0=Vv),cr=v0,f0=!1}function Jy(v0,N0){v0.side===DoubleSide?iv(a.CULL_FACE):Zy(a.CULL_FACE);let F0=v0.side===BackSide;N0&&(F0=!F0),Gy(F0),v0.blending===NormalBlending&&v0.transparent===!1?Iy(NoBlending):Iy(v0.blending,v0.blendEquation,v0.blendSrc,v0.blendDst,v0.blendEquationAlpha,v0.blendSrcAlpha,v0.blendDstAlpha,v0.blendColor,v0.blendAlpha,v0.premultipliedAlpha),bt.setFunc(v0.depthFunc),bt.setTest(v0.depthTest),bt.setMask(v0.depthWrite),_.setMask(v0.colorWrite);const sy=v0.stencilWrite;g.setTest(sy),sy&&(g.setMask(v0.stencilWriteMask),g.setFunc(v0.stencilFunc,v0.stencilRef,v0.stencilFuncMask),g.setOp(v0.stencilFail,v0.stencilZFail,v0.stencilZPass)),I0(v0.polygonOffset,v0.polygonOffsetFactor,v0.polygonOffsetUnits),v0.alphaToCoverage===!0?Zy(a.SAMPLE_ALPHA_TO_COVERAGE):iv(a.SAMPLE_ALPHA_TO_COVERAGE)}function Gy(v0){C0!==v0&&(v0?a.frontFace(a.CW):a.frontFace(a.CCW),C0=v0)}function sv(v0){v0!==CullFaceNone?(Zy(a.CULL_FACE),v0!==Z0&&(v0===CullFaceBack?a.cullFace(a.BACK):v0===CullFaceFront?a.cullFace(a.FRONT):a.cullFace(a.FRONT_AND_BACK))):iv(a.CULL_FACE),Z0=v0}function yv(v0){v0!==R0&&(w0&&a.lineWidth(v0),R0=v0)}function I0(v0,N0,F0){v0?(Zy(a.POLYGON_OFFSET_FILL),(Y0!==N0||H0!==F0)&&(a.polygonOffset(N0,F0),Y0=N0,H0=F0)):iv(a.POLYGON_OFFSET_FILL)}function b0(v0){v0?Zy(a.SCISSOR_TEST):iv(a.SCISSOR_TEST)}function uy(v0){v0===void 0&&(v0=a.TEXTURE0+ty-1),T0!==v0&&(a.activeTexture(v0),T0=v0)}function Ey(v0,N0,F0){F0===void 0&&(T0===null?F0=a.TEXTURE0+ty-1:F0=T0);let sy=q0[F0];sy===void 0&&(sy={type:void 0,texture:void 0},q0[F0]=sy),(sy.type!==v0||sy.texture!==N0)&&(T0!==F0&&(a.activeTexture(F0),T0=F0),a.bindTexture(v0,N0||Qy[v0]),sy.type=v0,sy.texture=N0)}function Dy(){const v0=q0[T0];v0!==void 0&&v0.type!==void 0&&(a.bindTexture(v0.type,null),v0.type=void 0,v0.texture=void 0)}function By(){try{a.compressedTexImage2D.apply(a,arguments)}catch(v0){console.error("THREE.WebGLState:",v0)}}function bv(){try{a.compressedTexImage3D.apply(a,arguments)}catch(v0){console.error("THREE.WebGLState:",v0)}}function av(){try{a.texSubImage2D.apply(a,arguments)}catch(v0){console.error("THREE.WebGLState:",v0)}}function Wy(){try{a.texSubImage3D.apply(a,arguments)}catch(v0){console.error("THREE.WebGLState:",v0)}}function my(){try{a.compressedTexSubImage2D.apply(a,arguments)}catch(v0){console.error("THREE.WebGLState:",v0)}}function uv(){try{a.compressedTexSubImage3D.apply(a,arguments)}catch(v0){console.error("THREE.WebGLState:",v0)}}function Hy(){try{a.texStorage2D.apply(a,arguments)}catch(v0){console.error("THREE.WebGLState:",v0)}}function wv(){try{a.texStorage3D.apply(a,arguments)}catch(v0){console.error("THREE.WebGLState:",v0)}}function mv(){try{a.texImage2D.apply(a,arguments)}catch(v0){console.error("THREE.WebGLState:",v0)}}function cv(){try{a.texImage3D.apply(a,arguments)}catch(v0){console.error("THREE.WebGLState:",v0)}}function O0(v0){cy.equals(v0)===!1&&(a.scissor(v0.x,v0.y,v0.z,v0.w),cy.copy(v0))}function oy(v0){Ty.equals(v0)===!1&&(a.viewport(v0.x,v0.y,v0.z,v0.w),Ty.copy(v0))}function Py(v0,N0){let F0=b.get(N0);F0===void 0&&(F0=new WeakMap,b.set(N0,F0));let sy=F0.get(v0);sy===void 0&&(sy=a.getUniformBlockIndex(N0,v0.name),F0.set(v0,sy))}function nv(v0,N0){const sy=b.get(N0).get(v0);j.get(N0)!==sy&&(a.uniformBlockBinding(N0,sy,v0.__bindingPointIndex),j.set(N0,sy))}function d0(){a.disable(a.BLEND),a.disable(a.CULL_FACE),a.disable(a.DEPTH_TEST),a.disable(a.POLYGON_OFFSET_FILL),a.disable(a.SCISSOR_TEST),a.disable(a.STENCIL_TEST),a.disable(a.SAMPLE_ALPHA_TO_COVERAGE),a.blendEquation(a.FUNC_ADD),a.blendFunc(a.ONE,a.ZERO),a.blendFuncSeparate(a.ONE,a.ZERO,a.ONE,a.ZERO),a.blendColor(0,0,0,0),a.colorMask(!0,!0,!0,!0),a.clearColor(0,0,0,0),a.depthMask(!0),a.depthFunc(a.LESS),a.clearDepth(1),a.stencilMask(4294967295),a.stencilFunc(a.ALWAYS,0,4294967295),a.stencilOp(a.KEEP,a.KEEP,a.KEEP),a.clearStencil(0),a.cullFace(a.BACK),a.frontFace(a.CCW),a.polygonOffset(0,0),a.activeTexture(a.TEXTURE0),a.bindFramebuffer(a.FRAMEBUFFER,null),s===!0&&(a.bindFramebuffer(a.DRAW_FRAMEBUFFER,null),a.bindFramebuffer(a.READ_FRAMEBUFFER,null)),a.useProgram(null),a.lineWidth(1),a.scissor(0,0,a.canvas.width,a.canvas.height),a.viewport(0,0,a.canvas.width,a.canvas.height),Et={},T0=null,q0={},It={},zt=new WeakMap,er=[],Hn=null,Qt=!1,cr=null,fr=null,jr=null,e0=null,t0=null,o0=null,l0=null,g0=new Color(0,0,0),i0=0,f0=!1,C0=null,Z0=null,R0=null,Y0=null,H0=null,cy.set(0,0,a.canvas.width,a.canvas.height),Ty.set(0,0,a.canvas.width,a.canvas.height),_.reset(),bt.reset(),g.reset()}return{buffers:{color:_,depth:bt,stencil:g},enable:Zy,disable:iv,bindFramebuffer:zy,drawBuffers:B0,useProgram:Ay,setBlending:Iy,setMaterial:Jy,setFlipSided:Gy,setCullFace:sv,setLineWidth:yv,setPolygonOffset:I0,setScissorTest:b0,activeTexture:uy,bindTexture:Ey,unbindTexture:Dy,compressedTexImage2D:By,compressedTexImage3D:bv,texImage2D:mv,texImage3D:cv,updateUBOMapping:Py,uniformBlockBinding:nv,texStorage2D:Hy,texStorage3D:wv,texSubImage2D:av,texSubImage3D:Wy,compressedTexSubImage2D:my,compressedTexSubImage3D:uv,scissor:O0,viewport:oy,reset:d0}}function WebGLTextures(a,e,o,s,d,c,h){const _=d.isWebGL2,bt=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,g=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),j=new Vector2,b=new WeakMap;let Et;const It=new WeakMap;let zt=!1;try{zt=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function er(I0,b0){return zt?new OffscreenCanvas(I0,b0):createElementNS("canvas")}function Hn(I0,b0,uy,Ey){let Dy=1;const By=yv(I0);if((By.width>Ey||By.height>Ey)&&(Dy=Ey/Math.max(By.width,By.height)),Dy<1||b0===!0)if(typeof HTMLImageElement<"u"&&I0 instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&I0 instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&I0 instanceof ImageBitmap||typeof VideoFrame<"u"&&I0 instanceof VideoFrame){const bv=b0?floorPowerOfTwo:Math.floor,av=bv(Dy*By.width),Wy=bv(Dy*By.height);Et===void 0&&(Et=er(av,Wy));const my=uy?er(av,Wy):Et;return my.width=av,my.height=Wy,my.getContext("2d").drawImage(I0,0,0,av,Wy),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+By.width+"x"+By.height+") to ("+av+"x"+Wy+")."),my}else return"data"in I0&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+By.width+"x"+By.height+")."),I0;return I0}function Qt(I0){const b0=yv(I0);return isPowerOfTwo(b0.width)&&isPowerOfTwo(b0.height)}function cr(I0){return _?!1:I0.wrapS!==ClampToEdgeWrapping||I0.wrapT!==ClampToEdgeWrapping||I0.minFilter!==NearestFilter&&I0.minFilter!==LinearFilter}function fr(I0,b0){return I0.generateMipmaps&&b0&&I0.minFilter!==NearestFilter&&I0.minFilter!==LinearFilter}function jr(I0){a.generateMipmap(I0)}function e0(I0,b0,uy,Ey,Dy=!1){if(_===!1)return b0;if(I0!==null){if(a[I0]!==void 0)return a[I0];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+I0+"'")}let By=b0;if(b0===a.RED&&(uy===a.FLOAT&&(By=a.R32F),uy===a.HALF_FLOAT&&(By=a.R16F),uy===a.UNSIGNED_BYTE&&(By=a.R8)),b0===a.RED_INTEGER&&(uy===a.UNSIGNED_BYTE&&(By=a.R8UI),uy===a.UNSIGNED_SHORT&&(By=a.R16UI),uy===a.UNSIGNED_INT&&(By=a.R32UI),uy===a.BYTE&&(By=a.R8I),uy===a.SHORT&&(By=a.R16I),uy===a.INT&&(By=a.R32I)),b0===a.RG&&(uy===a.FLOAT&&(By=a.RG32F),uy===a.HALF_FLOAT&&(By=a.RG16F),uy===a.UNSIGNED_BYTE&&(By=a.RG8)),b0===a.RG_INTEGER&&(uy===a.UNSIGNED_BYTE&&(By=a.RG8UI),uy===a.UNSIGNED_SHORT&&(By=a.RG16UI),uy===a.UNSIGNED_INT&&(By=a.RG32UI),uy===a.BYTE&&(By=a.RG8I),uy===a.SHORT&&(By=a.RG16I),uy===a.INT&&(By=a.RG32I)),b0===a.RGBA){const bv=Dy?LinearTransfer:ColorManagement.getTransfer(Ey);uy===a.FLOAT&&(By=a.RGBA32F),uy===a.HALF_FLOAT&&(By=a.RGBA16F),uy===a.UNSIGNED_BYTE&&(By=bv===SRGBTransfer?a.SRGB8_ALPHA8:a.RGBA8),uy===a.UNSIGNED_SHORT_4_4_4_4&&(By=a.RGBA4),uy===a.UNSIGNED_SHORT_5_5_5_1&&(By=a.RGB5_A1)}return(By===a.R16F||By===a.R32F||By===a.RG16F||By===a.RG32F||By===a.RGBA16F||By===a.RGBA32F)&&e.get("EXT_color_buffer_float"),By}function t0(I0,b0,uy){return fr(I0,uy)===!0||I0.isFramebufferTexture&&I0.minFilter!==NearestFilter&&I0.minFilter!==LinearFilter?Math.log2(Math.max(b0.width,b0.height))+1:I0.mipmaps!==void 0&&I0.mipmaps.length>0?I0.mipmaps.length:I0.isCompressedTexture&&Array.isArray(I0.image)?b0.mipmaps.length:1}function o0(I0){return I0===NearestFilter||I0===NearestMipmapNearestFilter||I0===NearestMipmapLinearFilter?a.NEAREST:a.LINEAR}function l0(I0){const b0=I0.target;b0.removeEventListener("dispose",l0),i0(b0),b0.isVideoTexture&&b.delete(b0)}function g0(I0){const b0=I0.target;b0.removeEventListener("dispose",g0),C0(b0)}function i0(I0){const b0=s.get(I0);if(b0.__webglInit===void 0)return;const uy=I0.source,Ey=It.get(uy);if(Ey){const Dy=Ey[b0.__cacheKey];Dy.usedTimes--,Dy.usedTimes===0&&f0(I0),Object.keys(Ey).length===0&&It.delete(uy)}s.remove(I0)}function f0(I0){const b0=s.get(I0);a.deleteTexture(b0.__webglTexture);const uy=I0.source,Ey=It.get(uy);delete Ey[b0.__cacheKey],h.memory.textures--}function C0(I0){const b0=s.get(I0);if(I0.depthTexture&&I0.depthTexture.dispose(),I0.isWebGLCubeRenderTarget)for(let Ey=0;Ey<6;Ey++){if(Array.isArray(b0.__webglFramebuffer[Ey]))for(let Dy=0;Dy<b0.__webglFramebuffer[Ey].length;Dy++)a.deleteFramebuffer(b0.__webglFramebuffer[Ey][Dy]);else a.deleteFramebuffer(b0.__webglFramebuffer[Ey]);b0.__webglDepthbuffer&&a.deleteRenderbuffer(b0.__webglDepthbuffer[Ey])}else{if(Array.isArray(b0.__webglFramebuffer))for(let Ey=0;Ey<b0.__webglFramebuffer.length;Ey++)a.deleteFramebuffer(b0.__webglFramebuffer[Ey]);else a.deleteFramebuffer(b0.__webglFramebuffer);if(b0.__webglDepthbuffer&&a.deleteRenderbuffer(b0.__webglDepthbuffer),b0.__webglMultisampledFramebuffer&&a.deleteFramebuffer(b0.__webglMultisampledFramebuffer),b0.__webglColorRenderbuffer)for(let Ey=0;Ey<b0.__webglColorRenderbuffer.length;Ey++)b0.__webglColorRenderbuffer[Ey]&&a.deleteRenderbuffer(b0.__webglColorRenderbuffer[Ey]);b0.__webglDepthRenderbuffer&&a.deleteRenderbuffer(b0.__webglDepthRenderbuffer)}const uy=I0.textures;for(let Ey=0,Dy=uy.length;Ey<Dy;Ey++){const By=s.get(uy[Ey]);By.__webglTexture&&(a.deleteTexture(By.__webglTexture),h.memory.textures--),s.remove(uy[Ey])}s.remove(I0)}let Z0=0;function R0(){Z0=0}function Y0(){const I0=Z0;return I0>=d.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+I0+" texture units while this GPU supports only "+d.maxTextures),Z0+=1,I0}function H0(I0){const b0=[];return b0.push(I0.wrapS),b0.push(I0.wrapT),b0.push(I0.wrapR||0),b0.push(I0.magFilter),b0.push(I0.minFilter),b0.push(I0.anisotropy),b0.push(I0.internalFormat),b0.push(I0.format),b0.push(I0.type),b0.push(I0.generateMipmaps),b0.push(I0.premultiplyAlpha),b0.push(I0.flipY),b0.push(I0.unpackAlignment),b0.push(I0.colorSpace),b0.join()}function ty(I0,b0){const uy=s.get(I0);if(I0.isVideoTexture&&Gy(I0),I0.isRenderTargetTexture===!1&&I0.version>0&&uy.__version!==I0.version){const Ey=I0.image;if(Ey===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Ey.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Ty(uy,I0,b0);return}}o.bindTexture(a.TEXTURE_2D,uy.__webglTexture,a.TEXTURE0+b0)}function w0(I0,b0){const uy=s.get(I0);if(I0.version>0&&uy.__version!==I0.version){Ty(uy,I0,b0);return}o.bindTexture(a.TEXTURE_2D_ARRAY,uy.__webglTexture,a.TEXTURE0+b0)}function L0(I0,b0){const uy=s.get(I0);if(I0.version>0&&uy.__version!==I0.version){Ty(uy,I0,b0);return}o.bindTexture(a.TEXTURE_3D,uy.__webglTexture,a.TEXTURE0+b0)}function k0(I0,b0){const uy=s.get(I0);if(I0.version>0&&uy.__version!==I0.version){Uy(uy,I0,b0);return}o.bindTexture(a.TEXTURE_CUBE_MAP,uy.__webglTexture,a.TEXTURE0+b0)}const T0={[RepeatWrapping]:a.REPEAT,[ClampToEdgeWrapping]:a.CLAMP_TO_EDGE,[MirroredRepeatWrapping]:a.MIRRORED_REPEAT},q0={[NearestFilter]:a.NEAREST,[NearestMipmapNearestFilter]:a.NEAREST_MIPMAP_NEAREST,[NearestMipmapLinearFilter]:a.NEAREST_MIPMAP_LINEAR,[LinearFilter]:a.LINEAR,[LinearMipmapNearestFilter]:a.LINEAR_MIPMAP_NEAREST,[LinearMipmapLinearFilter]:a.LINEAR_MIPMAP_LINEAR},vy={[NeverCompare]:a.NEVER,[AlwaysCompare]:a.ALWAYS,[LessCompare]:a.LESS,[LessEqualCompare]:a.LEQUAL,[EqualCompare]:a.EQUAL,[GreaterEqualCompare]:a.GEQUAL,[GreaterCompare]:a.GREATER,[NotEqualCompare]:a.NOTEQUAL};function J0(I0,b0,uy){if(b0.type===FloatType&&e.has("OES_texture_float_linear")===!1&&(b0.magFilter===LinearFilter||b0.magFilter===LinearMipmapNearestFilter||b0.magFilter===NearestMipmapLinearFilter||b0.magFilter===LinearMipmapLinearFilter||b0.minFilter===LinearFilter||b0.minFilter===LinearMipmapNearestFilter||b0.minFilter===NearestMipmapLinearFilter||b0.minFilter===LinearMipmapLinearFilter)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),uy?(a.texParameteri(I0,a.TEXTURE_WRAP_S,T0[b0.wrapS]),a.texParameteri(I0,a.TEXTURE_WRAP_T,T0[b0.wrapT]),(I0===a.TEXTURE_3D||I0===a.TEXTURE_2D_ARRAY)&&a.texParameteri(I0,a.TEXTURE_WRAP_R,T0[b0.wrapR]),a.texParameteri(I0,a.TEXTURE_MAG_FILTER,q0[b0.magFilter]),a.texParameteri(I0,a.TEXTURE_MIN_FILTER,q0[b0.minFilter])):(a.texParameteri(I0,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(I0,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),(I0===a.TEXTURE_3D||I0===a.TEXTURE_2D_ARRAY)&&a.texParameteri(I0,a.TEXTURE_WRAP_R,a.CLAMP_TO_EDGE),(b0.wrapS!==ClampToEdgeWrapping||b0.wrapT!==ClampToEdgeWrapping)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),a.texParameteri(I0,a.TEXTURE_MAG_FILTER,o0(b0.magFilter)),a.texParameteri(I0,a.TEXTURE_MIN_FILTER,o0(b0.minFilter)),b0.minFilter!==NearestFilter&&b0.minFilter!==LinearFilter&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),b0.compareFunction&&(a.texParameteri(I0,a.TEXTURE_COMPARE_MODE,a.COMPARE_REF_TO_TEXTURE),a.texParameteri(I0,a.TEXTURE_COMPARE_FUNC,vy[b0.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){if(b0.magFilter===NearestFilter||b0.minFilter!==NearestMipmapLinearFilter&&b0.minFilter!==LinearMipmapLinearFilter||b0.type===FloatType&&e.has("OES_texture_float_linear")===!1||_===!1&&b0.type===HalfFloatType&&e.has("OES_texture_half_float_linear")===!1)return;if(b0.anisotropy>1||s.get(b0).__currentAnisotropy){const Ey=e.get("EXT_texture_filter_anisotropic");a.texParameterf(I0,Ey.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(b0.anisotropy,d.getMaxAnisotropy())),s.get(b0).__currentAnisotropy=b0.anisotropy}}}function cy(I0,b0){let uy=!1;I0.__webglInit===void 0&&(I0.__webglInit=!0,b0.addEventListener("dispose",l0));const Ey=b0.source;let Dy=It.get(Ey);Dy===void 0&&(Dy={},It.set(Ey,Dy));const By=H0(b0);if(By!==I0.__cacheKey){Dy[By]===void 0&&(Dy[By]={texture:a.createTexture(),usedTimes:0},h.memory.textures++,uy=!0),Dy[By].usedTimes++;const bv=Dy[I0.__cacheKey];bv!==void 0&&(Dy[I0.__cacheKey].usedTimes--,bv.usedTimes===0&&f0(b0)),I0.__cacheKey=By,I0.__webglTexture=Dy[By].texture}return uy}function Ty(I0,b0,uy){let Ey=a.TEXTURE_2D;(b0.isDataArrayTexture||b0.isCompressedArrayTexture)&&(Ey=a.TEXTURE_2D_ARRAY),b0.isData3DTexture&&(Ey=a.TEXTURE_3D);const Dy=cy(I0,b0),By=b0.source;o.bindTexture(Ey,I0.__webglTexture,a.TEXTURE0+uy);const bv=s.get(By);if(By.version!==bv.__version||Dy===!0){o.activeTexture(a.TEXTURE0+uy);const av=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),Wy=b0.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(b0.colorSpace),my=b0.colorSpace===NoColorSpace||av===Wy?a.NONE:a.BROWSER_DEFAULT_WEBGL;a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,b0.flipY),a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,b0.premultiplyAlpha),a.pixelStorei(a.UNPACK_ALIGNMENT,b0.unpackAlignment),a.pixelStorei(a.UNPACK_COLORSPACE_CONVERSION_WEBGL,my);const uv=cr(b0)&&Qt(b0.image)===!1;let Hy=Hn(b0.image,uv,!1,d.maxTextureSize);Hy=sv(b0,Hy);const wv=Qt(Hy)||_,mv=c.convert(b0.format,b0.colorSpace);let cv=c.convert(b0.type),O0=e0(b0.internalFormat,mv,cv,b0.colorSpace,b0.isVideoTexture);J0(Ey,b0,wv);let oy;const Py=b0.mipmaps,nv=_&&b0.isVideoTexture!==!0&&O0!==RGB_ETC1_Format,d0=bv.__version===void 0||Dy===!0,v0=By.dataReady,N0=t0(b0,Hy,wv);if(b0.isDepthTexture)O0=a.DEPTH_COMPONENT,_?b0.type===FloatType?O0=a.DEPTH_COMPONENT32F:b0.type===UnsignedIntType?O0=a.DEPTH_COMPONENT24:b0.type===UnsignedInt248Type?O0=a.DEPTH24_STENCIL8:O0=a.DEPTH_COMPONENT16:b0.type===FloatType&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),b0.format===DepthFormat&&O0===a.DEPTH_COMPONENT&&b0.type!==UnsignedShortType&&b0.type!==UnsignedIntType&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),b0.type=UnsignedIntType,cv=c.convert(b0.type)),b0.format===DepthStencilFormat&&O0===a.DEPTH_COMPONENT&&(O0=a.DEPTH_STENCIL,b0.type!==UnsignedInt248Type&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),b0.type=UnsignedInt248Type,cv=c.convert(b0.type))),d0&&(nv?o.texStorage2D(a.TEXTURE_2D,1,O0,Hy.width,Hy.height):o.texImage2D(a.TEXTURE_2D,0,O0,Hy.width,Hy.height,0,mv,cv,null));else if(b0.isDataTexture)if(Py.length>0&&wv){nv&&d0&&o.texStorage2D(a.TEXTURE_2D,N0,O0,Py[0].width,Py[0].height);for(let F0=0,sy=Py.length;F0<sy;F0++)oy=Py[F0],nv?v0&&o.texSubImage2D(a.TEXTURE_2D,F0,0,0,oy.width,oy.height,mv,cv,oy.data):o.texImage2D(a.TEXTURE_2D,F0,O0,oy.width,oy.height,0,mv,cv,oy.data);b0.generateMipmaps=!1}else nv?(d0&&o.texStorage2D(a.TEXTURE_2D,N0,O0,Hy.width,Hy.height),v0&&o.texSubImage2D(a.TEXTURE_2D,0,0,0,Hy.width,Hy.height,mv,cv,Hy.data)):o.texImage2D(a.TEXTURE_2D,0,O0,Hy.width,Hy.height,0,mv,cv,Hy.data);else if(b0.isCompressedTexture)if(b0.isCompressedArrayTexture){nv&&d0&&o.texStorage3D(a.TEXTURE_2D_ARRAY,N0,O0,Py[0].width,Py[0].height,Hy.depth);for(let F0=0,sy=Py.length;F0<sy;F0++)oy=Py[F0],b0.format!==RGBAFormat?mv!==null?nv?v0&&o.compressedTexSubImage3D(a.TEXTURE_2D_ARRAY,F0,0,0,0,oy.width,oy.height,Hy.depth,mv,oy.data,0,0):o.compressedTexImage3D(a.TEXTURE_2D_ARRAY,F0,O0,oy.width,oy.height,Hy.depth,0,oy.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):nv?v0&&o.texSubImage3D(a.TEXTURE_2D_ARRAY,F0,0,0,0,oy.width,oy.height,Hy.depth,mv,cv,oy.data):o.texImage3D(a.TEXTURE_2D_ARRAY,F0,O0,oy.width,oy.height,Hy.depth,0,mv,cv,oy.data)}else{nv&&d0&&o.texStorage2D(a.TEXTURE_2D,N0,O0,Py[0].width,Py[0].height);for(let F0=0,sy=Py.length;F0<sy;F0++)oy=Py[F0],b0.format!==RGBAFormat?mv!==null?nv?v0&&o.compressedTexSubImage2D(a.TEXTURE_2D,F0,0,0,oy.width,oy.height,mv,oy.data):o.compressedTexImage2D(a.TEXTURE_2D,F0,O0,oy.width,oy.height,0,oy.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):nv?v0&&o.texSubImage2D(a.TEXTURE_2D,F0,0,0,oy.width,oy.height,mv,cv,oy.data):o.texImage2D(a.TEXTURE_2D,F0,O0,oy.width,oy.height,0,mv,cv,oy.data)}else if(b0.isDataArrayTexture)nv?(d0&&o.texStorage3D(a.TEXTURE_2D_ARRAY,N0,O0,Hy.width,Hy.height,Hy.depth),v0&&o.texSubImage3D(a.TEXTURE_2D_ARRAY,0,0,0,0,Hy.width,Hy.height,Hy.depth,mv,cv,Hy.data)):o.texImage3D(a.TEXTURE_2D_ARRAY,0,O0,Hy.width,Hy.height,Hy.depth,0,mv,cv,Hy.data);else if(b0.isData3DTexture)nv?(d0&&o.texStorage3D(a.TEXTURE_3D,N0,O0,Hy.width,Hy.height,Hy.depth),v0&&o.texSubImage3D(a.TEXTURE_3D,0,0,0,0,Hy.width,Hy.height,Hy.depth,mv,cv,Hy.data)):o.texImage3D(a.TEXTURE_3D,0,O0,Hy.width,Hy.height,Hy.depth,0,mv,cv,Hy.data);else if(b0.isFramebufferTexture){if(d0)if(nv)o.texStorage2D(a.TEXTURE_2D,N0,O0,Hy.width,Hy.height);else{let F0=Hy.width,sy=Hy.height;for(let xy=0;xy<N0;xy++)o.texImage2D(a.TEXTURE_2D,xy,O0,F0,sy,0,mv,cv,null),F0>>=1,sy>>=1}}else if(Py.length>0&&wv){if(nv&&d0){const F0=yv(Py[0]);o.texStorage2D(a.TEXTURE_2D,N0,O0,F0.width,F0.height)}for(let F0=0,sy=Py.length;F0<sy;F0++)oy=Py[F0],nv?v0&&o.texSubImage2D(a.TEXTURE_2D,F0,0,0,mv,cv,oy):o.texImage2D(a.TEXTURE_2D,F0,O0,mv,cv,oy);b0.generateMipmaps=!1}else if(nv){if(d0){const F0=yv(Hy);o.texStorage2D(a.TEXTURE_2D,N0,O0,F0.width,F0.height)}v0&&o.texSubImage2D(a.TEXTURE_2D,0,0,0,mv,cv,Hy)}else o.texImage2D(a.TEXTURE_2D,0,O0,mv,cv,Hy);fr(b0,wv)&&jr(Ey),bv.__version=By.version,b0.onUpdate&&b0.onUpdate(b0)}I0.__version=b0.version}function Uy(I0,b0,uy){if(b0.image.length!==6)return;const Ey=cy(I0,b0),Dy=b0.source;o.bindTexture(a.TEXTURE_CUBE_MAP,I0.__webglTexture,a.TEXTURE0+uy);const By=s.get(Dy);if(Dy.version!==By.__version||Ey===!0){o.activeTexture(a.TEXTURE0+uy);const bv=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),av=b0.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(b0.colorSpace),Wy=b0.colorSpace===NoColorSpace||bv===av?a.NONE:a.BROWSER_DEFAULT_WEBGL;a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,b0.flipY),a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,b0.premultiplyAlpha),a.pixelStorei(a.UNPACK_ALIGNMENT,b0.unpackAlignment),a.pixelStorei(a.UNPACK_COLORSPACE_CONVERSION_WEBGL,Wy);const my=b0.isCompressedTexture||b0.image[0].isCompressedTexture,uv=b0.image[0]&&b0.image[0].isDataTexture,Hy=[];for(let F0=0;F0<6;F0++)!my&&!uv?Hy[F0]=Hn(b0.image[F0],!1,!0,d.maxCubemapSize):Hy[F0]=uv?b0.image[F0].image:b0.image[F0],Hy[F0]=sv(b0,Hy[F0]);const wv=Hy[0],mv=Qt(wv)||_,cv=c.convert(b0.format,b0.colorSpace),O0=c.convert(b0.type),oy=e0(b0.internalFormat,cv,O0,b0.colorSpace),Py=_&&b0.isVideoTexture!==!0,nv=By.__version===void 0||Ey===!0,d0=Dy.dataReady;let v0=t0(b0,wv,mv);J0(a.TEXTURE_CUBE_MAP,b0,mv);let N0;if(my){Py&&nv&&o.texStorage2D(a.TEXTURE_CUBE_MAP,v0,oy,wv.width,wv.height);for(let F0=0;F0<6;F0++){N0=Hy[F0].mipmaps;for(let sy=0;sy<N0.length;sy++){const xy=N0[sy];b0.format!==RGBAFormat?cv!==null?Py?d0&&o.compressedTexSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+F0,sy,0,0,xy.width,xy.height,cv,xy.data):o.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+F0,sy,oy,xy.width,xy.height,0,xy.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Py?d0&&o.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+F0,sy,0,0,xy.width,xy.height,cv,O0,xy.data):o.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+F0,sy,oy,xy.width,xy.height,0,cv,O0,xy.data)}}}else{if(N0=b0.mipmaps,Py&&nv){N0.length>0&&v0++;const F0=yv(Hy[0]);o.texStorage2D(a.TEXTURE_CUBE_MAP,v0,oy,F0.width,F0.height)}for(let F0=0;F0<6;F0++)if(uv){Py?d0&&o.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+F0,0,0,0,Hy[F0].width,Hy[F0].height,cv,O0,Hy[F0].data):o.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+F0,0,oy,Hy[F0].width,Hy[F0].height,0,cv,O0,Hy[F0].data);for(let sy=0;sy<N0.length;sy++){const ev=N0[sy].image[F0].image;Py?d0&&o.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+F0,sy+1,0,0,ev.width,ev.height,cv,O0,ev.data):o.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+F0,sy+1,oy,ev.width,ev.height,0,cv,O0,ev.data)}}else{Py?d0&&o.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+F0,0,0,0,cv,O0,Hy[F0]):o.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+F0,0,oy,cv,O0,Hy[F0]);for(let sy=0;sy<N0.length;sy++){const xy=N0[sy];Py?d0&&o.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+F0,sy+1,0,0,cv,O0,xy.image[F0]):o.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+F0,sy+1,oy,cv,O0,xy.image[F0])}}}fr(b0,mv)&&jr(a.TEXTURE_CUBE_MAP),By.__version=Dy.version,b0.onUpdate&&b0.onUpdate(b0)}I0.__version=b0.version}function Qy(I0,b0,uy,Ey,Dy,By){const bv=c.convert(uy.format,uy.colorSpace),av=c.convert(uy.type),Wy=e0(uy.internalFormat,bv,av,uy.colorSpace);if(!s.get(b0).__hasExternalTextures){const uv=Math.max(1,b0.width>>By),Hy=Math.max(1,b0.height>>By);Dy===a.TEXTURE_3D||Dy===a.TEXTURE_2D_ARRAY?o.texImage3D(Dy,By,Wy,uv,Hy,b0.depth,0,bv,av,null):o.texImage2D(Dy,By,Wy,uv,Hy,0,bv,av,null)}o.bindFramebuffer(a.FRAMEBUFFER,I0),Jy(b0)?bt.framebufferTexture2DMultisampleEXT(a.FRAMEBUFFER,Ey,Dy,s.get(uy).__webglTexture,0,Iy(b0)):(Dy===a.TEXTURE_2D||Dy>=a.TEXTURE_CUBE_MAP_POSITIVE_X&&Dy<=a.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&a.framebufferTexture2D(a.FRAMEBUFFER,Ey,Dy,s.get(uy).__webglTexture,By),o.bindFramebuffer(a.FRAMEBUFFER,null)}function Zy(I0,b0,uy){if(a.bindRenderbuffer(a.RENDERBUFFER,I0),b0.depthBuffer&&!b0.stencilBuffer){let Ey=_===!0?a.DEPTH_COMPONENT24:a.DEPTH_COMPONENT16;if(uy||Jy(b0)){const Dy=b0.depthTexture;Dy&&Dy.isDepthTexture&&(Dy.type===FloatType?Ey=a.DEPTH_COMPONENT32F:Dy.type===UnsignedIntType&&(Ey=a.DEPTH_COMPONENT24));const By=Iy(b0);Jy(b0)?bt.renderbufferStorageMultisampleEXT(a.RENDERBUFFER,By,Ey,b0.width,b0.height):a.renderbufferStorageMultisample(a.RENDERBUFFER,By,Ey,b0.width,b0.height)}else a.renderbufferStorage(a.RENDERBUFFER,Ey,b0.width,b0.height);a.framebufferRenderbuffer(a.FRAMEBUFFER,a.DEPTH_ATTACHMENT,a.RENDERBUFFER,I0)}else if(b0.depthBuffer&&b0.stencilBuffer){const Ey=Iy(b0);uy&&Jy(b0)===!1?a.renderbufferStorageMultisample(a.RENDERBUFFER,Ey,a.DEPTH24_STENCIL8,b0.width,b0.height):Jy(b0)?bt.renderbufferStorageMultisampleEXT(a.RENDERBUFFER,Ey,a.DEPTH24_STENCIL8,b0.width,b0.height):a.renderbufferStorage(a.RENDERBUFFER,a.DEPTH_STENCIL,b0.width,b0.height),a.framebufferRenderbuffer(a.FRAMEBUFFER,a.DEPTH_STENCIL_ATTACHMENT,a.RENDERBUFFER,I0)}else{const Ey=b0.textures;for(let Dy=0;Dy<Ey.length;Dy++){const By=Ey[Dy],bv=c.convert(By.format,By.colorSpace),av=c.convert(By.type),Wy=e0(By.internalFormat,bv,av,By.colorSpace),my=Iy(b0);uy&&Jy(b0)===!1?a.renderbufferStorageMultisample(a.RENDERBUFFER,my,Wy,b0.width,b0.height):Jy(b0)?bt.renderbufferStorageMultisampleEXT(a.RENDERBUFFER,my,Wy,b0.width,b0.height):a.renderbufferStorage(a.RENDERBUFFER,Wy,b0.width,b0.height)}}a.bindRenderbuffer(a.RENDERBUFFER,null)}function iv(I0,b0){if(b0&&b0.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(o.bindFramebuffer(a.FRAMEBUFFER,I0),!(b0.depthTexture&&b0.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!s.get(b0.depthTexture).__webglTexture||b0.depthTexture.image.width!==b0.width||b0.depthTexture.image.height!==b0.height)&&(b0.depthTexture.image.width=b0.width,b0.depthTexture.image.height=b0.height,b0.depthTexture.needsUpdate=!0),ty(b0.depthTexture,0);const Ey=s.get(b0.depthTexture).__webglTexture,Dy=Iy(b0);if(b0.depthTexture.format===DepthFormat)Jy(b0)?bt.framebufferTexture2DMultisampleEXT(a.FRAMEBUFFER,a.DEPTH_ATTACHMENT,a.TEXTURE_2D,Ey,0,Dy):a.framebufferTexture2D(a.FRAMEBUFFER,a.DEPTH_ATTACHMENT,a.TEXTURE_2D,Ey,0);else if(b0.depthTexture.format===DepthStencilFormat)Jy(b0)?bt.framebufferTexture2DMultisampleEXT(a.FRAMEBUFFER,a.DEPTH_STENCIL_ATTACHMENT,a.TEXTURE_2D,Ey,0,Dy):a.framebufferTexture2D(a.FRAMEBUFFER,a.DEPTH_STENCIL_ATTACHMENT,a.TEXTURE_2D,Ey,0);else throw new Error("Unknown depthTexture format")}function zy(I0){const b0=s.get(I0),uy=I0.isWebGLCubeRenderTarget===!0;if(I0.depthTexture&&!b0.__autoAllocateDepthBuffer){if(uy)throw new Error("target.depthTexture not supported in Cube render targets");iv(b0.__webglFramebuffer,I0)}else if(uy){b0.__webglDepthbuffer=[];for(let Ey=0;Ey<6;Ey++)o.bindFramebuffer(a.FRAMEBUFFER,b0.__webglFramebuffer[Ey]),b0.__webglDepthbuffer[Ey]=a.createRenderbuffer(),Zy(b0.__webglDepthbuffer[Ey],I0,!1)}else o.bindFramebuffer(a.FRAMEBUFFER,b0.__webglFramebuffer),b0.__webglDepthbuffer=a.createRenderbuffer(),Zy(b0.__webglDepthbuffer,I0,!1);o.bindFramebuffer(a.FRAMEBUFFER,null)}function B0(I0,b0,uy){const Ey=s.get(I0);b0!==void 0&&Qy(Ey.__webglFramebuffer,I0,I0.texture,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,0),uy!==void 0&&zy(I0)}function Ay(I0){const b0=I0.texture,uy=s.get(I0),Ey=s.get(b0);I0.addEventListener("dispose",g0);const Dy=I0.textures,By=I0.isWebGLCubeRenderTarget===!0,bv=Dy.length>1,av=Qt(I0)||_;if(bv||(Ey.__webglTexture===void 0&&(Ey.__webglTexture=a.createTexture()),Ey.__version=b0.version,h.memory.textures++),By){uy.__webglFramebuffer=[];for(let Wy=0;Wy<6;Wy++)if(_&&b0.mipmaps&&b0.mipmaps.length>0){uy.__webglFramebuffer[Wy]=[];for(let my=0;my<b0.mipmaps.length;my++)uy.__webglFramebuffer[Wy][my]=a.createFramebuffer()}else uy.__webglFramebuffer[Wy]=a.createFramebuffer()}else{if(_&&b0.mipmaps&&b0.mipmaps.length>0){uy.__webglFramebuffer=[];for(let Wy=0;Wy<b0.mipmaps.length;Wy++)uy.__webglFramebuffer[Wy]=a.createFramebuffer()}else uy.__webglFramebuffer=a.createFramebuffer();if(bv)if(d.drawBuffers)for(let Wy=0,my=Dy.length;Wy<my;Wy++){const uv=s.get(Dy[Wy]);uv.__webglTexture===void 0&&(uv.__webglTexture=a.createTexture(),h.memory.textures++)}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(_&&I0.samples>0&&Jy(I0)===!1){uy.__webglMultisampledFramebuffer=a.createFramebuffer(),uy.__webglColorRenderbuffer=[],o.bindFramebuffer(a.FRAMEBUFFER,uy.__webglMultisampledFramebuffer);for(let Wy=0;Wy<Dy.length;Wy++){const my=Dy[Wy];uy.__webglColorRenderbuffer[Wy]=a.createRenderbuffer(),a.bindRenderbuffer(a.RENDERBUFFER,uy.__webglColorRenderbuffer[Wy]);const uv=c.convert(my.format,my.colorSpace),Hy=c.convert(my.type),wv=e0(my.internalFormat,uv,Hy,my.colorSpace,I0.isXRRenderTarget===!0),mv=Iy(I0);a.renderbufferStorageMultisample(a.RENDERBUFFER,mv,wv,I0.width,I0.height),a.framebufferRenderbuffer(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0+Wy,a.RENDERBUFFER,uy.__webglColorRenderbuffer[Wy])}a.bindRenderbuffer(a.RENDERBUFFER,null),I0.depthBuffer&&(uy.__webglDepthRenderbuffer=a.createRenderbuffer(),Zy(uy.__webglDepthRenderbuffer,I0,!0)),o.bindFramebuffer(a.FRAMEBUFFER,null)}}if(By){o.bindTexture(a.TEXTURE_CUBE_MAP,Ey.__webglTexture),J0(a.TEXTURE_CUBE_MAP,b0,av);for(let Wy=0;Wy<6;Wy++)if(_&&b0.mipmaps&&b0.mipmaps.length>0)for(let my=0;my<b0.mipmaps.length;my++)Qy(uy.__webglFramebuffer[Wy][my],I0,b0,a.COLOR_ATTACHMENT0,a.TEXTURE_CUBE_MAP_POSITIVE_X+Wy,my);else Qy(uy.__webglFramebuffer[Wy],I0,b0,a.COLOR_ATTACHMENT0,a.TEXTURE_CUBE_MAP_POSITIVE_X+Wy,0);fr(b0,av)&&jr(a.TEXTURE_CUBE_MAP),o.unbindTexture()}else if(bv){for(let Wy=0,my=Dy.length;Wy<my;Wy++){const uv=Dy[Wy],Hy=s.get(uv);o.bindTexture(a.TEXTURE_2D,Hy.__webglTexture),J0(a.TEXTURE_2D,uv,av),Qy(uy.__webglFramebuffer,I0,uv,a.COLOR_ATTACHMENT0+Wy,a.TEXTURE_2D,0),fr(uv,av)&&jr(a.TEXTURE_2D)}o.unbindTexture()}else{let Wy=a.TEXTURE_2D;if((I0.isWebGL3DRenderTarget||I0.isWebGLArrayRenderTarget)&&(_?Wy=I0.isWebGL3DRenderTarget?a.TEXTURE_3D:a.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),o.bindTexture(Wy,Ey.__webglTexture),J0(Wy,b0,av),_&&b0.mipmaps&&b0.mipmaps.length>0)for(let my=0;my<b0.mipmaps.length;my++)Qy(uy.__webglFramebuffer[my],I0,b0,a.COLOR_ATTACHMENT0,Wy,my);else Qy(uy.__webglFramebuffer,I0,b0,a.COLOR_ATTACHMENT0,Wy,0);fr(b0,av)&&jr(Wy),o.unbindTexture()}I0.depthBuffer&&zy(I0)}function hy(I0){const b0=Qt(I0)||_,uy=I0.textures;for(let Ey=0,Dy=uy.length;Ey<Dy;Ey++){const By=uy[Ey];if(fr(By,b0)){const bv=I0.isWebGLCubeRenderTarget?a.TEXTURE_CUBE_MAP:a.TEXTURE_2D,av=s.get(By).__webglTexture;o.bindTexture(bv,av),jr(bv),o.unbindTexture()}}}function Ly(I0){if(_&&I0.samples>0&&Jy(I0)===!1){const b0=I0.textures,uy=I0.width,Ey=I0.height;let Dy=a.COLOR_BUFFER_BIT;const By=[],bv=I0.stencilBuffer?a.DEPTH_STENCIL_ATTACHMENT:a.DEPTH_ATTACHMENT,av=s.get(I0),Wy=b0.length>1;if(Wy)for(let my=0;my<b0.length;my++)o.bindFramebuffer(a.FRAMEBUFFER,av.__webglMultisampledFramebuffer),a.framebufferRenderbuffer(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0+my,a.RENDERBUFFER,null),o.bindFramebuffer(a.FRAMEBUFFER,av.__webglFramebuffer),a.framebufferTexture2D(a.DRAW_FRAMEBUFFER,a.COLOR_ATTACHMENT0+my,a.TEXTURE_2D,null,0);o.bindFramebuffer(a.READ_FRAMEBUFFER,av.__webglMultisampledFramebuffer),o.bindFramebuffer(a.DRAW_FRAMEBUFFER,av.__webglFramebuffer);for(let my=0;my<b0.length;my++){By.push(a.COLOR_ATTACHMENT0+my),I0.depthBuffer&&By.push(bv);const uv=av.__ignoreDepthValues!==void 0?av.__ignoreDepthValues:!1;if(uv===!1&&(I0.depthBuffer&&(Dy|=a.DEPTH_BUFFER_BIT),I0.stencilBuffer&&(Dy|=a.STENCIL_BUFFER_BIT)),Wy&&a.framebufferRenderbuffer(a.READ_FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.RENDERBUFFER,av.__webglColorRenderbuffer[my]),uv===!0&&(a.invalidateFramebuffer(a.READ_FRAMEBUFFER,[bv]),a.invalidateFramebuffer(a.DRAW_FRAMEBUFFER,[bv])),Wy){const Hy=s.get(b0[my]).__webglTexture;a.framebufferTexture2D(a.DRAW_FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,Hy,0)}a.blitFramebuffer(0,0,uy,Ey,0,0,uy,Ey,Dy,a.NEAREST),g&&a.invalidateFramebuffer(a.READ_FRAMEBUFFER,By)}if(o.bindFramebuffer(a.READ_FRAMEBUFFER,null),o.bindFramebuffer(a.DRAW_FRAMEBUFFER,null),Wy)for(let my=0;my<b0.length;my++){o.bindFramebuffer(a.FRAMEBUFFER,av.__webglMultisampledFramebuffer),a.framebufferRenderbuffer(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0+my,a.RENDERBUFFER,av.__webglColorRenderbuffer[my]);const uv=s.get(b0[my]).__webglTexture;o.bindFramebuffer(a.FRAMEBUFFER,av.__webglFramebuffer),a.framebufferTexture2D(a.DRAW_FRAMEBUFFER,a.COLOR_ATTACHMENT0+my,a.TEXTURE_2D,uv,0)}o.bindFramebuffer(a.DRAW_FRAMEBUFFER,av.__webglMultisampledFramebuffer)}}function Iy(I0){return Math.min(d.maxSamples,I0.samples)}function Jy(I0){const b0=s.get(I0);return _&&I0.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&b0.__useRenderToTexture!==!1}function Gy(I0){const b0=h.render.frame;b.get(I0)!==b0&&(b.set(I0,b0),I0.update())}function sv(I0,b0){const uy=I0.colorSpace,Ey=I0.format,Dy=I0.type;return I0.isCompressedTexture===!0||I0.isVideoTexture===!0||I0.format===_SRGBAFormat||uy!==LinearSRGBColorSpace&&uy!==NoColorSpace&&(ColorManagement.getTransfer(uy)===SRGBTransfer?_===!1?e.has("EXT_sRGB")===!0&&Ey===RGBAFormat?(I0.format=_SRGBAFormat,I0.minFilter=LinearFilter,I0.generateMipmaps=!1):b0=ImageUtils.sRGBToLinear(b0):(Ey!==RGBAFormat||Dy!==UnsignedByteType)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",uy)),b0}function yv(I0){return typeof HTMLImageElement<"u"&&I0 instanceof HTMLImageElement?(j.width=I0.naturalWidth||I0.width,j.height=I0.naturalHeight||I0.height):typeof VideoFrame<"u"&&I0 instanceof VideoFrame?(j.width=I0.displayWidth,j.height=I0.displayHeight):(j.width=I0.width,j.height=I0.height),j}this.allocateTextureUnit=Y0,this.resetTextureUnits=R0,this.setTexture2D=ty,this.setTexture2DArray=w0,this.setTexture3D=L0,this.setTextureCube=k0,this.rebindTextures=B0,this.setupRenderTarget=Ay,this.updateRenderTargetMipmap=hy,this.updateMultisampleRenderTarget=Ly,this.setupDepthRenderbuffer=zy,this.setupFrameBufferTexture=Qy,this.useMultisampledRTT=Jy}function WebGLUtils(a,e,o){const s=o.isWebGL2;function d(c,h=NoColorSpace){let _;const bt=ColorManagement.getTransfer(h);if(c===UnsignedByteType)return a.UNSIGNED_BYTE;if(c===UnsignedShort4444Type)return a.UNSIGNED_SHORT_4_4_4_4;if(c===UnsignedShort5551Type)return a.UNSIGNED_SHORT_5_5_5_1;if(c===ByteType)return a.BYTE;if(c===ShortType)return a.SHORT;if(c===UnsignedShortType)return a.UNSIGNED_SHORT;if(c===IntType)return a.INT;if(c===UnsignedIntType)return a.UNSIGNED_INT;if(c===FloatType)return a.FLOAT;if(c===HalfFloatType)return s?a.HALF_FLOAT:(_=e.get("OES_texture_half_float"),_!==null?_.HALF_FLOAT_OES:null);if(c===AlphaFormat)return a.ALPHA;if(c===RGBAFormat)return a.RGBA;if(c===LuminanceFormat)return a.LUMINANCE;if(c===LuminanceAlphaFormat)return a.LUMINANCE_ALPHA;if(c===DepthFormat)return a.DEPTH_COMPONENT;if(c===DepthStencilFormat)return a.DEPTH_STENCIL;if(c===_SRGBAFormat)return _=e.get("EXT_sRGB"),_!==null?_.SRGB_ALPHA_EXT:null;if(c===RedFormat)return a.RED;if(c===RedIntegerFormat)return a.RED_INTEGER;if(c===RGFormat)return a.RG;if(c===RGIntegerFormat)return a.RG_INTEGER;if(c===RGBAIntegerFormat)return a.RGBA_INTEGER;if(c===RGB_S3TC_DXT1_Format||c===RGBA_S3TC_DXT1_Format||c===RGBA_S3TC_DXT3_Format||c===RGBA_S3TC_DXT5_Format)if(bt===SRGBTransfer)if(_=e.get("WEBGL_compressed_texture_s3tc_srgb"),_!==null){if(c===RGB_S3TC_DXT1_Format)return _.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(c===RGBA_S3TC_DXT1_Format)return _.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(c===RGBA_S3TC_DXT3_Format)return _.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(c===RGBA_S3TC_DXT5_Format)return _.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(_=e.get("WEBGL_compressed_texture_s3tc"),_!==null){if(c===RGB_S3TC_DXT1_Format)return _.COMPRESSED_RGB_S3TC_DXT1_EXT;if(c===RGBA_S3TC_DXT1_Format)return _.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(c===RGBA_S3TC_DXT3_Format)return _.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(c===RGBA_S3TC_DXT5_Format)return _.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(c===RGB_PVRTC_4BPPV1_Format||c===RGB_PVRTC_2BPPV1_Format||c===RGBA_PVRTC_4BPPV1_Format||c===RGBA_PVRTC_2BPPV1_Format)if(_=e.get("WEBGL_compressed_texture_pvrtc"),_!==null){if(c===RGB_PVRTC_4BPPV1_Format)return _.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(c===RGB_PVRTC_2BPPV1_Format)return _.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(c===RGBA_PVRTC_4BPPV1_Format)return _.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(c===RGBA_PVRTC_2BPPV1_Format)return _.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(c===RGB_ETC1_Format)return _=e.get("WEBGL_compressed_texture_etc1"),_!==null?_.COMPRESSED_RGB_ETC1_WEBGL:null;if(c===RGB_ETC2_Format||c===RGBA_ETC2_EAC_Format)if(_=e.get("WEBGL_compressed_texture_etc"),_!==null){if(c===RGB_ETC2_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ETC2:_.COMPRESSED_RGB8_ETC2;if(c===RGBA_ETC2_EAC_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:_.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(c===RGBA_ASTC_4x4_Format||c===RGBA_ASTC_5x4_Format||c===RGBA_ASTC_5x5_Format||c===RGBA_ASTC_6x5_Format||c===RGBA_ASTC_6x6_Format||c===RGBA_ASTC_8x5_Format||c===RGBA_ASTC_8x6_Format||c===RGBA_ASTC_8x8_Format||c===RGBA_ASTC_10x5_Format||c===RGBA_ASTC_10x6_Format||c===RGBA_ASTC_10x8_Format||c===RGBA_ASTC_10x10_Format||c===RGBA_ASTC_12x10_Format||c===RGBA_ASTC_12x12_Format)if(_=e.get("WEBGL_compressed_texture_astc"),_!==null){if(c===RGBA_ASTC_4x4_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:_.COMPRESSED_RGBA_ASTC_4x4_KHR;if(c===RGBA_ASTC_5x4_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:_.COMPRESSED_RGBA_ASTC_5x4_KHR;if(c===RGBA_ASTC_5x5_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:_.COMPRESSED_RGBA_ASTC_5x5_KHR;if(c===RGBA_ASTC_6x5_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:_.COMPRESSED_RGBA_ASTC_6x5_KHR;if(c===RGBA_ASTC_6x6_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:_.COMPRESSED_RGBA_ASTC_6x6_KHR;if(c===RGBA_ASTC_8x5_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:_.COMPRESSED_RGBA_ASTC_8x5_KHR;if(c===RGBA_ASTC_8x6_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:_.COMPRESSED_RGBA_ASTC_8x6_KHR;if(c===RGBA_ASTC_8x8_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:_.COMPRESSED_RGBA_ASTC_8x8_KHR;if(c===RGBA_ASTC_10x5_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:_.COMPRESSED_RGBA_ASTC_10x5_KHR;if(c===RGBA_ASTC_10x6_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:_.COMPRESSED_RGBA_ASTC_10x6_KHR;if(c===RGBA_ASTC_10x8_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:_.COMPRESSED_RGBA_ASTC_10x8_KHR;if(c===RGBA_ASTC_10x10_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:_.COMPRESSED_RGBA_ASTC_10x10_KHR;if(c===RGBA_ASTC_12x10_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:_.COMPRESSED_RGBA_ASTC_12x10_KHR;if(c===RGBA_ASTC_12x12_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:_.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(c===RGBA_BPTC_Format||c===RGB_BPTC_SIGNED_Format||c===RGB_BPTC_UNSIGNED_Format)if(_=e.get("EXT_texture_compression_bptc"),_!==null){if(c===RGBA_BPTC_Format)return bt===SRGBTransfer?_.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:_.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(c===RGB_BPTC_SIGNED_Format)return _.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(c===RGB_BPTC_UNSIGNED_Format)return _.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(c===RED_RGTC1_Format||c===SIGNED_RED_RGTC1_Format||c===RED_GREEN_RGTC2_Format||c===SIGNED_RED_GREEN_RGTC2_Format)if(_=e.get("EXT_texture_compression_rgtc"),_!==null){if(c===RGBA_BPTC_Format)return _.COMPRESSED_RED_RGTC1_EXT;if(c===SIGNED_RED_RGTC1_Format)return _.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(c===RED_GREEN_RGTC2_Format)return _.COMPRESSED_RED_GREEN_RGTC2_EXT;if(c===SIGNED_RED_GREEN_RGTC2_Format)return _.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return c===UnsignedInt248Type?s?a.UNSIGNED_INT_24_8:(_=e.get("WEBGL_depth_texture"),_!==null?_.UNSIGNED_INT_24_8_WEBGL:null):a[c]!==void 0?a[c]:null}return{convert:d}}class ArrayCamera extends PerspectiveCamera{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class Group extends Object3D{constructor(){super(),this.isGroup=!0,this.type="Group"}}const _moveEvent={type:"move"};class WebXRController{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Group,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Group,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Vector3,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Vector3),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Group,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Vector3,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Vector3),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const o=this._hand;if(o)for(const s of e.hand.values())this._getHandJoint(o,s)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,o,s){let d=null,c=null,h=null;const _=this._targetRay,bt=this._grip,g=this._hand;if(e&&o.session.visibilityState!=="visible-blurred"){if(g&&e.hand){h=!0;for(const er of e.hand.values()){const Hn=o.getJointPose(er,s),Qt=this._getHandJoint(g,er);Hn!==null&&(Qt.matrix.fromArray(Hn.transform.matrix),Qt.matrix.decompose(Qt.position,Qt.rotation,Qt.scale),Qt.matrixWorldNeedsUpdate=!0,Qt.jointRadius=Hn.radius),Qt.visible=Hn!==null}const j=g.joints["index-finger-tip"],b=g.joints["thumb-tip"],Et=j.position.distanceTo(b.position),It=.02,zt=.005;g.inputState.pinching&&Et>It+zt?(g.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!g.inputState.pinching&&Et<=It-zt&&(g.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else bt!==null&&e.gripSpace&&(c=o.getPose(e.gripSpace,s),c!==null&&(bt.matrix.fromArray(c.transform.matrix),bt.matrix.decompose(bt.position,bt.rotation,bt.scale),bt.matrixWorldNeedsUpdate=!0,c.linearVelocity?(bt.hasLinearVelocity=!0,bt.linearVelocity.copy(c.linearVelocity)):bt.hasLinearVelocity=!1,c.angularVelocity?(bt.hasAngularVelocity=!0,bt.angularVelocity.copy(c.angularVelocity)):bt.hasAngularVelocity=!1));_!==null&&(d=o.getPose(e.targetRaySpace,s),d===null&&c!==null&&(d=c),d!==null&&(_.matrix.fromArray(d.transform.matrix),_.matrix.decompose(_.position,_.rotation,_.scale),_.matrixWorldNeedsUpdate=!0,d.linearVelocity?(_.hasLinearVelocity=!0,_.linearVelocity.copy(d.linearVelocity)):_.hasLinearVelocity=!1,d.angularVelocity?(_.hasAngularVelocity=!0,_.angularVelocity.copy(d.angularVelocity)):_.hasAngularVelocity=!1,this.dispatchEvent(_moveEvent)))}return _!==null&&(_.visible=d!==null),bt!==null&&(bt.visible=c!==null),g!==null&&(g.visible=h!==null),this}_getHandJoint(e,o){if(e.joints[o.jointName]===void 0){const s=new Group;s.matrixAutoUpdate=!1,s.visible=!1,e.joints[o.jointName]=s,e.add(s)}return e.joints[o.jointName]}}const _occlusion_vertex=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,_occlusion_fragment=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class WebXRDepthSensing{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,o,s){if(this.texture===null){const d=new Texture,c=e.properties.get(d);c.__webglTexture=o.texture,(o.depthNear!=s.depthNear||o.depthFar!=s.depthFar)&&(this.depthNear=o.depthNear,this.depthFar=o.depthFar),this.texture=d}}render(e,o){if(this.texture!==null){if(this.mesh===null){const s=o.cameras[0].viewport,d=new ShaderMaterial({extensions:{fragDepth:!0},vertexShader:_occlusion_vertex,fragmentShader:_occlusion_fragment,uniforms:{depthColor:{value:this.texture},depthWidth:{value:s.z},depthHeight:{value:s.w}}});this.mesh=new Mesh(new PlaneGeometry(20,20),d)}e.render(this.mesh,o)}}reset(){this.texture=null,this.mesh=null}}class WebXRManager extends EventDispatcher{constructor(e,o){super();const s=this;let d=null,c=1,h=null,_="local-floor",bt=1,g=null,j=null,b=null,Et=null,It=null,zt=null;const er=new WebXRDepthSensing,Hn=o.getContextAttributes();let Qt=null,cr=null;const fr=[],jr=[],e0=new Vector2;let t0=null;const o0=new PerspectiveCamera;o0.layers.enable(1),o0.viewport=new Vector4;const l0=new PerspectiveCamera;l0.layers.enable(2),l0.viewport=new Vector4;const g0=[o0,l0],i0=new ArrayCamera;i0.layers.enable(1),i0.layers.enable(2);let f0=null,C0=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(J0){let cy=fr[J0];return cy===void 0&&(cy=new WebXRController,fr[J0]=cy),cy.getTargetRaySpace()},this.getControllerGrip=function(J0){let cy=fr[J0];return cy===void 0&&(cy=new WebXRController,fr[J0]=cy),cy.getGripSpace()},this.getHand=function(J0){let cy=fr[J0];return cy===void 0&&(cy=new WebXRController,fr[J0]=cy),cy.getHandSpace()};function Z0(J0){const cy=jr.indexOf(J0.inputSource);if(cy===-1)return;const Ty=fr[cy];Ty!==void 0&&(Ty.update(J0.inputSource,J0.frame,g||h),Ty.dispatchEvent({type:J0.type,data:J0.inputSource}))}function R0(){d.removeEventListener("select",Z0),d.removeEventListener("selectstart",Z0),d.removeEventListener("selectend",Z0),d.removeEventListener("squeeze",Z0),d.removeEventListener("squeezestart",Z0),d.removeEventListener("squeezeend",Z0),d.removeEventListener("end",R0),d.removeEventListener("inputsourceschange",Y0);for(let J0=0;J0<fr.length;J0++){const cy=jr[J0];cy!==null&&(jr[J0]=null,fr[J0].disconnect(cy))}f0=null,C0=null,er.reset(),e.setRenderTarget(Qt),It=null,Et=null,b=null,d=null,cr=null,vy.stop(),s.isPresenting=!1,e.setPixelRatio(t0),e.setSize(e0.width,e0.height,!1),s.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(J0){c=J0,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(J0){_=J0,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return g||h},this.setReferenceSpace=function(J0){g=J0},this.getBaseLayer=function(){return Et!==null?Et:It},this.getBinding=function(){return b},this.getFrame=function(){return zt},this.getSession=function(){return d},this.setSession=async function(J0){if(d=J0,d!==null){if(Qt=e.getRenderTarget(),d.addEventListener("select",Z0),d.addEventListener("selectstart",Z0),d.addEventListener("selectend",Z0),d.addEventListener("squeeze",Z0),d.addEventListener("squeezestart",Z0),d.addEventListener("squeezeend",Z0),d.addEventListener("end",R0),d.addEventListener("inputsourceschange",Y0),Hn.xrCompatible!==!0&&await o.makeXRCompatible(),t0=e.getPixelRatio(),e.getSize(e0),d.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const cy={antialias:d.renderState.layers===void 0?Hn.antialias:!0,alpha:!0,depth:Hn.depth,stencil:Hn.stencil,framebufferScaleFactor:c};It=new XRWebGLLayer(d,o,cy),d.updateRenderState({baseLayer:It}),e.setPixelRatio(1),e.setSize(It.framebufferWidth,It.framebufferHeight,!1),cr=new WebGLRenderTarget(It.framebufferWidth,It.framebufferHeight,{format:RGBAFormat,type:UnsignedByteType,colorSpace:e.outputColorSpace,stencilBuffer:Hn.stencil})}else{let cy=null,Ty=null,Uy=null;Hn.depth&&(Uy=Hn.stencil?o.DEPTH24_STENCIL8:o.DEPTH_COMPONENT24,cy=Hn.stencil?DepthStencilFormat:DepthFormat,Ty=Hn.stencil?UnsignedInt248Type:UnsignedIntType);const Qy={colorFormat:o.RGBA8,depthFormat:Uy,scaleFactor:c};b=new XRWebGLBinding(d,o),Et=b.createProjectionLayer(Qy),d.updateRenderState({layers:[Et]}),e.setPixelRatio(1),e.setSize(Et.textureWidth,Et.textureHeight,!1),cr=new WebGLRenderTarget(Et.textureWidth,Et.textureHeight,{format:RGBAFormat,type:UnsignedByteType,depthTexture:new DepthTexture(Et.textureWidth,Et.textureHeight,Ty,void 0,void 0,void 0,void 0,void 0,void 0,cy),stencilBuffer:Hn.stencil,colorSpace:e.outputColorSpace,samples:Hn.antialias?4:0});const Zy=e.properties.get(cr);Zy.__ignoreDepthValues=Et.ignoreDepthValues}cr.isXRRenderTarget=!0,this.setFoveation(bt),g=null,h=await d.requestReferenceSpace(_),vy.setContext(d),vy.start(),s.isPresenting=!0,s.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(d!==null)return d.environmentBlendMode};function Y0(J0){for(let cy=0;cy<J0.removed.length;cy++){const Ty=J0.removed[cy],Uy=jr.indexOf(Ty);Uy>=0&&(jr[Uy]=null,fr[Uy].disconnect(Ty))}for(let cy=0;cy<J0.added.length;cy++){const Ty=J0.added[cy];let Uy=jr.indexOf(Ty);if(Uy===-1){for(let Zy=0;Zy<fr.length;Zy++)if(Zy>=jr.length){jr.push(Ty),Uy=Zy;break}else if(jr[Zy]===null){jr[Zy]=Ty,Uy=Zy;break}if(Uy===-1)break}const Qy=fr[Uy];Qy&&Qy.connect(Ty)}}const H0=new Vector3,ty=new Vector3;function w0(J0,cy,Ty){H0.setFromMatrixPosition(cy.matrixWorld),ty.setFromMatrixPosition(Ty.matrixWorld);const Uy=H0.distanceTo(ty),Qy=cy.projectionMatrix.elements,Zy=Ty.projectionMatrix.elements,iv=Qy[14]/(Qy[10]-1),zy=Qy[14]/(Qy[10]+1),B0=(Qy[9]+1)/Qy[5],Ay=(Qy[9]-1)/Qy[5],hy=(Qy[8]-1)/Qy[0],Ly=(Zy[8]+1)/Zy[0],Iy=iv*hy,Jy=iv*Ly,Gy=Uy/(-hy+Ly),sv=Gy*-hy;cy.matrixWorld.decompose(J0.position,J0.quaternion,J0.scale),J0.translateX(sv),J0.translateZ(Gy),J0.matrixWorld.compose(J0.position,J0.quaternion,J0.scale),J0.matrixWorldInverse.copy(J0.matrixWorld).invert();const yv=iv+Gy,I0=zy+Gy,b0=Iy-sv,uy=Jy+(Uy-sv),Ey=B0*zy/I0*yv,Dy=Ay*zy/I0*yv;J0.projectionMatrix.makePerspective(b0,uy,Ey,Dy,yv,I0),J0.projectionMatrixInverse.copy(J0.projectionMatrix).invert()}function L0(J0,cy){cy===null?J0.matrixWorld.copy(J0.matrix):J0.matrixWorld.multiplyMatrices(cy.matrixWorld,J0.matrix),J0.matrixWorldInverse.copy(J0.matrixWorld).invert()}this.updateCamera=function(J0){if(d===null)return;er.texture!==null&&(J0.near=er.depthNear,J0.far=er.depthFar),i0.near=l0.near=o0.near=J0.near,i0.far=l0.far=o0.far=J0.far,(f0!==i0.near||C0!==i0.far)&&(d.updateRenderState({depthNear:i0.near,depthFar:i0.far}),f0=i0.near,C0=i0.far,o0.near=f0,o0.far=C0,l0.near=f0,l0.far=C0,o0.updateProjectionMatrix(),l0.updateProjectionMatrix(),J0.updateProjectionMatrix());const cy=J0.parent,Ty=i0.cameras;L0(i0,cy);for(let Uy=0;Uy<Ty.length;Uy++)L0(Ty[Uy],cy);Ty.length===2?w0(i0,o0,l0):i0.projectionMatrix.copy(o0.projectionMatrix),k0(J0,i0,cy)};function k0(J0,cy,Ty){Ty===null?J0.matrix.copy(cy.matrixWorld):(J0.matrix.copy(Ty.matrixWorld),J0.matrix.invert(),J0.matrix.multiply(cy.matrixWorld)),J0.matrix.decompose(J0.position,J0.quaternion,J0.scale),J0.updateMatrixWorld(!0),J0.projectionMatrix.copy(cy.projectionMatrix),J0.projectionMatrixInverse.copy(cy.projectionMatrixInverse),J0.isPerspectiveCamera&&(J0.fov=RAD2DEG*2*Math.atan(1/J0.projectionMatrix.elements[5]),J0.zoom=1)}this.getCamera=function(){return i0},this.getFoveation=function(){if(!(Et===null&&It===null))return bt},this.setFoveation=function(J0){bt=J0,Et!==null&&(Et.fixedFoveation=J0),It!==null&&It.fixedFoveation!==void 0&&(It.fixedFoveation=J0)},this.hasDepthSensing=function(){return er.texture!==null};let T0=null;function q0(J0,cy){if(j=cy.getViewerPose(g||h),zt=cy,j!==null){const Ty=j.views;It!==null&&(e.setRenderTargetFramebuffer(cr,It.framebuffer),e.setRenderTarget(cr));let Uy=!1;Ty.length!==i0.cameras.length&&(i0.cameras.length=0,Uy=!0);for(let Zy=0;Zy<Ty.length;Zy++){const iv=Ty[Zy];let zy=null;if(It!==null)zy=It.getViewport(iv);else{const Ay=b.getViewSubImage(Et,iv);zy=Ay.viewport,Zy===0&&(e.setRenderTargetTextures(cr,Ay.colorTexture,Et.ignoreDepthValues?void 0:Ay.depthStencilTexture),e.setRenderTarget(cr))}let B0=g0[Zy];B0===void 0&&(B0=new PerspectiveCamera,B0.layers.enable(Zy),B0.viewport=new Vector4,g0[Zy]=B0),B0.matrix.fromArray(iv.transform.matrix),B0.matrix.decompose(B0.position,B0.quaternion,B0.scale),B0.projectionMatrix.fromArray(iv.projectionMatrix),B0.projectionMatrixInverse.copy(B0.projectionMatrix).invert(),B0.viewport.set(zy.x,zy.y,zy.width,zy.height),Zy===0&&(i0.matrix.copy(B0.matrix),i0.matrix.decompose(i0.position,i0.quaternion,i0.scale)),Uy===!0&&i0.cameras.push(B0)}const Qy=d.enabledFeatures;if(Qy&&Qy.includes("depth-sensing")){const Zy=b.getDepthInformation(Ty[0]);Zy&&Zy.isValid&&Zy.texture&&er.init(e,Zy,d.renderState)}}for(let Ty=0;Ty<fr.length;Ty++){const Uy=jr[Ty],Qy=fr[Ty];Uy!==null&&Qy!==void 0&&Qy.update(Uy,cy,g||h)}er.render(e,i0),T0&&T0(J0,cy),cy.detectedPlanes&&s.dispatchEvent({type:"planesdetected",data:cy}),zt=null}const vy=new WebGLAnimation;vy.setAnimationLoop(q0),this.setAnimationLoop=function(J0){T0=J0},this.dispose=function(){}}}const _e1=new Euler,_m1=new Matrix4;function WebGLMaterials(a,e){function o(Hn,Qt){Hn.matrixAutoUpdate===!0&&Hn.updateMatrix(),Qt.value.copy(Hn.matrix)}function s(Hn,Qt){Qt.color.getRGB(Hn.fogColor.value,getUnlitUniformColorSpace(a)),Qt.isFog?(Hn.fogNear.value=Qt.near,Hn.fogFar.value=Qt.far):Qt.isFogExp2&&(Hn.fogDensity.value=Qt.density)}function d(Hn,Qt,cr,fr,jr){Qt.isMeshBasicMaterial||Qt.isMeshLambertMaterial?c(Hn,Qt):Qt.isMeshToonMaterial?(c(Hn,Qt),b(Hn,Qt)):Qt.isMeshPhongMaterial?(c(Hn,Qt),j(Hn,Qt)):Qt.isMeshStandardMaterial?(c(Hn,Qt),Et(Hn,Qt),Qt.isMeshPhysicalMaterial&&It(Hn,Qt,jr)):Qt.isMeshMatcapMaterial?(c(Hn,Qt),zt(Hn,Qt)):Qt.isMeshDepthMaterial?c(Hn,Qt):Qt.isMeshDistanceMaterial?(c(Hn,Qt),er(Hn,Qt)):Qt.isMeshNormalMaterial?c(Hn,Qt):Qt.isLineBasicMaterial?(h(Hn,Qt),Qt.isLineDashedMaterial&&_(Hn,Qt)):Qt.isPointsMaterial?bt(Hn,Qt,cr,fr):Qt.isSpriteMaterial?g(Hn,Qt):Qt.isShadowMaterial?(Hn.color.value.copy(Qt.color),Hn.opacity.value=Qt.opacity):Qt.isShaderMaterial&&(Qt.uniformsNeedUpdate=!1)}function c(Hn,Qt){Hn.opacity.value=Qt.opacity,Qt.color&&Hn.diffuse.value.copy(Qt.color),Qt.emissive&&Hn.emissive.value.copy(Qt.emissive).multiplyScalar(Qt.emissiveIntensity),Qt.map&&(Hn.map.value=Qt.map,o(Qt.map,Hn.mapTransform)),Qt.alphaMap&&(Hn.alphaMap.value=Qt.alphaMap,o(Qt.alphaMap,Hn.alphaMapTransform)),Qt.bumpMap&&(Hn.bumpMap.value=Qt.bumpMap,o(Qt.bumpMap,Hn.bumpMapTransform),Hn.bumpScale.value=Qt.bumpScale,Qt.side===BackSide&&(Hn.bumpScale.value*=-1)),Qt.normalMap&&(Hn.normalMap.value=Qt.normalMap,o(Qt.normalMap,Hn.normalMapTransform),Hn.normalScale.value.copy(Qt.normalScale),Qt.side===BackSide&&Hn.normalScale.value.negate()),Qt.displacementMap&&(Hn.displacementMap.value=Qt.displacementMap,o(Qt.displacementMap,Hn.displacementMapTransform),Hn.displacementScale.value=Qt.displacementScale,Hn.displacementBias.value=Qt.displacementBias),Qt.emissiveMap&&(Hn.emissiveMap.value=Qt.emissiveMap,o(Qt.emissiveMap,Hn.emissiveMapTransform)),Qt.specularMap&&(Hn.specularMap.value=Qt.specularMap,o(Qt.specularMap,Hn.specularMapTransform)),Qt.alphaTest>0&&(Hn.alphaTest.value=Qt.alphaTest);const cr=e.get(Qt),fr=cr.envMap,jr=cr.envMapRotation;if(fr&&(Hn.envMap.value=fr,_e1.copy(jr),_e1.x*=-1,_e1.y*=-1,_e1.z*=-1,fr.isCubeTexture&&fr.isRenderTargetTexture===!1&&(_e1.y*=-1,_e1.z*=-1),Hn.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1)),Hn.flipEnvMap.value=fr.isCubeTexture&&fr.isRenderTargetTexture===!1?-1:1,Hn.reflectivity.value=Qt.reflectivity,Hn.ior.value=Qt.ior,Hn.refractionRatio.value=Qt.refractionRatio),Qt.lightMap){Hn.lightMap.value=Qt.lightMap;const e0=a._useLegacyLights===!0?Math.PI:1;Hn.lightMapIntensity.value=Qt.lightMapIntensity*e0,o(Qt.lightMap,Hn.lightMapTransform)}Qt.aoMap&&(Hn.aoMap.value=Qt.aoMap,Hn.aoMapIntensity.value=Qt.aoMapIntensity,o(Qt.aoMap,Hn.aoMapTransform))}function h(Hn,Qt){Hn.diffuse.value.copy(Qt.color),Hn.opacity.value=Qt.opacity,Qt.map&&(Hn.map.value=Qt.map,o(Qt.map,Hn.mapTransform))}function _(Hn,Qt){Hn.dashSize.value=Qt.dashSize,Hn.totalSize.value=Qt.dashSize+Qt.gapSize,Hn.scale.value=Qt.scale}function bt(Hn,Qt,cr,fr){Hn.diffuse.value.copy(Qt.color),Hn.opacity.value=Qt.opacity,Hn.size.value=Qt.size*cr,Hn.scale.value=fr*.5,Qt.map&&(Hn.map.value=Qt.map,o(Qt.map,Hn.uvTransform)),Qt.alphaMap&&(Hn.alphaMap.value=Qt.alphaMap,o(Qt.alphaMap,Hn.alphaMapTransform)),Qt.alphaTest>0&&(Hn.alphaTest.value=Qt.alphaTest)}function g(Hn,Qt){Hn.diffuse.value.copy(Qt.color),Hn.opacity.value=Qt.opacity,Hn.rotation.value=Qt.rotation,Qt.map&&(Hn.map.value=Qt.map,o(Qt.map,Hn.mapTransform)),Qt.alphaMap&&(Hn.alphaMap.value=Qt.alphaMap,o(Qt.alphaMap,Hn.alphaMapTransform)),Qt.alphaTest>0&&(Hn.alphaTest.value=Qt.alphaTest)}function j(Hn,Qt){Hn.specular.value.copy(Qt.specular),Hn.shininess.value=Math.max(Qt.shininess,1e-4)}function b(Hn,Qt){Qt.gradientMap&&(Hn.gradientMap.value=Qt.gradientMap)}function Et(Hn,Qt){Hn.metalness.value=Qt.metalness,Qt.metalnessMap&&(Hn.metalnessMap.value=Qt.metalnessMap,o(Qt.metalnessMap,Hn.metalnessMapTransform)),Hn.roughness.value=Qt.roughness,Qt.roughnessMap&&(Hn.roughnessMap.value=Qt.roughnessMap,o(Qt.roughnessMap,Hn.roughnessMapTransform)),e.get(Qt).envMap&&(Hn.envMapIntensity.value=Qt.envMapIntensity)}function It(Hn,Qt,cr){Hn.ior.value=Qt.ior,Qt.sheen>0&&(Hn.sheenColor.value.copy(Qt.sheenColor).multiplyScalar(Qt.sheen),Hn.sheenRoughness.value=Qt.sheenRoughness,Qt.sheenColorMap&&(Hn.sheenColorMap.value=Qt.sheenColorMap,o(Qt.sheenColorMap,Hn.sheenColorMapTransform)),Qt.sheenRoughnessMap&&(Hn.sheenRoughnessMap.value=Qt.sheenRoughnessMap,o(Qt.sheenRoughnessMap,Hn.sheenRoughnessMapTransform))),Qt.clearcoat>0&&(Hn.clearcoat.value=Qt.clearcoat,Hn.clearcoatRoughness.value=Qt.clearcoatRoughness,Qt.clearcoatMap&&(Hn.clearcoatMap.value=Qt.clearcoatMap,o(Qt.clearcoatMap,Hn.clearcoatMapTransform)),Qt.clearcoatRoughnessMap&&(Hn.clearcoatRoughnessMap.value=Qt.clearcoatRoughnessMap,o(Qt.clearcoatRoughnessMap,Hn.clearcoatRoughnessMapTransform)),Qt.clearcoatNormalMap&&(Hn.clearcoatNormalMap.value=Qt.clearcoatNormalMap,o(Qt.clearcoatNormalMap,Hn.clearcoatNormalMapTransform),Hn.clearcoatNormalScale.value.copy(Qt.clearcoatNormalScale),Qt.side===BackSide&&Hn.clearcoatNormalScale.value.negate())),Qt.iridescence>0&&(Hn.iridescence.value=Qt.iridescence,Hn.iridescenceIOR.value=Qt.iridescenceIOR,Hn.iridescenceThicknessMinimum.value=Qt.iridescenceThicknessRange[0],Hn.iridescenceThicknessMaximum.value=Qt.iridescenceThicknessRange[1],Qt.iridescenceMap&&(Hn.iridescenceMap.value=Qt.iridescenceMap,o(Qt.iridescenceMap,Hn.iridescenceMapTransform)),Qt.iridescenceThicknessMap&&(Hn.iridescenceThicknessMap.value=Qt.iridescenceThicknessMap,o(Qt.iridescenceThicknessMap,Hn.iridescenceThicknessMapTransform))),Qt.transmission>0&&(Hn.transmission.value=Qt.transmission,Hn.transmissionSamplerMap.value=cr.texture,Hn.transmissionSamplerSize.value.set(cr.width,cr.height),Qt.transmissionMap&&(Hn.transmissionMap.value=Qt.transmissionMap,o(Qt.transmissionMap,Hn.transmissionMapTransform)),Hn.thickness.value=Qt.thickness,Qt.thicknessMap&&(Hn.thicknessMap.value=Qt.thicknessMap,o(Qt.thicknessMap,Hn.thicknessMapTransform)),Hn.attenuationDistance.value=Qt.attenuationDistance,Hn.attenuationColor.value.copy(Qt.attenuationColor)),Qt.anisotropy>0&&(Hn.anisotropyVector.value.set(Qt.anisotropy*Math.cos(Qt.anisotropyRotation),Qt.anisotropy*Math.sin(Qt.anisotropyRotation)),Qt.anisotropyMap&&(Hn.anisotropyMap.value=Qt.anisotropyMap,o(Qt.anisotropyMap,Hn.anisotropyMapTransform))),Hn.specularIntensity.value=Qt.specularIntensity,Hn.specularColor.value.copy(Qt.specularColor),Qt.specularColorMap&&(Hn.specularColorMap.value=Qt.specularColorMap,o(Qt.specularColorMap,Hn.specularColorMapTransform)),Qt.specularIntensityMap&&(Hn.specularIntensityMap.value=Qt.specularIntensityMap,o(Qt.specularIntensityMap,Hn.specularIntensityMapTransform))}function zt(Hn,Qt){Qt.matcap&&(Hn.matcap.value=Qt.matcap)}function er(Hn,Qt){const cr=e.get(Qt).light;Hn.referencePosition.value.setFromMatrixPosition(cr.matrixWorld),Hn.nearDistance.value=cr.shadow.camera.near,Hn.farDistance.value=cr.shadow.camera.far}return{refreshFogUniforms:s,refreshMaterialUniforms:d}}function WebGLUniformsGroups(a,e,o,s){let d={},c={},h=[];const _=o.isWebGL2?a.getParameter(a.MAX_UNIFORM_BUFFER_BINDINGS):0;function bt(cr,fr){const jr=fr.program;s.uniformBlockBinding(cr,jr)}function g(cr,fr){let jr=d[cr.id];jr===void 0&&(zt(cr),jr=j(cr),d[cr.id]=jr,cr.addEventListener("dispose",Hn));const e0=fr.program;s.updateUBOMapping(cr,e0);const t0=e.render.frame;c[cr.id]!==t0&&(Et(cr),c[cr.id]=t0)}function j(cr){const fr=b();cr.__bindingPointIndex=fr;const jr=a.createBuffer(),e0=cr.__size,t0=cr.usage;return a.bindBuffer(a.UNIFORM_BUFFER,jr),a.bufferData(a.UNIFORM_BUFFER,e0,t0),a.bindBuffer(a.UNIFORM_BUFFER,null),a.bindBufferBase(a.UNIFORM_BUFFER,fr,jr),jr}function b(){for(let cr=0;cr<_;cr++)if(h.indexOf(cr)===-1)return h.push(cr),cr;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function Et(cr){const fr=d[cr.id],jr=cr.uniforms,e0=cr.__cache;a.bindBuffer(a.UNIFORM_BUFFER,fr);for(let t0=0,o0=jr.length;t0<o0;t0++){const l0=Array.isArray(jr[t0])?jr[t0]:[jr[t0]];for(let g0=0,i0=l0.length;g0<i0;g0++){const f0=l0[g0];if(It(f0,t0,g0,e0)===!0){const C0=f0.__offset,Z0=Array.isArray(f0.value)?f0.value:[f0.value];let R0=0;for(let Y0=0;Y0<Z0.length;Y0++){const H0=Z0[Y0],ty=er(H0);typeof H0=="number"||typeof H0=="boolean"?(f0.__data[0]=H0,a.bufferSubData(a.UNIFORM_BUFFER,C0+R0,f0.__data)):H0.isMatrix3?(f0.__data[0]=H0.elements[0],f0.__data[1]=H0.elements[1],f0.__data[2]=H0.elements[2],f0.__data[3]=0,f0.__data[4]=H0.elements[3],f0.__data[5]=H0.elements[4],f0.__data[6]=H0.elements[5],f0.__data[7]=0,f0.__data[8]=H0.elements[6],f0.__data[9]=H0.elements[7],f0.__data[10]=H0.elements[8],f0.__data[11]=0):(H0.toArray(f0.__data,R0),R0+=ty.storage/Float32Array.BYTES_PER_ELEMENT)}a.bufferSubData(a.UNIFORM_BUFFER,C0,f0.__data)}}}a.bindBuffer(a.UNIFORM_BUFFER,null)}function It(cr,fr,jr,e0){const t0=cr.value,o0=fr+"_"+jr;if(e0[o0]===void 0)return typeof t0=="number"||typeof t0=="boolean"?e0[o0]=t0:e0[o0]=t0.clone(),!0;{const l0=e0[o0];if(typeof t0=="number"||typeof t0=="boolean"){if(l0!==t0)return e0[o0]=t0,!0}else if(l0.equals(t0)===!1)return l0.copy(t0),!0}return!1}function zt(cr){const fr=cr.uniforms;let jr=0;const e0=16;for(let o0=0,l0=fr.length;o0<l0;o0++){const g0=Array.isArray(fr[o0])?fr[o0]:[fr[o0]];for(let i0=0,f0=g0.length;i0<f0;i0++){const C0=g0[i0],Z0=Array.isArray(C0.value)?C0.value:[C0.value];for(let R0=0,Y0=Z0.length;R0<Y0;R0++){const H0=Z0[R0],ty=er(H0),w0=jr%e0;w0!==0&&e0-w0<ty.boundary&&(jr+=e0-w0),C0.__data=new Float32Array(ty.storage/Float32Array.BYTES_PER_ELEMENT),C0.__offset=jr,jr+=ty.storage}}}const t0=jr%e0;return t0>0&&(jr+=e0-t0),cr.__size=jr,cr.__cache={},this}function er(cr){const fr={boundary:0,storage:0};return typeof cr=="number"||typeof cr=="boolean"?(fr.boundary=4,fr.storage=4):cr.isVector2?(fr.boundary=8,fr.storage=8):cr.isVector3||cr.isColor?(fr.boundary=16,fr.storage=12):cr.isVector4?(fr.boundary=16,fr.storage=16):cr.isMatrix3?(fr.boundary=48,fr.storage=48):cr.isMatrix4?(fr.boundary=64,fr.storage=64):cr.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",cr),fr}function Hn(cr){const fr=cr.target;fr.removeEventListener("dispose",Hn);const jr=h.indexOf(fr.__bindingPointIndex);h.splice(jr,1),a.deleteBuffer(d[fr.id]),delete d[fr.id],delete c[fr.id]}function Qt(){for(const cr in d)a.deleteBuffer(d[cr]);h=[],d={},c={}}return{bind:bt,update:g,dispose:Qt}}class WebGLRenderer{constructor(e={}){const{canvas:o=createCanvasElement(),context:s=null,depth:d=!0,stencil:c=!0,alpha:h=!1,antialias:_=!1,premultipliedAlpha:bt=!0,preserveDrawingBuffer:g=!1,powerPreference:j="default",failIfMajorPerformanceCaveat:b=!1}=e;this.isWebGLRenderer=!0;let Et;s!==null?Et=s.getContextAttributes().alpha:Et=h;const It=new Uint32Array(4),zt=new Int32Array(4);let er=null,Hn=null;const Qt=[],cr=[];this.domElement=o,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=SRGBColorSpace,this._useLegacyLights=!1,this.toneMapping=NoToneMapping,this.toneMappingExposure=1;const fr=this;let jr=!1,e0=0,t0=0,o0=null,l0=-1,g0=null;const i0=new Vector4,f0=new Vector4;let C0=null;const Z0=new Color(0);let R0=0,Y0=o.width,H0=o.height,ty=1,w0=null,L0=null;const k0=new Vector4(0,0,Y0,H0),T0=new Vector4(0,0,Y0,H0);let q0=!1;const vy=new Frustum;let J0=!1,cy=!1,Ty=null;const Uy=new Matrix4,Qy=new Vector2,Zy=new Vector3,iv={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function zy(){return o0===null?ty:1}let B0=s;function Ay(h0,$0){for(let P0=0;P0<h0.length;P0++){const Yr=h0[P0],r0=o.getContext(Yr,$0);if(r0!==null)return r0}return null}try{const h0={alpha:!0,depth:d,stencil:c,antialias:_,premultipliedAlpha:bt,preserveDrawingBuffer:g,powerPreference:j,failIfMajorPerformanceCaveat:b};if("setAttribute"in o&&o.setAttribute("data-engine",`three.js r${REVISION}`),o.addEventListener("webglcontextlost",d0,!1),o.addEventListener("webglcontextrestored",v0,!1),o.addEventListener("webglcontextcreationerror",N0,!1),B0===null){const $0=["webgl2","webgl","experimental-webgl"];if(fr.isWebGL1Renderer===!0&&$0.shift(),B0=Ay($0,h0),B0===null)throw Ay($0)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}typeof WebGLRenderingContext<"u"&&B0 instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),B0.getShaderPrecisionFormat===void 0&&(B0.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(h0){throw console.error("THREE.WebGLRenderer: "+h0.message),h0}let hy,Ly,Iy,Jy,Gy,sv,yv,I0,b0,uy,Ey,Dy,By,bv,av,Wy,my,uv,Hy,wv,mv,cv,O0,oy;function Py(){hy=new WebGLExtensions(B0),Ly=new WebGLCapabilities(B0,hy,e),hy.init(Ly),cv=new WebGLUtils(B0,hy,Ly),Iy=new WebGLState(B0,hy,Ly),Jy=new WebGLInfo(B0),Gy=new WebGLProperties,sv=new WebGLTextures(B0,hy,Iy,Gy,Ly,cv,Jy),yv=new WebGLCubeMaps(fr),I0=new WebGLCubeUVMaps(fr),b0=new WebGLAttributes(B0,Ly),O0=new WebGLBindingStates(B0,hy,b0,Ly),uy=new WebGLGeometries(B0,b0,Jy,O0),Ey=new WebGLObjects(B0,uy,b0,Jy),Hy=new WebGLMorphtargets(B0,Ly,sv),Wy=new WebGLClipping(Gy),Dy=new WebGLPrograms(fr,yv,I0,hy,Ly,O0,Wy),By=new WebGLMaterials(fr,Gy),bv=new WebGLRenderLists,av=new WebGLRenderStates(hy,Ly),uv=new WebGLBackground(fr,yv,I0,Iy,Ey,Et,bt),my=new WebGLShadowMap(fr,Ey,Ly),oy=new WebGLUniformsGroups(B0,Jy,Ly,Iy),wv=new WebGLBufferRenderer(B0,hy,Jy,Ly),mv=new WebGLIndexedBufferRenderer(B0,hy,Jy,Ly),Jy.programs=Dy.programs,fr.capabilities=Ly,fr.extensions=hy,fr.properties=Gy,fr.renderLists=bv,fr.shadowMap=my,fr.state=Iy,fr.info=Jy}Py();const nv=new WebXRManager(fr,B0);this.xr=nv,this.getContext=function(){return B0},this.getContextAttributes=function(){return B0.getContextAttributes()},this.forceContextLoss=function(){const h0=hy.get("WEBGL_lose_context");h0&&h0.loseContext()},this.forceContextRestore=function(){const h0=hy.get("WEBGL_lose_context");h0&&h0.restoreContext()},this.getPixelRatio=function(){return ty},this.setPixelRatio=function(h0){h0!==void 0&&(ty=h0,this.setSize(Y0,H0,!1))},this.getSize=function(h0){return h0.set(Y0,H0)},this.setSize=function(h0,$0,P0=!0){if(nv.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}Y0=h0,H0=$0,o.width=Math.floor(h0*ty),o.height=Math.floor($0*ty),P0===!0&&(o.style.width=h0+"px",o.style.height=$0+"px"),this.setViewport(0,0,h0,$0)},this.getDrawingBufferSize=function(h0){return h0.set(Y0*ty,H0*ty).floor()},this.setDrawingBufferSize=function(h0,$0,P0){Y0=h0,H0=$0,ty=P0,o.width=Math.floor(h0*P0),o.height=Math.floor($0*P0),this.setViewport(0,0,h0,$0)},this.getCurrentViewport=function(h0){return h0.copy(i0)},this.getViewport=function(h0){return h0.copy(k0)},this.setViewport=function(h0,$0,P0,Yr){h0.isVector4?k0.set(h0.x,h0.y,h0.z,h0.w):k0.set(h0,$0,P0,Yr),Iy.viewport(i0.copy(k0).multiplyScalar(ty).round())},this.getScissor=function(h0){return h0.copy(T0)},this.setScissor=function(h0,$0,P0,Yr){h0.isVector4?T0.set(h0.x,h0.y,h0.z,h0.w):T0.set(h0,$0,P0,Yr),Iy.scissor(f0.copy(T0).multiplyScalar(ty).round())},this.getScissorTest=function(){return q0},this.setScissorTest=function(h0){Iy.setScissorTest(q0=h0)},this.setOpaqueSort=function(h0){w0=h0},this.setTransparentSort=function(h0){L0=h0},this.getClearColor=function(h0){return h0.copy(uv.getClearColor())},this.setClearColor=function(){uv.setClearColor.apply(uv,arguments)},this.getClearAlpha=function(){return uv.getClearAlpha()},this.setClearAlpha=function(){uv.setClearAlpha.apply(uv,arguments)},this.clear=function(h0=!0,$0=!0,P0=!0){let Yr=0;if(h0){let r0=!1;if(o0!==null){const p0=o0.texture.format;r0=p0===RGBAIntegerFormat||p0===RGIntegerFormat||p0===RedIntegerFormat}if(r0){const p0=o0.texture.type,_0=p0===UnsignedByteType||p0===UnsignedIntType||p0===UnsignedShortType||p0===UnsignedInt248Type||p0===UnsignedShort4444Type||p0===UnsignedShort5551Type,D0=uv.getClearColor(),V0=uv.getClearAlpha(),yy=D0.r,ly=D0.g,gy=D0.b;_0?(It[0]=yy,It[1]=ly,It[2]=gy,It[3]=V0,B0.clearBufferuiv(B0.COLOR,0,It)):(zt[0]=yy,zt[1]=ly,zt[2]=gy,zt[3]=V0,B0.clearBufferiv(B0.COLOR,0,zt))}else Yr|=B0.COLOR_BUFFER_BIT}$0&&(Yr|=B0.DEPTH_BUFFER_BIT),P0&&(Yr|=B0.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),B0.clear(Yr)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){o.removeEventListener("webglcontextlost",d0,!1),o.removeEventListener("webglcontextrestored",v0,!1),o.removeEventListener("webglcontextcreationerror",N0,!1),bv.dispose(),av.dispose(),Gy.dispose(),yv.dispose(),I0.dispose(),Ey.dispose(),O0.dispose(),oy.dispose(),Dy.dispose(),nv.dispose(),nv.removeEventListener("sessionstart",Vv),nv.removeEventListener("sessionend",$v),Ty&&(Ty.dispose(),Ty=null),ov.stop()};function d0(h0){h0.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),jr=!0}function v0(){console.log("THREE.WebGLRenderer: Context Restored."),jr=!1;const h0=Jy.autoReset,$0=my.enabled,P0=my.autoUpdate,Yr=my.needsUpdate,r0=my.type;Py(),Jy.autoReset=h0,my.enabled=$0,my.autoUpdate=P0,my.needsUpdate=Yr,my.type=r0}function N0(h0){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",h0.statusMessage)}function F0(h0){const $0=h0.target;$0.removeEventListener("dispose",F0),sy($0)}function sy(h0){xy(h0),Gy.remove(h0)}function xy(h0){const $0=Gy.get(h0).programs;$0!==void 0&&($0.forEach(function(P0){Dy.releaseProgram(P0)}),h0.isShaderMaterial&&Dy.releaseShaderCache(h0))}this.renderBufferDirect=function(h0,$0,P0,Yr,r0,p0){$0===null&&($0=iv);const _0=r0.isMesh&&r0.matrixWorld.determinant()<0,D0=m0(h0,$0,P0,Yr,r0);Iy.setMaterial(Yr,_0);let V0=P0.index,yy=1;if(Yr.wireframe===!0){if(V0=uy.getWireframeAttribute(P0),V0===void 0)return;yy=2}const ly=P0.drawRange,gy=P0.attributes.position;let ky=ly.start*yy,jy=(ly.start+ly.count)*yy;p0!==null&&(ky=Math.max(ky,p0.start*yy),jy=Math.min(jy,(p0.start+p0.count)*yy)),V0!==null?(ky=Math.max(ky,0),jy=Math.min(jy,V0.count)):gy!=null&&(ky=Math.max(ky,0),jy=Math.min(jy,gy.count));const rv=jy-ky;if(rv<0||rv===1/0)return;O0.setup(r0,Yr,D0,P0,V0);let dv,K0=wv;if(V0!==null&&(dv=b0.get(V0),K0=mv,K0.setIndex(dv)),r0.isMesh)Yr.wireframe===!0?(Iy.setLineWidth(Yr.wireframeLinewidth*zy()),K0.setMode(B0.LINES)):K0.setMode(B0.TRIANGLES);else if(r0.isLine){let Cy=Yr.linewidth;Cy===void 0&&(Cy=1),Iy.setLineWidth(Cy*zy()),r0.isLineSegments?K0.setMode(B0.LINES):r0.isLineLoop?K0.setMode(B0.LINE_LOOP):K0.setMode(B0.LINE_STRIP)}else r0.isPoints?K0.setMode(B0.POINTS):r0.isSprite&&K0.setMode(B0.TRIANGLES);if(r0.isBatchedMesh)K0.renderMultiDraw(r0._multiDrawStarts,r0._multiDrawCounts,r0._multiDrawCount);else if(r0.isInstancedMesh)K0.renderInstances(ky,rv,r0.count);else if(P0.isInstancedBufferGeometry){const Cy=P0._maxInstanceCount!==void 0?P0._maxInstanceCount:1/0,lv=Math.min(P0.instanceCount,Cy);K0.renderInstances(ky,rv,lv)}else K0.render(ky,rv)};function ev(h0,$0,P0){h0.transparent===!0&&h0.side===DoubleSide&&h0.forceSinglePass===!1?(h0.side=BackSide,h0.needsUpdate=!0,Rv(h0,$0,P0),h0.side=FrontSide,h0.needsUpdate=!0,Rv(h0,$0,P0),h0.side=DoubleSide):Rv(h0,$0,P0)}this.compile=function(h0,$0,P0=null){P0===null&&(P0=h0),Hn=av.get(P0),Hn.init(),cr.push(Hn),P0.traverseVisible(function(r0){r0.isLight&&r0.layers.test($0.layers)&&(Hn.pushLight(r0),r0.castShadow&&Hn.pushShadow(r0))}),h0!==P0&&h0.traverseVisible(function(r0){r0.isLight&&r0.layers.test($0.layers)&&(Hn.pushLight(r0),r0.castShadow&&Hn.pushShadow(r0))}),Hn.setupLights(fr._useLegacyLights);const Yr=new Set;return h0.traverse(function(r0){const p0=r0.material;if(p0)if(Array.isArray(p0))for(let _0=0;_0<p0.length;_0++){const D0=p0[_0];ev(D0,P0,r0),Yr.add(D0)}else ev(p0,P0,r0),Yr.add(p0)}),cr.pop(),Hn=null,Yr},this.compileAsync=function(h0,$0,P0=null){const Yr=this.compile(h0,$0,P0);return new Promise(r0=>{function p0(){if(Yr.forEach(function(_0){Gy.get(_0).currentProgram.isReady()&&Yr.delete(_0)}),Yr.size===0){r0(h0);return}setTimeout(p0,10)}hy.get("KHR_parallel_shader_compile")!==null?p0():setTimeout(p0,10)})};let Sv=null;function kv(h0){Sv&&Sv(h0)}function Vv(){ov.stop()}function $v(){ov.start()}const ov=new WebGLAnimation;ov.setAnimationLoop(kv),typeof self<"u"&&ov.setContext(self),this.setAnimationLoop=function(h0){Sv=h0,nv.setAnimationLoop(h0),h0===null?ov.stop():ov.start()},nv.addEventListener("sessionstart",Vv),nv.addEventListener("sessionend",$v),this.render=function(h0,$0){if($0!==void 0&&$0.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(jr===!0)return;h0.matrixWorldAutoUpdate===!0&&h0.updateMatrixWorld(),$0.parent===null&&$0.matrixWorldAutoUpdate===!0&&$0.updateMatrixWorld(),nv.enabled===!0&&nv.isPresenting===!0&&(nv.cameraAutoUpdate===!0&&nv.updateCamera($0),$0=nv.getCamera()),h0.isScene===!0&&h0.onBeforeRender(fr,h0,$0,o0),Hn=av.get(h0,cr.length),Hn.init(),cr.push(Hn),Uy.multiplyMatrices($0.projectionMatrix,$0.matrixWorldInverse),vy.setFromProjectionMatrix(Uy),cy=this.localClippingEnabled,J0=Wy.init(this.clippingPlanes,cy),er=bv.get(h0,Qt.length),er.init(),Qt.push(er),C_(h0,$0,0,fr.sortObjects),er.finish(),fr.sortObjects===!0&&er.sort(w0,L0),this.info.render.frame++,J0===!0&&Wy.beginShadows();const P0=Hn.state.shadowsArray;if(my.render(P0,h0,$0),J0===!0&&Wy.endShadows(),this.info.autoReset===!0&&this.info.reset(),(nv.enabled===!1||nv.isPresenting===!1||nv.hasDepthSensing()===!1)&&uv.render(er,h0),Hn.setupLights(fr._useLegacyLights),$0.isArrayCamera){const Yr=$0.cameras;for(let r0=0,p0=Yr.length;r0<p0;r0++){const _0=Yr[r0];wy(er,h0,_0,_0.viewport)}}else wy(er,h0,$0);o0!==null&&(sv.updateMultisampleRenderTarget(o0),sv.updateRenderTargetMipmap(o0)),h0.isScene===!0&&h0.onAfterRender(fr,h0,$0),O0.resetDefaultState(),l0=-1,g0=null,cr.pop(),cr.length>0?Hn=cr[cr.length-1]:Hn=null,Qt.pop(),Qt.length>0?er=Qt[Qt.length-1]:er=null};function C_(h0,$0,P0,Yr){if(h0.visible===!1)return;if(h0.layers.test($0.layers)){if(h0.isGroup)P0=h0.renderOrder;else if(h0.isLOD)h0.autoUpdate===!0&&h0.update($0);else if(h0.isLight)Hn.pushLight(h0),h0.castShadow&&Hn.pushShadow(h0);else if(h0.isSprite){if(!h0.frustumCulled||vy.intersectsSprite(h0)){Yr&&Zy.setFromMatrixPosition(h0.matrixWorld).applyMatrix4(Uy);const _0=Ey.update(h0),D0=h0.material;D0.visible&&er.push(h0,_0,D0,P0,Zy.z,null)}}else if((h0.isMesh||h0.isLine||h0.isPoints)&&(!h0.frustumCulled||vy.intersectsObject(h0))){const _0=Ey.update(h0),D0=h0.material;if(Yr&&(h0.boundingSphere!==void 0?(h0.boundingSphere===null&&h0.computeBoundingSphere(),Zy.copy(h0.boundingSphere.center)):(_0.boundingSphere===null&&_0.computeBoundingSphere(),Zy.copy(_0.boundingSphere.center)),Zy.applyMatrix4(h0.matrixWorld).applyMatrix4(Uy)),Array.isArray(D0)){const V0=_0.groups;for(let yy=0,ly=V0.length;yy<ly;yy++){const gy=V0[yy],ky=D0[gy.materialIndex];ky&&ky.visible&&er.push(h0,_0,ky,P0,Zy.z,gy)}}else D0.visible&&er.push(h0,_0,D0,P0,Zy.z,null)}}const p0=h0.children;for(let _0=0,D0=p0.length;_0<D0;_0++)C_(p0[_0],$0,P0,Yr)}function wy(h0,$0,P0,Yr){const r0=h0.opaque,p0=h0.transmissive,_0=h0.transparent;Hn.setupLightsView(P0),J0===!0&&Wy.setGlobalState(fr.clippingPlanes,P0),p0.length>0&&Zv(r0,p0,$0,P0),Yr&&Iy.viewport(i0.copy(Yr)),r0.length>0&&Xv(r0,$0,P0),p0.length>0&&Xv(p0,$0,P0),_0.length>0&&Xv(_0,$0,P0),Iy.buffers.depth.setTest(!0),Iy.buffers.depth.setMask(!0),Iy.buffers.color.setMask(!0),Iy.setPolygonOffset(!1)}function Zv(h0,$0,P0,Yr){if((P0.isScene===!0?P0.overrideMaterial:null)!==null)return;const p0=Ly.isWebGL2;Ty===null&&(Ty=new WebGLRenderTarget(1,1,{generateMipmaps:!0,type:hy.has("EXT_color_buffer_half_float")?HalfFloatType:UnsignedByteType,minFilter:LinearMipmapLinearFilter,samples:p0?4:0})),fr.getDrawingBufferSize(Qy),p0?Ty.setSize(Qy.x,Qy.y):Ty.setSize(floorPowerOfTwo(Qy.x),floorPowerOfTwo(Qy.y));const _0=fr.getRenderTarget();fr.setRenderTarget(Ty),fr.getClearColor(Z0),R0=fr.getClearAlpha(),R0<1&&fr.setClearColor(16777215,.5),fr.clear();const D0=fr.toneMapping;fr.toneMapping=NoToneMapping,Xv(h0,P0,Yr),sv.updateMultisampleRenderTarget(Ty),sv.updateRenderTargetMipmap(Ty);let V0=!1;for(let yy=0,ly=$0.length;yy<ly;yy++){const gy=$0[yy],ky=gy.object,jy=gy.geometry,rv=gy.material,dv=gy.group;if(rv.side===DoubleSide&&ky.layers.test(Yr.layers)){const K0=rv.side;rv.side=BackSide,rv.needsUpdate=!0,v_(ky,P0,Yr,jy,rv,dv),rv.side=K0,rv.needsUpdate=!0,V0=!0}}V0===!0&&(sv.updateMultisampleRenderTarget(Ty),sv.updateRenderTargetMipmap(Ty)),fr.setRenderTarget(_0),fr.setClearColor(Z0,R0),fr.toneMapping=D0}function Xv(h0,$0,P0){const Yr=$0.isScene===!0?$0.overrideMaterial:null;for(let r0=0,p0=h0.length;r0<p0;r0++){const _0=h0[r0],D0=_0.object,V0=_0.geometry,yy=Yr===null?_0.material:Yr,ly=_0.group;D0.layers.test(P0.layers)&&v_(D0,$0,P0,V0,yy,ly)}}function v_(h0,$0,P0,Yr,r0,p0){h0.onBeforeRender(fr,$0,P0,Yr,r0,p0),h0.modelViewMatrix.multiplyMatrices(P0.matrixWorldInverse,h0.matrixWorld),h0.normalMatrix.getNormalMatrix(h0.modelViewMatrix),r0.onBeforeRender(fr,$0,P0,Yr,h0,p0),r0.transparent===!0&&r0.side===DoubleSide&&r0.forceSinglePass===!1?(r0.side=BackSide,r0.needsUpdate=!0,fr.renderBufferDirect(P0,$0,Yr,r0,h0,p0),r0.side=FrontSide,r0.needsUpdate=!0,fr.renderBufferDirect(P0,$0,Yr,r0,h0,p0),r0.side=DoubleSide):fr.renderBufferDirect(P0,$0,Yr,r0,h0,p0),h0.onAfterRender(fr,$0,P0,Yr,r0,p0)}function Rv(h0,$0,P0){$0.isScene!==!0&&($0=iv);const Yr=Gy.get(h0),r0=Hn.state.lights,p0=Hn.state.shadowsArray,_0=r0.state.version,D0=Dy.getParameters(h0,r0.state,p0,$0,P0),V0=Dy.getProgramCacheKey(D0);let yy=Yr.programs;Yr.environment=h0.isMeshStandardMaterial?$0.environment:null,Yr.fog=$0.fog,Yr.envMap=(h0.isMeshStandardMaterial?I0:yv).get(h0.envMap||Yr.environment),Yr.envMapRotation=Yr.environment!==null&&h0.envMap===null?$0.environmentRotation:h0.envMapRotation,yy===void 0&&(h0.addEventListener("dispose",F0),yy=new Map,Yr.programs=yy);let ly=yy.get(V0);if(ly!==void 0){if(Yr.currentProgram===ly&&Yr.lightsStateVersion===_0)return h1(h0,D0),ly}else D0.uniforms=Dy.getUniforms(h0),h0.onBuild(P0,D0,fr),h0.onBeforeCompile(D0,fr),ly=Dy.acquireProgram(D0,V0),yy.set(V0,ly),Yr.uniforms=D0.uniforms;const gy=Yr.uniforms;return(!h0.isShaderMaterial&&!h0.isRawShaderMaterial||h0.clipping===!0)&&(gy.clippingPlanes=Wy.uniform),h1(h0,D0),Yr.needsLights=j0(h0),Yr.lightsStateVersion=_0,Yr.needsLights&&(gy.ambientLightColor.value=r0.state.ambient,gy.lightProbe.value=r0.state.probe,gy.directionalLights.value=r0.state.directional,gy.directionalLightShadows.value=r0.state.directionalShadow,gy.spotLights.value=r0.state.spot,gy.spotLightShadows.value=r0.state.spotShadow,gy.rectAreaLights.value=r0.state.rectArea,gy.ltc_1.value=r0.state.rectAreaLTC1,gy.ltc_2.value=r0.state.rectAreaLTC2,gy.pointLights.value=r0.state.point,gy.pointLightShadows.value=r0.state.pointShadow,gy.hemisphereLights.value=r0.state.hemi,gy.directionalShadowMap.value=r0.state.directionalShadowMap,gy.directionalShadowMatrix.value=r0.state.directionalShadowMatrix,gy.spotShadowMap.value=r0.state.spotShadowMap,gy.spotLightMatrix.value=r0.state.spotLightMatrix,gy.spotLightMap.value=r0.state.spotLightMap,gy.pointShadowMap.value=r0.state.pointShadowMap,gy.pointShadowMatrix.value=r0.state.pointShadowMatrix),Yr.currentProgram=ly,Yr.uniformsList=null,ly}function i1(h0){if(h0.uniformsList===null){const $0=h0.currentProgram.getUniforms();h0.uniformsList=WebGLUniforms.seqWithValue($0.seq,h0.uniforms)}return h0.uniformsList}function h1(h0,$0){const P0=Gy.get(h0);P0.outputColorSpace=$0.outputColorSpace,P0.batching=$0.batching,P0.instancing=$0.instancing,P0.instancingColor=$0.instancingColor,P0.instancingMorph=$0.instancingMorph,P0.skinning=$0.skinning,P0.morphTargets=$0.morphTargets,P0.morphNormals=$0.morphNormals,P0.morphColors=$0.morphColors,P0.morphTargetsCount=$0.morphTargetsCount,P0.numClippingPlanes=$0.numClippingPlanes,P0.numIntersection=$0.numClipIntersection,P0.vertexAlphas=$0.vertexAlphas,P0.vertexTangents=$0.vertexTangents,P0.toneMapping=$0.toneMapping}function m0(h0,$0,P0,Yr,r0){$0.isScene!==!0&&($0=iv),sv.resetTextureUnits();const p0=$0.fog,_0=Yr.isMeshStandardMaterial?$0.environment:null,D0=o0===null?fr.outputColorSpace:o0.isXRRenderTarget===!0?o0.texture.colorSpace:LinearSRGBColorSpace,V0=(Yr.isMeshStandardMaterial?I0:yv).get(Yr.envMap||_0),yy=Yr.vertexColors===!0&&!!P0.attributes.color&&P0.attributes.color.itemSize===4,ly=!!P0.attributes.tangent&&(!!Yr.normalMap||Yr.anisotropy>0),gy=!!P0.morphAttributes.position,ky=!!P0.morphAttributes.normal,jy=!!P0.morphAttributes.color;let rv=NoToneMapping;Yr.toneMapped&&(o0===null||o0.isXRRenderTarget===!0)&&(rv=fr.toneMapping);const dv=P0.morphAttributes.position||P0.morphAttributes.normal||P0.morphAttributes.color,K0=dv!==void 0?dv.length:0,Cy=Gy.get(Yr),lv=Hn.state.lights;if(J0===!0&&(cy===!0||h0!==g0)){const Ov=h0===g0&&Yr.id===l0;Wy.setState(Yr,h0,Ov)}let vv=!1;Yr.version===Cy.__version?(Cy.needsLights&&Cy.lightsStateVersion!==lv.state.version||Cy.outputColorSpace!==D0||r0.isBatchedMesh&&Cy.batching===!1||!r0.isBatchedMesh&&Cy.batching===!0||r0.isInstancedMesh&&Cy.instancing===!1||!r0.isInstancedMesh&&Cy.instancing===!0||r0.isSkinnedMesh&&Cy.skinning===!1||!r0.isSkinnedMesh&&Cy.skinning===!0||r0.isInstancedMesh&&Cy.instancingColor===!0&&r0.instanceColor===null||r0.isInstancedMesh&&Cy.instancingColor===!1&&r0.instanceColor!==null||r0.isInstancedMesh&&Cy.instancingMorph===!0&&r0.morphTexture===null||r0.isInstancedMesh&&Cy.instancingMorph===!1&&r0.morphTexture!==null||Cy.envMap!==V0||Yr.fog===!0&&Cy.fog!==p0||Cy.numClippingPlanes!==void 0&&(Cy.numClippingPlanes!==Wy.numPlanes||Cy.numIntersection!==Wy.numIntersection)||Cy.vertexAlphas!==yy||Cy.vertexTangents!==ly||Cy.morphTargets!==gy||Cy.morphNormals!==ky||Cy.morphColors!==jy||Cy.toneMapping!==rv||Ly.isWebGL2===!0&&Cy.morphTargetsCount!==K0)&&(vv=!0):(vv=!0,Cy.__version=Yr.version);let Mv=Cy.currentProgram;vv===!0&&(Mv=Rv(Yr,$0,r0));let f_=!1,b_=!1,x_=!1;const o_=Mv.getUniforms(),Yy=Cy.uniforms;if(Iy.useProgram(Mv.program)&&(f_=!0,b_=!0,x_=!0),Yr.id!==l0&&(l0=Yr.id,b_=!0),f_||g0!==h0){o_.setValue(B0,"projectionMatrix",h0.projectionMatrix),o_.setValue(B0,"viewMatrix",h0.matrixWorldInverse);const Ov=o_.map.cameraPosition;Ov!==void 0&&Ov.setValue(B0,Zy.setFromMatrixPosition(h0.matrixWorld)),Ly.logarithmicDepthBuffer&&o_.setValue(B0,"logDepthBufFC",2/(Math.log(h0.far+1)/Math.LN2)),(Yr.isMeshPhongMaterial||Yr.isMeshToonMaterial||Yr.isMeshLambertMaterial||Yr.isMeshBasicMaterial||Yr.isMeshStandardMaterial||Yr.isShaderMaterial)&&o_.setValue(B0,"isOrthographic",h0.isOrthographicCamera===!0),g0!==h0&&(g0=h0,b_=!0,x_=!0)}if(r0.isSkinnedMesh){o_.setOptional(B0,r0,"bindMatrix"),o_.setOptional(B0,r0,"bindMatrixInverse");const Ov=r0.skeleton;Ov&&(Ly.floatVertexTextures?(Ov.boneTexture===null&&Ov.computeBoneTexture(),o_.setValue(B0,"boneTexture",Ov.boneTexture,sv)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}r0.isBatchedMesh&&(o_.setOptional(B0,r0,"batchingTexture"),o_.setValue(B0,"batchingTexture",r0._matricesTexture,sv));const w_=P0.morphAttributes;if((w_.position!==void 0||w_.normal!==void 0||w_.color!==void 0&&Ly.isWebGL2===!0)&&Hy.update(r0,P0,Mv),(b_||Cy.receiveShadow!==r0.receiveShadow)&&(Cy.receiveShadow=r0.receiveShadow,o_.setValue(B0,"receiveShadow",r0.receiveShadow)),Yr.isMeshGouraudMaterial&&Yr.envMap!==null&&(Yy.envMap.value=V0,Yy.flipEnvMap.value=V0.isCubeTexture&&V0.isRenderTargetTexture===!1?-1:1),b_&&(o_.setValue(B0,"toneMappingExposure",fr.toneMappingExposure),Cy.needsLights&&E0(Yy,x_),p0&&Yr.fog===!0&&By.refreshFogUniforms(Yy,p0),By.refreshMaterialUniforms(Yy,Yr,ty,H0,Ty),WebGLUniforms.upload(B0,i1(Cy),Yy,sv)),Yr.isShaderMaterial&&Yr.uniformsNeedUpdate===!0&&(WebGLUniforms.upload(B0,i1(Cy),Yy,sv),Yr.uniformsNeedUpdate=!1),Yr.isSpriteMaterial&&o_.setValue(B0,"center",r0.center),o_.setValue(B0,"modelViewMatrix",r0.modelViewMatrix),o_.setValue(B0,"normalMatrix",r0.normalMatrix),o_.setValue(B0,"modelMatrix",r0.matrixWorld),Yr.isShaderMaterial||Yr.isRawShaderMaterial){const Ov=Yr.uniformsGroups;for(let Qv=0,s_=Ov.length;Qv<s_;Qv++)if(Ly.isWebGL2){const S_=Ov[Qv];oy.update(S_,Mv),oy.bind(S_,Mv)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return Mv}function E0(h0,$0){h0.ambientLightColor.needsUpdate=$0,h0.lightProbe.needsUpdate=$0,h0.directionalLights.needsUpdate=$0,h0.directionalLightShadows.needsUpdate=$0,h0.pointLights.needsUpdate=$0,h0.pointLightShadows.needsUpdate=$0,h0.spotLights.needsUpdate=$0,h0.spotLightShadows.needsUpdate=$0,h0.rectAreaLights.needsUpdate=$0,h0.hemisphereLights.needsUpdate=$0}function j0(h0){return h0.isMeshLambertMaterial||h0.isMeshToonMaterial||h0.isMeshPhongMaterial||h0.isMeshStandardMaterial||h0.isShadowMaterial||h0.isShaderMaterial&&h0.lights===!0}this.getActiveCubeFace=function(){return e0},this.getActiveMipmapLevel=function(){return t0},this.getRenderTarget=function(){return o0},this.setRenderTargetTextures=function(h0,$0,P0){Gy.get(h0.texture).__webglTexture=$0,Gy.get(h0.depthTexture).__webglTexture=P0;const Yr=Gy.get(h0);Yr.__hasExternalTextures=!0,Yr.__autoAllocateDepthBuffer=P0===void 0,Yr.__autoAllocateDepthBuffer||hy.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),Yr.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(h0,$0){const P0=Gy.get(h0);P0.__webglFramebuffer=$0,P0.__useDefaultFramebuffer=$0===void 0},this.setRenderTarget=function(h0,$0=0,P0=0){o0=h0,e0=$0,t0=P0;let Yr=!0,r0=null,p0=!1,_0=!1;if(h0){const V0=Gy.get(h0);V0.__useDefaultFramebuffer!==void 0?(Iy.bindFramebuffer(B0.FRAMEBUFFER,null),Yr=!1):V0.__webglFramebuffer===void 0?sv.setupRenderTarget(h0):V0.__hasExternalTextures&&sv.rebindTextures(h0,Gy.get(h0.texture).__webglTexture,Gy.get(h0.depthTexture).__webglTexture);const yy=h0.texture;(yy.isData3DTexture||yy.isDataArrayTexture||yy.isCompressedArrayTexture)&&(_0=!0);const ly=Gy.get(h0).__webglFramebuffer;h0.isWebGLCubeRenderTarget?(Array.isArray(ly[$0])?r0=ly[$0][P0]:r0=ly[$0],p0=!0):Ly.isWebGL2&&h0.samples>0&&sv.useMultisampledRTT(h0)===!1?r0=Gy.get(h0).__webglMultisampledFramebuffer:Array.isArray(ly)?r0=ly[P0]:r0=ly,i0.copy(h0.viewport),f0.copy(h0.scissor),C0=h0.scissorTest}else i0.copy(k0).multiplyScalar(ty).floor(),f0.copy(T0).multiplyScalar(ty).floor(),C0=q0;if(Iy.bindFramebuffer(B0.FRAMEBUFFER,r0)&&Ly.drawBuffers&&Yr&&Iy.drawBuffers(h0,r0),Iy.viewport(i0),Iy.scissor(f0),Iy.setScissorTest(C0),p0){const V0=Gy.get(h0.texture);B0.framebufferTexture2D(B0.FRAMEBUFFER,B0.COLOR_ATTACHMENT0,B0.TEXTURE_CUBE_MAP_POSITIVE_X+$0,V0.__webglTexture,P0)}else if(_0){const V0=Gy.get(h0.texture),yy=$0||0;B0.framebufferTextureLayer(B0.FRAMEBUFFER,B0.COLOR_ATTACHMENT0,V0.__webglTexture,P0||0,yy)}l0=-1},this.readRenderTargetPixels=function(h0,$0,P0,Yr,r0,p0,_0){if(!(h0&&h0.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let D0=Gy.get(h0).__webglFramebuffer;if(h0.isWebGLCubeRenderTarget&&_0!==void 0&&(D0=D0[_0]),D0){Iy.bindFramebuffer(B0.FRAMEBUFFER,D0);try{const V0=h0.texture,yy=V0.format,ly=V0.type;if(yy!==RGBAFormat&&cv.convert(yy)!==B0.getParameter(B0.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const gy=ly===HalfFloatType&&(hy.has("EXT_color_buffer_half_float")||Ly.isWebGL2&&hy.has("EXT_color_buffer_float"));if(ly!==UnsignedByteType&&cv.convert(ly)!==B0.getParameter(B0.IMPLEMENTATION_COLOR_READ_TYPE)&&!(ly===FloatType&&(Ly.isWebGL2||hy.has("OES_texture_float")||hy.has("WEBGL_color_buffer_float")))&&!gy){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}$0>=0&&$0<=h0.width-Yr&&P0>=0&&P0<=h0.height-r0&&B0.readPixels($0,P0,Yr,r0,cv.convert(yy),cv.convert(ly),p0)}finally{const V0=o0!==null?Gy.get(o0).__webglFramebuffer:null;Iy.bindFramebuffer(B0.FRAMEBUFFER,V0)}}},this.copyFramebufferToTexture=function(h0,$0,P0=0){const Yr=Math.pow(2,-P0),r0=Math.floor($0.image.width*Yr),p0=Math.floor($0.image.height*Yr);sv.setTexture2D($0,0),B0.copyTexSubImage2D(B0.TEXTURE_2D,P0,0,0,h0.x,h0.y,r0,p0),Iy.unbindTexture()},this.copyTextureToTexture=function(h0,$0,P0,Yr=0){const r0=$0.image.width,p0=$0.image.height,_0=cv.convert(P0.format),D0=cv.convert(P0.type);sv.setTexture2D(P0,0),B0.pixelStorei(B0.UNPACK_FLIP_Y_WEBGL,P0.flipY),B0.pixelStorei(B0.UNPACK_PREMULTIPLY_ALPHA_WEBGL,P0.premultiplyAlpha),B0.pixelStorei(B0.UNPACK_ALIGNMENT,P0.unpackAlignment),$0.isDataTexture?B0.texSubImage2D(B0.TEXTURE_2D,Yr,h0.x,h0.y,r0,p0,_0,D0,$0.image.data):$0.isCompressedTexture?B0.compressedTexSubImage2D(B0.TEXTURE_2D,Yr,h0.x,h0.y,$0.mipmaps[0].width,$0.mipmaps[0].height,_0,$0.mipmaps[0].data):B0.texSubImage2D(B0.TEXTURE_2D,Yr,h0.x,h0.y,_0,D0,$0.image),Yr===0&&P0.generateMipmaps&&B0.generateMipmap(B0.TEXTURE_2D),Iy.unbindTexture()},this.copyTextureToTexture3D=function(h0,$0,P0,Yr,r0=0){if(fr.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const p0=Math.round(h0.max.x-h0.min.x),_0=Math.round(h0.max.y-h0.min.y),D0=h0.max.z-h0.min.z+1,V0=cv.convert(Yr.format),yy=cv.convert(Yr.type);let ly;if(Yr.isData3DTexture)sv.setTexture3D(Yr,0),ly=B0.TEXTURE_3D;else if(Yr.isDataArrayTexture||Yr.isCompressedArrayTexture)sv.setTexture2DArray(Yr,0),ly=B0.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}B0.pixelStorei(B0.UNPACK_FLIP_Y_WEBGL,Yr.flipY),B0.pixelStorei(B0.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Yr.premultiplyAlpha),B0.pixelStorei(B0.UNPACK_ALIGNMENT,Yr.unpackAlignment);const gy=B0.getParameter(B0.UNPACK_ROW_LENGTH),ky=B0.getParameter(B0.UNPACK_IMAGE_HEIGHT),jy=B0.getParameter(B0.UNPACK_SKIP_PIXELS),rv=B0.getParameter(B0.UNPACK_SKIP_ROWS),dv=B0.getParameter(B0.UNPACK_SKIP_IMAGES),K0=P0.isCompressedTexture?P0.mipmaps[r0]:P0.image;B0.pixelStorei(B0.UNPACK_ROW_LENGTH,K0.width),B0.pixelStorei(B0.UNPACK_IMAGE_HEIGHT,K0.height),B0.pixelStorei(B0.UNPACK_SKIP_PIXELS,h0.min.x),B0.pixelStorei(B0.UNPACK_SKIP_ROWS,h0.min.y),B0.pixelStorei(B0.UNPACK_SKIP_IMAGES,h0.min.z),P0.isDataTexture||P0.isData3DTexture?B0.texSubImage3D(ly,r0,$0.x,$0.y,$0.z,p0,_0,D0,V0,yy,K0.data):Yr.isCompressedArrayTexture?B0.compressedTexSubImage3D(ly,r0,$0.x,$0.y,$0.z,p0,_0,D0,V0,K0.data):B0.texSubImage3D(ly,r0,$0.x,$0.y,$0.z,p0,_0,D0,V0,yy,K0),B0.pixelStorei(B0.UNPACK_ROW_LENGTH,gy),B0.pixelStorei(B0.UNPACK_IMAGE_HEIGHT,ky),B0.pixelStorei(B0.UNPACK_SKIP_PIXELS,jy),B0.pixelStorei(B0.UNPACK_SKIP_ROWS,rv),B0.pixelStorei(B0.UNPACK_SKIP_IMAGES,dv),r0===0&&Yr.generateMipmaps&&B0.generateMipmap(ly),Iy.unbindTexture()},this.initTexture=function(h0){h0.isCubeTexture?sv.setTextureCube(h0,0):h0.isData3DTexture?sv.setTexture3D(h0,0):h0.isDataArrayTexture||h0.isCompressedArrayTexture?sv.setTexture2DArray(h0,0):sv.setTexture2D(h0,0),Iy.unbindTexture()},this.resetState=function(){e0=0,t0=0,o0=null,Iy.reset(),O0.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return WebGLCoordinateSystem}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const o=this.getContext();o.drawingBufferColorSpace=e===DisplayP3ColorSpace?"display-p3":"srgb",o.unpackColorSpace=ColorManagement.workingColorSpace===LinearDisplayP3ColorSpace?"display-p3":"srgb"}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(e){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=e}}class WebGL1Renderer extends WebGLRenderer{}WebGL1Renderer.prototype.isWebGL1Renderer=!0;class FogExp2{constructor(e,o=25e-5){this.isFogExp2=!0,this.name="",this.color=new Color(e),this.density=o}clone(){return new FogExp2(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class Fog{constructor(e,o=1,s=1e3){this.isFog=!0,this.name="",this.color=new Color(e),this.near=o,this.far=s}clone(){return new Fog(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class Scene extends Object3D{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Euler,this.environmentRotation=new Euler,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,o){return super.copy(e,o),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const o=super.toJSON(e);return this.fog!==null&&(o.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(o.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(o.object.backgroundIntensity=this.backgroundIntensity),o.object.backgroundRotation=this.backgroundRotation.toArray(),o.object.environmentRotation=this.environmentRotation.toArray(),o}}class InterleavedBuffer{constructor(e,o){this.isInterleavedBuffer=!0,this.array=e,this.stride=o,this.count=e!==void 0?e.length/o:0,this.usage=StaticDrawUsage,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=generateUUID()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return warnOnce("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,o){this.updateRanges.push({start:e,count:o})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,o,s){e*=this.stride,s*=o.stride;for(let d=0,c=this.stride;d<c;d++)this.array[e+d]=o.array[s+d];return this}set(e,o=0){return this.array.set(e,o),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=generateUUID()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const o=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),s=new this.constructor(o,this.stride);return s.setUsage(this.usage),s}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=generateUUID()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const _vector$6=new Vector3;class InterleavedBufferAttribute{constructor(e,o,s,d=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=o,this.offset=s,this.normalized=d}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let o=0,s=this.data.count;o<s;o++)_vector$6.fromBufferAttribute(this,o),_vector$6.applyMatrix4(e),this.setXYZ(o,_vector$6.x,_vector$6.y,_vector$6.z);return this}applyNormalMatrix(e){for(let o=0,s=this.count;o<s;o++)_vector$6.fromBufferAttribute(this,o),_vector$6.applyNormalMatrix(e),this.setXYZ(o,_vector$6.x,_vector$6.y,_vector$6.z);return this}transformDirection(e){for(let o=0,s=this.count;o<s;o++)_vector$6.fromBufferAttribute(this,o),_vector$6.transformDirection(e),this.setXYZ(o,_vector$6.x,_vector$6.y,_vector$6.z);return this}getComponent(e,o){let s=this.array[e*this.data.stride+this.offset+o];return this.normalized&&(s=denormalize(s,this.array)),s}setComponent(e,o,s){return this.normalized&&(s=normalize(s,this.array)),this.data.array[e*this.data.stride+this.offset+o]=s,this}setX(e,o){return this.normalized&&(o=normalize(o,this.array)),this.data.array[e*this.data.stride+this.offset]=o,this}setY(e,o){return this.normalized&&(o=normalize(o,this.array)),this.data.array[e*this.data.stride+this.offset+1]=o,this}setZ(e,o){return this.normalized&&(o=normalize(o,this.array)),this.data.array[e*this.data.stride+this.offset+2]=o,this}setW(e,o){return this.normalized&&(o=normalize(o,this.array)),this.data.array[e*this.data.stride+this.offset+3]=o,this}getX(e){let o=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(o=denormalize(o,this.array)),o}getY(e){let o=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(o=denormalize(o,this.array)),o}getZ(e){let o=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(o=denormalize(o,this.array)),o}getW(e){let o=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(o=denormalize(o,this.array)),o}setXY(e,o,s){return e=e*this.data.stride+this.offset,this.normalized&&(o=normalize(o,this.array),s=normalize(s,this.array)),this.data.array[e+0]=o,this.data.array[e+1]=s,this}setXYZ(e,o,s,d){return e=e*this.data.stride+this.offset,this.normalized&&(o=normalize(o,this.array),s=normalize(s,this.array),d=normalize(d,this.array)),this.data.array[e+0]=o,this.data.array[e+1]=s,this.data.array[e+2]=d,this}setXYZW(e,o,s,d,c){return e=e*this.data.stride+this.offset,this.normalized&&(o=normalize(o,this.array),s=normalize(s,this.array),d=normalize(d,this.array),c=normalize(c,this.array)),this.data.array[e+0]=o,this.data.array[e+1]=s,this.data.array[e+2]=d,this.data.array[e+3]=c,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const o=[];for(let s=0;s<this.count;s++){const d=s*this.data.stride+this.offset;for(let c=0;c<this.itemSize;c++)o.push(this.data.array[d+c])}return new BufferAttribute(new this.array.constructor(o),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new InterleavedBufferAttribute(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const o=[];for(let s=0;s<this.count;s++){const d=s*this.data.stride+this.offset;for(let c=0;c<this.itemSize;c++)o.push(this.data.array[d+c])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:o,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class SpriteMaterial extends Material{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let _geometry;const _intersectPoint=new Vector3,_worldScale=new Vector3,_mvPosition=new Vector3,_alignedPosition=new Vector2,_rotatedPosition=new Vector2,_viewWorldMatrix=new Matrix4,_vA=new Vector3,_vB=new Vector3,_vC=new Vector3,_uvA=new Vector2,_uvB=new Vector2,_uvC=new Vector2;class Sprite extends Object3D{constructor(e=new SpriteMaterial){if(super(),this.isSprite=!0,this.type="Sprite",_geometry===void 0){_geometry=new BufferGeometry;const o=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),s=new InterleavedBuffer(o,5);_geometry.setIndex([0,1,2,0,2,3]),_geometry.setAttribute("position",new InterleavedBufferAttribute(s,3,0,!1)),_geometry.setAttribute("uv",new InterleavedBufferAttribute(s,2,3,!1))}this.geometry=_geometry,this.material=e,this.center=new Vector2(.5,.5)}raycast(e,o){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),_worldScale.setFromMatrixScale(this.matrixWorld),_viewWorldMatrix.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),_mvPosition.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&_worldScale.multiplyScalar(-_mvPosition.z);const s=this.material.rotation;let d,c;s!==0&&(c=Math.cos(s),d=Math.sin(s));const h=this.center;transformVertex(_vA.set(-.5,-.5,0),_mvPosition,h,_worldScale,d,c),transformVertex(_vB.set(.5,-.5,0),_mvPosition,h,_worldScale,d,c),transformVertex(_vC.set(.5,.5,0),_mvPosition,h,_worldScale,d,c),_uvA.set(0,0),_uvB.set(1,0),_uvC.set(1,1);let _=e.ray.intersectTriangle(_vA,_vB,_vC,!1,_intersectPoint);if(_===null&&(transformVertex(_vB.set(-.5,.5,0),_mvPosition,h,_worldScale,d,c),_uvB.set(0,1),_=e.ray.intersectTriangle(_vA,_vC,_vB,!1,_intersectPoint),_===null))return;const bt=e.ray.origin.distanceTo(_intersectPoint);bt<e.near||bt>e.far||o.push({distance:bt,point:_intersectPoint.clone(),uv:Triangle.getInterpolation(_intersectPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new Vector2),face:null,object:this})}copy(e,o){return super.copy(e,o),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function transformVertex(a,e,o,s,d,c){_alignedPosition.subVectors(a,o).addScalar(.5).multiply(s),d!==void 0?(_rotatedPosition.x=c*_alignedPosition.x-d*_alignedPosition.y,_rotatedPosition.y=d*_alignedPosition.x+c*_alignedPosition.y):_rotatedPosition.copy(_alignedPosition),a.copy(e),a.x+=_rotatedPosition.x,a.y+=_rotatedPosition.y,a.applyMatrix4(_viewWorldMatrix)}const _v1$2=new Vector3,_v2$1=new Vector3;class LOD extends Object3D{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const o=e.levels;for(let s=0,d=o.length;s<d;s++){const c=o[s];this.addLevel(c.object.clone(),c.distance,c.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,o=0,s=0){o=Math.abs(o);const d=this.levels;let c;for(c=0;c<d.length&&!(o<d[c].distance);c++);return d.splice(c,0,{distance:o,hysteresis:s,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const o=this.levels;if(o.length>0){let s,d;for(s=1,d=o.length;s<d;s++){let c=o[s].distance;if(o[s].object.visible&&(c-=c*o[s].hysteresis),e<c)break}return o[s-1].object}return null}raycast(e,o){if(this.levels.length>0){_v1$2.setFromMatrixPosition(this.matrixWorld);const d=e.ray.origin.distanceTo(_v1$2);this.getObjectForDistance(d).raycast(e,o)}}update(e){const o=this.levels;if(o.length>1){_v1$2.setFromMatrixPosition(e.matrixWorld),_v2$1.setFromMatrixPosition(this.matrixWorld);const s=_v1$2.distanceTo(_v2$1)/e.zoom;o[0].object.visible=!0;let d,c;for(d=1,c=o.length;d<c;d++){let h=o[d].distance;if(o[d].object.visible&&(h-=h*o[d].hysteresis),s>=h)o[d-1].object.visible=!1,o[d].object.visible=!0;else break}for(this._currentLevel=d-1;d<c;d++)o[d].object.visible=!1}}toJSON(e){const o=super.toJSON(e);this.autoUpdate===!1&&(o.object.autoUpdate=!1),o.object.levels=[];const s=this.levels;for(let d=0,c=s.length;d<c;d++){const h=s[d];o.object.levels.push({object:h.object.uuid,distance:h.distance,hysteresis:h.hysteresis})}return o}}const _basePosition=new Vector3,_skinIndex=new Vector4,_skinWeight=new Vector4,_vector3=new Vector3,_matrix4=new Matrix4,_vertex=new Vector3,_sphere$4=new Sphere,_inverseMatrix$2=new Matrix4,_ray$2=new Ray;class SkinnedMesh extends Mesh{constructor(e,o){super(e,o),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=AttachedBindMode,this.bindMatrix=new Matrix4,this.bindMatrixInverse=new Matrix4,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new Box3),this.boundingBox.makeEmpty();const o=e.getAttribute("position");for(let s=0;s<o.count;s++)this.getVertexPosition(s,_vertex),this.boundingBox.expandByPoint(_vertex)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Sphere),this.boundingSphere.makeEmpty();const o=e.getAttribute("position");for(let s=0;s<o.count;s++)this.getVertexPosition(s,_vertex),this.boundingSphere.expandByPoint(_vertex)}copy(e,o){return super.copy(e,o),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,o){const s=this.material,d=this.matrixWorld;s!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_sphere$4.copy(this.boundingSphere),_sphere$4.applyMatrix4(d),e.ray.intersectsSphere(_sphere$4)!==!1&&(_inverseMatrix$2.copy(d).invert(),_ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$2),!(this.boundingBox!==null&&_ray$2.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,o,_ray$2)))}getVertexPosition(e,o){return super.getVertexPosition(e,o),this.applyBoneTransform(e,o),o}bind(e,o){this.skeleton=e,o===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),o=this.matrixWorld),this.bindMatrix.copy(o),this.bindMatrixInverse.copy(o).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Vector4,o=this.geometry.attributes.skinWeight;for(let s=0,d=o.count;s<d;s++){e.fromBufferAttribute(o,s);const c=1/e.manhattanLength();c!==1/0?e.multiplyScalar(c):e.set(1,0,0,0),o.setXYZW(s,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===AttachedBindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===DetachedBindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,o){const s=this.skeleton,d=this.geometry;_skinIndex.fromBufferAttribute(d.attributes.skinIndex,e),_skinWeight.fromBufferAttribute(d.attributes.skinWeight,e),_basePosition.copy(o).applyMatrix4(this.bindMatrix),o.set(0,0,0);for(let c=0;c<4;c++){const h=_skinWeight.getComponent(c);if(h!==0){const _=_skinIndex.getComponent(c);_matrix4.multiplyMatrices(s.bones[_].matrixWorld,s.boneInverses[_]),o.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4),h)}}return o.applyMatrix4(this.bindMatrixInverse)}}class Bone extends Object3D{constructor(){super(),this.isBone=!0,this.type="Bone"}}class DataTexture extends Texture{constructor(e=null,o=1,s=1,d,c,h,_,bt,g=NearestFilter,j=NearestFilter,b,Et){super(null,h,_,bt,g,j,d,c,b,Et),this.isDataTexture=!0,this.image={data:e,width:o,height:s},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const _offsetMatrix=new Matrix4,_identityMatrix$1=new Matrix4;class Skeleton{constructor(e=[],o=[]){this.uuid=generateUUID(),this.bones=e.slice(0),this.boneInverses=o,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,o=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),o.length===0)this.calculateInverses();else if(e.length!==o.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let s=0,d=this.bones.length;s<d;s++)this.boneInverses.push(new Matrix4)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,o=this.bones.length;e<o;e++){const s=new Matrix4;this.bones[e]&&s.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(s)}}pose(){for(let e=0,o=this.bones.length;e<o;e++){const s=this.bones[e];s&&s.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,o=this.bones.length;e<o;e++){const s=this.bones[e];s&&(s.parent&&s.parent.isBone?(s.matrix.copy(s.parent.matrixWorld).invert(),s.matrix.multiply(s.matrixWorld)):s.matrix.copy(s.matrixWorld),s.matrix.decompose(s.position,s.quaternion,s.scale))}}update(){const e=this.bones,o=this.boneInverses,s=this.boneMatrices,d=this.boneTexture;for(let c=0,h=e.length;c<h;c++){const _=e[c]?e[c].matrixWorld:_identityMatrix$1;_offsetMatrix.multiplyMatrices(_,o[c]),_offsetMatrix.toArray(s,c*16)}d!==null&&(d.needsUpdate=!0)}clone(){return new Skeleton(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const o=new Float32Array(e*e*4);o.set(this.boneMatrices);const s=new DataTexture(o,e,e,RGBAFormat,FloatType);return s.needsUpdate=!0,this.boneMatrices=o,this.boneTexture=s,this}getBoneByName(e){for(let o=0,s=this.bones.length;o<s;o++){const d=this.bones[o];if(d.name===e)return d}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,o){this.uuid=e.uuid;for(let s=0,d=e.bones.length;s<d;s++){const c=e.bones[s];let h=o[c];h===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",c),h=new Bone),this.bones.push(h),this.boneInverses.push(new Matrix4().fromArray(e.boneInverses[s]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const o=this.bones,s=this.boneInverses;for(let d=0,c=o.length;d<c;d++){const h=o[d];e.bones.push(h.uuid);const _=s[d];e.boneInverses.push(_.toArray())}return e}}class InstancedBufferAttribute extends BufferAttribute{constructor(e,o,s,d=1){super(e,o,s),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=d}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const _instanceLocalMatrix=new Matrix4,_instanceWorldMatrix=new Matrix4,_instanceIntersects=[],_box3=new Box3,_identity=new Matrix4,_mesh$1=new Mesh,_sphere$3=new Sphere;class InstancedMesh extends Mesh{constructor(e,o,s){super(e,o),this.isInstancedMesh=!0,this.instanceMatrix=new InstancedBufferAttribute(new Float32Array(s*16),16),this.instanceColor=null,this.morphTexture=null,this.count=s,this.boundingBox=null,this.boundingSphere=null;for(let d=0;d<s;d++)this.setMatrixAt(d,_identity)}computeBoundingBox(){const e=this.geometry,o=this.count;this.boundingBox===null&&(this.boundingBox=new Box3),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let s=0;s<o;s++)this.getMatrixAt(s,_instanceLocalMatrix),_box3.copy(e.boundingBox).applyMatrix4(_instanceLocalMatrix),this.boundingBox.union(_box3)}computeBoundingSphere(){const e=this.geometry,o=this.count;this.boundingSphere===null&&(this.boundingSphere=new Sphere),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let s=0;s<o;s++)this.getMatrixAt(s,_instanceLocalMatrix),_sphere$3.copy(e.boundingSphere).applyMatrix4(_instanceLocalMatrix),this.boundingSphere.union(_sphere$3)}copy(e,o){return super.copy(e,o),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,o){o.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,o){o.fromArray(this.instanceMatrix.array,e*16)}getMorphAt(e,o){const s=o.morphTargetInfluences,d=this.morphTexture.source.data.data,c=s.length+1,h=e*c+1;for(let _=0;_<s.length;_++)s[_]=d[h+_]}raycast(e,o){const s=this.matrixWorld,d=this.count;if(_mesh$1.geometry=this.geometry,_mesh$1.material=this.material,_mesh$1.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_sphere$3.copy(this.boundingSphere),_sphere$3.applyMatrix4(s),e.ray.intersectsSphere(_sphere$3)!==!1))for(let c=0;c<d;c++){this.getMatrixAt(c,_instanceLocalMatrix),_instanceWorldMatrix.multiplyMatrices(s,_instanceLocalMatrix),_mesh$1.matrixWorld=_instanceWorldMatrix,_mesh$1.raycast(e,_instanceIntersects);for(let h=0,_=_instanceIntersects.length;h<_;h++){const bt=_instanceIntersects[h];bt.instanceId=c,bt.object=this,o.push(bt)}_instanceIntersects.length=0}}setColorAt(e,o){this.instanceColor===null&&(this.instanceColor=new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count*3),3)),o.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,o){o.toArray(this.instanceMatrix.array,e*16)}setMorphAt(e,o){const s=o.morphTargetInfluences,d=s.length+1;this.morphTexture===null&&(this.morphTexture=new DataTexture(new Float32Array(d*this.count),d,this.count,RedFormat,FloatType));const c=this.morphTexture.source.data.data;let h=0;for(let g=0;g<s.length;g++)h+=s[g];const _=this.geometry.morphTargetsRelative?1:1-h,bt=d*e;c[bt]=_,c.set(s,bt+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}function sortOpaque(a,e){return a.z-e.z}function sortTransparent(a,e){return e.z-a.z}class MultiDrawRenderList{constructor(){this.index=0,this.pool=[],this.list=[]}push(e,o){const s=this.pool,d=this.list;this.index>=s.length&&s.push({start:-1,count:-1,z:-1});const c=s[this.index];d.push(c),this.index++,c.start=e.start,c.count=e.count,c.z=o}reset(){this.list.length=0,this.index=0}}const ID_ATTR_NAME="batchId",_matrix$1=new Matrix4,_invMatrixWorld=new Matrix4,_identityMatrix$2=new Matrix4,_projScreenMatrix$2=new Matrix4,_frustum=new Frustum,_box$1=new Box3,_sphere$2=new Sphere,_vector$5=new Vector3,_renderList=new MultiDrawRenderList,_mesh=new Mesh,_batchIntersects=[];function copyAttributeData(a,e,o=0){const s=e.itemSize;if(a.isInterleavedBufferAttribute||a.array.constructor!==e.array.constructor){const d=a.count;for(let c=0;c<d;c++)for(let h=0;h<s;h++)e.setComponent(c+o,h,a.getComponent(c,h))}else e.array.set(a.array,o*s);e.needsUpdate=!0}class BatchedMesh extends Mesh{get maxGeometryCount(){return this._maxGeometryCount}constructor(e,o,s=o*2,d){super(new BufferGeometry,d),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._drawRanges=[],this._reservedRanges=[],this._visibility=[],this._active=[],this._bounds=[],this._maxGeometryCount=e,this._maxVertexCount=o,this._maxIndexCount=s,this._geometryInitialized=!1,this._geometryCount=0,this._multiDrawCounts=new Int32Array(e),this._multiDrawStarts=new Int32Array(e),this._multiDrawCount=0,this._visibilityChanged=!0,this._matricesTexture=null,this._initMatricesTexture()}_initMatricesTexture(){let e=Math.sqrt(this._maxGeometryCount*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const o=new Float32Array(e*e*4),s=new DataTexture(o,e,e,RGBAFormat,FloatType);this._matricesTexture=s}_initializeGeometry(e){const o=this.geometry,s=this._maxVertexCount,d=this._maxGeometryCount,c=this._maxIndexCount;if(this._geometryInitialized===!1){for(const _ in e.attributes){const bt=e.getAttribute(_),{array:g,itemSize:j,normalized:b}=bt,Et=new g.constructor(s*j),It=new bt.constructor(Et,j,b);It.setUsage(bt.usage),o.setAttribute(_,It)}if(e.getIndex()!==null){const _=s>65536?new Uint32Array(c):new Uint16Array(c);o.setIndex(new BufferAttribute(_,1))}const h=d>65536?new Uint32Array(s):new Uint16Array(s);o.setAttribute(ID_ATTR_NAME,new BufferAttribute(h,1)),this._geometryInitialized=!0}}_validateGeometry(e){if(e.getAttribute(ID_ATTR_NAME))throw new Error(`BatchedMesh: Geometry cannot use attribute "${ID_ATTR_NAME}"`);const o=this.geometry;if(!!e.getIndex()!=!!o.getIndex())throw new Error('BatchedMesh: All geometries must consistently have "index".');for(const s in o.attributes){if(s===ID_ATTR_NAME)continue;if(!e.hasAttribute(s))throw new Error(`BatchedMesh: Added geometry missing "${s}". All geometries must have consistent attributes.`);const d=e.getAttribute(s),c=o.getAttribute(s);if(d.itemSize!==c.itemSize||d.normalized!==c.normalized)throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}setCustomSort(e){return this.customSort=e,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Box3);const e=this._geometryCount,o=this.boundingBox,s=this._active;o.makeEmpty();for(let d=0;d<e;d++)s[d]!==!1&&(this.getMatrixAt(d,_matrix$1),this.getBoundingBoxAt(d,_box$1).applyMatrix4(_matrix$1),o.union(_box$1))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Sphere);const e=this._geometryCount,o=this.boundingSphere,s=this._active;o.makeEmpty();for(let d=0;d<e;d++)s[d]!==!1&&(this.getMatrixAt(d,_matrix$1),this.getBoundingSphereAt(d,_sphere$2).applyMatrix4(_matrix$1),o.union(_sphere$2))}addGeometry(e,o=-1,s=-1){if(this._initializeGeometry(e),this._validateGeometry(e),this._geometryCount>=this._maxGeometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");const d={vertexStart:-1,vertexCount:-1,indexStart:-1,indexCount:-1};let c=null;const h=this._reservedRanges,_=this._drawRanges,bt=this._bounds;this._geometryCount!==0&&(c=h[h.length-1]),o===-1?d.vertexCount=e.getAttribute("position").count:d.vertexCount=o,c===null?d.vertexStart=0:d.vertexStart=c.vertexStart+c.vertexCount;const g=e.getIndex(),j=g!==null;if(j&&(s===-1?d.indexCount=g.count:d.indexCount=s,c===null?d.indexStart=0:d.indexStart=c.indexStart+c.indexCount),d.indexStart!==-1&&d.indexStart+d.indexCount>this._maxIndexCount||d.vertexStart+d.vertexCount>this._maxVertexCount)throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");const b=this._visibility,Et=this._active,It=this._matricesTexture,zt=this._matricesTexture.image.data;b.push(!0),Et.push(!0);const er=this._geometryCount;this._geometryCount++,_identityMatrix$2.toArray(zt,er*16),It.needsUpdate=!0,h.push(d),_.push({start:j?d.indexStart:d.vertexStart,count:-1}),bt.push({boxInitialized:!1,box:new Box3,sphereInitialized:!1,sphere:new Sphere});const Hn=this.geometry.getAttribute(ID_ATTR_NAME);for(let Qt=0;Qt<d.vertexCount;Qt++)Hn.setX(d.vertexStart+Qt,er);return Hn.needsUpdate=!0,this.setGeometryAt(er,e),er}setGeometryAt(e,o){if(e>=this._geometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");this._validateGeometry(o);const s=this.geometry,d=s.getIndex()!==null,c=s.getIndex(),h=o.getIndex(),_=this._reservedRanges[e];if(d&&h.count>_.indexCount||o.attributes.position.count>_.vertexCount)throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");const bt=_.vertexStart,g=_.vertexCount;for(const It in s.attributes){if(It===ID_ATTR_NAME)continue;const zt=o.getAttribute(It),er=s.getAttribute(It);copyAttributeData(zt,er,bt);const Hn=zt.itemSize;for(let Qt=zt.count,cr=g;Qt<cr;Qt++){const fr=bt+Qt;for(let jr=0;jr<Hn;jr++)er.setComponent(fr,jr,0)}er.needsUpdate=!0}if(d){const It=_.indexStart;for(let zt=0;zt<h.count;zt++)c.setX(It+zt,bt+h.getX(zt));for(let zt=h.count,er=_.indexCount;zt<er;zt++)c.setX(It+zt,bt);c.needsUpdate=!0}const j=this._bounds[e];o.boundingBox!==null?(j.box.copy(o.boundingBox),j.boxInitialized=!0):j.boxInitialized=!1,o.boundingSphere!==null?(j.sphere.copy(o.boundingSphere),j.sphereInitialized=!0):j.sphereInitialized=!1;const b=this._drawRanges[e],Et=o.getAttribute("position");return b.count=d?h.count:Et.count,this._visibilityChanged=!0,e}deleteGeometry(e){const o=this._active;return e>=o.length||o[e]===!1?this:(o[e]=!1,this._visibilityChanged=!0,this)}getBoundingBoxAt(e,o){if(this._active[e]===!1)return null;const d=this._bounds[e],c=d.box,h=this.geometry;if(d.boxInitialized===!1){c.makeEmpty();const _=h.index,bt=h.attributes.position,g=this._drawRanges[e];for(let j=g.start,b=g.start+g.count;j<b;j++){let Et=j;_&&(Et=_.getX(Et)),c.expandByPoint(_vector$5.fromBufferAttribute(bt,Et))}d.boxInitialized=!0}return o.copy(c),o}getBoundingSphereAt(e,o){if(this._active[e]===!1)return null;const d=this._bounds[e],c=d.sphere,h=this.geometry;if(d.sphereInitialized===!1){c.makeEmpty(),this.getBoundingBoxAt(e,_box$1),_box$1.getCenter(c.center);const _=h.index,bt=h.attributes.position,g=this._drawRanges[e];let j=0;for(let b=g.start,Et=g.start+g.count;b<Et;b++){let It=b;_&&(It=_.getX(It)),_vector$5.fromBufferAttribute(bt,It),j=Math.max(j,c.center.distanceToSquared(_vector$5))}c.radius=Math.sqrt(j),d.sphereInitialized=!0}return o.copy(c),o}setMatrixAt(e,o){const s=this._active,d=this._matricesTexture,c=this._matricesTexture.image.data,h=this._geometryCount;return e>=h||s[e]===!1?this:(o.toArray(c,e*16),d.needsUpdate=!0,this)}getMatrixAt(e,o){const s=this._active,d=this._matricesTexture.image.data,c=this._geometryCount;return e>=c||s[e]===!1?null:o.fromArray(d,e*16)}setVisibleAt(e,o){const s=this._visibility,d=this._active,c=this._geometryCount;return e>=c||d[e]===!1||s[e]===o?this:(s[e]=o,this._visibilityChanged=!0,this)}getVisibleAt(e){const o=this._visibility,s=this._active,d=this._geometryCount;return e>=d||s[e]===!1?!1:o[e]}raycast(e,o){const s=this._visibility,d=this._active,c=this._drawRanges,h=this._geometryCount,_=this.matrixWorld,bt=this.geometry;_mesh.material=this.material,_mesh.geometry.index=bt.index,_mesh.geometry.attributes=bt.attributes,_mesh.geometry.boundingBox===null&&(_mesh.geometry.boundingBox=new Box3),_mesh.geometry.boundingSphere===null&&(_mesh.geometry.boundingSphere=new Sphere);for(let g=0;g<h;g++){if(!s[g]||!d[g])continue;const j=c[g];_mesh.geometry.setDrawRange(j.start,j.count),this.getMatrixAt(g,_mesh.matrixWorld).premultiply(_),this.getBoundingBoxAt(g,_mesh.geometry.boundingBox),this.getBoundingSphereAt(g,_mesh.geometry.boundingSphere),_mesh.raycast(e,_batchIntersects);for(let b=0,Et=_batchIntersects.length;b<Et;b++){const It=_batchIntersects[b];It.object=this,It.batchId=g,o.push(It)}_batchIntersects.length=0}_mesh.material=null,_mesh.geometry.index=null,_mesh.geometry.attributes={},_mesh.geometry.setDrawRange(0,1/0)}copy(e){return super.copy(e),this.geometry=e.geometry.clone(),this.perObjectFrustumCulled=e.perObjectFrustumCulled,this.sortObjects=e.sortObjects,this.boundingBox=e.boundingBox!==null?e.boundingBox.clone():null,this.boundingSphere=e.boundingSphere!==null?e.boundingSphere.clone():null,this._drawRanges=e._drawRanges.map(o=>({...o})),this._reservedRanges=e._reservedRanges.map(o=>({...o})),this._visibility=e._visibility.slice(),this._active=e._active.slice(),this._bounds=e._bounds.map(o=>({boxInitialized:o.boxInitialized,box:o.box.clone(),sphereInitialized:o.sphereInitialized,sphere:o.sphere.clone()})),this._maxGeometryCount=e._maxGeometryCount,this._maxVertexCount=e._maxVertexCount,this._maxIndexCount=e._maxIndexCount,this._geometryInitialized=e._geometryInitialized,this._geometryCount=e._geometryCount,this._multiDrawCounts=e._multiDrawCounts.slice(),this._multiDrawStarts=e._multiDrawStarts.slice(),this._matricesTexture=e._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.slice(),this}dispose(){return this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this}onBeforeRender(e,o,s,d,c){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const h=d.getIndex(),_=h===null?1:h.array.BYTES_PER_ELEMENT,bt=this._active,g=this._visibility,j=this._multiDrawStarts,b=this._multiDrawCounts,Et=this._drawRanges,It=this.perObjectFrustumCulled;It&&(_projScreenMatrix$2.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse).multiply(this.matrixWorld),_frustum.setFromProjectionMatrix(_projScreenMatrix$2,e.coordinateSystem));let zt=0;if(this.sortObjects){_invMatrixWorld.copy(this.matrixWorld).invert(),_vector$5.setFromMatrixPosition(s.matrixWorld).applyMatrix4(_invMatrixWorld);for(let Qt=0,cr=g.length;Qt<cr;Qt++)if(g[Qt]&&bt[Qt]){this.getMatrixAt(Qt,_matrix$1),this.getBoundingSphereAt(Qt,_sphere$2).applyMatrix4(_matrix$1);let fr=!1;if(It&&(fr=!_frustum.intersectsSphere(_sphere$2)),!fr){const jr=_vector$5.distanceTo(_sphere$2.center);_renderList.push(Et[Qt],jr)}}const er=_renderList.list,Hn=this.customSort;Hn===null?er.sort(c.transparent?sortTransparent:sortOpaque):Hn.call(this,er,s);for(let Qt=0,cr=er.length;Qt<cr;Qt++){const fr=er[Qt];j[zt]=fr.start*_,b[zt]=fr.count,zt++}_renderList.reset()}else for(let er=0,Hn=g.length;er<Hn;er++)if(g[er]&&bt[er]){let Qt=!1;if(It&&(this.getMatrixAt(er,_matrix$1),this.getBoundingSphereAt(er,_sphere$2).applyMatrix4(_matrix$1),Qt=!_frustum.intersectsSphere(_sphere$2)),!Qt){const cr=Et[er];j[zt]=cr.start*_,b[zt]=cr.count,zt++}}this._multiDrawCount=zt,this._visibilityChanged=!1}onBeforeShadow(e,o,s,d,c,h){this.onBeforeRender(e,null,d,c,h)}}class LineBasicMaterial extends Material{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Color(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const _start$1=new Vector3,_end$1=new Vector3,_inverseMatrix$1=new Matrix4,_ray$1=new Ray,_sphere$1=new Sphere;class Line extends Object3D{constructor(e=new BufferGeometry,o=new LineBasicMaterial){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=o,this.updateMorphTargets()}copy(e,o){return super.copy(e,o),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const o=e.attributes.position,s=[0];for(let d=1,c=o.count;d<c;d++)_start$1.fromBufferAttribute(o,d-1),_end$1.fromBufferAttribute(o,d),s[d]=s[d-1],s[d]+=_start$1.distanceTo(_end$1);e.setAttribute("lineDistance",new Float32BufferAttribute(s,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,o){const s=this.geometry,d=this.matrixWorld,c=e.params.Line.threshold,h=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),_sphere$1.copy(s.boundingSphere),_sphere$1.applyMatrix4(d),_sphere$1.radius+=c,e.ray.intersectsSphere(_sphere$1)===!1)return;_inverseMatrix$1.copy(d).invert(),_ray$1.copy(e.ray).applyMatrix4(_inverseMatrix$1);const _=c/((this.scale.x+this.scale.y+this.scale.z)/3),bt=_*_,g=new Vector3,j=new Vector3,b=new Vector3,Et=new Vector3,It=this.isLineSegments?2:1,zt=s.index,Hn=s.attributes.position;if(zt!==null){const Qt=Math.max(0,h.start),cr=Math.min(zt.count,h.start+h.count);for(let fr=Qt,jr=cr-1;fr<jr;fr+=It){const e0=zt.getX(fr),t0=zt.getX(fr+1);if(g.fromBufferAttribute(Hn,e0),j.fromBufferAttribute(Hn,t0),_ray$1.distanceSqToSegment(g,j,Et,b)>bt)continue;Et.applyMatrix4(this.matrixWorld);const l0=e.ray.origin.distanceTo(Et);l0<e.near||l0>e.far||o.push({distance:l0,point:b.clone().applyMatrix4(this.matrixWorld),index:fr,face:null,faceIndex:null,object:this})}}else{const Qt=Math.max(0,h.start),cr=Math.min(Hn.count,h.start+h.count);for(let fr=Qt,jr=cr-1;fr<jr;fr+=It){if(g.fromBufferAttribute(Hn,fr),j.fromBufferAttribute(Hn,fr+1),_ray$1.distanceSqToSegment(g,j,Et,b)>bt)continue;Et.applyMatrix4(this.matrixWorld);const t0=e.ray.origin.distanceTo(Et);t0<e.near||t0>e.far||o.push({distance:t0,point:b.clone().applyMatrix4(this.matrixWorld),index:fr,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const o=this.geometry.morphAttributes,s=Object.keys(o);if(s.length>0){const d=o[s[0]];if(d!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let c=0,h=d.length;c<h;c++){const _=d[c].name||String(c);this.morphTargetInfluences.push(0),this.morphTargetDictionary[_]=c}}}}}const _start=new Vector3,_end=new Vector3;class LineSegments extends Line{constructor(e,o){super(e,o),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const o=e.attributes.position,s=[];for(let d=0,c=o.count;d<c;d+=2)_start.fromBufferAttribute(o,d),_end.fromBufferAttribute(o,d+1),s[d]=d===0?0:s[d-1],s[d+1]=s[d]+_start.distanceTo(_end);e.setAttribute("lineDistance",new Float32BufferAttribute(s,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class LineLoop extends Line{constructor(e,o){super(e,o),this.isLineLoop=!0,this.type="LineLoop"}}class PointsMaterial extends Material{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const _inverseMatrix=new Matrix4,_ray$4=new Ray,_sphere=new Sphere,_position$2=new Vector3;class Points extends Object3D{constructor(e=new BufferGeometry,o=new PointsMaterial){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=o,this.updateMorphTargets()}copy(e,o){return super.copy(e,o),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,o){const s=this.geometry,d=this.matrixWorld,c=e.params.Points.threshold,h=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),_sphere.copy(s.boundingSphere),_sphere.applyMatrix4(d),_sphere.radius+=c,e.ray.intersectsSphere(_sphere)===!1)return;_inverseMatrix.copy(d).invert(),_ray$4.copy(e.ray).applyMatrix4(_inverseMatrix);const _=c/((this.scale.x+this.scale.y+this.scale.z)/3),bt=_*_,g=s.index,b=s.attributes.position;if(g!==null){const Et=Math.max(0,h.start),It=Math.min(g.count,h.start+h.count);for(let zt=Et,er=It;zt<er;zt++){const Hn=g.getX(zt);_position$2.fromBufferAttribute(b,Hn),testPoint(_position$2,Hn,bt,d,e,o,this)}}else{const Et=Math.max(0,h.start),It=Math.min(b.count,h.start+h.count);for(let zt=Et,er=It;zt<er;zt++)_position$2.fromBufferAttribute(b,zt),testPoint(_position$2,zt,bt,d,e,o,this)}}updateMorphTargets(){const o=this.geometry.morphAttributes,s=Object.keys(o);if(s.length>0){const d=o[s[0]];if(d!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let c=0,h=d.length;c<h;c++){const _=d[c].name||String(c);this.morphTargetInfluences.push(0),this.morphTargetDictionary[_]=c}}}}}function testPoint(a,e,o,s,d,c,h){const _=_ray$4.distanceSqToPoint(a);if(_<o){const bt=new Vector3;_ray$4.closestPointToPoint(a,bt),bt.applyMatrix4(s);const g=d.ray.origin.distanceTo(bt);if(g<d.near||g>d.far)return;c.push({distance:g,distanceToRay:Math.sqrt(_),point:bt,index:e,face:null,object:h})}}class VideoTexture extends Texture{constructor(e,o,s,d,c,h,_,bt,g){super(e,o,s,d,c,h,_,bt,g),this.isVideoTexture=!0,this.minFilter=h!==void 0?h:LinearFilter,this.magFilter=c!==void 0?c:LinearFilter,this.generateMipmaps=!1;const j=this;function b(){j.needsUpdate=!0,e.requestVideoFrameCallback(b)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(b)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class FramebufferTexture extends Texture{constructor(e,o){super({width:e,height:o}),this.isFramebufferTexture=!0,this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.generateMipmaps=!1,this.needsUpdate=!0}}class CompressedTexture extends Texture{constructor(e,o,s,d,c,h,_,bt,g,j,b,Et){super(null,h,_,bt,g,j,d,c,b,Et),this.isCompressedTexture=!0,this.image={width:o,height:s},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class CompressedArrayTexture extends CompressedTexture{constructor(e,o,s,d,c,h){super(e,o,s,c,h),this.isCompressedArrayTexture=!0,this.image.depth=d,this.wrapR=ClampToEdgeWrapping}}class CompressedCubeTexture extends CompressedTexture{constructor(e,o,s){super(void 0,e[0].width,e[0].height,o,s,CubeReflectionMapping),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class CanvasTexture extends Texture{constructor(e,o,s,d,c,h,_,bt,g){super(e,o,s,d,c,h,_,bt,g),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Curve{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,o){const s=this.getUtoTmapping(e);return this.getPoint(s,o)}getPoints(e=5){const o=[];for(let s=0;s<=e;s++)o.push(this.getPoint(s/e));return o}getSpacedPoints(e=5){const o=[];for(let s=0;s<=e;s++)o.push(this.getPointAt(s/e));return o}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const o=[];let s,d=this.getPoint(0),c=0;o.push(0);for(let h=1;h<=e;h++)s=this.getPoint(h/e),c+=s.distanceTo(d),o.push(c),d=s;return this.cacheArcLengths=o,o}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,o){const s=this.getLengths();let d=0;const c=s.length;let h;o?h=o:h=e*s[c-1];let _=0,bt=c-1,g;for(;_<=bt;)if(d=Math.floor(_+(bt-_)/2),g=s[d]-h,g<0)_=d+1;else if(g>0)bt=d-1;else{bt=d;break}if(d=bt,s[d]===h)return d/(c-1);const j=s[d],Et=s[d+1]-j,It=(h-j)/Et;return(d+It)/(c-1)}getTangent(e,o){let d=e-1e-4,c=e+1e-4;d<0&&(d=0),c>1&&(c=1);const h=this.getPoint(d),_=this.getPoint(c),bt=o||(h.isVector2?new Vector2:new Vector3);return bt.copy(_).sub(h).normalize(),bt}getTangentAt(e,o){const s=this.getUtoTmapping(e);return this.getTangent(s,o)}computeFrenetFrames(e,o){const s=new Vector3,d=[],c=[],h=[],_=new Vector3,bt=new Matrix4;for(let It=0;It<=e;It++){const zt=It/e;d[It]=this.getTangentAt(zt,new Vector3)}c[0]=new Vector3,h[0]=new Vector3;let g=Number.MAX_VALUE;const j=Math.abs(d[0].x),b=Math.abs(d[0].y),Et=Math.abs(d[0].z);j<=g&&(g=j,s.set(1,0,0)),b<=g&&(g=b,s.set(0,1,0)),Et<=g&&s.set(0,0,1),_.crossVectors(d[0],s).normalize(),c[0].crossVectors(d[0],_),h[0].crossVectors(d[0],c[0]);for(let It=1;It<=e;It++){if(c[It]=c[It-1].clone(),h[It]=h[It-1].clone(),_.crossVectors(d[It-1],d[It]),_.length()>Number.EPSILON){_.normalize();const zt=Math.acos(clamp(d[It-1].dot(d[It]),-1,1));c[It].applyMatrix4(bt.makeRotationAxis(_,zt))}h[It].crossVectors(d[It],c[It])}if(o===!0){let It=Math.acos(clamp(c[0].dot(c[e]),-1,1));It/=e,d[0].dot(_.crossVectors(c[0],c[e]))>0&&(It=-It);for(let zt=1;zt<=e;zt++)c[zt].applyMatrix4(bt.makeRotationAxis(d[zt],It*zt)),h[zt].crossVectors(d[zt],c[zt])}return{tangents:d,normals:c,binormals:h}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class EllipseCurve extends Curve{constructor(e=0,o=0,s=1,d=1,c=0,h=Math.PI*2,_=!1,bt=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=o,this.xRadius=s,this.yRadius=d,this.aStartAngle=c,this.aEndAngle=h,this.aClockwise=_,this.aRotation=bt}getPoint(e,o=new Vector2){const s=o,d=Math.PI*2;let c=this.aEndAngle-this.aStartAngle;const h=Math.abs(c)<Number.EPSILON;for(;c<0;)c+=d;for(;c>d;)c-=d;c<Number.EPSILON&&(h?c=0:c=d),this.aClockwise===!0&&!h&&(c===d?c=-d:c=c-d);const _=this.aStartAngle+e*c;let bt=this.aX+this.xRadius*Math.cos(_),g=this.aY+this.yRadius*Math.sin(_);if(this.aRotation!==0){const j=Math.cos(this.aRotation),b=Math.sin(this.aRotation),Et=bt-this.aX,It=g-this.aY;bt=Et*j-It*b+this.aX,g=Et*b+It*j+this.aY}return s.set(bt,g)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class ArcCurve extends EllipseCurve{constructor(e,o,s,d,c,h){super(e,o,s,s,d,c,h),this.isArcCurve=!0,this.type="ArcCurve"}}function CubicPoly(){let a=0,e=0,o=0,s=0;function d(c,h,_,bt){a=c,e=_,o=-3*c+3*h-2*_-bt,s=2*c-2*h+_+bt}return{initCatmullRom:function(c,h,_,bt,g){d(h,_,g*(_-c),g*(bt-h))},initNonuniformCatmullRom:function(c,h,_,bt,g,j,b){let Et=(h-c)/g-(_-c)/(g+j)+(_-h)/j,It=(_-h)/j-(bt-h)/(j+b)+(bt-_)/b;Et*=j,It*=j,d(h,_,Et,It)},calc:function(c){const h=c*c,_=h*c;return a+e*c+o*h+s*_}}}const tmp=new Vector3,px=new CubicPoly,py=new CubicPoly,pz=new CubicPoly;class CatmullRomCurve3 extends Curve{constructor(e=[],o=!1,s="centripetal",d=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=o,this.curveType=s,this.tension=d}getPoint(e,o=new Vector3){const s=o,d=this.points,c=d.length,h=(c-(this.closed?0:1))*e;let _=Math.floor(h),bt=h-_;this.closed?_+=_>0?0:(Math.floor(Math.abs(_)/c)+1)*c:bt===0&&_===c-1&&(_=c-2,bt=1);let g,j;this.closed||_>0?g=d[(_-1)%c]:(tmp.subVectors(d[0],d[1]).add(d[0]),g=tmp);const b=d[_%c],Et=d[(_+1)%c];if(this.closed||_+2<c?j=d[(_+2)%c]:(tmp.subVectors(d[c-1],d[c-2]).add(d[c-1]),j=tmp),this.curveType==="centripetal"||this.curveType==="chordal"){const It=this.curveType==="chordal"?.5:.25;let zt=Math.pow(g.distanceToSquared(b),It),er=Math.pow(b.distanceToSquared(Et),It),Hn=Math.pow(Et.distanceToSquared(j),It);er<1e-4&&(er=1),zt<1e-4&&(zt=er),Hn<1e-4&&(Hn=er),px.initNonuniformCatmullRom(g.x,b.x,Et.x,j.x,zt,er,Hn),py.initNonuniformCatmullRom(g.y,b.y,Et.y,j.y,zt,er,Hn),pz.initNonuniformCatmullRom(g.z,b.z,Et.z,j.z,zt,er,Hn)}else this.curveType==="catmullrom"&&(px.initCatmullRom(g.x,b.x,Et.x,j.x,this.tension),py.initCatmullRom(g.y,b.y,Et.y,j.y,this.tension),pz.initCatmullRom(g.z,b.z,Et.z,j.z,this.tension));return s.set(px.calc(bt),py.calc(bt),pz.calc(bt)),s}copy(e){super.copy(e),this.points=[];for(let o=0,s=e.points.length;o<s;o++){const d=e.points[o];this.points.push(d.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let o=0,s=this.points.length;o<s;o++){const d=this.points[o];e.points.push(d.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let o=0,s=e.points.length;o<s;o++){const d=e.points[o];this.points.push(new Vector3().fromArray(d))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function CatmullRom(a,e,o,s,d){const c=(s-e)*.5,h=(d-o)*.5,_=a*a,bt=a*_;return(2*o-2*s+c+h)*bt+(-3*o+3*s-2*c-h)*_+c*a+o}function QuadraticBezierP0(a,e){const o=1-a;return o*o*e}function QuadraticBezierP1(a,e){return 2*(1-a)*a*e}function QuadraticBezierP2(a,e){return a*a*e}function QuadraticBezier(a,e,o,s){return QuadraticBezierP0(a,e)+QuadraticBezierP1(a,o)+QuadraticBezierP2(a,s)}function CubicBezierP0(a,e){const o=1-a;return o*o*o*e}function CubicBezierP1(a,e){const o=1-a;return 3*o*o*a*e}function CubicBezierP2(a,e){return 3*(1-a)*a*a*e}function CubicBezierP3(a,e){return a*a*a*e}function CubicBezier(a,e,o,s,d){return CubicBezierP0(a,e)+CubicBezierP1(a,o)+CubicBezierP2(a,s)+CubicBezierP3(a,d)}class CubicBezierCurve extends Curve{constructor(e=new Vector2,o=new Vector2,s=new Vector2,d=new Vector2){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=o,this.v2=s,this.v3=d}getPoint(e,o=new Vector2){const s=o,d=this.v0,c=this.v1,h=this.v2,_=this.v3;return s.set(CubicBezier(e,d.x,c.x,h.x,_.x),CubicBezier(e,d.y,c.y,h.y,_.y)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class CubicBezierCurve3 extends Curve{constructor(e=new Vector3,o=new Vector3,s=new Vector3,d=new Vector3){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=o,this.v2=s,this.v3=d}getPoint(e,o=new Vector3){const s=o,d=this.v0,c=this.v1,h=this.v2,_=this.v3;return s.set(CubicBezier(e,d.x,c.x,h.x,_.x),CubicBezier(e,d.y,c.y,h.y,_.y),CubicBezier(e,d.z,c.z,h.z,_.z)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class LineCurve extends Curve{constructor(e=new Vector2,o=new Vector2){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=o}getPoint(e,o=new Vector2){const s=o;return e===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(e).add(this.v1)),s}getPointAt(e,o){return this.getPoint(e,o)}getTangent(e,o=new Vector2){return o.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,o){return this.getTangent(e,o)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class LineCurve3 extends Curve{constructor(e=new Vector3,o=new Vector3){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=o}getPoint(e,o=new Vector3){const s=o;return e===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(e).add(this.v1)),s}getPointAt(e,o){return this.getPoint(e,o)}getTangent(e,o=new Vector3){return o.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,o){return this.getTangent(e,o)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class QuadraticBezierCurve extends Curve{constructor(e=new Vector2,o=new Vector2,s=new Vector2){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=o,this.v2=s}getPoint(e,o=new Vector2){const s=o,d=this.v0,c=this.v1,h=this.v2;return s.set(QuadraticBezier(e,d.x,c.x,h.x),QuadraticBezier(e,d.y,c.y,h.y)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class QuadraticBezierCurve3 extends Curve{constructor(e=new Vector3,o=new Vector3,s=new Vector3){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=o,this.v2=s}getPoint(e,o=new Vector3){const s=o,d=this.v0,c=this.v1,h=this.v2;return s.set(QuadraticBezier(e,d.x,c.x,h.x),QuadraticBezier(e,d.y,c.y,h.y),QuadraticBezier(e,d.z,c.z,h.z)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class SplineCurve extends Curve{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,o=new Vector2){const s=o,d=this.points,c=(d.length-1)*e,h=Math.floor(c),_=c-h,bt=d[h===0?h:h-1],g=d[h],j=d[h>d.length-2?d.length-1:h+1],b=d[h>d.length-3?d.length-1:h+2];return s.set(CatmullRom(_,bt.x,g.x,j.x,b.x),CatmullRom(_,bt.y,g.y,j.y,b.y)),s}copy(e){super.copy(e),this.points=[];for(let o=0,s=e.points.length;o<s;o++){const d=e.points[o];this.points.push(d.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let o=0,s=this.points.length;o<s;o++){const d=this.points[o];e.points.push(d.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let o=0,s=e.points.length;o<s;o++){const d=e.points[o];this.points.push(new Vector2().fromArray(d))}return this}}var Curves=Object.freeze({__proto__:null,ArcCurve,CatmullRomCurve3,CubicBezierCurve,CubicBezierCurve3,EllipseCurve,LineCurve,LineCurve3,QuadraticBezierCurve,QuadraticBezierCurve3,SplineCurve});class CurvePath extends Curve{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),o=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(o)){const s=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new Curves[s](o,e))}return this}getPoint(e,o){const s=e*this.getLength(),d=this.getCurveLengths();let c=0;for(;c<d.length;){if(d[c]>=s){const h=d[c]-s,_=this.curves[c],bt=_.getLength(),g=bt===0?0:1-h/bt;return _.getPointAt(g,o)}c++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let o=0;for(let s=0,d=this.curves.length;s<d;s++)o+=this.curves[s].getLength(),e.push(o);return this.cacheLengths=e,e}getSpacedPoints(e=40){const o=[];for(let s=0;s<=e;s++)o.push(this.getPoint(s/e));return this.autoClose&&o.push(o[0]),o}getPoints(e=12){const o=[];let s;for(let d=0,c=this.curves;d<c.length;d++){const h=c[d],_=h.isEllipseCurve?e*2:h.isLineCurve||h.isLineCurve3?1:h.isSplineCurve?e*h.points.length:e,bt=h.getPoints(_);for(let g=0;g<bt.length;g++){const j=bt[g];s&&s.equals(j)||(o.push(j),s=j)}}return this.autoClose&&o.length>1&&!o[o.length-1].equals(o[0])&&o.push(o[0]),o}copy(e){super.copy(e),this.curves=[];for(let o=0,s=e.curves.length;o<s;o++){const d=e.curves[o];this.curves.push(d.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let o=0,s=this.curves.length;o<s;o++){const d=this.curves[o];e.curves.push(d.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let o=0,s=e.curves.length;o<s;o++){const d=e.curves[o];this.curves.push(new Curves[d.type]().fromJSON(d))}return this}}class Path extends CurvePath{constructor(e){super(),this.type="Path",this.currentPoint=new Vector2,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let o=1,s=e.length;o<s;o++)this.lineTo(e[o].x,e[o].y);return this}moveTo(e,o){return this.currentPoint.set(e,o),this}lineTo(e,o){const s=new LineCurve(this.currentPoint.clone(),new Vector2(e,o));return this.curves.push(s),this.currentPoint.set(e,o),this}quadraticCurveTo(e,o,s,d){const c=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(e,o),new Vector2(s,d));return this.curves.push(c),this.currentPoint.set(s,d),this}bezierCurveTo(e,o,s,d,c,h){const _=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(e,o),new Vector2(s,d),new Vector2(c,h));return this.curves.push(_),this.currentPoint.set(c,h),this}splineThru(e){const o=[this.currentPoint.clone()].concat(e),s=new SplineCurve(o);return this.curves.push(s),this.currentPoint.copy(e[e.length-1]),this}arc(e,o,s,d,c,h){const _=this.currentPoint.x,bt=this.currentPoint.y;return this.absarc(e+_,o+bt,s,d,c,h),this}absarc(e,o,s,d,c,h){return this.absellipse(e,o,s,s,d,c,h),this}ellipse(e,o,s,d,c,h,_,bt){const g=this.currentPoint.x,j=this.currentPoint.y;return this.absellipse(e+g,o+j,s,d,c,h,_,bt),this}absellipse(e,o,s,d,c,h,_,bt){const g=new EllipseCurve(e,o,s,d,c,h,_,bt);if(this.curves.length>0){const b=g.getPoint(0);b.equals(this.currentPoint)||this.lineTo(b.x,b.y)}this.curves.push(g);const j=g.getPoint(1);return this.currentPoint.copy(j),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class LatheGeometry extends BufferGeometry{constructor(e=[new Vector2(0,-.5),new Vector2(.5,0),new Vector2(0,.5)],o=12,s=0,d=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:o,phiStart:s,phiLength:d},o=Math.floor(o),d=clamp(d,0,Math.PI*2);const c=[],h=[],_=[],bt=[],g=[],j=1/o,b=new Vector3,Et=new Vector2,It=new Vector3,zt=new Vector3,er=new Vector3;let Hn=0,Qt=0;for(let cr=0;cr<=e.length-1;cr++)switch(cr){case 0:Hn=e[cr+1].x-e[cr].x,Qt=e[cr+1].y-e[cr].y,It.x=Qt*1,It.y=-Hn,It.z=Qt*0,er.copy(It),It.normalize(),bt.push(It.x,It.y,It.z);break;case e.length-1:bt.push(er.x,er.y,er.z);break;default:Hn=e[cr+1].x-e[cr].x,Qt=e[cr+1].y-e[cr].y,It.x=Qt*1,It.y=-Hn,It.z=Qt*0,zt.copy(It),It.x+=er.x,It.y+=er.y,It.z+=er.z,It.normalize(),bt.push(It.x,It.y,It.z),er.copy(zt)}for(let cr=0;cr<=o;cr++){const fr=s+cr*j*d,jr=Math.sin(fr),e0=Math.cos(fr);for(let t0=0;t0<=e.length-1;t0++){b.x=e[t0].x*jr,b.y=e[t0].y,b.z=e[t0].x*e0,h.push(b.x,b.y,b.z),Et.x=cr/o,Et.y=t0/(e.length-1),_.push(Et.x,Et.y);const o0=bt[3*t0+0]*jr,l0=bt[3*t0+1],g0=bt[3*t0+0]*e0;g.push(o0,l0,g0)}}for(let cr=0;cr<o;cr++)for(let fr=0;fr<e.length-1;fr++){const jr=fr+cr*e.length,e0=jr,t0=jr+e.length,o0=jr+e.length+1,l0=jr+1;c.push(e0,t0,l0),c.push(o0,l0,t0)}this.setIndex(c),this.setAttribute("position",new Float32BufferAttribute(h,3)),this.setAttribute("uv",new Float32BufferAttribute(_,2)),this.setAttribute("normal",new Float32BufferAttribute(g,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new LatheGeometry(e.points,e.segments,e.phiStart,e.phiLength)}}class CapsuleGeometry extends LatheGeometry{constructor(e=1,o=1,s=4,d=8){const c=new Path;c.absarc(0,-o/2,e,Math.PI*1.5,0),c.absarc(0,o/2,e,0,Math.PI*.5),super(c.getPoints(s),d),this.type="CapsuleGeometry",this.parameters={radius:e,length:o,capSegments:s,radialSegments:d}}static fromJSON(e){return new CapsuleGeometry(e.radius,e.length,e.capSegments,e.radialSegments)}}class CircleGeometry extends BufferGeometry{constructor(e=1,o=32,s=0,d=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:o,thetaStart:s,thetaLength:d},o=Math.max(3,o);const c=[],h=[],_=[],bt=[],g=new Vector3,j=new Vector2;h.push(0,0,0),_.push(0,0,1),bt.push(.5,.5);for(let b=0,Et=3;b<=o;b++,Et+=3){const It=s+b/o*d;g.x=e*Math.cos(It),g.y=e*Math.sin(It),h.push(g.x,g.y,g.z),_.push(0,0,1),j.x=(h[Et]/e+1)/2,j.y=(h[Et+1]/e+1)/2,bt.push(j.x,j.y)}for(let b=1;b<=o;b++)c.push(b,b+1,0);this.setIndex(c),this.setAttribute("position",new Float32BufferAttribute(h,3)),this.setAttribute("normal",new Float32BufferAttribute(_,3)),this.setAttribute("uv",new Float32BufferAttribute(bt,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new CircleGeometry(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class CylinderGeometry extends BufferGeometry{constructor(e=1,o=1,s=1,d=32,c=1,h=!1,_=0,bt=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:o,height:s,radialSegments:d,heightSegments:c,openEnded:h,thetaStart:_,thetaLength:bt};const g=this;d=Math.floor(d),c=Math.floor(c);const j=[],b=[],Et=[],It=[];let zt=0;const er=[],Hn=s/2;let Qt=0;cr(),h===!1&&(e>0&&fr(!0),o>0&&fr(!1)),this.setIndex(j),this.setAttribute("position",new Float32BufferAttribute(b,3)),this.setAttribute("normal",new Float32BufferAttribute(Et,3)),this.setAttribute("uv",new Float32BufferAttribute(It,2));function cr(){const jr=new Vector3,e0=new Vector3;let t0=0;const o0=(o-e)/s;for(let l0=0;l0<=c;l0++){const g0=[],i0=l0/c,f0=i0*(o-e)+e;for(let C0=0;C0<=d;C0++){const Z0=C0/d,R0=Z0*bt+_,Y0=Math.sin(R0),H0=Math.cos(R0);e0.x=f0*Y0,e0.y=-i0*s+Hn,e0.z=f0*H0,b.push(e0.x,e0.y,e0.z),jr.set(Y0,o0,H0).normalize(),Et.push(jr.x,jr.y,jr.z),It.push(Z0,1-i0),g0.push(zt++)}er.push(g0)}for(let l0=0;l0<d;l0++)for(let g0=0;g0<c;g0++){const i0=er[g0][l0],f0=er[g0+1][l0],C0=er[g0+1][l0+1],Z0=er[g0][l0+1];j.push(i0,f0,Z0),j.push(f0,C0,Z0),t0+=6}g.addGroup(Qt,t0,0),Qt+=t0}function fr(jr){const e0=zt,t0=new Vector2,o0=new Vector3;let l0=0;const g0=jr===!0?e:o,i0=jr===!0?1:-1;for(let C0=1;C0<=d;C0++)b.push(0,Hn*i0,0),Et.push(0,i0,0),It.push(.5,.5),zt++;const f0=zt;for(let C0=0;C0<=d;C0++){const R0=C0/d*bt+_,Y0=Math.cos(R0),H0=Math.sin(R0);o0.x=g0*H0,o0.y=Hn*i0,o0.z=g0*Y0,b.push(o0.x,o0.y,o0.z),Et.push(0,i0,0),t0.x=Y0*.5+.5,t0.y=H0*.5*i0+.5,It.push(t0.x,t0.y),zt++}for(let C0=0;C0<d;C0++){const Z0=e0+C0,R0=f0+C0;jr===!0?j.push(R0,R0+1,Z0):j.push(R0+1,R0,Z0),l0+=3}g.addGroup(Qt,l0,jr===!0?1:2),Qt+=l0}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new CylinderGeometry(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class ConeGeometry extends CylinderGeometry{constructor(e=1,o=1,s=32,d=1,c=!1,h=0,_=Math.PI*2){super(0,e,o,s,d,c,h,_),this.type="ConeGeometry",this.parameters={radius:e,height:o,radialSegments:s,heightSegments:d,openEnded:c,thetaStart:h,thetaLength:_}}static fromJSON(e){return new ConeGeometry(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class PolyhedronGeometry extends BufferGeometry{constructor(e=[],o=[],s=1,d=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:o,radius:s,detail:d};const c=[],h=[];_(d),g(s),j(),this.setAttribute("position",new Float32BufferAttribute(c,3)),this.setAttribute("normal",new Float32BufferAttribute(c.slice(),3)),this.setAttribute("uv",new Float32BufferAttribute(h,2)),d===0?this.computeVertexNormals():this.normalizeNormals();function _(cr){const fr=new Vector3,jr=new Vector3,e0=new Vector3;for(let t0=0;t0<o.length;t0+=3)It(o[t0+0],fr),It(o[t0+1],jr),It(o[t0+2],e0),bt(fr,jr,e0,cr)}function bt(cr,fr,jr,e0){const t0=e0+1,o0=[];for(let l0=0;l0<=t0;l0++){o0[l0]=[];const g0=cr.clone().lerp(jr,l0/t0),i0=fr.clone().lerp(jr,l0/t0),f0=t0-l0;for(let C0=0;C0<=f0;C0++)C0===0&&l0===t0?o0[l0][C0]=g0:o0[l0][C0]=g0.clone().lerp(i0,C0/f0)}for(let l0=0;l0<t0;l0++)for(let g0=0;g0<2*(t0-l0)-1;g0++){const i0=Math.floor(g0/2);g0%2===0?(Et(o0[l0][i0+1]),Et(o0[l0+1][i0]),Et(o0[l0][i0])):(Et(o0[l0][i0+1]),Et(o0[l0+1][i0+1]),Et(o0[l0+1][i0]))}}function g(cr){const fr=new Vector3;for(let jr=0;jr<c.length;jr+=3)fr.x=c[jr+0],fr.y=c[jr+1],fr.z=c[jr+2],fr.normalize().multiplyScalar(cr),c[jr+0]=fr.x,c[jr+1]=fr.y,c[jr+2]=fr.z}function j(){const cr=new Vector3;for(let fr=0;fr<c.length;fr+=3){cr.x=c[fr+0],cr.y=c[fr+1],cr.z=c[fr+2];const jr=Hn(cr)/2/Math.PI+.5,e0=Qt(cr)/Math.PI+.5;h.push(jr,1-e0)}zt(),b()}function b(){for(let cr=0;cr<h.length;cr+=6){const fr=h[cr+0],jr=h[cr+2],e0=h[cr+4],t0=Math.max(fr,jr,e0),o0=Math.min(fr,jr,e0);t0>.9&&o0<.1&&(fr<.2&&(h[cr+0]+=1),jr<.2&&(h[cr+2]+=1),e0<.2&&(h[cr+4]+=1))}}function Et(cr){c.push(cr.x,cr.y,cr.z)}function It(cr,fr){const jr=cr*3;fr.x=e[jr+0],fr.y=e[jr+1],fr.z=e[jr+2]}function zt(){const cr=new Vector3,fr=new Vector3,jr=new Vector3,e0=new Vector3,t0=new Vector2,o0=new Vector2,l0=new Vector2;for(let g0=0,i0=0;g0<c.length;g0+=9,i0+=6){cr.set(c[g0+0],c[g0+1],c[g0+2]),fr.set(c[g0+3],c[g0+4],c[g0+5]),jr.set(c[g0+6],c[g0+7],c[g0+8]),t0.set(h[i0+0],h[i0+1]),o0.set(h[i0+2],h[i0+3]),l0.set(h[i0+4],h[i0+5]),e0.copy(cr).add(fr).add(jr).divideScalar(3);const f0=Hn(e0);er(t0,i0+0,cr,f0),er(o0,i0+2,fr,f0),er(l0,i0+4,jr,f0)}}function er(cr,fr,jr,e0){e0<0&&cr.x===1&&(h[fr]=cr.x-1),jr.x===0&&jr.z===0&&(h[fr]=e0/2/Math.PI+.5)}function Hn(cr){return Math.atan2(cr.z,-cr.x)}function Qt(cr){return Math.atan2(-cr.y,Math.sqrt(cr.x*cr.x+cr.z*cr.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new PolyhedronGeometry(e.vertices,e.indices,e.radius,e.details)}}class DodecahedronGeometry extends PolyhedronGeometry{constructor(e=1,o=0){const s=(1+Math.sqrt(5))/2,d=1/s,c=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-d,-s,0,-d,s,0,d,-s,0,d,s,-d,-s,0,-d,s,0,d,-s,0,d,s,0,-s,0,-d,s,0,-d,-s,0,d,s,0,d],h=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(c,h,e,o),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:o}}static fromJSON(e){return new DodecahedronGeometry(e.radius,e.detail)}}const _v0=new Vector3,_v1$1=new Vector3,_normal=new Vector3,_triangle=new Triangle;class EdgesGeometry extends BufferGeometry{constructor(e=null,o=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:o},e!==null){const d=Math.pow(10,4),c=Math.cos(DEG2RAD*o),h=e.getIndex(),_=e.getAttribute("position"),bt=h?h.count:_.count,g=[0,0,0],j=["a","b","c"],b=new Array(3),Et={},It=[];for(let zt=0;zt<bt;zt+=3){h?(g[0]=h.getX(zt),g[1]=h.getX(zt+1),g[2]=h.getX(zt+2)):(g[0]=zt,g[1]=zt+1,g[2]=zt+2);const{a:er,b:Hn,c:Qt}=_triangle;if(er.fromBufferAttribute(_,g[0]),Hn.fromBufferAttribute(_,g[1]),Qt.fromBufferAttribute(_,g[2]),_triangle.getNormal(_normal),b[0]=`${Math.round(er.x*d)},${Math.round(er.y*d)},${Math.round(er.z*d)}`,b[1]=`${Math.round(Hn.x*d)},${Math.round(Hn.y*d)},${Math.round(Hn.z*d)}`,b[2]=`${Math.round(Qt.x*d)},${Math.round(Qt.y*d)},${Math.round(Qt.z*d)}`,!(b[0]===b[1]||b[1]===b[2]||b[2]===b[0]))for(let cr=0;cr<3;cr++){const fr=(cr+1)%3,jr=b[cr],e0=b[fr],t0=_triangle[j[cr]],o0=_triangle[j[fr]],l0=`${jr}_${e0}`,g0=`${e0}_${jr}`;g0 in Et&&Et[g0]?(_normal.dot(Et[g0].normal)<=c&&(It.push(t0.x,t0.y,t0.z),It.push(o0.x,o0.y,o0.z)),Et[g0]=null):l0 in Et||(Et[l0]={index0:g[cr],index1:g[fr],normal:_normal.clone()})}}for(const zt in Et)if(Et[zt]){const{index0:er,index1:Hn}=Et[zt];_v0.fromBufferAttribute(_,er),_v1$1.fromBufferAttribute(_,Hn),It.push(_v0.x,_v0.y,_v0.z),It.push(_v1$1.x,_v1$1.y,_v1$1.z)}this.setAttribute("position",new Float32BufferAttribute(It,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class Shape extends Path{constructor(e){super(e),this.uuid=generateUUID(),this.type="Shape",this.holes=[]}getPointsHoles(e){const o=[];for(let s=0,d=this.holes.length;s<d;s++)o[s]=this.holes[s].getPoints(e);return o}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let o=0,s=e.holes.length;o<s;o++){const d=e.holes[o];this.holes.push(d.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let o=0,s=this.holes.length;o<s;o++){const d=this.holes[o];e.holes.push(d.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let o=0,s=e.holes.length;o<s;o++){const d=e.holes[o];this.holes.push(new Path().fromJSON(d))}return this}}const Earcut={triangulate:function(a,e,o=2){const s=e&&e.length,d=s?e[0]*o:a.length;let c=linkedList(a,0,d,o,!0);const h=[];if(!c||c.next===c.prev)return h;let _,bt,g,j,b,Et,It;if(s&&(c=eliminateHoles(a,e,c,o)),a.length>80*o){_=g=a[0],bt=j=a[1];for(let zt=o;zt<d;zt+=o)b=a[zt],Et=a[zt+1],b<_&&(_=b),Et<bt&&(bt=Et),b>g&&(g=b),Et>j&&(j=Et);It=Math.max(g-_,j-bt),It=It!==0?32767/It:0}return earcutLinked(c,h,o,_,bt,It,0),h}};function linkedList(a,e,o,s,d){let c,h;if(d===signedArea(a,e,o,s)>0)for(c=e;c<o;c+=s)h=insertNode(c,a[c],a[c+1],h);else for(c=o-s;c>=e;c-=s)h=insertNode(c,a[c],a[c+1],h);return h&&equals(h,h.next)&&(removeNode(h),h=h.next),h}function filterPoints(a,e){if(!a)return a;e||(e=a);let o=a,s;do if(s=!1,!o.steiner&&(equals(o,o.next)||area(o.prev,o,o.next)===0)){if(removeNode(o),o=e=o.prev,o===o.next)break;s=!0}else o=o.next;while(s||o!==e);return e}function earcutLinked(a,e,o,s,d,c,h){if(!a)return;!h&&c&&indexCurve(a,s,d,c);let _=a,bt,g;for(;a.prev!==a.next;){if(bt=a.prev,g=a.next,c?isEarHashed(a,s,d,c):isEar(a)){e.push(bt.i/o|0),e.push(a.i/o|0),e.push(g.i/o|0),removeNode(a),a=g.next,_=g.next;continue}if(a=g,a===_){h?h===1?(a=cureLocalIntersections(filterPoints(a),e,o),earcutLinked(a,e,o,s,d,c,2)):h===2&&splitEarcut(a,e,o,s,d,c):earcutLinked(filterPoints(a),e,o,s,d,c,1);break}}}function isEar(a){const e=a.prev,o=a,s=a.next;if(area(e,o,s)>=0)return!1;const d=e.x,c=o.x,h=s.x,_=e.y,bt=o.y,g=s.y,j=d<c?d<h?d:h:c<h?c:h,b=_<bt?_<g?_:g:bt<g?bt:g,Et=d>c?d>h?d:h:c>h?c:h,It=_>bt?_>g?_:g:bt>g?bt:g;let zt=s.next;for(;zt!==e;){if(zt.x>=j&&zt.x<=Et&&zt.y>=b&&zt.y<=It&&pointInTriangle(d,_,c,bt,h,g,zt.x,zt.y)&&area(zt.prev,zt,zt.next)>=0)return!1;zt=zt.next}return!0}function isEarHashed(a,e,o,s){const d=a.prev,c=a,h=a.next;if(area(d,c,h)>=0)return!1;const _=d.x,bt=c.x,g=h.x,j=d.y,b=c.y,Et=h.y,It=_<bt?_<g?_:g:bt<g?bt:g,zt=j<b?j<Et?j:Et:b<Et?b:Et,er=_>bt?_>g?_:g:bt>g?bt:g,Hn=j>b?j>Et?j:Et:b>Et?b:Et,Qt=zOrder(It,zt,e,o,s),cr=zOrder(er,Hn,e,o,s);let fr=a.prevZ,jr=a.nextZ;for(;fr&&fr.z>=Qt&&jr&&jr.z<=cr;){if(fr.x>=It&&fr.x<=er&&fr.y>=zt&&fr.y<=Hn&&fr!==d&&fr!==h&&pointInTriangle(_,j,bt,b,g,Et,fr.x,fr.y)&&area(fr.prev,fr,fr.next)>=0||(fr=fr.prevZ,jr.x>=It&&jr.x<=er&&jr.y>=zt&&jr.y<=Hn&&jr!==d&&jr!==h&&pointInTriangle(_,j,bt,b,g,Et,jr.x,jr.y)&&area(jr.prev,jr,jr.next)>=0))return!1;jr=jr.nextZ}for(;fr&&fr.z>=Qt;){if(fr.x>=It&&fr.x<=er&&fr.y>=zt&&fr.y<=Hn&&fr!==d&&fr!==h&&pointInTriangle(_,j,bt,b,g,Et,fr.x,fr.y)&&area(fr.prev,fr,fr.next)>=0)return!1;fr=fr.prevZ}for(;jr&&jr.z<=cr;){if(jr.x>=It&&jr.x<=er&&jr.y>=zt&&jr.y<=Hn&&jr!==d&&jr!==h&&pointInTriangle(_,j,bt,b,g,Et,jr.x,jr.y)&&area(jr.prev,jr,jr.next)>=0)return!1;jr=jr.nextZ}return!0}function cureLocalIntersections(a,e,o){let s=a;do{const d=s.prev,c=s.next.next;!equals(d,c)&&intersects(d,s,s.next,c)&&locallyInside(d,c)&&locallyInside(c,d)&&(e.push(d.i/o|0),e.push(s.i/o|0),e.push(c.i/o|0),removeNode(s),removeNode(s.next),s=a=c),s=s.next}while(s!==a);return filterPoints(s)}function splitEarcut(a,e,o,s,d,c){let h=a;do{let _=h.next.next;for(;_!==h.prev;){if(h.i!==_.i&&isValidDiagonal(h,_)){let bt=splitPolygon(h,_);h=filterPoints(h,h.next),bt=filterPoints(bt,bt.next),earcutLinked(h,e,o,s,d,c,0),earcutLinked(bt,e,o,s,d,c,0);return}_=_.next}h=h.next}while(h!==a)}function eliminateHoles(a,e,o,s){const d=[];let c,h,_,bt,g;for(c=0,h=e.length;c<h;c++)_=e[c]*s,bt=c<h-1?e[c+1]*s:a.length,g=linkedList(a,_,bt,s,!1),g===g.next&&(g.steiner=!0),d.push(getLeftmost(g));for(d.sort(compareX),c=0;c<d.length;c++)o=eliminateHole(d[c],o);return o}function compareX(a,e){return a.x-e.x}function eliminateHole(a,e){const o=findHoleBridge(a,e);if(!o)return e;const s=splitPolygon(o,a);return filterPoints(s,s.next),filterPoints(o,o.next)}function findHoleBridge(a,e){let o=e,s=-1/0,d;const c=a.x,h=a.y;do{if(h<=o.y&&h>=o.next.y&&o.next.y!==o.y){const Et=o.x+(h-o.y)*(o.next.x-o.x)/(o.next.y-o.y);if(Et<=c&&Et>s&&(s=Et,d=o.x<o.next.x?o:o.next,Et===c))return d}o=o.next}while(o!==e);if(!d)return null;const _=d,bt=d.x,g=d.y;let j=1/0,b;o=d;do c>=o.x&&o.x>=bt&&c!==o.x&&pointInTriangle(h<g?c:s,h,bt,g,h<g?s:c,h,o.x,o.y)&&(b=Math.abs(h-o.y)/(c-o.x),locallyInside(o,a)&&(b<j||b===j&&(o.x>d.x||o.x===d.x&&sectorContainsSector(d,o)))&&(d=o,j=b)),o=o.next;while(o!==_);return d}function sectorContainsSector(a,e){return area(a.prev,a,e.prev)<0&&area(e.next,a,a.next)<0}function indexCurve(a,e,o,s){let d=a;do d.z===0&&(d.z=zOrder(d.x,d.y,e,o,s)),d.prevZ=d.prev,d.nextZ=d.next,d=d.next;while(d!==a);d.prevZ.nextZ=null,d.prevZ=null,sortLinked(d)}function sortLinked(a){let e,o,s,d,c,h,_,bt,g=1;do{for(o=a,a=null,c=null,h=0;o;){for(h++,s=o,_=0,e=0;e<g&&(_++,s=s.nextZ,!!s);e++);for(bt=g;_>0||bt>0&&s;)_!==0&&(bt===0||!s||o.z<=s.z)?(d=o,o=o.nextZ,_--):(d=s,s=s.nextZ,bt--),c?c.nextZ=d:a=d,d.prevZ=c,c=d;o=s}c.nextZ=null,g*=2}while(h>1);return a}function zOrder(a,e,o,s,d){return a=(a-o)*d|0,e=(e-s)*d|0,a=(a|a<<8)&16711935,a=(a|a<<4)&252645135,a=(a|a<<2)&858993459,a=(a|a<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,a|e<<1}function getLeftmost(a){let e=a,o=a;do(e.x<o.x||e.x===o.x&&e.y<o.y)&&(o=e),e=e.next;while(e!==a);return o}function pointInTriangle(a,e,o,s,d,c,h,_){return(d-h)*(e-_)>=(a-h)*(c-_)&&(a-h)*(s-_)>=(o-h)*(e-_)&&(o-h)*(c-_)>=(d-h)*(s-_)}function isValidDiagonal(a,e){return a.next.i!==e.i&&a.prev.i!==e.i&&!intersectsPolygon(a,e)&&(locallyInside(a,e)&&locallyInside(e,a)&&middleInside(a,e)&&(area(a.prev,a,e.prev)||area(a,e.prev,e))||equals(a,e)&&area(a.prev,a,a.next)>0&&area(e.prev,e,e.next)>0)}function area(a,e,o){return(e.y-a.y)*(o.x-e.x)-(e.x-a.x)*(o.y-e.y)}function equals(a,e){return a.x===e.x&&a.y===e.y}function intersects(a,e,o,s){const d=sign(area(a,e,o)),c=sign(area(a,e,s)),h=sign(area(o,s,a)),_=sign(area(o,s,e));return!!(d!==c&&h!==_||d===0&&onSegment(a,o,e)||c===0&&onSegment(a,s,e)||h===0&&onSegment(o,a,s)||_===0&&onSegment(o,e,s))}function onSegment(a,e,o){return e.x<=Math.max(a.x,o.x)&&e.x>=Math.min(a.x,o.x)&&e.y<=Math.max(a.y,o.y)&&e.y>=Math.min(a.y,o.y)}function sign(a){return a>0?1:a<0?-1:0}function intersectsPolygon(a,e){let o=a;do{if(o.i!==a.i&&o.next.i!==a.i&&o.i!==e.i&&o.next.i!==e.i&&intersects(o,o.next,a,e))return!0;o=o.next}while(o!==a);return!1}function locallyInside(a,e){return area(a.prev,a,a.next)<0?area(a,e,a.next)>=0&&area(a,a.prev,e)>=0:area(a,e,a.prev)<0||area(a,a.next,e)<0}function middleInside(a,e){let o=a,s=!1;const d=(a.x+e.x)/2,c=(a.y+e.y)/2;do o.y>c!=o.next.y>c&&o.next.y!==o.y&&d<(o.next.x-o.x)*(c-o.y)/(o.next.y-o.y)+o.x&&(s=!s),o=o.next;while(o!==a);return s}function splitPolygon(a,e){const o=new Node(a.i,a.x,a.y),s=new Node(e.i,e.x,e.y),d=a.next,c=e.prev;return a.next=e,e.prev=a,o.next=d,d.prev=o,s.next=o,o.prev=s,c.next=s,s.prev=c,s}function insertNode(a,e,o,s){const d=new Node(a,e,o);return s?(d.next=s.next,d.prev=s,s.next.prev=d,s.next=d):(d.prev=d,d.next=d),d}function removeNode(a){a.next.prev=a.prev,a.prev.next=a.next,a.prevZ&&(a.prevZ.nextZ=a.nextZ),a.nextZ&&(a.nextZ.prevZ=a.prevZ)}function Node(a,e,o){this.i=a,this.x=e,this.y=o,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function signedArea(a,e,o,s){let d=0;for(let c=e,h=o-s;c<o;c+=s)d+=(a[h]-a[c])*(a[c+1]+a[h+1]),h=c;return d}class ShapeUtils{static area(e){const o=e.length;let s=0;for(let d=o-1,c=0;c<o;d=c++)s+=e[d].x*e[c].y-e[c].x*e[d].y;return s*.5}static isClockWise(e){return ShapeUtils.area(e)<0}static triangulateShape(e,o){const s=[],d=[],c=[];removeDupEndPts(e),addContour(s,e);let h=e.length;o.forEach(removeDupEndPts);for(let bt=0;bt<o.length;bt++)d.push(h),h+=o[bt].length,addContour(s,o[bt]);const _=Earcut.triangulate(s,d);for(let bt=0;bt<_.length;bt+=3)c.push(_.slice(bt,bt+3));return c}}function removeDupEndPts(a){const e=a.length;e>2&&a[e-1].equals(a[0])&&a.pop()}function addContour(a,e){for(let o=0;o<e.length;o++)a.push(e[o].x),a.push(e[o].y)}class ExtrudeGeometry extends BufferGeometry{constructor(e=new Shape([new Vector2(.5,.5),new Vector2(-.5,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),o={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:o},e=Array.isArray(e)?e:[e];const s=this,d=[],c=[];for(let _=0,bt=e.length;_<bt;_++){const g=e[_];h(g)}this.setAttribute("position",new Float32BufferAttribute(d,3)),this.setAttribute("uv",new Float32BufferAttribute(c,2)),this.computeVertexNormals();function h(_){const bt=[],g=o.curveSegments!==void 0?o.curveSegments:12,j=o.steps!==void 0?o.steps:1,b=o.depth!==void 0?o.depth:1;let Et=o.bevelEnabled!==void 0?o.bevelEnabled:!0,It=o.bevelThickness!==void 0?o.bevelThickness:.2,zt=o.bevelSize!==void 0?o.bevelSize:It-.1,er=o.bevelOffset!==void 0?o.bevelOffset:0,Hn=o.bevelSegments!==void 0?o.bevelSegments:3;const Qt=o.extrudePath,cr=o.UVGenerator!==void 0?o.UVGenerator:WorldUVGenerator;let fr,jr=!1,e0,t0,o0,l0;Qt&&(fr=Qt.getSpacedPoints(j),jr=!0,Et=!1,e0=Qt.computeFrenetFrames(j,!1),t0=new Vector3,o0=new Vector3,l0=new Vector3),Et||(Hn=0,It=0,zt=0,er=0);const g0=_.extractPoints(g);let i0=g0.shape;const f0=g0.holes;if(!ShapeUtils.isClockWise(i0)){i0=i0.reverse();for(let B0=0,Ay=f0.length;B0<Ay;B0++){const hy=f0[B0];ShapeUtils.isClockWise(hy)&&(f0[B0]=hy.reverse())}}const Z0=ShapeUtils.triangulateShape(i0,f0),R0=i0;for(let B0=0,Ay=f0.length;B0<Ay;B0++){const hy=f0[B0];i0=i0.concat(hy)}function Y0(B0,Ay,hy){return Ay||console.error("THREE.ExtrudeGeometry: vec does not exist"),B0.clone().addScaledVector(Ay,hy)}const H0=i0.length,ty=Z0.length;function w0(B0,Ay,hy){let Ly,Iy,Jy;const Gy=B0.x-Ay.x,sv=B0.y-Ay.y,yv=hy.x-B0.x,I0=hy.y-B0.y,b0=Gy*Gy+sv*sv,uy=Gy*I0-sv*yv;if(Math.abs(uy)>Number.EPSILON){const Ey=Math.sqrt(b0),Dy=Math.sqrt(yv*yv+I0*I0),By=Ay.x-sv/Ey,bv=Ay.y+Gy/Ey,av=hy.x-I0/Dy,Wy=hy.y+yv/Dy,my=((av-By)*I0-(Wy-bv)*yv)/(Gy*I0-sv*yv);Ly=By+Gy*my-B0.x,Iy=bv+sv*my-B0.y;const uv=Ly*Ly+Iy*Iy;if(uv<=2)return new Vector2(Ly,Iy);Jy=Math.sqrt(uv/2)}else{let Ey=!1;Gy>Number.EPSILON?yv>Number.EPSILON&&(Ey=!0):Gy<-Number.EPSILON?yv<-Number.EPSILON&&(Ey=!0):Math.sign(sv)===Math.sign(I0)&&(Ey=!0),Ey?(Ly=-sv,Iy=Gy,Jy=Math.sqrt(b0)):(Ly=Gy,Iy=sv,Jy=Math.sqrt(b0/2))}return new Vector2(Ly/Jy,Iy/Jy)}const L0=[];for(let B0=0,Ay=R0.length,hy=Ay-1,Ly=B0+1;B0<Ay;B0++,hy++,Ly++)hy===Ay&&(hy=0),Ly===Ay&&(Ly=0),L0[B0]=w0(R0[B0],R0[hy],R0[Ly]);const k0=[];let T0,q0=L0.concat();for(let B0=0,Ay=f0.length;B0<Ay;B0++){const hy=f0[B0];T0=[];for(let Ly=0,Iy=hy.length,Jy=Iy-1,Gy=Ly+1;Ly<Iy;Ly++,Jy++,Gy++)Jy===Iy&&(Jy=0),Gy===Iy&&(Gy=0),T0[Ly]=w0(hy[Ly],hy[Jy],hy[Gy]);k0.push(T0),q0=q0.concat(T0)}for(let B0=0;B0<Hn;B0++){const Ay=B0/Hn,hy=It*Math.cos(Ay*Math.PI/2),Ly=zt*Math.sin(Ay*Math.PI/2)+er;for(let Iy=0,Jy=R0.length;Iy<Jy;Iy++){const Gy=Y0(R0[Iy],L0[Iy],Ly);Uy(Gy.x,Gy.y,-hy)}for(let Iy=0,Jy=f0.length;Iy<Jy;Iy++){const Gy=f0[Iy];T0=k0[Iy];for(let sv=0,yv=Gy.length;sv<yv;sv++){const I0=Y0(Gy[sv],T0[sv],Ly);Uy(I0.x,I0.y,-hy)}}}const vy=zt+er;for(let B0=0;B0<H0;B0++){const Ay=Et?Y0(i0[B0],q0[B0],vy):i0[B0];jr?(o0.copy(e0.normals[0]).multiplyScalar(Ay.x),t0.copy(e0.binormals[0]).multiplyScalar(Ay.y),l0.copy(fr[0]).add(o0).add(t0),Uy(l0.x,l0.y,l0.z)):Uy(Ay.x,Ay.y,0)}for(let B0=1;B0<=j;B0++)for(let Ay=0;Ay<H0;Ay++){const hy=Et?Y0(i0[Ay],q0[Ay],vy):i0[Ay];jr?(o0.copy(e0.normals[B0]).multiplyScalar(hy.x),t0.copy(e0.binormals[B0]).multiplyScalar(hy.y),l0.copy(fr[B0]).add(o0).add(t0),Uy(l0.x,l0.y,l0.z)):Uy(hy.x,hy.y,b/j*B0)}for(let B0=Hn-1;B0>=0;B0--){const Ay=B0/Hn,hy=It*Math.cos(Ay*Math.PI/2),Ly=zt*Math.sin(Ay*Math.PI/2)+er;for(let Iy=0,Jy=R0.length;Iy<Jy;Iy++){const Gy=Y0(R0[Iy],L0[Iy],Ly);Uy(Gy.x,Gy.y,b+hy)}for(let Iy=0,Jy=f0.length;Iy<Jy;Iy++){const Gy=f0[Iy];T0=k0[Iy];for(let sv=0,yv=Gy.length;sv<yv;sv++){const I0=Y0(Gy[sv],T0[sv],Ly);jr?Uy(I0.x,I0.y+fr[j-1].y,fr[j-1].x+hy):Uy(I0.x,I0.y,b+hy)}}}J0(),cy();function J0(){const B0=d.length/3;if(Et){let Ay=0,hy=H0*Ay;for(let Ly=0;Ly<ty;Ly++){const Iy=Z0[Ly];Qy(Iy[2]+hy,Iy[1]+hy,Iy[0]+hy)}Ay=j+Hn*2,hy=H0*Ay;for(let Ly=0;Ly<ty;Ly++){const Iy=Z0[Ly];Qy(Iy[0]+hy,Iy[1]+hy,Iy[2]+hy)}}else{for(let Ay=0;Ay<ty;Ay++){const hy=Z0[Ay];Qy(hy[2],hy[1],hy[0])}for(let Ay=0;Ay<ty;Ay++){const hy=Z0[Ay];Qy(hy[0]+H0*j,hy[1]+H0*j,hy[2]+H0*j)}}s.addGroup(B0,d.length/3-B0,0)}function cy(){const B0=d.length/3;let Ay=0;Ty(R0,Ay),Ay+=R0.length;for(let hy=0,Ly=f0.length;hy<Ly;hy++){const Iy=f0[hy];Ty(Iy,Ay),Ay+=Iy.length}s.addGroup(B0,d.length/3-B0,1)}function Ty(B0,Ay){let hy=B0.length;for(;--hy>=0;){const Ly=hy;let Iy=hy-1;Iy<0&&(Iy=B0.length-1);for(let Jy=0,Gy=j+Hn*2;Jy<Gy;Jy++){const sv=H0*Jy,yv=H0*(Jy+1),I0=Ay+Ly+sv,b0=Ay+Iy+sv,uy=Ay+Iy+yv,Ey=Ay+Ly+yv;Zy(I0,b0,uy,Ey)}}}function Uy(B0,Ay,hy){bt.push(B0),bt.push(Ay),bt.push(hy)}function Qy(B0,Ay,hy){iv(B0),iv(Ay),iv(hy);const Ly=d.length/3,Iy=cr.generateTopUV(s,d,Ly-3,Ly-2,Ly-1);zy(Iy[0]),zy(Iy[1]),zy(Iy[2])}function Zy(B0,Ay,hy,Ly){iv(B0),iv(Ay),iv(Ly),iv(Ay),iv(hy),iv(Ly);const Iy=d.length/3,Jy=cr.generateSideWallUV(s,d,Iy-6,Iy-3,Iy-2,Iy-1);zy(Jy[0]),zy(Jy[1]),zy(Jy[3]),zy(Jy[1]),zy(Jy[2]),zy(Jy[3])}function iv(B0){d.push(bt[B0*3+0]),d.push(bt[B0*3+1]),d.push(bt[B0*3+2])}function zy(B0){c.push(B0.x),c.push(B0.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),o=this.parameters.shapes,s=this.parameters.options;return toJSON$1(o,s,e)}static fromJSON(e,o){const s=[];for(let c=0,h=e.shapes.length;c<h;c++){const _=o[e.shapes[c]];s.push(_)}const d=e.options.extrudePath;return d!==void 0&&(e.options.extrudePath=new Curves[d.type]().fromJSON(d)),new ExtrudeGeometry(s,e.options)}}const WorldUVGenerator={generateTopUV:function(a,e,o,s,d){const c=e[o*3],h=e[o*3+1],_=e[s*3],bt=e[s*3+1],g=e[d*3],j=e[d*3+1];return[new Vector2(c,h),new Vector2(_,bt),new Vector2(g,j)]},generateSideWallUV:function(a,e,o,s,d,c){const h=e[o*3],_=e[o*3+1],bt=e[o*3+2],g=e[s*3],j=e[s*3+1],b=e[s*3+2],Et=e[d*3],It=e[d*3+1],zt=e[d*3+2],er=e[c*3],Hn=e[c*3+1],Qt=e[c*3+2];return Math.abs(_-j)<Math.abs(h-g)?[new Vector2(h,1-bt),new Vector2(g,1-b),new Vector2(Et,1-zt),new Vector2(er,1-Qt)]:[new Vector2(_,1-bt),new Vector2(j,1-b),new Vector2(It,1-zt),new Vector2(Hn,1-Qt)]}};function toJSON$1(a,e,o){if(o.shapes=[],Array.isArray(a))for(let s=0,d=a.length;s<d;s++){const c=a[s];o.shapes.push(c.uuid)}else o.shapes.push(a.uuid);return o.options=Object.assign({},e),e.extrudePath!==void 0&&(o.options.extrudePath=e.extrudePath.toJSON()),o}class IcosahedronGeometry extends PolyhedronGeometry{constructor(e=1,o=0){const s=(1+Math.sqrt(5))/2,d=[-1,s,0,1,s,0,-1,-s,0,1,-s,0,0,-1,s,0,1,s,0,-1,-s,0,1,-s,s,0,-1,s,0,1,-s,0,-1,-s,0,1],c=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(d,c,e,o),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:o}}static fromJSON(e){return new IcosahedronGeometry(e.radius,e.detail)}}class OctahedronGeometry extends PolyhedronGeometry{constructor(e=1,o=0){const s=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],d=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(s,d,e,o),this.type="OctahedronGeometry",this.parameters={radius:e,detail:o}}static fromJSON(e){return new OctahedronGeometry(e.radius,e.detail)}}class RingGeometry extends BufferGeometry{constructor(e=.5,o=1,s=32,d=1,c=0,h=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:o,thetaSegments:s,phiSegments:d,thetaStart:c,thetaLength:h},s=Math.max(3,s),d=Math.max(1,d);const _=[],bt=[],g=[],j=[];let b=e;const Et=(o-e)/d,It=new Vector3,zt=new Vector2;for(let er=0;er<=d;er++){for(let Hn=0;Hn<=s;Hn++){const Qt=c+Hn/s*h;It.x=b*Math.cos(Qt),It.y=b*Math.sin(Qt),bt.push(It.x,It.y,It.z),g.push(0,0,1),zt.x=(It.x/o+1)/2,zt.y=(It.y/o+1)/2,j.push(zt.x,zt.y)}b+=Et}for(let er=0;er<d;er++){const Hn=er*(s+1);for(let Qt=0;Qt<s;Qt++){const cr=Qt+Hn,fr=cr,jr=cr+s+1,e0=cr+s+2,t0=cr+1;_.push(fr,jr,t0),_.push(jr,e0,t0)}}this.setIndex(_),this.setAttribute("position",new Float32BufferAttribute(bt,3)),this.setAttribute("normal",new Float32BufferAttribute(g,3)),this.setAttribute("uv",new Float32BufferAttribute(j,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new RingGeometry(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class ShapeGeometry extends BufferGeometry{constructor(e=new Shape([new Vector2(0,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),o=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:o};const s=[],d=[],c=[],h=[];let _=0,bt=0;if(Array.isArray(e)===!1)g(e);else for(let j=0;j<e.length;j++)g(e[j]),this.addGroup(_,bt,j),_+=bt,bt=0;this.setIndex(s),this.setAttribute("position",new Float32BufferAttribute(d,3)),this.setAttribute("normal",new Float32BufferAttribute(c,3)),this.setAttribute("uv",new Float32BufferAttribute(h,2));function g(j){const b=d.length/3,Et=j.extractPoints(o);let It=Et.shape;const zt=Et.holes;ShapeUtils.isClockWise(It)===!1&&(It=It.reverse());for(let Hn=0,Qt=zt.length;Hn<Qt;Hn++){const cr=zt[Hn];ShapeUtils.isClockWise(cr)===!0&&(zt[Hn]=cr.reverse())}const er=ShapeUtils.triangulateShape(It,zt);for(let Hn=0,Qt=zt.length;Hn<Qt;Hn++){const cr=zt[Hn];It=It.concat(cr)}for(let Hn=0,Qt=It.length;Hn<Qt;Hn++){const cr=It[Hn];d.push(cr.x,cr.y,0),c.push(0,0,1),h.push(cr.x,cr.y)}for(let Hn=0,Qt=er.length;Hn<Qt;Hn++){const cr=er[Hn],fr=cr[0]+b,jr=cr[1]+b,e0=cr[2]+b;s.push(fr,jr,e0),bt+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),o=this.parameters.shapes;return toJSON(o,e)}static fromJSON(e,o){const s=[];for(let d=0,c=e.shapes.length;d<c;d++){const h=o[e.shapes[d]];s.push(h)}return new ShapeGeometry(s,e.curveSegments)}}function toJSON(a,e){if(e.shapes=[],Array.isArray(a))for(let o=0,s=a.length;o<s;o++){const d=a[o];e.shapes.push(d.uuid)}else e.shapes.push(a.uuid);return e}class SphereGeometry extends BufferGeometry{constructor(e=1,o=32,s=16,d=0,c=Math.PI*2,h=0,_=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:o,heightSegments:s,phiStart:d,phiLength:c,thetaStart:h,thetaLength:_},o=Math.max(3,Math.floor(o)),s=Math.max(2,Math.floor(s));const bt=Math.min(h+_,Math.PI);let g=0;const j=[],b=new Vector3,Et=new Vector3,It=[],zt=[],er=[],Hn=[];for(let Qt=0;Qt<=s;Qt++){const cr=[],fr=Qt/s;let jr=0;Qt===0&&h===0?jr=.5/o:Qt===s&&bt===Math.PI&&(jr=-.5/o);for(let e0=0;e0<=o;e0++){const t0=e0/o;b.x=-e*Math.cos(d+t0*c)*Math.sin(h+fr*_),b.y=e*Math.cos(h+fr*_),b.z=e*Math.sin(d+t0*c)*Math.sin(h+fr*_),zt.push(b.x,b.y,b.z),Et.copy(b).normalize(),er.push(Et.x,Et.y,Et.z),Hn.push(t0+jr,1-fr),cr.push(g++)}j.push(cr)}for(let Qt=0;Qt<s;Qt++)for(let cr=0;cr<o;cr++){const fr=j[Qt][cr+1],jr=j[Qt][cr],e0=j[Qt+1][cr],t0=j[Qt+1][cr+1];(Qt!==0||h>0)&&It.push(fr,jr,t0),(Qt!==s-1||bt<Math.PI)&&It.push(jr,e0,t0)}this.setIndex(It),this.setAttribute("position",new Float32BufferAttribute(zt,3)),this.setAttribute("normal",new Float32BufferAttribute(er,3)),this.setAttribute("uv",new Float32BufferAttribute(Hn,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new SphereGeometry(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class TetrahedronGeometry extends PolyhedronGeometry{constructor(e=1,o=0){const s=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],d=[2,1,0,0,3,2,1,3,0,2,3,1];super(s,d,e,o),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:o}}static fromJSON(e){return new TetrahedronGeometry(e.radius,e.detail)}}class TorusGeometry extends BufferGeometry{constructor(e=1,o=.4,s=12,d=48,c=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:o,radialSegments:s,tubularSegments:d,arc:c},s=Math.floor(s),d=Math.floor(d);const h=[],_=[],bt=[],g=[],j=new Vector3,b=new Vector3,Et=new Vector3;for(let It=0;It<=s;It++)for(let zt=0;zt<=d;zt++){const er=zt/d*c,Hn=It/s*Math.PI*2;b.x=(e+o*Math.cos(Hn))*Math.cos(er),b.y=(e+o*Math.cos(Hn))*Math.sin(er),b.z=o*Math.sin(Hn),_.push(b.x,b.y,b.z),j.x=e*Math.cos(er),j.y=e*Math.sin(er),Et.subVectors(b,j).normalize(),bt.push(Et.x,Et.y,Et.z),g.push(zt/d),g.push(It/s)}for(let It=1;It<=s;It++)for(let zt=1;zt<=d;zt++){const er=(d+1)*It+zt-1,Hn=(d+1)*(It-1)+zt-1,Qt=(d+1)*(It-1)+zt,cr=(d+1)*It+zt;h.push(er,Hn,cr),h.push(Hn,Qt,cr)}this.setIndex(h),this.setAttribute("position",new Float32BufferAttribute(_,3)),this.setAttribute("normal",new Float32BufferAttribute(bt,3)),this.setAttribute("uv",new Float32BufferAttribute(g,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new TorusGeometry(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class TorusKnotGeometry extends BufferGeometry{constructor(e=1,o=.4,s=64,d=8,c=2,h=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:o,tubularSegments:s,radialSegments:d,p:c,q:h},s=Math.floor(s),d=Math.floor(d);const _=[],bt=[],g=[],j=[],b=new Vector3,Et=new Vector3,It=new Vector3,zt=new Vector3,er=new Vector3,Hn=new Vector3,Qt=new Vector3;for(let fr=0;fr<=s;++fr){const jr=fr/s*c*Math.PI*2;cr(jr,c,h,e,It),cr(jr+.01,c,h,e,zt),Hn.subVectors(zt,It),Qt.addVectors(zt,It),er.crossVectors(Hn,Qt),Qt.crossVectors(er,Hn),er.normalize(),Qt.normalize();for(let e0=0;e0<=d;++e0){const t0=e0/d*Math.PI*2,o0=-o*Math.cos(t0),l0=o*Math.sin(t0);b.x=It.x+(o0*Qt.x+l0*er.x),b.y=It.y+(o0*Qt.y+l0*er.y),b.z=It.z+(o0*Qt.z+l0*er.z),bt.push(b.x,b.y,b.z),Et.subVectors(b,It).normalize(),g.push(Et.x,Et.y,Et.z),j.push(fr/s),j.push(e0/d)}}for(let fr=1;fr<=s;fr++)for(let jr=1;jr<=d;jr++){const e0=(d+1)*(fr-1)+(jr-1),t0=(d+1)*fr+(jr-1),o0=(d+1)*fr+jr,l0=(d+1)*(fr-1)+jr;_.push(e0,t0,l0),_.push(t0,o0,l0)}this.setIndex(_),this.setAttribute("position",new Float32BufferAttribute(bt,3)),this.setAttribute("normal",new Float32BufferAttribute(g,3)),this.setAttribute("uv",new Float32BufferAttribute(j,2));function cr(fr,jr,e0,t0,o0){const l0=Math.cos(fr),g0=Math.sin(fr),i0=e0/jr*fr,f0=Math.cos(i0);o0.x=t0*(2+f0)*.5*l0,o0.y=t0*(2+f0)*g0*.5,o0.z=t0*Math.sin(i0)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new TorusKnotGeometry(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class TubeGeometry extends BufferGeometry{constructor(e=new QuadraticBezierCurve3(new Vector3(-1,-1,0),new Vector3(-1,1,0),new Vector3(1,1,0)),o=64,s=1,d=8,c=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:o,radius:s,radialSegments:d,closed:c};const h=e.computeFrenetFrames(o,c);this.tangents=h.tangents,this.normals=h.normals,this.binormals=h.binormals;const _=new Vector3,bt=new Vector3,g=new Vector2;let j=new Vector3;const b=[],Et=[],It=[],zt=[];er(),this.setIndex(zt),this.setAttribute("position",new Float32BufferAttribute(b,3)),this.setAttribute("normal",new Float32BufferAttribute(Et,3)),this.setAttribute("uv",new Float32BufferAttribute(It,2));function er(){for(let fr=0;fr<o;fr++)Hn(fr);Hn(c===!1?o:0),cr(),Qt()}function Hn(fr){j=e.getPointAt(fr/o,j);const jr=h.normals[fr],e0=h.binormals[fr];for(let t0=0;t0<=d;t0++){const o0=t0/d*Math.PI*2,l0=Math.sin(o0),g0=-Math.cos(o0);bt.x=g0*jr.x+l0*e0.x,bt.y=g0*jr.y+l0*e0.y,bt.z=g0*jr.z+l0*e0.z,bt.normalize(),Et.push(bt.x,bt.y,bt.z),_.x=j.x+s*bt.x,_.y=j.y+s*bt.y,_.z=j.z+s*bt.z,b.push(_.x,_.y,_.z)}}function Qt(){for(let fr=1;fr<=o;fr++)for(let jr=1;jr<=d;jr++){const e0=(d+1)*(fr-1)+(jr-1),t0=(d+1)*fr+(jr-1),o0=(d+1)*fr+jr,l0=(d+1)*(fr-1)+jr;zt.push(e0,t0,l0),zt.push(t0,o0,l0)}}function cr(){for(let fr=0;fr<=o;fr++)for(let jr=0;jr<=d;jr++)g.x=fr/o,g.y=jr/d,It.push(g.x,g.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new TubeGeometry(new Curves[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class WireframeGeometry extends BufferGeometry{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const o=[],s=new Set,d=new Vector3,c=new Vector3;if(e.index!==null){const h=e.attributes.position,_=e.index;let bt=e.groups;bt.length===0&&(bt=[{start:0,count:_.count,materialIndex:0}]);for(let g=0,j=bt.length;g<j;++g){const b=bt[g],Et=b.start,It=b.count;for(let zt=Et,er=Et+It;zt<er;zt+=3)for(let Hn=0;Hn<3;Hn++){const Qt=_.getX(zt+Hn),cr=_.getX(zt+(Hn+1)%3);d.fromBufferAttribute(h,Qt),c.fromBufferAttribute(h,cr),isUniqueEdge(d,c,s)===!0&&(o.push(d.x,d.y,d.z),o.push(c.x,c.y,c.z))}}}else{const h=e.attributes.position;for(let _=0,bt=h.count/3;_<bt;_++)for(let g=0;g<3;g++){const j=3*_+g,b=3*_+(g+1)%3;d.fromBufferAttribute(h,j),c.fromBufferAttribute(h,b),isUniqueEdge(d,c,s)===!0&&(o.push(d.x,d.y,d.z),o.push(c.x,c.y,c.z))}}this.setAttribute("position",new Float32BufferAttribute(o,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function isUniqueEdge(a,e,o){const s=`${a.x},${a.y},${a.z}-${e.x},${e.y},${e.z}`,d=`${e.x},${e.y},${e.z}-${a.x},${a.y},${a.z}`;return o.has(s)===!0||o.has(d)===!0?!1:(o.add(s),o.add(d),!0)}var Geometries=Object.freeze({__proto__:null,BoxGeometry,CapsuleGeometry,CircleGeometry,ConeGeometry,CylinderGeometry,DodecahedronGeometry,EdgesGeometry,ExtrudeGeometry,IcosahedronGeometry,LatheGeometry,OctahedronGeometry,PlaneGeometry,PolyhedronGeometry,RingGeometry,ShapeGeometry,SphereGeometry,TetrahedronGeometry,TorusGeometry,TorusKnotGeometry,TubeGeometry,WireframeGeometry});class ShadowMaterial extends Material{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Color(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class RawShaderMaterial extends ShaderMaterial{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class MeshStandardMaterial extends Material{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Color(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class MeshPhysicalMaterial extends MeshStandardMaterial{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Vector2(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return clamp(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(o){this.ior=(1+.4*o)/(1-.4*o)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Color(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Color(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Color(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class MeshPhongMaterial extends Material{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Color(16777215),this.specular=new Color(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class MeshToonMaterial extends Material{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Color(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class MeshNormalMaterial extends Material{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class MeshLambertMaterial extends Material{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class MeshMatcapMaterial extends Material{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Color(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class LineDashedMaterial extends LineBasicMaterial{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function convertArray(a,e,o){return!a||!o&&a.constructor===e?a:typeof e.BYTES_PER_ELEMENT=="number"?new e(a):Array.prototype.slice.call(a)}function isTypedArray(a){return ArrayBuffer.isView(a)&&!(a instanceof DataView)}function getKeyframeOrder(a){function e(d,c){return a[d]-a[c]}const o=a.length,s=new Array(o);for(let d=0;d!==o;++d)s[d]=d;return s.sort(e),s}function sortedArray(a,e,o){const s=a.length,d=new a.constructor(s);for(let c=0,h=0;h!==s;++c){const _=o[c]*e;for(let bt=0;bt!==e;++bt)d[h++]=a[_+bt]}return d}function flattenJSON(a,e,o,s){let d=1,c=a[0];for(;c!==void 0&&c[s]===void 0;)c=a[d++];if(c===void 0)return;let h=c[s];if(h!==void 0)if(Array.isArray(h))do h=c[s],h!==void 0&&(e.push(c.time),o.push.apply(o,h)),c=a[d++];while(c!==void 0);else if(h.toArray!==void 0)do h=c[s],h!==void 0&&(e.push(c.time),h.toArray(o,o.length)),c=a[d++];while(c!==void 0);else do h=c[s],h!==void 0&&(e.push(c.time),o.push(h)),c=a[d++];while(c!==void 0)}function subclip(a,e,o,s,d=30){const c=a.clone();c.name=e;const h=[];for(let bt=0;bt<c.tracks.length;++bt){const g=c.tracks[bt],j=g.getValueSize(),b=[],Et=[];for(let It=0;It<g.times.length;++It){const zt=g.times[It]*d;if(!(zt<o||zt>=s)){b.push(g.times[It]);for(let er=0;er<j;++er)Et.push(g.values[It*j+er])}}b.length!==0&&(g.times=convertArray(b,g.times.constructor),g.values=convertArray(Et,g.values.constructor),h.push(g))}c.tracks=h;let _=1/0;for(let bt=0;bt<c.tracks.length;++bt)_>c.tracks[bt].times[0]&&(_=c.tracks[bt].times[0]);for(let bt=0;bt<c.tracks.length;++bt)c.tracks[bt].shift(-1*_);return c.resetDuration(),c}function makeClipAdditive(a,e=0,o=a,s=30){s<=0&&(s=30);const d=o.tracks.length,c=e/s;for(let h=0;h<d;++h){const _=o.tracks[h],bt=_.ValueTypeName;if(bt==="bool"||bt==="string")continue;const g=a.tracks.find(function(Qt){return Qt.name===_.name&&Qt.ValueTypeName===bt});if(g===void 0)continue;let j=0;const b=_.getValueSize();_.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(j=b/3);let Et=0;const It=g.getValueSize();g.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(Et=It/3);const zt=_.times.length-1;let er;if(c<=_.times[0]){const Qt=j,cr=b-j;er=_.values.slice(Qt,cr)}else if(c>=_.times[zt]){const Qt=zt*b+j,cr=Qt+b-j;er=_.values.slice(Qt,cr)}else{const Qt=_.createInterpolant(),cr=j,fr=b-j;Qt.evaluate(c),er=Qt.resultBuffer.slice(cr,fr)}bt==="quaternion"&&new Quaternion().fromArray(er).normalize().conjugate().toArray(er);const Hn=g.times.length;for(let Qt=0;Qt<Hn;++Qt){const cr=Qt*It+Et;if(bt==="quaternion")Quaternion.multiplyQuaternionsFlat(g.values,cr,er,0,g.values,cr);else{const fr=It-Et*2;for(let jr=0;jr<fr;++jr)g.values[cr+jr]-=er[jr]}}}return a.blendMode=AdditiveAnimationBlendMode,a}const AnimationUtils={convertArray,isTypedArray,getKeyframeOrder,sortedArray,flattenJSON,subclip,makeClipAdditive};class Interpolant{constructor(e,o,s,d){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=d!==void 0?d:new o.constructor(s),this.sampleValues=o,this.valueSize=s,this.settings=null,this.DefaultSettings_={}}evaluate(e){const o=this.parameterPositions;let s=this._cachedIndex,d=o[s],c=o[s-1];e:{t:{let h;n:{r:if(!(e<d)){for(let _=s+2;;){if(d===void 0){if(e<c)break r;return s=o.length,this._cachedIndex=s,this.copySampleValue_(s-1)}if(s===_)break;if(c=d,d=o[++s],e<d)break t}h=o.length;break n}if(!(e>=c)){const _=o[1];e<_&&(s=2,c=_);for(let bt=s-2;;){if(c===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===bt)break;if(d=c,c=o[--s-1],e>=c)break t}h=s,s=0;break n}break e}for(;s<h;){const _=s+h>>>1;e<o[_]?h=_:s=_+1}if(d=o[s],c=o[s-1],c===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(d===void 0)return s=o.length,this._cachedIndex=s,this.copySampleValue_(s-1)}this._cachedIndex=s,this.intervalChanged_(s,c,d)}return this.interpolate_(s,c,e,d)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const o=this.resultBuffer,s=this.sampleValues,d=this.valueSize,c=e*d;for(let h=0;h!==d;++h)o[h]=s[c+h];return o}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class CubicInterpolant extends Interpolant{constructor(e,o,s,d){super(e,o,s,d),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding}}intervalChanged_(e,o,s){const d=this.parameterPositions;let c=e-2,h=e+1,_=d[c],bt=d[h];if(_===void 0)switch(this.getSettings_().endingStart){case ZeroSlopeEnding:c=e,_=2*o-s;break;case WrapAroundEnding:c=d.length-2,_=o+d[c]-d[c+1];break;default:c=e,_=s}if(bt===void 0)switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:h=e,bt=2*s-o;break;case WrapAroundEnding:h=1,bt=s+d[1]-d[0];break;default:h=e-1,bt=o}const g=(s-o)*.5,j=this.valueSize;this._weightPrev=g/(o-_),this._weightNext=g/(bt-s),this._offsetPrev=c*j,this._offsetNext=h*j}interpolate_(e,o,s,d){const c=this.resultBuffer,h=this.sampleValues,_=this.valueSize,bt=e*_,g=bt-_,j=this._offsetPrev,b=this._offsetNext,Et=this._weightPrev,It=this._weightNext,zt=(s-o)/(d-o),er=zt*zt,Hn=er*zt,Qt=-Et*Hn+2*Et*er-Et*zt,cr=(1+Et)*Hn+(-1.5-2*Et)*er+(-.5+Et)*zt+1,fr=(-1-It)*Hn+(1.5+It)*er+.5*zt,jr=It*Hn-It*er;for(let e0=0;e0!==_;++e0)c[e0]=Qt*h[j+e0]+cr*h[g+e0]+fr*h[bt+e0]+jr*h[b+e0];return c}}class LinearInterpolant extends Interpolant{constructor(e,o,s,d){super(e,o,s,d)}interpolate_(e,o,s,d){const c=this.resultBuffer,h=this.sampleValues,_=this.valueSize,bt=e*_,g=bt-_,j=(s-o)/(d-o),b=1-j;for(let Et=0;Et!==_;++Et)c[Et]=h[g+Et]*b+h[bt+Et]*j;return c}}class DiscreteInterpolant extends Interpolant{constructor(e,o,s,d){super(e,o,s,d)}interpolate_(e){return this.copySampleValue_(e-1)}}class KeyframeTrack{constructor(e,o,s,d){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(o===void 0||o.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=convertArray(o,this.TimeBufferType),this.values=convertArray(s,this.ValueBufferType),this.setInterpolation(d||this.DefaultInterpolation)}static toJSON(e){const o=e.constructor;let s;if(o.toJSON!==this.toJSON)s=o.toJSON(e);else{s={name:e.name,times:convertArray(e.times,Array),values:convertArray(e.values,Array)};const d=e.getInterpolation();d!==e.DefaultInterpolation&&(s.interpolation=d)}return s.type=e.ValueTypeName,s}InterpolantFactoryMethodDiscrete(e){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new LinearInterpolant(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new CubicInterpolant(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let o;switch(e){case InterpolateDiscrete:o=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:o=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:o=this.InterpolantFactoryMethodSmooth;break}if(o===void 0){const s="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(s);return console.warn("THREE.KeyframeTrack:",s),this}return this.createInterpolant=o,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const o=this.times;for(let s=0,d=o.length;s!==d;++s)o[s]+=e}return this}scale(e){if(e!==1){const o=this.times;for(let s=0,d=o.length;s!==d;++s)o[s]*=e}return this}trim(e,o){const s=this.times,d=s.length;let c=0,h=d-1;for(;c!==d&&s[c]<e;)++c;for(;h!==-1&&s[h]>o;)--h;if(++h,c!==0||h!==d){c>=h&&(h=Math.max(h,1),c=h-1);const _=this.getValueSize();this.times=s.slice(c,h),this.values=this.values.slice(c*_,h*_)}return this}validate(){let e=!0;const o=this.getValueSize();o-Math.floor(o)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const s=this.times,d=this.values,c=s.length;c===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let h=null;for(let _=0;_!==c;_++){const bt=s[_];if(typeof bt=="number"&&isNaN(bt)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,_,bt),e=!1;break}if(h!==null&&h>bt){console.error("THREE.KeyframeTrack: Out of order keys.",this,_,bt,h),e=!1;break}h=bt}if(d!==void 0&&isTypedArray(d))for(let _=0,bt=d.length;_!==bt;++_){const g=d[_];if(isNaN(g)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,_,g),e=!1;break}}return e}optimize(){const e=this.times.slice(),o=this.values.slice(),s=this.getValueSize(),d=this.getInterpolation()===InterpolateSmooth,c=e.length-1;let h=1;for(let _=1;_<c;++_){let bt=!1;const g=e[_],j=e[_+1];if(g!==j&&(_!==1||g!==e[0]))if(d)bt=!0;else{const b=_*s,Et=b-s,It=b+s;for(let zt=0;zt!==s;++zt){const er=o[b+zt];if(er!==o[Et+zt]||er!==o[It+zt]){bt=!0;break}}}if(bt){if(_!==h){e[h]=e[_];const b=_*s,Et=h*s;for(let It=0;It!==s;++It)o[Et+It]=o[b+It]}++h}}if(c>0){e[h]=e[c];for(let _=c*s,bt=h*s,g=0;g!==s;++g)o[bt+g]=o[_+g];++h}return h!==e.length?(this.times=e.slice(0,h),this.values=o.slice(0,h*s)):(this.times=e,this.values=o),this}clone(){const e=this.times.slice(),o=this.values.slice(),s=this.constructor,d=new s(this.name,e,o);return d.createInterpolant=this.createInterpolant,d}}KeyframeTrack.prototype.TimeBufferType=Float32Array;KeyframeTrack.prototype.ValueBufferType=Float32Array;KeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;class BooleanKeyframeTrack extends KeyframeTrack{}BooleanKeyframeTrack.prototype.ValueTypeName="bool";BooleanKeyframeTrack.prototype.ValueBufferType=Array;BooleanKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class ColorKeyframeTrack extends KeyframeTrack{}ColorKeyframeTrack.prototype.ValueTypeName="color";class NumberKeyframeTrack extends KeyframeTrack{}NumberKeyframeTrack.prototype.ValueTypeName="number";class QuaternionLinearInterpolant extends Interpolant{constructor(e,o,s,d){super(e,o,s,d)}interpolate_(e,o,s,d){const c=this.resultBuffer,h=this.sampleValues,_=this.valueSize,bt=(s-o)/(d-o);let g=e*_;for(let j=g+_;g!==j;g+=4)Quaternion.slerpFlat(c,0,h,g-_,h,g,bt);return c}}class QuaternionKeyframeTrack extends KeyframeTrack{InterpolantFactoryMethodLinear(e){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),e)}}QuaternionKeyframeTrack.prototype.ValueTypeName="quaternion";QuaternionKeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class StringKeyframeTrack extends KeyframeTrack{}StringKeyframeTrack.prototype.ValueTypeName="string";StringKeyframeTrack.prototype.ValueBufferType=Array;StringKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class VectorKeyframeTrack extends KeyframeTrack{}VectorKeyframeTrack.prototype.ValueTypeName="vector";class AnimationClip{constructor(e,o=-1,s,d=NormalAnimationBlendMode){this.name=e,this.tracks=s,this.duration=o,this.blendMode=d,this.uuid=generateUUID(),this.duration<0&&this.resetDuration()}static parse(e){const o=[],s=e.tracks,d=1/(e.fps||1);for(let h=0,_=s.length;h!==_;++h)o.push(parseKeyframeTrack(s[h]).scale(d));const c=new this(e.name,e.duration,o,e.blendMode);return c.uuid=e.uuid,c}static toJSON(e){const o=[],s=e.tracks,d={name:e.name,duration:e.duration,tracks:o,uuid:e.uuid,blendMode:e.blendMode};for(let c=0,h=s.length;c!==h;++c)o.push(KeyframeTrack.toJSON(s[c]));return d}static CreateFromMorphTargetSequence(e,o,s,d){const c=o.length,h=[];for(let _=0;_<c;_++){let bt=[],g=[];bt.push((_+c-1)%c,_,(_+1)%c),g.push(0,1,0);const j=getKeyframeOrder(bt);bt=sortedArray(bt,1,j),g=sortedArray(g,1,j),!d&&bt[0]===0&&(bt.push(c),g.push(g[0])),h.push(new NumberKeyframeTrack(".morphTargetInfluences["+o[_].name+"]",bt,g).scale(1/s))}return new this(e,-1,h)}static findByName(e,o){let s=e;if(!Array.isArray(e)){const d=e;s=d.geometry&&d.geometry.animations||d.animations}for(let d=0;d<s.length;d++)if(s[d].name===o)return s[d];return null}static CreateClipsFromMorphTargetSequences(e,o,s){const d={},c=/^([\w-]*?)([\d]+)$/;for(let _=0,bt=e.length;_<bt;_++){const g=e[_],j=g.name.match(c);if(j&&j.length>1){const b=j[1];let Et=d[b];Et||(d[b]=Et=[]),Et.push(g)}}const h=[];for(const _ in d)h.push(this.CreateFromMorphTargetSequence(_,d[_],o,s));return h}static parseAnimation(e,o){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const s=function(b,Et,It,zt,er){if(It.length!==0){const Hn=[],Qt=[];flattenJSON(It,Hn,Qt,zt),Hn.length!==0&&er.push(new b(Et,Hn,Qt))}},d=[],c=e.name||"default",h=e.fps||30,_=e.blendMode;let bt=e.length||-1;const g=e.hierarchy||[];for(let b=0;b<g.length;b++){const Et=g[b].keys;if(!(!Et||Et.length===0))if(Et[0].morphTargets){const It={};let zt;for(zt=0;zt<Et.length;zt++)if(Et[zt].morphTargets)for(let er=0;er<Et[zt].morphTargets.length;er++)It[Et[zt].morphTargets[er]]=-1;for(const er in It){const Hn=[],Qt=[];for(let cr=0;cr!==Et[zt].morphTargets.length;++cr){const fr=Et[zt];Hn.push(fr.time),Qt.push(fr.morphTarget===er?1:0)}d.push(new NumberKeyframeTrack(".morphTargetInfluence["+er+"]",Hn,Qt))}bt=It.length*h}else{const It=".bones["+o[b].name+"]";s(VectorKeyframeTrack,It+".position",Et,"pos",d),s(QuaternionKeyframeTrack,It+".quaternion",Et,"rot",d),s(VectorKeyframeTrack,It+".scale",Et,"scl",d)}}return d.length===0?null:new this(c,bt,d,_)}resetDuration(){const e=this.tracks;let o=0;for(let s=0,d=e.length;s!==d;++s){const c=this.tracks[s];o=Math.max(o,c.times[c.times.length-1])}return this.duration=o,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let o=0;o<this.tracks.length;o++)e=e&&this.tracks[o].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let o=0;o<this.tracks.length;o++)e.push(this.tracks[o].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function getTrackTypeForValueTypeName(a){switch(a.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+a)}function parseKeyframeTrack(a){if(a.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=getTrackTypeForValueTypeName(a.type);if(a.times===void 0){const o=[],s=[];flattenJSON(a.keys,o,s,"value"),a.times=o,a.values=s}return e.parse!==void 0?e.parse(a):new e(a.name,a.times,a.values,a.interpolation)}const Cache={enabled:!1,files:{},add:function(a,e){this.enabled!==!1&&(this.files[a]=e)},get:function(a){if(this.enabled!==!1)return this.files[a]},remove:function(a){delete this.files[a]},clear:function(){this.files={}}};class LoadingManager{constructor(e,o,s){const d=this;let c=!1,h=0,_=0,bt;const g=[];this.onStart=void 0,this.onLoad=e,this.onProgress=o,this.onError=s,this.itemStart=function(j){_++,c===!1&&d.onStart!==void 0&&d.onStart(j,h,_),c=!0},this.itemEnd=function(j){h++,d.onProgress!==void 0&&d.onProgress(j,h,_),h===_&&(c=!1,d.onLoad!==void 0&&d.onLoad())},this.itemError=function(j){d.onError!==void 0&&d.onError(j)},this.resolveURL=function(j){return bt?bt(j):j},this.setURLModifier=function(j){return bt=j,this},this.addHandler=function(j,b){return g.push(j,b),this},this.removeHandler=function(j){const b=g.indexOf(j);return b!==-1&&g.splice(b,2),this},this.getHandler=function(j){for(let b=0,Et=g.length;b<Et;b+=2){const It=g[b],zt=g[b+1];if(It.global&&(It.lastIndex=0),It.test(j))return zt}return null}}}const DefaultLoadingManager=new LoadingManager;class Loader{constructor(e){this.manager=e!==void 0?e:DefaultLoadingManager,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,o){const s=this;return new Promise(function(d,c){s.load(e,d,o,c)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}Loader.DEFAULT_MATERIAL_NAME="__DEFAULT";const loading={};class HttpError extends Error{constructor(e,o){super(e),this.response=o}}class FileLoader extends Loader{constructor(e){super(e)}load(e,o,s,d){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const c=Cache.get(e);if(c!==void 0)return this.manager.itemStart(e),setTimeout(()=>{o&&o(c),this.manager.itemEnd(e)},0),c;if(loading[e]!==void 0){loading[e].push({onLoad:o,onProgress:s,onError:d});return}loading[e]=[],loading[e].push({onLoad:o,onProgress:s,onError:d});const h=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),_=this.mimeType,bt=this.responseType;fetch(h).then(g=>{if(g.status===200||g.status===0){if(g.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||g.body===void 0||g.body.getReader===void 0)return g;const j=loading[e],b=g.body.getReader(),Et=g.headers.get("Content-Length")||g.headers.get("X-File-Size"),It=Et?parseInt(Et):0,zt=It!==0;let er=0;const Hn=new ReadableStream({start(Qt){cr();function cr(){b.read().then(({done:fr,value:jr})=>{if(fr)Qt.close();else{er+=jr.byteLength;const e0=new ProgressEvent("progress",{lengthComputable:zt,loaded:er,total:It});for(let t0=0,o0=j.length;t0<o0;t0++){const l0=j[t0];l0.onProgress&&l0.onProgress(e0)}Qt.enqueue(jr),cr()}})}}});return new Response(Hn)}else throw new HttpError(`fetch for "${g.url}" responded with ${g.status}: ${g.statusText}`,g)}).then(g=>{switch(bt){case"arraybuffer":return g.arrayBuffer();case"blob":return g.blob();case"document":return g.text().then(j=>new DOMParser().parseFromString(j,_));case"json":return g.json();default:if(_===void 0)return g.text();{const b=/charset="?([^;"\s]*)"?/i.exec(_),Et=b&&b[1]?b[1].toLowerCase():void 0,It=new TextDecoder(Et);return g.arrayBuffer().then(zt=>It.decode(zt))}}}).then(g=>{Cache.add(e,g);const j=loading[e];delete loading[e];for(let b=0,Et=j.length;b<Et;b++){const It=j[b];It.onLoad&&It.onLoad(g)}}).catch(g=>{const j=loading[e];if(j===void 0)throw this.manager.itemError(e),g;delete loading[e];for(let b=0,Et=j.length;b<Et;b++){const It=j[b];It.onError&&It.onError(g)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class AnimationLoader extends Loader{constructor(e){super(e)}load(e,o,s,d){const c=this,h=new FileLoader(this.manager);h.setPath(this.path),h.setRequestHeader(this.requestHeader),h.setWithCredentials(this.withCredentials),h.load(e,function(_){try{o(c.parse(JSON.parse(_)))}catch(bt){d?d(bt):console.error(bt),c.manager.itemError(e)}},s,d)}parse(e){const o=[];for(let s=0;s<e.length;s++){const d=AnimationClip.parse(e[s]);o.push(d)}return o}}class CompressedTextureLoader extends Loader{constructor(e){super(e)}load(e,o,s,d){const c=this,h=[],_=new CompressedTexture,bt=new FileLoader(this.manager);bt.setPath(this.path),bt.setResponseType("arraybuffer"),bt.setRequestHeader(this.requestHeader),bt.setWithCredentials(c.withCredentials);let g=0;function j(b){bt.load(e[b],function(Et){const It=c.parse(Et,!0);h[b]={width:It.width,height:It.height,format:It.format,mipmaps:It.mipmaps},g+=1,g===6&&(It.mipmapCount===1&&(_.minFilter=LinearFilter),_.image=h,_.format=It.format,_.needsUpdate=!0,o&&o(_))},s,d)}if(Array.isArray(e))for(let b=0,Et=e.length;b<Et;++b)j(b);else bt.load(e,function(b){const Et=c.parse(b,!0);if(Et.isCubemap){const It=Et.mipmaps.length/Et.mipmapCount;for(let zt=0;zt<It;zt++){h[zt]={mipmaps:[]};for(let er=0;er<Et.mipmapCount;er++)h[zt].mipmaps.push(Et.mipmaps[zt*Et.mipmapCount+er]),h[zt].format=Et.format,h[zt].width=Et.width,h[zt].height=Et.height}_.image=h}else _.image.width=Et.width,_.image.height=Et.height,_.mipmaps=Et.mipmaps;Et.mipmapCount===1&&(_.minFilter=LinearFilter),_.format=Et.format,_.needsUpdate=!0,o&&o(_)},s,d);return _}}class ImageLoader extends Loader{constructor(e){super(e)}load(e,o,s,d){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const c=this,h=Cache.get(e);if(h!==void 0)return c.manager.itemStart(e),setTimeout(function(){o&&o(h),c.manager.itemEnd(e)},0),h;const _=createElementNS("img");function bt(){j(),Cache.add(e,this),o&&o(this),c.manager.itemEnd(e)}function g(b){j(),d&&d(b),c.manager.itemError(e),c.manager.itemEnd(e)}function j(){_.removeEventListener("load",bt,!1),_.removeEventListener("error",g,!1)}return _.addEventListener("load",bt,!1),_.addEventListener("error",g,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(_.crossOrigin=this.crossOrigin),c.manager.itemStart(e),_.src=e,_}}class CubeTextureLoader extends Loader{constructor(e){super(e)}load(e,o,s,d){const c=new CubeTexture;c.colorSpace=SRGBColorSpace;const h=new ImageLoader(this.manager);h.setCrossOrigin(this.crossOrigin),h.setPath(this.path);let _=0;function bt(g){h.load(e[g],function(j){c.images[g]=j,_++,_===6&&(c.needsUpdate=!0,o&&o(c))},void 0,d)}for(let g=0;g<e.length;++g)bt(g);return c}}class DataTextureLoader extends Loader{constructor(e){super(e)}load(e,o,s,d){const c=this,h=new DataTexture,_=new FileLoader(this.manager);return _.setResponseType("arraybuffer"),_.setRequestHeader(this.requestHeader),_.setPath(this.path),_.setWithCredentials(c.withCredentials),_.load(e,function(bt){let g;try{g=c.parse(bt)}catch(j){if(d!==void 0)d(j);else{console.error(j);return}}g.image!==void 0?h.image=g.image:g.data!==void 0&&(h.image.width=g.width,h.image.height=g.height,h.image.data=g.data),h.wrapS=g.wrapS!==void 0?g.wrapS:ClampToEdgeWrapping,h.wrapT=g.wrapT!==void 0?g.wrapT:ClampToEdgeWrapping,h.magFilter=g.magFilter!==void 0?g.magFilter:LinearFilter,h.minFilter=g.minFilter!==void 0?g.minFilter:LinearFilter,h.anisotropy=g.anisotropy!==void 0?g.anisotropy:1,g.colorSpace!==void 0&&(h.colorSpace=g.colorSpace),g.flipY!==void 0&&(h.flipY=g.flipY),g.format!==void 0&&(h.format=g.format),g.type!==void 0&&(h.type=g.type),g.mipmaps!==void 0&&(h.mipmaps=g.mipmaps,h.minFilter=LinearMipmapLinearFilter),g.mipmapCount===1&&(h.minFilter=LinearFilter),g.generateMipmaps!==void 0&&(h.generateMipmaps=g.generateMipmaps),h.needsUpdate=!0,o&&o(h,g)},s,d),h}}class TextureLoader extends Loader{constructor(e){super(e)}load(e,o,s,d){const c=new Texture,h=new ImageLoader(this.manager);return h.setCrossOrigin(this.crossOrigin),h.setPath(this.path),h.load(e,function(_){c.image=_,c.needsUpdate=!0,o!==void 0&&o(c)},s,d),c}}class Light extends Object3D{constructor(e,o=1){super(),this.isLight=!0,this.type="Light",this.color=new Color(e),this.intensity=o}dispose(){}copy(e,o){return super.copy(e,o),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const o=super.toJSON(e);return o.object.color=this.color.getHex(),o.object.intensity=this.intensity,this.groundColor!==void 0&&(o.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(o.object.distance=this.distance),this.angle!==void 0&&(o.object.angle=this.angle),this.decay!==void 0&&(o.object.decay=this.decay),this.penumbra!==void 0&&(o.object.penumbra=this.penumbra),this.shadow!==void 0&&(o.object.shadow=this.shadow.toJSON()),o}}class HemisphereLight extends Light{constructor(e,o,s){super(e,s),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Color(o)}copy(e,o){return super.copy(e,o),this.groundColor.copy(e.groundColor),this}}const _projScreenMatrix$1=new Matrix4,_lightPositionWorld$1=new Vector3,_lookTarget$1=new Vector3;class LightShadow{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Vector2(512,512),this.map=null,this.mapPass=null,this.matrix=new Matrix4,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Frustum,this._frameExtents=new Vector2(1,1),this._viewportCount=1,this._viewports=[new Vector4(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const o=this.camera,s=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(e.matrixWorld),o.position.copy(_lightPositionWorld$1),_lookTarget$1.setFromMatrixPosition(e.target.matrixWorld),o.lookAt(_lookTarget$1),o.updateMatrixWorld(),_projScreenMatrix$1.multiplyMatrices(o.projectionMatrix,o.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix$1),s.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.multiply(_projScreenMatrix$1)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class SpotLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const o=this.camera,s=RAD2DEG*2*e.angle*this.focus,d=this.mapSize.width/this.mapSize.height,c=e.distance||o.far;(s!==o.fov||d!==o.aspect||c!==o.far)&&(o.fov=s,o.aspect=d,o.far=c,o.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class SpotLight extends Light{constructor(e,o,s=0,d=Math.PI/3,c=0,h=2){super(e,o),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.distance=s,this.angle=d,this.penumbra=c,this.decay=h,this.map=null,this.shadow=new SpotLightShadow}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,o){return super.copy(e,o),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const _projScreenMatrix=new Matrix4,_lightPositionWorld=new Vector3,_lookTarget=new Vector3;class PointLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Vector2(4,2),this._viewportCount=6,this._viewports=[new Vector4(2,1,1,1),new Vector4(0,1,1,1),new Vector4(3,1,1,1),new Vector4(1,1,1,1),new Vector4(3,0,1,1),new Vector4(1,0,1,1)],this._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)],this._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)]}updateMatrices(e,o=0){const s=this.camera,d=this.matrix,c=e.distance||s.far;c!==s.far&&(s.far=c,s.updateProjectionMatrix()),_lightPositionWorld.setFromMatrixPosition(e.matrixWorld),s.position.copy(_lightPositionWorld),_lookTarget.copy(s.position),_lookTarget.add(this._cubeDirections[o]),s.up.copy(this._cubeUps[o]),s.lookAt(_lookTarget),s.updateMatrixWorld(),d.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z),_projScreenMatrix.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix)}}class PointLight extends Light{constructor(e,o,s=0,d=2){super(e,o),this.isPointLight=!0,this.type="PointLight",this.distance=s,this.decay=d,this.shadow=new PointLightShadow}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,o){return super.copy(e,o),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class DirectionalLightShadow extends LightShadow{constructor(){super(new OrthographicCamera(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class DirectionalLight extends Light{constructor(e,o){super(e,o),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.shadow=new DirectionalLightShadow}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class AmbientLight extends Light{constructor(e,o){super(e,o),this.isAmbientLight=!0,this.type="AmbientLight"}}class RectAreaLight extends Light{constructor(e,o,s=10,d=10){super(e,o),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=s,this.height=d}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const o=super.toJSON(e);return o.object.width=this.width,o.object.height=this.height,o}}class SphericalHarmonics3{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new Vector3)}set(e){for(let o=0;o<9;o++)this.coefficients[o].copy(e[o]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,o){const s=e.x,d=e.y,c=e.z,h=this.coefficients;return o.copy(h[0]).multiplyScalar(.282095),o.addScaledVector(h[1],.488603*d),o.addScaledVector(h[2],.488603*c),o.addScaledVector(h[3],.488603*s),o.addScaledVector(h[4],1.092548*(s*d)),o.addScaledVector(h[5],1.092548*(d*c)),o.addScaledVector(h[6],.315392*(3*c*c-1)),o.addScaledVector(h[7],1.092548*(s*c)),o.addScaledVector(h[8],.546274*(s*s-d*d)),o}getIrradianceAt(e,o){const s=e.x,d=e.y,c=e.z,h=this.coefficients;return o.copy(h[0]).multiplyScalar(.886227),o.addScaledVector(h[1],2*.511664*d),o.addScaledVector(h[2],2*.511664*c),o.addScaledVector(h[3],2*.511664*s),o.addScaledVector(h[4],2*.429043*s*d),o.addScaledVector(h[5],2*.429043*d*c),o.addScaledVector(h[6],.743125*c*c-.247708),o.addScaledVector(h[7],2*.429043*s*c),o.addScaledVector(h[8],.429043*(s*s-d*d)),o}add(e){for(let o=0;o<9;o++)this.coefficients[o].add(e.coefficients[o]);return this}addScaledSH(e,o){for(let s=0;s<9;s++)this.coefficients[s].addScaledVector(e.coefficients[s],o);return this}scale(e){for(let o=0;o<9;o++)this.coefficients[o].multiplyScalar(e);return this}lerp(e,o){for(let s=0;s<9;s++)this.coefficients[s].lerp(e.coefficients[s],o);return this}equals(e){for(let o=0;o<9;o++)if(!this.coefficients[o].equals(e.coefficients[o]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,o=0){const s=this.coefficients;for(let d=0;d<9;d++)s[d].fromArray(e,o+d*3);return this}toArray(e=[],o=0){const s=this.coefficients;for(let d=0;d<9;d++)s[d].toArray(e,o+d*3);return e}static getBasisAt(e,o){const s=e.x,d=e.y,c=e.z;o[0]=.282095,o[1]=.488603*d,o[2]=.488603*c,o[3]=.488603*s,o[4]=1.092548*s*d,o[5]=1.092548*d*c,o[6]=.315392*(3*c*c-1),o[7]=1.092548*s*c,o[8]=.546274*(s*s-d*d)}}class LightProbe extends Light{constructor(e=new SphericalHarmonics3,o=1){super(void 0,o),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const o=super.toJSON(e);return o.object.sh=this.sh.toArray(),o}}class MaterialLoader extends Loader{constructor(e){super(e),this.textures={}}load(e,o,s,d){const c=this,h=new FileLoader(c.manager);h.setPath(c.path),h.setRequestHeader(c.requestHeader),h.setWithCredentials(c.withCredentials),h.load(e,function(_){try{o(c.parse(JSON.parse(_)))}catch(bt){d?d(bt):console.error(bt),c.manager.itemError(e)}},s,d)}parse(e){const o=this.textures;function s(c){return o[c]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",c),o[c]}const d=MaterialLoader.createMaterialFromType(e.type);if(e.uuid!==void 0&&(d.uuid=e.uuid),e.name!==void 0&&(d.name=e.name),e.color!==void 0&&d.color!==void 0&&d.color.setHex(e.color),e.roughness!==void 0&&(d.roughness=e.roughness),e.metalness!==void 0&&(d.metalness=e.metalness),e.sheen!==void 0&&(d.sheen=e.sheen),e.sheenColor!==void 0&&(d.sheenColor=new Color().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(d.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&d.emissive!==void 0&&d.emissive.setHex(e.emissive),e.specular!==void 0&&d.specular!==void 0&&d.specular.setHex(e.specular),e.specularIntensity!==void 0&&(d.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&d.specularColor!==void 0&&d.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(d.shininess=e.shininess),e.clearcoat!==void 0&&(d.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(d.clearcoatRoughness=e.clearcoatRoughness),e.iridescence!==void 0&&(d.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(d.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(d.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(d.transmission=e.transmission),e.thickness!==void 0&&(d.thickness=e.thickness),e.attenuationDistance!==void 0&&(d.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&d.attenuationColor!==void 0&&d.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(d.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(d.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(d.fog=e.fog),e.flatShading!==void 0&&(d.flatShading=e.flatShading),e.blending!==void 0&&(d.blending=e.blending),e.combine!==void 0&&(d.combine=e.combine),e.side!==void 0&&(d.side=e.side),e.shadowSide!==void 0&&(d.shadowSide=e.shadowSide),e.opacity!==void 0&&(d.opacity=e.opacity),e.transparent!==void 0&&(d.transparent=e.transparent),e.alphaTest!==void 0&&(d.alphaTest=e.alphaTest),e.alphaHash!==void 0&&(d.alphaHash=e.alphaHash),e.depthFunc!==void 0&&(d.depthFunc=e.depthFunc),e.depthTest!==void 0&&(d.depthTest=e.depthTest),e.depthWrite!==void 0&&(d.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(d.colorWrite=e.colorWrite),e.blendSrc!==void 0&&(d.blendSrc=e.blendSrc),e.blendDst!==void 0&&(d.blendDst=e.blendDst),e.blendEquation!==void 0&&(d.blendEquation=e.blendEquation),e.blendSrcAlpha!==void 0&&(d.blendSrcAlpha=e.blendSrcAlpha),e.blendDstAlpha!==void 0&&(d.blendDstAlpha=e.blendDstAlpha),e.blendEquationAlpha!==void 0&&(d.blendEquationAlpha=e.blendEquationAlpha),e.blendColor!==void 0&&d.blendColor!==void 0&&d.blendColor.setHex(e.blendColor),e.blendAlpha!==void 0&&(d.blendAlpha=e.blendAlpha),e.stencilWriteMask!==void 0&&(d.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(d.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(d.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(d.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(d.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(d.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(d.stencilZPass=e.stencilZPass),e.stencilWrite!==void 0&&(d.stencilWrite=e.stencilWrite),e.wireframe!==void 0&&(d.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(d.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(d.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(d.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(d.rotation=e.rotation),e.linewidth!==void 0&&(d.linewidth=e.linewidth),e.dashSize!==void 0&&(d.dashSize=e.dashSize),e.gapSize!==void 0&&(d.gapSize=e.gapSize),e.scale!==void 0&&(d.scale=e.scale),e.polygonOffset!==void 0&&(d.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(d.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(d.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(d.dithering=e.dithering),e.alphaToCoverage!==void 0&&(d.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(d.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(d.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(d.visible=e.visible),e.toneMapped!==void 0&&(d.toneMapped=e.toneMapped),e.userData!==void 0&&(d.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?d.vertexColors=e.vertexColors>0:d.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const c in e.uniforms){const h=e.uniforms[c];switch(d.uniforms[c]={},h.type){case"t":d.uniforms[c].value=s(h.value);break;case"c":d.uniforms[c].value=new Color().setHex(h.value);break;case"v2":d.uniforms[c].value=new Vector2().fromArray(h.value);break;case"v3":d.uniforms[c].value=new Vector3().fromArray(h.value);break;case"v4":d.uniforms[c].value=new Vector4().fromArray(h.value);break;case"m3":d.uniforms[c].value=new Matrix3().fromArray(h.value);break;case"m4":d.uniforms[c].value=new Matrix4().fromArray(h.value);break;default:d.uniforms[c].value=h.value}}if(e.defines!==void 0&&(d.defines=e.defines),e.vertexShader!==void 0&&(d.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(d.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(d.glslVersion=e.glslVersion),e.extensions!==void 0)for(const c in e.extensions)d.extensions[c]=e.extensions[c];if(e.lights!==void 0&&(d.lights=e.lights),e.clipping!==void 0&&(d.clipping=e.clipping),e.size!==void 0&&(d.size=e.size),e.sizeAttenuation!==void 0&&(d.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(d.map=s(e.map)),e.matcap!==void 0&&(d.matcap=s(e.matcap)),e.alphaMap!==void 0&&(d.alphaMap=s(e.alphaMap)),e.bumpMap!==void 0&&(d.bumpMap=s(e.bumpMap)),e.bumpScale!==void 0&&(d.bumpScale=e.bumpScale),e.normalMap!==void 0&&(d.normalMap=s(e.normalMap)),e.normalMapType!==void 0&&(d.normalMapType=e.normalMapType),e.normalScale!==void 0){let c=e.normalScale;Array.isArray(c)===!1&&(c=[c,c]),d.normalScale=new Vector2().fromArray(c)}return e.displacementMap!==void 0&&(d.displacementMap=s(e.displacementMap)),e.displacementScale!==void 0&&(d.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(d.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(d.roughnessMap=s(e.roughnessMap)),e.metalnessMap!==void 0&&(d.metalnessMap=s(e.metalnessMap)),e.emissiveMap!==void 0&&(d.emissiveMap=s(e.emissiveMap)),e.emissiveIntensity!==void 0&&(d.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(d.specularMap=s(e.specularMap)),e.specularIntensityMap!==void 0&&(d.specularIntensityMap=s(e.specularIntensityMap)),e.specularColorMap!==void 0&&(d.specularColorMap=s(e.specularColorMap)),e.envMap!==void 0&&(d.envMap=s(e.envMap)),e.envMapRotation!==void 0&&d.envMapRotation.fromArray(e.envMapRotation),e.envMapIntensity!==void 0&&(d.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(d.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(d.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(d.lightMap=s(e.lightMap)),e.lightMapIntensity!==void 0&&(d.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(d.aoMap=s(e.aoMap)),e.aoMapIntensity!==void 0&&(d.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(d.gradientMap=s(e.gradientMap)),e.clearcoatMap!==void 0&&(d.clearcoatMap=s(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(d.clearcoatRoughnessMap=s(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(d.clearcoatNormalMap=s(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(d.clearcoatNormalScale=new Vector2().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(d.iridescenceMap=s(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(d.iridescenceThicknessMap=s(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(d.transmissionMap=s(e.transmissionMap)),e.thicknessMap!==void 0&&(d.thicknessMap=s(e.thicknessMap)),e.anisotropyMap!==void 0&&(d.anisotropyMap=s(e.anisotropyMap)),e.sheenColorMap!==void 0&&(d.sheenColorMap=s(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(d.sheenRoughnessMap=s(e.sheenRoughnessMap)),d}setTextures(e){return this.textures=e,this}static createMaterialFromType(e){const o={ShadowMaterial,SpriteMaterial,RawShaderMaterial,ShaderMaterial,PointsMaterial,MeshPhysicalMaterial,MeshStandardMaterial,MeshPhongMaterial,MeshToonMaterial,MeshNormalMaterial,MeshLambertMaterial,MeshDepthMaterial,MeshDistanceMaterial,MeshBasicMaterial,MeshMatcapMaterial,LineDashedMaterial,LineBasicMaterial,Material};return new o[e]}}class LoaderUtils{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let o="";for(let s=0,d=e.length;s<d;s++)o+=String.fromCharCode(e[s]);try{return decodeURIComponent(escape(o))}catch{return o}}static extractUrlBase(e){const o=e.lastIndexOf("/");return o===-1?"./":e.slice(0,o+1)}static resolveURL(e,o){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(o)&&/^\//.test(e)&&(o=o.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:o+e)}}class InstancedBufferGeometry extends BufferGeometry{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class BufferGeometryLoader extends Loader{constructor(e){super(e)}load(e,o,s,d){const c=this,h=new FileLoader(c.manager);h.setPath(c.path),h.setRequestHeader(c.requestHeader),h.setWithCredentials(c.withCredentials),h.load(e,function(_){try{o(c.parse(JSON.parse(_)))}catch(bt){d?d(bt):console.error(bt),c.manager.itemError(e)}},s,d)}parse(e){const o={},s={};function d(It,zt){if(o[zt]!==void 0)return o[zt];const Hn=It.interleavedBuffers[zt],Qt=c(It,Hn.buffer),cr=getTypedArray(Hn.type,Qt),fr=new InterleavedBuffer(cr,Hn.stride);return fr.uuid=Hn.uuid,o[zt]=fr,fr}function c(It,zt){if(s[zt]!==void 0)return s[zt];const Hn=It.arrayBuffers[zt],Qt=new Uint32Array(Hn).buffer;return s[zt]=Qt,Qt}const h=e.isInstancedBufferGeometry?new InstancedBufferGeometry:new BufferGeometry,_=e.data.index;if(_!==void 0){const It=getTypedArray(_.type,_.array);h.setIndex(new BufferAttribute(It,1))}const bt=e.data.attributes;for(const It in bt){const zt=bt[It];let er;if(zt.isInterleavedBufferAttribute){const Hn=d(e.data,zt.data);er=new InterleavedBufferAttribute(Hn,zt.itemSize,zt.offset,zt.normalized)}else{const Hn=getTypedArray(zt.type,zt.array),Qt=zt.isInstancedBufferAttribute?InstancedBufferAttribute:BufferAttribute;er=new Qt(Hn,zt.itemSize,zt.normalized)}zt.name!==void 0&&(er.name=zt.name),zt.usage!==void 0&&er.setUsage(zt.usage),h.setAttribute(It,er)}const g=e.data.morphAttributes;if(g)for(const It in g){const zt=g[It],er=[];for(let Hn=0,Qt=zt.length;Hn<Qt;Hn++){const cr=zt[Hn];let fr;if(cr.isInterleavedBufferAttribute){const jr=d(e.data,cr.data);fr=new InterleavedBufferAttribute(jr,cr.itemSize,cr.offset,cr.normalized)}else{const jr=getTypedArray(cr.type,cr.array);fr=new BufferAttribute(jr,cr.itemSize,cr.normalized)}cr.name!==void 0&&(fr.name=cr.name),er.push(fr)}h.morphAttributes[It]=er}e.data.morphTargetsRelative&&(h.morphTargetsRelative=!0);const b=e.data.groups||e.data.drawcalls||e.data.offsets;if(b!==void 0)for(let It=0,zt=b.length;It!==zt;++It){const er=b[It];h.addGroup(er.start,er.count,er.materialIndex)}const Et=e.data.boundingSphere;if(Et!==void 0){const It=new Vector3;Et.center!==void 0&&It.fromArray(Et.center),h.boundingSphere=new Sphere(It,Et.radius)}return e.name&&(h.name=e.name),e.userData&&(h.userData=e.userData),h}}class ObjectLoader extends Loader{constructor(e){super(e)}load(e,o,s,d){const c=this,h=this.path===""?LoaderUtils.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||h;const _=new FileLoader(this.manager);_.setPath(this.path),_.setRequestHeader(this.requestHeader),_.setWithCredentials(this.withCredentials),_.load(e,function(bt){let g=null;try{g=JSON.parse(bt)}catch(b){d!==void 0&&d(b),console.error("THREE:ObjectLoader: Can't parse "+e+".",b.message);return}const j=g.metadata;if(j===void 0||j.type===void 0||j.type.toLowerCase()==="geometry"){d!==void 0&&d(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}c.parse(g,o)},s,d)}async loadAsync(e,o){const s=this,d=this.path===""?LoaderUtils.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||d;const c=new FileLoader(this.manager);c.setPath(this.path),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials);const h=await c.loadAsync(e,o),_=JSON.parse(h),bt=_.metadata;if(bt===void 0||bt.type===void 0||bt.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await s.parseAsync(_)}parse(e,o){const s=this.parseAnimations(e.animations),d=this.parseShapes(e.shapes),c=this.parseGeometries(e.geometries,d),h=this.parseImages(e.images,function(){o!==void 0&&o(g)}),_=this.parseTextures(e.textures,h),bt=this.parseMaterials(e.materials,_),g=this.parseObject(e.object,c,bt,_,s),j=this.parseSkeletons(e.skeletons,g);if(this.bindSkeletons(g,j),o!==void 0){let b=!1;for(const Et in h)if(h[Et].data instanceof HTMLImageElement){b=!0;break}b===!1&&o(g)}return g}async parseAsync(e){const o=this.parseAnimations(e.animations),s=this.parseShapes(e.shapes),d=this.parseGeometries(e.geometries,s),c=await this.parseImagesAsync(e.images),h=this.parseTextures(e.textures,c),_=this.parseMaterials(e.materials,h),bt=this.parseObject(e.object,d,_,h,o),g=this.parseSkeletons(e.skeletons,bt);return this.bindSkeletons(bt,g),bt}parseShapes(e){const o={};if(e!==void 0)for(let s=0,d=e.length;s<d;s++){const c=new Shape().fromJSON(e[s]);o[c.uuid]=c}return o}parseSkeletons(e,o){const s={},d={};if(o.traverse(function(c){c.isBone&&(d[c.uuid]=c)}),e!==void 0)for(let c=0,h=e.length;c<h;c++){const _=new Skeleton().fromJSON(e[c],d);s[_.uuid]=_}return s}parseGeometries(e,o){const s={};if(e!==void 0){const d=new BufferGeometryLoader;for(let c=0,h=e.length;c<h;c++){let _;const bt=e[c];switch(bt.type){case"BufferGeometry":case"InstancedBufferGeometry":_=d.parse(bt);break;default:bt.type in Geometries?_=Geometries[bt.type].fromJSON(bt,o):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${bt.type}"`)}_.uuid=bt.uuid,bt.name!==void 0&&(_.name=bt.name),bt.userData!==void 0&&(_.userData=bt.userData),s[bt.uuid]=_}}return s}parseMaterials(e,o){const s={},d={};if(e!==void 0){const c=new MaterialLoader;c.setTextures(o);for(let h=0,_=e.length;h<_;h++){const bt=e[h];s[bt.uuid]===void 0&&(s[bt.uuid]=c.parse(bt)),d[bt.uuid]=s[bt.uuid]}}return d}parseAnimations(e){const o={};if(e!==void 0)for(let s=0;s<e.length;s++){const d=e[s],c=AnimationClip.parse(d);o[c.uuid]=c}return o}parseImages(e,o){const s=this,d={};let c;function h(bt){return s.manager.itemStart(bt),c.load(bt,function(){s.manager.itemEnd(bt)},void 0,function(){s.manager.itemError(bt),s.manager.itemEnd(bt)})}function _(bt){if(typeof bt=="string"){const g=bt,j=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(g)?g:s.resourcePath+g;return h(j)}else return bt.data?{data:getTypedArray(bt.type,bt.data),width:bt.width,height:bt.height}:null}if(e!==void 0&&e.length>0){const bt=new LoadingManager(o);c=new ImageLoader(bt),c.setCrossOrigin(this.crossOrigin);for(let g=0,j=e.length;g<j;g++){const b=e[g],Et=b.url;if(Array.isArray(Et)){const It=[];for(let zt=0,er=Et.length;zt<er;zt++){const Hn=Et[zt],Qt=_(Hn);Qt!==null&&(Qt instanceof HTMLImageElement?It.push(Qt):It.push(new DataTexture(Qt.data,Qt.width,Qt.height)))}d[b.uuid]=new Source(It)}else{const It=_(b.url);d[b.uuid]=new Source(It)}}}return d}async parseImagesAsync(e){const o=this,s={};let d;async function c(h){if(typeof h=="string"){const _=h,bt=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(_)?_:o.resourcePath+_;return await d.loadAsync(bt)}else return h.data?{data:getTypedArray(h.type,h.data),width:h.width,height:h.height}:null}if(e!==void 0&&e.length>0){d=new ImageLoader(this.manager),d.setCrossOrigin(this.crossOrigin);for(let h=0,_=e.length;h<_;h++){const bt=e[h],g=bt.url;if(Array.isArray(g)){const j=[];for(let b=0,Et=g.length;b<Et;b++){const It=g[b],zt=await c(It);zt!==null&&(zt instanceof HTMLImageElement?j.push(zt):j.push(new DataTexture(zt.data,zt.width,zt.height)))}s[bt.uuid]=new Source(j)}else{const j=await c(bt.url);s[bt.uuid]=new Source(j)}}}return s}parseTextures(e,o){function s(c,h){return typeof c=="number"?c:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",c),h[c])}const d={};if(e!==void 0)for(let c=0,h=e.length;c<h;c++){const _=e[c];_.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',_.uuid),o[_.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",_.image);const bt=o[_.image],g=bt.data;let j;Array.isArray(g)?(j=new CubeTexture,g.length===6&&(j.needsUpdate=!0)):(g&&g.data?j=new DataTexture:j=new Texture,g&&(j.needsUpdate=!0)),j.source=bt,j.uuid=_.uuid,_.name!==void 0&&(j.name=_.name),_.mapping!==void 0&&(j.mapping=s(_.mapping,TEXTURE_MAPPING)),_.channel!==void 0&&(j.channel=_.channel),_.offset!==void 0&&j.offset.fromArray(_.offset),_.repeat!==void 0&&j.repeat.fromArray(_.repeat),_.center!==void 0&&j.center.fromArray(_.center),_.rotation!==void 0&&(j.rotation=_.rotation),_.wrap!==void 0&&(j.wrapS=s(_.wrap[0],TEXTURE_WRAPPING),j.wrapT=s(_.wrap[1],TEXTURE_WRAPPING)),_.format!==void 0&&(j.format=_.format),_.internalFormat!==void 0&&(j.internalFormat=_.internalFormat),_.type!==void 0&&(j.type=_.type),_.colorSpace!==void 0&&(j.colorSpace=_.colorSpace),_.minFilter!==void 0&&(j.minFilter=s(_.minFilter,TEXTURE_FILTER)),_.magFilter!==void 0&&(j.magFilter=s(_.magFilter,TEXTURE_FILTER)),_.anisotropy!==void 0&&(j.anisotropy=_.anisotropy),_.flipY!==void 0&&(j.flipY=_.flipY),_.generateMipmaps!==void 0&&(j.generateMipmaps=_.generateMipmaps),_.premultiplyAlpha!==void 0&&(j.premultiplyAlpha=_.premultiplyAlpha),_.unpackAlignment!==void 0&&(j.unpackAlignment=_.unpackAlignment),_.compareFunction!==void 0&&(j.compareFunction=_.compareFunction),_.userData!==void 0&&(j.userData=_.userData),d[_.uuid]=j}return d}parseObject(e,o,s,d,c){let h;function _(Et){return o[Et]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",Et),o[Et]}function bt(Et){if(Et!==void 0){if(Array.isArray(Et)){const It=[];for(let zt=0,er=Et.length;zt<er;zt++){const Hn=Et[zt];s[Hn]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",Hn),It.push(s[Hn])}return It}return s[Et]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",Et),s[Et]}}function g(Et){return d[Et]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",Et),d[Et]}let j,b;switch(e.type){case"Scene":h=new Scene,e.background!==void 0&&(Number.isInteger(e.background)?h.background=new Color(e.background):h.background=g(e.background)),e.environment!==void 0&&(h.environment=g(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?h.fog=new Fog(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(h.fog=new FogExp2(e.fog.color,e.fog.density)),e.fog.name!==""&&(h.fog.name=e.fog.name)),e.backgroundBlurriness!==void 0&&(h.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(h.backgroundIntensity=e.backgroundIntensity),e.backgroundRotation!==void 0&&h.backgroundRotation.fromArray(e.backgroundRotation),e.environmentRotation!==void 0&&h.environmentRotation.fromArray(e.environmentRotation);break;case"PerspectiveCamera":h=new PerspectiveCamera(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(h.focus=e.focus),e.zoom!==void 0&&(h.zoom=e.zoom),e.filmGauge!==void 0&&(h.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(h.filmOffset=e.filmOffset),e.view!==void 0&&(h.view=Object.assign({},e.view));break;case"OrthographicCamera":h=new OrthographicCamera(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(h.zoom=e.zoom),e.view!==void 0&&(h.view=Object.assign({},e.view));break;case"AmbientLight":h=new AmbientLight(e.color,e.intensity);break;case"DirectionalLight":h=new DirectionalLight(e.color,e.intensity);break;case"PointLight":h=new PointLight(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":h=new RectAreaLight(e.color,e.intensity,e.width,e.height);break;case"SpotLight":h=new SpotLight(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":h=new HemisphereLight(e.color,e.groundColor,e.intensity);break;case"LightProbe":h=new LightProbe().fromJSON(e);break;case"SkinnedMesh":j=_(e.geometry),b=bt(e.material),h=new SkinnedMesh(j,b),e.bindMode!==void 0&&(h.bindMode=e.bindMode),e.bindMatrix!==void 0&&h.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(h.skeleton=e.skeleton);break;case"Mesh":j=_(e.geometry),b=bt(e.material),h=new Mesh(j,b);break;case"InstancedMesh":j=_(e.geometry),b=bt(e.material);const Et=e.count,It=e.instanceMatrix,zt=e.instanceColor;h=new InstancedMesh(j,b,Et),h.instanceMatrix=new InstancedBufferAttribute(new Float32Array(It.array),16),zt!==void 0&&(h.instanceColor=new InstancedBufferAttribute(new Float32Array(zt.array),zt.itemSize));break;case"BatchedMesh":j=_(e.geometry),b=bt(e.material),h=new BatchedMesh(e.maxGeometryCount,e.maxVertexCount,e.maxIndexCount,b),h.geometry=j,h.perObjectFrustumCulled=e.perObjectFrustumCulled,h.sortObjects=e.sortObjects,h._drawRanges=e.drawRanges,h._reservedRanges=e.reservedRanges,h._visibility=e.visibility,h._active=e.active,h._bounds=e.bounds.map(er=>{const Hn=new Box3;Hn.min.fromArray(er.boxMin),Hn.max.fromArray(er.boxMax);const Qt=new Sphere;return Qt.radius=er.sphereRadius,Qt.center.fromArray(er.sphereCenter),{boxInitialized:er.boxInitialized,box:Hn,sphereInitialized:er.sphereInitialized,sphere:Qt}}),h._maxGeometryCount=e.maxGeometryCount,h._maxVertexCount=e.maxVertexCount,h._maxIndexCount=e.maxIndexCount,h._geometryInitialized=e.geometryInitialized,h._geometryCount=e.geometryCount,h._matricesTexture=g(e.matricesTexture.uuid);break;case"LOD":h=new LOD;break;case"Line":h=new Line(_(e.geometry),bt(e.material));break;case"LineLoop":h=new LineLoop(_(e.geometry),bt(e.material));break;case"LineSegments":h=new LineSegments(_(e.geometry),bt(e.material));break;case"PointCloud":case"Points":h=new Points(_(e.geometry),bt(e.material));break;case"Sprite":h=new Sprite(bt(e.material));break;case"Group":h=new Group;break;case"Bone":h=new Bone;break;default:h=new Object3D}if(h.uuid=e.uuid,e.name!==void 0&&(h.name=e.name),e.matrix!==void 0?(h.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(h.matrixAutoUpdate=e.matrixAutoUpdate),h.matrixAutoUpdate&&h.matrix.decompose(h.position,h.quaternion,h.scale)):(e.position!==void 0&&h.position.fromArray(e.position),e.rotation!==void 0&&h.rotation.fromArray(e.rotation),e.quaternion!==void 0&&h.quaternion.fromArray(e.quaternion),e.scale!==void 0&&h.scale.fromArray(e.scale)),e.up!==void 0&&h.up.fromArray(e.up),e.castShadow!==void 0&&(h.castShadow=e.castShadow),e.receiveShadow!==void 0&&(h.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(h.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(h.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(h.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&h.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(h.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(h.visible=e.visible),e.frustumCulled!==void 0&&(h.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(h.renderOrder=e.renderOrder),e.userData!==void 0&&(h.userData=e.userData),e.layers!==void 0&&(h.layers.mask=e.layers),e.children!==void 0){const Et=e.children;for(let It=0;It<Et.length;It++)h.add(this.parseObject(Et[It],o,s,d,c))}if(e.animations!==void 0){const Et=e.animations;for(let It=0;It<Et.length;It++){const zt=Et[It];h.animations.push(c[zt])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(h.autoUpdate=e.autoUpdate);const Et=e.levels;for(let It=0;It<Et.length;It++){const zt=Et[It],er=h.getObjectByProperty("uuid",zt.object);er!==void 0&&h.addLevel(er,zt.distance,zt.hysteresis)}}return h}bindSkeletons(e,o){Object.keys(o).length!==0&&e.traverse(function(s){if(s.isSkinnedMesh===!0&&s.skeleton!==void 0){const d=o[s.skeleton];d===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",s.skeleton):s.bind(d,s.bindMatrix)}})}}const TEXTURE_MAPPING={UVMapping,CubeReflectionMapping,CubeRefractionMapping,EquirectangularReflectionMapping,EquirectangularRefractionMapping,CubeUVReflectionMapping},TEXTURE_WRAPPING={RepeatWrapping,ClampToEdgeWrapping,MirroredRepeatWrapping},TEXTURE_FILTER={NearestFilter,NearestMipmapNearestFilter,NearestMipmapLinearFilter,LinearFilter,LinearMipmapNearestFilter,LinearMipmapLinearFilter};class ImageBitmapLoader extends Loader{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,o,s,d){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const c=this,h=Cache.get(e);if(h!==void 0){if(c.manager.itemStart(e),h.then){h.then(g=>{o&&o(g),c.manager.itemEnd(e)}).catch(g=>{d&&d(g)});return}return setTimeout(function(){o&&o(h),c.manager.itemEnd(e)},0),h}const _={};_.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",_.headers=this.requestHeader;const bt=fetch(e,_).then(function(g){return g.blob()}).then(function(g){return createImageBitmap(g,Object.assign(c.options,{colorSpaceConversion:"none"}))}).then(function(g){return Cache.add(e,g),o&&o(g),c.manager.itemEnd(e),g}).catch(function(g){d&&d(g),Cache.remove(e),c.manager.itemError(e),c.manager.itemEnd(e)});Cache.add(e,bt),c.manager.itemStart(e)}}let _context;class AudioContext{static getContext(){return _context===void 0&&(_context=new(window.AudioContext||window.webkitAudioContext)),_context}static setContext(e){_context=e}}class AudioLoader extends Loader{constructor(e){super(e)}load(e,o,s,d){const c=this,h=new FileLoader(this.manager);h.setResponseType("arraybuffer"),h.setPath(this.path),h.setRequestHeader(this.requestHeader),h.setWithCredentials(this.withCredentials),h.load(e,function(bt){try{const g=bt.slice(0);AudioContext.getContext().decodeAudioData(g,function(b){o(b)}).catch(_)}catch(g){_(g)}},s,d);function _(bt){d?d(bt):console.error(bt),c.manager.itemError(e)}}}const _eyeRight=new Matrix4,_eyeLeft=new Matrix4,_projectionMatrix=new Matrix4;class StereoCamera{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new PerspectiveCamera,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new PerspectiveCamera,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const o=this._cache;if(o.focus!==e.focus||o.fov!==e.fov||o.aspect!==e.aspect*this.aspect||o.near!==e.near||o.far!==e.far||o.zoom!==e.zoom||o.eyeSep!==this.eyeSep){o.focus=e.focus,o.fov=e.fov,o.aspect=e.aspect*this.aspect,o.near=e.near,o.far=e.far,o.zoom=e.zoom,o.eyeSep=this.eyeSep,_projectionMatrix.copy(e.projectionMatrix);const d=o.eyeSep/2,c=d*o.near/o.focus,h=o.near*Math.tan(DEG2RAD*o.fov*.5)/o.zoom;let _,bt;_eyeLeft.elements[12]=-d,_eyeRight.elements[12]=d,_=-h*o.aspect+c,bt=h*o.aspect+c,_projectionMatrix.elements[0]=2*o.near/(bt-_),_projectionMatrix.elements[8]=(bt+_)/(bt-_),this.cameraL.projectionMatrix.copy(_projectionMatrix),_=-h*o.aspect-c,bt=h*o.aspect-c,_projectionMatrix.elements[0]=2*o.near/(bt-_),_projectionMatrix.elements[8]=(bt+_)/(bt-_),this.cameraR.projectionMatrix.copy(_projectionMatrix)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(_eyeLeft),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_eyeRight)}}class Clock{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const o=now();e=(o-this.oldTime)/1e3,this.oldTime=o,this.elapsedTime+=e}return e}}function now(){return(typeof performance>"u"?Date:performance).now()}const _position$1=new Vector3,_quaternion$1=new Quaternion,_scale$1=new Vector3,_orientation$1=new Vector3;class AudioListener extends Object3D{constructor(){super(),this.type="AudioListener",this.context=AudioContext.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Clock}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const o=this.context.listener,s=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(_position$1,_quaternion$1,_scale$1),_orientation$1.set(0,0,-1).applyQuaternion(_quaternion$1),o.positionX){const d=this.context.currentTime+this.timeDelta;o.positionX.linearRampToValueAtTime(_position$1.x,d),o.positionY.linearRampToValueAtTime(_position$1.y,d),o.positionZ.linearRampToValueAtTime(_position$1.z,d),o.forwardX.linearRampToValueAtTime(_orientation$1.x,d),o.forwardY.linearRampToValueAtTime(_orientation$1.y,d),o.forwardZ.linearRampToValueAtTime(_orientation$1.z,d),o.upX.linearRampToValueAtTime(s.x,d),o.upY.linearRampToValueAtTime(s.y,d),o.upZ.linearRampToValueAtTime(s.z,d)}else o.setPosition(_position$1.x,_position$1.y,_position$1.z),o.setOrientation(_orientation$1.x,_orientation$1.y,_orientation$1.z,s.x,s.y,s.z)}}class Audio extends Object3D{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const o=this.context.createBufferSource();return o.buffer=this.buffer,o.loop=this.loop,o.loopStart=this.loopStart,o.loopEnd=this.loopEnd,o.onended=this.onEnded.bind(this),o.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=o,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,o=this.filters.length;e<o;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,o=this.filters.length;e<o;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){return this.detune=e,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const _position=new Vector3,_quaternion=new Quaternion,_scale=new Vector3,_orientation=new Vector3;class PositionalAudio extends Audio{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,o,s){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=o,this.panner.coneOuterGain=s,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(_position,_quaternion,_scale),_orientation.set(0,0,1).applyQuaternion(_quaternion);const o=this.panner;if(o.positionX){const s=this.context.currentTime+this.listener.timeDelta;o.positionX.linearRampToValueAtTime(_position.x,s),o.positionY.linearRampToValueAtTime(_position.y,s),o.positionZ.linearRampToValueAtTime(_position.z,s),o.orientationX.linearRampToValueAtTime(_orientation.x,s),o.orientationY.linearRampToValueAtTime(_orientation.y,s),o.orientationZ.linearRampToValueAtTime(_orientation.z,s)}else o.setPosition(_position.x,_position.y,_position.z),o.setOrientation(_orientation.x,_orientation.y,_orientation.z)}}class AudioAnalyser{constructor(e,o=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=o,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const o=this.getFrequencyData();for(let s=0;s<o.length;s++)e+=o[s];return e/o.length}}class PropertyMixer{constructor(e,o,s){this.binding=e,this.valueSize=s;let d,c,h;switch(o){case"quaternion":d=this._slerp,c=this._slerpAdditive,h=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(s*6),this._workIndex=5;break;case"string":case"bool":d=this._select,c=this._select,h=this._setAdditiveIdentityOther,this.buffer=new Array(s*5);break;default:d=this._lerp,c=this._lerpAdditive,h=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(s*5)}this._mixBufferRegion=d,this._mixBufferRegionAdditive=c,this._setIdentity=h,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,o){const s=this.buffer,d=this.valueSize,c=e*d+d;let h=this.cumulativeWeight;if(h===0){for(let _=0;_!==d;++_)s[c+_]=s[_];h=o}else{h+=o;const _=o/h;this._mixBufferRegion(s,c,0,_,d)}this.cumulativeWeight=h}accumulateAdditive(e){const o=this.buffer,s=this.valueSize,d=s*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(o,d,0,e,s),this.cumulativeWeightAdditive+=e}apply(e){const o=this.valueSize,s=this.buffer,d=e*o+o,c=this.cumulativeWeight,h=this.cumulativeWeightAdditive,_=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,c<1){const bt=o*this._origIndex;this._mixBufferRegion(s,d,bt,1-c,o)}h>0&&this._mixBufferRegionAdditive(s,d,this._addIndex*o,1,o);for(let bt=o,g=o+o;bt!==g;++bt)if(s[bt]!==s[bt+o]){_.setValue(s,d);break}}saveOriginalState(){const e=this.binding,o=this.buffer,s=this.valueSize,d=s*this._origIndex;e.getValue(o,d);for(let c=s,h=d;c!==h;++c)o[c]=o[d+c%s];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,o=e+this.valueSize;for(let s=e;s<o;s++)this.buffer[s]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,o=this._addIndex*this.valueSize;for(let s=0;s<this.valueSize;s++)this.buffer[o+s]=this.buffer[e+s]}_select(e,o,s,d,c){if(d>=.5)for(let h=0;h!==c;++h)e[o+h]=e[s+h]}_slerp(e,o,s,d){Quaternion.slerpFlat(e,o,e,o,e,s,d)}_slerpAdditive(e,o,s,d,c){const h=this._workIndex*c;Quaternion.multiplyQuaternionsFlat(e,h,e,o,e,s),Quaternion.slerpFlat(e,o,e,o,e,h,d)}_lerp(e,o,s,d,c){const h=1-d;for(let _=0;_!==c;++_){const bt=o+_;e[bt]=e[bt]*h+e[s+_]*d}}_lerpAdditive(e,o,s,d,c){for(let h=0;h!==c;++h){const _=o+h;e[_]=e[_]+e[s+h]*d}}}const _RESERVED_CHARS_RE="\\[\\]\\.:\\/",_reservedRe=new RegExp("["+_RESERVED_CHARS_RE+"]","g"),_wordChar="[^"+_RESERVED_CHARS_RE+"]",_wordCharOrDot="[^"+_RESERVED_CHARS_RE.replace("\\.","")+"]",_directoryRe=/((?:WC+[\/:])*)/.source.replace("WC",_wordChar),_nodeRe=/(WCOD+)?/.source.replace("WCOD",_wordCharOrDot),_objectRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",_wordChar),_propertyRe=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",_wordChar),_trackRe=new RegExp("^"+_directoryRe+_nodeRe+_objectRe+_propertyRe+"$"),_supportedObjectNames=["material","materials","bones","map"];class Composite{constructor(e,o,s){const d=s||PropertyBinding.parseTrackName(o);this._targetGroup=e,this._bindings=e.subscribe_(o,d)}getValue(e,o){this.bind();const s=this._targetGroup.nCachedObjects_,d=this._bindings[s];d!==void 0&&d.getValue(e,o)}setValue(e,o){const s=this._bindings;for(let d=this._targetGroup.nCachedObjects_,c=s.length;d!==c;++d)s[d].setValue(e,o)}bind(){const e=this._bindings;for(let o=this._targetGroup.nCachedObjects_,s=e.length;o!==s;++o)e[o].bind()}unbind(){const e=this._bindings;for(let o=this._targetGroup.nCachedObjects_,s=e.length;o!==s;++o)e[o].unbind()}}class PropertyBinding{constructor(e,o,s){this.path=o,this.parsedPath=s||PropertyBinding.parseTrackName(o),this.node=PropertyBinding.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,o,s){return e&&e.isAnimationObjectGroup?new PropertyBinding.Composite(e,o,s):new PropertyBinding(e,o,s)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(_reservedRe,"")}static parseTrackName(e){const o=_trackRe.exec(e);if(o===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const s={nodeName:o[2],objectName:o[3],objectIndex:o[4],propertyName:o[5],propertyIndex:o[6]},d=s.nodeName&&s.nodeName.lastIndexOf(".");if(d!==void 0&&d!==-1){const c=s.nodeName.substring(d+1);_supportedObjectNames.indexOf(c)!==-1&&(s.nodeName=s.nodeName.substring(0,d),s.objectName=c)}if(s.propertyName===null||s.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return s}static findNode(e,o){if(o===void 0||o===""||o==="."||o===-1||o===e.name||o===e.uuid)return e;if(e.skeleton){const s=e.skeleton.getBoneByName(o);if(s!==void 0)return s}if(e.children){const s=function(c){for(let h=0;h<c.length;h++){const _=c[h];if(_.name===o||_.uuid===o)return _;const bt=s(_.children);if(bt)return bt}return null},d=s(e.children);if(d)return d}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,o){e[o]=this.targetObject[this.propertyName]}_getValue_array(e,o){const s=this.resolvedProperty;for(let d=0,c=s.length;d!==c;++d)e[o++]=s[d]}_getValue_arrayElement(e,o){e[o]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,o){this.resolvedProperty.toArray(e,o)}_setValue_direct(e,o){this.targetObject[this.propertyName]=e[o]}_setValue_direct_setNeedsUpdate(e,o){this.targetObject[this.propertyName]=e[o],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,o){this.targetObject[this.propertyName]=e[o],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,o){const s=this.resolvedProperty;for(let d=0,c=s.length;d!==c;++d)s[d]=e[o++]}_setValue_array_setNeedsUpdate(e,o){const s=this.resolvedProperty;for(let d=0,c=s.length;d!==c;++d)s[d]=e[o++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,o){const s=this.resolvedProperty;for(let d=0,c=s.length;d!==c;++d)s[d]=e[o++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,o){this.resolvedProperty[this.propertyIndex]=e[o]}_setValue_arrayElement_setNeedsUpdate(e,o){this.resolvedProperty[this.propertyIndex]=e[o],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,o){this.resolvedProperty[this.propertyIndex]=e[o],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,o){this.resolvedProperty.fromArray(e,o)}_setValue_fromArray_setNeedsUpdate(e,o){this.resolvedProperty.fromArray(e,o),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,o){this.resolvedProperty.fromArray(e,o),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,o){this.bind(),this.getValue(e,o)}_setValue_unbound(e,o){this.bind(),this.setValue(e,o)}bind(){let e=this.node;const o=this.parsedPath,s=o.objectName,d=o.propertyName;let c=o.propertyIndex;if(e||(e=PropertyBinding.findNode(this.rootNode,o.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(s){let g=o.objectIndex;switch(s){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let j=0;j<e.length;j++)if(e[j].name===g){g=j;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[s]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[s]}if(g!==void 0){if(e[g]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[g]}}const h=e[d];if(h===void 0){const g=o.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+g+"."+d+" but it wasn't found.",e);return}let _=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?_=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(_=this.Versioning.MatrixWorldNeedsUpdate);let bt=this.BindingType.Direct;if(c!==void 0){if(d==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[c]!==void 0&&(c=e.morphTargetDictionary[c])}bt=this.BindingType.ArrayElement,this.resolvedProperty=h,this.propertyIndex=c}else h.fromArray!==void 0&&h.toArray!==void 0?(bt=this.BindingType.HasFromToArray,this.resolvedProperty=h):Array.isArray(h)?(bt=this.BindingType.EntireArray,this.resolvedProperty=h):this.propertyName=d;this.getValue=this.GetterByBindingType[bt],this.setValue=this.SetterByBindingTypeAndVersioning[bt][_]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}PropertyBinding.Composite=Composite;PropertyBinding.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};PropertyBinding.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};PropertyBinding.prototype.GetterByBindingType=[PropertyBinding.prototype._getValue_direct,PropertyBinding.prototype._getValue_array,PropertyBinding.prototype._getValue_arrayElement,PropertyBinding.prototype._getValue_toArray];PropertyBinding.prototype.SetterByBindingTypeAndVersioning=[[PropertyBinding.prototype._setValue_direct,PropertyBinding.prototype._setValue_direct_setNeedsUpdate,PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_array,PropertyBinding.prototype._setValue_array_setNeedsUpdate,PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_arrayElement,PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_fromArray,PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class AnimationObjectGroup{constructor(){this.isAnimationObjectGroup=!0,this.uuid=generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let s=0,d=arguments.length;s!==d;++s)e[arguments[s].uuid]=s;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const o=this;this.stats={objects:{get total(){return o._objects.length},get inUse(){return this.total-o.nCachedObjects_}},get bindingsPerObject(){return o._bindings.length}}}add(){const e=this._objects,o=this._indicesByUUID,s=this._paths,d=this._parsedPaths,c=this._bindings,h=c.length;let _,bt=e.length,g=this.nCachedObjects_;for(let j=0,b=arguments.length;j!==b;++j){const Et=arguments[j],It=Et.uuid;let zt=o[It];if(zt===void 0){zt=bt++,o[It]=zt,e.push(Et);for(let er=0,Hn=h;er!==Hn;++er)c[er].push(new PropertyBinding(Et,s[er],d[er]))}else if(zt<g){_=e[zt];const er=--g,Hn=e[er];o[Hn.uuid]=zt,e[zt]=Hn,o[It]=er,e[er]=Et;for(let Qt=0,cr=h;Qt!==cr;++Qt){const fr=c[Qt],jr=fr[er];let e0=fr[zt];fr[zt]=jr,e0===void 0&&(e0=new PropertyBinding(Et,s[Qt],d[Qt])),fr[er]=e0}}else e[zt]!==_&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=g}remove(){const e=this._objects,o=this._indicesByUUID,s=this._bindings,d=s.length;let c=this.nCachedObjects_;for(let h=0,_=arguments.length;h!==_;++h){const bt=arguments[h],g=bt.uuid,j=o[g];if(j!==void 0&&j>=c){const b=c++,Et=e[b];o[Et.uuid]=j,e[j]=Et,o[g]=b,e[b]=bt;for(let It=0,zt=d;It!==zt;++It){const er=s[It],Hn=er[b],Qt=er[j];er[j]=Hn,er[b]=Qt}}}this.nCachedObjects_=c}uncache(){const e=this._objects,o=this._indicesByUUID,s=this._bindings,d=s.length;let c=this.nCachedObjects_,h=e.length;for(let _=0,bt=arguments.length;_!==bt;++_){const g=arguments[_],j=g.uuid,b=o[j];if(b!==void 0)if(delete o[j],b<c){const Et=--c,It=e[Et],zt=--h,er=e[zt];o[It.uuid]=b,e[b]=It,o[er.uuid]=Et,e[Et]=er,e.pop();for(let Hn=0,Qt=d;Hn!==Qt;++Hn){const cr=s[Hn],fr=cr[Et],jr=cr[zt];cr[b]=fr,cr[Et]=jr,cr.pop()}}else{const Et=--h,It=e[Et];Et>0&&(o[It.uuid]=b),e[b]=It,e.pop();for(let zt=0,er=d;zt!==er;++zt){const Hn=s[zt];Hn[b]=Hn[Et],Hn.pop()}}}this.nCachedObjects_=c}subscribe_(e,o){const s=this._bindingsIndicesByPath;let d=s[e];const c=this._bindings;if(d!==void 0)return c[d];const h=this._paths,_=this._parsedPaths,bt=this._objects,g=bt.length,j=this.nCachedObjects_,b=new Array(g);d=c.length,s[e]=d,h.push(e),_.push(o),c.push(b);for(let Et=j,It=bt.length;Et!==It;++Et){const zt=bt[Et];b[Et]=new PropertyBinding(zt,e,o)}return b}unsubscribe_(e){const o=this._bindingsIndicesByPath,s=o[e];if(s!==void 0){const d=this._paths,c=this._parsedPaths,h=this._bindings,_=h.length-1,bt=h[_],g=e[_];o[g]=s,h[s]=bt,h.pop(),c[s]=c[_],c.pop(),d[s]=d[_],d.pop()}}}class AnimationAction{constructor(e,o,s=null,d=o.blendMode){this._mixer=e,this._clip=o,this._localRoot=s,this.blendMode=d;const c=o.tracks,h=c.length,_=new Array(h),bt={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};for(let g=0;g!==h;++g){const j=c[g].createInterpolant(null);_[g]=j,j.settings=bt}this._interpolantSettings=bt,this._interpolants=_,this._propertyBindings=new Array(h),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=LoopRepeat,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,o){return this.loop=e,this.repetitions=o,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,o,s){if(e.fadeOut(o),this.fadeIn(o),s){const d=this._clip.duration,c=e._clip.duration,h=c/d,_=d/c;e.warp(1,h,o),this.warp(_,1,o)}return this}crossFadeTo(e,o,s){return e.crossFadeFrom(this,o,s)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,o,s){const d=this._mixer,c=d.time,h=this.timeScale;let _=this._timeScaleInterpolant;_===null&&(_=d._lendControlInterpolant(),this._timeScaleInterpolant=_);const bt=_.parameterPositions,g=_.sampleValues;return bt[0]=c,bt[1]=c+s,g[0]=e/h,g[1]=o/h,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,o,s,d){if(!this.enabled){this._updateWeight(e);return}const c=this._startTime;if(c!==null){const bt=(e-c)*s;bt<0||s===0?o=0:(this._startTime=null,o=s*bt)}o*=this._updateTimeScale(e);const h=this._updateTime(o),_=this._updateWeight(e);if(_>0){const bt=this._interpolants,g=this._propertyBindings;switch(this.blendMode){case AdditiveAnimationBlendMode:for(let j=0,b=bt.length;j!==b;++j)bt[j].evaluate(h),g[j].accumulateAdditive(_);break;case NormalAnimationBlendMode:default:for(let j=0,b=bt.length;j!==b;++j)bt[j].evaluate(h),g[j].accumulate(d,_)}}}_updateWeight(e){let o=0;if(this.enabled){o=this.weight;const s=this._weightInterpolant;if(s!==null){const d=s.evaluate(e)[0];o*=d,e>s.parameterPositions[1]&&(this.stopFading(),d===0&&(this.enabled=!1))}}return this._effectiveWeight=o,o}_updateTimeScale(e){let o=0;if(!this.paused){o=this.timeScale;const s=this._timeScaleInterpolant;if(s!==null){const d=s.evaluate(e)[0];o*=d,e>s.parameterPositions[1]&&(this.stopWarping(),o===0?this.paused=!0:this.timeScale=o)}}return this._effectiveTimeScale=o,o}_updateTime(e){const o=this._clip.duration,s=this.loop;let d=this.time+e,c=this._loopCount;const h=s===LoopPingPong;if(e===0)return c===-1?d:h&&(c&1)===1?o-d:d;if(s===LoopOnce){c===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(d>=o)d=o;else if(d<0)d=0;else{this.time=d;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=d,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(c===-1&&(e>=0?(c=0,this._setEndings(!0,this.repetitions===0,h)):this._setEndings(this.repetitions===0,!0,h)),d>=o||d<0){const _=Math.floor(d/o);d-=o*_,c+=Math.abs(_);const bt=this.repetitions-c;if(bt<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,d=e>0?o:0,this.time=d,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(bt===1){const g=e<0;this._setEndings(g,!g,h)}else this._setEndings(!1,!1,h);this._loopCount=c,this.time=d,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:_})}}else this.time=d;if(h&&(c&1)===1)return o-d}return d}_setEndings(e,o,s){const d=this._interpolantSettings;s?(d.endingStart=ZeroSlopeEnding,d.endingEnd=ZeroSlopeEnding):(e?d.endingStart=this.zeroSlopeAtStart?ZeroSlopeEnding:ZeroCurvatureEnding:d.endingStart=WrapAroundEnding,o?d.endingEnd=this.zeroSlopeAtEnd?ZeroSlopeEnding:ZeroCurvatureEnding:d.endingEnd=WrapAroundEnding)}_scheduleFading(e,o,s){const d=this._mixer,c=d.time;let h=this._weightInterpolant;h===null&&(h=d._lendControlInterpolant(),this._weightInterpolant=h);const _=h.parameterPositions,bt=h.sampleValues;return _[0]=c,bt[0]=o,_[1]=c+e,bt[1]=s,this}}const _controlInterpolantsResultBuffer=new Float32Array(1);class AnimationMixer extends EventDispatcher{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,o){const s=e._localRoot||this._root,d=e._clip.tracks,c=d.length,h=e._propertyBindings,_=e._interpolants,bt=s.uuid,g=this._bindingsByRootAndName;let j=g[bt];j===void 0&&(j={},g[bt]=j);for(let b=0;b!==c;++b){const Et=d[b],It=Et.name;let zt=j[It];if(zt!==void 0)++zt.referenceCount,h[b]=zt;else{if(zt=h[b],zt!==void 0){zt._cacheIndex===null&&(++zt.referenceCount,this._addInactiveBinding(zt,bt,It));continue}const er=o&&o._propertyBindings[b].binding.parsedPath;zt=new PropertyMixer(PropertyBinding.create(s,It,er),Et.ValueTypeName,Et.getValueSize()),++zt.referenceCount,this._addInactiveBinding(zt,bt,It),h[b]=zt}_[b].resultBuffer=zt.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const s=(e._localRoot||this._root).uuid,d=e._clip.uuid,c=this._actionsByClip[d];this._bindAction(e,c&&c.knownActions[0]),this._addInactiveAction(e,d,s)}const o=e._propertyBindings;for(let s=0,d=o.length;s!==d;++s){const c=o[s];c.useCount++===0&&(this._lendBinding(c),c.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const o=e._propertyBindings;for(let s=0,d=o.length;s!==d;++s){const c=o[s];--c.useCount===0&&(c.restoreOriginalState(),this._takeBackBinding(c))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const o=e._cacheIndex;return o!==null&&o<this._nActiveActions}_addInactiveAction(e,o,s){const d=this._actions,c=this._actionsByClip;let h=c[o];if(h===void 0)h={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,c[o]=h;else{const _=h.knownActions;e._byClipCacheIndex=_.length,_.push(e)}e._cacheIndex=d.length,d.push(e),h.actionByRoot[s]=e}_removeInactiveAction(e){const o=this._actions,s=o[o.length-1],d=e._cacheIndex;s._cacheIndex=d,o[d]=s,o.pop(),e._cacheIndex=null;const c=e._clip.uuid,h=this._actionsByClip,_=h[c],bt=_.knownActions,g=bt[bt.length-1],j=e._byClipCacheIndex;g._byClipCacheIndex=j,bt[j]=g,bt.pop(),e._byClipCacheIndex=null;const b=_.actionByRoot,Et=(e._localRoot||this._root).uuid;delete b[Et],bt.length===0&&delete h[c],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const o=e._propertyBindings;for(let s=0,d=o.length;s!==d;++s){const c=o[s];--c.referenceCount===0&&this._removeInactiveBinding(c)}}_lendAction(e){const o=this._actions,s=e._cacheIndex,d=this._nActiveActions++,c=o[d];e._cacheIndex=d,o[d]=e,c._cacheIndex=s,o[s]=c}_takeBackAction(e){const o=this._actions,s=e._cacheIndex,d=--this._nActiveActions,c=o[d];e._cacheIndex=d,o[d]=e,c._cacheIndex=s,o[s]=c}_addInactiveBinding(e,o,s){const d=this._bindingsByRootAndName,c=this._bindings;let h=d[o];h===void 0&&(h={},d[o]=h),h[s]=e,e._cacheIndex=c.length,c.push(e)}_removeInactiveBinding(e){const o=this._bindings,s=e.binding,d=s.rootNode.uuid,c=s.path,h=this._bindingsByRootAndName,_=h[d],bt=o[o.length-1],g=e._cacheIndex;bt._cacheIndex=g,o[g]=bt,o.pop(),delete _[c],Object.keys(_).length===0&&delete h[d]}_lendBinding(e){const o=this._bindings,s=e._cacheIndex,d=this._nActiveBindings++,c=o[d];e._cacheIndex=d,o[d]=e,c._cacheIndex=s,o[s]=c}_takeBackBinding(e){const o=this._bindings,s=e._cacheIndex,d=--this._nActiveBindings,c=o[d];e._cacheIndex=d,o[d]=e,c._cacheIndex=s,o[s]=c}_lendControlInterpolant(){const e=this._controlInterpolants,o=this._nActiveControlInterpolants++;let s=e[o];return s===void 0&&(s=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,_controlInterpolantsResultBuffer),s.__cacheIndex=o,e[o]=s),s}_takeBackControlInterpolant(e){const o=this._controlInterpolants,s=e.__cacheIndex,d=--this._nActiveControlInterpolants,c=o[d];e.__cacheIndex=d,o[d]=e,c.__cacheIndex=s,o[s]=c}clipAction(e,o,s){const d=o||this._root,c=d.uuid;let h=typeof e=="string"?AnimationClip.findByName(d,e):e;const _=h!==null?h.uuid:e,bt=this._actionsByClip[_];let g=null;if(s===void 0&&(h!==null?s=h.blendMode:s=NormalAnimationBlendMode),bt!==void 0){const b=bt.actionByRoot[c];if(b!==void 0&&b.blendMode===s)return b;g=bt.knownActions[0],h===null&&(h=g._clip)}if(h===null)return null;const j=new AnimationAction(this,h,o,s);return this._bindAction(j,g),this._addInactiveAction(j,_,c),j}existingAction(e,o){const s=o||this._root,d=s.uuid,c=typeof e=="string"?AnimationClip.findByName(s,e):e,h=c?c.uuid:e,_=this._actionsByClip[h];return _!==void 0&&_.actionByRoot[d]||null}stopAllAction(){const e=this._actions,o=this._nActiveActions;for(let s=o-1;s>=0;--s)e[s].stop();return this}update(e){e*=this.timeScale;const o=this._actions,s=this._nActiveActions,d=this.time+=e,c=Math.sign(e),h=this._accuIndex^=1;for(let g=0;g!==s;++g)o[g]._update(d,e,c,h);const _=this._bindings,bt=this._nActiveBindings;for(let g=0;g!==bt;++g)_[g].apply(h);return this}setTime(e){this.time=0;for(let o=0;o<this._actions.length;o++)this._actions[o].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const o=this._actions,s=e.uuid,d=this._actionsByClip,c=d[s];if(c!==void 0){const h=c.knownActions;for(let _=0,bt=h.length;_!==bt;++_){const g=h[_];this._deactivateAction(g);const j=g._cacheIndex,b=o[o.length-1];g._cacheIndex=null,g._byClipCacheIndex=null,b._cacheIndex=j,o[j]=b,o.pop(),this._removeInactiveBindingsForAction(g)}delete d[s]}}uncacheRoot(e){const o=e.uuid,s=this._actionsByClip;for(const h in s){const _=s[h].actionByRoot,bt=_[o];bt!==void 0&&(this._deactivateAction(bt),this._removeInactiveAction(bt))}const d=this._bindingsByRootAndName,c=d[o];if(c!==void 0)for(const h in c){const _=c[h];_.restoreOriginalState(),this._removeInactiveBinding(_)}}uncacheAction(e,o){const s=this.existingAction(e,o);s!==null&&(this._deactivateAction(s),this._removeInactiveAction(s))}}class Uniform{constructor(e){this.value=e}clone(){return new Uniform(this.value.clone===void 0?this.value:this.value.clone())}}let _id=0;class UniformsGroup extends EventDispatcher{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:_id++}),this.name="",this.usage=StaticDrawUsage,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const o=this.uniforms.indexOf(e);return o!==-1&&this.uniforms.splice(o,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(e){this.name=e.name,this.usage=e.usage;const o=e.uniforms;this.uniforms.length=0;for(let s=0,d=o.length;s<d;s++){const c=Array.isArray(o[s])?o[s]:[o[s]];for(let h=0;h<c.length;h++)this.uniforms.push(c[h].clone())}return this}clone(){return new this.constructor().copy(this)}}class InstancedInterleavedBuffer extends InterleavedBuffer{constructor(e,o,s=1){super(e,o),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=s}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const o=super.clone(e);return o.meshPerAttribute=this.meshPerAttribute,o}toJSON(e){const o=super.toJSON(e);return o.isInstancedInterleavedBuffer=!0,o.meshPerAttribute=this.meshPerAttribute,o}}class GLBufferAttribute{constructor(e,o,s,d,c){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=o,this.itemSize=s,this.elementSize=d,this.count=c,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,o){return this.type=e,this.elementSize=o,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}const _matrix=new Matrix4;class Raycaster{constructor(e,o,s=0,d=1/0){this.ray=new Ray(e,o),this.near=s,this.far=d,this.camera=null,this.layers=new Layers,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,o){this.ray.set(e,o)}setFromCamera(e,o){o.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(o.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(o).sub(this.ray.origin).normalize(),this.camera=o):o.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(o.near+o.far)/(o.near-o.far)).unproject(o),this.ray.direction.set(0,0,-1).transformDirection(o.matrixWorld),this.camera=o):console.error("THREE.Raycaster: Unsupported camera type: "+o.type)}setFromXRController(e){return _matrix.identity().extractRotation(e.matrixWorld),this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(_matrix),this}intersectObject(e,o=!0,s=[]){return intersect(e,this,s,o),s.sort(ascSort),s}intersectObjects(e,o=!0,s=[]){for(let d=0,c=e.length;d<c;d++)intersect(e[d],this,s,o);return s.sort(ascSort),s}}function ascSort(a,e){return a.distance-e.distance}function intersect(a,e,o,s){if(a.layers.test(e.layers)&&a.raycast(e,o),s===!0){const d=a.children;for(let c=0,h=d.length;c<h;c++)intersect(d[c],e,o,!0)}}class Spherical{constructor(e=1,o=0,s=0){return this.radius=e,this.phi=o,this.theta=s,this}set(e,o,s){return this.radius=e,this.phi=o,this.theta=s,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,o,s){return this.radius=Math.sqrt(e*e+o*o+s*s),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,s),this.phi=Math.acos(clamp(o/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class Cylindrical{constructor(e=1,o=0,s=0){return this.radius=e,this.theta=o,this.y=s,this}set(e,o,s){return this.radius=e,this.theta=o,this.y=s,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,o,s){return this.radius=Math.sqrt(e*e+s*s),this.theta=Math.atan2(e,s),this.y=o,this}clone(){return new this.constructor().copy(this)}}const _vector$4=new Vector2;class Box2{constructor(e=new Vector2(1/0,1/0),o=new Vector2(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=o}set(e,o){return this.min.copy(e),this.max.copy(o),this}setFromPoints(e){this.makeEmpty();for(let o=0,s=e.length;o<s;o++)this.expandByPoint(e[o]);return this}setFromCenterAndSize(e,o){const s=_vector$4.copy(o).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,o){return o.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,o){return o.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,_vector$4).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const _startP=new Vector3,_startEnd=new Vector3;class Line3{constructor(e=new Vector3,o=new Vector3){this.start=e,this.end=o}set(e,o){return this.start.copy(e),this.end.copy(o),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,o){return this.delta(o).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,o){_startP.subVectors(e,this.start),_startEnd.subVectors(this.end,this.start);const s=_startEnd.dot(_startEnd);let c=_startEnd.dot(_startP)/s;return o&&(c=clamp(c,0,1)),c}closestPointToPoint(e,o,s){const d=this.closestPointToPointParameter(e,o);return this.delta(s).multiplyScalar(d).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const _vector$3=new Vector3;class SpotLightHelper extends Object3D{constructor(e,o){super(),this.light=e,this.matrixAutoUpdate=!1,this.color=o,this.type="SpotLightHelper";const s=new BufferGeometry,d=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let h=0,_=1,bt=32;h<bt;h++,_++){const g=h/bt*Math.PI*2,j=_/bt*Math.PI*2;d.push(Math.cos(g),Math.sin(g),1,Math.cos(j),Math.sin(j),1)}s.setAttribute("position",new Float32BufferAttribute(d,3));const c=new LineBasicMaterial({fog:!1,toneMapped:!1});this.cone=new LineSegments(s,c),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const e=this.light.distance?this.light.distance:1e3,o=e*Math.tan(this.light.angle);this.cone.scale.set(o,o,e),_vector$3.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(_vector$3),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const _vector$2=new Vector3,_boneMatrix=new Matrix4,_matrixWorldInv=new Matrix4;class SkeletonHelper extends LineSegments{constructor(e){const o=getBoneList(e),s=new BufferGeometry,d=[],c=[],h=new Color(0,0,1),_=new Color(0,1,0);for(let g=0;g<o.length;g++){const j=o[g];j.parent&&j.parent.isBone&&(d.push(0,0,0),d.push(0,0,0),c.push(h.r,h.g,h.b),c.push(_.r,_.g,_.b))}s.setAttribute("position",new Float32BufferAttribute(d,3)),s.setAttribute("color",new Float32BufferAttribute(c,3));const bt=new LineBasicMaterial({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(s,bt),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=o,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const o=this.bones,s=this.geometry,d=s.getAttribute("position");_matrixWorldInv.copy(this.root.matrixWorld).invert();for(let c=0,h=0;c<o.length;c++){const _=o[c];_.parent&&_.parent.isBone&&(_boneMatrix.multiplyMatrices(_matrixWorldInv,_.matrixWorld),_vector$2.setFromMatrixPosition(_boneMatrix),d.setXYZ(h,_vector$2.x,_vector$2.y,_vector$2.z),_boneMatrix.multiplyMatrices(_matrixWorldInv,_.parent.matrixWorld),_vector$2.setFromMatrixPosition(_boneMatrix),d.setXYZ(h+1,_vector$2.x,_vector$2.y,_vector$2.z),h+=2)}s.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function getBoneList(a){const e=[];a.isBone===!0&&e.push(a);for(let o=0;o<a.children.length;o++)e.push.apply(e,getBoneList(a.children[o]));return e}class PointLightHelper extends Mesh{constructor(e,o,s){const d=new SphereGeometry(o,4,2),c=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1});super(d,c),this.light=e,this.color=s,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const _vector$1=new Vector3,_color1=new Color,_color2=new Color;class HemisphereLightHelper extends Object3D{constructor(e,o,s){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=s,this.type="HemisphereLightHelper";const d=new OctahedronGeometry(o);d.rotateY(Math.PI*.5),this.material=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const c=d.getAttribute("position"),h=new Float32Array(c.count*3);d.setAttribute("color",new BufferAttribute(h,3)),this.add(new Mesh(d,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const o=e.geometry.getAttribute("color");_color1.copy(this.light.color),_color2.copy(this.light.groundColor);for(let s=0,d=o.count;s<d;s++){const c=s<d/2?_color1:_color2;o.setXYZ(s,c.r,c.g,c.b)}o.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate())}}class GridHelper extends LineSegments{constructor(e=10,o=10,s=4473924,d=8947848){s=new Color(s),d=new Color(d);const c=o/2,h=e/o,_=e/2,bt=[],g=[];for(let Et=0,It=0,zt=-_;Et<=o;Et++,zt+=h){bt.push(-_,0,zt,_,0,zt),bt.push(zt,0,-_,zt,0,_);const er=Et===c?s:d;er.toArray(g,It),It+=3,er.toArray(g,It),It+=3,er.toArray(g,It),It+=3,er.toArray(g,It),It+=3}const j=new BufferGeometry;j.setAttribute("position",new Float32BufferAttribute(bt,3)),j.setAttribute("color",new Float32BufferAttribute(g,3));const b=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(j,b),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class PolarGridHelper extends LineSegments{constructor(e=10,o=16,s=8,d=64,c=4473924,h=8947848){c=new Color(c),h=new Color(h);const _=[],bt=[];if(o>1)for(let b=0;b<o;b++){const Et=b/o*(Math.PI*2),It=Math.sin(Et)*e,zt=Math.cos(Et)*e;_.push(0,0,0),_.push(It,0,zt);const er=b&1?c:h;bt.push(er.r,er.g,er.b),bt.push(er.r,er.g,er.b)}for(let b=0;b<s;b++){const Et=b&1?c:h,It=e-e/s*b;for(let zt=0;zt<d;zt++){let er=zt/d*(Math.PI*2),Hn=Math.sin(er)*It,Qt=Math.cos(er)*It;_.push(Hn,0,Qt),bt.push(Et.r,Et.g,Et.b),er=(zt+1)/d*(Math.PI*2),Hn=Math.sin(er)*It,Qt=Math.cos(er)*It,_.push(Hn,0,Qt),bt.push(Et.r,Et.g,Et.b)}}const g=new BufferGeometry;g.setAttribute("position",new Float32BufferAttribute(_,3)),g.setAttribute("color",new Float32BufferAttribute(bt,3));const j=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(g,j),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const _v1=new Vector3,_v2=new Vector3,_v3=new Vector3;class DirectionalLightHelper extends Object3D{constructor(e,o,s){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=s,this.type="DirectionalLightHelper",o===void 0&&(o=1);let d=new BufferGeometry;d.setAttribute("position",new Float32BufferAttribute([-o,o,0,o,o,0,o,-o,0,-o,-o,0,-o,o,0],3));const c=new LineBasicMaterial({fog:!1,toneMapped:!1});this.lightPlane=new Line(d,c),this.add(this.lightPlane),d=new BufferGeometry,d.setAttribute("position",new Float32BufferAttribute([0,0,0,0,0,1],3)),this.targetLine=new Line(d,c),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),_v1.setFromMatrixPosition(this.light.matrixWorld),_v2.setFromMatrixPosition(this.light.target.matrixWorld),_v3.subVectors(_v2,_v1),this.lightPlane.lookAt(_v2),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(_v2),this.targetLine.scale.z=_v3.length()}}const _vector=new Vector3,_camera=new Camera;class CameraHelper extends LineSegments{constructor(e){const o=new BufferGeometry,s=new LineBasicMaterial({color:16777215,vertexColors:!0,toneMapped:!1}),d=[],c=[],h={};_("n1","n2"),_("n2","n4"),_("n4","n3"),_("n3","n1"),_("f1","f2"),_("f2","f4"),_("f4","f3"),_("f3","f1"),_("n1","f1"),_("n2","f2"),_("n3","f3"),_("n4","f4"),_("p","n1"),_("p","n2"),_("p","n3"),_("p","n4"),_("u1","u2"),_("u2","u3"),_("u3","u1"),_("c","t"),_("p","c"),_("cn1","cn2"),_("cn3","cn4"),_("cf1","cf2"),_("cf3","cf4");function _(zt,er){bt(zt),bt(er)}function bt(zt){d.push(0,0,0),c.push(0,0,0),h[zt]===void 0&&(h[zt]=[]),h[zt].push(d.length/3-1)}o.setAttribute("position",new Float32BufferAttribute(d,3)),o.setAttribute("color",new Float32BufferAttribute(c,3)),super(o,s),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=h,this.update();const g=new Color(16755200),j=new Color(16711680),b=new Color(43775),Et=new Color(16777215),It=new Color(3355443);this.setColors(g,j,b,Et,It)}setColors(e,o,s,d,c){const _=this.geometry.getAttribute("color");_.setXYZ(0,e.r,e.g,e.b),_.setXYZ(1,e.r,e.g,e.b),_.setXYZ(2,e.r,e.g,e.b),_.setXYZ(3,e.r,e.g,e.b),_.setXYZ(4,e.r,e.g,e.b),_.setXYZ(5,e.r,e.g,e.b),_.setXYZ(6,e.r,e.g,e.b),_.setXYZ(7,e.r,e.g,e.b),_.setXYZ(8,e.r,e.g,e.b),_.setXYZ(9,e.r,e.g,e.b),_.setXYZ(10,e.r,e.g,e.b),_.setXYZ(11,e.r,e.g,e.b),_.setXYZ(12,e.r,e.g,e.b),_.setXYZ(13,e.r,e.g,e.b),_.setXYZ(14,e.r,e.g,e.b),_.setXYZ(15,e.r,e.g,e.b),_.setXYZ(16,e.r,e.g,e.b),_.setXYZ(17,e.r,e.g,e.b),_.setXYZ(18,e.r,e.g,e.b),_.setXYZ(19,e.r,e.g,e.b),_.setXYZ(20,e.r,e.g,e.b),_.setXYZ(21,e.r,e.g,e.b),_.setXYZ(22,e.r,e.g,e.b),_.setXYZ(23,e.r,e.g,e.b),_.setXYZ(24,o.r,o.g,o.b),_.setXYZ(25,o.r,o.g,o.b),_.setXYZ(26,o.r,o.g,o.b),_.setXYZ(27,o.r,o.g,o.b),_.setXYZ(28,o.r,o.g,o.b),_.setXYZ(29,o.r,o.g,o.b),_.setXYZ(30,o.r,o.g,o.b),_.setXYZ(31,o.r,o.g,o.b),_.setXYZ(32,s.r,s.g,s.b),_.setXYZ(33,s.r,s.g,s.b),_.setXYZ(34,s.r,s.g,s.b),_.setXYZ(35,s.r,s.g,s.b),_.setXYZ(36,s.r,s.g,s.b),_.setXYZ(37,s.r,s.g,s.b),_.setXYZ(38,d.r,d.g,d.b),_.setXYZ(39,d.r,d.g,d.b),_.setXYZ(40,c.r,c.g,c.b),_.setXYZ(41,c.r,c.g,c.b),_.setXYZ(42,c.r,c.g,c.b),_.setXYZ(43,c.r,c.g,c.b),_.setXYZ(44,c.r,c.g,c.b),_.setXYZ(45,c.r,c.g,c.b),_.setXYZ(46,c.r,c.g,c.b),_.setXYZ(47,c.r,c.g,c.b),_.setXYZ(48,c.r,c.g,c.b),_.setXYZ(49,c.r,c.g,c.b),_.needsUpdate=!0}update(){const e=this.geometry,o=this.pointMap,s=1,d=1;_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),setPoint("c",o,e,_camera,0,0,-1),setPoint("t",o,e,_camera,0,0,1),setPoint("n1",o,e,_camera,-s,-d,-1),setPoint("n2",o,e,_camera,s,-d,-1),setPoint("n3",o,e,_camera,-s,d,-1),setPoint("n4",o,e,_camera,s,d,-1),setPoint("f1",o,e,_camera,-s,-d,1),setPoint("f2",o,e,_camera,s,-d,1),setPoint("f3",o,e,_camera,-s,d,1),setPoint("f4",o,e,_camera,s,d,1),setPoint("u1",o,e,_camera,s*.7,d*1.1,-1),setPoint("u2",o,e,_camera,-s*.7,d*1.1,-1),setPoint("u3",o,e,_camera,0,d*2,-1),setPoint("cf1",o,e,_camera,-s,0,1),setPoint("cf2",o,e,_camera,s,0,1),setPoint("cf3",o,e,_camera,0,-d,1),setPoint("cf4",o,e,_camera,0,d,1),setPoint("cn1",o,e,_camera,-s,0,-1),setPoint("cn2",o,e,_camera,s,0,-1),setPoint("cn3",o,e,_camera,0,-d,-1),setPoint("cn4",o,e,_camera,0,d,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function setPoint(a,e,o,s,d,c,h){_vector.set(d,c,h).unproject(s);const _=e[a];if(_!==void 0){const bt=o.getAttribute("position");for(let g=0,j=_.length;g<j;g++)bt.setXYZ(_[g],_vector.x,_vector.y,_vector.z)}}const _box=new Box3;class BoxHelper extends LineSegments{constructor(e,o=16776960){const s=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),d=new Float32Array(8*3),c=new BufferGeometry;c.setIndex(new BufferAttribute(s,1)),c.setAttribute("position",new BufferAttribute(d,3)),super(c,new LineBasicMaterial({color:o,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&_box.setFromObject(this.object),_box.isEmpty())return;const o=_box.min,s=_box.max,d=this.geometry.attributes.position,c=d.array;c[0]=s.x,c[1]=s.y,c[2]=s.z,c[3]=o.x,c[4]=s.y,c[5]=s.z,c[6]=o.x,c[7]=o.y,c[8]=s.z,c[9]=s.x,c[10]=o.y,c[11]=s.z,c[12]=s.x,c[13]=s.y,c[14]=o.z,c[15]=o.x,c[16]=s.y,c[17]=o.z,c[18]=o.x,c[19]=o.y,c[20]=o.z,c[21]=s.x,c[22]=o.y,c[23]=o.z,d.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,o){return super.copy(e,o),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class Box3Helper extends LineSegments{constructor(e,o=16776960){const s=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),d=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],c=new BufferGeometry;c.setIndex(new BufferAttribute(s,1)),c.setAttribute("position",new Float32BufferAttribute(d,3)),super(c,new LineBasicMaterial({color:o,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const o=this.box;o.isEmpty()||(o.getCenter(this.position),o.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class PlaneHelper extends Line{constructor(e,o=1,s=16776960){const d=s,c=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],h=new BufferGeometry;h.setAttribute("position",new Float32BufferAttribute(c,3)),h.computeBoundingSphere(),super(h,new LineBasicMaterial({color:d,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=o;const _=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],bt=new BufferGeometry;bt.setAttribute("position",new Float32BufferAttribute(_,3)),bt.computeBoundingSphere(),this.add(new Mesh(bt,new MeshBasicMaterial({color:d,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const _axis=new Vector3;let _lineGeometry,_coneGeometry;class ArrowHelper extends Object3D{constructor(e=new Vector3(0,0,1),o=new Vector3(0,0,0),s=1,d=16776960,c=s*.2,h=c*.2){super(),this.type="ArrowHelper",_lineGeometry===void 0&&(_lineGeometry=new BufferGeometry,_lineGeometry.setAttribute("position",new Float32BufferAttribute([0,0,0,0,1,0],3)),_coneGeometry=new CylinderGeometry(0,.5,1,5,1),_coneGeometry.translate(0,-.5,0)),this.position.copy(o),this.line=new Line(_lineGeometry,new LineBasicMaterial({color:d,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Mesh(_coneGeometry,new MeshBasicMaterial({color:d,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(s,c,h)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{_axis.set(e.z,0,-e.x).normalize();const o=Math.acos(e.y);this.quaternion.setFromAxisAngle(_axis,o)}}setLength(e,o=e*.2,s=o*.2){this.line.scale.set(1,Math.max(1e-4,e-o),1),this.line.updateMatrix(),this.cone.scale.set(s,o,s),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class AxesHelper extends LineSegments{constructor(e=1){const o=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],s=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],d=new BufferGeometry;d.setAttribute("position",new Float32BufferAttribute(o,3)),d.setAttribute("color",new Float32BufferAttribute(s,3));const c=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(d,c),this.type="AxesHelper"}setColors(e,o,s){const d=new Color,c=this.geometry.attributes.color.array;return d.set(e),d.toArray(c,0),d.toArray(c,3),d.set(o),d.toArray(c,6),d.toArray(c,9),d.set(s),d.toArray(c,12),d.toArray(c,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class ShapePath{constructor(){this.type="ShapePath",this.color=new Color,this.subPaths=[],this.currentPath=null}moveTo(e,o){return this.currentPath=new Path,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,o),this}lineTo(e,o){return this.currentPath.lineTo(e,o),this}quadraticCurveTo(e,o,s,d){return this.currentPath.quadraticCurveTo(e,o,s,d),this}bezierCurveTo(e,o,s,d,c,h){return this.currentPath.bezierCurveTo(e,o,s,d,c,h),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function o(Qt){const cr=[];for(let fr=0,jr=Qt.length;fr<jr;fr++){const e0=Qt[fr],t0=new Shape;t0.curves=e0.curves,cr.push(t0)}return cr}function s(Qt,cr){const fr=cr.length;let jr=!1;for(let e0=fr-1,t0=0;t0<fr;e0=t0++){let o0=cr[e0],l0=cr[t0],g0=l0.x-o0.x,i0=l0.y-o0.y;if(Math.abs(i0)>Number.EPSILON){if(i0<0&&(o0=cr[t0],g0=-g0,l0=cr[e0],i0=-i0),Qt.y<o0.y||Qt.y>l0.y)continue;if(Qt.y===o0.y){if(Qt.x===o0.x)return!0}else{const f0=i0*(Qt.x-o0.x)-g0*(Qt.y-o0.y);if(f0===0)return!0;if(f0<0)continue;jr=!jr}}else{if(Qt.y!==o0.y)continue;if(l0.x<=Qt.x&&Qt.x<=o0.x||o0.x<=Qt.x&&Qt.x<=l0.x)return!0}}return jr}const d=ShapeUtils.isClockWise,c=this.subPaths;if(c.length===0)return[];let h,_,bt;const g=[];if(c.length===1)return _=c[0],bt=new Shape,bt.curves=_.curves,g.push(bt),g;let j=!d(c[0].getPoints());j=e?!j:j;const b=[],Et=[];let It=[],zt=0,er;Et[zt]=void 0,It[zt]=[];for(let Qt=0,cr=c.length;Qt<cr;Qt++)_=c[Qt],er=_.getPoints(),h=d(er),h=e?!h:h,h?(!j&&Et[zt]&&zt++,Et[zt]={s:new Shape,p:er},Et[zt].s.curves=_.curves,j&&zt++,It[zt]=[]):It[zt].push({h:_,p:er[0]});if(!Et[0])return o(c);if(Et.length>1){let Qt=!1,cr=0;for(let fr=0,jr=Et.length;fr<jr;fr++)b[fr]=[];for(let fr=0,jr=Et.length;fr<jr;fr++){const e0=It[fr];for(let t0=0;t0<e0.length;t0++){const o0=e0[t0];let l0=!0;for(let g0=0;g0<Et.length;g0++)s(o0.p,Et[g0].p)&&(fr!==g0&&cr++,l0?(l0=!1,b[g0].push(o0)):Qt=!0);l0&&b[fr].push(o0)}}cr>0&&Qt===!1&&(It=b)}let Hn;for(let Qt=0,cr=Et.length;Qt<cr;Qt++){bt=Et[Qt].s,g.push(bt),Hn=It[Qt];for(let fr=0,jr=Hn.length;fr<jr;fr++)bt.holes.push(Hn[fr].h)}return g}}class WebGLMultipleRenderTargets extends WebGLRenderTarget{constructor(e=1,o=1,s=1,d={}){console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'),super(e,o,{...d,count:s}),this.isWebGLMultipleRenderTargets=!0}get texture(){return this.textures}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:REVISION}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=REVISION);const THREE=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping,AddEquation,AddOperation,AdditiveAnimationBlendMode,AdditiveBlending,AgXToneMapping,AlphaFormat,AlwaysCompare,AlwaysDepth,AlwaysStencilFunc,AmbientLight,AnimationAction,AnimationClip,AnimationLoader,AnimationMixer,AnimationObjectGroup,AnimationUtils,ArcCurve,ArrayCamera,ArrowHelper,AttachedBindMode,Audio,AudioAnalyser,AudioContext,AudioListener,AudioLoader,AxesHelper,BackSide,BasicDepthPacking,BasicShadowMap,BatchedMesh,Bone,BooleanKeyframeTrack,Box2,Box3,Box3Helper,BoxGeometry,BoxHelper,BufferAttribute,BufferGeometry,BufferGeometryLoader,ByteType,Cache,Camera,CameraHelper,CanvasTexture,CapsuleGeometry,CatmullRomCurve3,CineonToneMapping,CircleGeometry,ClampToEdgeWrapping,Clock,Color,ColorKeyframeTrack,ColorManagement,CompressedArrayTexture,CompressedCubeTexture,CompressedTexture,CompressedTextureLoader,ConeGeometry,ConstantAlphaFactor,ConstantColorFactor,CubeCamera,CubeReflectionMapping,CubeRefractionMapping,CubeTexture,CubeTextureLoader,CubeUVReflectionMapping,CubicBezierCurve,CubicBezierCurve3,CubicInterpolant,CullFaceBack,CullFaceFront,CullFaceFrontBack,CullFaceNone,Curve,CurvePath,CustomBlending,CustomToneMapping,CylinderGeometry,Cylindrical,Data3DTexture,DataArrayTexture,DataTexture,DataTextureLoader,DataUtils,DecrementStencilOp,DecrementWrapStencilOp,DefaultLoadingManager,DepthFormat,DepthStencilFormat,DepthTexture,DetachedBindMode,DirectionalLight,DirectionalLightHelper,DiscreteInterpolant,DisplayP3ColorSpace,DodecahedronGeometry,DoubleSide,DstAlphaFactor,DstColorFactor,DynamicCopyUsage,DynamicDrawUsage,DynamicReadUsage,EdgesGeometry,EllipseCurve,EqualCompare,EqualDepth,EqualStencilFunc,EquirectangularReflectionMapping,EquirectangularRefractionMapping,Euler,EventDispatcher,ExtrudeGeometry,FileLoader,Float16BufferAttribute,Float32BufferAttribute,FloatType,Fog,FogExp2,FramebufferTexture,FrontSide,Frustum,GLBufferAttribute,GLSL1,GLSL3,GreaterCompare,GreaterDepth,GreaterEqualCompare,GreaterEqualDepth,GreaterEqualStencilFunc,GreaterStencilFunc,GridHelper,Group,HalfFloatType,HemisphereLight,HemisphereLightHelper,IcosahedronGeometry,ImageBitmapLoader,ImageLoader,ImageUtils,IncrementStencilOp,IncrementWrapStencilOp,InstancedBufferAttribute,InstancedBufferGeometry,InstancedInterleavedBuffer,InstancedMesh,Int16BufferAttribute,Int32BufferAttribute,Int8BufferAttribute,IntType,InterleavedBuffer,InterleavedBufferAttribute,Interpolant,InterpolateDiscrete,InterpolateLinear,InterpolateSmooth,InvertStencilOp,KeepStencilOp,KeyframeTrack,LOD,LatheGeometry,Layers,LessCompare,LessDepth,LessEqualCompare,LessEqualDepth,LessEqualStencilFunc,LessStencilFunc,Light,LightProbe,Line,Line3,LineBasicMaterial,LineCurve,LineCurve3,LineDashedMaterial,LineLoop,LineSegments,LinearDisplayP3ColorSpace,LinearFilter,LinearInterpolant,LinearMipMapLinearFilter,LinearMipMapNearestFilter,LinearMipmapLinearFilter,LinearMipmapNearestFilter,LinearSRGBColorSpace,LinearToneMapping,LinearTransfer,Loader,LoaderUtils,LoadingManager,LoopOnce,LoopPingPong,LoopRepeat,LuminanceAlphaFormat,LuminanceFormat,MOUSE,Material,MaterialLoader,MathUtils,Matrix3,Matrix4,MaxEquation,Mesh,MeshBasicMaterial,MeshDepthMaterial,MeshDistanceMaterial,MeshLambertMaterial,MeshMatcapMaterial,MeshNormalMaterial,MeshPhongMaterial,MeshPhysicalMaterial,MeshStandardMaterial,MeshToonMaterial,MinEquation,MirroredRepeatWrapping,MixOperation,MultiplyBlending,MultiplyOperation,NearestFilter,NearestMipMapLinearFilter,NearestMipMapNearestFilter,NearestMipmapLinearFilter,NearestMipmapNearestFilter,NeutralToneMapping,NeverCompare,NeverDepth,NeverStencilFunc,NoBlending,NoColorSpace,NoToneMapping,NormalAnimationBlendMode,NormalBlending,NotEqualCompare,NotEqualDepth,NotEqualStencilFunc,NumberKeyframeTrack,Object3D,ObjectLoader,ObjectSpaceNormalMap,OctahedronGeometry,OneFactor,OneMinusConstantAlphaFactor,OneMinusConstantColorFactor,OneMinusDstAlphaFactor,OneMinusDstColorFactor,OneMinusSrcAlphaFactor,OneMinusSrcColorFactor,OrthographicCamera,P3Primaries,PCFShadowMap,PCFSoftShadowMap,PMREMGenerator,Path,PerspectiveCamera,Plane,PlaneGeometry,PlaneHelper,PointLight,PointLightHelper,Points,PointsMaterial,PolarGridHelper,PolyhedronGeometry,PositionalAudio,PropertyBinding,PropertyMixer,QuadraticBezierCurve,QuadraticBezierCurve3,Quaternion,QuaternionKeyframeTrack,QuaternionLinearInterpolant,RED_GREEN_RGTC2_Format,RED_RGTC1_Format,REVISION,RGBADepthPacking,RGBAFormat,RGBAIntegerFormat,RGBA_ASTC_10x10_Format,RGBA_ASTC_10x5_Format,RGBA_ASTC_10x6_Format,RGBA_ASTC_10x8_Format,RGBA_ASTC_12x10_Format,RGBA_ASTC_12x12_Format,RGBA_ASTC_4x4_Format,RGBA_ASTC_5x4_Format,RGBA_ASTC_5x5_Format,RGBA_ASTC_6x5_Format,RGBA_ASTC_6x6_Format,RGBA_ASTC_8x5_Format,RGBA_ASTC_8x6_Format,RGBA_ASTC_8x8_Format,RGBA_BPTC_Format,RGBA_ETC2_EAC_Format,RGBA_PVRTC_2BPPV1_Format,RGBA_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT1_Format,RGBA_S3TC_DXT3_Format,RGBA_S3TC_DXT5_Format,RGB_BPTC_SIGNED_Format,RGB_BPTC_UNSIGNED_Format,RGB_ETC1_Format,RGB_ETC2_Format,RGB_PVRTC_2BPPV1_Format,RGB_PVRTC_4BPPV1_Format,RGB_S3TC_DXT1_Format,RGFormat,RGIntegerFormat,RawShaderMaterial,Ray,Raycaster,Rec709Primaries,RectAreaLight,RedFormat,RedIntegerFormat,ReinhardToneMapping,RenderTarget,RepeatWrapping,ReplaceStencilOp,ReverseSubtractEquation,RingGeometry,SIGNED_RED_GREEN_RGTC2_Format,SIGNED_RED_RGTC1_Format,SRGBColorSpace,SRGBTransfer,Scene,ShaderChunk,ShaderLib,ShaderMaterial,ShadowMaterial,Shape,ShapeGeometry,ShapePath,ShapeUtils,ShortType,Skeleton,SkeletonHelper,SkinnedMesh,Source,Sphere,SphereGeometry,Spherical,SphericalHarmonics3,SplineCurve,SpotLight,SpotLightHelper,Sprite,SpriteMaterial,SrcAlphaFactor,SrcAlphaSaturateFactor,SrcColorFactor,StaticCopyUsage,StaticDrawUsage,StaticReadUsage,StereoCamera,StreamCopyUsage,StreamDrawUsage,StreamReadUsage,StringKeyframeTrack,SubtractEquation,SubtractiveBlending,TOUCH,TangentSpaceNormalMap,TetrahedronGeometry,Texture,TextureLoader,TorusGeometry,TorusKnotGeometry,Triangle,TriangleFanDrawMode,TriangleStripDrawMode,TrianglesDrawMode,TubeGeometry,UVMapping,Uint16BufferAttribute,Uint32BufferAttribute,Uint8BufferAttribute,Uint8ClampedBufferAttribute,Uniform,UniformsGroup,UniformsLib,UniformsUtils,UnsignedByteType,UnsignedInt248Type,UnsignedIntType,UnsignedShort4444Type,UnsignedShort5551Type,UnsignedShortType,VSMShadowMap,Vector2,Vector3,Vector4,VectorKeyframeTrack,VideoTexture,WebGL1Renderer,WebGL3DRenderTarget,WebGLArrayRenderTarget,WebGLCoordinateSystem,WebGLCubeRenderTarget,WebGLMultipleRenderTargets,WebGLRenderTarget,WebGLRenderer,WebGLUtils,WebGPUCoordinateSystem,WireframeGeometry,WrapAroundEnding,ZeroCurvatureEnding,ZeroFactor,ZeroSlopeEnding,ZeroStencilOp,_SRGBAFormat,createCanvasElement},Symbol.toStringTag,{value:"Module"}));var constants={exports:{}},reactReconcilerConstants_production_min={};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */reactReconcilerConstants_production_min.ConcurrentRoot=1;reactReconcilerConstants_production_min.ContinuousEventPriority=4;reactReconcilerConstants_production_min.DefaultEventPriority=16;reactReconcilerConstants_production_min.DiscreteEventPriority=1;reactReconcilerConstants_production_min.IdleEventPriority=536870912;reactReconcilerConstants_production_min.LegacyRoot=0;constants.exports=reactReconcilerConstants_production_min;var constantsExports=constants.exports;function createStore$1(a){let e;const o=new Set,s=(g,j)=>{const b=typeof g=="function"?g(e):g;if(b!==e){const Et=e;e=j?b:Object.assign({},e,b),o.forEach(It=>It(e,Et))}},d=()=>e,c=(g,j=d,b=Object.is)=>{console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");let Et=j(e);function It(){const zt=j(e);if(!b(Et,zt)){const er=Et;g(Et=zt,er)}}return o.add(It),()=>o.delete(It)},bt={setState:s,getState:d,subscribe:(g,j,b)=>j||b?c(g,j,b):(o.add(g),()=>o.delete(g)),destroy:()=>o.clear()};return e=a(s,d,bt),bt}const isSSR=typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent),useIsomorphicLayoutEffect$1=isSSR?reactExports.useEffect:reactExports.useLayoutEffect;function create(a){const e=typeof a=="function"?createStore$1(a):a,o=(s=e.getState,d=Object.is)=>{const[,c]=reactExports.useReducer(Hn=>Hn+1,0),h=e.getState(),_=reactExports.useRef(h),bt=reactExports.useRef(s),g=reactExports.useRef(d),j=reactExports.useRef(!1),b=reactExports.useRef();b.current===void 0&&(b.current=s(h));let Et,It=!1;(_.current!==h||bt.current!==s||g.current!==d||j.current)&&(Et=s(h),It=!d(b.current,Et)),useIsomorphicLayoutEffect$1(()=>{It&&(b.current=Et),_.current=h,bt.current=s,g.current=d,j.current=!1});const zt=reactExports.useRef(h);useIsomorphicLayoutEffect$1(()=>{const Hn=()=>{try{const cr=e.getState(),fr=bt.current(cr);g.current(b.current,fr)||(_.current=cr,b.current=fr,c())}catch{j.current=!0,c()}},Qt=e.subscribe(Hn);return e.getState()!==zt.current&&Hn(),Qt},[]);const er=It?Et:b.current;return reactExports.useDebugValue(er),er};return Object.assign(o,e),o[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");const s=[o,e];return{next(){const d=s.length<=0;return{value:s.shift(),done:d}}}},o}var reactReconciler={exports:{}},scheduler={exports:{}},scheduler_production_min={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(a){function e(w0,L0){var k0=w0.length;w0.push(L0);e:for(;0<k0;){var T0=k0-1>>>1,q0=w0[T0];if(0<d(q0,L0))w0[T0]=L0,w0[k0]=q0,k0=T0;else break e}}function o(w0){return w0.length===0?null:w0[0]}function s(w0){if(w0.length===0)return null;var L0=w0[0],k0=w0.pop();if(k0!==L0){w0[0]=k0;e:for(var T0=0,q0=w0.length,vy=q0>>>1;T0<vy;){var J0=2*(T0+1)-1,cy=w0[J0],Ty=J0+1,Uy=w0[Ty];if(0>d(cy,k0))Ty<q0&&0>d(Uy,cy)?(w0[T0]=Uy,w0[Ty]=k0,T0=Ty):(w0[T0]=cy,w0[J0]=k0,T0=J0);else if(Ty<q0&&0>d(Uy,k0))w0[T0]=Uy,w0[Ty]=k0,T0=Ty;else break e}}return L0}function d(w0,L0){var k0=w0.sortIndex-L0.sortIndex;return k0!==0?k0:w0.id-L0.id}if(typeof performance=="object"&&typeof performance.now=="function"){var c=performance;a.unstable_now=function(){return c.now()}}else{var h=Date,_=h.now();a.unstable_now=function(){return h.now()-_}}var bt=[],g=[],j=1,b=null,Et=3,It=!1,zt=!1,er=!1,Hn=typeof setTimeout=="function"?setTimeout:null,Qt=typeof clearTimeout=="function"?clearTimeout:null,cr=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function fr(w0){for(var L0=o(g);L0!==null;){if(L0.callback===null)s(g);else if(L0.startTime<=w0)s(g),L0.sortIndex=L0.expirationTime,e(bt,L0);else break;L0=o(g)}}function jr(w0){if(er=!1,fr(w0),!zt)if(o(bt)!==null)zt=!0,H0(e0);else{var L0=o(g);L0!==null&&ty(jr,L0.startTime-w0)}}function e0(w0,L0){zt=!1,er&&(er=!1,Qt(l0),l0=-1),It=!0;var k0=Et;try{for(fr(L0),b=o(bt);b!==null&&(!(b.expirationTime>L0)||w0&&!f0());){var T0=b.callback;if(typeof T0=="function"){b.callback=null,Et=b.priorityLevel;var q0=T0(b.expirationTime<=L0);L0=a.unstable_now(),typeof q0=="function"?b.callback=q0:b===o(bt)&&s(bt),fr(L0)}else s(bt);b=o(bt)}if(b!==null)var vy=!0;else{var J0=o(g);J0!==null&&ty(jr,J0.startTime-L0),vy=!1}return vy}finally{b=null,Et=k0,It=!1}}var t0=!1,o0=null,l0=-1,g0=5,i0=-1;function f0(){return!(a.unstable_now()-i0<g0)}function C0(){if(o0!==null){var w0=a.unstable_now();i0=w0;var L0=!0;try{L0=o0(!0,w0)}finally{L0?Z0():(t0=!1,o0=null)}}else t0=!1}var Z0;if(typeof cr=="function")Z0=function(){cr(C0)};else if(typeof MessageChannel<"u"){var R0=new MessageChannel,Y0=R0.port2;R0.port1.onmessage=C0,Z0=function(){Y0.postMessage(null)}}else Z0=function(){Hn(C0,0)};function H0(w0){o0=w0,t0||(t0=!0,Z0())}function ty(w0,L0){l0=Hn(function(){w0(a.unstable_now())},L0)}a.unstable_IdlePriority=5,a.unstable_ImmediatePriority=1,a.unstable_LowPriority=4,a.unstable_NormalPriority=3,a.unstable_Profiling=null,a.unstable_UserBlockingPriority=2,a.unstable_cancelCallback=function(w0){w0.callback=null},a.unstable_continueExecution=function(){zt||It||(zt=!0,H0(e0))},a.unstable_forceFrameRate=function(w0){0>w0||125<w0?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):g0=0<w0?Math.floor(1e3/w0):5},a.unstable_getCurrentPriorityLevel=function(){return Et},a.unstable_getFirstCallbackNode=function(){return o(bt)},a.unstable_next=function(w0){switch(Et){case 1:case 2:case 3:var L0=3;break;default:L0=Et}var k0=Et;Et=L0;try{return w0()}finally{Et=k0}},a.unstable_pauseExecution=function(){},a.unstable_requestPaint=function(){},a.unstable_runWithPriority=function(w0,L0){switch(w0){case 1:case 2:case 3:case 4:case 5:break;default:w0=3}var k0=Et;Et=w0;try{return L0()}finally{Et=k0}},a.unstable_scheduleCallback=function(w0,L0,k0){var T0=a.unstable_now();switch(typeof k0=="object"&&k0!==null?(k0=k0.delay,k0=typeof k0=="number"&&0<k0?T0+k0:T0):k0=T0,w0){case 1:var q0=-1;break;case 2:q0=250;break;case 5:q0=1073741823;break;case 4:q0=1e4;break;default:q0=5e3}return q0=k0+q0,w0={id:j++,callback:L0,priorityLevel:w0,startTime:k0,expirationTime:q0,sortIndex:-1},k0>T0?(w0.sortIndex=k0,e(g,w0),o(bt)===null&&w0===o(g)&&(er?(Qt(l0),l0=-1):er=!0,ty(jr,k0-T0))):(w0.sortIndex=q0,e(bt,w0),zt||It||(zt=!0,H0(e0))),w0},a.unstable_shouldYield=f0,a.unstable_wrapCallback=function(w0){var L0=Et;return function(){var k0=Et;Et=L0;try{return w0.apply(this,arguments)}finally{Et=k0}}}})(scheduler_production_min);scheduler.exports=scheduler_production_min;var schedulerExports=scheduler.exports;/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var reactReconciler_production_min=function(e){var o={},s=reactExports,d=schedulerExports,c=Object.assign;function h(Pt){for(var Ut="https://reactjs.org/docs/error-decoder.html?invariant="+Pt,vr=1;vr<arguments.length;vr++)Ut+="&args[]="+encodeURIComponent(arguments[vr]);return"Minified React error #"+Pt+"; visit "+Ut+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var _=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,bt=Symbol.for("react.element"),g=Symbol.for("react.portal"),j=Symbol.for("react.fragment"),b=Symbol.for("react.strict_mode"),Et=Symbol.for("react.profiler"),It=Symbol.for("react.provider"),zt=Symbol.for("react.context"),er=Symbol.for("react.forward_ref"),Hn=Symbol.for("react.suspense"),Qt=Symbol.for("react.suspense_list"),cr=Symbol.for("react.memo"),fr=Symbol.for("react.lazy"),jr=Symbol.for("react.offscreen"),e0=Symbol.iterator;function t0(Pt){return Pt===null||typeof Pt!="object"?null:(Pt=e0&&Pt[e0]||Pt["@@iterator"],typeof Pt=="function"?Pt:null)}function o0(Pt){if(Pt==null)return null;if(typeof Pt=="function")return Pt.displayName||Pt.name||null;if(typeof Pt=="string")return Pt;switch(Pt){case j:return"Fragment";case g:return"Portal";case Et:return"Profiler";case b:return"StrictMode";case Hn:return"Suspense";case Qt:return"SuspenseList"}if(typeof Pt=="object")switch(Pt.$$typeof){case zt:return(Pt.displayName||"Context")+".Consumer";case It:return(Pt._context.displayName||"Context")+".Provider";case er:var Ut=Pt.render;return Pt=Pt.displayName,Pt||(Pt=Ut.displayName||Ut.name||"",Pt=Pt!==""?"ForwardRef("+Pt+")":"ForwardRef"),Pt;case cr:return Ut=Pt.displayName||null,Ut!==null?Ut:o0(Pt.type)||"Memo";case fr:Ut=Pt._payload,Pt=Pt._init;try{return o0(Pt(Ut))}catch{}}return null}function l0(Pt){var Ut=Pt.type;switch(Pt.tag){case 24:return"Cache";case 9:return(Ut.displayName||"Context")+".Consumer";case 10:return(Ut._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return Pt=Ut.render,Pt=Pt.displayName||Pt.name||"",Ut.displayName||(Pt!==""?"ForwardRef("+Pt+")":"ForwardRef");case 7:return"Fragment";case 5:return Ut;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return o0(Ut);case 8:return Ut===b?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof Ut=="function")return Ut.displayName||Ut.name||null;if(typeof Ut=="string")return Ut}return null}function g0(Pt){var Ut=Pt,vr=Pt;if(Pt.alternate)for(;Ut.return;)Ut=Ut.return;else{Pt=Ut;do Ut=Pt,Ut.flags&4098&&(vr=Ut.return),Pt=Ut.return;while(Pt)}return Ut.tag===3?vr:null}function i0(Pt){if(g0(Pt)!==Pt)throw Error(h(188))}function f0(Pt){var Ut=Pt.alternate;if(!Ut){if(Ut=g0(Pt),Ut===null)throw Error(h(188));return Ut!==Pt?null:Pt}for(var vr=Pt,Kr=Ut;;){var n0=vr.return;if(n0===null)break;var s0=n0.alternate;if(s0===null){if(Kr=n0.return,Kr!==null){vr=Kr;continue}break}if(n0.child===s0.child){for(s0=n0.child;s0;){if(s0===vr)return i0(n0),Pt;if(s0===Kr)return i0(n0),Ut;s0=s0.sibling}throw Error(h(188))}if(vr.return!==Kr.return)vr=n0,Kr=s0;else{for(var z0=!1,ny=n0.child;ny;){if(ny===vr){z0=!0,vr=n0,Kr=s0;break}if(ny===Kr){z0=!0,Kr=n0,vr=s0;break}ny=ny.sibling}if(!z0){for(ny=s0.child;ny;){if(ny===vr){z0=!0,vr=s0,Kr=n0;break}if(ny===Kr){z0=!0,Kr=s0,vr=n0;break}ny=ny.sibling}if(!z0)throw Error(h(189))}}if(vr.alternate!==Kr)throw Error(h(190))}if(vr.tag!==3)throw Error(h(188));return vr.stateNode.current===vr?Pt:Ut}function C0(Pt){return Pt=f0(Pt),Pt!==null?Z0(Pt):null}function Z0(Pt){if(Pt.tag===5||Pt.tag===6)return Pt;for(Pt=Pt.child;Pt!==null;){var Ut=Z0(Pt);if(Ut!==null)return Ut;Pt=Pt.sibling}return null}function R0(Pt){if(Pt.tag===5||Pt.tag===6)return Pt;for(Pt=Pt.child;Pt!==null;){if(Pt.tag!==4){var Ut=R0(Pt);if(Ut!==null)return Ut}Pt=Pt.sibling}return null}var Y0=Array.isArray,H0=e.getPublicInstance,ty=e.getRootHostContext,w0=e.getChildHostContext,L0=e.prepareForCommit,k0=e.resetAfterCommit,T0=e.createInstance,q0=e.appendInitialChild,vy=e.finalizeInitialChildren,J0=e.prepareUpdate,cy=e.shouldSetTextContent,Ty=e.createTextInstance,Uy=e.scheduleTimeout,Qy=e.cancelTimeout,Zy=e.noTimeout,iv=e.isPrimaryRenderer,zy=e.supportsMutation,B0=e.supportsPersistence,Ay=e.supportsHydration,hy=e.getInstanceFromNode,Ly=e.preparePortalMount,Iy=e.getCurrentEventPriority,Jy=e.detachDeletedInstance,Gy=e.supportsMicrotasks,sv=e.scheduleMicrotask,yv=e.supportsTestSelectors,I0=e.findFiberRoot,b0=e.getBoundingRect,uy=e.getTextContent,Ey=e.isHiddenSubtree,Dy=e.matchAccessibilityRole,By=e.setFocusIfFocusable,bv=e.setupIntersectionObserver,av=e.appendChild,Wy=e.appendChildToContainer,my=e.commitTextUpdate,uv=e.commitMount,Hy=e.commitUpdate,wv=e.insertBefore,mv=e.insertInContainerBefore,cv=e.removeChild,O0=e.removeChildFromContainer,oy=e.resetTextContent,Py=e.hideInstance,nv=e.hideTextInstance,d0=e.unhideInstance,v0=e.unhideTextInstance,N0=e.clearContainer,F0=e.cloneInstance,sy=e.createContainerChildSet,xy=e.appendChildToContainerChildSet,ev=e.finalizeContainerChildren,Sv=e.replaceContainerChildren,kv=e.cloneHiddenInstance,Vv=e.cloneHiddenTextInstance,$v=e.canHydrateInstance,ov=e.canHydrateTextInstance,C_=e.canHydrateSuspenseInstance,wy=e.isSuspenseInstancePending,Zv=e.isSuspenseInstanceFallback,Xv=e.registerSuspenseInstanceRetry,v_=e.getNextHydratableSibling,Rv=e.getFirstHydratableChild,i1=e.getFirstHydratableChildWithinContainer,h1=e.getFirstHydratableChildWithinSuspenseInstance,m0=e.hydrateInstance,E0=e.hydrateTextInstance,j0=e.hydrateSuspenseInstance,h0=e.getNextHydratableInstanceAfterSuspenseInstance,$0=e.commitHydratedContainer,P0=e.commitHydratedSuspenseInstance,Yr=e.clearSuspenseBoundary,r0=e.clearSuspenseBoundaryFromContainer,p0=e.shouldDeleteUnhydratedTailInstances,_0=e.didNotMatchHydratedContainerTextInstance,D0=e.didNotMatchHydratedTextInstance,V0;function yy(Pt){if(V0===void 0)try{throw Error()}catch(vr){var Ut=vr.stack.trim().match(/\n( *(at )?)/);V0=Ut&&Ut[1]||""}return`
`+V0+Pt}var ly=!1;function gy(Pt,Ut){if(!Pt||ly)return"";ly=!0;var vr=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(Ut)if(Ut=function(){throw Error()},Object.defineProperty(Ut.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Ut,[])}catch(tv){var Kr=tv}Reflect.construct(Pt,[],Ut)}else{try{Ut.call()}catch(tv){Kr=tv}Pt.call(Ut.prototype)}else{try{throw Error()}catch(tv){Kr=tv}Pt()}}catch(tv){if(tv&&Kr&&typeof tv.stack=="string"){for(var n0=tv.stack.split(`
`),s0=Kr.stack.split(`
`),z0=n0.length-1,ny=s0.length-1;1<=z0&&0<=ny&&n0[z0]!==s0[ny];)ny--;for(;1<=z0&&0<=ny;z0--,ny--)if(n0[z0]!==s0[ny]){if(z0!==1||ny!==1)do if(z0--,ny--,0>ny||n0[z0]!==s0[ny]){var My=`
`+n0[z0].replace(" at new "," at ");return Pt.displayName&&My.includes("<anonymous>")&&(My=My.replace("<anonymous>",Pt.displayName)),My}while(1<=z0&&0<=ny);break}}}finally{ly=!1,Error.prepareStackTrace=vr}return(Pt=Pt?Pt.displayName||Pt.name:"")?yy(Pt):""}var ky=Object.prototype.hasOwnProperty,jy=[],rv=-1;function dv(Pt){return{current:Pt}}function K0(Pt){0>rv||(Pt.current=jy[rv],jy[rv]=null,rv--)}function Cy(Pt,Ut){rv++,jy[rv]=Pt.current,Pt.current=Ut}var lv={},vv=dv(lv),Mv=dv(!1),f_=lv;function b_(Pt,Ut){var vr=Pt.type.contextTypes;if(!vr)return lv;var Kr=Pt.stateNode;if(Kr&&Kr.__reactInternalMemoizedUnmaskedChildContext===Ut)return Kr.__reactInternalMemoizedMaskedChildContext;var n0={},s0;for(s0 in vr)n0[s0]=Ut[s0];return Kr&&(Pt=Pt.stateNode,Pt.__reactInternalMemoizedUnmaskedChildContext=Ut,Pt.__reactInternalMemoizedMaskedChildContext=n0),n0}function x_(Pt){return Pt=Pt.childContextTypes,Pt!=null}function o_(){K0(Mv),K0(vv)}function Yy(Pt,Ut,vr){if(vv.current!==lv)throw Error(h(168));Cy(vv,Ut),Cy(Mv,vr)}function w_(Pt,Ut,vr){var Kr=Pt.stateNode;if(Ut=Ut.childContextTypes,typeof Kr.getChildContext!="function")return vr;Kr=Kr.getChildContext();for(var n0 in Kr)if(!(n0 in Ut))throw Error(h(108,l0(Pt)||"Unknown",n0));return c({},vr,Kr)}function Ov(Pt){return Pt=(Pt=Pt.stateNode)&&Pt.__reactInternalMemoizedMergedChildContext||lv,f_=vv.current,Cy(vv,Pt),Cy(Mv,Mv.current),!0}function Qv(Pt,Ut,vr){var Kr=Pt.stateNode;if(!Kr)throw Error(h(169));vr?(Pt=w_(Pt,Ut,f_),Kr.__reactInternalMemoizedMergedChildContext=Pt,K0(Mv),K0(vv),Cy(vv,Pt)):K0(Mv),Cy(Mv,vr)}var s_=Math.clz32?Math.clz32:z_,S_=Math.log,B_=Math.LN2;function z_(Pt){return Pt>>>=0,Pt===0?32:31-(S_(Pt)/B_|0)|0}var D1=64,B1=4194304;function m1(Pt){switch(Pt&-Pt){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return Pt&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return Pt&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return Pt}}function S1(Pt,Ut){var vr=Pt.pendingLanes;if(vr===0)return 0;var Kr=0,n0=Pt.suspendedLanes,s0=Pt.pingedLanes,z0=vr&268435455;if(z0!==0){var ny=z0&~n0;ny!==0?Kr=m1(ny):(s0&=z0,s0!==0&&(Kr=m1(s0)))}else z0=vr&~n0,z0!==0?Kr=m1(z0):s0!==0&&(Kr=m1(s0));if(Kr===0)return 0;if(Ut!==0&&Ut!==Kr&&!(Ut&n0)&&(n0=Kr&-Kr,s0=Ut&-Ut,n0>=s0||n0===16&&(s0&4194240)!==0))return Ut;if(Kr&4&&(Kr|=vr&16),Ut=Pt.entangledLanes,Ut!==0)for(Pt=Pt.entanglements,Ut&=Kr;0<Ut;)vr=31-s_(Ut),n0=1<<vr,Kr|=Pt[vr],Ut&=~n0;return Kr}function vw(Pt,Ut){switch(Pt){case 1:case 2:case 4:return Ut+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return Ut+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Hw(Pt,Ut){for(var vr=Pt.suspendedLanes,Kr=Pt.pingedLanes,n0=Pt.expirationTimes,s0=Pt.pendingLanes;0<s0;){var z0=31-s_(s0),ny=1<<z0,My=n0[z0];My===-1?(!(ny&vr)||ny&Kr)&&(n0[z0]=vw(ny,Ut)):My<=Ut&&(Pt.expiredLanes|=ny),s0&=~ny}}function Cw(Pt){return Pt=Pt.pendingLanes&-1073741825,Pt!==0?Pt:Pt&1073741824?1073741824:0}function H1(Pt){for(var Ut=[],vr=0;31>vr;vr++)Ut.push(Pt);return Ut}function W1(Pt,Ut,vr){Pt.pendingLanes|=Ut,Ut!==536870912&&(Pt.suspendedLanes=0,Pt.pingedLanes=0),Pt=Pt.eventTimes,Ut=31-s_(Ut),Pt[Ut]=vr}function u0(Pt,Ut){var vr=Pt.pendingLanes&~Ut;Pt.pendingLanes=Ut,Pt.suspendedLanes=0,Pt.pingedLanes=0,Pt.expiredLanes&=Ut,Pt.mutableReadLanes&=Ut,Pt.entangledLanes&=Ut,Ut=Pt.entanglements;var Kr=Pt.eventTimes;for(Pt=Pt.expirationTimes;0<vr;){var n0=31-s_(vr),s0=1<<n0;Ut[n0]=0,Kr[n0]=-1,Pt[n0]=-1,vr&=~s0}}function M0(Pt,Ut){var vr=Pt.entangledLanes|=Ut;for(Pt=Pt.entanglements;vr;){var Kr=31-s_(vr),n0=1<<Kr;n0&Ut|Pt[Kr]&Ut&&(Pt[Kr]|=Ut),vr&=~n0}}var G0=0;function X0(Pt){return Pt&=-Pt,1<Pt?4<Pt?Pt&268435455?16:536870912:4:1}var Ky=d.unstable_scheduleCallback,Xy=d.unstable_cancelCallback,_v=d.unstable_shouldYield,A_=d.unstable_requestPaint,y_=d.unstable_now,$_=d.unstable_ImmediatePriority,G_=d.unstable_UserBlockingPriority,aw=d.unstable_NormalPriority,Ww=d.unstable_IdlePriority,Ry=null,t_=null;function Pv(Pt){if(t_&&typeof t_.onCommitFiberRoot=="function")try{t_.onCommitFiberRoot(Ry,Pt,void 0,(Pt.current.flags&128)===128)}catch{}}function l_(Pt,Ut){return Pt===Ut&&(Pt!==0||1/Pt===1/Ut)||Pt!==Pt&&Ut!==Ut}var t1=typeof Object.is=="function"?Object.is:l_,L1=null,jw=!1,lx=!1;function Fx(Pt){L1===null?L1=[Pt]:L1.push(Pt)}function y2(Pt){jw=!0,Fx(Pt)}function E1(){if(!lx&&L1!==null){lx=!0;var Pt=0,Ut=G0;try{var vr=L1;for(G0=1;Pt<vr.length;Pt++){var Kr=vr[Pt];do Kr=Kr(!0);while(Kr!==null)}L1=null,jw=!1}catch(n0){throw L1!==null&&(L1=L1.slice(Pt+1)),Ky($_,E1),n0}finally{G0=Ut,lx=!1}}return null}var ux=_.ReactCurrentBatchConfig;function O_(Pt,Ut){if(t1(Pt,Ut))return!0;if(typeof Pt!="object"||Pt===null||typeof Ut!="object"||Ut===null)return!1;var vr=Object.keys(Pt),Kr=Object.keys(Ut);if(vr.length!==Kr.length)return!1;for(Kr=0;Kr<vr.length;Kr++){var n0=vr[Kr];if(!ky.call(Ut,n0)||!t1(Pt[n0],Ut[n0]))return!1}return!0}function om(Pt){switch(Pt.tag){case 5:return yy(Pt.type);case 16:return yy("Lazy");case 13:return yy("Suspense");case 19:return yy("SuspenseList");case 0:case 2:case 15:return Pt=gy(Pt.type,!1),Pt;case 11:return Pt=gy(Pt.type.render,!1),Pt;case 1:return Pt=gy(Pt.type,!0),Pt;default:return""}}function c0(Pt,Ut){if(Pt&&Pt.defaultProps){Ut=c({},Ut),Pt=Pt.defaultProps;for(var vr in Pt)Ut[vr]===void 0&&(Ut[vr]=Pt[vr]);return Ut}return Ut}var x0=dv(null),U0=null,ry=null,by=null;function Vy(){by=ry=U0=null}function Ev(Pt,Ut,vr){iv?(Cy(x0,Ut._currentValue),Ut._currentValue=vr):(Cy(x0,Ut._currentValue2),Ut._currentValue2=vr)}function Hv(Pt){var Ut=x0.current;K0(x0),iv?Pt._currentValue=Ut:Pt._currentValue2=Ut}function Nv(Pt,Ut,vr){for(;Pt!==null;){var Kr=Pt.alternate;if((Pt.childLanes&Ut)!==Ut?(Pt.childLanes|=Ut,Kr!==null&&(Kr.childLanes|=Ut)):Kr!==null&&(Kr.childLanes&Ut)!==Ut&&(Kr.childLanes|=Ut),Pt===vr)break;Pt=Pt.return}}function jv(Pt,Ut){U0=Pt,by=ry=null,Pt=Pt.dependencies,Pt!==null&&Pt.firstContext!==null&&(Pt.lanes&Ut&&(A1=!0),Pt.firstContext=null)}function Lv(Pt){var Ut=iv?Pt._currentValue:Pt._currentValue2;if(by!==Pt)if(Pt={context:Pt,memoizedValue:Ut,next:null},ry===null){if(U0===null)throw Error(h(308));ry=Pt,U0.dependencies={lanes:0,firstContext:Pt}}else ry=ry.next=Pt;return Ut}var p_=null,dy=!1;function qv(Pt){Pt.updateQueue={baseState:Pt.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function d_(Pt,Ut){Pt=Pt.updateQueue,Ut.updateQueue===Pt&&(Ut.updateQueue={baseState:Pt.baseState,firstBaseUpdate:Pt.firstBaseUpdate,lastBaseUpdate:Pt.lastBaseUpdate,shared:Pt.shared,effects:Pt.effects})}function P_(Pt,Ut){return{eventTime:Pt,lane:Ut,tag:0,payload:null,callback:null,next:null}}function _1(Pt,Ut){var vr=Pt.updateQueue;vr!==null&&(vr=vr.shared,V_!==null&&Pt.mode&1&&!(r_&2)?(Pt=vr.interleaved,Pt===null?(Ut.next=Ut,p_===null?p_=[vr]:p_.push(vr)):(Ut.next=Pt.next,Pt.next=Ut),vr.interleaved=Ut):(Pt=vr.pending,Pt===null?Ut.next=Ut:(Ut.next=Pt.next,Pt.next=Ut),vr.pending=Ut))}function cx(Pt,Ut,vr){if(Ut=Ut.updateQueue,Ut!==null&&(Ut=Ut.shared,(vr&4194240)!==0)){var Kr=Ut.lanes;Kr&=Pt.pendingLanes,vr|=Kr,Ut.lanes=vr,M0(Pt,vr)}}function M_(Pt,Ut){var vr=Pt.updateQueue,Kr=Pt.alternate;if(Kr!==null&&(Kr=Kr.updateQueue,vr===Kr)){var n0=null,s0=null;if(vr=vr.firstBaseUpdate,vr!==null){do{var z0={eventTime:vr.eventTime,lane:vr.lane,tag:vr.tag,payload:vr.payload,callback:vr.callback,next:null};s0===null?n0=s0=z0:s0=s0.next=z0,vr=vr.next}while(vr!==null);s0===null?n0=s0=Ut:s0=s0.next=Ut}else n0=s0=Ut;vr={baseState:Kr.baseState,firstBaseUpdate:n0,lastBaseUpdate:s0,shared:Kr.shared,effects:Kr.effects},Pt.updateQueue=vr;return}Pt=vr.lastBaseUpdate,Pt===null?vr.firstBaseUpdate=Ut:Pt.next=Ut,vr.lastBaseUpdate=Ut}function j1(Pt,Ut,vr,Kr){var n0=Pt.updateQueue;dy=!1;var s0=n0.firstBaseUpdate,z0=n0.lastBaseUpdate,ny=n0.shared.pending;if(ny!==null){n0.shared.pending=null;var My=ny,tv=My.next;My.next=null,z0===null?s0=tv:z0.next=tv,z0=My;var xv=Pt.alternate;xv!==null&&(xv=xv.updateQueue,ny=xv.lastBaseUpdate,ny!==z0&&(ny===null?xv.firstBaseUpdate=tv:ny.next=tv,xv.lastBaseUpdate=My))}if(s0!==null){var Yv=n0.baseState;z0=0,xv=tv=My=null,ny=s0;do{var Iv=ny.lane,E_=ny.eventTime;if((Kr&Iv)===Iv){xv!==null&&(xv=xv.next={eventTime:E_,lane:0,tag:ny.tag,payload:ny.payload,callback:ny.callback,next:null});e:{var Tv=Pt,f1=ny;switch(Iv=Ut,E_=vr,f1.tag){case 1:if(Tv=f1.payload,typeof Tv=="function"){Yv=Tv.call(E_,Yv,Iv);break e}Yv=Tv;break e;case 3:Tv.flags=Tv.flags&-65537|128;case 0:if(Tv=f1.payload,Iv=typeof Tv=="function"?Tv.call(E_,Yv,Iv):Tv,Iv==null)break e;Yv=c({},Yv,Iv);break e;case 2:dy=!0}}ny.callback!==null&&ny.lane!==0&&(Pt.flags|=64,Iv=n0.effects,Iv===null?n0.effects=[ny]:Iv.push(ny))}else E_={eventTime:E_,lane:Iv,tag:ny.tag,payload:ny.payload,callback:ny.callback,next:null},xv===null?(tv=xv=E_,My=Yv):xv=xv.next=E_,z0|=Iv;if(ny=ny.next,ny===null){if(ny=n0.shared.pending,ny===null)break;Iv=ny,ny=Iv.next,Iv.next=null,n0.lastBaseUpdate=Iv,n0.shared.pending=null}}while(!0);if(xv===null&&(My=Yv),n0.baseState=My,n0.firstBaseUpdate=tv,n0.lastBaseUpdate=xv,Ut=n0.shared.interleaved,Ut!==null){n0=Ut;do z0|=n0.lane,n0=n0.next;while(n0!==Ut)}else s0===null&&(n0.shared.lanes=0);Px|=z0,Pt.lanes=z0,Pt.memoizedState=Yv}}function v2(Pt,Ut,vr){if(Pt=Ut.effects,Ut.effects=null,Pt!==null)for(Ut=0;Ut<Pt.length;Ut++){var Kr=Pt[Ut],n0=Kr.callback;if(n0!==null){if(Kr.callback=null,Kr=vr,typeof n0!="function")throw Error(h(191,n0));n0.call(Kr)}}}var DS=new s.Component().refs;function Ux(Pt,Ut,vr,Kr){Ut=Pt.memoizedState,vr=vr(Kr,Ut),vr=vr==null?Ut:c({},Ut,vr),Pt.memoizedState=vr,Pt.lanes===0&&(Pt.updateQueue.baseState=vr)}var _2={isMounted:function(Pt){return(Pt=Pt._reactInternals)?g0(Pt)===Pt:!1},enqueueSetState:function(Pt,Ut,vr){Pt=Pt._reactInternals;var Kr=l1(),n0=pw(Pt),s0=P_(Kr,n0);s0.payload=Ut,vr!=null&&(s0.callback=vr),_1(Pt,s0),Ut=N1(Pt,n0,Kr),Ut!==null&&cx(Ut,Pt,n0)},enqueueReplaceState:function(Pt,Ut,vr){Pt=Pt._reactInternals;var Kr=l1(),n0=pw(Pt),s0=P_(Kr,n0);s0.tag=1,s0.payload=Ut,vr!=null&&(s0.callback=vr),_1(Pt,s0),Ut=N1(Pt,n0,Kr),Ut!==null&&cx(Ut,Pt,n0)},enqueueForceUpdate:function(Pt,Ut){Pt=Pt._reactInternals;var vr=l1(),Kr=pw(Pt),n0=P_(vr,Kr);n0.tag=2,Ut!=null&&(n0.callback=Ut),_1(Pt,n0),Ut=N1(Pt,Kr,vr),Ut!==null&&cx(Ut,Pt,Kr)}};function BS(Pt,Ut,vr,Kr,n0,s0,z0){return Pt=Pt.stateNode,typeof Pt.shouldComponentUpdate=="function"?Pt.shouldComponentUpdate(Kr,s0,z0):Ut.prototype&&Ut.prototype.isPureReactComponent?!O_(vr,Kr)||!O_(n0,s0):!0}function LS(Pt,Ut,vr){var Kr=!1,n0=lv,s0=Ut.contextType;return typeof s0=="object"&&s0!==null?s0=Lv(s0):(n0=x_(Ut)?f_:vv.current,Kr=Ut.contextTypes,s0=(Kr=Kr!=null)?b_(Pt,n0):lv),Ut=new Ut(vr,s0),Pt.memoizedState=Ut.state!==null&&Ut.state!==void 0?Ut.state:null,Ut.updater=_2,Pt.stateNode=Ut,Ut._reactInternals=Pt,Kr&&(Pt=Pt.stateNode,Pt.__reactInternalMemoizedUnmaskedChildContext=n0,Pt.__reactInternalMemoizedMaskedChildContext=s0),Ut}function j2(Pt,Ut,vr,Kr){Pt=Ut.state,typeof Ut.componentWillReceiveProps=="function"&&Ut.componentWillReceiveProps(vr,Kr),typeof Ut.UNSAFE_componentWillReceiveProps=="function"&&Ut.UNSAFE_componentWillReceiveProps(vr,Kr),Ut.state!==Pt&&_2.enqueueReplaceState(Ut,Ut.state,null)}function dx(Pt,Ut,vr,Kr){var n0=Pt.stateNode;n0.props=vr,n0.state=Pt.memoizedState,n0.refs=DS,qv(Pt);var s0=Ut.contextType;typeof s0=="object"&&s0!==null?n0.context=Lv(s0):(s0=x_(Ut)?f_:vv.current,n0.context=b_(Pt,s0)),n0.state=Pt.memoizedState,s0=Ut.getDerivedStateFromProps,typeof s0=="function"&&(Ux(Pt,Ut,s0,vr),n0.state=Pt.memoizedState),typeof Ut.getDerivedStateFromProps=="function"||typeof n0.getSnapshotBeforeUpdate=="function"||typeof n0.UNSAFE_componentWillMount!="function"&&typeof n0.componentWillMount!="function"||(Ut=n0.state,typeof n0.componentWillMount=="function"&&n0.componentWillMount(),typeof n0.UNSAFE_componentWillMount=="function"&&n0.UNSAFE_componentWillMount(),Ut!==n0.state&&_2.enqueueReplaceState(n0,n0.state,null),j1(Pt,vr,n0,Kr),n0.state=Pt.memoizedState),typeof n0.componentDidMount=="function"&&(Pt.flags|=4194308)}var q1=[],fx=0,zx=null,Gx=0,b1=[],w1=0,Mw=null,_w=1,Z1="";function bw(Pt,Ut){q1[fx++]=Gx,q1[fx++]=zx,zx=Pt,Gx=Ut}function kS(Pt,Ut,vr){b1[w1++]=_w,b1[w1++]=Z1,b1[w1++]=Mw,Mw=Pt;var Kr=_w;Pt=Z1;var n0=32-s_(Kr)-1;Kr&=~(1<<n0),vr+=1;var s0=32-s_(Ut)+n0;if(30<s0){var z0=n0-n0%5;s0=(Kr&(1<<z0)-1).toString(32),Kr>>=z0,n0-=z0,_w=1<<32-s_(Ut)+n0|vr<<n0|Kr,Z1=s0+Pt}else _w=1<<s0|vr<<n0|Kr,Z1=Pt}function b2(Pt){Pt.return!==null&&(bw(Pt,1),kS(Pt,1,0))}function g1(Pt){for(;Pt===zx;)zx=q1[--fx],q1[fx]=null,Gx=q1[--fx],q1[fx]=null;for(;Pt===Mw;)Mw=b1[--w1],b1[w1]=null,Z1=b1[--w1],b1[w1]=null,_w=b1[--w1],b1[w1]=null}var y1=null,n1=null,I_=!1,hx=!1,K1=null;function NS(Pt,Ut){var vr=F1(5,null,null,0);vr.elementType="DELETED",vr.stateNode=Ut,vr.return=Pt,Ut=Pt.deletions,Ut===null?(Pt.deletions=[vr],Pt.flags|=16):Ut.push(vr)}function FS(Pt,Ut){switch(Pt.tag){case 5:return Ut=$v(Ut,Pt.type,Pt.pendingProps),Ut!==null?(Pt.stateNode=Ut,y1=Pt,n1=Rv(Ut),!0):!1;case 6:return Ut=ov(Ut,Pt.pendingProps),Ut!==null?(Pt.stateNode=Ut,y1=Pt,n1=null,!0):!1;case 13:if(Ut=C_(Ut),Ut!==null){var vr=Mw!==null?{id:_w,overflow:Z1}:null;return Pt.memoizedState={dehydrated:Ut,treeContext:vr,retryLane:1073741824},vr=F1(18,null,null,0),vr.stateNode=Ut,vr.return=Pt,Pt.child=vr,y1=Pt,n1=null,!0}return!1;default:return!1}}function q2(Pt){return(Pt.mode&1)!==0&&(Pt.flags&128)===0}function Z2(Pt){if(I_){var Ut=n1;if(Ut){var vr=Ut;if(!FS(Pt,Ut)){if(q2(Pt))throw Error(h(418));Ut=v_(vr);var Kr=y1;Ut&&FS(Pt,Ut)?NS(Kr,vr):(Pt.flags=Pt.flags&-4097|2,I_=!1,y1=Pt)}}else{if(q2(Pt))throw Error(h(418));Pt.flags=Pt.flags&-4097|2,I_=!1,y1=Pt}}}function qw(Pt){for(Pt=Pt.return;Pt!==null&&Pt.tag!==5&&Pt.tag!==3&&Pt.tag!==13;)Pt=Pt.return;y1=Pt}function Vx(Pt){if(!Ay||Pt!==y1)return!1;if(!I_)return qw(Pt),I_=!0,!1;if(Pt.tag!==3&&(Pt.tag!==5||p0(Pt.type)&&!cy(Pt.type,Pt.memoizedProps))){var Ut=n1;if(Ut){if(q2(Pt)){for(Pt=n1;Pt;)Pt=v_(Pt);throw Error(h(418))}for(;Ut;)NS(Pt,Ut),Ut=v_(Ut)}}if(qw(Pt),Pt.tag===13){if(!Ay)throw Error(h(316));if(Pt=Pt.memoizedState,Pt=Pt!==null?Pt.dehydrated:null,!Pt)throw Error(h(317));n1=h0(Pt)}else n1=y1?v_(Pt.stateNode):null;return!0}function mx(){Ay&&(n1=y1=null,hx=I_=!1)}function Hx(Pt){K1===null?K1=[Pt]:K1.push(Pt)}function gx(Pt,Ut,vr){if(Pt=vr.ref,Pt!==null&&typeof Pt!="function"&&typeof Pt!="object"){if(vr._owner){if(vr=vr._owner,vr){if(vr.tag!==1)throw Error(h(309));var Kr=vr.stateNode}if(!Kr)throw Error(h(147,Pt));var n0=Kr,s0=""+Pt;return Ut!==null&&Ut.ref!==null&&typeof Ut.ref=="function"&&Ut.ref._stringRef===s0?Ut.ref:(Ut=function(z0){var ny=n0.refs;ny===DS&&(ny=n0.refs={}),z0===null?delete ny[s0]:ny[s0]=z0},Ut._stringRef=s0,Ut)}if(typeof Pt!="string")throw Error(h(284));if(!vr._owner)throw Error(h(290,Pt))}return Pt}function X1(Pt,Ut){throw Pt=Object.prototype.toString.call(Ut),Error(h(31,Pt==="[object Object]"?"object with keys {"+Object.keys(Ut).join(", ")+"}":Pt))}function Wx(Pt){var Ut=Pt._init;return Ut(Pt._payload)}function US(Pt){function Ut(fy,iy){if(Pt){var $y=fy.deletions;$y===null?(fy.deletions=[iy],fy.flags|=16):$y.push(iy)}}function vr(fy,iy){if(!Pt)return null;for(;iy!==null;)Ut(fy,iy),iy=iy.sibling;return null}function Kr(fy,iy){for(fy=new Map;iy!==null;)iy.key!==null?fy.set(iy.key,iy):fy.set(iy.index,iy),iy=iy.sibling;return fy}function n0(fy,iy){return fy=Tw(fy,iy),fy.index=0,fy.sibling=null,fy}function s0(fy,iy,$y){return fy.index=$y,Pt?($y=fy.alternate,$y!==null?($y=$y.index,$y<iy?(fy.flags|=2,iy):$y):(fy.flags|=2,iy)):(fy.flags|=1048576,iy)}function z0(fy){return Pt&&fy.alternate===null&&(fy.flags|=2),fy}function ny(fy,iy,$y,hv){return iy===null||iy.tag!==6?(iy=d1($y,fy.mode,hv),iy.return=fy,iy):(iy=n0(iy,$y),iy.return=fy,iy)}function My(fy,iy,$y,hv){var Av=$y.type;return Av===j?xv(fy,iy,$y.props.children,hv,$y.key):iy!==null&&(iy.elementType===Av||typeof Av=="object"&&Av!==null&&Av.$$typeof===fr&&Wx(Av)===iy.type)?(hv=n0(iy,$y.props),hv.ref=gx(fy,iy,$y),hv.return=fy,hv):(hv=U2($y.type,$y.key,$y.props,null,fy.mode,hv),hv.ref=gx(fy,iy,$y),hv.return=fy,hv)}function tv(fy,iy,$y,hv){return iy===null||iy.tag!==4||iy.stateNode.containerInfo!==$y.containerInfo||iy.stateNode.implementation!==$y.implementation?(iy=U1($y,fy.mode,hv),iy.return=fy,iy):(iy=n0(iy,$y.children||[]),iy.return=fy,iy)}function xv(fy,iy,$y,hv,Av){return iy===null||iy.tag!==7?(iy=Gw($y,fy.mode,hv,Av),iy.return=fy,iy):(iy=n0(iy,$y),iy.return=fy,iy)}function Yv(fy,iy,$y){if(typeof iy=="string"&&iy!==""||typeof iy=="number")return iy=d1(""+iy,fy.mode,$y),iy.return=fy,iy;if(typeof iy=="object"&&iy!==null){switch(iy.$$typeof){case bt:return $y=U2(iy.type,iy.key,iy.props,null,fy.mode,$y),$y.ref=gx(fy,null,iy),$y.return=fy,$y;case g:return iy=U1(iy,fy.mode,$y),iy.return=fy,iy;case fr:var hv=iy._init;return Yv(fy,hv(iy._payload),$y)}if(Y0(iy)||t0(iy))return iy=Gw(iy,fy.mode,$y,null),iy.return=fy,iy;X1(fy,iy)}return null}function Iv(fy,iy,$y,hv){var Av=iy!==null?iy.key:null;if(typeof $y=="string"&&$y!==""||typeof $y=="number")return Av!==null?null:ny(fy,iy,""+$y,hv);if(typeof $y=="object"&&$y!==null){switch($y.$$typeof){case bt:return $y.key===Av?My(fy,iy,$y,hv):null;case g:return $y.key===Av?tv(fy,iy,$y,hv):null;case fr:return Av=$y._init,Iv(fy,iy,Av($y._payload),hv)}if(Y0($y)||t0($y))return Av!==null?null:xv(fy,iy,$y,hv,null);X1(fy,$y)}return null}function E_(fy,iy,$y,hv,Av){if(typeof hv=="string"&&hv!==""||typeof hv=="number")return fy=fy.get($y)||null,ny(iy,fy,""+hv,Av);if(typeof hv=="object"&&hv!==null){switch(hv.$$typeof){case bt:return fy=fy.get(hv.key===null?$y:hv.key)||null,My(iy,fy,hv,Av);case g:return fy=fy.get(hv.key===null?$y:hv.key)||null,tv(iy,fy,hv,Av);case fr:var i_=hv._init;return E_(fy,iy,$y,i_(hv._payload),Av)}if(Y0(hv)||t0(hv))return fy=fy.get($y)||null,xv(iy,fy,hv,Av,null);X1(iy,hv)}return null}function Tv(fy,iy,$y,hv){for(var Av=null,i_=null,Jv=iy,a_=iy=0,W_=null;Jv!==null&&a_<$y.length;a_++){Jv.index>a_?(W_=Jv,Jv=null):W_=Jv.sibling;var m_=Iv(fy,Jv,$y[a_],hv);if(m_===null){Jv===null&&(Jv=W_);break}Pt&&Jv&&m_.alternate===null&&Ut(fy,Jv),iy=s0(m_,iy,a_),i_===null?Av=m_:i_.sibling=m_,i_=m_,Jv=W_}if(a_===$y.length)return vr(fy,Jv),I_&&bw(fy,a_),Av;if(Jv===null){for(;a_<$y.length;a_++)Jv=Yv(fy,$y[a_],hv),Jv!==null&&(iy=s0(Jv,iy,a_),i_===null?Av=Jv:i_.sibling=Jv,i_=Jv);return I_&&bw(fy,a_),Av}for(Jv=Kr(fy,Jv);a_<$y.length;a_++)W_=E_(Jv,fy,a_,$y[a_],hv),W_!==null&&(Pt&&W_.alternate!==null&&Jv.delete(W_.key===null?a_:W_.key),iy=s0(W_,iy,a_),i_===null?Av=W_:i_.sibling=W_,i_=W_);return Pt&&Jv.forEach(function(mw){return Ut(fy,mw)}),I_&&bw(fy,a_),Av}function f1(fy,iy,$y,hv){var Av=t0($y);if(typeof Av!="function")throw Error(h(150));if($y=Av.call($y),$y==null)throw Error(h(151));for(var i_=Av=null,Jv=iy,a_=iy=0,W_=null,m_=$y.next();Jv!==null&&!m_.done;a_++,m_=$y.next()){Jv.index>a_?(W_=Jv,Jv=null):W_=Jv.sibling;var mw=Iv(fy,Jv,m_.value,hv);if(mw===null){Jv===null&&(Jv=W_);break}Pt&&Jv&&mw.alternate===null&&Ut(fy,Jv),iy=s0(mw,iy,a_),i_===null?Av=mw:i_.sibling=mw,i_=mw,Jv=W_}if(m_.done)return vr(fy,Jv),I_&&bw(fy,a_),Av;if(Jv===null){for(;!m_.done;a_++,m_=$y.next())m_=Yv(fy,m_.value,hv),m_!==null&&(iy=s0(m_,iy,a_),i_===null?Av=m_:i_.sibling=m_,i_=m_);return I_&&bw(fy,a_),Av}for(Jv=Kr(fy,Jv);!m_.done;a_++,m_=$y.next())m_=E_(Jv,fy,a_,m_.value,hv),m_!==null&&(Pt&&m_.alternate!==null&&Jv.delete(m_.key===null?a_:m_.key),iy=s0(m_,iy,a_),i_===null?Av=m_:i_.sibling=m_,i_=m_);return Pt&&Jv.forEach(function(G2){return Ut(fy,G2)}),I_&&bw(fy,a_),Av}function R1(fy,iy,$y,hv){if(typeof $y=="object"&&$y!==null&&$y.type===j&&$y.key===null&&($y=$y.props.children),typeof $y=="object"&&$y!==null){switch($y.$$typeof){case bt:e:{for(var Av=$y.key,i_=iy;i_!==null;){if(i_.key===Av){if(Av=$y.type,Av===j){if(i_.tag===7){vr(fy,i_.sibling),iy=n0(i_,$y.props.children),iy.return=fy,fy=iy;break e}}else if(i_.elementType===Av||typeof Av=="object"&&Av!==null&&Av.$$typeof===fr&&Wx(Av)===i_.type){vr(fy,i_.sibling),iy=n0(i_,$y.props),iy.ref=gx(fy,i_,$y),iy.return=fy,fy=iy;break e}vr(fy,i_);break}else Ut(fy,i_);i_=i_.sibling}$y.type===j?(iy=Gw($y.props.children,fy.mode,hv,$y.key),iy.return=fy,fy=iy):(hv=U2($y.type,$y.key,$y.props,null,fy.mode,hv),hv.ref=gx(fy,iy,$y),hv.return=fy,fy=hv)}return z0(fy);case g:e:{for(i_=$y.key;iy!==null;){if(iy.key===i_)if(iy.tag===4&&iy.stateNode.containerInfo===$y.containerInfo&&iy.stateNode.implementation===$y.implementation){vr(fy,iy.sibling),iy=n0(iy,$y.children||[]),iy.return=fy,fy=iy;break e}else{vr(fy,iy);break}else Ut(fy,iy);iy=iy.sibling}iy=U1($y,fy.mode,hv),iy.return=fy,fy=iy}return z0(fy);case fr:return i_=$y._init,R1(fy,iy,i_($y._payload),hv)}if(Y0($y))return Tv(fy,iy,$y,hv);if(t0($y))return f1(fy,iy,$y,hv);X1(fy,$y)}return typeof $y=="string"&&$y!==""||typeof $y=="number"?($y=""+$y,iy!==null&&iy.tag===6?(vr(fy,iy.sibling),iy=n0(iy,$y),iy.return=fy,fy=iy):(vr(fy,iy),iy=d1($y,fy.mode,hv),iy.return=fy,fy=iy),z0(fy)):vr(fy,iy)}return R1}var yx=US(!0),zS=US(!1),ow={},L_=dv(ow),vx=dv(ow),bx=dv(ow);function sw(Pt){if(Pt===ow)throw Error(h(174));return Pt}function K2(Pt,Ut){Cy(bx,Ut),Cy(vx,Pt),Cy(L_,ow),Pt=ty(Ut),K0(L_),Cy(L_,Pt)}function wx(){K0(L_),K0(vx),K0(bx)}function GS(Pt){var Ut=sw(bx.current),vr=sw(L_.current);Ut=w0(vr,Pt.type,Ut),vr!==Ut&&(Cy(vx,Pt),Cy(L_,Ut))}function lw(Pt){vx.current===Pt&&(K0(L_),K0(vx))}var ey=dv(0);function Oy(Pt){for(var Ut=Pt;Ut!==null;){if(Ut.tag===13){var vr=Ut.memoizedState;if(vr!==null&&(vr=vr.dehydrated,vr===null||wy(vr)||Zv(vr)))return Ut}else if(Ut.tag===19&&Ut.memoizedProps.revealOrder!==void 0){if(Ut.flags&128)return Ut}else if(Ut.child!==null){Ut.child.return=Ut,Ut=Ut.child;continue}if(Ut===Pt)break;for(;Ut.sibling===null;){if(Ut.return===null||Ut.return===Pt)return null;Ut=Ut.return}Ut.sibling.return=Ut.return,Ut=Ut.sibling}return null}var Sy=[];function gv(){for(var Pt=0;Pt<Sy.length;Pt++){var Ut=Sy[Pt];iv?Ut._workInProgressVersionPrimary=null:Ut._workInProgressVersionSecondary=null}Sy.length=0}var Wv=_.ReactCurrentDispatcher,e_=_.ReactCurrentBatchConfig,D_=0,Uv=null,J_=null,Q_=null,v1=!1,Iw=!1,jx=0,xx=0;function q_(){throw Error(h(321))}function Sx(Pt,Ut){if(Ut===null)return!1;for(var vr=0;vr<Ut.length&&vr<Pt.length;vr++)if(!t1(Pt[vr],Ut[vr]))return!1;return!0}function __(Pt,Ut,vr,Kr,n0,s0){if(D_=s0,Uv=Ut,Ut.memoizedState=null,Ut.updateQueue=null,Ut.lanes=0,Wv.current=Pt===null||Pt.memoizedState===null?e2:nS,Pt=vr(Kr,n0),Iw){s0=0;do{if(Iw=!1,jx=0,25<=s0)throw Error(h(301));s0+=1,Q_=J_=null,Ut.updateQueue=null,Wv.current=Ax,Pt=vr(Kr,n0)}while(Iw)}if(Wv.current=Tx,Ut=J_!==null&&J_.next!==null,D_=0,Q_=J_=Uv=null,v1=!1,Ut)throw Error(h(300));return Pt}function X2(){var Pt=jx!==0;return jx=0,Pt}function uw(){var Pt={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Q_===null?Uv.memoizedState=Q_=Pt:Q_=Q_.next=Pt,Q_}function T1(){if(J_===null){var Pt=Uv.alternate;Pt=Pt!==null?Pt.memoizedState:null}else Pt=J_.next;var Ut=Q_===null?Uv.memoizedState:Q_.next;if(Ut!==null)Q_=Ut,J_=Pt;else{if(Pt===null)throw Error(h(310));J_=Pt,Pt={memoizedState:J_.memoizedState,baseState:J_.baseState,baseQueue:J_.baseQueue,queue:J_.queue,next:null},Q_===null?Uv.memoizedState=Q_=Pt:Q_=Q_.next=Pt}return Q_}function Zw(Pt,Ut){return typeof Ut=="function"?Ut(Pt):Ut}function w2(Pt){var Ut=T1(),vr=Ut.queue;if(vr===null)throw Error(h(311));vr.lastRenderedReducer=Pt;var Kr=J_,n0=Kr.baseQueue,s0=vr.pending;if(s0!==null){if(n0!==null){var z0=n0.next;n0.next=s0.next,s0.next=z0}Kr.baseQueue=n0=s0,vr.pending=null}if(n0!==null){s0=n0.next,Kr=Kr.baseState;var ny=z0=null,My=null,tv=s0;do{var xv=tv.lane;if((D_&xv)===xv)My!==null&&(My=My.next={lane:0,action:tv.action,hasEagerState:tv.hasEagerState,eagerState:tv.eagerState,next:null}),Kr=tv.hasEagerState?tv.eagerState:Pt(Kr,tv.action);else{var Yv={lane:xv,action:tv.action,hasEagerState:tv.hasEagerState,eagerState:tv.eagerState,next:null};My===null?(ny=My=Yv,z0=Kr):My=My.next=Yv,Uv.lanes|=xv,Px|=xv}tv=tv.next}while(tv!==null&&tv!==s0);My===null?z0=Kr:My.next=ny,t1(Kr,Ut.memoizedState)||(A1=!0),Ut.memoizedState=Kr,Ut.baseState=z0,Ut.baseQueue=My,vr.lastRenderedState=Kr}if(Pt=vr.interleaved,Pt!==null){n0=Pt;do s0=n0.lane,Uv.lanes|=s0,Px|=s0,n0=n0.next;while(n0!==Pt)}else n0===null&&(vr.lanes=0);return[Ut.memoizedState,vr.dispatch]}function x2(Pt){var Ut=T1(),vr=Ut.queue;if(vr===null)throw Error(h(311));vr.lastRenderedReducer=Pt;var Kr=vr.dispatch,n0=vr.pending,s0=Ut.memoizedState;if(n0!==null){vr.pending=null;var z0=n0=n0.next;do s0=Pt(s0,z0.action),z0=z0.next;while(z0!==n0);t1(s0,Ut.memoizedState)||(A1=!0),Ut.memoizedState=s0,Ut.baseQueue===null&&(Ut.baseState=s0),vr.lastRenderedState=s0}return[s0,Kr]}function qx(){}function ww(Pt,Ut){var vr=Uv,Kr=T1(),n0=Ut(),s0=!t1(Kr.memoizedState,n0);if(s0&&(Kr.memoizedState=n0,A1=!0),Kr=Kr.queue,Xx(Kx.bind(null,vr,Kr,Pt),[Pt]),Kr.getSnapshot!==Ut||s0||Q_!==null&&Q_.memoizedState.tag&1){if(vr.flags|=2048,Rw(9,Y2.bind(null,vr,Kr,n0,Ut),void 0,null),V_===null)throw Error(h(349));D_&30||Zx(vr,Ut,n0)}return n0}function Zx(Pt,Ut,vr){Pt.flags|=16384,Pt={getSnapshot:Ut,value:vr},Ut=Uv.updateQueue,Ut===null?(Ut={lastEffect:null,stores:null},Uv.updateQueue=Ut,Ut.stores=[Pt]):(vr=Ut.stores,vr===null?Ut.stores=[Pt]:vr.push(Pt))}function Y2(Pt,Ut,vr,Kr){Ut.value=vr,Ut.getSnapshot=Kr,J2(Ut)&&N1(Pt,1,-1)}function Kx(Pt,Ut,vr){return vr(function(){J2(Ut)&&N1(Pt,1,-1)})}function J2(Pt){var Ut=Pt.getSnapshot;Pt=Pt.value;try{var vr=Ut();return!t1(Pt,vr)}catch{return!0}}function S2(Pt){var Ut=uw();return typeof Pt=="function"&&(Pt=Pt()),Ut.memoizedState=Ut.baseState=Pt,Pt={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Zw,lastRenderedState:Pt},Ut.queue=Pt,Pt=Pt.dispatch=a1.bind(null,Uv,Pt),[Ut.memoizedState,Pt]}function Rw(Pt,Ut,vr,Kr){return Pt={tag:Pt,create:Ut,destroy:vr,deps:Kr,next:null},Ut=Uv.updateQueue,Ut===null?(Ut={lastEffect:null,stores:null},Uv.updateQueue=Ut,Ut.lastEffect=Pt.next=Pt):(vr=Ut.lastEffect,vr===null?Ut.lastEffect=Pt.next=Pt:(Kr=vr.next,vr.next=Pt,Pt.next=Kr,Ut.lastEffect=Pt)),Pt}function Q2(){return T1().memoizedState}function Ow(Pt,Ut,vr,Kr){var n0=uw();Uv.flags|=Pt,n0.memoizedState=Rw(1|Ut,vr,void 0,Kr===void 0?null:Kr)}function cw(Pt,Ut,vr,Kr){var n0=T1();Kr=Kr===void 0?null:Kr;var s0=void 0;if(J_!==null){var z0=J_.memoizedState;if(s0=z0.destroy,Kr!==null&&Sx(Kr,z0.deps)){n0.memoizedState=Rw(Ut,vr,s0,Kr);return}}Uv.flags|=Pt,n0.memoizedState=Rw(1|Ut,vr,s0,Kr)}function Ex(Pt,Ut){return Ow(8390656,8,Pt,Ut)}function Xx(Pt,Ut){return cw(2048,8,Pt,Ut)}function VS(Pt,Ut){return cw(4,2,Pt,Ut)}function HS(Pt,Ut){return cw(4,4,Pt,Ut)}function Yx(Pt,Ut){if(typeof Ut=="function")return Pt=Pt(),Ut(Pt),function(){Ut(null)};if(Ut!=null)return Pt=Pt(),Ut.current=Pt,function(){Ut.current=null}}function Jx(Pt,Ut,vr){return vr=vr!=null?vr.concat([Pt]):null,cw(4,4,Yx.bind(null,Ut,Pt),vr)}function Qx(){}function WS(Pt,Ut){var vr=T1();Ut=Ut===void 0?null:Ut;var Kr=vr.memoizedState;return Kr!==null&&Ut!==null&&Sx(Ut,Kr[1])?Kr[0]:(vr.memoizedState=[Pt,Ut],Pt)}function eS(Pt,Ut){var vr=T1();Ut=Ut===void 0?null:Ut;var Kr=vr.memoizedState;return Kr!==null&&Ut!==null&&Sx(Ut,Kr[1])?Kr[0]:(Pt=Pt(),vr.memoizedState=[Pt,Ut],Pt)}function kE(Pt,Ut){var vr=G0;G0=vr!==0&&4>vr?vr:4,Pt(!0);var Kr=e_.transition;e_.transition={};try{Pt(!1),Ut()}finally{G0=vr,e_.transition=Kr}}function jS(){return T1().memoizedState}function Z_(Pt,Ut,vr){var Kr=pw(Pt);vr={lane:Kr,action:vr,hasEagerState:!1,eagerState:null,next:null},qS(Pt)?ZS(Ut,vr):(tS(Pt,Ut,vr),vr=l1(),Pt=N1(Pt,Kr,vr),Pt!==null&&KS(Pt,Ut,Kr))}function a1(Pt,Ut,vr){var Kr=pw(Pt),n0={lane:Kr,action:vr,hasEagerState:!1,eagerState:null,next:null};if(qS(Pt))ZS(Ut,n0);else{tS(Pt,Ut,n0);var s0=Pt.alternate;if(Pt.lanes===0&&(s0===null||s0.lanes===0)&&(s0=Ut.lastRenderedReducer,s0!==null))try{var z0=Ut.lastRenderedState,ny=s0(z0,vr);if(n0.hasEagerState=!0,n0.eagerState=ny,t1(ny,z0))return}catch{}finally{}vr=l1(),Pt=N1(Pt,Kr,vr),Pt!==null&&KS(Pt,Ut,Kr)}}function qS(Pt){var Ut=Pt.alternate;return Pt===Uv||Ut!==null&&Ut===Uv}function ZS(Pt,Ut){Iw=v1=!0;var vr=Pt.pending;vr===null?Ut.next=Ut:(Ut.next=vr.next,vr.next=Ut),Pt.pending=Ut}function tS(Pt,Ut,vr){V_!==null&&Pt.mode&1&&!(r_&2)?(Pt=Ut.interleaved,Pt===null?(vr.next=vr,p_===null?p_=[Ut]:p_.push(Ut)):(vr.next=Pt.next,Pt.next=vr),Ut.interleaved=vr):(Pt=Ut.pending,Pt===null?vr.next=vr:(vr.next=Pt.next,Pt.next=vr),Ut.pending=vr)}function KS(Pt,Ut,vr){if(vr&4194240){var Kr=Ut.lanes;Kr&=Pt.pendingLanes,vr|=Kr,Ut.lanes=vr,M0(Pt,vr)}}var Tx={readContext:Lv,useCallback:q_,useContext:q_,useEffect:q_,useImperativeHandle:q_,useInsertionEffect:q_,useLayoutEffect:q_,useMemo:q_,useReducer:q_,useRef:q_,useState:q_,useDebugValue:q_,useDeferredValue:q_,useTransition:q_,useMutableSource:q_,useSyncExternalStore:q_,useId:q_,unstable_isNewReconciler:!1},e2={readContext:Lv,useCallback:function(Pt,Ut){return uw().memoizedState=[Pt,Ut===void 0?null:Ut],Pt},useContext:Lv,useEffect:Ex,useImperativeHandle:function(Pt,Ut,vr){return vr=vr!=null?vr.concat([Pt]):null,Ow(4194308,4,Yx.bind(null,Ut,Pt),vr)},useLayoutEffect:function(Pt,Ut){return Ow(4194308,4,Pt,Ut)},useInsertionEffect:function(Pt,Ut){return Ow(4,2,Pt,Ut)},useMemo:function(Pt,Ut){var vr=uw();return Ut=Ut===void 0?null:Ut,Pt=Pt(),vr.memoizedState=[Pt,Ut],Pt},useReducer:function(Pt,Ut,vr){var Kr=uw();return Ut=vr!==void 0?vr(Ut):Ut,Kr.memoizedState=Kr.baseState=Ut,Pt={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Pt,lastRenderedState:Ut},Kr.queue=Pt,Pt=Pt.dispatch=Z_.bind(null,Uv,Pt),[Kr.memoizedState,Pt]},useRef:function(Pt){var Ut=uw();return Pt={current:Pt},Ut.memoizedState=Pt},useState:S2,useDebugValue:Qx,useDeferredValue:function(Pt){var Ut=S2(Pt),vr=Ut[0],Kr=Ut[1];return Ex(function(){var n0=e_.transition;e_.transition={};try{Kr(Pt)}finally{e_.transition=n0}},[Pt]),vr},useTransition:function(){var Pt=S2(!1),Ut=Pt[0];return Pt=kE.bind(null,Pt[1]),uw().memoizedState=Pt,[Ut,Pt]},useMutableSource:function(){},useSyncExternalStore:function(Pt,Ut,vr){var Kr=Uv,n0=uw();if(I_){if(vr===void 0)throw Error(h(407));vr=vr()}else{if(vr=Ut(),V_===null)throw Error(h(349));D_&30||Zx(Kr,Ut,vr)}n0.memoizedState=vr;var s0={value:vr,getSnapshot:Ut};return n0.queue=s0,Ex(Kx.bind(null,Kr,s0,Pt),[Pt]),Kr.flags|=2048,Rw(9,Y2.bind(null,Kr,s0,vr,Ut),void 0,null),vr},useId:function(){var Pt=uw(),Ut=V_.identifierPrefix;if(I_){var vr=Z1,Kr=_w;vr=(Kr&~(1<<32-s_(Kr)-1)).toString(32)+vr,Ut=":"+Ut+"R"+vr,vr=jx++,0<vr&&(Ut+="H"+vr.toString(32)),Ut+=":"}else vr=xx++,Ut=":"+Ut+"r"+vr.toString(32)+":";return Pt.memoizedState=Ut},unstable_isNewReconciler:!1},nS={readContext:Lv,useCallback:WS,useContext:Lv,useEffect:Xx,useImperativeHandle:Jx,useInsertionEffect:VS,useLayoutEffect:HS,useMemo:eS,useReducer:w2,useRef:Q2,useState:function(){return w2(Zw)},useDebugValue:Qx,useDeferredValue:function(Pt){var Ut=w2(Zw),vr=Ut[0],Kr=Ut[1];return Xx(function(){var n0=e_.transition;e_.transition={};try{Kr(Pt)}finally{e_.transition=n0}},[Pt]),vr},useTransition:function(){var Pt=w2(Zw)[0],Ut=T1().memoizedState;return[Pt,Ut]},useMutableSource:qx,useSyncExternalStore:ww,useId:jS,unstable_isNewReconciler:!1},Ax={readContext:Lv,useCallback:WS,useContext:Lv,useEffect:Xx,useImperativeHandle:Jx,useInsertionEffect:VS,useLayoutEffect:HS,useMemo:eS,useReducer:x2,useRef:Q2,useState:function(){return x2(Zw)},useDebugValue:Qx,useDeferredValue:function(Pt){var Ut=x2(Zw),vr=Ut[0],Kr=Ut[1];return Xx(function(){var n0=e_.transition;e_.transition={};try{Kr(Pt)}finally{e_.transition=n0}},[Pt]),vr},useTransition:function(){var Pt=x2(Zw)[0],Ut=T1().memoizedState;return[Pt,Ut]},useMutableSource:qx,useSyncExternalStore:ww,useId:jS,unstable_isNewReconciler:!1};function Kw(Pt,Ut){try{var vr="",Kr=Ut;do vr+=om(Kr),Kr=Kr.return;while(Kr);var n0=vr}catch(s0){n0=`
Error generating stack: `+s0.message+`
`+s0.stack}return{value:Pt,source:Ut,stack:n0}}function Xw(Pt,Ut){try{console.error(Ut.value)}catch(vr){setTimeout(function(){throw vr})}}var E2=typeof WeakMap=="function"?WeakMap:Map;function Yw(Pt,Ut,vr){vr=P_(-1,vr),vr.tag=3,vr.payload={element:null};var Kr=Ut.value;return vr.callback=function(){l2||(l2=!0,O2=Kr),Xw(Pt,Ut)},vr}function XS(Pt,Ut,vr){vr=P_(-1,vr),vr.tag=3;var Kr=Pt.type.getDerivedStateFromError;if(typeof Kr=="function"){var n0=Ut.value;vr.payload=function(){return Kr(n0)},vr.callback=function(){Xw(Pt,Ut)}}var s0=Pt.stateNode;return s0!==null&&typeof s0.componentDidCatch=="function"&&(vr.callback=function(){Xw(Pt,Ut),typeof Kr!="function"&&(tw===null?tw=new Set([this]):tw.add(this));var z0=Ut.stack;this.componentDidCatch(Ut.value,{componentStack:z0!==null?z0:""})}),vr}function YS(Pt,Ut,vr){var Kr=Pt.pingCache;if(Kr===null){Kr=Pt.pingCache=new E2;var n0=new Set;Kr.set(Ut,n0)}else n0=Kr.get(Ut),n0===void 0&&(n0=new Set,Kr.set(Ut,n0));n0.has(vr)||(n0.add(vr),Pt=Uw.bind(null,Pt,Ut,vr),Ut.then(Pt,Pt))}function JS(Pt){do{var Ut;if((Ut=Pt.tag===13)&&(Ut=Pt.memoizedState,Ut=Ut!==null?Ut.dehydrated!==null:!0),Ut)return Pt;Pt=Pt.return}while(Pt!==null);return null}function QS(Pt,Ut,vr,Kr,n0){return Pt.mode&1?(Pt.flags|=65536,Pt.lanes=n0,Pt):(Pt===Ut?Pt.flags|=65536:(Pt.flags|=128,vr.flags|=131072,vr.flags&=-52805,vr.tag===1&&(vr.alternate===null?vr.tag=17:(Ut=P_(-1,1),Ut.tag=2,_1(vr,Ut))),vr.lanes|=1),Pt)}function dw(Pt){Pt.flags|=4}function t2(Pt,Ut){if(Pt!==null&&Pt.child===Ut.child)return!0;if(Ut.flags&16)return!1;for(Pt=Ut.child;Pt!==null;){if(Pt.flags&12854||Pt.subtreeFlags&12854)return!1;Pt=Pt.sibling}return!0}var xw,$x,S0,Sw;if(zy)xw=function(Pt,Ut){for(var vr=Ut.child;vr!==null;){if(vr.tag===5||vr.tag===6)q0(Pt,vr.stateNode);else if(vr.tag!==4&&vr.child!==null){vr.child.return=vr,vr=vr.child;continue}if(vr===Ut)break;for(;vr.sibling===null;){if(vr.return===null||vr.return===Ut)return;vr=vr.return}vr.sibling.return=vr.return,vr=vr.sibling}},$x=function(){},S0=function(Pt,Ut,vr,Kr,n0){if(Pt=Pt.memoizedProps,Pt!==Kr){var s0=Ut.stateNode,z0=sw(L_.current);vr=J0(s0,vr,Pt,Kr,n0,z0),(Ut.updateQueue=vr)&&dw(Ut)}},Sw=function(Pt,Ut,vr,Kr){vr!==Kr&&dw(Ut)};else if(B0){xw=function(Pt,Ut,vr,Kr){for(var n0=Ut.child;n0!==null;){if(n0.tag===5){var s0=n0.stateNode;vr&&Kr&&(s0=kv(s0,n0.type,n0.memoizedProps,n0)),q0(Pt,s0)}else if(n0.tag===6)s0=n0.stateNode,vr&&Kr&&(s0=Vv(s0,n0.memoizedProps,n0)),q0(Pt,s0);else if(n0.tag!==4){if(n0.tag===22&&n0.memoizedState!==null)s0=n0.child,s0!==null&&(s0.return=n0),xw(Pt,n0,!0,!0);else if(n0.child!==null){n0.child.return=n0,n0=n0.child;continue}}if(n0===Ut)break;for(;n0.sibling===null;){if(n0.return===null||n0.return===Ut)return;n0=n0.return}n0.sibling.return=n0.return,n0=n0.sibling}};var n2=function(Pt,Ut,vr,Kr){for(var n0=Ut.child;n0!==null;){if(n0.tag===5){var s0=n0.stateNode;vr&&Kr&&(s0=kv(s0,n0.type,n0.memoizedProps,n0)),xy(Pt,s0)}else if(n0.tag===6)s0=n0.stateNode,vr&&Kr&&(s0=Vv(s0,n0.memoizedProps,n0)),xy(Pt,s0);else if(n0.tag!==4){if(n0.tag===22&&n0.memoizedState!==null)s0=n0.child,s0!==null&&(s0.return=n0),n2(Pt,n0,!0,!0);else if(n0.child!==null){n0.child.return=n0,n0=n0.child;continue}}if(n0===Ut)break;for(;n0.sibling===null;){if(n0.return===null||n0.return===Ut)return;n0=n0.return}n0.sibling.return=n0.return,n0=n0.sibling}};$x=function(Pt,Ut){var vr=Ut.stateNode;if(!t2(Pt,Ut)){Pt=vr.containerInfo;var Kr=sy(Pt);n2(Kr,Ut,!1,!1),vr.pendingChildren=Kr,dw(Ut),ev(Pt,Kr)}},S0=function(Pt,Ut,vr,Kr,n0){var s0=Pt.stateNode,z0=Pt.memoizedProps;if((Pt=t2(Pt,Ut))&&z0===Kr)Ut.stateNode=s0;else{var ny=Ut.stateNode,My=sw(L_.current),tv=null;z0!==Kr&&(tv=J0(ny,vr,z0,Kr,n0,My)),Pt&&tv===null?Ut.stateNode=s0:(s0=F0(s0,tv,vr,z0,Kr,Ut,Pt,ny),vy(s0,vr,Kr,n0,My)&&dw(Ut),Ut.stateNode=s0,Pt?dw(Ut):xw(s0,Ut,!1,!1))}},Sw=function(Pt,Ut,vr,Kr){vr!==Kr?(Pt=sw(bx.current),vr=sw(L_.current),Ut.stateNode=Ty(Kr,Pt,vr,Ut),dw(Ut)):Ut.stateNode=Pt.stateNode}}else $x=function(){},S0=function(){},Sw=function(){};function o1(Pt,Ut){if(!I_)switch(Pt.tailMode){case"hidden":Ut=Pt.tail;for(var vr=null;Ut!==null;)Ut.alternate!==null&&(vr=Ut),Ut=Ut.sibling;vr===null?Pt.tail=null:vr.sibling=null;break;case"collapsed":vr=Pt.tail;for(var Kr=null;vr!==null;)vr.alternate!==null&&(Kr=vr),vr=vr.sibling;Kr===null?Ut||Pt.tail===null?Pt.tail=null:Pt.tail.sibling=null:Kr.sibling=null}}function Bv(Pt){var Ut=Pt.alternate!==null&&Pt.alternate.child===Pt.child,vr=0,Kr=0;if(Ut)for(var n0=Pt.child;n0!==null;)vr|=n0.lanes|n0.childLanes,Kr|=n0.subtreeFlags&14680064,Kr|=n0.flags&14680064,n0.return=Pt,n0=n0.sibling;else for(n0=Pt.child;n0!==null;)vr|=n0.lanes|n0.childLanes,Kr|=n0.subtreeFlags,Kr|=n0.flags,n0.return=Pt,n0=n0.sibling;return Pt.subtreeFlags|=Kr,Pt.childLanes=vr,Ut}function NE(Pt,Ut,vr){var Kr=Ut.pendingProps;switch(g1(Ut),Ut.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Bv(Ut),null;case 1:return x_(Ut.type)&&o_(),Bv(Ut),null;case 3:return Kr=Ut.stateNode,wx(),K0(Mv),K0(vv),gv(),Kr.pendingContext&&(Kr.context=Kr.pendingContext,Kr.pendingContext=null),(Pt===null||Pt.child===null)&&(Vx(Ut)?dw(Ut):Pt===null||Pt.memoizedState.isDehydrated&&!(Ut.flags&256)||(Ut.flags|=1024,K1!==null&&(nx(K1),K1=null))),$x(Pt,Ut),Bv(Ut),null;case 5:lw(Ut),vr=sw(bx.current);var n0=Ut.type;if(Pt!==null&&Ut.stateNode!=null)S0(Pt,Ut,n0,Kr,vr),Pt.ref!==Ut.ref&&(Ut.flags|=512,Ut.flags|=2097152);else{if(!Kr){if(Ut.stateNode===null)throw Error(h(166));return Bv(Ut),null}if(Pt=sw(L_.current),Vx(Ut)){if(!Ay)throw Error(h(175));Pt=m0(Ut.stateNode,Ut.type,Ut.memoizedProps,vr,Pt,Ut,!hx),Ut.updateQueue=Pt,Pt!==null&&dw(Ut)}else{var s0=T0(n0,Kr,vr,Pt,Ut);xw(s0,Ut,!1,!1),Ut.stateNode=s0,vy(s0,n0,Kr,vr,Pt)&&dw(Ut)}Ut.ref!==null&&(Ut.flags|=512,Ut.flags|=2097152)}return Bv(Ut),null;case 6:if(Pt&&Ut.stateNode!=null)Sw(Pt,Ut,Pt.memoizedProps,Kr);else{if(typeof Kr!="string"&&Ut.stateNode===null)throw Error(h(166));if(Pt=sw(bx.current),vr=sw(L_.current),Vx(Ut)){if(!Ay)throw Error(h(176));if(Pt=Ut.stateNode,Kr=Ut.memoizedProps,(vr=E0(Pt,Kr,Ut,!hx))&&(n0=y1,n0!==null))switch(s0=(n0.mode&1)!==0,n0.tag){case 3:_0(n0.stateNode.containerInfo,Pt,Kr,s0);break;case 5:D0(n0.type,n0.memoizedProps,n0.stateNode,Pt,Kr,s0)}vr&&dw(Ut)}else Ut.stateNode=Ty(Kr,Pt,vr,Ut)}return Bv(Ut),null;case 13:if(K0(ey),Kr=Ut.memoizedState,I_&&n1!==null&&Ut.mode&1&&!(Ut.flags&128)){for(Pt=n1;Pt;)Pt=v_(Pt);return mx(),Ut.flags|=98560,Ut}if(Kr!==null&&Kr.dehydrated!==null){if(Kr=Vx(Ut),Pt===null){if(!Kr)throw Error(h(318));if(!Ay)throw Error(h(344));if(Pt=Ut.memoizedState,Pt=Pt!==null?Pt.dehydrated:null,!Pt)throw Error(h(317));j0(Pt,Ut)}else mx(),!(Ut.flags&128)&&(Ut.memoizedState=null),Ut.flags|=4;return Bv(Ut),null}return K1!==null&&(nx(K1),K1=null),Ut.flags&128?(Ut.lanes=vr,Ut):(Kr=Kr!==null,vr=!1,Pt===null?Vx(Ut):vr=Pt.memoizedState!==null,Kr&&!vr&&(Ut.child.flags|=8192,Ut.mode&1&&(Pt===null||ey.current&1?F_===0&&(F_=3):k2())),Ut.updateQueue!==null&&(Ut.flags|=4),Bv(Ut),null);case 4:return wx(),$x(Pt,Ut),Pt===null&&Ly(Ut.stateNode.containerInfo),Bv(Ut),null;case 10:return Hv(Ut.type._context),Bv(Ut),null;case 17:return x_(Ut.type)&&o_(),Bv(Ut),null;case 19:if(K0(ey),n0=Ut.memoizedState,n0===null)return Bv(Ut),null;if(Kr=(Ut.flags&128)!==0,s0=n0.rendering,s0===null)if(Kr)o1(n0,!1);else{if(F_!==0||Pt!==null&&Pt.flags&128)for(Pt=Ut.child;Pt!==null;){if(s0=Oy(Pt),s0!==null){for(Ut.flags|=128,o1(n0,!1),Pt=s0.updateQueue,Pt!==null&&(Ut.updateQueue=Pt,Ut.flags|=4),Ut.subtreeFlags=0,Pt=vr,Kr=Ut.child;Kr!==null;)vr=Kr,n0=Pt,vr.flags&=14680066,s0=vr.alternate,s0===null?(vr.childLanes=0,vr.lanes=n0,vr.child=null,vr.subtreeFlags=0,vr.memoizedProps=null,vr.memoizedState=null,vr.updateQueue=null,vr.dependencies=null,vr.stateNode=null):(vr.childLanes=s0.childLanes,vr.lanes=s0.lanes,vr.child=s0.child,vr.subtreeFlags=0,vr.deletions=null,vr.memoizedProps=s0.memoizedProps,vr.memoizedState=s0.memoizedState,vr.updateQueue=s0.updateQueue,vr.type=s0.type,n0=s0.dependencies,vr.dependencies=n0===null?null:{lanes:n0.lanes,firstContext:n0.firstContext}),Kr=Kr.sibling;return Cy(ey,ey.current&1|2),Ut.child}Pt=Pt.sibling}n0.tail!==null&&y_()>s2&&(Ut.flags|=128,Kr=!0,o1(n0,!1),Ut.lanes=4194304)}else{if(!Kr)if(Pt=Oy(s0),Pt!==null){if(Ut.flags|=128,Kr=!0,Pt=Pt.updateQueue,Pt!==null&&(Ut.updateQueue=Pt,Ut.flags|=4),o1(n0,!0),n0.tail===null&&n0.tailMode==="hidden"&&!s0.alternate&&!I_)return Bv(Ut),null}else 2*y_()-n0.renderingStartTime>s2&&vr!==1073741824&&(Ut.flags|=128,Kr=!0,o1(n0,!1),Ut.lanes=4194304);n0.isBackwards?(s0.sibling=Ut.child,Ut.child=s0):(Pt=n0.last,Pt!==null?Pt.sibling=s0:Ut.child=s0,n0.last=s0)}return n0.tail!==null?(Ut=n0.tail,n0.rendering=Ut,n0.tail=Ut.sibling,n0.renderingStartTime=y_(),Ut.sibling=null,Pt=ey.current,Cy(ey,Kr?Pt&1|2:Pt&1),Ut):(Bv(Ut),null);case 22:case 23:return vS(),Kr=Ut.memoizedState!==null,Pt!==null&&Pt.memoizedState!==null!==Kr&&(Ut.flags|=8192),Kr&&Ut.mode&1?M1&1073741824&&(Bv(Ut),zy&&Ut.subtreeFlags&6&&(Ut.flags|=8192)):Bv(Ut),null;case 24:return null;case 25:return null}throw Error(h(156,Ut.tag))}var FE=_.ReactCurrentOwner,A1=!1;function k_(Pt,Ut,vr,Kr){Ut.child=Pt===null?zS(Ut,null,vr,Kr):yx(Ut,Pt.child,vr,Kr)}function eE(Pt,Ut,vr,Kr,n0){vr=vr.render;var s0=Ut.ref;return jv(Ut,n0),Kr=__(Pt,Ut,vr,Kr,s0,n0),vr=X2(),Pt!==null&&!A1?(Ut.updateQueue=Pt.updateQueue,Ut.flags&=-2053,Pt.lanes&=~n0,K_(Pt,Ut,n0)):(I_&&vr&&b2(Ut),Ut.flags|=1,k_(Pt,Ut,Kr,n0),Ut.child)}function tE(Pt,Ut,vr,Kr,n0){if(Pt===null){var s0=vr.type;return typeof s0=="function"&&!ES(s0)&&s0.defaultProps===void 0&&vr.compare===null&&vr.defaultProps===void 0?(Ut.tag=15,Ut.type=s0,nE(Pt,Ut,s0,Kr,n0)):(Pt=U2(vr.type,null,Kr,Ut,Ut.mode,n0),Pt.ref=Ut.ref,Pt.return=Ut,Ut.child=Pt)}if(s0=Pt.child,!(Pt.lanes&n0)){var z0=s0.memoizedProps;if(vr=vr.compare,vr=vr!==null?vr:O_,vr(z0,Kr)&&Pt.ref===Ut.ref)return K_(Pt,Ut,n0)}return Ut.flags|=1,Pt=Tw(s0,Kr),Pt.ref=Ut.ref,Pt.return=Ut,Ut.child=Pt}function nE(Pt,Ut,vr,Kr,n0){if(Pt!==null&&O_(Pt.memoizedProps,Kr)&&Pt.ref===Ut.ref)if(A1=!1,(Pt.lanes&n0)!==0)Pt.flags&131072&&(A1=!0);else return Ut.lanes=Pt.lanes,K_(Pt,Ut,n0);return Y1(Pt,Ut,vr,Kr,n0)}function rE(Pt,Ut,vr){var Kr=Ut.pendingProps,n0=Kr.children,s0=Pt!==null?Pt.memoizedState:null;if(Kr.mode==="hidden")if(!(Ut.mode&1))Ut.memoizedState={baseLanes:0,cachePool:null},Cy(Rx,M1),M1|=vr;else if(vr&1073741824)Ut.memoizedState={baseLanes:0,cachePool:null},Kr=s0!==null?s0.baseLanes:vr,Cy(Rx,M1),M1|=Kr;else return Pt=s0!==null?s0.baseLanes|vr:vr,Ut.lanes=Ut.childLanes=1073741824,Ut.memoizedState={baseLanes:Pt,cachePool:null},Ut.updateQueue=null,Cy(Rx,M1),M1|=Pt,null;else s0!==null?(Kr=s0.baseLanes|vr,Ut.memoizedState=null):Kr=vr,Cy(Rx,M1),M1|=Kr;return k_(Pt,Ut,n0,vr),Ut.child}function iE(Pt,Ut){var vr=Ut.ref;(Pt===null&&vr!==null||Pt!==null&&Pt.ref!==vr)&&(Ut.flags|=512,Ut.flags|=2097152)}function Y1(Pt,Ut,vr,Kr,n0){var s0=x_(vr)?f_:vv.current;return s0=b_(Ut,s0),jv(Ut,n0),vr=__(Pt,Ut,vr,Kr,s0,n0),Kr=X2(),Pt!==null&&!A1?(Ut.updateQueue=Pt.updateQueue,Ut.flags&=-2053,Pt.lanes&=~n0,K_(Pt,Ut,n0)):(I_&&Kr&&b2(Ut),Ut.flags|=1,k_(Pt,Ut,vr,n0),Ut.child)}function aE(Pt,Ut,vr,Kr,n0){if(x_(vr)){var s0=!0;Ov(Ut)}else s0=!1;if(jv(Ut,n0),Ut.stateNode===null)Pt!==null&&(Pt.alternate=null,Ut.alternate=null,Ut.flags|=2),LS(Ut,vr,Kr),dx(Ut,vr,Kr,n0),Kr=!0;else if(Pt===null){var z0=Ut.stateNode,ny=Ut.memoizedProps;z0.props=ny;var My=z0.context,tv=vr.contextType;typeof tv=="object"&&tv!==null?tv=Lv(tv):(tv=x_(vr)?f_:vv.current,tv=b_(Ut,tv));var xv=vr.getDerivedStateFromProps,Yv=typeof xv=="function"||typeof z0.getSnapshotBeforeUpdate=="function";Yv||typeof z0.UNSAFE_componentWillReceiveProps!="function"&&typeof z0.componentWillReceiveProps!="function"||(ny!==Kr||My!==tv)&&j2(Ut,z0,Kr,tv),dy=!1;var Iv=Ut.memoizedState;z0.state=Iv,j1(Ut,Kr,z0,n0),My=Ut.memoizedState,ny!==Kr||Iv!==My||Mv.current||dy?(typeof xv=="function"&&(Ux(Ut,vr,xv,Kr),My=Ut.memoizedState),(ny=dy||BS(Ut,vr,ny,Kr,Iv,My,tv))?(Yv||typeof z0.UNSAFE_componentWillMount!="function"&&typeof z0.componentWillMount!="function"||(typeof z0.componentWillMount=="function"&&z0.componentWillMount(),typeof z0.UNSAFE_componentWillMount=="function"&&z0.UNSAFE_componentWillMount()),typeof z0.componentDidMount=="function"&&(Ut.flags|=4194308)):(typeof z0.componentDidMount=="function"&&(Ut.flags|=4194308),Ut.memoizedProps=Kr,Ut.memoizedState=My),z0.props=Kr,z0.state=My,z0.context=tv,Kr=ny):(typeof z0.componentDidMount=="function"&&(Ut.flags|=4194308),Kr=!1)}else{z0=Ut.stateNode,d_(Pt,Ut),ny=Ut.memoizedProps,tv=Ut.type===Ut.elementType?ny:c0(Ut.type,ny),z0.props=tv,Yv=Ut.pendingProps,Iv=z0.context,My=vr.contextType,typeof My=="object"&&My!==null?My=Lv(My):(My=x_(vr)?f_:vv.current,My=b_(Ut,My));var E_=vr.getDerivedStateFromProps;(xv=typeof E_=="function"||typeof z0.getSnapshotBeforeUpdate=="function")||typeof z0.UNSAFE_componentWillReceiveProps!="function"&&typeof z0.componentWillReceiveProps!="function"||(ny!==Yv||Iv!==My)&&j2(Ut,z0,Kr,My),dy=!1,Iv=Ut.memoizedState,z0.state=Iv,j1(Ut,Kr,z0,n0);var Tv=Ut.memoizedState;ny!==Yv||Iv!==Tv||Mv.current||dy?(typeof E_=="function"&&(Ux(Ut,vr,E_,Kr),Tv=Ut.memoizedState),(tv=dy||BS(Ut,vr,tv,Kr,Iv,Tv,My)||!1)?(xv||typeof z0.UNSAFE_componentWillUpdate!="function"&&typeof z0.componentWillUpdate!="function"||(typeof z0.componentWillUpdate=="function"&&z0.componentWillUpdate(Kr,Tv,My),typeof z0.UNSAFE_componentWillUpdate=="function"&&z0.UNSAFE_componentWillUpdate(Kr,Tv,My)),typeof z0.componentDidUpdate=="function"&&(Ut.flags|=4),typeof z0.getSnapshotBeforeUpdate=="function"&&(Ut.flags|=1024)):(typeof z0.componentDidUpdate!="function"||ny===Pt.memoizedProps&&Iv===Pt.memoizedState||(Ut.flags|=4),typeof z0.getSnapshotBeforeUpdate!="function"||ny===Pt.memoizedProps&&Iv===Pt.memoizedState||(Ut.flags|=1024),Ut.memoizedProps=Kr,Ut.memoizedState=Tv),z0.props=Kr,z0.state=Tv,z0.context=My,Kr=tv):(typeof z0.componentDidUpdate!="function"||ny===Pt.memoizedProps&&Iv===Pt.memoizedState||(Ut.flags|=4),typeof z0.getSnapshotBeforeUpdate!="function"||ny===Pt.memoizedProps&&Iv===Pt.memoizedState||(Ut.flags|=1024),Kr=!1)}return rS(Pt,Ut,vr,Kr,s0,n0)}function rS(Pt,Ut,vr,Kr,n0,s0){iE(Pt,Ut);var z0=(Ut.flags&128)!==0;if(!Kr&&!z0)return n0&&Qv(Ut,vr,!1),K_(Pt,Ut,s0);Kr=Ut.stateNode,FE.current=Ut;var ny=z0&&typeof vr.getDerivedStateFromError!="function"?null:Kr.render();return Ut.flags|=1,Pt!==null&&z0?(Ut.child=yx(Ut,Pt.child,null,s0),Ut.child=yx(Ut,null,ny,s0)):k_(Pt,Ut,ny,s0),Ut.memoizedState=Kr.state,n0&&Qv(Ut,vr,!0),Ut.child}function oE(Pt){var Ut=Pt.stateNode;Ut.pendingContext?Yy(Pt,Ut.pendingContext,Ut.pendingContext!==Ut.context):Ut.context&&Yy(Pt,Ut.context,!1),K2(Pt,Ut.containerInfo)}function sE(Pt,Ut,vr,Kr,n0){return mx(),Hx(n0),Ut.flags|=256,k_(Pt,Ut,vr,Kr),Ut.child}var T2={dehydrated:null,treeContext:null,retryLane:0};function k1(Pt){return{baseLanes:Pt,cachePool:null}}function lE(Pt,Ut,vr){var Kr=Ut.pendingProps,n0=ey.current,s0=!1,z0=(Ut.flags&128)!==0,ny;if((ny=z0)||(ny=Pt!==null&&Pt.memoizedState===null?!1:(n0&2)!==0),ny?(s0=!0,Ut.flags&=-129):(Pt===null||Pt.memoizedState!==null)&&(n0|=1),Cy(ey,n0&1),Pt===null)return Z2(Ut),Pt=Ut.memoizedState,Pt!==null&&(Pt=Pt.dehydrated,Pt!==null)?(Ut.mode&1?Zv(Pt)?Ut.lanes=8:Ut.lanes=1073741824:Ut.lanes=1,null):(n0=Kr.children,Pt=Kr.fallback,s0?(Kr=Ut.mode,s0=Ut.child,n0={mode:"hidden",children:n0},!(Kr&1)&&s0!==null?(s0.childLanes=0,s0.pendingProps=n0):s0=f2(n0,Kr,0,null),Pt=Gw(Pt,Kr,vr,null),s0.return=Ut,Pt.return=Ut,s0.sibling=Pt,Ut.child=s0,Ut.child.memoizedState=k1(vr),Ut.memoizedState=T2,Pt):iS(Ut,n0));if(n0=Pt.memoizedState,n0!==null){if(ny=n0.dehydrated,ny!==null){if(z0)return Ut.flags&256?(Ut.flags&=-257,A2(Pt,Ut,vr,Error(h(422)))):Ut.memoizedState!==null?(Ut.child=Pt.child,Ut.flags|=128,null):(s0=Kr.fallback,n0=Ut.mode,Kr=f2({mode:"visible",children:Kr.children},n0,0,null),s0=Gw(s0,n0,vr,null),s0.flags|=2,Kr.return=Ut,s0.return=Ut,Kr.sibling=s0,Ut.child=Kr,Ut.mode&1&&yx(Ut,Pt.child,null,vr),Ut.child.memoizedState=k1(vr),Ut.memoizedState=T2,s0);if(!(Ut.mode&1))Ut=A2(Pt,Ut,vr,null);else if(Zv(ny))Ut=A2(Pt,Ut,vr,Error(h(419)));else if(Kr=(vr&Pt.childLanes)!==0,A1||Kr){if(Kr=V_,Kr!==null){switch(vr&-vr){case 4:s0=2;break;case 16:s0=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:s0=32;break;case 536870912:s0=268435456;break;default:s0=0}Kr=s0&(Kr.suspendedLanes|vr)?0:s0,Kr!==0&&Kr!==n0.retryLane&&(n0.retryLane=Kr,N1(Pt,Kr,-1))}k2(),Ut=A2(Pt,Ut,vr,Error(h(421)))}else wy(ny)?(Ut.flags|=128,Ut.child=Pt.child,Ut=zw.bind(null,Pt),Xv(ny,Ut),Ut=null):(vr=n0.treeContext,Ay&&(n1=h1(ny),y1=Ut,I_=!0,K1=null,hx=!1,vr!==null&&(b1[w1++]=_w,b1[w1++]=Z1,b1[w1++]=Mw,_w=vr.id,Z1=vr.overflow,Mw=Ut)),Ut=iS(Ut,Ut.pendingProps.children),Ut.flags|=4096);return Ut}return s0?(Kr=cE(Pt,Ut,Kr.children,Kr.fallback,vr),s0=Ut.child,n0=Pt.child.memoizedState,s0.memoizedState=n0===null?k1(vr):{baseLanes:n0.baseLanes|vr,cachePool:null},s0.childLanes=Pt.childLanes&~vr,Ut.memoizedState=T2,Kr):(vr=uE(Pt,Ut,Kr.children,vr),Ut.memoizedState=null,vr)}return s0?(Kr=cE(Pt,Ut,Kr.children,Kr.fallback,vr),s0=Ut.child,n0=Pt.child.memoizedState,s0.memoizedState=n0===null?k1(vr):{baseLanes:n0.baseLanes|vr,cachePool:null},s0.childLanes=Pt.childLanes&~vr,Ut.memoizedState=T2,Kr):(vr=uE(Pt,Ut,Kr.children,vr),Ut.memoizedState=null,vr)}function iS(Pt,Ut){return Ut=f2({mode:"visible",children:Ut},Pt.mode,0,null),Ut.return=Pt,Pt.child=Ut}function uE(Pt,Ut,vr,Kr){var n0=Pt.child;return Pt=n0.sibling,vr=Tw(n0,{mode:"visible",children:vr}),!(Ut.mode&1)&&(vr.lanes=Kr),vr.return=Ut,vr.sibling=null,Pt!==null&&(Kr=Ut.deletions,Kr===null?(Ut.deletions=[Pt],Ut.flags|=16):Kr.push(Pt)),Ut.child=vr}function cE(Pt,Ut,vr,Kr,n0){var s0=Ut.mode;Pt=Pt.child;var z0=Pt.sibling,ny={mode:"hidden",children:vr};return!(s0&1)&&Ut.child!==Pt?(vr=Ut.child,vr.childLanes=0,vr.pendingProps=ny,Ut.deletions=null):(vr=Tw(Pt,ny),vr.subtreeFlags=Pt.subtreeFlags&14680064),z0!==null?Kr=Tw(z0,Kr):(Kr=Gw(Kr,s0,n0,null),Kr.flags|=2),Kr.return=Ut,vr.return=Ut,vr.sibling=Kr,Ut.child=vr,Kr}function A2(Pt,Ut,vr,Kr){return Kr!==null&&Hx(Kr),yx(Ut,Pt.child,null,vr),Pt=iS(Ut,Ut.pendingProps.children),Pt.flags|=2,Ut.memoizedState=null,Pt}function Pw(Pt,Ut,vr){Pt.lanes|=Ut;var Kr=Pt.alternate;Kr!==null&&(Kr.lanes|=Ut),Nv(Pt.return,Ut,vr)}function aS(Pt,Ut,vr,Kr,n0){var s0=Pt.memoizedState;s0===null?Pt.memoizedState={isBackwards:Ut,rendering:null,renderingStartTime:0,last:Kr,tail:vr,tailMode:n0}:(s0.isBackwards=Ut,s0.rendering=null,s0.renderingStartTime=0,s0.last=Kr,s0.tail=vr,s0.tailMode=n0)}function dE(Pt,Ut,vr){var Kr=Ut.pendingProps,n0=Kr.revealOrder,s0=Kr.tail;if(k_(Pt,Ut,Kr.children,vr),Kr=ey.current,Kr&2)Kr=Kr&1|2,Ut.flags|=128;else{if(Pt!==null&&Pt.flags&128)e:for(Pt=Ut.child;Pt!==null;){if(Pt.tag===13)Pt.memoizedState!==null&&Pw(Pt,vr,Ut);else if(Pt.tag===19)Pw(Pt,vr,Ut);else if(Pt.child!==null){Pt.child.return=Pt,Pt=Pt.child;continue}if(Pt===Ut)break e;for(;Pt.sibling===null;){if(Pt.return===null||Pt.return===Ut)break e;Pt=Pt.return}Pt.sibling.return=Pt.return,Pt=Pt.sibling}Kr&=1}if(Cy(ey,Kr),!(Ut.mode&1))Ut.memoizedState=null;else switch(n0){case"forwards":for(vr=Ut.child,n0=null;vr!==null;)Pt=vr.alternate,Pt!==null&&Oy(Pt)===null&&(n0=vr),vr=vr.sibling;vr=n0,vr===null?(n0=Ut.child,Ut.child=null):(n0=vr.sibling,vr.sibling=null),aS(Ut,!1,n0,vr,s0);break;case"backwards":for(vr=null,n0=Ut.child,Ut.child=null;n0!==null;){if(Pt=n0.alternate,Pt!==null&&Oy(Pt)===null){Ut.child=n0;break}Pt=n0.sibling,n0.sibling=vr,vr=n0,n0=Pt}aS(Ut,!0,vr,null,s0);break;case"together":aS(Ut,!1,null,null,void 0);break;default:Ut.memoizedState=null}return Ut.child}function K_(Pt,Ut,vr){if(Pt!==null&&(Ut.dependencies=Pt.dependencies),Px|=Ut.lanes,!(vr&Ut.childLanes))return null;if(Pt!==null&&Ut.child!==Pt.child)throw Error(h(153));if(Ut.child!==null){for(Pt=Ut.child,vr=Tw(Pt,Pt.pendingProps),Ut.child=vr,vr.return=Ut;Pt.sibling!==null;)Pt=Pt.sibling,vr=vr.sibling=Tw(Pt,Pt.pendingProps),vr.return=Ut;vr.sibling=null}return Ut.child}function UE(Pt,Ut,vr){switch(Ut.tag){case 3:oE(Ut),mx();break;case 5:GS(Ut);break;case 1:x_(Ut.type)&&Ov(Ut);break;case 4:K2(Ut,Ut.stateNode.containerInfo);break;case 10:Ev(Ut,Ut.type._context,Ut.memoizedProps.value);break;case 13:var Kr=Ut.memoizedState;if(Kr!==null)return Kr.dehydrated!==null?(Cy(ey,ey.current&1),Ut.flags|=128,null):vr&Ut.child.childLanes?lE(Pt,Ut,vr):(Cy(ey,ey.current&1),Pt=K_(Pt,Ut,vr),Pt!==null?Pt.sibling:null);Cy(ey,ey.current&1);break;case 19:if(Kr=(vr&Ut.childLanes)!==0,Pt.flags&128){if(Kr)return dE(Pt,Ut,vr);Ut.flags|=128}var n0=Ut.memoizedState;if(n0!==null&&(n0.rendering=null,n0.tail=null,n0.lastEffect=null),Cy(ey,ey.current),Kr)break;return null;case 22:case 23:return Ut.lanes=0,rE(Pt,Ut,vr)}return K_(Pt,Ut,vr)}function zE(Pt,Ut){switch(g1(Ut),Ut.tag){case 1:return x_(Ut.type)&&o_(),Pt=Ut.flags,Pt&65536?(Ut.flags=Pt&-65537|128,Ut):null;case 3:return wx(),K0(Mv),K0(vv),gv(),Pt=Ut.flags,Pt&65536&&!(Pt&128)?(Ut.flags=Pt&-65537|128,Ut):null;case 5:return lw(Ut),null;case 13:if(K0(ey),Pt=Ut.memoizedState,Pt!==null&&Pt.dehydrated!==null){if(Ut.alternate===null)throw Error(h(340));mx()}return Pt=Ut.flags,Pt&65536?(Ut.flags=Pt&-65537|128,Ut):null;case 19:return K0(ey),null;case 4:return wx(),null;case 10:return Hv(Ut.type._context),null;case 22:case 23:return vS(),null;case 24:return null;default:return null}}var $2=!1,Jw=!1,GE=typeof WeakSet=="function"?WeakSet:Set,fv=null;function r2(Pt,Ut){var vr=Pt.ref;if(vr!==null)if(typeof vr=="function")try{vr(null)}catch(Kr){c1(Pt,Ut,Kr)}else vr.current=null}function oS(Pt,Ut,vr){try{vr()}catch(Kr){c1(Pt,Ut,Kr)}}var fE=!1;function sS(Pt,Ut){for(L0(Pt.containerInfo),fv=Ut;fv!==null;)if(Pt=fv,Ut=Pt.child,(Pt.subtreeFlags&1028)!==0&&Ut!==null)Ut.return=Pt,fv=Ut;else for(;fv!==null;){Pt=fv;try{var vr=Pt.alternate;if(Pt.flags&1024)switch(Pt.tag){case 0:case 11:case 15:break;case 1:if(vr!==null){var Kr=vr.memoizedProps,n0=vr.memoizedState,s0=Pt.stateNode,z0=s0.getSnapshotBeforeUpdate(Pt.elementType===Pt.type?Kr:c0(Pt.type,Kr),n0);s0.__reactInternalSnapshotBeforeUpdate=z0}break;case 3:zy&&N0(Pt.stateNode.containerInfo);break;case 5:case 6:case 4:case 17:break;default:throw Error(h(163))}}catch(ny){c1(Pt,Pt.return,ny)}if(Ut=Pt.sibling,Ut!==null){Ut.return=Pt.return,fv=Ut;break}fv=Pt.return}return vr=fE,fE=!1,vr}function J1(Pt,Ut,vr){var Kr=Ut.updateQueue;if(Kr=Kr!==null?Kr.lastEffect:null,Kr!==null){var n0=Kr=Kr.next;do{if((n0.tag&Pt)===Pt){var s0=n0.destroy;n0.destroy=void 0,s0!==void 0&&oS(Ut,vr,s0)}n0=n0.next}while(n0!==Kr)}}function Dw(Pt,Ut){if(Ut=Ut.updateQueue,Ut=Ut!==null?Ut.lastEffect:null,Ut!==null){var vr=Ut=Ut.next;do{if((vr.tag&Pt)===Pt){var Kr=vr.create;vr.destroy=Kr()}vr=vr.next}while(vr!==Ut)}}function lS(Pt){var Ut=Pt.ref;if(Ut!==null){var vr=Pt.stateNode;switch(Pt.tag){case 5:Pt=H0(vr);break;default:Pt=vr}typeof Ut=="function"?Ut(Pt):Ut.current=Pt}}function uS(Pt,Ut,vr){if(t_&&typeof t_.onCommitFiberUnmount=="function")try{t_.onCommitFiberUnmount(Ry,Ut)}catch{}switch(Ut.tag){case 0:case 11:case 14:case 15:if(Pt=Ut.updateQueue,Pt!==null&&(Pt=Pt.lastEffect,Pt!==null)){var Kr=Pt=Pt.next;do{var n0=Kr,s0=n0.destroy;n0=n0.tag,s0!==void 0&&(n0&2||n0&4)&&oS(Ut,vr,s0),Kr=Kr.next}while(Kr!==Pt)}break;case 1:if(r2(Ut,vr),Pt=Ut.stateNode,typeof Pt.componentWillUnmount=="function")try{Pt.props=Ut.memoizedProps,Pt.state=Ut.memoizedState,Pt.componentWillUnmount()}catch(z0){c1(Ut,vr,z0)}break;case 5:r2(Ut,vr);break;case 4:zy?dS(Pt,Ut,vr):B0&&B0&&(Ut=Ut.stateNode.containerInfo,vr=sy(Ut),Sv(Ut,vr))}}function pE(Pt,Ut,vr){for(var Kr=Ut;;)if(uS(Pt,Kr,vr),Kr.child===null||zy&&Kr.tag===4){if(Kr===Ut)break;for(;Kr.sibling===null;){if(Kr.return===null||Kr.return===Ut)return;Kr=Kr.return}Kr.sibling.return=Kr.return,Kr=Kr.sibling}else Kr.child.return=Kr,Kr=Kr.child}function fw(Pt){var Ut=Pt.alternate;Ut!==null&&(Pt.alternate=null,fw(Ut)),Pt.child=null,Pt.deletions=null,Pt.sibling=null,Pt.tag===5&&(Ut=Pt.stateNode,Ut!==null&&Jy(Ut)),Pt.stateNode=null,Pt.return=null,Pt.dependencies=null,Pt.memoizedProps=null,Pt.memoizedState=null,Pt.pendingProps=null,Pt.stateNode=null,Pt.updateQueue=null}function C2(Pt){return Pt.tag===5||Pt.tag===3||Pt.tag===4}function Bw(Pt){e:for(;;){for(;Pt.sibling===null;){if(Pt.return===null||C2(Pt.return))return null;Pt=Pt.return}for(Pt.sibling.return=Pt.return,Pt=Pt.sibling;Pt.tag!==5&&Pt.tag!==6&&Pt.tag!==18;){if(Pt.flags&2||Pt.child===null||Pt.tag===4)continue e;Pt.child.return=Pt,Pt=Pt.child}if(!(Pt.flags&2))return Pt.stateNode}}function $1(Pt){if(zy){e:{for(var Ut=Pt.return;Ut!==null;){if(C2(Ut))break e;Ut=Ut.return}throw Error(h(160))}var vr=Ut;switch(vr.tag){case 5:Ut=vr.stateNode,vr.flags&32&&(oy(Ut),vr.flags&=-33),vr=Bw(Pt),M2(Pt,vr,Ut);break;case 3:case 4:Ut=vr.stateNode.containerInfo,vr=Bw(Pt),cS(Pt,vr,Ut);break;default:throw Error(h(161))}}}function cS(Pt,Ut,vr){var Kr=Pt.tag;if(Kr===5||Kr===6)Pt=Pt.stateNode,Ut?mv(vr,Pt,Ut):Wy(vr,Pt);else if(Kr!==4&&(Pt=Pt.child,Pt!==null))for(cS(Pt,Ut,vr),Pt=Pt.sibling;Pt!==null;)cS(Pt,Ut,vr),Pt=Pt.sibling}function M2(Pt,Ut,vr){var Kr=Pt.tag;if(Kr===5||Kr===6)Pt=Pt.stateNode,Ut?wv(vr,Pt,Ut):av(vr,Pt);else if(Kr!==4&&(Pt=Pt.child,Pt!==null))for(M2(Pt,Ut,vr),Pt=Pt.sibling;Pt!==null;)M2(Pt,Ut,vr),Pt=Pt.sibling}function dS(Pt,Ut,vr){for(var Kr=Ut,n0=!1,s0,z0;;){if(!n0){n0=Kr.return;e:for(;;){if(n0===null)throw Error(h(160));switch(s0=n0.stateNode,n0.tag){case 5:z0=!1;break e;case 3:s0=s0.containerInfo,z0=!0;break e;case 4:s0=s0.containerInfo,z0=!0;break e}n0=n0.return}n0=!0}if(Kr.tag===5||Kr.tag===6)pE(Pt,Kr,vr),z0?O0(s0,Kr.stateNode):cv(s0,Kr.stateNode);else if(Kr.tag===18)z0?r0(s0,Kr.stateNode):Yr(s0,Kr.stateNode);else if(Kr.tag===4){if(Kr.child!==null){s0=Kr.stateNode.containerInfo,z0=!0,Kr.child.return=Kr,Kr=Kr.child;continue}}else if(uS(Pt,Kr,vr),Kr.child!==null){Kr.child.return=Kr,Kr=Kr.child;continue}if(Kr===Ut)break;for(;Kr.sibling===null;){if(Kr.return===null||Kr.return===Ut)return;Kr=Kr.return,Kr.tag===4&&(n0=!1)}Kr.sibling.return=Kr.return,Kr=Kr.sibling}}function Qw(Pt,Ut){if(zy){switch(Ut.tag){case 0:case 11:case 14:case 15:J1(3,Ut,Ut.return),Dw(3,Ut),J1(5,Ut,Ut.return);return;case 1:return;case 5:var vr=Ut.stateNode;if(vr!=null){var Kr=Ut.memoizedProps;Pt=Pt!==null?Pt.memoizedProps:Kr;var n0=Ut.type,s0=Ut.updateQueue;Ut.updateQueue=null,s0!==null&&Hy(vr,s0,n0,Pt,Kr,Ut)}return;case 6:if(Ut.stateNode===null)throw Error(h(162));vr=Ut.memoizedProps,my(Ut.stateNode,Pt!==null?Pt.memoizedProps:vr,vr);return;case 3:Ay&&Pt!==null&&Pt.memoizedState.isDehydrated&&$0(Ut.stateNode.containerInfo);return;case 12:return;case 13:Q1(Ut);return;case 19:Q1(Ut);return;case 17:return}throw Error(h(163))}switch(Ut.tag){case 0:case 11:case 14:case 15:J1(3,Ut,Ut.return),Dw(3,Ut),J1(5,Ut,Ut.return);return;case 12:return;case 13:Q1(Ut);return;case 19:Q1(Ut);return;case 3:Ay&&Pt!==null&&Pt.memoizedState.isDehydrated&&$0(Ut.stateNode.containerInfo);break;case 22:case 23:return}e:if(B0){switch(Ut.tag){case 1:case 5:case 6:break e;case 3:case 4:Ut=Ut.stateNode,Sv(Ut.containerInfo,Ut.pendingChildren);break e}throw Error(h(163))}}function Q1(Pt){var Ut=Pt.updateQueue;if(Ut!==null){Pt.updateQueue=null;var vr=Pt.stateNode;vr===null&&(vr=Pt.stateNode=new GE),Ut.forEach(function(Kr){var n0=wE.bind(null,Pt,Kr);vr.has(Kr)||(vr.add(Kr),Kr.then(n0,n0))})}}function hE(Pt,Ut){for(fv=Ut;fv!==null;){Ut=fv;var vr=Ut.deletions;if(vr!==null)for(var Kr=0;Kr<vr.length;Kr++){var n0=vr[Kr];try{var s0=Pt;zy?dS(s0,n0,Ut):pE(s0,n0,Ut);var z0=n0.alternate;z0!==null&&(z0.return=null),n0.return=null}catch(Av){c1(n0,Ut,Av)}}if(vr=Ut.child,Ut.subtreeFlags&12854&&vr!==null)vr.return=Ut,fv=vr;else for(;fv!==null;){Ut=fv;try{var ny=Ut.flags;if(ny&32&&zy&&oy(Ut.stateNode),ny&512){var My=Ut.alternate;if(My!==null){var tv=My.ref;tv!==null&&(typeof tv=="function"?tv(null):tv.current=null)}}if(ny&8192)switch(Ut.tag){case 13:if(Ut.memoizedState!==null){var xv=Ut.alternate;(xv===null||xv.memoizedState===null)&&(gS=y_())}break;case 22:var Yv=Ut.memoizedState!==null,Iv=Ut.alternate,E_=Iv!==null&&Iv.memoizedState!==null;if(vr=Ut,zy){e:if(Kr=vr,n0=Yv,s0=null,zy)for(var Tv=Kr;;){if(Tv.tag===5){if(s0===null){s0=Tv;var f1=Tv.stateNode;n0?Py(f1):d0(Tv.stateNode,Tv.memoizedProps)}}else if(Tv.tag===6){if(s0===null){var R1=Tv.stateNode;n0?nv(R1):v0(R1,Tv.memoizedProps)}}else if((Tv.tag!==22&&Tv.tag!==23||Tv.memoizedState===null||Tv===Kr)&&Tv.child!==null){Tv.child.return=Tv,Tv=Tv.child;continue}if(Tv===Kr)break;for(;Tv.sibling===null;){if(Tv.return===null||Tv.return===Kr)break e;s0===Tv&&(s0=null),Tv=Tv.return}s0===Tv&&(s0=null),Tv.sibling.return=Tv.return,Tv=Tv.sibling}}if(Yv&&!E_&&vr.mode&1){fv=vr;for(var fy=vr.child;fy!==null;){for(vr=fv=fy;fv!==null;){Kr=fv;var iy=Kr.child;switch(Kr.tag){case 0:case 11:case 14:case 15:J1(4,Kr,Kr.return);break;case 1:r2(Kr,Kr.return);var $y=Kr.stateNode;if(typeof $y.componentWillUnmount=="function"){var hv=Kr.return;try{$y.props=Kr.memoizedProps,$y.state=Kr.memoizedState,$y.componentWillUnmount()}catch(Av){c1(Kr,hv,Av)}}break;case 5:r2(Kr,Kr.return);break;case 22:if(Kr.memoizedState!==null){fS(vr);continue}}iy!==null?(iy.return=Kr,fv=iy):fS(vr)}fy=fy.sibling}}}switch(ny&4102){case 2:$1(Ut),Ut.flags&=-3;break;case 6:$1(Ut),Ut.flags&=-3,Qw(Ut.alternate,Ut);break;case 4096:Ut.flags&=-4097;break;case 4100:Ut.flags&=-4097,Qw(Ut.alternate,Ut);break;case 4:Qw(Ut.alternate,Ut)}}catch(Av){c1(Ut,Ut.return,Av)}if(vr=Ut.sibling,vr!==null){vr.return=Ut.return,fv=vr;break}fv=Ut.return}}}function VE(Pt,Ut,vr){fv=Pt,i2(Pt)}function i2(Pt,Ut,vr){for(var Kr=(Pt.mode&1)!==0;fv!==null;){var n0=fv,s0=n0.child;if(n0.tag===22&&Kr){var z0=n0.memoizedState!==null||$2;if(!z0){var ny=n0.alternate,My=ny!==null&&ny.memoizedState!==null||Jw;ny=$2;var tv=Jw;if($2=z0,(Jw=My)&&!tv)for(fv=n0;fv!==null;)z0=fv,My=z0.child,z0.tag===22&&z0.memoizedState!==null?e1(n0):My!==null?(My.return=z0,fv=My):e1(n0);for(;s0!==null;)fv=s0,i2(s0),s0=s0.sibling;fv=n0,$2=ny,Jw=tv}mE(Pt)}else n0.subtreeFlags&8772&&s0!==null?(s0.return=n0,fv=s0):mE(Pt)}}function mE(Pt){for(;fv!==null;){var Ut=fv;if(Ut.flags&8772){var vr=Ut.alternate;try{if(Ut.flags&8772)switch(Ut.tag){case 0:case 11:case 15:Jw||Dw(5,Ut);break;case 1:var Kr=Ut.stateNode;if(Ut.flags&4&&!Jw)if(vr===null)Kr.componentDidMount();else{var n0=Ut.elementType===Ut.type?vr.memoizedProps:c0(Ut.type,vr.memoizedProps);Kr.componentDidUpdate(n0,vr.memoizedState,Kr.__reactInternalSnapshotBeforeUpdate)}var s0=Ut.updateQueue;s0!==null&&v2(Ut,s0,Kr);break;case 3:var z0=Ut.updateQueue;if(z0!==null){if(vr=null,Ut.child!==null)switch(Ut.child.tag){case 5:vr=H0(Ut.child.stateNode);break;case 1:vr=Ut.child.stateNode}v2(Ut,z0,vr)}break;case 5:var ny=Ut.stateNode;vr===null&&Ut.flags&4&&uv(ny,Ut.type,Ut.memoizedProps,Ut);break;case 6:break;case 4:break;case 12:break;case 13:if(Ay&&Ut.memoizedState===null){var My=Ut.alternate;if(My!==null){var tv=My.memoizedState;if(tv!==null){var xv=tv.dehydrated;xv!==null&&P0(xv)}}}break;case 19:case 17:case 21:case 22:case 23:break;default:throw Error(h(163))}Jw||Ut.flags&512&&lS(Ut)}catch(Yv){c1(Ut,Ut.return,Yv)}}if(Ut===Pt){fv=null;break}if(vr=Ut.sibling,vr!==null){vr.return=Ut.return,fv=vr;break}fv=Ut.return}}function fS(Pt){for(;fv!==null;){var Ut=fv;if(Ut===Pt){fv=null;break}var vr=Ut.sibling;if(vr!==null){vr.return=Ut.return,fv=vr;break}fv=Ut.return}}function e1(Pt){for(;fv!==null;){var Ut=fv;try{switch(Ut.tag){case 0:case 11:case 15:var vr=Ut.return;try{Dw(4,Ut)}catch(My){c1(Ut,vr,My)}break;case 1:var Kr=Ut.stateNode;if(typeof Kr.componentDidMount=="function"){var n0=Ut.return;try{Kr.componentDidMount()}catch(My){c1(Ut,n0,My)}}var s0=Ut.return;try{lS(Ut)}catch(My){c1(Ut,s0,My)}break;case 5:var z0=Ut.return;try{lS(Ut)}catch(My){c1(Ut,z0,My)}}}catch(My){c1(Ut,Ut.return,My)}if(Ut===Pt){fv=null;break}var ny=Ut.sibling;if(ny!==null){ny.return=Ut.return,fv=ny;break}fv=Ut.return}}var Cx=0,a2=1,C1=2,Mx=3,ex=4;if(typeof Symbol=="function"&&Symbol.for){var ew=Symbol.for;Cx=ew("selector.component"),a2=ew("selector.has_pseudo_class"),C1=ew("selector.role"),Mx=ew("selector.test_id"),ex=ew("selector.text")}function I2(Pt){var Ut=hy(Pt);if(Ut!=null){if(typeof Ut.memoizedProps["data-testname"]!="string")throw Error(h(364));return Ut}if(Pt=I0(Pt),Pt===null)throw Error(h(362));return Pt.stateNode.current}function r1(Pt,Ut){switch(Ut.$$typeof){case Cx:if(Pt.type===Ut.value)return!0;break;case a2:e:{Ut=Ut.value,Pt=[Pt,0];for(var vr=0;vr<Pt.length;){var Kr=Pt[vr++],n0=Pt[vr++],s0=Ut[n0];if(Kr.tag!==5||!Ey(Kr)){for(;s0!=null&&r1(Kr,s0);)n0++,s0=Ut[n0];if(n0===Ut.length){Ut=!0;break e}else for(Kr=Kr.child;Kr!==null;)Pt.push(Kr,n0),Kr=Kr.sibling}}Ut=!1}return Ut;case C1:if(Pt.tag===5&&Dy(Pt.stateNode,Ut.value))return!0;break;case ex:if((Pt.tag===5||Pt.tag===6)&&(Pt=uy(Pt),Pt!==null&&0<=Pt.indexOf(Ut.value)))return!0;break;case Mx:if(Pt.tag===5&&(Pt=Pt.memoizedProps["data-testname"],typeof Pt=="string"&&Pt.toLowerCase()===Ut.value.toLowerCase()))return!0;break;default:throw Error(h(365))}return!1}function o2(Pt){switch(Pt.$$typeof){case Cx:return"<"+(o0(Pt.value)||"Unknown")+">";case a2:return":has("+(o2(Pt)||"")+")";case C1:return'[role="'+Pt.value+'"]';case ex:return'"'+Pt.value+'"';case Mx:return'[data-testname="'+Pt.value+'"]';default:throw Error(h(365))}}function gE(Pt,Ut){var vr=[];Pt=[Pt,0];for(var Kr=0;Kr<Pt.length;){var n0=Pt[Kr++],s0=Pt[Kr++],z0=Ut[s0];if(n0.tag!==5||!Ey(n0)){for(;z0!=null&&r1(n0,z0);)s0++,z0=Ut[s0];if(s0===Ut.length)vr.push(n0);else for(n0=n0.child;n0!==null;)Pt.push(n0,s0),n0=n0.sibling}}return vr}function pS(Pt,Ut){if(!yv)throw Error(h(363));Pt=I2(Pt),Pt=gE(Pt,Ut),Ut=[],Pt=Array.from(Pt);for(var vr=0;vr<Pt.length;){var Kr=Pt[vr++];if(Kr.tag===5)Ey(Kr)||Ut.push(Kr.stateNode);else for(Kr=Kr.child;Kr!==null;)Pt.push(Kr),Kr=Kr.sibling}return Ut}var HE=Math.ceil,Ix=_.ReactCurrentDispatcher,hS=_.ReactCurrentOwner,R_=_.ReactCurrentBatchConfig,r_=0,V_=null,H_=null,N_=0,M1=0,Rx=dv(0),F_=0,Ox=null,Px=0,R2=0,mS=0,Dx=null,s1=null,gS=0,s2=1/0;function tx(){s2=y_()+500}var l2=!1,O2=null,tw=null,P2=!1,Ew=null,u2=0,c2=0,D2=null,B2=-1,Bx=0;function l1(){return r_&6?y_():B2!==-1?B2:B2=y_()}function pw(Pt){return Pt.mode&1?r_&2&&N_!==0?N_&-N_:ux.transition!==null?(Bx===0&&(Pt=D1,D1<<=1,!(D1&4194240)&&(D1=64),Bx=Pt),Bx):(Pt=G0,Pt!==0?Pt:Iy()):1}function N1(Pt,Ut,vr){if(50<c2)throw c2=0,D2=null,Error(h(185));var Kr=Lx(Pt,Ut);return Kr===null?null:(W1(Kr,Ut,vr),(!(r_&2)||Kr!==V_)&&(Kr===V_&&(!(r_&2)&&(R2|=Ut),F_===4&&Lw(Kr,N_)),Dv(Kr,vr),Ut===1&&r_===0&&!(Pt.mode&1)&&(tx(),jw&&E1())),Kr)}function Lx(Pt,Ut){Pt.lanes|=Ut;var vr=Pt.alternate;for(vr!==null&&(vr.lanes|=Ut),vr=Pt,Pt=Pt.return;Pt!==null;)Pt.childLanes|=Ut,vr=Pt.alternate,vr!==null&&(vr.childLanes|=Ut),vr=Pt,Pt=Pt.return;return vr.tag===3?vr.stateNode:null}function Dv(Pt,Ut){var vr=Pt.callbackNode;Hw(Pt,Ut);var Kr=S1(Pt,Pt===V_?N_:0);if(Kr===0)vr!==null&&Xy(vr),Pt.callbackNode=null,Pt.callbackPriority=0;else if(Ut=Kr&-Kr,Pt.callbackPriority!==Ut){if(vr!=null&&Xy(vr),Ut===1)Pt.tag===0?y2(_E.bind(null,Pt)):Fx(_E.bind(null,Pt)),Gy?sv(function(){r_===0&&E1()}):Ky($_,E1),vr=null;else{switch(X0(Kr)){case 1:vr=$_;break;case 4:vr=G_;break;case 16:vr=aw;break;case 536870912:vr=Ww;break;default:vr=aw}vr=F2(vr,yE.bind(null,Pt))}Pt.callbackPriority=Ut,Pt.callbackNode=vr}}function yE(Pt,Ut){if(B2=-1,Bx=0,r_&6)throw Error(h(327));var vr=Pt.callbackNode;if(Fw()&&Pt.callbackNode!==vr)return null;var Kr=S1(Pt,Pt===V_?N_:0);if(Kr===0)return null;if(Kr&30||Kr&Pt.expiredLanes||Ut)Ut=u1(Pt,Kr);else{Ut=Kr;var n0=r_;r_|=2;var s0=_S();(V_!==Pt||N_!==Ut)&&(tx(),hw(Pt,Ut));do try{bS();break}catch(ny){L2(Pt,ny)}while(!0);Vy(),Ix.current=s0,r_=n0,H_!==null?Ut=0:(V_=null,N_=0,Ut=F_)}if(Ut!==0){if(Ut===2&&(n0=Cw(Pt),n0!==0&&(Kr=n0,Ut=yS(Pt,n0))),Ut===1)throw vr=Ox,hw(Pt,0),Lw(Pt,Kr),Dv(Pt,y_()),vr;if(Ut===6)Lw(Pt,Kr);else{if(n0=Pt.current.alternate,!(Kr&30)&&!vE(n0)&&(Ut=u1(Pt,Kr),Ut===2&&(s0=Cw(Pt),s0!==0&&(Kr=s0,Ut=yS(Pt,s0))),Ut===1))throw vr=Ox,hw(Pt,0),Lw(Pt,Kr),Dv(Pt,y_()),vr;switch(Pt.finishedWork=n0,Pt.finishedLanes=Kr,Ut){case 0:case 1:throw Error(h(345));case 2:Nw(Pt,s1);break;case 3:if(Lw(Pt,Kr),(Kr&130023424)===Kr&&(Ut=gS+500-y_(),10<Ut)){if(S1(Pt,0)!==0)break;if(n0=Pt.suspendedLanes,(n0&Kr)!==Kr){l1(),Pt.pingedLanes|=Pt.suspendedLanes&n0;break}Pt.timeoutHandle=Uy(Nw.bind(null,Pt,s1),Ut);break}Nw(Pt,s1);break;case 4:if(Lw(Pt,Kr),(Kr&4194240)===Kr)break;for(Ut=Pt.eventTimes,n0=-1;0<Kr;){var z0=31-s_(Kr);s0=1<<z0,z0=Ut[z0],z0>n0&&(n0=z0),Kr&=~s0}if(Kr=n0,Kr=y_()-Kr,Kr=(120>Kr?120:480>Kr?480:1080>Kr?1080:1920>Kr?1920:3e3>Kr?3e3:4320>Kr?4320:1960*HE(Kr/1960))-Kr,10<Kr){Pt.timeoutHandle=Uy(Nw.bind(null,Pt,s1),Kr);break}Nw(Pt,s1);break;case 5:Nw(Pt,s1);break;default:throw Error(h(329))}}}return Dv(Pt,y_()),Pt.callbackNode===vr?yE.bind(null,Pt):null}function yS(Pt,Ut){var vr=Dx;return Pt.current.memoizedState.isDehydrated&&(hw(Pt,Ut).flags|=256),Pt=u1(Pt,Ut),Pt!==2&&(Ut=s1,s1=vr,Ut!==null&&nx(Ut)),Pt}function nx(Pt){s1===null?s1=Pt:s1.push.apply(s1,Pt)}function vE(Pt){for(var Ut=Pt;;){if(Ut.flags&16384){var vr=Ut.updateQueue;if(vr!==null&&(vr=vr.stores,vr!==null))for(var Kr=0;Kr<vr.length;Kr++){var n0=vr[Kr],s0=n0.getSnapshot;n0=n0.value;try{if(!t1(s0(),n0))return!1}catch{return!1}}}if(vr=Ut.child,Ut.subtreeFlags&16384&&vr!==null)vr.return=Ut,Ut=vr;else{if(Ut===Pt)break;for(;Ut.sibling===null;){if(Ut.return===null||Ut.return===Pt)return!0;Ut=Ut.return}Ut.sibling.return=Ut.return,Ut=Ut.sibling}}return!0}function Lw(Pt,Ut){for(Ut&=~mS,Ut&=~R2,Pt.suspendedLanes|=Ut,Pt.pingedLanes&=~Ut,Pt=Pt.expirationTimes;0<Ut;){var vr=31-s_(Ut),Kr=1<<vr;Pt[vr]=-1,Ut&=~Kr}}function _E(Pt){if(r_&6)throw Error(h(327));Fw();var Ut=S1(Pt,0);if(!(Ut&1))return Dv(Pt,y_()),null;var vr=u1(Pt,Ut);if(Pt.tag!==0&&vr===2){var Kr=Cw(Pt);Kr!==0&&(Ut=Kr,vr=yS(Pt,Kr))}if(vr===1)throw vr=Ox,hw(Pt,0),Lw(Pt,Ut),Dv(Pt,y_()),vr;if(vr===6)throw Error(h(345));return Pt.finishedWork=Pt.current.alternate,Pt.finishedLanes=Ut,Nw(Pt,s1),Dv(Pt,y_()),null}function I1(Pt){Ew!==null&&Ew.tag===0&&!(r_&6)&&Fw();var Ut=r_;r_|=1;var vr=R_.transition,Kr=G0;try{if(R_.transition=null,G0=1,Pt)return Pt()}finally{G0=Kr,R_.transition=vr,r_=Ut,!(r_&6)&&E1()}}function vS(){M1=Rx.current,K0(Rx)}function hw(Pt,Ut){Pt.finishedWork=null,Pt.finishedLanes=0;var vr=Pt.timeoutHandle;if(vr!==Zy&&(Pt.timeoutHandle=Zy,Qy(vr)),H_!==null)for(vr=H_.return;vr!==null;){var Kr=vr;switch(g1(Kr),Kr.tag){case 1:Kr=Kr.type.childContextTypes,Kr!=null&&o_();break;case 3:wx(),K0(Mv),K0(vv),gv();break;case 5:lw(Kr);break;case 4:wx();break;case 13:K0(ey);break;case 19:K0(ey);break;case 10:Hv(Kr.type._context);break;case 22:case 23:vS()}vr=vr.return}if(V_=Pt,H_=Pt=Tw(Pt.current,null),N_=M1=Ut,F_=0,Ox=null,mS=R2=Px=0,s1=Dx=null,p_!==null){for(Ut=0;Ut<p_.length;Ut++)if(vr=p_[Ut],Kr=vr.interleaved,Kr!==null){vr.interleaved=null;var n0=Kr.next,s0=vr.pending;if(s0!==null){var z0=s0.next;s0.next=n0,Kr.next=z0}vr.pending=Kr}p_=null}return Pt}function L2(Pt,Ut){do{var vr=H_;try{if(Vy(),Wv.current=Tx,v1){for(var Kr=Uv.memoizedState;Kr!==null;){var n0=Kr.queue;n0!==null&&(n0.pending=null),Kr=Kr.next}v1=!1}if(D_=0,Q_=J_=Uv=null,Iw=!1,jx=0,hS.current=null,vr===null||vr.return===null){F_=1,Ox=Ut,H_=null;break}e:{var s0=Pt,z0=vr.return,ny=vr,My=Ut;if(Ut=N_,ny.flags|=32768,My!==null&&typeof My=="object"&&typeof My.then=="function"){var tv=My,xv=ny,Yv=xv.tag;if(!(xv.mode&1)&&(Yv===0||Yv===11||Yv===15)){var Iv=xv.alternate;Iv?(xv.updateQueue=Iv.updateQueue,xv.memoizedState=Iv.memoizedState,xv.lanes=Iv.lanes):(xv.updateQueue=null,xv.memoizedState=null)}var E_=JS(z0);if(E_!==null){E_.flags&=-257,QS(E_,z0,ny,s0,Ut),E_.mode&1&&YS(s0,tv,Ut),Ut=E_,My=tv;var Tv=Ut.updateQueue;if(Tv===null){var f1=new Set;f1.add(My),Ut.updateQueue=f1}else Tv.add(My);break e}else{if(!(Ut&1)){YS(s0,tv,Ut),k2();break e}My=Error(h(426))}}else if(I_&&ny.mode&1){var R1=JS(z0);if(R1!==null){!(R1.flags&65536)&&(R1.flags|=256),QS(R1,z0,ny,s0,Ut),Hx(My);break e}}s0=My,F_!==4&&(F_=2),Dx===null?Dx=[s0]:Dx.push(s0),My=Kw(My,ny),ny=z0;do{switch(ny.tag){case 3:ny.flags|=65536,Ut&=-Ut,ny.lanes|=Ut;var fy=Yw(ny,My,Ut);M_(ny,fy);break e;case 1:s0=My;var iy=ny.type,$y=ny.stateNode;if(!(ny.flags&128)&&(typeof iy.getDerivedStateFromError=="function"||$y!==null&&typeof $y.componentDidCatch=="function"&&(tw===null||!tw.has($y)))){ny.flags|=65536,Ut&=-Ut,ny.lanes|=Ut;var hv=XS(ny,s0,Ut);M_(ny,hv);break e}}ny=ny.return}while(ny!==null)}d2(vr)}catch(Av){Ut=Av,H_===vr&&vr!==null&&(H_=vr=vr.return);continue}break}while(!0)}function _S(){var Pt=Ix.current;return Ix.current=Tx,Pt===null?Tx:Pt}function k2(){(F_===0||F_===3||F_===2)&&(F_=4),V_===null||!(Px&268435455)&&!(R2&268435455)||Lw(V_,N_)}function u1(Pt,Ut){var vr=r_;r_|=2;var Kr=_S();V_===Pt&&N_===Ut||hw(Pt,Ut);do try{kw();break}catch(n0){L2(Pt,n0)}while(!0);if(Vy(),r_=vr,Ix.current=Kr,H_!==null)throw Error(h(261));return V_=null,N_=0,F_}function kw(){for(;H_!==null;)wS(H_)}function bS(){for(;H_!==null&&!_v();)wS(H_)}function wS(Pt){var Ut=SS(Pt.alternate,Pt,M1);Pt.memoizedProps=Pt.pendingProps,Ut===null?d2(Pt):H_=Ut,hS.current=null}function d2(Pt){var Ut=Pt;do{var vr=Ut.alternate;if(Pt=Ut.return,Ut.flags&32768){if(vr=zE(vr,Ut),vr!==null){vr.flags&=32767,H_=vr;return}if(Pt!==null)Pt.flags|=32768,Pt.subtreeFlags=0,Pt.deletions=null;else{F_=6,H_=null;return}}else if(vr=NE(vr,Ut,M1),vr!==null){H_=vr;return}if(Ut=Ut.sibling,Ut!==null){H_=Ut;return}H_=Ut=Pt}while(Ut!==null);F_===0&&(F_=5)}function Nw(Pt,Ut){var vr=G0,Kr=R_.transition;try{R_.transition=null,G0=1,xS(Pt,Ut,vr)}finally{R_.transition=Kr,G0=vr}return null}function xS(Pt,Ut,vr){do Fw();while(Ew!==null);if(r_&6)throw Error(h(327));var Kr=Pt.finishedWork,n0=Pt.finishedLanes;if(Kr===null)return null;if(Pt.finishedWork=null,Pt.finishedLanes=0,Kr===Pt.current)throw Error(h(177));Pt.callbackNode=null,Pt.callbackPriority=0;var s0=Kr.lanes|Kr.childLanes;if(u0(Pt,s0),Pt===V_&&(H_=V_=null,N_=0),!(Kr.subtreeFlags&2064)&&!(Kr.flags&2064)||P2||(P2=!0,F2(aw,function(){return Fw(),null})),s0=(Kr.flags&15990)!==0,Kr.subtreeFlags&15990||s0){s0=R_.transition,R_.transition=null;var z0=G0;G0=1;var ny=r_;r_|=4,hS.current=null,sS(Pt,Kr),hE(Pt,Kr),k0(Pt.containerInfo),Pt.current=Kr,VE(Kr),A_(),r_=ny,G0=z0,R_.transition=s0}else Pt.current=Kr;if(P2&&(P2=!1,Ew=Pt,u2=n0),s0=Pt.pendingLanes,s0===0&&(tw=null),Pv(Kr.stateNode),Dv(Pt,y_()),Ut!==null)for(vr=Pt.onRecoverableError,Kr=0;Kr<Ut.length;Kr++)vr(Ut[Kr]);if(l2)throw l2=!1,Pt=O2,O2=null,Pt;return u2&1&&Pt.tag!==0&&Fw(),s0=Pt.pendingLanes,s0&1?Pt===D2?c2++:(c2=0,D2=Pt):c2=0,E1(),null}function Fw(){if(Ew!==null){var Pt=X0(u2),Ut=R_.transition,vr=G0;try{if(R_.transition=null,G0=16>Pt?16:Pt,Ew===null)var Kr=!1;else{if(Pt=Ew,Ew=null,u2=0,r_&6)throw Error(h(331));var n0=r_;for(r_|=4,fv=Pt.current;fv!==null;){var s0=fv,z0=s0.child;if(fv.flags&16){var ny=s0.deletions;if(ny!==null){for(var My=0;My<ny.length;My++){var tv=ny[My];for(fv=tv;fv!==null;){var xv=fv;switch(xv.tag){case 0:case 11:case 15:J1(8,xv,s0)}var Yv=xv.child;if(Yv!==null)Yv.return=xv,fv=Yv;else for(;fv!==null;){xv=fv;var Iv=xv.sibling,E_=xv.return;if(fw(xv),xv===tv){fv=null;break}if(Iv!==null){Iv.return=E_,fv=Iv;break}fv=E_}}}var Tv=s0.alternate;if(Tv!==null){var f1=Tv.child;if(f1!==null){Tv.child=null;do{var R1=f1.sibling;f1.sibling=null,f1=R1}while(f1!==null)}}fv=s0}}if(s0.subtreeFlags&2064&&z0!==null)z0.return=s0,fv=z0;else e:for(;fv!==null;){if(s0=fv,s0.flags&2048)switch(s0.tag){case 0:case 11:case 15:J1(9,s0,s0.return)}var fy=s0.sibling;if(fy!==null){fy.return=s0.return,fv=fy;break e}fv=s0.return}}var iy=Pt.current;for(fv=iy;fv!==null;){z0=fv;var $y=z0.child;if(z0.subtreeFlags&2064&&$y!==null)$y.return=z0,fv=$y;else e:for(z0=iy;fv!==null;){if(ny=fv,ny.flags&2048)try{switch(ny.tag){case 0:case 11:case 15:Dw(9,ny)}}catch(Av){c1(ny,ny.return,Av)}if(ny===z0){fv=null;break e}var hv=ny.sibling;if(hv!==null){hv.return=ny.return,fv=hv;break e}fv=ny.return}}if(r_=n0,E1(),t_&&typeof t_.onPostCommitFiberRoot=="function")try{t_.onPostCommitFiberRoot(Ry,Pt)}catch{}Kr=!0}return Kr}finally{G0=vr,R_.transition=Ut}}return!1}function N2(Pt,Ut,vr){Ut=Kw(vr,Ut),Ut=Yw(Pt,Ut,1),_1(Pt,Ut),Ut=l1(),Pt=Lx(Pt,1),Pt!==null&&(W1(Pt,1,Ut),Dv(Pt,Ut))}function c1(Pt,Ut,vr){if(Pt.tag===3)N2(Pt,Pt,vr);else for(;Ut!==null;){if(Ut.tag===3){N2(Ut,Pt,vr);break}else if(Ut.tag===1){var Kr=Ut.stateNode;if(typeof Ut.type.getDerivedStateFromError=="function"||typeof Kr.componentDidCatch=="function"&&(tw===null||!tw.has(Kr))){Pt=Kw(vr,Pt),Pt=XS(Ut,Pt,1),_1(Ut,Pt),Pt=l1(),Ut=Lx(Ut,1),Ut!==null&&(W1(Ut,1,Pt),Dv(Ut,Pt));break}}Ut=Ut.return}}function Uw(Pt,Ut,vr){var Kr=Pt.pingCache;Kr!==null&&Kr.delete(Ut),Ut=l1(),Pt.pingedLanes|=Pt.suspendedLanes&vr,V_===Pt&&(N_&vr)===vr&&(F_===4||F_===3&&(N_&130023424)===N_&&500>y_()-gS?hw(Pt,0):mS|=vr),Dv(Pt,Ut)}function bE(Pt,Ut){Ut===0&&(Pt.mode&1?(Ut=B1,B1<<=1,!(B1&130023424)&&(B1=4194304)):Ut=1);var vr=l1();Pt=Lx(Pt,Ut),Pt!==null&&(W1(Pt,Ut,vr),Dv(Pt,vr))}function zw(Pt){var Ut=Pt.memoizedState,vr=0;Ut!==null&&(vr=Ut.retryLane),bE(Pt,vr)}function wE(Pt,Ut){var vr=0;switch(Pt.tag){case 13:var Kr=Pt.stateNode,n0=Pt.memoizedState;n0!==null&&(vr=n0.retryLane);break;case 19:Kr=Pt.stateNode;break;default:throw Error(h(314))}Kr!==null&&Kr.delete(Ut),bE(Pt,vr)}var SS;SS=function(Pt,Ut,vr){if(Pt!==null)if(Pt.memoizedProps!==Ut.pendingProps||Mv.current)A1=!0;else{if(!(Pt.lanes&vr)&&!(Ut.flags&128))return A1=!1,UE(Pt,Ut,vr);A1=!!(Pt.flags&131072)}else A1=!1,I_&&Ut.flags&1048576&&kS(Ut,Gx,Ut.index);switch(Ut.lanes=0,Ut.tag){case 2:var Kr=Ut.type;Pt!==null&&(Pt.alternate=null,Ut.alternate=null,Ut.flags|=2),Pt=Ut.pendingProps;var n0=b_(Ut,vv.current);jv(Ut,vr),n0=__(null,Ut,Kr,Pt,n0,vr);var s0=X2();return Ut.flags|=1,typeof n0=="object"&&n0!==null&&typeof n0.render=="function"&&n0.$$typeof===void 0?(Ut.tag=1,Ut.memoizedState=null,Ut.updateQueue=null,x_(Kr)?(s0=!0,Ov(Ut)):s0=!1,Ut.memoizedState=n0.state!==null&&n0.state!==void 0?n0.state:null,qv(Ut),n0.updater=_2,Ut.stateNode=n0,n0._reactInternals=Ut,dx(Ut,Kr,Pt,vr),Ut=rS(null,Ut,Kr,!0,s0,vr)):(Ut.tag=0,I_&&s0&&b2(Ut),k_(null,Ut,n0,vr),Ut=Ut.child),Ut;case 16:Kr=Ut.elementType;e:{switch(Pt!==null&&(Pt.alternate=null,Ut.alternate=null,Ut.flags|=2),Pt=Ut.pendingProps,n0=Kr._init,Kr=n0(Kr._payload),Ut.type=Kr,n0=Ut.tag=xE(Kr),Pt=c0(Kr,Pt),n0){case 0:Ut=Y1(null,Ut,Kr,Pt,vr);break e;case 1:Ut=aE(null,Ut,Kr,Pt,vr);break e;case 11:Ut=eE(null,Ut,Kr,Pt,vr);break e;case 14:Ut=tE(null,Ut,Kr,c0(Kr.type,Pt),vr);break e}throw Error(h(306,Kr,""))}return Ut;case 0:return Kr=Ut.type,n0=Ut.pendingProps,n0=Ut.elementType===Kr?n0:c0(Kr,n0),Y1(Pt,Ut,Kr,n0,vr);case 1:return Kr=Ut.type,n0=Ut.pendingProps,n0=Ut.elementType===Kr?n0:c0(Kr,n0),aE(Pt,Ut,Kr,n0,vr);case 3:e:{if(oE(Ut),Pt===null)throw Error(h(387));Kr=Ut.pendingProps,s0=Ut.memoizedState,n0=s0.element,d_(Pt,Ut),j1(Ut,Kr,null,vr);var z0=Ut.memoizedState;if(Kr=z0.element,Ay&&s0.isDehydrated)if(s0={element:Kr,isDehydrated:!1,cache:z0.cache,transitions:z0.transitions},Ut.updateQueue.baseState=s0,Ut.memoizedState=s0,Ut.flags&256){n0=Error(h(423)),Ut=sE(Pt,Ut,Kr,vr,n0);break e}else if(Kr!==n0){n0=Error(h(424)),Ut=sE(Pt,Ut,Kr,vr,n0);break e}else for(Ay&&(n1=i1(Ut.stateNode.containerInfo),y1=Ut,I_=!0,K1=null,hx=!1),vr=zS(Ut,null,Kr,vr),Ut.child=vr;vr;)vr.flags=vr.flags&-3|4096,vr=vr.sibling;else{if(mx(),Kr===n0){Ut=K_(Pt,Ut,vr);break e}k_(Pt,Ut,Kr,vr)}Ut=Ut.child}return Ut;case 5:return GS(Ut),Pt===null&&Z2(Ut),Kr=Ut.type,n0=Ut.pendingProps,s0=Pt!==null?Pt.memoizedProps:null,z0=n0.children,cy(Kr,n0)?z0=null:s0!==null&&cy(Kr,s0)&&(Ut.flags|=32),iE(Pt,Ut),k_(Pt,Ut,z0,vr),Ut.child;case 6:return Pt===null&&Z2(Ut),null;case 13:return lE(Pt,Ut,vr);case 4:return K2(Ut,Ut.stateNode.containerInfo),Kr=Ut.pendingProps,Pt===null?Ut.child=yx(Ut,null,Kr,vr):k_(Pt,Ut,Kr,vr),Ut.child;case 11:return Kr=Ut.type,n0=Ut.pendingProps,n0=Ut.elementType===Kr?n0:c0(Kr,n0),eE(Pt,Ut,Kr,n0,vr);case 7:return k_(Pt,Ut,Ut.pendingProps,vr),Ut.child;case 8:return k_(Pt,Ut,Ut.pendingProps.children,vr),Ut.child;case 12:return k_(Pt,Ut,Ut.pendingProps.children,vr),Ut.child;case 10:e:{if(Kr=Ut.type._context,n0=Ut.pendingProps,s0=Ut.memoizedProps,z0=n0.value,Ev(Ut,Kr,z0),s0!==null)if(t1(s0.value,z0)){if(s0.children===n0.children&&!Mv.current){Ut=K_(Pt,Ut,vr);break e}}else for(s0=Ut.child,s0!==null&&(s0.return=Ut);s0!==null;){var ny=s0.dependencies;if(ny!==null){z0=s0.child;for(var My=ny.firstContext;My!==null;){if(My.context===Kr){if(s0.tag===1){My=P_(-1,vr&-vr),My.tag=2;var tv=s0.updateQueue;if(tv!==null){tv=tv.shared;var xv=tv.pending;xv===null?My.next=My:(My.next=xv.next,xv.next=My),tv.pending=My}}s0.lanes|=vr,My=s0.alternate,My!==null&&(My.lanes|=vr),Nv(s0.return,vr,Ut),ny.lanes|=vr;break}My=My.next}}else if(s0.tag===10)z0=s0.type===Ut.type?null:s0.child;else if(s0.tag===18){if(z0=s0.return,z0===null)throw Error(h(341));z0.lanes|=vr,ny=z0.alternate,ny!==null&&(ny.lanes|=vr),Nv(z0,vr,Ut),z0=s0.sibling}else z0=s0.child;if(z0!==null)z0.return=s0;else for(z0=s0;z0!==null;){if(z0===Ut){z0=null;break}if(s0=z0.sibling,s0!==null){s0.return=z0.return,z0=s0;break}z0=z0.return}s0=z0}k_(Pt,Ut,n0.children,vr),Ut=Ut.child}return Ut;case 9:return n0=Ut.type,Kr=Ut.pendingProps.children,jv(Ut,vr),n0=Lv(n0),Kr=Kr(n0),Ut.flags|=1,k_(Pt,Ut,Kr,vr),Ut.child;case 14:return Kr=Ut.type,n0=c0(Kr,Ut.pendingProps),n0=c0(Kr.type,n0),tE(Pt,Ut,Kr,n0,vr);case 15:return nE(Pt,Ut,Ut.type,Ut.pendingProps,vr);case 17:return Kr=Ut.type,n0=Ut.pendingProps,n0=Ut.elementType===Kr?n0:c0(Kr,n0),Pt!==null&&(Pt.alternate=null,Ut.alternate=null,Ut.flags|=2),Ut.tag=1,x_(Kr)?(Pt=!0,Ov(Ut)):Pt=!1,jv(Ut,vr),LS(Ut,Kr,n0),dx(Ut,Kr,n0,vr),rS(null,Ut,Kr,!0,Pt,vr);case 19:return dE(Pt,Ut,vr);case 22:return rE(Pt,Ut,vr)}throw Error(h(156,Ut.tag))};function F2(Pt,Ut){return Ky(Pt,Ut)}function WE(Pt,Ut,vr,Kr){this.tag=Pt,this.key=vr,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=Ut,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=Kr,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function F1(Pt,Ut,vr,Kr){return new WE(Pt,Ut,vr,Kr)}function ES(Pt){return Pt=Pt.prototype,!(!Pt||!Pt.isReactComponent)}function xE(Pt){if(typeof Pt=="function")return ES(Pt)?1:0;if(Pt!=null){if(Pt=Pt.$$typeof,Pt===er)return 11;if(Pt===cr)return 14}return 2}function Tw(Pt,Ut){var vr=Pt.alternate;return vr===null?(vr=F1(Pt.tag,Ut,Pt.key,Pt.mode),vr.elementType=Pt.elementType,vr.type=Pt.type,vr.stateNode=Pt.stateNode,vr.alternate=Pt,Pt.alternate=vr):(vr.pendingProps=Ut,vr.type=Pt.type,vr.flags=0,vr.subtreeFlags=0,vr.deletions=null),vr.flags=Pt.flags&14680064,vr.childLanes=Pt.childLanes,vr.lanes=Pt.lanes,vr.child=Pt.child,vr.memoizedProps=Pt.memoizedProps,vr.memoizedState=Pt.memoizedState,vr.updateQueue=Pt.updateQueue,Ut=Pt.dependencies,vr.dependencies=Ut===null?null:{lanes:Ut.lanes,firstContext:Ut.firstContext},vr.sibling=Pt.sibling,vr.index=Pt.index,vr.ref=Pt.ref,vr}function U2(Pt,Ut,vr,Kr,n0,s0){var z0=2;if(Kr=Pt,typeof Pt=="function")ES(Pt)&&(z0=1);else if(typeof Pt=="string")z0=5;else e:switch(Pt){case j:return Gw(vr.children,n0,s0,Ut);case b:z0=8,n0|=8;break;case Et:return Pt=F1(12,vr,Ut,n0|2),Pt.elementType=Et,Pt.lanes=s0,Pt;case Hn:return Pt=F1(13,vr,Ut,n0),Pt.elementType=Hn,Pt.lanes=s0,Pt;case Qt:return Pt=F1(19,vr,Ut,n0),Pt.elementType=Qt,Pt.lanes=s0,Pt;case jr:return f2(vr,n0,s0,Ut);default:if(typeof Pt=="object"&&Pt!==null)switch(Pt.$$typeof){case It:z0=10;break e;case zt:z0=9;break e;case er:z0=11;break e;case cr:z0=14;break e;case fr:z0=16,Kr=null;break e}throw Error(h(130,Pt==null?Pt:typeof Pt,""))}return Ut=F1(z0,vr,Ut,n0),Ut.elementType=Pt,Ut.type=Kr,Ut.lanes=s0,Ut}function Gw(Pt,Ut,vr,Kr){return Pt=F1(7,Pt,Kr,Ut),Pt.lanes=vr,Pt}function f2(Pt,Ut,vr,Kr){return Pt=F1(22,Pt,Kr,Ut),Pt.elementType=jr,Pt.lanes=vr,Pt.stateNode={},Pt}function d1(Pt,Ut,vr){return Pt=F1(6,Pt,null,Ut),Pt.lanes=vr,Pt}function U1(Pt,Ut,vr){return Ut=F1(4,Pt.children!==null?Pt.children:[],Pt.key,Ut),Ut.lanes=vr,Ut.stateNode={containerInfo:Pt.containerInfo,pendingChildren:null,implementation:Pt.implementation},Ut}function jE(Pt,Ut,vr,Kr,n0){this.tag=Ut,this.containerInfo=Pt,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=Zy,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=H1(0),this.expirationTimes=H1(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=H1(0),this.identifierPrefix=Kr,this.onRecoverableError=n0,Ay&&(this.mutableSourceEagerHydrationData=null)}function SE(Pt,Ut,vr,Kr,n0,s0,z0,ny,My){return Pt=new jE(Pt,Ut,vr,ny,My),Ut===1?(Ut=1,s0===!0&&(Ut|=8)):Ut=0,s0=F1(3,null,null,Ut),Pt.current=s0,s0.stateNode=Pt,s0.memoizedState={element:Kr,isDehydrated:vr,cache:null,transitions:null},qv(s0),Pt}function p2(Pt){if(!Pt)return lv;Pt=Pt._reactInternals;e:{if(g0(Pt)!==Pt||Pt.tag!==1)throw Error(h(170));var Ut=Pt;do{switch(Ut.tag){case 3:Ut=Ut.stateNode.context;break e;case 1:if(x_(Ut.type)){Ut=Ut.stateNode.__reactInternalMemoizedMergedChildContext;break e}}Ut=Ut.return}while(Ut!==null);throw Error(h(171))}if(Pt.tag===1){var vr=Pt.type;if(x_(vr))return w_(Pt,vr,Ut)}return Ut}function rx(Pt){var Ut=Pt._reactInternals;if(Ut===void 0)throw typeof Pt.render=="function"?Error(h(188)):(Pt=Object.keys(Pt).join(","),Error(h(268,Pt)));return Pt=C0(Ut),Pt===null?null:Pt.stateNode}function TS(Pt,Ut){if(Pt=Pt.memoizedState,Pt!==null&&Pt.dehydrated!==null){var vr=Pt.retryLane;Pt.retryLane=vr!==0&&vr<Ut?vr:Ut}}function z2(Pt,Ut){TS(Pt,Ut),(Pt=Pt.alternate)&&TS(Pt,Ut)}function qE(Pt){return Pt=C0(Pt),Pt===null?null:Pt.stateNode}function EE(){return null}return o.attemptContinuousHydration=function(Pt){if(Pt.tag===13){var Ut=l1();N1(Pt,134217728,Ut),z2(Pt,134217728)}},o.attemptHydrationAtCurrentPriority=function(Pt){if(Pt.tag===13){var Ut=l1(),vr=pw(Pt);N1(Pt,vr,Ut),z2(Pt,vr)}},o.attemptSynchronousHydration=function(Pt){switch(Pt.tag){case 3:var Ut=Pt.stateNode;if(Ut.current.memoizedState.isDehydrated){var vr=m1(Ut.pendingLanes);vr!==0&&(M0(Ut,vr|1),Dv(Ut,y_()),!(r_&6)&&(tx(),E1()))}break;case 13:var Kr=l1();I1(function(){return N1(Pt,1,Kr)}),z2(Pt,1)}},o.batchedUpdates=function(Pt,Ut){var vr=r_;r_|=1;try{return Pt(Ut)}finally{r_=vr,r_===0&&(tx(),jw&&E1())}},o.createComponentSelector=function(Pt){return{$$typeof:Cx,value:Pt}},o.createContainer=function(Pt,Ut,vr,Kr,n0,s0,z0){return SE(Pt,Ut,!1,null,vr,Kr,n0,s0,z0)},o.createHasPseudoClassSelector=function(Pt){return{$$typeof:a2,value:Pt}},o.createHydrationContainer=function(Pt,Ut,vr,Kr,n0,s0,z0,ny,My){return Pt=SE(vr,Kr,!0,Pt,n0,s0,z0,ny,My),Pt.context=p2(null),vr=Pt.current,Kr=l1(),n0=pw(vr),s0=P_(Kr,n0),s0.callback=Ut??null,_1(vr,s0),Pt.current.lanes=n0,W1(Pt,n0,Kr),Dv(Pt,Kr),Pt},o.createPortal=function(Pt,Ut,vr){var Kr=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:g,key:Kr==null?null:""+Kr,children:Pt,containerInfo:Ut,implementation:vr}},o.createRoleSelector=function(Pt){return{$$typeof:C1,value:Pt}},o.createTestNameSelector=function(Pt){return{$$typeof:Mx,value:Pt}},o.createTextSelector=function(Pt){return{$$typeof:ex,value:Pt}},o.deferredUpdates=function(Pt){var Ut=G0,vr=R_.transition;try{return R_.transition=null,G0=16,Pt()}finally{G0=Ut,R_.transition=vr}},o.discreteUpdates=function(Pt,Ut,vr,Kr,n0){var s0=G0,z0=R_.transition;try{return R_.transition=null,G0=1,Pt(Ut,vr,Kr,n0)}finally{G0=s0,R_.transition=z0,r_===0&&tx()}},o.findAllNodes=pS,o.findBoundingRects=function(Pt,Ut){if(!yv)throw Error(h(363));Ut=pS(Pt,Ut),Pt=[];for(var vr=0;vr<Ut.length;vr++)Pt.push(b0(Ut[vr]));for(Ut=Pt.length-1;0<Ut;Ut--){vr=Pt[Ut];for(var Kr=vr.x,n0=Kr+vr.width,s0=vr.y,z0=s0+vr.height,ny=Ut-1;0<=ny;ny--)if(Ut!==ny){var My=Pt[ny],tv=My.x,xv=tv+My.width,Yv=My.y,Iv=Yv+My.height;if(Kr>=tv&&s0>=Yv&&n0<=xv&&z0<=Iv){Pt.splice(Ut,1);break}else if(Kr!==tv||vr.width!==My.width||Iv<s0||Yv>z0){if(!(s0!==Yv||vr.height!==My.height||xv<Kr||tv>n0)){tv>Kr&&(My.width+=tv-Kr,My.x=Kr),xv<n0&&(My.width=n0-tv),Pt.splice(Ut,1);break}}else{Yv>s0&&(My.height+=Yv-s0,My.y=s0),Iv<z0&&(My.height=z0-Yv),Pt.splice(Ut,1);break}}}return Pt},o.findHostInstance=rx,o.findHostInstanceWithNoPortals=function(Pt){return Pt=f0(Pt),Pt=Pt!==null?R0(Pt):null,Pt===null?null:Pt.stateNode},o.findHostInstanceWithWarning=function(Pt){return rx(Pt)},o.flushControlled=function(Pt){var Ut=r_;r_|=1;var vr=R_.transition,Kr=G0;try{R_.transition=null,G0=1,Pt()}finally{G0=Kr,R_.transition=vr,r_=Ut,r_===0&&(tx(),E1())}},o.flushPassiveEffects=Fw,o.flushSync=I1,o.focusWithin=function(Pt,Ut){if(!yv)throw Error(h(363));for(Pt=I2(Pt),Ut=gE(Pt,Ut),Ut=Array.from(Ut),Pt=0;Pt<Ut.length;){var vr=Ut[Pt++];if(!Ey(vr)){if(vr.tag===5&&By(vr.stateNode))return!0;for(vr=vr.child;vr!==null;)Ut.push(vr),vr=vr.sibling}}return!1},o.getCurrentUpdatePriority=function(){return G0},o.getFindAllNodesFailureDescription=function(Pt,Ut){if(!yv)throw Error(h(363));var vr=0,Kr=[];Pt=[I2(Pt),0];for(var n0=0;n0<Pt.length;){var s0=Pt[n0++],z0=Pt[n0++],ny=Ut[z0];if((s0.tag!==5||!Ey(s0))&&(r1(s0,ny)&&(Kr.push(o2(ny)),z0++,z0>vr&&(vr=z0)),z0<Ut.length))for(s0=s0.child;s0!==null;)Pt.push(s0,z0),s0=s0.sibling}if(vr<Ut.length){for(Pt=[];vr<Ut.length;vr++)Pt.push(o2(Ut[vr]));return`findAllNodes was able to match part of the selector:
  `+(Kr.join(" > ")+`

No matching component was found for:
  `)+Pt.join(" > ")}return null},o.getPublicRootInstance=function(Pt){if(Pt=Pt.current,!Pt.child)return null;switch(Pt.child.tag){case 5:return H0(Pt.child.stateNode);default:return Pt.child.stateNode}},o.injectIntoDevTools=function(Pt){if(Pt={bundleType:Pt.bundleType,version:Pt.version,rendererPackageName:Pt.rendererPackageName,rendererConfig:Pt.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:_.ReactCurrentDispatcher,findHostInstanceByFiber:qE,findFiberByHostInstance:Pt.findFiberByHostInstance||EE,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.0.0-fc46dba67-20220329"},typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")Pt=!1;else{var Ut=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(Ut.isDisabled||!Ut.supportsFiber)Pt=!0;else{try{Ry=Ut.inject(Pt),t_=Ut}catch{}Pt=!!Ut.checkDCE}}return Pt},o.isAlreadyRendering=function(){return!1},o.observeVisibleRects=function(Pt,Ut,vr,Kr){if(!yv)throw Error(h(363));Pt=pS(Pt,Ut);var n0=bv(Pt,vr,Kr).disconnect;return{disconnect:function(){n0()}}},o.registerMutableSourceForHydration=function(Pt,Ut){var vr=Ut._getVersion;vr=vr(Ut._source),Pt.mutableSourceEagerHydrationData==null?Pt.mutableSourceEagerHydrationData=[Ut,vr]:Pt.mutableSourceEagerHydrationData.push(Ut,vr)},o.runWithPriority=function(Pt,Ut){var vr=G0;try{return G0=Pt,Ut()}finally{G0=vr}},o.shouldError=function(){return null},o.shouldSuspend=function(){return!1},o.updateContainer=function(Pt,Ut,vr,Kr){var n0=Ut.current,s0=l1(),z0=pw(n0);return vr=p2(vr),Ut.context===null?Ut.context=vr:Ut.pendingContext=vr,Ut=P_(s0,z0),Ut.payload={element:Pt},Kr=Kr===void 0?null:Kr,Kr!==null&&(Ut.callback=Kr),_1(n0,Ut),Pt=N1(n0,z0,s0),Pt!==null&&cx(Pt,n0,z0),z0},o};reactReconciler.exports=reactReconciler_production_min;var reactReconcilerExports=reactReconciler.exports;const Reconciler=getDefaultExportFromCjs(reactReconcilerExports),isPromise=a=>typeof a=="object"&&typeof a.then=="function",globalCache=[];function shallowEqualArrays(a,e,o=(s,d)=>s===d){if(a===e)return!0;if(!a||!e)return!1;const s=a.length;if(e.length!==s)return!1;for(let d=0;d<s;d++)if(!o(a[d],e[d]))return!1;return!0}function query(a,e=null,o=!1,s={}){e===null&&(e=[a]);for(const c of globalCache)if(shallowEqualArrays(e,c.keys,c.equal)){if(o)return;if(Object.prototype.hasOwnProperty.call(c,"error"))throw c.error;if(Object.prototype.hasOwnProperty.call(c,"response"))return s.lifespan&&s.lifespan>0&&(c.timeout&&clearTimeout(c.timeout),c.timeout=setTimeout(c.remove,s.lifespan)),c.response;if(!o)throw c.promise}const d={keys:e,equal:s.equal,remove:()=>{const c=globalCache.indexOf(d);c!==-1&&globalCache.splice(c,1)},promise:(isPromise(a)?a:a(...e)).then(c=>{d.response=c,s.lifespan&&s.lifespan>0&&(d.timeout=setTimeout(d.remove,s.lifespan))}).catch(c=>d.error=c)};if(globalCache.push(d),!o)throw d.promise}const suspend=(a,e,o)=>query(a,e,!1,o),preload=(a,e,o)=>void query(a,e,!0,o),clear=a=>{if(a===void 0||a.length===0)globalCache.splice(0,globalCache.length);else{const e=globalCache.find(o=>shallowEqualArrays(a,o.keys,o.equal));e&&e.remove()}},catalogue={},extend=a=>void Object.assign(catalogue,a);function createRenderer(a,e){function o(j,{args:b=[],attach:Et,...It},zt){let er=`${j[0].toUpperCase()}${j.slice(1)}`,Hn;if(j==="primitive"){if(It.object===void 0)throw new Error("R3F: Primitives without 'object' are invalid!");const Qt=It.object;Hn=prepare(Qt,{type:j,root:zt,attach:Et,primitive:!0})}else{const Qt=catalogue[er];if(!Qt)throw new Error(`R3F: ${er} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(!Array.isArray(b))throw new Error("R3F: The args prop must be an array!");Hn=prepare(new Qt(...b),{type:j,root:zt,attach:Et,memoizedProps:{args:b}})}return Hn.__r3f.attach===void 0&&(Hn instanceof BufferGeometry?Hn.__r3f.attach="geometry":Hn instanceof Material&&(Hn.__r3f.attach="material")),er!=="inject"&&applyProps$1(Hn,It),Hn}function s(j,b){let Et=!1;if(b){var It,zt;(It=b.__r3f)!=null&&It.attach?attach(j,b,b.__r3f.attach):b.isObject3D&&j.isObject3D&&(j.add(b),Et=!0),Et||(zt=j.__r3f)==null||zt.objects.push(b),b.__r3f||prepare(b,{}),b.__r3f.parent=j,updateInstance(b),invalidateInstance(b)}}function d(j,b,Et){let It=!1;if(b){var zt,er;if((zt=b.__r3f)!=null&&zt.attach)attach(j,b,b.__r3f.attach);else if(b.isObject3D&&j.isObject3D){b.parent=j,b.dispatchEvent({type:"added"}),j.dispatchEvent({type:"childadded",child:b});const Hn=j.children.filter(cr=>cr!==b),Qt=Hn.indexOf(Et);j.children=[...Hn.slice(0,Qt),b,...Hn.slice(Qt)],It=!0}It||(er=j.__r3f)==null||er.objects.push(b),b.__r3f||prepare(b,{}),b.__r3f.parent=j,updateInstance(b),invalidateInstance(b)}}function c(j,b,Et=!1){j&&[...j].forEach(It=>h(b,It,Et))}function h(j,b,Et){if(b){var It,zt,er;if(b.__r3f&&(b.__r3f.parent=null),(It=j.__r3f)!=null&&It.objects&&(j.__r3f.objects=j.__r3f.objects.filter(jr=>jr!==b)),(zt=b.__r3f)!=null&&zt.attach)detach(j,b,b.__r3f.attach);else if(b.isObject3D&&j.isObject3D){var Hn;j.remove(b),(Hn=b.__r3f)!=null&&Hn.root&&removeInteractivity(findInitialRoot(b),b)}const cr=(er=b.__r3f)==null?void 0:er.primitive,fr=!cr&&(Et===void 0?b.dispose!==null:Et);if(!cr){var Qt;c((Qt=b.__r3f)==null?void 0:Qt.objects,b,fr),c(b.children,b,fr)}if(delete b.__r3f,fr&&b.dispose&&b.type!=="Scene"){const jr=()=>{try{b.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT>"u"?schedulerExports.unstable_scheduleCallback(schedulerExports.unstable_IdlePriority,jr):jr()}invalidateInstance(j)}}function _(j,b,Et,It){var zt;const er=(zt=j.__r3f)==null?void 0:zt.parent;if(!er)return;const Hn=o(b,Et,j.__r3f.root);if(j.children){for(const Qt of j.children)Qt.__r3f&&s(Hn,Qt);j.children=j.children.filter(Qt=>!Qt.__r3f)}j.__r3f.objects.forEach(Qt=>s(Hn,Qt)),j.__r3f.objects=[],j.__r3f.autoRemovedBeforeAppend||h(er,j),Hn.parent&&(Hn.__r3f.autoRemovedBeforeAppend=!0),s(er,Hn),Hn.raycast&&Hn.__r3f.eventCount&&findInitialRoot(Hn).getState().internal.interaction.push(Hn),[It,It.alternate].forEach(Qt=>{Qt!==null&&(Qt.stateNode=Hn,Qt.ref&&(typeof Qt.ref=="function"?Qt.ref(Hn):Qt.ref.current=Hn))})}const bt=()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");return{reconciler:Reconciler({createInstance:o,removeChild:h,appendChild:s,appendInitialChild:s,insertBefore:d,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:(j,b)=>{if(!b)return;const Et=j.getState().scene;Et.__r3f&&(Et.__r3f.root=j,s(Et,b))},removeChildFromContainer:(j,b)=>{b&&h(j.getState().scene,b)},insertInContainerBefore:(j,b,Et)=>{if(!b||!Et)return;const It=j.getState().scene;It.__r3f&&d(It,b,Et)},getRootHostContext:()=>null,getChildHostContext:j=>j,finalizeInitialChildren(j){var b;return!!((b=j==null?void 0:j.__r3f)!=null?b:{}).handlers},prepareUpdate(j,b,Et,It){var zt;if(((zt=j==null?void 0:j.__r3f)!=null?zt:{}).primitive&&It.object&&It.object!==j)return[!0];{const{args:Hn=[],children:Qt,...cr}=It,{args:fr=[],children:jr,...e0}=Et;if(!Array.isArray(Hn))throw new Error("R3F: the args prop must be an array!");if(Hn.some((o0,l0)=>o0!==fr[l0]))return[!0];const t0=diffProps(j,cr,e0,!0);return t0.changes.length?[!1,t0]:null}},commitUpdate(j,[b,Et],It,zt,er,Hn){b?_(j,It,er,Hn):applyProps$1(j,Et)},commitMount(j,b,Et,It){var zt;const er=(zt=j.__r3f)!=null?zt:{};j.raycast&&er.handlers&&er.eventCount&&findInitialRoot(j).getState().internal.interaction.push(j)},getPublicInstance:j=>j,prepareForCommit:()=>null,preparePortalMount:j=>prepare(j.getState().scene),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance(j){var b;const{attach:Et,parent:It}=(b=j.__r3f)!=null?b:{};Et&&It&&detach(It,j,Et),j.isObject3D&&(j.visible=!1),invalidateInstance(j)},unhideInstance(j,b){var Et;const{attach:It,parent:zt}=(Et=j.__r3f)!=null?Et:{};It&&zt&&attach(zt,j,It),(j.isObject3D&&b.visible==null||b.visible)&&(j.visible=!0),invalidateInstance(j)},createTextInstance:bt,hideTextInstance:bt,unhideTextInstance:bt,getCurrentEventPriority:()=>e?e():constantsExports.DefaultEventPriority,beforeActiveInstanceBlur:()=>{},afterActiveInstanceBlur:()=>{},detachDeletedInstance:()=>{},now:typeof performance<"u"&&is$2.fun(performance.now)?performance.now:is$2.fun(Date.now)?Date.now:()=>0,scheduleTimeout:is$2.fun(setTimeout)?setTimeout:void 0,cancelTimeout:is$2.fun(clearTimeout)?clearTimeout:void 0}),applyProps:applyProps$1}}var _window$document,_window$navigator;const hasColorSpace$1=a=>"colorSpace"in a||"outputColorSpace"in a,getColorManagement=()=>{var a;return(a=catalogue.ColorManagement)!=null?a:null},isOrthographicCamera=a=>a&&a.isOrthographicCamera,isRef$1=a=>a&&a.hasOwnProperty("current"),useIsomorphicLayoutEffect=typeof window<"u"&&((_window$document=window.document)!=null&&_window$document.createElement||((_window$navigator=window.navigator)==null?void 0:_window$navigator.product)==="ReactNative")?reactExports.useLayoutEffect:reactExports.useEffect;function useMutableCallback(a){const e=reactExports.useRef(a);return useIsomorphicLayoutEffect(()=>void(e.current=a),[a]),e}function Block({set:a}){return useIsomorphicLayoutEffect(()=>(a(new Promise(()=>null)),()=>a(!1)),[a]),null}class ErrorBoundary extends reactExports.Component{constructor(...e){super(...e),this.state={error:!1}}componentDidCatch(e){this.props.set(e)}render(){return this.state.error?null:this.props.children}}ErrorBoundary.getDerivedStateFromError=()=>({error:!0});const DEFAULT="__default",DEFAULTS=new Map,isDiffSet=a=>a&&!!a.memoized&&!!a.changes;function calculateDpr(a){var e;const o=typeof window<"u"?(e=window.devicePixelRatio)!=null?e:2:1;return Array.isArray(a)?Math.min(Math.max(a[0],o),a[1]):a}const getRootState=a=>{var e;return(e=a.__r3f)==null?void 0:e.root.getState()};function findInitialRoot(a){let e=a.__r3f.root;for(;e.getState().previousRoot;)e=e.getState().previousRoot;return e}const is$2={obj:a=>a===Object(a)&&!is$2.arr(a)&&typeof a!="function",fun:a=>typeof a=="function",str:a=>typeof a=="string",num:a=>typeof a=="number",boo:a=>typeof a=="boolean",und:a=>a===void 0,arr:a=>Array.isArray(a),equ(a,e,{arrays:o="shallow",objects:s="reference",strict:d=!0}={}){if(typeof a!=typeof e||!!a!=!!e)return!1;if(is$2.str(a)||is$2.num(a))return a===e;const c=is$2.obj(a);if(c&&s==="reference")return a===e;const h=is$2.arr(a);if(h&&o==="reference")return a===e;if((h||c)&&a===e)return!0;let _;for(_ in a)if(!(_ in e))return!1;if(c&&o==="shallow"&&s==="shallow"){for(_ in d?e:a)if(!is$2.equ(a[_],e[_],{strict:d,objects:"reference"}))return!1}else for(_ in d?e:a)if(a[_]!==e[_])return!1;if(is$2.und(_)){if(h&&a.length===0&&e.length===0||c&&Object.keys(a).length===0&&Object.keys(e).length===0)return!0;if(a!==e)return!1}return!0}};function buildGraph(a){const e={nodes:{},materials:{}};return a&&a.traverse(o=>{o.name&&(e.nodes[o.name]=o),o.material&&!e.materials[o.material.name]&&(e.materials[o.material.name]=o.material)}),e}function dispose(a){a.dispose&&a.type!=="Scene"&&a.dispose();for(const e in a)e.dispose==null||e.dispose(),delete a[e]}function prepare(a,e){const o=a;return o.__r3f={type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null,...e},a}function resolve(a,e){let o=a;if(e.includes("-")){const s=e.split("-"),d=s.pop();return o=s.reduce((c,h)=>c[h],a),{target:o,key:d}}else return{target:o,key:e}}const INDEX_REGEX=/-\d+$/;function attach(a,e,o){if(is$2.str(o)){if(INDEX_REGEX.test(o)){const c=o.replace(INDEX_REGEX,""),{target:h,key:_}=resolve(a,c);Array.isArray(h[_])||(h[_]=[])}const{target:s,key:d}=resolve(a,o);e.__r3f.previousAttach=s[d],s[d]=e}else e.__r3f.previousAttach=o(a,e)}function detach(a,e,o){var s,d;if(is$2.str(o)){const{target:c,key:h}=resolve(a,o),_=e.__r3f.previousAttach;_===void 0?delete c[h]:c[h]=_}else(s=e.__r3f)==null||s.previousAttach==null||s.previousAttach(a,e);(d=e.__r3f)==null||delete d.previousAttach}function diffProps(a,{children:e,key:o,ref:s,...d},{children:c,key:h,ref:_,...bt}={},g=!1){var j;const b=(j=a==null?void 0:a.__r3f)!=null?j:{},Et=Object.entries(d),It=[];if(g){const er=Object.keys(bt);for(let Hn=0;Hn<er.length;Hn++)d.hasOwnProperty(er[Hn])||Et.unshift([er[Hn],DEFAULT+"remove"])}Et.forEach(([er,Hn])=>{var Qt;if((Qt=a.__r3f)!=null&&Qt.primitive&&er==="object"||is$2.equ(Hn,bt[er]))return;if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(er))return It.push([er,Hn,!0,[]]);let cr=[];er.includes("-")&&(cr=er.split("-")),It.push([er,Hn,!1,cr]);for(const fr in d){const jr=d[fr];fr.startsWith(`${er}-`)&&It.push([fr,jr,!1,fr.split("-")])}});const zt={...d};return b.memoizedProps&&b.memoizedProps.args&&(zt.args=b.memoizedProps.args),b.memoizedProps&&b.memoizedProps.attach&&(zt.attach=b.memoizedProps.attach),{memoized:zt,changes:It}}const __DEV__=typeof process<"u"&&!1;function applyProps$1(a,e){var o,s,d;const c=(o=a.__r3f)!=null?o:{},h=c.root,_=(s=h==null||h.getState==null?void 0:h.getState())!=null?s:{},{memoized:bt,changes:g}=isDiffSet(e)?e:diffProps(a,e),j=c.eventCount;a.__r3f&&(a.__r3f.memoizedProps=bt);for(let Et=0;Et<g.length;Et++){let[It,zt,er,Hn]=g[Et];if(hasColorSpace$1(a)){const jr="srgb",e0="srgb-linear";It==="encoding"?(It="colorSpace",zt=zt===3001?jr:e0):It==="outputEncoding"&&(It="outputColorSpace",zt=zt===3001?jr:e0)}let Qt=a,cr=Qt[It];if(Hn.length&&(cr=Hn.reduce((fr,jr)=>fr[jr],a),!(cr&&cr.set))){const[fr,...jr]=Hn.reverse();Qt=jr.reverse().reduce((e0,t0)=>e0[t0],a),It=fr}if(zt===DEFAULT+"remove")if(Qt.constructor){let fr=DEFAULTS.get(Qt.constructor);fr||(fr=new Qt.constructor,DEFAULTS.set(Qt.constructor,fr)),zt=fr[It]}else zt=0;if(er)zt?c.handlers[It]=zt:delete c.handlers[It],c.eventCount=Object.keys(c.handlers).length;else if(cr&&cr.set&&(cr.copy||cr instanceof Layers)){if(Array.isArray(zt))cr.fromArray?cr.fromArray(zt):cr.set(...zt);else if(cr.copy&&zt&&zt.constructor&&(__DEV__?cr.constructor.name===zt.constructor.name:cr.constructor===zt.constructor))cr.copy(zt);else if(zt!==void 0){const fr=cr instanceof Color;!fr&&cr.setScalar?cr.setScalar(zt):cr instanceof Layers&&zt instanceof Layers?cr.mask=zt.mask:cr.set(zt),!getColorManagement()&&!_.linear&&fr&&cr.convertSRGBToLinear()}}else if(Qt[It]=zt,Qt[It]instanceof Texture&&Qt[It].format===RGBAFormat&&Qt[It].type===UnsignedByteType){const fr=Qt[It];hasColorSpace$1(fr)&&hasColorSpace$1(_.gl)?fr.colorSpace=_.gl.outputColorSpace:fr.encoding=_.gl.outputEncoding}invalidateInstance(a)}if(c.parent&&a.raycast&&j!==c.eventCount){const Et=findInitialRoot(a).getState().internal,It=Et.interaction.indexOf(a);It>-1&&Et.interaction.splice(It,1),c.eventCount&&Et.interaction.push(a)}return!(g.length===1&&g[0][0]==="onUpdate")&&g.length&&(d=a.__r3f)!=null&&d.parent&&updateInstance(a),a}function invalidateInstance(a){var e,o;const s=(e=a.__r3f)==null||(o=e.root)==null||o.getState==null?void 0:o.getState();s&&s.internal.frames===0&&s.invalidate()}function updateInstance(a){a.onUpdate==null||a.onUpdate(a)}function updateCamera(a,e){a.manual||(isOrthographicCamera(a)?(a.left=e.width/-2,a.right=e.width/2,a.top=e.height/2,a.bottom=e.height/-2):a.aspect=e.width/e.height,a.updateProjectionMatrix(),a.updateMatrixWorld())}function makeId(a){return(a.eventObject||a.object).uuid+"/"+a.index+a.instanceId}function getEventPriority(){var a;const e=typeof self<"u"&&self||typeof window<"u"&&window;if(!e)return constantsExports.DefaultEventPriority;switch((a=e.event)==null?void 0:a.type){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return constantsExports.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return constantsExports.ContinuousEventPriority;default:return constantsExports.DefaultEventPriority}}function releaseInternalPointerCapture(a,e,o,s){const d=o.get(e);d&&(o.delete(e),o.size===0&&(a.delete(s),d.target.releasePointerCapture(s)))}function removeInteractivity(a,e){const{internal:o}=a.getState();o.interaction=o.interaction.filter(s=>s!==e),o.initialHits=o.initialHits.filter(s=>s!==e),o.hovered.forEach((s,d)=>{(s.eventObject===e||s.object===e)&&o.hovered.delete(d)}),o.capturedMap.forEach((s,d)=>{releaseInternalPointerCapture(o.capturedMap,e,s,d)})}function createEvents(a){function e(bt){const{internal:g}=a.getState(),j=bt.offsetX-g.initialClick[0],b=bt.offsetY-g.initialClick[1];return Math.round(Math.sqrt(j*j+b*b))}function o(bt){return bt.filter(g=>["Move","Over","Enter","Out","Leave"].some(j=>{var b;return(b=g.__r3f)==null?void 0:b.handlers["onPointer"+j]}))}function s(bt,g){const j=a.getState(),b=new Set,Et=[],It=g?g(j.internal.interaction):j.internal.interaction;for(let Qt=0;Qt<It.length;Qt++){const cr=getRootState(It[Qt]);cr&&(cr.raycaster.camera=void 0)}j.previousRoot||j.events.compute==null||j.events.compute(bt,j);function zt(Qt){const cr=getRootState(Qt);if(!cr||!cr.events.enabled||cr.raycaster.camera===null)return[];if(cr.raycaster.camera===void 0){var fr;cr.events.compute==null||cr.events.compute(bt,cr,(fr=cr.previousRoot)==null?void 0:fr.getState()),cr.raycaster.camera===void 0&&(cr.raycaster.camera=null)}return cr.raycaster.camera?cr.raycaster.intersectObject(Qt,!0):[]}let er=It.flatMap(zt).sort((Qt,cr)=>{const fr=getRootState(Qt.object),jr=getRootState(cr.object);return!fr||!jr?Qt.distance-cr.distance:jr.events.priority-fr.events.priority||Qt.distance-cr.distance}).filter(Qt=>{const cr=makeId(Qt);return b.has(cr)?!1:(b.add(cr),!0)});j.events.filter&&(er=j.events.filter(er,j));for(const Qt of er){let cr=Qt.object;for(;cr;){var Hn;(Hn=cr.__r3f)!=null&&Hn.eventCount&&Et.push({...Qt,eventObject:cr}),cr=cr.parent}}if("pointerId"in bt&&j.internal.capturedMap.has(bt.pointerId))for(let Qt of j.internal.capturedMap.get(bt.pointerId).values())b.has(makeId(Qt.intersection))||Et.push(Qt.intersection);return Et}function d(bt,g,j,b){const Et=a.getState();if(bt.length){const It={stopped:!1};for(const zt of bt){const er=getRootState(zt.object)||Et,{raycaster:Hn,pointer:Qt,camera:cr,internal:fr}=er,jr=new Vector3(Qt.x,Qt.y,0).unproject(cr),e0=i0=>{var f0,C0;return(f0=(C0=fr.capturedMap.get(i0))==null?void 0:C0.has(zt.eventObject))!=null?f0:!1},t0=i0=>{const f0={intersection:zt,target:g.target};fr.capturedMap.has(i0)?fr.capturedMap.get(i0).set(zt.eventObject,f0):fr.capturedMap.set(i0,new Map([[zt.eventObject,f0]])),g.target.setPointerCapture(i0)},o0=i0=>{const f0=fr.capturedMap.get(i0);f0&&releaseInternalPointerCapture(fr.capturedMap,zt.eventObject,f0,i0)};let l0={};for(let i0 in g){let f0=g[i0];typeof f0!="function"&&(l0[i0]=f0)}let g0={...zt,...l0,pointer:Qt,intersections:bt,stopped:It.stopped,delta:j,unprojectedPoint:jr,ray:Hn.ray,camera:cr,stopPropagation(){const i0="pointerId"in g&&fr.capturedMap.get(g.pointerId);if((!i0||i0.has(zt.eventObject))&&(g0.stopped=It.stopped=!0,fr.hovered.size&&Array.from(fr.hovered.values()).find(f0=>f0.eventObject===zt.eventObject))){const f0=bt.slice(0,bt.indexOf(zt));c([...f0,zt])}},target:{hasPointerCapture:e0,setPointerCapture:t0,releasePointerCapture:o0},currentTarget:{hasPointerCapture:e0,setPointerCapture:t0,releasePointerCapture:o0},nativeEvent:g};if(b(g0),It.stopped===!0)break}}return bt}function c(bt){const{internal:g}=a.getState();for(const j of g.hovered.values())if(!bt.length||!bt.find(b=>b.object===j.object&&b.index===j.index&&b.instanceId===j.instanceId)){const Et=j.eventObject.__r3f,It=Et==null?void 0:Et.handlers;if(g.hovered.delete(makeId(j)),Et!=null&&Et.eventCount){const zt={...j,intersections:bt};It.onPointerOut==null||It.onPointerOut(zt),It.onPointerLeave==null||It.onPointerLeave(zt)}}}function h(bt,g){for(let j=0;j<g.length;j++){const b=g[j].__r3f;b==null||b.handlers.onPointerMissed==null||b.handlers.onPointerMissed(bt)}}function _(bt){switch(bt){case"onPointerLeave":case"onPointerCancel":return()=>c([]);case"onLostPointerCapture":return g=>{const{internal:j}=a.getState();"pointerId"in g&&j.capturedMap.has(g.pointerId)&&requestAnimationFrame(()=>{j.capturedMap.has(g.pointerId)&&(j.capturedMap.delete(g.pointerId),c([]))})}}return function(j){const{onPointerMissed:b,internal:Et}=a.getState();Et.lastEvent.current=j;const It=bt==="onPointerMove",zt=bt==="onClick"||bt==="onContextMenu"||bt==="onDoubleClick",Hn=s(j,It?o:void 0),Qt=zt?e(j):0;bt==="onPointerDown"&&(Et.initialClick=[j.offsetX,j.offsetY],Et.initialHits=Hn.map(fr=>fr.eventObject)),zt&&!Hn.length&&Qt<=2&&(h(j,Et.interaction),b&&b(j)),It&&c(Hn);function cr(fr){const jr=fr.eventObject,e0=jr.__r3f,t0=e0==null?void 0:e0.handlers;if(e0!=null&&e0.eventCount)if(It){if(t0.onPointerOver||t0.onPointerEnter||t0.onPointerOut||t0.onPointerLeave){const o0=makeId(fr),l0=Et.hovered.get(o0);l0?l0.stopped&&fr.stopPropagation():(Et.hovered.set(o0,fr),t0.onPointerOver==null||t0.onPointerOver(fr),t0.onPointerEnter==null||t0.onPointerEnter(fr))}t0.onPointerMove==null||t0.onPointerMove(fr)}else{const o0=t0[bt];o0?(!zt||Et.initialHits.includes(jr))&&(h(j,Et.interaction.filter(l0=>!Et.initialHits.includes(l0))),o0(fr)):zt&&Et.initialHits.includes(jr)&&h(j,Et.interaction.filter(l0=>!Et.initialHits.includes(l0)))}}d(Hn,j,Qt,cr)}}return{handlePointer:_}}const privateKeys=["set","get","setSize","setFrameloop","setDpr","events","invalidate","advance","size","viewport"],isRenderer=a=>!!(a!=null&&a.render),context=reactExports.createContext(null),createStore=(a,e)=>{const o=create((_,bt)=>{const g=new Vector3,j=new Vector3,b=new Vector3;function Et(Qt=bt().camera,cr=j,fr=bt().size){const{width:jr,height:e0,top:t0,left:o0}=fr,l0=jr/e0;cr instanceof Vector3?b.copy(cr):b.set(...cr);const g0=Qt.getWorldPosition(g).distanceTo(b);if(isOrthographicCamera(Qt))return{width:jr/Qt.zoom,height:e0/Qt.zoom,top:t0,left:o0,factor:1,distance:g0,aspect:l0};{const i0=Qt.fov*Math.PI/180,f0=2*Math.tan(i0/2)*g0,C0=f0*(jr/e0);return{width:C0,height:f0,top:t0,left:o0,factor:jr/C0,distance:g0,aspect:l0}}}let It;const zt=Qt=>_(cr=>({performance:{...cr.performance,current:Qt}})),er=new Vector2;return{set:_,get:bt,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,scene:null,invalidate:(Qt=1)=>a(bt(),Qt),advance:(Qt,cr)=>e(Qt,cr,bt()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new Clock,pointer:er,mouse:er,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const Qt=bt();It&&clearTimeout(It),Qt.performance.current!==Qt.performance.min&&zt(Qt.performance.min),It=setTimeout(()=>zt(bt().performance.max),Qt.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:Et},setEvents:Qt=>_(cr=>({...cr,events:{...cr.events,...Qt}})),setSize:(Qt,cr,fr,jr,e0)=>{const t0=bt().camera,o0={width:Qt,height:cr,top:jr||0,left:e0||0,updateStyle:fr};_(l0=>({size:o0,viewport:{...l0.viewport,...Et(t0,j,o0)}}))},setDpr:Qt=>_(cr=>{const fr=calculateDpr(Qt);return{viewport:{...cr.viewport,dpr:fr,initialDpr:cr.viewport.initialDpr||fr}}}),setFrameloop:(Qt="always")=>{const cr=bt().clock;cr.stop(),cr.elapsedTime=0,Qt!=="never"&&(cr.start(),cr.elapsedTime=0),_(()=>({frameloop:Qt}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:reactExports.createRef(),interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:(Qt,cr,fr)=>{const jr=bt().internal;return jr.priority=jr.priority+(cr>0?1:0),jr.subscribers.push({ref:Qt,priority:cr,store:fr}),jr.subscribers=jr.subscribers.sort((e0,t0)=>e0.priority-t0.priority),()=>{const e0=bt().internal;e0!=null&&e0.subscribers&&(e0.priority=e0.priority-(cr>0?1:0),e0.subscribers=e0.subscribers.filter(t0=>t0.ref!==Qt))}}}}}),s=o.getState();let d=s.size,c=s.viewport.dpr,h=s.camera;return o.subscribe(()=>{const{camera:_,size:bt,viewport:g,gl:j,set:b}=o.getState();if(bt.width!==d.width||bt.height!==d.height||g.dpr!==c){var Et;d=bt,c=g.dpr,updateCamera(_,bt),j.setPixelRatio(g.dpr);const It=(Et=bt.updateStyle)!=null?Et:typeof HTMLCanvasElement<"u"&&j.domElement instanceof HTMLCanvasElement;j.setSize(bt.width,bt.height,It)}_!==h&&(h=_,b(It=>({viewport:{...It.viewport,...It.viewport.getCurrentViewport(_)}})))}),o.subscribe(_=>a(_)),o};let i$1,globalEffects=new Set,globalAfterEffects=new Set,globalTailEffects=new Set;function run(a,e){if(a.size)for(const{callback:o}of a.values())o(e)}function flushGlobalEffects(a,e){switch(a){case"before":return run(globalEffects,e);case"after":return run(globalAfterEffects,e);case"tail":return run(globalTailEffects,e)}}let subscribers,subscription;function render$1(a,e,o){let s=e.clock.getDelta();for(e.frameloop==="never"&&typeof a=="number"&&(s=a-e.clock.elapsedTime,e.clock.oldTime=e.clock.elapsedTime,e.clock.elapsedTime=a),subscribers=e.internal.subscribers,i$1=0;i$1<subscribers.length;i$1++)subscription=subscribers[i$1],subscription.ref.current(subscription.store.getState(),s,o);return!e.internal.priority&&e.gl.render&&e.gl.render(e.scene,e.camera),e.internal.frames=Math.max(0,e.internal.frames-1),e.frameloop==="always"?1:e.internal.frames}function createLoop(a){let e=!1,o=!1,s,d,c;function h(g){d=requestAnimationFrame(h),e=!0,s=0,flushGlobalEffects("before",g),o=!0;for(const b of a.values()){var j;c=b.store.getState(),c.internal.active&&(c.frameloop==="always"||c.internal.frames>0)&&!((j=c.gl.xr)!=null&&j.isPresenting)&&(s+=render$1(g,c))}if(o=!1,flushGlobalEffects("after",g),s===0)return flushGlobalEffects("tail",g),e=!1,cancelAnimationFrame(d)}function _(g,j=1){var b;if(!g)return a.forEach(Et=>_(Et.store.getState(),j));(b=g.gl.xr)!=null&&b.isPresenting||!g.internal.active||g.frameloop==="never"||(j>1?g.internal.frames=Math.min(60,g.internal.frames+j):o?g.internal.frames=2:g.internal.frames=1,e||(e=!0,requestAnimationFrame(h)))}function bt(g,j=!0,b,Et){if(j&&flushGlobalEffects("before",g),b)render$1(g,b,Et);else for(const It of a.values())render$1(g,It.store.getState());j&&flushGlobalEffects("after",g)}return{loop:h,invalidate:_,advance:bt}}function useStore(){const a=reactExports.useContext(context);if(!a)throw new Error("R3F: Hooks can only be used within the Canvas component!");return a}function useThree(a=o=>o,e){return useStore()(a,e)}function useFrame(a,e=0){const o=useStore(),s=o.getState().internal.subscribe,d=useMutableCallback(a);return useIsomorphicLayoutEffect(()=>s(d,e,o),[e,s,o]),null}const memoizedLoaders=new WeakMap;function loadingFn(a,e){return function(o,...s){let d=memoizedLoaders.get(o);return d||(d=new o,memoizedLoaders.set(o,d)),a&&a(d),Promise.all(s.map(c=>new Promise((h,_)=>d.load(c,bt=>{bt.scene&&Object.assign(bt,buildGraph(bt.scene)),h(bt)},e,bt=>_(new Error(`Could not load ${c}: ${bt==null?void 0:bt.message}`))))))}}function useLoader(a,e,o,s){const d=Array.isArray(e)?e:[e],c=suspend(loadingFn(o,s),[a,...d],{equal:is$2.equ});return Array.isArray(e)?c:c[0]}useLoader.preload=function(a,e,o){const s=Array.isArray(e)?e:[e];return preload(loadingFn(o),[a,...s])};useLoader.clear=function(a,e){const o=Array.isArray(e)?e:[e];return clear([a,...o])};const roots=new Map,{invalidate,advance}=createLoop(roots),{reconciler,applyProps}=createRenderer(roots,getEventPriority),shallowLoose={objects:"shallow",strict:!1},createRendererInstance=(a,e)=>{const o=typeof a=="function"?a(e):a;return isRenderer(o)?o:new WebGLRenderer({powerPreference:"high-performance",canvas:e,antialias:!0,alpha:!0,...a})};function computeInitialSize(a,e){const o=typeof HTMLCanvasElement<"u"&&a instanceof HTMLCanvasElement;if(e){const{width:s,height:d,top:c,left:h,updateStyle:_=o}=e;return{width:s,height:d,top:c,left:h,updateStyle:_}}else if(typeof HTMLCanvasElement<"u"&&a instanceof HTMLCanvasElement&&a.parentElement){const{width:s,height:d,top:c,left:h}=a.parentElement.getBoundingClientRect();return{width:s,height:d,top:c,left:h,updateStyle:o}}else if(typeof OffscreenCanvas<"u"&&a instanceof OffscreenCanvas)return{width:a.width,height:a.height,top:0,left:0,updateStyle:o};return{width:0,height:0,top:0,left:0}}function createRoot(a){const e=roots.get(a),o=e==null?void 0:e.fiber,s=e==null?void 0:e.store;e&&console.warn("R3F.createRoot should only be called once!");const d=typeof reportError=="function"?reportError:console.error,c=s||createStore(invalidate,advance),h=o||reconciler.createContainer(c,constantsExports.ConcurrentRoot,null,!1,null,"",d,null);e||roots.set(a,{fiber:h,store:c});let _,bt=!1,g;return{configure(j={}){let{gl:b,size:Et,scene:It,events:zt,onCreated:er,shadows:Hn=!1,linear:Qt=!1,flat:cr=!1,legacy:fr=!1,orthographic:jr=!1,frameloop:e0="always",dpr:t0=[1,2],performance:o0,raycaster:l0,camera:g0,onPointerMissed:i0}=j,f0=c.getState(),C0=f0.gl;f0.gl||f0.set({gl:C0=createRendererInstance(b,a)});let Z0=f0.raycaster;Z0||f0.set({raycaster:Z0=new Raycaster});const{params:R0,...Y0}=l0||{};if(is$2.equ(Y0,Z0,shallowLoose)||applyProps(Z0,{...Y0}),is$2.equ(R0,Z0.params,shallowLoose)||applyProps(Z0,{params:{...Z0.params,...R0}}),!f0.camera||f0.camera===g&&!is$2.equ(g,g0,shallowLoose)){g=g0;const k0=g0 instanceof Camera,T0=k0?g0:jr?new OrthographicCamera(0,0,0,0,.1,1e3):new PerspectiveCamera(75,0,.1,1e3);k0||(T0.position.z=5,g0&&applyProps(T0,g0),!f0.camera&&!(g0!=null&&g0.rotation)&&T0.lookAt(0,0,0)),f0.set({camera:T0}),Z0.camera=T0}if(!f0.scene){let k0;It instanceof Scene?k0=It:(k0=new Scene,It&&applyProps(k0,It)),f0.set({scene:prepare(k0)})}if(!f0.xr){var H0;const k0=(vy,J0)=>{const cy=c.getState();cy.frameloop!=="never"&&advance(vy,!0,cy,J0)},T0=()=>{const vy=c.getState();vy.gl.xr.enabled=vy.gl.xr.isPresenting,vy.gl.xr.setAnimationLoop(vy.gl.xr.isPresenting?k0:null),vy.gl.xr.isPresenting||invalidate(vy)},q0={connect(){const vy=c.getState().gl;vy.xr.addEventListener("sessionstart",T0),vy.xr.addEventListener("sessionend",T0)},disconnect(){const vy=c.getState().gl;vy.xr.removeEventListener("sessionstart",T0),vy.xr.removeEventListener("sessionend",T0)}};typeof((H0=C0.xr)==null?void 0:H0.addEventListener)=="function"&&q0.connect(),f0.set({xr:q0})}if(C0.shadowMap){const k0=C0.shadowMap.enabled,T0=C0.shadowMap.type;if(C0.shadowMap.enabled=!!Hn,is$2.boo(Hn))C0.shadowMap.type=PCFSoftShadowMap;else if(is$2.str(Hn)){var ty;const q0={basic:BasicShadowMap,percentage:PCFShadowMap,soft:PCFSoftShadowMap,variance:VSMShadowMap};C0.shadowMap.type=(ty=q0[Hn])!=null?ty:PCFSoftShadowMap}else is$2.obj(Hn)&&Object.assign(C0.shadowMap,Hn);(k0!==C0.shadowMap.enabled||T0!==C0.shadowMap.type)&&(C0.shadowMap.needsUpdate=!0)}const w0=getColorManagement();w0&&("enabled"in w0?w0.enabled=!fr:"legacyMode"in w0&&(w0.legacyMode=fr)),bt||applyProps(C0,{outputEncoding:Qt?3e3:3001,toneMapping:cr?NoToneMapping:ACESFilmicToneMapping}),f0.legacy!==fr&&f0.set(()=>({legacy:fr})),f0.linear!==Qt&&f0.set(()=>({linear:Qt})),f0.flat!==cr&&f0.set(()=>({flat:cr})),b&&!is$2.fun(b)&&!isRenderer(b)&&!is$2.equ(b,C0,shallowLoose)&&applyProps(C0,b),zt&&!f0.events.handlers&&f0.set({events:zt(c)});const L0=computeInitialSize(a,Et);return is$2.equ(L0,f0.size,shallowLoose)||f0.setSize(L0.width,L0.height,L0.updateStyle,L0.top,L0.left),t0&&f0.viewport.dpr!==calculateDpr(t0)&&f0.setDpr(t0),f0.frameloop!==e0&&f0.setFrameloop(e0),f0.onPointerMissed||f0.set({onPointerMissed:i0}),o0&&!is$2.equ(o0,f0.performance,shallowLoose)&&f0.set(k0=>({performance:{...k0.performance,...o0}})),_=er,bt=!0,this},render(j){return bt||this.configure(),reconciler.updateContainer(reactExports.createElement(Provider,{store:c,children:j,onCreated:_,rootElement:a}),h,null,()=>{}),c},unmount(){unmountComponentAtNode(a)}}}function Provider({store:a,children:e,onCreated:o,rootElement:s}){return useIsomorphicLayoutEffect(()=>{const d=a.getState();d.set(c=>({internal:{...c.internal,active:!0}})),o&&o(d),a.getState().events.connected||d.events.connect==null||d.events.connect(s)},[]),reactExports.createElement(context.Provider,{value:a},e)}function unmountComponentAtNode(a,e){const o=roots.get(a),s=o==null?void 0:o.fiber;if(s){const d=o==null?void 0:o.store.getState();d&&(d.internal.active=!1),reconciler.updateContainer(null,s,null,()=>{d&&setTimeout(()=>{try{var c,h,_,bt;d.events.disconnect==null||d.events.disconnect(),(c=d.gl)==null||(h=c.renderLists)==null||h.dispose==null||h.dispose(),(_=d.gl)==null||_.forceContextLoss==null||_.forceContextLoss(),(bt=d.gl)!=null&&bt.xr&&d.xr.disconnect(),dispose(d),roots.delete(a),e&&e(a)}catch{}},500)})}}function createPortal(a,e,o){return reactExports.createElement(Portal,{key:e.uuid,children:a,container:e,state:o})}function Portal({state:a={},children:e,container:o}){const{events:s,size:d,...c}=a,h=useStore(),[_]=reactExports.useState(()=>new Raycaster),[bt]=reactExports.useState(()=>new Vector2),g=reactExports.useCallback((b,Et)=>{const It={...b};Object.keys(b).forEach(er=>{(privateKeys.includes(er)||b[er]!==Et[er]&&Et[er])&&delete It[er]});let zt;if(Et&&d){const er=Et.camera;zt=b.viewport.getCurrentViewport(er,new Vector3,d),er!==b.camera&&updateCamera(er,d)}return{...It,scene:o,raycaster:_,pointer:bt,mouse:bt,previousRoot:h,events:{...b.events,...Et==null?void 0:Et.events,...s},size:{...b.size,...d},viewport:{...b.viewport,...zt},...c}},[a]),[j]=reactExports.useState(()=>{const b=h.getState();return create((It,zt)=>({...b,scene:o,raycaster:_,pointer:bt,mouse:bt,previousRoot:h,events:{...b.events,...s},size:{...b.size,...d},...c,set:It,get:zt,setEvents:er=>It(Hn=>({...Hn,events:{...Hn.events,...er}}))}))});return reactExports.useEffect(()=>{const b=h.subscribe(Et=>j.setState(It=>g(Et,It)));return()=>{b(),j.destroy()}},[]),reactExports.useEffect(()=>{j.setState(b=>g(h.getState(),b))},[g]),reactExports.createElement(reactExports.Fragment,null,reconciler.createPortal(reactExports.createElement(context.Provider,{value:j},e),j,null))}reconciler.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:reactExports.version});function _extends$1(){return _extends$1=Object.assign?Object.assign.bind():function(a){for(var e=1;e<arguments.length;e++){var o=arguments[e];for(var s in o)Object.prototype.hasOwnProperty.call(o,s)&&(a[s]=o[s])}return a},_extends$1.apply(this,arguments)}function debounce(a,e,o){var s,d,c,h,_;e==null&&(e=100);function bt(){var j=Date.now()-h;j<e&&j>=0?s=setTimeout(bt,e-j):(s=null,o||(_=a.apply(c,d),c=d=null))}var g=function(){c=this,d=arguments,h=Date.now();var j=o&&!s;return s||(s=setTimeout(bt,e)),j&&(_=a.apply(c,d),c=d=null),_};return g.clear=function(){s&&(clearTimeout(s),s=null)},g.flush=function(){s&&(_=a.apply(c,d),c=d=null,clearTimeout(s),s=null)},g}debounce.debounce=debounce;var debounce_1=debounce;const createDebounce=getDefaultExportFromCjs(debounce_1);function useMeasure(a){let{debounce:e,scroll:o,polyfill:s,offsetSize:d}=a===void 0?{debounce:0,scroll:!1,offsetSize:!1}:a;const c=s||(typeof window>"u"?class{}:window.ResizeObserver);if(!c)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[h,_]=reactExports.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),bt=reactExports.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:h}),g=e?typeof e=="number"?e:e.scroll:null,j=e?typeof e=="number"?e:e.resize:null,b=reactExports.useRef(!1);reactExports.useEffect(()=>(b.current=!0,()=>void(b.current=!1)));const[Et,It,zt]=reactExports.useMemo(()=>{const cr=()=>{if(!bt.current.element)return;const{left:fr,top:jr,width:e0,height:t0,bottom:o0,right:l0,x:g0,y:i0}=bt.current.element.getBoundingClientRect(),f0={left:fr,top:jr,width:e0,height:t0,bottom:o0,right:l0,x:g0,y:i0};bt.current.element instanceof HTMLElement&&d&&(f0.height=bt.current.element.offsetHeight,f0.width=bt.current.element.offsetWidth),Object.freeze(f0),b.current&&!areBoundsEqual(bt.current.lastBounds,f0)&&_(bt.current.lastBounds=f0)};return[cr,j?createDebounce(cr,j):cr,g?createDebounce(cr,g):cr]},[_,d,g,j]);function er(){bt.current.scrollContainers&&(bt.current.scrollContainers.forEach(cr=>cr.removeEventListener("scroll",zt,!0)),bt.current.scrollContainers=null),bt.current.resizeObserver&&(bt.current.resizeObserver.disconnect(),bt.current.resizeObserver=null)}function Hn(){bt.current.element&&(bt.current.resizeObserver=new c(zt),bt.current.resizeObserver.observe(bt.current.element),o&&bt.current.scrollContainers&&bt.current.scrollContainers.forEach(cr=>cr.addEventListener("scroll",zt,{capture:!0,passive:!0})))}const Qt=cr=>{!cr||cr===bt.current.element||(er(),bt.current.element=cr,bt.current.scrollContainers=findScrollContainers(cr),Hn())};return useOnWindowScroll(zt,!!o),useOnWindowResize(It),reactExports.useEffect(()=>{er(),Hn()},[o,zt,It]),reactExports.useEffect(()=>er,[]),[Qt,h,Et]}function useOnWindowResize(a){reactExports.useEffect(()=>{const e=a;return window.addEventListener("resize",e),()=>void window.removeEventListener("resize",e)},[a])}function useOnWindowScroll(a,e){reactExports.useEffect(()=>{if(e){const o=a;return window.addEventListener("scroll",o,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",o,!0)}},[a,e])}function findScrollContainers(a){const e=[];if(!a||a===document.body)return e;const{overflow:o,overflowX:s,overflowY:d}=window.getComputedStyle(a);return[o,s,d].some(c=>c==="auto"||c==="scroll")&&e.push(a),[...e,...findScrollContainers(a.parentElement)]}const keys=["x","y","top","bottom","left","right","width","height"],areBoundsEqual=(a,e)=>keys.every(o=>a[o]===e[o]);var __defProp$3=Object.defineProperty,__defProps=Object.defineProperties,__getOwnPropDescs=Object.getOwnPropertyDescriptors,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp$1=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp$2=(a,e,o)=>e in a?__defProp$3(a,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):a[e]=o,__spreadValues=(a,e)=>{for(var o in e||(e={}))__hasOwnProp$1.call(e,o)&&__defNormalProp$2(a,o,e[o]);if(__getOwnPropSymbols)for(var o of __getOwnPropSymbols(e))__propIsEnum.call(e,o)&&__defNormalProp$2(a,o,e[o]);return a},__spreadProps=(a,e)=>__defProps(a,__getOwnPropDescs(e));function traverseFiber(a,e,o){if(!a)return;if(o(a)===!0)return a;let s=e?a.return:a.child;for(;s;){const d=traverseFiber(s,e,o);if(d)return d;s=e?null:s.sibling}}function wrapContext(a){try{return Object.defineProperties(a,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return a}}const FiberContext=wrapContext(reactExports.createContext(null));class FiberProvider extends reactExports.Component{render(){return reactExports.createElement(FiberContext.Provider,{value:this._reactInternals},this.props.children)}}const{ReactCurrentOwner,ReactCurrentDispatcher}=reactExports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;function useFiber(){const a=reactExports.useContext(FiberContext);if(a===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const e=reactExports.useId();return reactExports.useMemo(()=>{for(const s of[ReactCurrentOwner==null?void 0:ReactCurrentOwner.current,a,a==null?void 0:a.alternate]){if(!s)continue;const d=traverseFiber(s,!1,c=>{let h=c.memoizedState;for(;h;){if(h.memoizedState===e)return!0;h=h.next}});if(d)return d}},[a,e])}function useContextMap(){var a;const e=useFiber(),[o]=reactExports.useState(()=>new Map);o.clear();let s=e;for(;s;){if(s.type&&typeof s.type=="object"){const c=s.type._context===void 0&&s.type.Provider===s.type?s.type:s.type._context;c&&c!==FiberContext&&!o.has(c)&&o.set(c,(a=ReactCurrentDispatcher==null?void 0:ReactCurrentDispatcher.current)==null?void 0:a.readContext(wrapContext(c)))}s=s.return}return o}function useContextBridge(){const a=useContextMap();return reactExports.useMemo(()=>Array.from(a.keys()).reduce((e,o)=>s=>reactExports.createElement(e,null,reactExports.createElement(o.Provider,__spreadProps(__spreadValues({},s),{value:a.get(o)}))),e=>reactExports.createElement(FiberProvider,__spreadValues({},e))),[a])}const DOM_EVENTS={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function createPointerEvents(a){const{handlePointer:e}=createEvents(a);return{priority:1,enabled:!0,compute(o,s,d){s.pointer.set(o.offsetX/s.size.width*2-1,-(o.offsetY/s.size.height)*2+1),s.raycaster.setFromCamera(s.pointer,s.camera)},connected:void 0,handlers:Object.keys(DOM_EVENTS).reduce((o,s)=>({...o,[s]:e(s)}),{}),update:()=>{var o;const{events:s,internal:d}=a.getState();(o=d.lastEvent)!=null&&o.current&&s.handlers&&s.handlers.onPointerMove(d.lastEvent.current)},connect:o=>{var s;const{set:d,events:c}=a.getState();c.disconnect==null||c.disconnect(),d(h=>({events:{...h.events,connected:o}})),Object.entries((s=c.handlers)!=null?s:[]).forEach(([h,_])=>{const[bt,g]=DOM_EVENTS[h];o.addEventListener(bt,_,{passive:g})})},disconnect:()=>{const{set:o,events:s}=a.getState();if(s.connected){var d;Object.entries((d=s.handlers)!=null?d:[]).forEach(([c,h])=>{if(s&&s.connected instanceof HTMLElement){const[_]=DOM_EVENTS[c];s.connected.removeEventListener(_,h)}}),o(c=>({events:{...c.events,connected:void 0}}))}}}}const CanvasImpl=reactExports.forwardRef(function({children:e,fallback:o,resize:s,style:d,gl:c,events:h=createPointerEvents,eventSource:_,eventPrefix:bt,shadows:g,linear:j,flat:b,legacy:Et,orthographic:It,frameloop:zt,dpr:er,performance:Hn,raycaster:Qt,camera:cr,scene:fr,onPointerMissed:jr,onCreated:e0,...t0},o0){reactExports.useMemo(()=>extend(THREE),[]);const l0=useContextBridge(),[g0,i0]=useMeasure({scroll:!0,debounce:{scroll:50,resize:0},...s}),f0=reactExports.useRef(null),C0=reactExports.useRef(null);reactExports.useImperativeHandle(o0,()=>f0.current);const Z0=useMutableCallback(jr),[R0,Y0]=reactExports.useState(!1),[H0,ty]=reactExports.useState(!1);if(R0)throw R0;if(H0)throw H0;const w0=reactExports.useRef(null);useIsomorphicLayoutEffect(()=>{const k0=f0.current;i0.width>0&&i0.height>0&&k0&&(w0.current||(w0.current=createRoot(k0)),w0.current.configure({gl:c,events:h,shadows:g,linear:j,flat:b,legacy:Et,orthographic:It,frameloop:zt,dpr:er,performance:Hn,raycaster:Qt,camera:cr,scene:fr,size:i0,onPointerMissed:(...T0)=>Z0.current==null?void 0:Z0.current(...T0),onCreated:T0=>{T0.events.connect==null||T0.events.connect(_?isRef$1(_)?_.current:_:C0.current),bt&&T0.setEvents({compute:(q0,vy)=>{const J0=q0[bt+"X"],cy=q0[bt+"Y"];vy.pointer.set(J0/vy.size.width*2-1,-(cy/vy.size.height)*2+1),vy.raycaster.setFromCamera(vy.pointer,vy.camera)}}),e0==null||e0(T0)}}),w0.current.render(reactExports.createElement(l0,null,reactExports.createElement(ErrorBoundary,{set:ty},reactExports.createElement(reactExports.Suspense,{fallback:reactExports.createElement(Block,{set:Y0})},e)))))}),reactExports.useEffect(()=>{const k0=f0.current;if(k0)return()=>unmountComponentAtNode(k0)},[]);const L0=_?"none":"auto";return reactExports.createElement("div",_extends$1({ref:C0,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:L0,...d}},t0),reactExports.createElement("div",{ref:g0,style:{width:"100%",height:"100%"}},reactExports.createElement("canvas",{ref:f0,style:{display:"block"}},o)))}),Canvas=reactExports.forwardRef(function(e,o){return reactExports.createElement(FiberProvider,null,reactExports.createElement(CanvasImpl,_extends$1({},e,{ref:o})))});function _extends(){return _extends=Object.assign?Object.assign.bind():function(a){for(var e=1;e<arguments.length;e++){var o=arguments[e];for(var s in o)Object.prototype.hasOwnProperty.call(o,s)&&(a[s]=o[s])}return a},_extends.apply(this,arguments)}function toTrianglesDrawMode(a,e){if(e===TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),a;if(e===TriangleFanDrawMode||e===TriangleStripDrawMode){let o=a.getIndex();if(o===null){const h=[],_=a.getAttribute("position");if(_!==void 0){for(let bt=0;bt<_.count;bt++)h.push(bt);a.setIndex(h),o=a.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),a}const s=o.count-2,d=[];if(o)if(e===TriangleFanDrawMode)for(let h=1;h<=s;h++)d.push(o.getX(0)),d.push(o.getX(h)),d.push(o.getX(h+1));else for(let h=0;h<s;h++)h%2===0?(d.push(o.getX(h)),d.push(o.getX(h+1)),d.push(o.getX(h+2))):(d.push(o.getX(h+2)),d.push(o.getX(h+1)),d.push(o.getX(h)));d.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const c=a.clone();return c.setIndex(d),c.clearGroups(),c}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),a}const version$1=parseInt(REVISION.replace(/\D+/g,""));var u8=Uint8Array,u16=Uint16Array,u32=Uint32Array,fleb=new u8([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),fdeb=new u8([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),clim=new u8([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),freb=function(a,e){for(var o=new u16(31),s=0;s<31;++s)o[s]=e+=1<<a[s-1];for(var d=new u32(o[30]),s=1;s<30;++s)for(var c=o[s];c<o[s+1];++c)d[c]=c-o[s]<<5|s;return[o,d]},_a$1=freb(fleb,2),fl$2=_a$1[0],revfl=_a$1[1];fl$2[28]=258,revfl[258]=28;var _b$1=freb(fdeb,0),fd$2=_b$1[0],rev=new u16(32768);for(var i=0;i<32768;++i){var x=(i&43690)>>>1|(i&21845)<<1;x=(x&52428)>>>2|(x&13107)<<2,x=(x&61680)>>>4|(x&3855)<<4,rev[i]=((x&65280)>>>8|(x&255)<<8)>>>1}var hMap=function(a,e,o){for(var s=a.length,d=0,c=new u16(e);d<s;++d)++c[a[d]-1];var h=new u16(e);for(d=0;d<e;++d)h[d]=h[d-1]+c[d-1]<<1;var _;if(o){_=new u16(1<<e);var bt=15-e;for(d=0;d<s;++d)if(a[d])for(var g=d<<4|a[d],j=e-a[d],b=h[a[d]-1]++<<j,Et=b|(1<<j)-1;b<=Et;++b)_[rev[b]>>>bt]=g}else for(_=new u16(s),d=0;d<s;++d)a[d]&&(_[d]=rev[h[a[d]-1]++]>>>15-a[d]);return _},flt=new u8(288);for(var i=0;i<144;++i)flt[i]=8;for(var i=144;i<256;++i)flt[i]=9;for(var i=256;i<280;++i)flt[i]=7;for(var i=280;i<288;++i)flt[i]=8;var fdt=new u8(32);for(var i=0;i<32;++i)fdt[i]=5;var flrm=hMap(flt,9,1),fdrm=hMap(fdt,5,1),max=function(a){for(var e=a[0],o=1;o<a.length;++o)a[o]>e&&(e=a[o]);return e},bits=function(a,e,o){var s=e/8|0;return(a[s]|a[s+1]<<8)>>(e&7)&o},bits16=function(a,e){var o=e/8|0;return(a[o]|a[o+1]<<8|a[o+2]<<16)>>(e&7)},shft=function(a){return(a/8|0)+(a&7&&1)},slc=function(a,e,o){(e==null||e<0)&&(e=0),(o==null||o>a.length)&&(o=a.length);var s=new(a instanceof u16?u16:a instanceof u32?u32:u8)(o-e);return s.set(a.subarray(e,o)),s},inflt=function(a,e,o){var s=a.length;if(!s||o&&!o.l&&s<5)return e||new u8(0);var d=!e||o,c=!o||o.i;o||(o={}),e||(e=new u8(s*3));var h=function(Ty){var Uy=e.length;if(Ty>Uy){var Qy=new u8(Math.max(Uy*2,Ty));Qy.set(e),e=Qy}},_=o.f||0,bt=o.p||0,g=o.b||0,j=o.l,b=o.d,Et=o.m,It=o.n,zt=s*8;do{if(!j){o.f=_=bits(a,bt,1);var er=bits(a,bt+1,3);if(bt+=3,er)if(er==1)j=flrm,b=fdrm,Et=9,It=5;else if(er==2){var fr=bits(a,bt,31)+257,jr=bits(a,bt+10,15)+4,e0=fr+bits(a,bt+5,31)+1;bt+=14;for(var t0=new u8(e0),o0=new u8(19),l0=0;l0<jr;++l0)o0[clim[l0]]=bits(a,bt+l0*3,7);bt+=jr*3;for(var g0=max(o0),i0=(1<<g0)-1,f0=hMap(o0,g0,1),l0=0;l0<e0;){var C0=f0[bits(a,bt,i0)];bt+=C0&15;var Hn=C0>>>4;if(Hn<16)t0[l0++]=Hn;else{var Z0=0,R0=0;for(Hn==16?(R0=3+bits(a,bt,3),bt+=2,Z0=t0[l0-1]):Hn==17?(R0=3+bits(a,bt,7),bt+=3):Hn==18&&(R0=11+bits(a,bt,127),bt+=7);R0--;)t0[l0++]=Z0}}var Y0=t0.subarray(0,fr),H0=t0.subarray(fr);Et=max(Y0),It=max(H0),j=hMap(Y0,Et,1),b=hMap(H0,It,1)}else throw"invalid block type";else{var Hn=shft(bt)+4,Qt=a[Hn-4]|a[Hn-3]<<8,cr=Hn+Qt;if(cr>s){if(c)throw"unexpected EOF";break}d&&h(g+Qt),e.set(a.subarray(Hn,cr),g),o.b=g+=Qt,o.p=bt=cr*8;continue}if(bt>zt){if(c)throw"unexpected EOF";break}}d&&h(g+131072);for(var ty=(1<<Et)-1,w0=(1<<It)-1,L0=bt;;L0=bt){var Z0=j[bits16(a,bt)&ty],k0=Z0>>>4;if(bt+=Z0&15,bt>zt){if(c)throw"unexpected EOF";break}if(!Z0)throw"invalid length/literal";if(k0<256)e[g++]=k0;else if(k0==256){L0=bt,j=null;break}else{var T0=k0-254;if(k0>264){var l0=k0-257,q0=fleb[l0];T0=bits(a,bt,(1<<q0)-1)+fl$2[l0],bt+=q0}var vy=b[bits16(a,bt)&w0],J0=vy>>>4;if(!vy)throw"invalid distance";bt+=vy&15;var H0=fd$2[J0];if(J0>3){var q0=fdeb[J0];H0+=bits16(a,bt)&(1<<q0)-1,bt+=q0}if(bt>zt){if(c)throw"unexpected EOF";break}d&&h(g+131072);for(var cy=g+T0;g<cy;g+=4)e[g]=e[g-H0],e[g+1]=e[g+1-H0],e[g+2]=e[g+2-H0],e[g+3]=e[g+3-H0];g=cy}}o.l=j,o.p=L0,o.b=g,j&&(_=1,o.m=Et,o.d=b,o.n=It)}while(!_);return g==e.length?e:slc(e,0,g)},et=new u8(0),zlv=function(a){if((a[0]&15)!=8||a[0]>>>4>7||(a[0]<<8|a[1])%31)throw"invalid zlib data";if(a[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function unzlibSync(a,e){return inflt((zlv(a),a.subarray(2,-4)),e)}var td$1=typeof TextDecoder<"u"&&new TextDecoder,tds=0;try{td$1.decode(et,{stream:!0}),tds=1}catch{}var __defProp$2=Object.defineProperty,__defNormalProp$1=(a,e,o)=>e in a?__defProp$2(a,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):a[e]=o,__publicField$1=(a,e,o)=>(__defNormalProp$1(a,typeof e!="symbol"?e+"":e,o),o);const SkyShader={uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new Vector3},up:{value:new Vector3(0,1,0)}},vertexShader:`
      uniform vec3 sunPosition;
      uniform float rayleigh;
      uniform float turbidity;
      uniform float mieCoefficient;
      uniform vec3 up;

      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      // constants for atmospheric scattering
      const float e = 2.71828182845904523536028747135266249775724709369995957;
      const float pi = 3.141592653589793238462643383279502884197169;

      // wavelength of used primaries, according to preetham
      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

      // mie stuff
      // K coefficient for the primaries
      const float v = 4.0;
      const vec3 K = vec3( 0.686, 0.678, 0.666 );
      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

      // earth shadow hack
      // cutoffAngle = pi / 1.95;
      const float cutoffAngle = 1.6110731556870734;
      const float steepness = 1.5;
      const float EE = 1000.0;

      float sunIntensity( float zenithAngleCos ) {
        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
      }

      vec3 totalMie( float T ) {
        float c = ( 0.2 * T ) * 10E-18;
        return 0.434 * c * MieConst;
      }

      void main() {

        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        gl_Position.z = gl_Position.w; // set z to camera.far

        vSunDirection = normalize( sunPosition );

        vSunE = sunIntensity( dot( vSunDirection, up ) );

        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

      // extinction (absorbtion + out scattering)
      // rayleigh coefficients
        vBetaR = totalRayleigh * rayleighCoefficient;

      // mie coefficients
        vBetaM = totalMie( turbidity ) * mieCoefficient;

      }
    `,fragmentShader:`
      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      uniform float mieDirectionalG;
      uniform vec3 up;

      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );

      // constants for atmospheric scattering
      const float pi = 3.141592653589793238462643383279502884197169;

      const float n = 1.0003; // refractive index of air
      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

      // optical length at zenith for molecules
      const float rayleighZenithLength = 8.4E3;
      const float mieZenithLength = 1.25E3;
      // 66 arc seconds -> degrees, and the cosine of that
      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

      // 3.0 / ( 16.0 * pi )
      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
      // 1.0 / ( 4.0 * pi )
      const float ONE_OVER_FOURPI = 0.07957747154594767;

      float rayleighPhase( float cosTheta ) {
        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
      }

      float hgPhase( float cosTheta, float g ) {
        float g2 = pow( g, 2.0 );
        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
      }

      void main() {

        vec3 direction = normalize( vWorldPosition - cameraPos );

      // optical length
      // cutoff angle at 90 to avoid singularity in next formula.
        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
        float sR = rayleighZenithLength * inverse;
        float sM = mieZenithLength * inverse;

      // combined extinction factor
        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

      // in scattering
        float cosTheta = dot( direction, vSunDirection );

        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
        vec3 betaRTheta = vBetaR * rPhase;

        float mPhase = hgPhase( cosTheta, mieDirectionalG );
        vec3 betaMTheta = vBetaM * mPhase;

        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

      // nightsky
        float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
        float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
        vec3 L0 = vec3( 0.1 ) * Fex;

      // composition + solar disc
        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

        gl_FragColor = vec4( retColor, 1.0 );

      #include <tonemapping_fragment>
      #include <${version$1>=154?"colorspace_fragment":"encodings_fragment"}>

      }
    `},material=new ShaderMaterial({name:"SkyShader",fragmentShader:SkyShader.fragmentShader,vertexShader:SkyShader.vertexShader,uniforms:UniformsUtils.clone(SkyShader.uniforms),side:BackSide,depthWrite:!1});let Sky$1=class extends Mesh{constructor(){super(new BoxGeometry(1,1,1),material)}};__publicField$1(Sky$1,"SkyShader",SkyShader);__publicField$1(Sky$1,"material",material);const isCubeTexture=a=>a&&a.isCubeTexture;class GroundProjectedEnv extends Mesh{constructor(e,o){var s,d;const c=isCubeTexture(e),_=((d=c?(s=e.image[0])==null?void 0:s.width:e.image.width)!=null?d:1024)/4,bt=Math.floor(Math.log2(_)),g=Math.pow(2,bt),j=3*Math.max(g,16*7),b=4*g,Et=[c?"#define ENVMAP_TYPE_CUBE":"",`#define CUBEUV_TEXEL_WIDTH ${1/j}`,`#define CUBEUV_TEXEL_HEIGHT ${1/b}`,`#define CUBEUV_MAX_MIP ${bt}.0`],It=`
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,zt=Et.join(`
`)+`
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${parseInt(REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>
        }
        `,er={map:{value:e},height:{value:(o==null?void 0:o.height)||15},radius:{value:(o==null?void 0:o.radius)||100}},Hn=new IcosahedronGeometry(1,16),Qt=new ShaderMaterial({uniforms:er,fragmentShader:zt,vertexShader:It,side:DoubleSide});super(Hn,Qt)}set radius(e){this.material.uniforms.radius.value=e}get radius(){return this.material.uniforms.radius.value}set height(e){this.material.uniforms.height.value=e}get height(){return this.material.uniforms.height.value}}var __defProp$1=Object.defineProperty,__defNormalProp=(a,e,o)=>e in a?__defProp$1(a,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):a[e]=o,__publicField=(a,e,o)=>(__defNormalProp(a,typeof e!="symbol"?e+"":e,o),o);const _ray=new Ray,_plane=new Plane,TILT_LIMIT=Math.cos(70*(Math.PI/180)),moduloWrapAround=(a,e)=>(a%e+e)%e;let OrbitControls$1=class extends EventDispatcher{constructor(e,o){super(),__publicField(this,"object"),__publicField(this,"domElement"),__publicField(this,"enabled",!0),__publicField(this,"target",new Vector3),__publicField(this,"minDistance",0),__publicField(this,"maxDistance",1/0),__publicField(this,"minZoom",0),__publicField(this,"maxZoom",1/0),__publicField(this,"minPolarAngle",0),__publicField(this,"maxPolarAngle",Math.PI),__publicField(this,"minAzimuthAngle",-1/0),__publicField(this,"maxAzimuthAngle",1/0),__publicField(this,"enableDamping",!1),__publicField(this,"dampingFactor",.05),__publicField(this,"enableZoom",!0),__publicField(this,"zoomSpeed",1),__publicField(this,"enableRotate",!0),__publicField(this,"rotateSpeed",1),__publicField(this,"enablePan",!0),__publicField(this,"panSpeed",1),__publicField(this,"screenSpacePanning",!0),__publicField(this,"keyPanSpeed",7),__publicField(this,"zoomToCursor",!1),__publicField(this,"autoRotate",!1),__publicField(this,"autoRotateSpeed",2),__publicField(this,"reverseOrbit",!1),__publicField(this,"reverseHorizontalOrbit",!1),__publicField(this,"reverseVerticalOrbit",!1),__publicField(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),__publicField(this,"mouseButtons",{LEFT:MOUSE.ROTATE,MIDDLE:MOUSE.DOLLY,RIGHT:MOUSE.PAN}),__publicField(this,"touches",{ONE:TOUCH.ROTATE,TWO:TOUCH.DOLLY_PAN}),__publicField(this,"target0"),__publicField(this,"position0"),__publicField(this,"zoom0"),__publicField(this,"_domElementKeyEvents",null),__publicField(this,"getPolarAngle"),__publicField(this,"getAzimuthalAngle"),__publicField(this,"setPolarAngle"),__publicField(this,"setAzimuthalAngle"),__publicField(this,"getDistance"),__publicField(this,"listenToKeyEvents"),__publicField(this,"stopListenToKeyEvents"),__publicField(this,"saveState"),__publicField(this,"reset"),__publicField(this,"update"),__publicField(this,"connect"),__publicField(this,"dispose"),this.object=e,this.domElement=o,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>j.phi,this.getAzimuthalAngle=()=>j.theta,this.setPolarAngle=O0=>{let oy=moduloWrapAround(O0,2*Math.PI),Py=j.phi;Py<0&&(Py+=2*Math.PI),oy<0&&(oy+=2*Math.PI);let nv=Math.abs(oy-Py);2*Math.PI-nv<nv&&(oy<Py?oy+=2*Math.PI:Py+=2*Math.PI),b.phi=oy-Py,s.update()},this.setAzimuthalAngle=O0=>{let oy=moduloWrapAround(O0,2*Math.PI),Py=j.theta;Py<0&&(Py+=2*Math.PI),oy<0&&(oy+=2*Math.PI);let nv=Math.abs(oy-Py);2*Math.PI-nv<nv&&(oy<Py?oy+=2*Math.PI:Py+=2*Math.PI),b.theta=oy-Py,s.update()},this.getDistance=()=>s.object.position.distanceTo(s.target),this.listenToKeyEvents=O0=>{O0.addEventListener("keydown",av),this._domElementKeyEvents=O0},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",av),this._domElementKeyEvents=null},this.saveState=()=>{s.target0.copy(s.target),s.position0.copy(s.object.position),s.zoom0=s.object.zoom},this.reset=()=>{s.target.copy(s.target0),s.object.position.copy(s.position0),s.object.zoom=s.zoom0,s.object.updateProjectionMatrix(),s.dispatchEvent(d),s.update(),bt=_.NONE},this.update=(()=>{const O0=new Vector3,oy=new Vector3(0,1,0),Py=new Quaternion().setFromUnitVectors(e.up,oy),nv=Py.clone().invert(),d0=new Vector3,v0=new Quaternion,N0=2*Math.PI;return function(){const sy=s.object.position;Py.setFromUnitVectors(e.up,oy),nv.copy(Py).invert(),O0.copy(sy).sub(s.target),O0.applyQuaternion(Py),j.setFromVector3(O0),s.autoRotate&&bt===_.NONE&&R0(C0()),s.enableDamping?(j.theta+=b.theta*s.dampingFactor,j.phi+=b.phi*s.dampingFactor):(j.theta+=b.theta,j.phi+=b.phi);let xy=s.minAzimuthAngle,ev=s.maxAzimuthAngle;isFinite(xy)&&isFinite(ev)&&(xy<-Math.PI?xy+=N0:xy>Math.PI&&(xy-=N0),ev<-Math.PI?ev+=N0:ev>Math.PI&&(ev-=N0),xy<=ev?j.theta=Math.max(xy,Math.min(ev,j.theta)):j.theta=j.theta>(xy+ev)/2?Math.max(xy,j.theta):Math.min(ev,j.theta)),j.phi=Math.max(s.minPolarAngle,Math.min(s.maxPolarAngle,j.phi)),j.makeSafe(),s.enableDamping===!0?s.target.addScaledVector(It,s.dampingFactor):s.target.add(It),s.zoomToCursor&&g0||s.object.isOrthographicCamera?j.radius=q0(j.radius):j.radius=q0(j.radius*Et),O0.setFromSpherical(j),O0.applyQuaternion(nv),sy.copy(s.target).add(O0),s.object.matrixAutoUpdate||s.object.updateMatrix(),s.object.lookAt(s.target),s.enableDamping===!0?(b.theta*=1-s.dampingFactor,b.phi*=1-s.dampingFactor,It.multiplyScalar(1-s.dampingFactor)):(b.set(0,0,0),It.set(0,0,0));let Sv=!1;if(s.zoomToCursor&&g0){let kv=null;if(s.object instanceof PerspectiveCamera&&s.object.isPerspectiveCamera){const Vv=O0.length();kv=q0(Vv*Et);const $v=Vv-kv;s.object.position.addScaledVector(o0,$v),s.object.updateMatrixWorld()}else if(s.object.isOrthographicCamera){const Vv=new Vector3(l0.x,l0.y,0);Vv.unproject(s.object),s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/Et)),s.object.updateProjectionMatrix(),Sv=!0;const $v=new Vector3(l0.x,l0.y,0);$v.unproject(s.object),s.object.position.sub($v).add(Vv),s.object.updateMatrixWorld(),kv=O0.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),s.zoomToCursor=!1;kv!==null&&(s.screenSpacePanning?s.target.set(0,0,-1).transformDirection(s.object.matrix).multiplyScalar(kv).add(s.object.position):(_ray.origin.copy(s.object.position),_ray.direction.set(0,0,-1).transformDirection(s.object.matrix),Math.abs(s.object.up.dot(_ray.direction))<TILT_LIMIT?e.lookAt(s.target):(_plane.setFromNormalAndCoplanarPoint(s.object.up,s.target),_ray.intersectPlane(_plane,s.target))))}else s.object instanceof OrthographicCamera&&s.object.isOrthographicCamera&&(Sv=Et!==1,Sv&&(s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/Et)),s.object.updateProjectionMatrix()));return Et=1,g0=!1,Sv||d0.distanceToSquared(s.object.position)>g||8*(1-v0.dot(s.object.quaternion))>g?(s.dispatchEvent(d),d0.copy(s.object.position),v0.copy(s.object.quaternion),Sv=!1,!0):!1}})(),this.connect=O0=>{O0===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),s.domElement=O0,s.domElement.style.touchAction="none",s.domElement.addEventListener("contextmenu",uv),s.domElement.addEventListener("pointerdown",I0),s.domElement.addEventListener("pointercancel",Ey),s.domElement.addEventListener("wheel",bv)},this.dispose=()=>{var O0,oy,Py,nv,d0,v0;(O0=s.domElement)==null||O0.removeEventListener("contextmenu",uv),(oy=s.domElement)==null||oy.removeEventListener("pointerdown",I0),(Py=s.domElement)==null||Py.removeEventListener("pointercancel",Ey),(nv=s.domElement)==null||nv.removeEventListener("wheel",bv),(d0=s.domElement)==null||d0.ownerDocument.removeEventListener("pointermove",b0),(v0=s.domElement)==null||v0.ownerDocument.removeEventListener("pointerup",uy),s._domElementKeyEvents!==null&&s._domElementKeyEvents.removeEventListener("keydown",av)};const s=this,d={type:"change"},c={type:"start"},h={type:"end"},_={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let bt=_.NONE;const g=1e-6,j=new Spherical,b=new Spherical;let Et=1;const It=new Vector3,zt=new Vector2,er=new Vector2,Hn=new Vector2,Qt=new Vector2,cr=new Vector2,fr=new Vector2,jr=new Vector2,e0=new Vector2,t0=new Vector2,o0=new Vector3,l0=new Vector2;let g0=!1;const i0=[],f0={};function C0(){return 2*Math.PI/60/60*s.autoRotateSpeed}function Z0(){return Math.pow(.95,s.zoomSpeed)}function R0(O0){s.reverseOrbit||s.reverseHorizontalOrbit?b.theta+=O0:b.theta-=O0}function Y0(O0){s.reverseOrbit||s.reverseVerticalOrbit?b.phi+=O0:b.phi-=O0}const H0=(()=>{const O0=new Vector3;return function(Py,nv){O0.setFromMatrixColumn(nv,0),O0.multiplyScalar(-Py),It.add(O0)}})(),ty=(()=>{const O0=new Vector3;return function(Py,nv){s.screenSpacePanning===!0?O0.setFromMatrixColumn(nv,1):(O0.setFromMatrixColumn(nv,0),O0.crossVectors(s.object.up,O0)),O0.multiplyScalar(Py),It.add(O0)}})(),w0=(()=>{const O0=new Vector3;return function(Py,nv){const d0=s.domElement;if(d0&&s.object instanceof PerspectiveCamera&&s.object.isPerspectiveCamera){const v0=s.object.position;O0.copy(v0).sub(s.target);let N0=O0.length();N0*=Math.tan(s.object.fov/2*Math.PI/180),H0(2*Py*N0/d0.clientHeight,s.object.matrix),ty(2*nv*N0/d0.clientHeight,s.object.matrix)}else d0&&s.object instanceof OrthographicCamera&&s.object.isOrthographicCamera?(H0(Py*(s.object.right-s.object.left)/s.object.zoom/d0.clientWidth,s.object.matrix),ty(nv*(s.object.top-s.object.bottom)/s.object.zoom/d0.clientHeight,s.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),s.enablePan=!1)}})();function L0(O0){s.object instanceof PerspectiveCamera&&s.object.isPerspectiveCamera||s.object instanceof OrthographicCamera&&s.object.isOrthographicCamera?Et/=O0:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function k0(O0){s.object instanceof PerspectiveCamera&&s.object.isPerspectiveCamera||s.object instanceof OrthographicCamera&&s.object.isOrthographicCamera?Et*=O0:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function T0(O0){if(!s.zoomToCursor||!s.domElement)return;g0=!0;const oy=s.domElement.getBoundingClientRect(),Py=O0.clientX-oy.left,nv=O0.clientY-oy.top,d0=oy.width,v0=oy.height;l0.x=Py/d0*2-1,l0.y=-(nv/v0)*2+1,o0.set(l0.x,l0.y,1).unproject(s.object).sub(s.object.position).normalize()}function q0(O0){return Math.max(s.minDistance,Math.min(s.maxDistance,O0))}function vy(O0){zt.set(O0.clientX,O0.clientY)}function J0(O0){T0(O0),jr.set(O0.clientX,O0.clientY)}function cy(O0){Qt.set(O0.clientX,O0.clientY)}function Ty(O0){er.set(O0.clientX,O0.clientY),Hn.subVectors(er,zt).multiplyScalar(s.rotateSpeed);const oy=s.domElement;oy&&(R0(2*Math.PI*Hn.x/oy.clientHeight),Y0(2*Math.PI*Hn.y/oy.clientHeight)),zt.copy(er),s.update()}function Uy(O0){e0.set(O0.clientX,O0.clientY),t0.subVectors(e0,jr),t0.y>0?L0(Z0()):t0.y<0&&k0(Z0()),jr.copy(e0),s.update()}function Qy(O0){cr.set(O0.clientX,O0.clientY),fr.subVectors(cr,Qt).multiplyScalar(s.panSpeed),w0(fr.x,fr.y),Qt.copy(cr),s.update()}function Zy(O0){T0(O0),O0.deltaY<0?k0(Z0()):O0.deltaY>0&&L0(Z0()),s.update()}function iv(O0){let oy=!1;switch(O0.code){case s.keys.UP:w0(0,s.keyPanSpeed),oy=!0;break;case s.keys.BOTTOM:w0(0,-s.keyPanSpeed),oy=!0;break;case s.keys.LEFT:w0(s.keyPanSpeed,0),oy=!0;break;case s.keys.RIGHT:w0(-s.keyPanSpeed,0),oy=!0;break}oy&&(O0.preventDefault(),s.update())}function zy(){if(i0.length==1)zt.set(i0[0].pageX,i0[0].pageY);else{const O0=.5*(i0[0].pageX+i0[1].pageX),oy=.5*(i0[0].pageY+i0[1].pageY);zt.set(O0,oy)}}function B0(){if(i0.length==1)Qt.set(i0[0].pageX,i0[0].pageY);else{const O0=.5*(i0[0].pageX+i0[1].pageX),oy=.5*(i0[0].pageY+i0[1].pageY);Qt.set(O0,oy)}}function Ay(){const O0=i0[0].pageX-i0[1].pageX,oy=i0[0].pageY-i0[1].pageY,Py=Math.sqrt(O0*O0+oy*oy);jr.set(0,Py)}function hy(){s.enableZoom&&Ay(),s.enablePan&&B0()}function Ly(){s.enableZoom&&Ay(),s.enableRotate&&zy()}function Iy(O0){if(i0.length==1)er.set(O0.pageX,O0.pageY);else{const Py=cv(O0),nv=.5*(O0.pageX+Py.x),d0=.5*(O0.pageY+Py.y);er.set(nv,d0)}Hn.subVectors(er,zt).multiplyScalar(s.rotateSpeed);const oy=s.domElement;oy&&(R0(2*Math.PI*Hn.x/oy.clientHeight),Y0(2*Math.PI*Hn.y/oy.clientHeight)),zt.copy(er)}function Jy(O0){if(i0.length==1)cr.set(O0.pageX,O0.pageY);else{const oy=cv(O0),Py=.5*(O0.pageX+oy.x),nv=.5*(O0.pageY+oy.y);cr.set(Py,nv)}fr.subVectors(cr,Qt).multiplyScalar(s.panSpeed),w0(fr.x,fr.y),Qt.copy(cr)}function Gy(O0){const oy=cv(O0),Py=O0.pageX-oy.x,nv=O0.pageY-oy.y,d0=Math.sqrt(Py*Py+nv*nv);e0.set(0,d0),t0.set(0,Math.pow(e0.y/jr.y,s.zoomSpeed)),L0(t0.y),jr.copy(e0)}function sv(O0){s.enableZoom&&Gy(O0),s.enablePan&&Jy(O0)}function yv(O0){s.enableZoom&&Gy(O0),s.enableRotate&&Iy(O0)}function I0(O0){var oy,Py;s.enabled!==!1&&(i0.length===0&&((oy=s.domElement)==null||oy.ownerDocument.addEventListener("pointermove",b0),(Py=s.domElement)==null||Py.ownerDocument.addEventListener("pointerup",uy)),Hy(O0),O0.pointerType==="touch"?Wy(O0):Dy(O0))}function b0(O0){s.enabled!==!1&&(O0.pointerType==="touch"?my(O0):By(O0))}function uy(O0){var oy,Py,nv;wv(O0),i0.length===0&&((oy=s.domElement)==null||oy.releasePointerCapture(O0.pointerId),(Py=s.domElement)==null||Py.ownerDocument.removeEventListener("pointermove",b0),(nv=s.domElement)==null||nv.ownerDocument.removeEventListener("pointerup",uy)),s.dispatchEvent(h),bt=_.NONE}function Ey(O0){wv(O0)}function Dy(O0){let oy;switch(O0.button){case 0:oy=s.mouseButtons.LEFT;break;case 1:oy=s.mouseButtons.MIDDLE;break;case 2:oy=s.mouseButtons.RIGHT;break;default:oy=-1}switch(oy){case MOUSE.DOLLY:if(s.enableZoom===!1)return;J0(O0),bt=_.DOLLY;break;case MOUSE.ROTATE:if(O0.ctrlKey||O0.metaKey||O0.shiftKey){if(s.enablePan===!1)return;cy(O0),bt=_.PAN}else{if(s.enableRotate===!1)return;vy(O0),bt=_.ROTATE}break;case MOUSE.PAN:if(O0.ctrlKey||O0.metaKey||O0.shiftKey){if(s.enableRotate===!1)return;vy(O0),bt=_.ROTATE}else{if(s.enablePan===!1)return;cy(O0),bt=_.PAN}break;default:bt=_.NONE}bt!==_.NONE&&s.dispatchEvent(c)}function By(O0){if(s.enabled!==!1)switch(bt){case _.ROTATE:if(s.enableRotate===!1)return;Ty(O0);break;case _.DOLLY:if(s.enableZoom===!1)return;Uy(O0);break;case _.PAN:if(s.enablePan===!1)return;Qy(O0);break}}function bv(O0){s.enabled===!1||s.enableZoom===!1||bt!==_.NONE&&bt!==_.ROTATE||(O0.preventDefault(),s.dispatchEvent(c),Zy(O0),s.dispatchEvent(h))}function av(O0){s.enabled===!1||s.enablePan===!1||iv(O0)}function Wy(O0){switch(mv(O0),i0.length){case 1:switch(s.touches.ONE){case TOUCH.ROTATE:if(s.enableRotate===!1)return;zy(),bt=_.TOUCH_ROTATE;break;case TOUCH.PAN:if(s.enablePan===!1)return;B0(),bt=_.TOUCH_PAN;break;default:bt=_.NONE}break;case 2:switch(s.touches.TWO){case TOUCH.DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;hy(),bt=_.TOUCH_DOLLY_PAN;break;case TOUCH.DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;Ly(),bt=_.TOUCH_DOLLY_ROTATE;break;default:bt=_.NONE}break;default:bt=_.NONE}bt!==_.NONE&&s.dispatchEvent(c)}function my(O0){switch(mv(O0),bt){case _.TOUCH_ROTATE:if(s.enableRotate===!1)return;Iy(O0),s.update();break;case _.TOUCH_PAN:if(s.enablePan===!1)return;Jy(O0),s.update();break;case _.TOUCH_DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;sv(O0),s.update();break;case _.TOUCH_DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;yv(O0),s.update();break;default:bt=_.NONE}}function uv(O0){s.enabled!==!1&&O0.preventDefault()}function Hy(O0){i0.push(O0)}function wv(O0){delete f0[O0.pointerId];for(let oy=0;oy<i0.length;oy++)if(i0[oy].pointerId==O0.pointerId){i0.splice(oy,1);return}}function mv(O0){let oy=f0[O0.pointerId];oy===void 0&&(oy=new Vector2,f0[O0.pointerId]=oy),oy.set(O0.pageX,O0.pageY)}function cv(O0){const oy=O0.pointerId===i0[0].pointerId?i0[1]:i0[0];return f0[oy.pointerId]}o!==void 0&&this.connect(o),this.update()}};class GLTFLoader extends Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(o){return new GLTFMaterialsClearcoatExtension(o)}),this.register(function(o){return new GLTFTextureBasisUExtension(o)}),this.register(function(o){return new GLTFTextureWebPExtension(o)}),this.register(function(o){return new GLTFTextureAVIFExtension(o)}),this.register(function(o){return new GLTFMaterialsSheenExtension(o)}),this.register(function(o){return new GLTFMaterialsTransmissionExtension(o)}),this.register(function(o){return new GLTFMaterialsVolumeExtension(o)}),this.register(function(o){return new GLTFMaterialsIorExtension(o)}),this.register(function(o){return new GLTFMaterialsEmissiveStrengthExtension(o)}),this.register(function(o){return new GLTFMaterialsSpecularExtension(o)}),this.register(function(o){return new GLTFMaterialsIridescenceExtension(o)}),this.register(function(o){return new GLTFMaterialsAnisotropyExtension(o)}),this.register(function(o){return new GLTFLightsExtension(o)}),this.register(function(o){return new GLTFMeshoptCompression(o)}),this.register(function(o){return new GLTFMeshGpuInstancing(o)})}load(e,o,s,d){const c=this;let h;this.resourcePath!==""?h=this.resourcePath:this.path!==""?h=this.path:h=LoaderUtils.extractUrlBase(e),this.manager.itemStart(e);const _=function(g){d?d(g):console.error(g),c.manager.itemError(e),c.manager.itemEnd(e)},bt=new FileLoader(this.manager);bt.setPath(this.path),bt.setResponseType("arraybuffer"),bt.setRequestHeader(this.requestHeader),bt.setWithCredentials(this.withCredentials),bt.load(e,function(g){try{c.parse(g,h,function(j){o(j),c.manager.itemEnd(e)},_)}catch(j){_(j)}},s,_)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,o,s,d){let c;const h={},_={};if(typeof e=="string")c=JSON.parse(e);else if(e instanceof ArrayBuffer)if(LoaderUtils.decodeText(new Uint8Array(e.slice(0,4)))===BINARY_EXTENSION_HEADER_MAGIC){try{h[EXTENSIONS.KHR_BINARY_GLTF]=new GLTFBinaryExtension(e)}catch(j){d&&d(j);return}c=JSON.parse(h[EXTENSIONS.KHR_BINARY_GLTF].content)}else c=JSON.parse(LoaderUtils.decodeText(new Uint8Array(e)));else c=e;if(c.asset===void 0||c.asset.version[0]<2){d&&d(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const bt=new GLTFParser(c,{path:o||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});bt.fileLoader.setRequestHeader(this.requestHeader);for(let g=0;g<this.pluginCallbacks.length;g++){const j=this.pluginCallbacks[g](bt);_[j.name]=j,h[j.name]=!0}if(c.extensionsUsed)for(let g=0;g<c.extensionsUsed.length;++g){const j=c.extensionsUsed[g],b=c.extensionsRequired||[];switch(j){case EXTENSIONS.KHR_MATERIALS_UNLIT:h[j]=new GLTFMaterialsUnlitExtension;break;case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:h[j]=new GLTFDracoMeshCompressionExtension(c,this.dracoLoader);break;case EXTENSIONS.KHR_TEXTURE_TRANSFORM:h[j]=new GLTFTextureTransformExtension;break;case EXTENSIONS.KHR_MESH_QUANTIZATION:h[j]=new GLTFMeshQuantizationExtension;break;default:b.indexOf(j)>=0&&_[j]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+j+'".')}}bt.setExtensions(h),bt.setPlugins(_),bt.parse(s,d)}parseAsync(e,o){const s=this;return new Promise(function(d,c){s.parse(e,o,d,c)})}}function GLTFRegistry(){let a={};return{get:function(e){return a[e]},add:function(e,o){a[e]=o},remove:function(e){delete a[e]},removeAll:function(){a={}}}}const EXTENSIONS={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class GLTFLightsExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,o=this.parser.json.nodes||[];for(let s=0,d=o.length;s<d;s++){const c=o[s];c.extensions&&c.extensions[this.name]&&c.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,c.extensions[this.name].light)}}_loadLight(e){const o=this.parser,s="light:"+e;let d=o.cache.get(s);if(d)return d;const c=o.json,bt=((c.extensions&&c.extensions[this.name]||{}).lights||[])[e];let g;const j=new Color(16777215);bt.color!==void 0&&j.fromArray(bt.color);const b=bt.range!==void 0?bt.range:0;switch(bt.type){case"directional":g=new DirectionalLight(j),g.target.position.set(0,0,-1),g.add(g.target);break;case"point":g=new PointLight(j),g.distance=b;break;case"spot":g=new SpotLight(j),g.distance=b,bt.spot=bt.spot||{},bt.spot.innerConeAngle=bt.spot.innerConeAngle!==void 0?bt.spot.innerConeAngle:0,bt.spot.outerConeAngle=bt.spot.outerConeAngle!==void 0?bt.spot.outerConeAngle:Math.PI/4,g.angle=bt.spot.outerConeAngle,g.penumbra=1-bt.spot.innerConeAngle/bt.spot.outerConeAngle,g.target.position.set(0,0,-1),g.add(g.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+bt.type)}return g.position.set(0,0,0),g.decay=2,assignExtrasToUserData(g,bt),bt.intensity!==void 0&&(g.intensity=bt.intensity),g.name=o.createUniqueName(bt.name||"light_"+e),d=Promise.resolve(g),o.cache.add(s,d),d}getDependency(e,o){if(e==="light")return this._loadLight(o)}createNodeAttachment(e){const o=this,s=this.parser,c=s.json.nodes[e],_=(c.extensions&&c.extensions[this.name]||{}).light;return _===void 0?null:this._loadLight(_).then(function(bt){return s._getNodeRef(o.cache,_,bt)})}}class GLTFMaterialsUnlitExtension{constructor(){this.name=EXTENSIONS.KHR_MATERIALS_UNLIT}getMaterialType(){return MeshBasicMaterial}extendParams(e,o,s){const d=[];e.color=new Color(1,1,1),e.opacity=1;const c=o.pbrMetallicRoughness;if(c){if(Array.isArray(c.baseColorFactor)){const h=c.baseColorFactor;e.color.fromArray(h),e.opacity=h[3]}c.baseColorTexture!==void 0&&d.push(s.assignTexture(e,"map",c.baseColorTexture,3001))}return Promise.all(d)}}class GLTFMaterialsEmissiveStrengthExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,o){const d=this.parser.json.materials[e];if(!d.extensions||!d.extensions[this.name])return Promise.resolve();const c=d.extensions[this.name].emissiveStrength;return c!==void 0&&(o.emissiveIntensity=c),Promise.resolve()}}class GLTFMaterialsClearcoatExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,o){const s=this.parser,d=s.json.materials[e];if(!d.extensions||!d.extensions[this.name])return Promise.resolve();const c=[],h=d.extensions[this.name];if(h.clearcoatFactor!==void 0&&(o.clearcoat=h.clearcoatFactor),h.clearcoatTexture!==void 0&&c.push(s.assignTexture(o,"clearcoatMap",h.clearcoatTexture)),h.clearcoatRoughnessFactor!==void 0&&(o.clearcoatRoughness=h.clearcoatRoughnessFactor),h.clearcoatRoughnessTexture!==void 0&&c.push(s.assignTexture(o,"clearcoatRoughnessMap",h.clearcoatRoughnessTexture)),h.clearcoatNormalTexture!==void 0&&(c.push(s.assignTexture(o,"clearcoatNormalMap",h.clearcoatNormalTexture)),h.clearcoatNormalTexture.scale!==void 0)){const _=h.clearcoatNormalTexture.scale;o.clearcoatNormalScale=new Vector2(_,_)}return Promise.all(c)}}class GLTFMaterialsIridescenceExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,o){const s=this.parser,d=s.json.materials[e];if(!d.extensions||!d.extensions[this.name])return Promise.resolve();const c=[],h=d.extensions[this.name];return h.iridescenceFactor!==void 0&&(o.iridescence=h.iridescenceFactor),h.iridescenceTexture!==void 0&&c.push(s.assignTexture(o,"iridescenceMap",h.iridescenceTexture)),h.iridescenceIor!==void 0&&(o.iridescenceIOR=h.iridescenceIor),o.iridescenceThicknessRange===void 0&&(o.iridescenceThicknessRange=[100,400]),h.iridescenceThicknessMinimum!==void 0&&(o.iridescenceThicknessRange[0]=h.iridescenceThicknessMinimum),h.iridescenceThicknessMaximum!==void 0&&(o.iridescenceThicknessRange[1]=h.iridescenceThicknessMaximum),h.iridescenceThicknessTexture!==void 0&&c.push(s.assignTexture(o,"iridescenceThicknessMap",h.iridescenceThicknessTexture)),Promise.all(c)}}class GLTFMaterialsSheenExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,o){const s=this.parser,d=s.json.materials[e];if(!d.extensions||!d.extensions[this.name])return Promise.resolve();const c=[];o.sheenColor=new Color(0,0,0),o.sheenRoughness=0,o.sheen=1;const h=d.extensions[this.name];return h.sheenColorFactor!==void 0&&o.sheenColor.fromArray(h.sheenColorFactor),h.sheenRoughnessFactor!==void 0&&(o.sheenRoughness=h.sheenRoughnessFactor),h.sheenColorTexture!==void 0&&c.push(s.assignTexture(o,"sheenColorMap",h.sheenColorTexture,3001)),h.sheenRoughnessTexture!==void 0&&c.push(s.assignTexture(o,"sheenRoughnessMap",h.sheenRoughnessTexture)),Promise.all(c)}}class GLTFMaterialsTransmissionExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,o){const s=this.parser,d=s.json.materials[e];if(!d.extensions||!d.extensions[this.name])return Promise.resolve();const c=[],h=d.extensions[this.name];return h.transmissionFactor!==void 0&&(o.transmission=h.transmissionFactor),h.transmissionTexture!==void 0&&c.push(s.assignTexture(o,"transmissionMap",h.transmissionTexture)),Promise.all(c)}}class GLTFMaterialsVolumeExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,o){const s=this.parser,d=s.json.materials[e];if(!d.extensions||!d.extensions[this.name])return Promise.resolve();const c=[],h=d.extensions[this.name];o.thickness=h.thicknessFactor!==void 0?h.thicknessFactor:0,h.thicknessTexture!==void 0&&c.push(s.assignTexture(o,"thicknessMap",h.thicknessTexture)),o.attenuationDistance=h.attenuationDistance||1/0;const _=h.attenuationColor||[1,1,1];return o.attenuationColor=new Color(_[0],_[1],_[2]),Promise.all(c)}}class GLTFMaterialsIorExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,o){const d=this.parser.json.materials[e];if(!d.extensions||!d.extensions[this.name])return Promise.resolve();const c=d.extensions[this.name];return o.ior=c.ior!==void 0?c.ior:1.5,Promise.resolve()}}class GLTFMaterialsSpecularExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,o){const s=this.parser,d=s.json.materials[e];if(!d.extensions||!d.extensions[this.name])return Promise.resolve();const c=[],h=d.extensions[this.name];o.specularIntensity=h.specularFactor!==void 0?h.specularFactor:1,h.specularTexture!==void 0&&c.push(s.assignTexture(o,"specularIntensityMap",h.specularTexture));const _=h.specularColorFactor||[1,1,1];return o.specularColor=new Color(_[0],_[1],_[2]),h.specularColorTexture!==void 0&&c.push(s.assignTexture(o,"specularColorMap",h.specularColorTexture,3001)),Promise.all(c)}}class GLTFMaterialsAnisotropyExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,o){const s=this.parser,d=s.json.materials[e];if(!d.extensions||!d.extensions[this.name])return Promise.resolve();const c=[],h=d.extensions[this.name];return h.anisotropyStrength!==void 0&&(o.anisotropy=h.anisotropyStrength),h.anisotropyRotation!==void 0&&(o.anisotropyRotation=h.anisotropyRotation),h.anisotropyTexture!==void 0&&c.push(s.assignTexture(o,"anisotropyMap",h.anisotropyTexture)),Promise.all(c)}}class GLTFTextureBasisUExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_TEXTURE_BASISU}loadTexture(e){const o=this.parser,s=o.json,d=s.textures[e];if(!d.extensions||!d.extensions[this.name])return null;const c=d.extensions[this.name],h=o.options.ktx2Loader;if(!h){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return o.loadTextureImage(e,c.source,h)}}class GLTFTextureWebPExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const o=this.name,s=this.parser,d=s.json,c=d.textures[e];if(!c.extensions||!c.extensions[o])return null;const h=c.extensions[o],_=d.images[h.source];let bt=s.textureLoader;if(_.uri){const g=s.options.manager.getHandler(_.uri);g!==null&&(bt=g)}return this.detectSupport().then(function(g){if(g)return s.loadTextureImage(e,h.source,bt);if(d.extensionsRequired&&d.extensionsRequired.indexOf(o)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const o=new Image;o.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",o.onload=o.onerror=function(){e(o.height===1)}})),this.isSupported}}class GLTFTextureAVIFExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const o=this.name,s=this.parser,d=s.json,c=d.textures[e];if(!c.extensions||!c.extensions[o])return null;const h=c.extensions[o],_=d.images[h.source];let bt=s.textureLoader;if(_.uri){const g=s.options.manager.getHandler(_.uri);g!==null&&(bt=g)}return this.detectSupport().then(function(g){if(g)return s.loadTextureImage(e,h.source,bt);if(d.extensionsRequired&&d.extensionsRequired.indexOf(o)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const o=new Image;o.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",o.onload=o.onerror=function(){e(o.height===1)}})),this.isSupported}}class GLTFMeshoptCompression{constructor(e){this.name=EXTENSIONS.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const o=this.parser.json,s=o.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const d=s.extensions[this.name],c=this.parser.getDependency("buffer",d.buffer),h=this.parser.options.meshoptDecoder;if(!h||!h.supported){if(o.extensionsRequired&&o.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return c.then(function(_){const bt=d.byteOffset||0,g=d.byteLength||0,j=d.count,b=d.byteStride,Et=new Uint8Array(_,bt,g);return h.decodeGltfBufferAsync?h.decodeGltfBufferAsync(j,b,Et,d.mode,d.filter).then(function(It){return It.buffer}):h.ready.then(function(){const It=new ArrayBuffer(j*b);return h.decodeGltfBuffer(new Uint8Array(It),j,b,Et,d.mode,d.filter),It})})}else return null}}class GLTFMeshGpuInstancing{constructor(e){this.name=EXTENSIONS.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const o=this.parser.json,s=o.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const d=o.meshes[s.mesh];for(const g of d.primitives)if(g.mode!==WEBGL_CONSTANTS.TRIANGLES&&g.mode!==WEBGL_CONSTANTS.TRIANGLE_STRIP&&g.mode!==WEBGL_CONSTANTS.TRIANGLE_FAN&&g.mode!==void 0)return null;const h=s.extensions[this.name].attributes,_=[],bt={};for(const g in h)_.push(this.parser.getDependency("accessor",h[g]).then(j=>(bt[g]=j,bt[g])));return _.length<1?null:(_.push(this.parser.createNodeMesh(e)),Promise.all(_).then(g=>{const j=g.pop(),b=j.isGroup?j.children:[j],Et=g[0].count,It=[];for(const zt of b){const er=new Matrix4,Hn=new Vector3,Qt=new Quaternion,cr=new Vector3(1,1,1),fr=new InstancedMesh(zt.geometry,zt.material,Et);for(let jr=0;jr<Et;jr++)bt.TRANSLATION&&Hn.fromBufferAttribute(bt.TRANSLATION,jr),bt.ROTATION&&Qt.fromBufferAttribute(bt.ROTATION,jr),bt.SCALE&&cr.fromBufferAttribute(bt.SCALE,jr),fr.setMatrixAt(jr,er.compose(Hn,Qt,cr));for(const jr in bt)jr!=="TRANSLATION"&&jr!=="ROTATION"&&jr!=="SCALE"&&zt.geometry.setAttribute(jr,bt[jr]);Object3D.prototype.copy.call(fr,zt),this.parser.assignFinalMaterial(fr),It.push(fr)}return j.isGroup?(j.clear(),j.add(...It),j):It[0]}))}}const BINARY_EXTENSION_HEADER_MAGIC="glTF",BINARY_EXTENSION_HEADER_LENGTH=12,BINARY_EXTENSION_CHUNK_TYPES={JSON:1313821514,BIN:5130562};class GLTFBinaryExtension{constructor(e){this.name=EXTENSIONS.KHR_BINARY_GLTF,this.content=null,this.body=null;const o=new DataView(e,0,BINARY_EXTENSION_HEADER_LENGTH);if(this.header={magic:LoaderUtils.decodeText(new Uint8Array(e.slice(0,4))),version:o.getUint32(4,!0),length:o.getUint32(8,!0)},this.header.magic!==BINARY_EXTENSION_HEADER_MAGIC)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const s=this.header.length-BINARY_EXTENSION_HEADER_LENGTH,d=new DataView(e,BINARY_EXTENSION_HEADER_LENGTH);let c=0;for(;c<s;){const h=d.getUint32(c,!0);c+=4;const _=d.getUint32(c,!0);if(c+=4,_===BINARY_EXTENSION_CHUNK_TYPES.JSON){const bt=new Uint8Array(e,BINARY_EXTENSION_HEADER_LENGTH+c,h);this.content=LoaderUtils.decodeText(bt)}else if(_===BINARY_EXTENSION_CHUNK_TYPES.BIN){const bt=BINARY_EXTENSION_HEADER_LENGTH+c;this.body=e.slice(bt,bt+h)}c+=h}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class GLTFDracoMeshCompressionExtension{constructor(e,o){if(!o)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=EXTENSIONS.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=o,this.dracoLoader.preload()}decodePrimitive(e,o){const s=this.json,d=this.dracoLoader,c=e.extensions[this.name].bufferView,h=e.extensions[this.name].attributes,_={},bt={},g={};for(const j in h){const b=ATTRIBUTES[j]||j.toLowerCase();_[b]=h[j]}for(const j in e.attributes){const b=ATTRIBUTES[j]||j.toLowerCase();if(h[j]!==void 0){const Et=s.accessors[e.attributes[j]],It=WEBGL_COMPONENT_TYPES[Et.componentType];g[b]=It.name,bt[b]=Et.normalized===!0}}return o.getDependency("bufferView",c).then(function(j){return new Promise(function(b){d.decodeDracoFile(j,function(Et){for(const It in Et.attributes){const zt=Et.attributes[It],er=bt[It];er!==void 0&&(zt.normalized=er)}b(Et)},_,g)})})}}class GLTFTextureTransformExtension{constructor(){this.name=EXTENSIONS.KHR_TEXTURE_TRANSFORM}extendTexture(e,o){return(o.texCoord===void 0||o.texCoord===e.channel)&&o.offset===void 0&&o.rotation===void 0&&o.scale===void 0||(e=e.clone(),o.texCoord!==void 0&&(e.channel=o.texCoord),o.offset!==void 0&&e.offset.fromArray(o.offset),o.rotation!==void 0&&(e.rotation=o.rotation),o.scale!==void 0&&e.repeat.fromArray(o.scale),e.needsUpdate=!0),e}}class GLTFMeshQuantizationExtension{constructor(){this.name=EXTENSIONS.KHR_MESH_QUANTIZATION}}class GLTFCubicSplineInterpolant extends Interpolant{constructor(e,o,s,d){super(e,o,s,d)}copySampleValue_(e){const o=this.resultBuffer,s=this.sampleValues,d=this.valueSize,c=e*d*3+d;for(let h=0;h!==d;h++)o[h]=s[c+h];return o}interpolate_(e,o,s,d){const c=this.resultBuffer,h=this.sampleValues,_=this.valueSize,bt=_*2,g=_*3,j=d-o,b=(s-o)/j,Et=b*b,It=Et*b,zt=e*g,er=zt-g,Hn=-2*It+3*Et,Qt=It-Et,cr=1-Hn,fr=Qt-Et+b;for(let jr=0;jr!==_;jr++){const e0=h[er+jr+_],t0=h[er+jr+bt]*j,o0=h[zt+jr+_],l0=h[zt+jr]*j;c[jr]=cr*e0+fr*t0+Hn*o0+Qt*l0}return c}}const _q=new Quaternion;class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant{interpolate_(e,o,s,d){const c=super.interpolate_(e,o,s,d);return _q.fromArray(c).normalize().toArray(c),c}}const WEBGL_CONSTANTS={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},WEBGL_COMPONENT_TYPES={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},WEBGL_FILTERS={9728:NearestFilter,9729:LinearFilter,9984:NearestMipmapNearestFilter,9985:LinearMipmapNearestFilter,9986:NearestMipmapLinearFilter,9987:LinearMipmapLinearFilter},WEBGL_WRAPPINGS={33071:ClampToEdgeWrapping,33648:MirroredRepeatWrapping,10497:RepeatWrapping},WEBGL_TYPE_SIZES={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ATTRIBUTES={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",...version$1>=152?{TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3"}:{TEXCOORD_0:"uv",TEXCOORD_1:"uv2"},COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},PATH_PROPERTIES={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},INTERPOLATION={CUBICSPLINE:void 0,LINEAR:InterpolateLinear,STEP:InterpolateDiscrete},ALPHA_MODES={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function createDefaultMaterial(a){return a.DefaultMaterial===void 0&&(a.DefaultMaterial=new MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:FrontSide})),a.DefaultMaterial}function addUnknownExtensionsToUserData(a,e,o){for(const s in o.extensions)a[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=o.extensions[s])}function assignExtrasToUserData(a,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(a.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function addMorphTargets(a,e,o){let s=!1,d=!1,c=!1;for(let g=0,j=e.length;g<j;g++){const b=e[g];if(b.POSITION!==void 0&&(s=!0),b.NORMAL!==void 0&&(d=!0),b.COLOR_0!==void 0&&(c=!0),s&&d&&c)break}if(!s&&!d&&!c)return Promise.resolve(a);const h=[],_=[],bt=[];for(let g=0,j=e.length;g<j;g++){const b=e[g];if(s){const Et=b.POSITION!==void 0?o.getDependency("accessor",b.POSITION):a.attributes.position;h.push(Et)}if(d){const Et=b.NORMAL!==void 0?o.getDependency("accessor",b.NORMAL):a.attributes.normal;_.push(Et)}if(c){const Et=b.COLOR_0!==void 0?o.getDependency("accessor",b.COLOR_0):a.attributes.color;bt.push(Et)}}return Promise.all([Promise.all(h),Promise.all(_),Promise.all(bt)]).then(function(g){const j=g[0],b=g[1],Et=g[2];return s&&(a.morphAttributes.position=j),d&&(a.morphAttributes.normal=b),c&&(a.morphAttributes.color=Et),a.morphTargetsRelative=!0,a})}function updateMorphTargets(a,e){if(a.updateMorphTargets(),e.weights!==void 0)for(let o=0,s=e.weights.length;o<s;o++)a.morphTargetInfluences[o]=e.weights[o];if(e.extras&&Array.isArray(e.extras.targetNames)){const o=e.extras.targetNames;if(a.morphTargetInfluences.length===o.length){a.morphTargetDictionary={};for(let s=0,d=o.length;s<d;s++)a.morphTargetDictionary[o[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function createPrimitiveKey(a){let e;const o=a.extensions&&a.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];if(o?e="draco:"+o.bufferView+":"+o.indices+":"+createAttributesKey(o.attributes):e=a.indices+":"+createAttributesKey(a.attributes)+":"+a.mode,a.targets!==void 0)for(let s=0,d=a.targets.length;s<d;s++)e+=":"+createAttributesKey(a.targets[s]);return e}function createAttributesKey(a){let e="";const o=Object.keys(a).sort();for(let s=0,d=o.length;s<d;s++)e+=o[s]+":"+a[o[s]]+";";return e}function getNormalizedComponentScale(a){switch(a){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function getImageURIMimeType(a){return a.search(/\.jpe?g($|\?)/i)>0||a.search(/^data\:image\/jpeg/)===0?"image/jpeg":a.search(/\.webp($|\?)/i)>0||a.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const _identityMatrix=new Matrix4;class GLTFParser{constructor(e={},o={}){this.json=e,this.extensions={},this.plugins={},this.options=o,this.cache=new GLTFRegistry,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,d=!1,c=-1;typeof navigator<"u"&&typeof navigator.userAgent<"u"&&(s=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,d=navigator.userAgent.indexOf("Firefox")>-1,c=d?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||s||d&&c<98?this.textureLoader=new TextureLoader(this.options.manager):this.textureLoader=new ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,o){const s=this,d=this.json,c=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(h){return h._markDefs&&h._markDefs()}),Promise.all(this._invokeAll(function(h){return h.beforeRoot&&h.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(h){const _={scene:h[0][d.scene||0],scenes:h[0],animations:h[1],cameras:h[2],asset:d.asset,parser:s,userData:{}};addUnknownExtensionsToUserData(c,_,d),assignExtrasToUserData(_,d),Promise.all(s._invokeAll(function(bt){return bt.afterRoot&&bt.afterRoot(_)})).then(function(){e(_)})}).catch(o)}_markDefs(){const e=this.json.nodes||[],o=this.json.skins||[],s=this.json.meshes||[];for(let d=0,c=o.length;d<c;d++){const h=o[d].joints;for(let _=0,bt=h.length;_<bt;_++)e[h[_]].isBone=!0}for(let d=0,c=e.length;d<c;d++){const h=e[d];h.mesh!==void 0&&(this._addNodeRef(this.meshCache,h.mesh),h.skin!==void 0&&(s[h.mesh].isSkinnedMesh=!0)),h.camera!==void 0&&this._addNodeRef(this.cameraCache,h.camera)}}_addNodeRef(e,o){o!==void 0&&(e.refs[o]===void 0&&(e.refs[o]=e.uses[o]=0),e.refs[o]++)}_getNodeRef(e,o,s){if(e.refs[o]<=1)return s;const d=s.clone(),c=(h,_)=>{const bt=this.associations.get(h);bt!=null&&this.associations.set(_,bt);for(const[g,j]of h.children.entries())c(j,_.children[g])};return c(s,d),d.name+="_instance_"+e.uses[o]++,d}_invokeOne(e){const o=Object.values(this.plugins);o.push(this);for(let s=0;s<o.length;s++){const d=e(o[s]);if(d)return d}return null}_invokeAll(e){const o=Object.values(this.plugins);o.unshift(this);const s=[];for(let d=0;d<o.length;d++){const c=e(o[d]);c&&s.push(c)}return s}getDependency(e,o){const s=e+":"+o;let d=this.cache.get(s);if(!d){switch(e){case"scene":d=this.loadScene(o);break;case"node":d=this._invokeOne(function(c){return c.loadNode&&c.loadNode(o)});break;case"mesh":d=this._invokeOne(function(c){return c.loadMesh&&c.loadMesh(o)});break;case"accessor":d=this.loadAccessor(o);break;case"bufferView":d=this._invokeOne(function(c){return c.loadBufferView&&c.loadBufferView(o)});break;case"buffer":d=this.loadBuffer(o);break;case"material":d=this._invokeOne(function(c){return c.loadMaterial&&c.loadMaterial(o)});break;case"texture":d=this._invokeOne(function(c){return c.loadTexture&&c.loadTexture(o)});break;case"skin":d=this.loadSkin(o);break;case"animation":d=this._invokeOne(function(c){return c.loadAnimation&&c.loadAnimation(o)});break;case"camera":d=this.loadCamera(o);break;default:if(d=this._invokeOne(function(c){return c!=this&&c.getDependency&&c.getDependency(e,o)}),!d)throw new Error("Unknown type: "+e);break}this.cache.add(s,d)}return d}getDependencies(e){let o=this.cache.get(e);if(!o){const s=this,d=this.json[e+(e==="mesh"?"es":"s")]||[];o=Promise.all(d.map(function(c,h){return s.getDependency(e,h)})),this.cache.add(e,o)}return o}loadBuffer(e){const o=this.json.buffers[e],s=this.fileLoader;if(o.type&&o.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+o.type+" buffer type is not supported.");if(o.uri===void 0&&e===0)return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);const d=this.options;return new Promise(function(c,h){s.load(LoaderUtils.resolveURL(o.uri,d.path),c,void 0,function(){h(new Error('THREE.GLTFLoader: Failed to load buffer "'+o.uri+'".'))})})}loadBufferView(e){const o=this.json.bufferViews[e];return this.getDependency("buffer",o.buffer).then(function(s){const d=o.byteLength||0,c=o.byteOffset||0;return s.slice(c,c+d)})}loadAccessor(e){const o=this,s=this.json,d=this.json.accessors[e];if(d.bufferView===void 0&&d.sparse===void 0){const h=WEBGL_TYPE_SIZES[d.type],_=WEBGL_COMPONENT_TYPES[d.componentType],bt=d.normalized===!0,g=new _(d.count*h);return Promise.resolve(new BufferAttribute(g,h,bt))}const c=[];return d.bufferView!==void 0?c.push(this.getDependency("bufferView",d.bufferView)):c.push(null),d.sparse!==void 0&&(c.push(this.getDependency("bufferView",d.sparse.indices.bufferView)),c.push(this.getDependency("bufferView",d.sparse.values.bufferView))),Promise.all(c).then(function(h){const _=h[0],bt=WEBGL_TYPE_SIZES[d.type],g=WEBGL_COMPONENT_TYPES[d.componentType],j=g.BYTES_PER_ELEMENT,b=j*bt,Et=d.byteOffset||0,It=d.bufferView!==void 0?s.bufferViews[d.bufferView].byteStride:void 0,zt=d.normalized===!0;let er,Hn;if(It&&It!==b){const Qt=Math.floor(Et/It),cr="InterleavedBuffer:"+d.bufferView+":"+d.componentType+":"+Qt+":"+d.count;let fr=o.cache.get(cr);fr||(er=new g(_,Qt*It,d.count*It/j),fr=new InterleavedBuffer(er,It/j),o.cache.add(cr,fr)),Hn=new InterleavedBufferAttribute(fr,bt,Et%It/j,zt)}else _===null?er=new g(d.count*bt):er=new g(_,Et,d.count*bt),Hn=new BufferAttribute(er,bt,zt);if(d.sparse!==void 0){const Qt=WEBGL_TYPE_SIZES.SCALAR,cr=WEBGL_COMPONENT_TYPES[d.sparse.indices.componentType],fr=d.sparse.indices.byteOffset||0,jr=d.sparse.values.byteOffset||0,e0=new cr(h[1],fr,d.sparse.count*Qt),t0=new g(h[2],jr,d.sparse.count*bt);_!==null&&(Hn=new BufferAttribute(Hn.array.slice(),Hn.itemSize,Hn.normalized));for(let o0=0,l0=e0.length;o0<l0;o0++){const g0=e0[o0];if(Hn.setX(g0,t0[o0*bt]),bt>=2&&Hn.setY(g0,t0[o0*bt+1]),bt>=3&&Hn.setZ(g0,t0[o0*bt+2]),bt>=4&&Hn.setW(g0,t0[o0*bt+3]),bt>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return Hn})}loadTexture(e){const o=this.json,s=this.options,c=o.textures[e].source,h=o.images[c];let _=this.textureLoader;if(h.uri){const bt=s.manager.getHandler(h.uri);bt!==null&&(_=bt)}return this.loadTextureImage(e,c,_)}loadTextureImage(e,o,s){const d=this,c=this.json,h=c.textures[e],_=c.images[o],bt=(_.uri||_.bufferView)+":"+h.sampler;if(this.textureCache[bt])return this.textureCache[bt];const g=this.loadImageSource(o,s).then(function(j){j.flipY=!1,j.name=h.name||_.name||"",j.name===""&&typeof _.uri=="string"&&_.uri.startsWith("data:image/")===!1&&(j.name=_.uri);const Et=(c.samplers||{})[h.sampler]||{};return j.magFilter=WEBGL_FILTERS[Et.magFilter]||LinearFilter,j.minFilter=WEBGL_FILTERS[Et.minFilter]||LinearMipmapLinearFilter,j.wrapS=WEBGL_WRAPPINGS[Et.wrapS]||RepeatWrapping,j.wrapT=WEBGL_WRAPPINGS[Et.wrapT]||RepeatWrapping,d.associations.set(j,{textures:e}),j}).catch(function(){return null});return this.textureCache[bt]=g,g}loadImageSource(e,o){const s=this,d=this.json,c=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(b=>b.clone());const h=d.images[e],_=self.URL||self.webkitURL;let bt=h.uri||"",g=!1;if(h.bufferView!==void 0)bt=s.getDependency("bufferView",h.bufferView).then(function(b){g=!0;const Et=new Blob([b],{type:h.mimeType});return bt=_.createObjectURL(Et),bt});else if(h.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const j=Promise.resolve(bt).then(function(b){return new Promise(function(Et,It){let zt=Et;o.isImageBitmapLoader===!0&&(zt=function(er){const Hn=new Texture(er);Hn.needsUpdate=!0,Et(Hn)}),o.load(LoaderUtils.resolveURL(b,c.path),zt,void 0,It)})}).then(function(b){return g===!0&&_.revokeObjectURL(bt),b.userData.mimeType=h.mimeType||getImageURIMimeType(h.uri),b}).catch(function(b){throw console.error("THREE.GLTFLoader: Couldn't load texture",bt),b});return this.sourceCache[e]=j,j}assignTexture(e,o,s,d){const c=this;return this.getDependency("texture",s.index).then(function(h){if(!h)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(h=h.clone(),h.channel=s.texCoord),c.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]){const _=s.extensions!==void 0?s.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]:void 0;if(_){const bt=c.associations.get(h);h=c.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(h,_),c.associations.set(h,bt)}}return d!==void 0&&("colorSpace"in h?h.colorSpace=d===3001?"srgb":"srgb-linear":h.encoding=d),e[o]=h,h})}assignFinalMaterial(e){const o=e.geometry;let s=e.material;const d=o.attributes.tangent===void 0,c=o.attributes.color!==void 0,h=o.attributes.normal===void 0;if(e.isPoints){const _="PointsMaterial:"+s.uuid;let bt=this.cache.get(_);bt||(bt=new PointsMaterial,Material.prototype.copy.call(bt,s),bt.color.copy(s.color),bt.map=s.map,bt.sizeAttenuation=!1,this.cache.add(_,bt)),s=bt}else if(e.isLine){const _="LineBasicMaterial:"+s.uuid;let bt=this.cache.get(_);bt||(bt=new LineBasicMaterial,Material.prototype.copy.call(bt,s),bt.color.copy(s.color),bt.map=s.map,this.cache.add(_,bt)),s=bt}if(d||c||h){let _="ClonedMaterial:"+s.uuid+":";d&&(_+="derivative-tangents:"),c&&(_+="vertex-colors:"),h&&(_+="flat-shading:");let bt=this.cache.get(_);bt||(bt=s.clone(),c&&(bt.vertexColors=!0),h&&(bt.flatShading=!0),d&&(bt.normalScale&&(bt.normalScale.y*=-1),bt.clearcoatNormalScale&&(bt.clearcoatNormalScale.y*=-1)),this.cache.add(_,bt),this.associations.set(bt,this.associations.get(s))),s=bt}e.material=s}getMaterialType(){return MeshStandardMaterial}loadMaterial(e){const o=this,s=this.json,d=this.extensions,c=s.materials[e];let h;const _={},bt=c.extensions||{},g=[];if(bt[EXTENSIONS.KHR_MATERIALS_UNLIT]){const b=d[EXTENSIONS.KHR_MATERIALS_UNLIT];h=b.getMaterialType(),g.push(b.extendParams(_,c,o))}else{const b=c.pbrMetallicRoughness||{};if(_.color=new Color(1,1,1),_.opacity=1,Array.isArray(b.baseColorFactor)){const Et=b.baseColorFactor;_.color.fromArray(Et),_.opacity=Et[3]}b.baseColorTexture!==void 0&&g.push(o.assignTexture(_,"map",b.baseColorTexture,3001)),_.metalness=b.metallicFactor!==void 0?b.metallicFactor:1,_.roughness=b.roughnessFactor!==void 0?b.roughnessFactor:1,b.metallicRoughnessTexture!==void 0&&(g.push(o.assignTexture(_,"metalnessMap",b.metallicRoughnessTexture)),g.push(o.assignTexture(_,"roughnessMap",b.metallicRoughnessTexture))),h=this._invokeOne(function(Et){return Et.getMaterialType&&Et.getMaterialType(e)}),g.push(Promise.all(this._invokeAll(function(Et){return Et.extendMaterialParams&&Et.extendMaterialParams(e,_)})))}c.doubleSided===!0&&(_.side=DoubleSide);const j=c.alphaMode||ALPHA_MODES.OPAQUE;if(j===ALPHA_MODES.BLEND?(_.transparent=!0,_.depthWrite=!1):(_.transparent=!1,j===ALPHA_MODES.MASK&&(_.alphaTest=c.alphaCutoff!==void 0?c.alphaCutoff:.5)),c.normalTexture!==void 0&&h!==MeshBasicMaterial&&(g.push(o.assignTexture(_,"normalMap",c.normalTexture)),_.normalScale=new Vector2(1,1),c.normalTexture.scale!==void 0)){const b=c.normalTexture.scale;_.normalScale.set(b,b)}return c.occlusionTexture!==void 0&&h!==MeshBasicMaterial&&(g.push(o.assignTexture(_,"aoMap",c.occlusionTexture)),c.occlusionTexture.strength!==void 0&&(_.aoMapIntensity=c.occlusionTexture.strength)),c.emissiveFactor!==void 0&&h!==MeshBasicMaterial&&(_.emissive=new Color().fromArray(c.emissiveFactor)),c.emissiveTexture!==void 0&&h!==MeshBasicMaterial&&g.push(o.assignTexture(_,"emissiveMap",c.emissiveTexture,3001)),Promise.all(g).then(function(){const b=new h(_);return c.name&&(b.name=c.name),assignExtrasToUserData(b,c),o.associations.set(b,{materials:e}),c.extensions&&addUnknownExtensionsToUserData(d,b,c),b})}createUniqueName(e){const o=PropertyBinding.sanitizeNodeName(e||"");return o in this.nodeNamesUsed?o+"_"+ ++this.nodeNamesUsed[o]:(this.nodeNamesUsed[o]=0,o)}loadGeometries(e){const o=this,s=this.extensions,d=this.primitiveCache;function c(_){return s[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(_,o).then(function(bt){return addPrimitiveAttributes(bt,_,o)})}const h=[];for(let _=0,bt=e.length;_<bt;_++){const g=e[_],j=createPrimitiveKey(g),b=d[j];if(b)h.push(b.promise);else{let Et;g.extensions&&g.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]?Et=c(g):Et=addPrimitiveAttributes(new BufferGeometry,g,o),d[j]={primitive:g,promise:Et},h.push(Et)}}return Promise.all(h)}loadMesh(e){const o=this,s=this.json,d=this.extensions,c=s.meshes[e],h=c.primitives,_=[];for(let bt=0,g=h.length;bt<g;bt++){const j=h[bt].material===void 0?createDefaultMaterial(this.cache):this.getDependency("material",h[bt].material);_.push(j)}return _.push(o.loadGeometries(h)),Promise.all(_).then(function(bt){const g=bt.slice(0,bt.length-1),j=bt[bt.length-1],b=[];for(let It=0,zt=j.length;It<zt;It++){const er=j[It],Hn=h[It];let Qt;const cr=g[It];if(Hn.mode===WEBGL_CONSTANTS.TRIANGLES||Hn.mode===WEBGL_CONSTANTS.TRIANGLE_STRIP||Hn.mode===WEBGL_CONSTANTS.TRIANGLE_FAN||Hn.mode===void 0)Qt=c.isSkinnedMesh===!0?new SkinnedMesh(er,cr):new Mesh(er,cr),Qt.isSkinnedMesh===!0&&Qt.normalizeSkinWeights(),Hn.mode===WEBGL_CONSTANTS.TRIANGLE_STRIP?Qt.geometry=toTrianglesDrawMode(Qt.geometry,TriangleStripDrawMode):Hn.mode===WEBGL_CONSTANTS.TRIANGLE_FAN&&(Qt.geometry=toTrianglesDrawMode(Qt.geometry,TriangleFanDrawMode));else if(Hn.mode===WEBGL_CONSTANTS.LINES)Qt=new LineSegments(er,cr);else if(Hn.mode===WEBGL_CONSTANTS.LINE_STRIP)Qt=new Line(er,cr);else if(Hn.mode===WEBGL_CONSTANTS.LINE_LOOP)Qt=new LineLoop(er,cr);else if(Hn.mode===WEBGL_CONSTANTS.POINTS)Qt=new Points(er,cr);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+Hn.mode);Object.keys(Qt.geometry.morphAttributes).length>0&&updateMorphTargets(Qt,c),Qt.name=o.createUniqueName(c.name||"mesh_"+e),assignExtrasToUserData(Qt,c),Hn.extensions&&addUnknownExtensionsToUserData(d,Qt,Hn),o.assignFinalMaterial(Qt),b.push(Qt)}for(let It=0,zt=b.length;It<zt;It++)o.associations.set(b[It],{meshes:e,primitives:It});if(b.length===1)return c.extensions&&addUnknownExtensionsToUserData(d,b[0],c),b[0];const Et=new Group;c.extensions&&addUnknownExtensionsToUserData(d,Et,c),o.associations.set(Et,{meshes:e});for(let It=0,zt=b.length;It<zt;It++)Et.add(b[It]);return Et})}loadCamera(e){let o;const s=this.json.cameras[e],d=s[s.type];if(!d){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?o=new PerspectiveCamera(MathUtils.radToDeg(d.yfov),d.aspectRatio||1,d.znear||1,d.zfar||2e6):s.type==="orthographic"&&(o=new OrthographicCamera(-d.xmag,d.xmag,d.ymag,-d.ymag,d.znear,d.zfar)),s.name&&(o.name=this.createUniqueName(s.name)),assignExtrasToUserData(o,s),Promise.resolve(o)}loadSkin(e){const o=this.json.skins[e],s=[];for(let d=0,c=o.joints.length;d<c;d++)s.push(this._loadNodeShallow(o.joints[d]));return o.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",o.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(d){const c=d.pop(),h=d,_=[],bt=[];for(let g=0,j=h.length;g<j;g++){const b=h[g];if(b){_.push(b);const Et=new Matrix4;c!==null&&Et.fromArray(c.array,g*16),bt.push(Et)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',o.joints[g])}return new Skeleton(_,bt)})}loadAnimation(e){const s=this.json.animations[e],d=s.name?s.name:"animation_"+e,c=[],h=[],_=[],bt=[],g=[];for(let j=0,b=s.channels.length;j<b;j++){const Et=s.channels[j],It=s.samplers[Et.sampler],zt=Et.target,er=zt.node,Hn=s.parameters!==void 0?s.parameters[It.input]:It.input,Qt=s.parameters!==void 0?s.parameters[It.output]:It.output;zt.node!==void 0&&(c.push(this.getDependency("node",er)),h.push(this.getDependency("accessor",Hn)),_.push(this.getDependency("accessor",Qt)),bt.push(It),g.push(zt))}return Promise.all([Promise.all(c),Promise.all(h),Promise.all(_),Promise.all(bt),Promise.all(g)]).then(function(j){const b=j[0],Et=j[1],It=j[2],zt=j[3],er=j[4],Hn=[];for(let Qt=0,cr=b.length;Qt<cr;Qt++){const fr=b[Qt],jr=Et[Qt],e0=It[Qt],t0=zt[Qt],o0=er[Qt];if(fr===void 0)continue;fr.updateMatrix();let l0;switch(PATH_PROPERTIES[o0.path]){case PATH_PROPERTIES.weights:l0=NumberKeyframeTrack;break;case PATH_PROPERTIES.rotation:l0=QuaternionKeyframeTrack;break;case PATH_PROPERTIES.position:case PATH_PROPERTIES.scale:default:l0=VectorKeyframeTrack;break}const g0=fr.name?fr.name:fr.uuid,i0=t0.interpolation!==void 0?INTERPOLATION[t0.interpolation]:InterpolateLinear,f0=[];PATH_PROPERTIES[o0.path]===PATH_PROPERTIES.weights?fr.traverse(function(Z0){Z0.morphTargetInfluences&&f0.push(Z0.name?Z0.name:Z0.uuid)}):f0.push(g0);let C0=e0.array;if(e0.normalized){const Z0=getNormalizedComponentScale(C0.constructor),R0=new Float32Array(C0.length);for(let Y0=0,H0=C0.length;Y0<H0;Y0++)R0[Y0]=C0[Y0]*Z0;C0=R0}for(let Z0=0,R0=f0.length;Z0<R0;Z0++){const Y0=new l0(f0[Z0]+"."+PATH_PROPERTIES[o0.path],jr.array,C0,i0);t0.interpolation==="CUBICSPLINE"&&(Y0.createInterpolant=function(ty){const w0=this instanceof QuaternionKeyframeTrack?GLTFCubicSplineQuaternionInterpolant:GLTFCubicSplineInterpolant;return new w0(this.times,this.values,this.getValueSize()/3,ty)},Y0.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),Hn.push(Y0)}}return new AnimationClip(d,void 0,Hn)})}createNodeMesh(e){const o=this.json,s=this,d=o.nodes[e];return d.mesh===void 0?null:s.getDependency("mesh",d.mesh).then(function(c){const h=s._getNodeRef(s.meshCache,d.mesh,c);return d.weights!==void 0&&h.traverse(function(_){if(_.isMesh)for(let bt=0,g=d.weights.length;bt<g;bt++)_.morphTargetInfluences[bt]=d.weights[bt]}),h})}loadNode(e){const o=this.json,s=this,d=o.nodes[e],c=s._loadNodeShallow(e),h=[],_=d.children||[];for(let g=0,j=_.length;g<j;g++)h.push(s.getDependency("node",_[g]));const bt=d.skin===void 0?Promise.resolve(null):s.getDependency("skin",d.skin);return Promise.all([c,Promise.all(h),bt]).then(function(g){const j=g[0],b=g[1],Et=g[2];Et!==null&&j.traverse(function(It){It.isSkinnedMesh&&It.bind(Et,_identityMatrix)});for(let It=0,zt=b.length;It<zt;It++)j.add(b[It]);return j})}_loadNodeShallow(e){const o=this.json,s=this.extensions,d=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const c=o.nodes[e],h=c.name?d.createUniqueName(c.name):"",_=[],bt=d._invokeOne(function(g){return g.createNodeMesh&&g.createNodeMesh(e)});return bt&&_.push(bt),c.camera!==void 0&&_.push(d.getDependency("camera",c.camera).then(function(g){return d._getNodeRef(d.cameraCache,c.camera,g)})),d._invokeAll(function(g){return g.createNodeAttachment&&g.createNodeAttachment(e)}).forEach(function(g){_.push(g)}),this.nodeCache[e]=Promise.all(_).then(function(g){let j;if(c.isBone===!0?j=new Bone:g.length>1?j=new Group:g.length===1?j=g[0]:j=new Object3D,j!==g[0])for(let b=0,Et=g.length;b<Et;b++)j.add(g[b]);if(c.name&&(j.userData.name=c.name,j.name=h),assignExtrasToUserData(j,c),c.extensions&&addUnknownExtensionsToUserData(s,j,c),c.matrix!==void 0){const b=new Matrix4;b.fromArray(c.matrix),j.applyMatrix4(b)}else c.translation!==void 0&&j.position.fromArray(c.translation),c.rotation!==void 0&&j.quaternion.fromArray(c.rotation),c.scale!==void 0&&j.scale.fromArray(c.scale);return d.associations.has(j)||d.associations.set(j,{}),d.associations.get(j).nodes=e,j}),this.nodeCache[e]}loadScene(e){const o=this.extensions,s=this.json.scenes[e],d=this,c=new Group;s.name&&(c.name=d.createUniqueName(s.name)),assignExtrasToUserData(c,s),s.extensions&&addUnknownExtensionsToUserData(o,c,s);const h=s.nodes||[],_=[];for(let bt=0,g=h.length;bt<g;bt++)_.push(d.getDependency("node",h[bt]));return Promise.all(_).then(function(bt){for(let j=0,b=bt.length;j<b;j++)c.add(bt[j]);const g=j=>{const b=new Map;for(const[Et,It]of d.associations)(Et instanceof Material||Et instanceof Texture)&&b.set(Et,It);return j.traverse(Et=>{const It=d.associations.get(Et);It!=null&&b.set(Et,It)}),b};return d.associations=g(c),c})}}function computeBounds(a,e,o){const s=e.attributes,d=new Box3;if(s.POSITION!==void 0){const _=o.json.accessors[s.POSITION],bt=_.min,g=_.max;if(bt!==void 0&&g!==void 0){if(d.set(new Vector3(bt[0],bt[1],bt[2]),new Vector3(g[0],g[1],g[2])),_.normalized){const j=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[_.componentType]);d.min.multiplyScalar(j),d.max.multiplyScalar(j)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const c=e.targets;if(c!==void 0){const _=new Vector3,bt=new Vector3;for(let g=0,j=c.length;g<j;g++){const b=c[g];if(b.POSITION!==void 0){const Et=o.json.accessors[b.POSITION],It=Et.min,zt=Et.max;if(It!==void 0&&zt!==void 0){if(bt.setX(Math.max(Math.abs(It[0]),Math.abs(zt[0]))),bt.setY(Math.max(Math.abs(It[1]),Math.abs(zt[1]))),bt.setZ(Math.max(Math.abs(It[2]),Math.abs(zt[2]))),Et.normalized){const er=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[Et.componentType]);bt.multiplyScalar(er)}_.max(bt)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}d.expandByVector(_)}a.boundingBox=d;const h=new Sphere;d.getCenter(h.center),h.radius=d.min.distanceTo(d.max)/2,a.boundingSphere=h}function addPrimitiveAttributes(a,e,o){const s=e.attributes,d=[];function c(h,_){return o.getDependency("accessor",h).then(function(bt){a.setAttribute(_,bt)})}for(const h in s){const _=ATTRIBUTES[h]||h.toLowerCase();_ in a.attributes||d.push(c(s[h],_))}if(e.indices!==void 0&&!a.index){const h=o.getDependency("accessor",e.indices).then(function(_){a.setIndex(_)});d.push(h)}return assignExtrasToUserData(a,e),computeBounds(a,e,o),Promise.all(d).then(function(){return e.targets!==void 0?addMorphTargets(a,e.targets,o):a})}class RGBELoader extends DataTextureLoader{constructor(e){super(e),this.type=HalfFloatType}parse(e){const _=function(fr,jr){switch(fr){case 1:console.error("THREE.RGBELoader Read Error: "+(jr||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(jr||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(jr||""));break;default:case 4:console.error("THREE.RGBELoader: Error: "+(jr||""))}return-1},b=`
`,Et=function(fr,jr,e0){jr=jr||1024;let o0=fr.pos,l0=-1,g0=0,i0="",f0=String.fromCharCode.apply(null,new Uint16Array(fr.subarray(o0,o0+128)));for(;0>(l0=f0.indexOf(b))&&g0<jr&&o0<fr.byteLength;)i0+=f0,g0+=f0.length,o0+=128,f0+=String.fromCharCode.apply(null,new Uint16Array(fr.subarray(o0,o0+128)));return-1<l0?(e0!==!1&&(fr.pos+=g0+l0+1),i0+f0.slice(0,l0)):!1},It=function(fr){const jr=/^#\?(\S+)/,e0=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,t0=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,o0=/^\s*FORMAT=(\S+)\s*$/,l0=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,g0={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let i0,f0;if(fr.pos>=fr.byteLength||!(i0=Et(fr)))return _(1,"no header found");if(!(f0=i0.match(jr)))return _(3,"bad initial token");for(g0.valid|=1,g0.programtype=f0[1],g0.string+=i0+`
`;i0=Et(fr),i0!==!1;){if(g0.string+=i0+`
`,i0.charAt(0)==="#"){g0.comments+=i0+`
`;continue}if((f0=i0.match(e0))&&(g0.gamma=parseFloat(f0[1])),(f0=i0.match(t0))&&(g0.exposure=parseFloat(f0[1])),(f0=i0.match(o0))&&(g0.valid|=2,g0.format=f0[1]),(f0=i0.match(l0))&&(g0.valid|=4,g0.height=parseInt(f0[1],10),g0.width=parseInt(f0[2],10)),g0.valid&2&&g0.valid&4)break}return g0.valid&2?g0.valid&4?g0:_(3,"missing image size specifier"):_(3,"missing format specifier")},zt=function(fr,jr,e0){const t0=jr;if(t0<8||t0>32767||fr[0]!==2||fr[1]!==2||fr[2]&128)return new Uint8Array(fr);if(t0!==(fr[2]<<8|fr[3]))return _(3,"wrong scanline width");const o0=new Uint8Array(4*jr*e0);if(!o0.length)return _(4,"unable to allocate buffer space");let l0=0,g0=0;const i0=4*t0,f0=new Uint8Array(4),C0=new Uint8Array(i0);let Z0=e0;for(;Z0>0&&g0<fr.byteLength;){if(g0+4>fr.byteLength)return _(1);if(f0[0]=fr[g0++],f0[1]=fr[g0++],f0[2]=fr[g0++],f0[3]=fr[g0++],f0[0]!=2||f0[1]!=2||(f0[2]<<8|f0[3])!=t0)return _(3,"bad rgbe scanline format");let R0=0,Y0;for(;R0<i0&&g0<fr.byteLength;){Y0=fr[g0++];const ty=Y0>128;if(ty&&(Y0-=128),Y0===0||R0+Y0>i0)return _(3,"bad scanline data");if(ty){const w0=fr[g0++];for(let L0=0;L0<Y0;L0++)C0[R0++]=w0}else C0.set(fr.subarray(g0,g0+Y0),R0),R0+=Y0,g0+=Y0}const H0=t0;for(let ty=0;ty<H0;ty++){let w0=0;o0[l0]=C0[ty+w0],w0+=t0,o0[l0+1]=C0[ty+w0],w0+=t0,o0[l0+2]=C0[ty+w0],w0+=t0,o0[l0+3]=C0[ty+w0],l0+=4}Z0--}return o0},er=function(fr,jr,e0,t0){const o0=fr[jr+3],l0=Math.pow(2,o0-128)/255;e0[t0+0]=fr[jr+0]*l0,e0[t0+1]=fr[jr+1]*l0,e0[t0+2]=fr[jr+2]*l0,e0[t0+3]=1},Hn=function(fr,jr,e0,t0){const o0=fr[jr+3],l0=Math.pow(2,o0-128)/255;e0[t0+0]=DataUtils.toHalfFloat(Math.min(fr[jr+0]*l0,65504)),e0[t0+1]=DataUtils.toHalfFloat(Math.min(fr[jr+1]*l0,65504)),e0[t0+2]=DataUtils.toHalfFloat(Math.min(fr[jr+2]*l0,65504)),e0[t0+3]=DataUtils.toHalfFloat(1)},Qt=new Uint8Array(e);Qt.pos=0;const cr=It(Qt);if(cr!==-1){const fr=cr.width,jr=cr.height,e0=zt(Qt.subarray(Qt.pos),fr,jr);if(e0!==-1){let t0,o0,l0;switch(this.type){case FloatType:l0=e0.length/4;const g0=new Float32Array(l0*4);for(let f0=0;f0<l0;f0++)er(e0,f0*4,g0,f0*4);t0=g0,o0=FloatType;break;case HalfFloatType:l0=e0.length/4;const i0=new Uint16Array(l0*4);for(let f0=0;f0<l0;f0++)Hn(e0,f0*4,i0,f0*4);t0=i0,o0=HalfFloatType;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type);break}return{width:fr,height:jr,data:t0,header:cr.string,gamma:cr.gamma,exposure:cr.exposure,type:o0}}}return null}setDataType(e){return this.type=e,this}load(e,o,s,d){function c(h,_){switch(h.type){case FloatType:case HalfFloatType:"colorSpace"in h?h.colorSpace="srgb-linear":h.encoding=3e3,h.minFilter=LinearFilter,h.magFilter=LinearFilter,h.generateMipmaps=!1,h.flipY=!0;break}o&&o(h,_)}return super.load(e,c,s,d)}}const hasColorSpace="colorSpace"in new Texture;class EXRLoader extends DataTextureLoader{constructor(e){super(e),this.type=HalfFloatType}parse(e){const g0=Math.pow(2.7182818,2.2);function i0(m0,E0){for(var j0=0,h0=0;h0<65536;++h0)(h0==0||m0[h0>>3]&1<<(h0&7))&&(E0[j0++]=h0);for(var $0=j0-1;j0<65536;)E0[j0++]=0;return $0}function f0(m0){for(var E0=0;E0<16384;E0++)m0[E0]={},m0[E0].len=0,m0[E0].lit=0,m0[E0].p=null}const C0={l:0,c:0,lc:0};function Z0(m0,E0,j0,h0,$0){for(;j0<m0;)E0=E0<<8|cv(h0,$0),j0+=8;j0-=m0,C0.l=E0>>j0&(1<<m0)-1,C0.c=E0,C0.lc=j0}const R0=new Array(59);function Y0(m0){for(var E0=0;E0<=58;++E0)R0[E0]=0;for(var E0=0;E0<65537;++E0)R0[m0[E0]]+=1;for(var j0=0,E0=58;E0>0;--E0){var h0=j0+R0[E0]>>1;R0[E0]=j0,j0=h0}for(var E0=0;E0<65537;++E0){var $0=m0[E0];$0>0&&(m0[E0]=$0|R0[$0]++<<6)}}function H0(m0,E0,j0,h0,$0,P0,Yr){for(var r0=j0,p0=0,_0=0;$0<=P0;$0++){if(r0.value-j0.value>h0)return!1;Z0(6,p0,_0,m0,r0);var D0=C0.l;if(p0=C0.c,_0=C0.lc,Yr[$0]=D0,D0==63){if(r0.value-j0.value>h0)throw"Something wrong with hufUnpackEncTable";Z0(8,p0,_0,m0,r0);var V0=C0.l+6;if(p0=C0.c,_0=C0.lc,$0+V0>P0+1)throw"Something wrong with hufUnpackEncTable";for(;V0--;)Yr[$0++]=0;$0--}else if(D0>=59){var V0=D0-59+2;if($0+V0>P0+1)throw"Something wrong with hufUnpackEncTable";for(;V0--;)Yr[$0++]=0;$0--}}Y0(Yr)}function ty(m0){return m0&63}function w0(m0){return m0>>6}function L0(m0,E0,j0,h0){for(;E0<=j0;E0++){var $0=w0(m0[E0]),P0=ty(m0[E0]);if($0>>P0)throw"Invalid table entry";if(P0>14){var Yr=h0[$0>>P0-14];if(Yr.len)throw"Invalid table entry";if(Yr.lit++,Yr.p){var r0=Yr.p;Yr.p=new Array(Yr.lit);for(var p0=0;p0<Yr.lit-1;++p0)Yr.p[p0]=r0[p0]}else Yr.p=new Array(1);Yr.p[Yr.lit-1]=E0}else if(P0)for(var _0=0,p0=1<<14-P0;p0>0;p0--){var Yr=h0[($0<<14-P0)+_0];if(Yr.len||Yr.p)throw"Invalid table entry";Yr.len=P0,Yr.lit=E0,_0++}}return!0}const k0={c:0,lc:0};function T0(m0,E0,j0,h0){m0=m0<<8|cv(j0,h0),E0+=8,k0.c=m0,k0.lc=E0}const q0={c:0,lc:0};function vy(m0,E0,j0,h0,$0,P0,Yr,r0,p0,_0){if(m0==E0){h0<8&&(T0(j0,h0,$0,Yr),j0=k0.c,h0=k0.lc),h0-=8;var D0=j0>>h0,D0=new Uint8Array([D0])[0];if(p0.value+D0>_0)return!1;for(var V0=r0[p0.value-1];D0-- >0;)r0[p0.value++]=V0}else if(p0.value<_0)r0[p0.value++]=m0;else return!1;q0.c=j0,q0.lc=h0}function J0(m0){return m0&65535}function cy(m0){var E0=J0(m0);return E0>32767?E0-65536:E0}const Ty={a:0,b:0};function Uy(m0,E0){var j0=cy(m0),h0=cy(E0),$0=h0,P0=j0+($0&1)+($0>>1),Yr=P0,r0=P0-$0;Ty.a=Yr,Ty.b=r0}function Qy(m0,E0){var j0=J0(m0),h0=J0(E0),$0=j0-(h0>>1)&65535,P0=h0+$0-32768&65535;Ty.a=P0,Ty.b=$0}function Zy(m0,E0,j0,h0,$0,P0,Yr){for(var r0=Yr<16384,p0=j0>$0?$0:j0,_0=1,D0;_0<=p0;)_0<<=1;for(_0>>=1,D0=_0,_0>>=1;_0>=1;){for(var V0=0,yy=V0+P0*($0-D0),ly=P0*_0,gy=P0*D0,ky=h0*_0,jy=h0*D0,rv,dv,K0,Cy;V0<=yy;V0+=gy){for(var lv=V0,vv=V0+h0*(j0-D0);lv<=vv;lv+=jy){var Mv=lv+ky,f_=lv+ly,b_=f_+ky;r0?(Uy(m0[lv+E0],m0[f_+E0]),rv=Ty.a,K0=Ty.b,Uy(m0[Mv+E0],m0[b_+E0]),dv=Ty.a,Cy=Ty.b,Uy(rv,dv),m0[lv+E0]=Ty.a,m0[Mv+E0]=Ty.b,Uy(K0,Cy),m0[f_+E0]=Ty.a,m0[b_+E0]=Ty.b):(Qy(m0[lv+E0],m0[f_+E0]),rv=Ty.a,K0=Ty.b,Qy(m0[Mv+E0],m0[b_+E0]),dv=Ty.a,Cy=Ty.b,Qy(rv,dv),m0[lv+E0]=Ty.a,m0[Mv+E0]=Ty.b,Qy(K0,Cy),m0[f_+E0]=Ty.a,m0[b_+E0]=Ty.b)}if(j0&_0){var f_=lv+ly;r0?Uy(m0[lv+E0],m0[f_+E0]):Qy(m0[lv+E0],m0[f_+E0]),rv=Ty.a,m0[f_+E0]=Ty.b,m0[lv+E0]=rv}}if($0&_0)for(var lv=V0,vv=V0+h0*(j0-D0);lv<=vv;lv+=jy){var Mv=lv+ky;r0?Uy(m0[lv+E0],m0[Mv+E0]):Qy(m0[lv+E0],m0[Mv+E0]),rv=Ty.a,m0[Mv+E0]=Ty.b,m0[lv+E0]=rv}D0=_0,_0>>=1}return V0}function iv(m0,E0,j0,h0,$0,P0,Yr,r0,p0,_0){for(var D0=0,V0=0,yy=r0,ly=Math.trunc($0.value+(P0+7)/8);$0.value<ly;)for(T0(D0,V0,j0,$0),D0=k0.c,V0=k0.lc;V0>=14;){var gy=D0>>V0-14&16383,ky=E0[gy];if(ky.len)V0-=ky.len,vy(ky.lit,Yr,D0,V0,j0,h0,$0,p0,_0,yy),D0=q0.c,V0=q0.lc;else{if(!ky.p)throw"hufDecode issues";var jy;for(jy=0;jy<ky.lit;jy++){for(var rv=ty(m0[ky.p[jy]]);V0<rv&&$0.value<ly;)T0(D0,V0,j0,$0),D0=k0.c,V0=k0.lc;if(V0>=rv&&w0(m0[ky.p[jy]])==(D0>>V0-rv&(1<<rv)-1)){V0-=rv,vy(ky.p[jy],Yr,D0,V0,j0,h0,$0,p0,_0,yy),D0=q0.c,V0=q0.lc;break}}if(jy==ky.lit)throw"hufDecode issues"}}var dv=8-P0&7;for(D0>>=dv,V0-=dv;V0>0;){var ky=E0[D0<<14-V0&16383];if(ky.len)V0-=ky.len,vy(ky.lit,Yr,D0,V0,j0,h0,$0,p0,_0,yy),D0=q0.c,V0=q0.lc;else throw"hufDecode issues"}return!0}function zy(m0,E0,j0,h0,$0,P0){var Yr={value:0},r0=j0.value,p0=mv(E0,j0),_0=mv(E0,j0);j0.value+=4;var D0=mv(E0,j0);if(j0.value+=4,p0<0||p0>=65537||_0<0||_0>=65537)throw"Something wrong with HUF_ENCSIZE";var V0=new Array(65537),yy=new Array(16384);f0(yy);var ly=h0-(j0.value-r0);if(H0(m0,E0,j0,ly,p0,_0,V0),D0>8*(h0-(j0.value-r0)))throw"Something wrong with hufUncompress";L0(V0,p0,_0,yy),iv(V0,yy,m0,E0,j0,D0,_0,P0,$0,Yr)}function B0(m0,E0,j0){for(var h0=0;h0<j0;++h0)E0[h0]=m0[E0[h0]]}function Ay(m0){for(var E0=1;E0<m0.length;E0++){var j0=m0[E0-1]+m0[E0]-128;m0[E0]=j0}}function hy(m0,E0){for(var j0=0,h0=Math.floor((m0.length+1)/2),$0=0,P0=m0.length-1;!($0>P0||(E0[$0++]=m0[j0++],$0>P0));)E0[$0++]=m0[h0++]}function Ly(m0){for(var E0=m0.byteLength,j0=new Array,h0=0,$0=new DataView(m0);E0>0;){var P0=$0.getInt8(h0++);if(P0<0){var Yr=-P0;E0-=Yr+1;for(var r0=0;r0<Yr;r0++)j0.push($0.getUint8(h0++))}else{var Yr=P0;E0-=2;for(var p0=$0.getUint8(h0++),r0=0;r0<Yr+1;r0++)j0.push(p0)}}return j0}function Iy(m0,E0,j0,h0,$0,P0){var Mv=new DataView(P0.buffer),Yr=j0[m0.idx[0]].width,r0=j0[m0.idx[0]].height,p0=3,_0=Math.floor(Yr/8),D0=Math.ceil(Yr/8),V0=Math.ceil(r0/8),yy=Yr-(D0-1)*8,ly=r0-(V0-1)*8,gy={value:0},ky=new Array(p0),jy=new Array(p0),rv=new Array(p0),dv=new Array(p0),K0=new Array(p0);for(let Yy=0;Yy<p0;++Yy)K0[Yy]=E0[m0.idx[Yy]],ky[Yy]=Yy<1?0:ky[Yy-1]+D0*V0,jy[Yy]=new Float32Array(64),rv[Yy]=new Uint16Array(64),dv[Yy]=new Uint16Array(D0*64);for(let Yy=0;Yy<V0;++Yy){var Cy=8;Yy==V0-1&&(Cy=ly);var lv=8;for(let Ov=0;Ov<D0;++Ov){Ov==D0-1&&(lv=yy);for(let Qv=0;Qv<p0;++Qv)rv[Qv].fill(0),rv[Qv][0]=$0[ky[Qv]++],Jy(gy,h0,rv[Qv]),Gy(rv[Qv],jy[Qv]),sv(jy[Qv]);yv(jy);for(let Qv=0;Qv<p0;++Qv)I0(jy[Qv],dv[Qv],Ov*64)}let w_=0;for(let Ov=0;Ov<p0;++Ov){const Qv=j0[m0.idx[Ov]].type;for(let s_=8*Yy;s_<8*Yy+Cy;++s_){w_=K0[Ov][s_];for(let S_=0;S_<_0;++S_){const B_=S_*64+(s_&7)*8;Mv.setUint16(w_+0*2*Qv,dv[Ov][B_+0],!0),Mv.setUint16(w_+1*2*Qv,dv[Ov][B_+1],!0),Mv.setUint16(w_+2*2*Qv,dv[Ov][B_+2],!0),Mv.setUint16(w_+3*2*Qv,dv[Ov][B_+3],!0),Mv.setUint16(w_+4*2*Qv,dv[Ov][B_+4],!0),Mv.setUint16(w_+5*2*Qv,dv[Ov][B_+5],!0),Mv.setUint16(w_+6*2*Qv,dv[Ov][B_+6],!0),Mv.setUint16(w_+7*2*Qv,dv[Ov][B_+7],!0),w_+=8*2*Qv}}if(_0!=D0)for(let s_=8*Yy;s_<8*Yy+Cy;++s_){const S_=K0[Ov][s_]+8*_0*2*Qv,B_=_0*64+(s_&7)*8;for(let z_=0;z_<lv;++z_)Mv.setUint16(S_+z_*2*Qv,dv[Ov][B_+z_],!0)}}}for(var vv=new Uint16Array(Yr),Mv=new DataView(P0.buffer),f_=0;f_<p0;++f_){j0[m0.idx[f_]].decoded=!0;var b_=j0[m0.idx[f_]].type;if(j0[f_].type==2)for(var x_=0;x_<r0;++x_){const Yy=K0[f_][x_];for(var o_=0;o_<Yr;++o_)vv[o_]=Mv.getUint16(Yy+o_*2*b_,!0);for(var o_=0;o_<Yr;++o_)Mv.setFloat32(Yy+o_*2*b_,d0(vv[o_]),!0)}}}function Jy(m0,E0,j0){for(var h0,$0=1;$0<64;)h0=E0[m0.value],h0==65280?$0=64:h0>>8==255?$0+=h0&255:(j0[$0]=h0,$0++),m0.value++}function Gy(m0,E0){E0[0]=d0(m0[0]),E0[1]=d0(m0[1]),E0[2]=d0(m0[5]),E0[3]=d0(m0[6]),E0[4]=d0(m0[14]),E0[5]=d0(m0[15]),E0[6]=d0(m0[27]),E0[7]=d0(m0[28]),E0[8]=d0(m0[2]),E0[9]=d0(m0[4]),E0[10]=d0(m0[7]),E0[11]=d0(m0[13]),E0[12]=d0(m0[16]),E0[13]=d0(m0[26]),E0[14]=d0(m0[29]),E0[15]=d0(m0[42]),E0[16]=d0(m0[3]),E0[17]=d0(m0[8]),E0[18]=d0(m0[12]),E0[19]=d0(m0[17]),E0[20]=d0(m0[25]),E0[21]=d0(m0[30]),E0[22]=d0(m0[41]),E0[23]=d0(m0[43]),E0[24]=d0(m0[9]),E0[25]=d0(m0[11]),E0[26]=d0(m0[18]),E0[27]=d0(m0[24]),E0[28]=d0(m0[31]),E0[29]=d0(m0[40]),E0[30]=d0(m0[44]),E0[31]=d0(m0[53]),E0[32]=d0(m0[10]),E0[33]=d0(m0[19]),E0[34]=d0(m0[23]),E0[35]=d0(m0[32]),E0[36]=d0(m0[39]),E0[37]=d0(m0[45]),E0[38]=d0(m0[52]),E0[39]=d0(m0[54]),E0[40]=d0(m0[20]),E0[41]=d0(m0[22]),E0[42]=d0(m0[33]),E0[43]=d0(m0[38]),E0[44]=d0(m0[46]),E0[45]=d0(m0[51]),E0[46]=d0(m0[55]),E0[47]=d0(m0[60]),E0[48]=d0(m0[21]),E0[49]=d0(m0[34]),E0[50]=d0(m0[37]),E0[51]=d0(m0[47]),E0[52]=d0(m0[50]),E0[53]=d0(m0[56]),E0[54]=d0(m0[59]),E0[55]=d0(m0[61]),E0[56]=d0(m0[35]),E0[57]=d0(m0[36]),E0[58]=d0(m0[48]),E0[59]=d0(m0[49]),E0[60]=d0(m0[57]),E0[61]=d0(m0[58]),E0[62]=d0(m0[62]),E0[63]=d0(m0[63])}function sv(m0){const E0=.5*Math.cos(.7853975),j0=.5*Math.cos(3.14159/16),h0=.5*Math.cos(3.14159/8),$0=.5*Math.cos(3*3.14159/16),P0=.5*Math.cos(5*3.14159/16),Yr=.5*Math.cos(3*3.14159/8),r0=.5*Math.cos(7*3.14159/16);for(var p0=new Array(4),_0=new Array(4),D0=new Array(4),V0=new Array(4),yy=0;yy<8;++yy){var ly=yy*8;p0[0]=h0*m0[ly+2],p0[1]=Yr*m0[ly+2],p0[2]=h0*m0[ly+6],p0[3]=Yr*m0[ly+6],_0[0]=j0*m0[ly+1]+$0*m0[ly+3]+P0*m0[ly+5]+r0*m0[ly+7],_0[1]=$0*m0[ly+1]-r0*m0[ly+3]-j0*m0[ly+5]-P0*m0[ly+7],_0[2]=P0*m0[ly+1]-j0*m0[ly+3]+r0*m0[ly+5]+$0*m0[ly+7],_0[3]=r0*m0[ly+1]-P0*m0[ly+3]+$0*m0[ly+5]-j0*m0[ly+7],D0[0]=E0*(m0[ly+0]+m0[ly+4]),D0[3]=E0*(m0[ly+0]-m0[ly+4]),D0[1]=p0[0]+p0[3],D0[2]=p0[1]-p0[2],V0[0]=D0[0]+D0[1],V0[1]=D0[3]+D0[2],V0[2]=D0[3]-D0[2],V0[3]=D0[0]-D0[1],m0[ly+0]=V0[0]+_0[0],m0[ly+1]=V0[1]+_0[1],m0[ly+2]=V0[2]+_0[2],m0[ly+3]=V0[3]+_0[3],m0[ly+4]=V0[3]-_0[3],m0[ly+5]=V0[2]-_0[2],m0[ly+6]=V0[1]-_0[1],m0[ly+7]=V0[0]-_0[0]}for(var gy=0;gy<8;++gy)p0[0]=h0*m0[16+gy],p0[1]=Yr*m0[16+gy],p0[2]=h0*m0[48+gy],p0[3]=Yr*m0[48+gy],_0[0]=j0*m0[8+gy]+$0*m0[24+gy]+P0*m0[40+gy]+r0*m0[56+gy],_0[1]=$0*m0[8+gy]-r0*m0[24+gy]-j0*m0[40+gy]-P0*m0[56+gy],_0[2]=P0*m0[8+gy]-j0*m0[24+gy]+r0*m0[40+gy]+$0*m0[56+gy],_0[3]=r0*m0[8+gy]-P0*m0[24+gy]+$0*m0[40+gy]-j0*m0[56+gy],D0[0]=E0*(m0[gy]+m0[32+gy]),D0[3]=E0*(m0[gy]-m0[32+gy]),D0[1]=p0[0]+p0[3],D0[2]=p0[1]-p0[2],V0[0]=D0[0]+D0[1],V0[1]=D0[3]+D0[2],V0[2]=D0[3]-D0[2],V0[3]=D0[0]-D0[1],m0[0+gy]=V0[0]+_0[0],m0[8+gy]=V0[1]+_0[1],m0[16+gy]=V0[2]+_0[2],m0[24+gy]=V0[3]+_0[3],m0[32+gy]=V0[3]-_0[3],m0[40+gy]=V0[2]-_0[2],m0[48+gy]=V0[1]-_0[1],m0[56+gy]=V0[0]-_0[0]}function yv(m0){for(var E0=0;E0<64;++E0){var j0=m0[0][E0],h0=m0[1][E0],$0=m0[2][E0];m0[0][E0]=j0+1.5747*$0,m0[1][E0]=j0-.1873*h0-.4682*$0,m0[2][E0]=j0+1.8556*h0}}function I0(m0,E0,j0){for(var h0=0;h0<64;++h0)E0[j0+h0]=DataUtils.toHalfFloat(b0(m0[h0]))}function b0(m0){return m0<=1?Math.sign(m0)*Math.pow(Math.abs(m0),2.2):Math.sign(m0)*Math.pow(g0,Math.abs(m0)-1)}function uy(m0){return new DataView(m0.array.buffer,m0.offset.value,m0.size)}function Ey(m0){var E0=m0.viewer.buffer.slice(m0.offset.value,m0.offset.value+m0.size),j0=new Uint8Array(Ly(E0)),h0=new Uint8Array(j0.length);return Ay(j0),hy(j0,h0),new DataView(h0.buffer)}function Dy(m0){var E0=m0.array.slice(m0.offset.value,m0.offset.value+m0.size),j0=unzlibSync(E0),h0=new Uint8Array(j0.length);return Ay(j0),hy(j0,h0),new DataView(h0.buffer)}function By(m0){for(var E0=m0.viewer,j0={value:m0.offset.value},h0=new Uint16Array(m0.width*m0.scanlineBlockSize*(m0.channels*m0.type)),$0=new Uint8Array(8192),P0=0,Yr=new Array(m0.channels),r0=0;r0<m0.channels;r0++)Yr[r0]={},Yr[r0].start=P0,Yr[r0].end=Yr[r0].start,Yr[r0].nx=m0.width,Yr[r0].ny=m0.lines,Yr[r0].size=m0.type,P0+=Yr[r0].nx*Yr[r0].ny*Yr[r0].size;var p0=v0(E0,j0),_0=v0(E0,j0);if(_0>=8192)throw"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";if(p0<=_0)for(var r0=0;r0<_0-p0+1;r0++)$0[r0+p0]=O0(E0,j0);var D0=new Uint16Array(65536),V0=i0($0,D0),yy=mv(E0,j0);zy(m0.array,E0,j0,yy,h0,P0);for(var r0=0;r0<m0.channels;++r0)for(var ly=Yr[r0],gy=0;gy<Yr[r0].size;++gy)Zy(h0,ly.start+gy,ly.nx,ly.size,ly.ny,ly.nx*ly.size,V0);B0(D0,h0,P0);for(var ky=0,jy=new Uint8Array(h0.buffer.byteLength),rv=0;rv<m0.lines;rv++)for(var dv=0;dv<m0.channels;dv++){var ly=Yr[dv],K0=ly.nx*ly.size,Cy=new Uint8Array(h0.buffer,ly.end*2,K0*2);jy.set(Cy,ky),ky+=K0*2,ly.end+=K0}return new DataView(jy.buffer)}function bv(m0){var E0=m0.array.slice(m0.offset.value,m0.offset.value+m0.size),j0=unzlibSync(E0);const h0=m0.lines*m0.channels*m0.width,$0=m0.type==1?new Uint16Array(h0):new Uint32Array(h0);let P0=0,Yr=0;const r0=new Array(4);for(let p0=0;p0<m0.lines;p0++)for(let _0=0;_0<m0.channels;_0++){let D0=0;switch(m0.type){case 1:r0[0]=P0,r0[1]=r0[0]+m0.width,P0=r0[1]+m0.width;for(let V0=0;V0<m0.width;++V0){const yy=j0[r0[0]++]<<8|j0[r0[1]++];D0+=yy,$0[Yr]=D0,Yr++}break;case 2:r0[0]=P0,r0[1]=r0[0]+m0.width,r0[2]=r0[1]+m0.width,P0=r0[2]+m0.width;for(let V0=0;V0<m0.width;++V0){const yy=j0[r0[0]++]<<24|j0[r0[1]++]<<16|j0[r0[2]++]<<8;D0+=yy,$0[Yr]=D0,Yr++}break}}return new DataView($0.buffer)}function av(m0){var E0=m0.viewer,j0={value:m0.offset.value},h0=new Uint8Array(m0.width*m0.lines*(m0.channels*m0.type*2)),$0={version:oy(E0,j0),unknownUncompressedSize:oy(E0,j0),unknownCompressedSize:oy(E0,j0),acCompressedSize:oy(E0,j0),dcCompressedSize:oy(E0,j0),rleCompressedSize:oy(E0,j0),rleUncompressedSize:oy(E0,j0),rleRawSize:oy(E0,j0),totalAcUncompressedCount:oy(E0,j0),totalDcUncompressedCount:oy(E0,j0),acCompression:oy(E0,j0)};if($0.version<2)throw"EXRLoader.parse: "+v_.compression+" version "+$0.version+" is unsupported";for(var P0=new Array,Yr=v0(E0,j0)-2;Yr>0;){var r0=Wy(E0.buffer,j0),p0=O0(E0,j0),_0=p0>>2&3,D0=(p0>>4)-1,V0=new Int8Array([D0])[0],yy=O0(E0,j0);P0.push({name:r0,index:V0,type:yy,compression:_0}),Yr-=r0.length+3}for(var ly=v_.channels,gy=new Array(m0.channels),ky=0;ky<m0.channels;++ky){var jy=gy[ky]={},rv=ly[ky];jy.name=rv.name,jy.compression=0,jy.decoded=!1,jy.type=rv.pixelType,jy.pLinear=rv.pLinear,jy.width=m0.width,jy.height=m0.lines}for(var dv={idx:new Array(3)},K0=0;K0<m0.channels;++K0)for(var jy=gy[K0],ky=0;ky<P0.length;++ky){var Cy=P0[ky];jy.name==Cy.name&&(jy.compression=Cy.compression,Cy.index>=0&&(dv.idx[Cy.index]=K0),jy.offset=K0)}if($0.acCompressedSize>0)switch($0.acCompression){case 0:var Mv=new Uint16Array($0.totalAcUncompressedCount);zy(m0.array,E0,j0,$0.acCompressedSize,Mv,$0.totalAcUncompressedCount);break;case 1:var lv=m0.array.slice(j0.value,j0.value+$0.totalAcUncompressedCount),vv=unzlibSync(lv),Mv=new Uint16Array(vv.buffer);j0.value+=$0.totalAcUncompressedCount;break}if($0.dcCompressedSize>0){var f_={array:m0.array,offset:j0,size:$0.dcCompressedSize},b_=new Uint16Array(Dy(f_).buffer);j0.value+=$0.dcCompressedSize}if($0.rleRawSize>0){var lv=m0.array.slice(j0.value,j0.value+$0.rleCompressedSize),vv=unzlibSync(lv),x_=Ly(vv.buffer);j0.value+=$0.rleCompressedSize}for(var o_=0,Yy=new Array(gy.length),ky=0;ky<Yy.length;++ky)Yy[ky]=new Array;for(var w_=0;w_<m0.lines;++w_)for(var Ov=0;Ov<gy.length;++Ov)Yy[Ov].push(o_),o_+=gy[Ov].width*m0.type*2;Iy(dv,Yy,gy,Mv,b_,h0);for(var ky=0;ky<gy.length;++ky){var jy=gy[ky];if(!jy.decoded)switch(jy.compression){case 2:for(var Qv=0,s_=0,w_=0;w_<m0.lines;++w_){for(var S_=Yy[ky][Qv],B_=0;B_<jy.width;++B_){for(var z_=0;z_<2*jy.type;++z_)h0[S_++]=x_[s_+z_*jy.width*jy.height];s_++}Qv++}break;case 1:default:throw"EXRLoader.parse: unsupported channel compression"}}return new DataView(h0.buffer)}function Wy(m0,E0){for(var j0=new Uint8Array(m0),h0=0;j0[E0.value+h0]!=0;)h0+=1;var $0=new TextDecoder().decode(j0.slice(E0.value,E0.value+h0));return E0.value=E0.value+h0+1,$0}function my(m0,E0,j0){var h0=new TextDecoder().decode(new Uint8Array(m0).slice(E0.value,E0.value+j0));return E0.value=E0.value+j0,h0}function uv(m0,E0){var j0=wv(m0,E0),h0=mv(m0,E0);return[j0,h0]}function Hy(m0,E0){var j0=mv(m0,E0),h0=mv(m0,E0);return[j0,h0]}function wv(m0,E0){var j0=m0.getInt32(E0.value,!0);return E0.value=E0.value+4,j0}function mv(m0,E0){var j0=m0.getUint32(E0.value,!0);return E0.value=E0.value+4,j0}function cv(m0,E0){var j0=m0[E0.value];return E0.value=E0.value+1,j0}function O0(m0,E0){var j0=m0.getUint8(E0.value);return E0.value=E0.value+1,j0}const oy=function(m0,E0){let j0;return"getBigInt64"in DataView.prototype?j0=Number(m0.getBigInt64(E0.value,!0)):j0=m0.getUint32(E0.value+4,!0)+Number(m0.getUint32(E0.value,!0)<<32),E0.value+=8,j0};function Py(m0,E0){var j0=m0.getFloat32(E0.value,!0);return E0.value+=4,j0}function nv(m0,E0){return DataUtils.toHalfFloat(Py(m0,E0))}function d0(m0){var E0=(m0&31744)>>10,j0=m0&1023;return(m0>>15?-1:1)*(E0?E0===31?j0?NaN:1/0:Math.pow(2,E0-15)*(1+j0/1024):6103515625e-14*(j0/1024))}function v0(m0,E0){var j0=m0.getUint16(E0.value,!0);return E0.value+=2,j0}function N0(m0,E0){return d0(v0(m0,E0))}function F0(m0,E0,j0,h0){for(var $0=j0.value,P0=[];j0.value<$0+h0-1;){var Yr=Wy(E0,j0),r0=wv(m0,j0),p0=O0(m0,j0);j0.value+=3;var _0=wv(m0,j0),D0=wv(m0,j0);P0.push({name:Yr,pixelType:r0,pLinear:p0,xSampling:_0,ySampling:D0})}return j0.value+=1,P0}function sy(m0,E0){var j0=Py(m0,E0),h0=Py(m0,E0),$0=Py(m0,E0),P0=Py(m0,E0),Yr=Py(m0,E0),r0=Py(m0,E0),p0=Py(m0,E0),_0=Py(m0,E0);return{redX:j0,redY:h0,greenX:$0,greenY:P0,blueX:Yr,blueY:r0,whiteX:p0,whiteY:_0}}function xy(m0,E0){var j0=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],h0=O0(m0,E0);return j0[h0]}function ev(m0,E0){var j0=mv(m0,E0),h0=mv(m0,E0),$0=mv(m0,E0),P0=mv(m0,E0);return{xMin:j0,yMin:h0,xMax:$0,yMax:P0}}function Sv(m0,E0){var j0=["INCREASING_Y"],h0=O0(m0,E0);return j0[h0]}function kv(m0,E0){var j0=Py(m0,E0),h0=Py(m0,E0);return[j0,h0]}function Vv(m0,E0){var j0=Py(m0,E0),h0=Py(m0,E0),$0=Py(m0,E0);return[j0,h0,$0]}function $v(m0,E0,j0,h0,$0){if(h0==="string"||h0==="stringvector"||h0==="iccProfile")return my(E0,j0,$0);if(h0==="chlist")return F0(m0,E0,j0,$0);if(h0==="chromaticities")return sy(m0,j0);if(h0==="compression")return xy(m0,j0);if(h0==="box2i")return ev(m0,j0);if(h0==="lineOrder")return Sv(m0,j0);if(h0==="float")return Py(m0,j0);if(h0==="v2f")return kv(m0,j0);if(h0==="v3f")return Vv(m0,j0);if(h0==="int")return wv(m0,j0);if(h0==="rational")return uv(m0,j0);if(h0==="timecode")return Hy(m0,j0);if(h0==="preview")return j0.value+=$0,"skipped";j0.value+=$0}function ov(m0,E0,j0){const h0={};if(m0.getUint32(0,!0)!=20000630)throw"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";h0.version=m0.getUint8(4);const $0=m0.getUint8(5);h0.spec={singleTile:!!($0&2),longName:!!($0&4),deepFormat:!!($0&8),multiPart:!!($0&16)},j0.value=8;for(var P0=!0;P0;){var Yr=Wy(E0,j0);if(Yr==0)P0=!1;else{var r0=Wy(E0,j0),p0=mv(m0,j0),_0=$v(m0,E0,j0,r0,p0);_0===void 0?console.warn(`EXRLoader.parse: skipped unknown header attribute type '${r0}'.`):h0[Yr]=_0}}if($0&-5)throw console.error("EXRHeader:",h0),"THREE.EXRLoader: provided file is currently unsupported.";return h0}function C_(m0,E0,j0,h0,$0){const P0={size:0,viewer:E0,array:j0,offset:h0,width:m0.dataWindow.xMax-m0.dataWindow.xMin+1,height:m0.dataWindow.yMax-m0.dataWindow.yMin+1,channels:m0.channels.length,bytesPerLine:null,lines:null,inputSize:null,type:m0.channels[0].pixelType,uncompress:null,getter:null,format:null,[hasColorSpace?"colorSpace":"encoding"]:null};switch(m0.compression){case"NO_COMPRESSION":P0.lines=1,P0.uncompress=uy;break;case"RLE_COMPRESSION":P0.lines=1,P0.uncompress=Ey;break;case"ZIPS_COMPRESSION":P0.lines=1,P0.uncompress=Dy;break;case"ZIP_COMPRESSION":P0.lines=16,P0.uncompress=Dy;break;case"PIZ_COMPRESSION":P0.lines=32,P0.uncompress=By;break;case"PXR24_COMPRESSION":P0.lines=16,P0.uncompress=bv;break;case"DWAA_COMPRESSION":P0.lines=32,P0.uncompress=av;break;case"DWAB_COMPRESSION":P0.lines=256,P0.uncompress=av;break;default:throw"EXRLoader.parse: "+m0.compression+" is unsupported"}if(P0.scanlineBlockSize=P0.lines,P0.type==1)switch($0){case FloatType:P0.getter=N0,P0.inputSize=2;break;case HalfFloatType:P0.getter=v0,P0.inputSize=2;break}else if(P0.type==2)switch($0){case FloatType:P0.getter=Py,P0.inputSize=4;break;case HalfFloatType:P0.getter=nv,P0.inputSize=4}else throw"EXRLoader.parse: unsupported pixelType "+P0.type+" for "+m0.compression+".";P0.blockCount=(m0.dataWindow.yMax+1)/P0.scanlineBlockSize;for(var Yr=0;Yr<P0.blockCount;Yr++)oy(E0,h0);P0.outputChannels=P0.channels==3?4:P0.channels;const r0=P0.width*P0.height*P0.outputChannels;switch($0){case FloatType:P0.byteArray=new Float32Array(r0),P0.channels<P0.outputChannels&&P0.byteArray.fill(1,0,r0);break;case HalfFloatType:P0.byteArray=new Uint16Array(r0),P0.channels<P0.outputChannels&&P0.byteArray.fill(15360,0,r0);break;default:console.error("THREE.EXRLoader: unsupported type: ",$0);break}return P0.bytesPerLine=P0.width*P0.inputSize*P0.channels,P0.outputChannels==4?P0.format=RGBAFormat:P0.format=RedFormat,hasColorSpace?P0.colorSpace="srgb-linear":P0.encoding=3e3,P0}const wy=new DataView(e),Zv=new Uint8Array(e),Xv={value:0},v_=ov(wy,e,Xv),Rv=C_(v_,wy,Zv,Xv,this.type),i1={value:0},h1={R:0,G:1,B:2,A:3,Y:0};for(let m0=0;m0<Rv.height/Rv.scanlineBlockSize;m0++){const E0=mv(wy,Xv);Rv.size=mv(wy,Xv),Rv.lines=E0+Rv.scanlineBlockSize>Rv.height?Rv.height-E0:Rv.scanlineBlockSize;const h0=Rv.size<Rv.lines*Rv.bytesPerLine?Rv.uncompress(Rv):uy(Rv);Xv.value+=Rv.size;for(let $0=0;$0<Rv.scanlineBlockSize;$0++){const P0=$0+m0*Rv.scanlineBlockSize;if(P0>=Rv.height)break;for(let Yr=0;Yr<Rv.channels;Yr++){const r0=h1[v_.channels[Yr].name];for(let p0=0;p0<Rv.width;p0++){i1.value=($0*(Rv.channels*Rv.width)+Yr*Rv.width+p0)*Rv.inputSize;const _0=(Rv.height-1-P0)*(Rv.width*Rv.outputChannels)+p0*Rv.outputChannels+r0;Rv.byteArray[_0]=Rv.getter(h0,i1)}}}}return{header:v_,width:Rv.width,height:Rv.height,data:Rv.byteArray,format:Rv.format,[hasColorSpace?"colorSpace":"encoding"]:Rv[hasColorSpace?"colorSpace":"encoding"],type:this.type}}setDataType(e){return this.type=e,this}load(e,o,s,d){function c(h,_){hasColorSpace?h.colorSpace=_.colorSpace:h.encoding=_.encoding,h.minFilter=LinearFilter,h.magFilter=LinearFilter,h.generateMipmaps=!1,h.flipY=!1,o&&o(h,_)}return super.load(e,c,s,d)}}const _taskCache=new WeakMap;class DRACOLoader extends Loader{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,o,s,d){const c=new FileLoader(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(e,h=>{const _={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(h,_).then(o).catch(d)},s,d)}decodeDracoFile(e,o,s,d){const c={attributeIDs:s||this.defaultAttributeIDs,attributeTypes:d||this.defaultAttributeTypes,useUniqueIDs:!!s};this.decodeGeometry(e,c).then(o)}decodeGeometry(e,o){for(const bt in o.attributeTypes){const g=o.attributeTypes[bt];g.BYTES_PER_ELEMENT!==void 0&&(o.attributeTypes[bt]=g.name)}const s=JSON.stringify(o);if(_taskCache.has(e)){const bt=_taskCache.get(e);if(bt.key===s)return bt.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let d;const c=this.workerNextTaskID++,h=e.byteLength,_=this._getWorker(c,h).then(bt=>(d=bt,new Promise((g,j)=>{d._callbacks[c]={resolve:g,reject:j},d.postMessage({type:"decode",id:c,taskConfig:o,buffer:e},[e])}))).then(bt=>this._createGeometry(bt.geometry));return _.catch(()=>!0).then(()=>{d&&c&&this._releaseTask(d,c)}),_taskCache.set(e,{key:s,promise:_}),_}_createGeometry(e){const o=new BufferGeometry;e.index&&o.setIndex(new BufferAttribute(e.index.array,1));for(let s=0;s<e.attributes.length;s++){const d=e.attributes[s],c=d.name,h=d.array,_=d.itemSize;o.setAttribute(c,new BufferAttribute(h,_))}return o}_loadLibrary(e,o){const s=new FileLoader(this.manager);return s.setPath(this.decoderPath),s.setResponseType(o),s.setWithCredentials(this.withCredentials),new Promise((d,c)=>{s.load(e,d,void 0,c)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",o=[];return e?o.push(this._loadLibrary("draco_decoder.js","text")):(o.push(this._loadLibrary("draco_wasm_wrapper.js","text")),o.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(o).then(s=>{const d=s[0];e||(this.decoderConfig.wasmBinary=s[1]);const c=DRACOWorker.toString(),h=["/* draco decoder */",d,"","/* worker */",c.substring(c.indexOf("{")+1,c.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([h]))}),this.decoderPending}_getWorker(e,o){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const d=new Worker(this.workerSourceURL);d._callbacks={},d._taskCosts={},d._taskLoad=0,d.postMessage({type:"init",decoderConfig:this.decoderConfig}),d.onmessage=function(c){const h=c.data;switch(h.type){case"decode":d._callbacks[h.id].resolve(h);break;case"error":d._callbacks[h.id].reject(h);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+h.type+'"')}},this.workerPool.push(d)}else this.workerPool.sort(function(d,c){return d._taskLoad>c._taskLoad?-1:1});const s=this.workerPool[this.workerPool.length-1];return s._taskCosts[e]=o,s._taskLoad+=o,s})}_releaseTask(e,o){e._taskLoad-=e._taskCosts[o],delete e._callbacks[o],delete e._taskCosts[o]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function DRACOWorker(){let a,e;onmessage=function(h){const _=h.data;switch(_.type){case"init":a=_.decoderConfig,e=new Promise(function(j){a.onModuleLoaded=function(b){j({draco:b})},DracoDecoderModule(a)});break;case"decode":const bt=_.buffer,g=_.taskConfig;e.then(j=>{const b=j.draco,Et=new b.Decoder,It=new b.DecoderBuffer;It.Init(new Int8Array(bt),bt.byteLength);try{const zt=o(b,Et,It,g),er=zt.attributes.map(Hn=>Hn.array.buffer);zt.index&&er.push(zt.index.array.buffer),self.postMessage({type:"decode",id:_.id,geometry:zt},er)}catch(zt){console.error(zt),self.postMessage({type:"error",id:_.id,error:zt.message})}finally{b.destroy(It),b.destroy(Et)}});break}};function o(h,_,bt,g){const j=g.attributeIDs,b=g.attributeTypes;let Et,It;const zt=_.GetEncodedGeometryType(bt);if(zt===h.TRIANGULAR_MESH)Et=new h.Mesh,It=_.DecodeBufferToMesh(bt,Et);else if(zt===h.POINT_CLOUD)Et=new h.PointCloud,It=_.DecodeBufferToPointCloud(bt,Et);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!It.ok()||Et.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+It.error_msg());const er={index:null,attributes:[]};for(const Hn in j){const Qt=self[b[Hn]];let cr,fr;if(g.useUniqueIDs)fr=j[Hn],cr=_.GetAttributeByUniqueId(Et,fr);else{if(fr=_.GetAttributeId(Et,h[j[Hn]]),fr===-1)continue;cr=_.GetAttribute(Et,fr)}er.attributes.push(d(h,_,Et,Hn,Qt,cr))}return zt===h.TRIANGULAR_MESH&&(er.index=s(h,_,Et)),h.destroy(Et),er}function s(h,_,bt){const j=bt.num_faces()*3,b=j*4,Et=h._malloc(b);_.GetTrianglesUInt32Array(bt,b,Et);const It=new Uint32Array(h.HEAPF32.buffer,Et,j).slice();return h._free(Et),{array:It,itemSize:1}}function d(h,_,bt,g,j,b){const Et=b.num_components(),zt=bt.num_points()*Et,er=zt*j.BYTES_PER_ELEMENT,Hn=c(h,j),Qt=h._malloc(er);_.GetAttributeDataArrayForAllPoints(bt,b,Hn,er,Qt);const cr=new j(h.HEAPF32.buffer,Qt,zt).slice();return h._free(Qt),{name:g,array:cr,itemSize:Et}}function c(h,_){switch(_){case Float32Array:return h.DT_FLOAT32;case Int8Array:return h.DT_INT8;case Int16Array:return h.DT_INT16;case Int32Array:return h.DT_INT32;case Uint8Array:return h.DT_UINT8;case Uint16Array:return h.DT_UINT16;case Uint32Array:return h.DT_UINT32}}}let generated;const MeshoptDecoder=()=>{if(generated)return generated;const a="B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",e="B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",o=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),s=new Uint8Array([32,0,65,253,3,1,2,34,4,106,6,5,11,8,7,20,13,33,12,16,128,9,116,64,19,113,127,15,10,21,22,14,255,66,24,54,136,107,18,23,192,26,114,118,132,17,77,101,130,144,27,87,131,44,45,74,156,154,70,167]);if(typeof WebAssembly!="object")return{supported:!1};let d=a;WebAssembly.validate(o)&&(d=e);let c;const h=WebAssembly.instantiate(_(d),{}).then(b=>{c=b.instance,c.exports.__wasm_call_ctors()});function _(b){const Et=new Uint8Array(b.length);for(let zt=0;zt<b.length;++zt){const er=b.charCodeAt(zt);Et[zt]=er>96?er-71:er>64?er-65:er>47?er+4:er>46?63:62}let It=0;for(let zt=0;zt<b.length;++zt)Et[It++]=Et[zt]<60?s[Et[zt]]:(Et[zt]-60)*64+Et[++zt];return Et.buffer.slice(0,It)}function bt(b,Et,It,zt,er,Hn){const Qt=c.exports.sbrk,cr=It+3&-4,fr=Qt(cr*zt),jr=Qt(er.length),e0=new Uint8Array(c.exports.memory.buffer);e0.set(er,jr);const t0=b(fr,It,zt,jr,er.length);if(t0===0&&Hn&&Hn(fr,cr,zt),Et.set(e0.subarray(fr,fr+It*zt)),Qt(fr-Qt(0)),t0!==0)throw new Error(`Malformed buffer data: ${t0}`)}const g={0:"",1:"meshopt_decodeFilterOct",2:"meshopt_decodeFilterQuat",3:"meshopt_decodeFilterExp",NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},j={0:"meshopt_decodeVertexBuffer",1:"meshopt_decodeIndexBuffer",2:"meshopt_decodeIndexSequence",ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"};return generated={ready:h,supported:!0,decodeVertexBuffer(b,Et,It,zt,er){bt(c.exports.meshopt_decodeVertexBuffer,b,Et,It,zt,c.exports[g[er]])},decodeIndexBuffer(b,Et,It,zt){bt(c.exports.meshopt_decodeIndexBuffer,b,Et,It,zt)},decodeIndexSequence(b,Et,It,zt){bt(c.exports.meshopt_decodeIndexSequence,b,Et,It,zt)},decodeGltfBuffer(b,Et,It,zt,er,Hn){bt(c.exports[j[er]],b,Et,It,zt,c.exports[g[Hn]])}},generated},IsObject=a=>a===Object(a)&&!Array.isArray(a)&&typeof a!="function";function useTexture(a,e){const o=useThree(c=>c.gl),s=useLoader(TextureLoader,IsObject(a)?Object.values(a):a);return reactExports.useLayoutEffect(()=>{e==null||e(s)},[e]),reactExports.useEffect(()=>{if("initTexture"in o){let c=[];Array.isArray(s)?c=s:s instanceof Texture?c=[s]:IsObject(s)&&(c=Object.values(s)),c.forEach(h=>{h instanceof Texture&&o.initTexture(h)})}},[o,s]),reactExports.useMemo(()=>{if(IsObject(a)){const c={};let h=0;for(const _ in a)c[_]=s[h++];return c}else return s},[a,s])}useTexture.preload=a=>useLoader.preload(TextureLoader,a);useTexture.clear=a=>useLoader.clear(TextureLoader,a);const getVersion=()=>parseInt(REVISION.replace(/\D+/g,"")),version=getVersion();let dracoLoader=null,decoderPath="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function extensions(a,e,o){return s=>{o&&o(s),a&&(dracoLoader||(dracoLoader=new DRACOLoader),dracoLoader.setDecoderPath(typeof a=="string"?a:decoderPath),s.setDRACOLoader(dracoLoader)),e&&s.setMeshoptDecoder(typeof MeshoptDecoder=="function"?MeshoptDecoder():MeshoptDecoder)}}function useGLTF(a,e=!0,o=!0,s){return useLoader(GLTFLoader,a,extensions(e,o,s))}useGLTF.preload=(a,e=!0,o=!0,s)=>useLoader.preload(GLTFLoader,a,extensions(e,o,s));useGLTF.clear=a=>useLoader.clear(GLTFLoader,a);useGLTF.setDecoderPath=a=>{decoderPath=a};const OrbitControls=reactExports.forwardRef(({makeDefault:a,camera:e,regress:o,domElement:s,enableDamping:d=!0,keyEvents:c=!1,onChange:h,onStart:_,onEnd:bt,...g},j)=>{const b=useThree(t0=>t0.invalidate),Et=useThree(t0=>t0.camera),It=useThree(t0=>t0.gl),zt=useThree(t0=>t0.events),er=useThree(t0=>t0.setEvents),Hn=useThree(t0=>t0.set),Qt=useThree(t0=>t0.get),cr=useThree(t0=>t0.performance),fr=e||Et,jr=s||zt.connected||It.domElement,e0=reactExports.useMemo(()=>new OrbitControls$1(fr),[fr]);return useFrame(()=>{e0.enabled&&e0.update()},-1),reactExports.useEffect(()=>(c&&e0.connect(c===!0?jr:c),e0.connect(jr),()=>void e0.dispose()),[c,jr,o,e0,b]),reactExports.useEffect(()=>{const t0=g0=>{b(),o&&cr.regress(),h&&h(g0)},o0=g0=>{_&&_(g0)},l0=g0=>{bt&&bt(g0)};return e0.addEventListener("change",t0),e0.addEventListener("start",o0),e0.addEventListener("end",l0),()=>{e0.removeEventListener("start",o0),e0.removeEventListener("end",l0),e0.removeEventListener("change",t0)}},[h,_,bt,e0,b,er]),reactExports.useEffect(()=>{if(a){const t0=Qt().controls;return Hn({controls:e0}),()=>Hn({controls:t0})}},[a,e0]),reactExports.createElement("primitive",_extends({ref:j,object:e0,enableDamping:d},g))}),Center=reactExports.forwardRef(function({children:e,disable:o,disableX:s,disableY:d,disableZ:c,left:h,right:_,top:bt,bottom:g,front:j,back:b,onCentered:Et,precise:It=!0,cacheKey:zt=0,...er},Hn){const Qt=reactExports.useRef(null),cr=reactExports.useRef(null),fr=reactExports.useRef(null);return reactExports.useLayoutEffect(()=>{cr.current.matrixWorld.identity();const jr=new Box3().setFromObject(fr.current,It),e0=new Vector3,t0=new Sphere,o0=jr.max.x-jr.min.x,l0=jr.max.y-jr.min.y,g0=jr.max.z-jr.min.z;jr.getCenter(e0),jr.getBoundingSphere(t0);const i0=bt?l0/2:g?-l0/2:0,f0=h?-o0/2:_?o0/2:0,C0=j?g0/2:b?-g0/2:0;cr.current.position.set(o||s?0:-e0.x+f0,o||d?0:-e0.y+i0,o||c?0:-e0.z+C0),typeof Et<"u"&&Et({parent:Qt.current.parent,container:Qt.current,width:o0,height:l0,depth:g0,boundingBox:jr,boundingSphere:t0,center:e0,verticalAlignment:i0,horizontalAlignment:f0,depthAlignment:C0})},[zt,Et,bt,h,j,o,s,d,c,It,_,g,b]),reactExports.useImperativeHandle(Hn,()=>Qt.current,[]),reactExports.createElement("group",_extends({ref:Qt},er),reactExports.createElement("group",{ref:cr},reactExports.createElement("group",{ref:fr},e)))}),LinearEncoding=3e3,sRGBEncoding=3001,Float=reactExports.forwardRef(({children:a,enabled:e=!0,speed:o=1,rotationIntensity:s=1,floatIntensity:d=1,floatingRange:c=[-.1,.1],...h},_)=>{const bt=reactExports.useRef(null);reactExports.useImperativeHandle(_,()=>bt.current,[]);const g=reactExports.useRef(Math.random()*1e4);return useFrame(j=>{var b,Et;if(!e||o===0)return;const It=g.current+j.clock.getElapsedTime();bt.current.rotation.x=Math.cos(It/4*o)/8*s,bt.current.rotation.y=Math.sin(It/4*o)/8*s,bt.current.rotation.z=Math.sin(It/4*o)/20*s;let zt=Math.sin(It/4*o)/10;zt=MathUtils.mapLinear(zt,-.1,.1,(b=c==null?void 0:c[0])!==null&&b!==void 0?b:-.1,(Et=c==null?void 0:c[1])!==null&&Et!==void 0?Et:.1),bt.current.position.y=zt*d,bt.current.updateMatrix()}),reactExports.createElement("group",h,reactExports.createElement("group",{ref:bt,matrixAutoUpdate:!1},a))}),getBufferForType=(a,e,o)=>{let s;switch(a){case UnsignedByteType:s=new Uint8ClampedArray(e*o*4);break;case HalfFloatType:s=new Uint16Array(e*o*4);break;case UnsignedIntType:s=new Uint32Array(e*o*4);break;case ByteType:s=new Int8Array(e*o*4);break;case ShortType:s=new Int16Array(e*o*4);break;case IntType:s=new Int32Array(e*o*4);break;case FloatType:s=new Float32Array(e*o*4);break;default:throw new Error("Unsupported data type")}return s};let _canReadPixelsResult;const canReadPixels=(a,e,o,s)=>{if(_canReadPixelsResult!==void 0)return _canReadPixelsResult;const d=new WebGLRenderTarget(1,1,s);e.setRenderTarget(d);const c=new Mesh(new PlaneGeometry,new MeshBasicMaterial({color:16777215}));e.render(c,o),e.setRenderTarget(null);const h=getBufferForType(a,d.width,d.height);return e.readRenderTargetPixels(d,0,0,d.width,d.height,h),d.dispose(),c.geometry.dispose(),c.material.dispose(),_canReadPixelsResult=h[0]!==0,_canReadPixelsResult};class QuadRenderer{constructor(e){var o,s,d,c,h,_,bt,g,j,b,Et,It,zt,er,Hn,Qt;this._rendererIsDisposable=!1,this._supportsReadPixels=!0,this.render=()=>{this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(fr){throw this._renderer.setRenderTarget(null),fr}this._renderer.setRenderTarget(null)},this._width=e.width,this._height=e.height,this._type=e.type,this._colorSpace=e.colorSpace;const cr={format:RGBAFormat,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:((o=e.renderTargetOptions)===null||o===void 0?void 0:o.anisotropy)!==void 0?(s=e.renderTargetOptions)===null||s===void 0?void 0:s.anisotropy:1,generateMipmaps:((d=e.renderTargetOptions)===null||d===void 0?void 0:d.generateMipmaps)!==void 0?(c=e.renderTargetOptions)===null||c===void 0?void 0:c.generateMipmaps:!1,magFilter:((h=e.renderTargetOptions)===null||h===void 0?void 0:h.magFilter)!==void 0?(_=e.renderTargetOptions)===null||_===void 0?void 0:_.magFilter:LinearFilter,minFilter:((bt=e.renderTargetOptions)===null||bt===void 0?void 0:bt.minFilter)!==void 0?(g=e.renderTargetOptions)===null||g===void 0?void 0:g.minFilter:LinearFilter,samples:((j=e.renderTargetOptions)===null||j===void 0?void 0:j.samples)!==void 0?(b=e.renderTargetOptions)===null||b===void 0?void 0:b.samples:void 0,wrapS:((Et=e.renderTargetOptions)===null||Et===void 0?void 0:Et.wrapS)!==void 0?(It=e.renderTargetOptions)===null||It===void 0?void 0:It.wrapS:ClampToEdgeWrapping,wrapT:((zt=e.renderTargetOptions)===null||zt===void 0?void 0:zt.wrapT)!==void 0?(er=e.renderTargetOptions)===null||er===void 0?void 0:er.wrapT:ClampToEdgeWrapping};if(this._material=e.material,e.renderer?this._renderer=e.renderer:(this._renderer=QuadRenderer.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new Scene,this._camera=new OrthographicCamera,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),!canReadPixels(this._type,this._renderer,this._camera,cr)){let fr;switch(this._type){case HalfFloatType:fr=this._renderer.extensions.has("EXT_color_buffer_float")?FloatType:void 0;break}fr!==void 0?(console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`),this._type=fr):(this._supportsReadPixels=!1,console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))}this._quad=new Mesh(new PlaneGeometry,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new WebGLRenderTarget(this.width,this.height,cr),this._renderTarget.texture.mapping=((Hn=e.renderTargetOptions)===null||Hn===void 0?void 0:Hn.mapping)!==void 0?(Qt=e.renderTargetOptions)===null||Qt===void 0?void 0:Qt.mapping:UVMapping}static instantiateRenderer(){const e=new WebGLRenderer;return e.setSize(128,128),e}toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");const e=getBufferForType(this._type,this._width,this._height);return this._renderer.readRenderTargetPixels(this._renderTarget,0,0,this._width,this._height,e),e}toDataTexture(e){const o=new DataTexture(this.toArray(),this.width,this.height,RGBAFormat,this._type,(e==null?void 0:e.mapping)||UVMapping,(e==null?void 0:e.wrapS)||ClampToEdgeWrapping,(e==null?void 0:e.wrapT)||ClampToEdgeWrapping,(e==null?void 0:e.magFilter)||LinearFilter,(e==null?void 0:e.minFilter)||LinearFilter,(e==null?void 0:e.anisotropy)||1,LinearSRGBColorSpace);return o.generateMipmaps=(e==null?void 0:e.generateMipmaps)!==void 0?e==null?void 0:e.generateMipmaps:!1,o}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&(this._renderer.dispose(),this._renderer.forceContextLoss())}dispose(e){this.disposeOnDemandRenderer(),e&&this.renderTarget.dispose(),this.material instanceof ShaderMaterial&&Object.values(this.material.uniforms).forEach(o=>{o.value instanceof Texture&&o.value.dispose()}),Object.values(this.material).forEach(o=>{o instanceof Texture&&o.dispose()}),this.material.dispose(),this._quad.geometry.dispose()}get width(){return this._width}set width(e){this._width=e,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(e){this._height=e,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(e){this._renderTarget=e,this._width=e.width,this._height=e.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}const vertexShader=`
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,fragmentShader=`
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;class GainMapDecoderMaterial extends ShaderMaterial{constructor({gamma:e,offsetHdr:o,offsetSdr:s,gainMapMin:d,gainMapMax:c,maxDisplayBoost:h,hdrCapacityMin:_,hdrCapacityMax:bt,sdr:g,gainMap:j}){super({name:"GainMapDecoderMaterial",vertexShader,fragmentShader,uniforms:{sdr:{value:g},gainMap:{value:j},gamma:{value:new Vector3(1/e[0],1/e[1],1/e[2])},offsetHdr:{value:new Vector3().fromArray(o)},offsetSdr:{value:new Vector3().fromArray(s)},gainMapMin:{value:new Vector3().fromArray(d)},gainMapMax:{value:new Vector3().fromArray(c)},weightFactor:{value:(Math.log2(h)-_)/(bt-_)}},blending:NoBlending,depthTest:!1,depthWrite:!1}),this._maxDisplayBoost=h,this._hdrCapacityMin=_,this._hdrCapacityMax=bt,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get sdr(){return this.uniforms.sdr.value}set sdr(e){this.uniforms.sdr.value=e}get gainMap(){return this.uniforms.gainMap.value}set gainMap(e){this.uniforms.gainMap.value=e}get offsetHdr(){return this.uniforms.offsetHdr.value.toArray()}set offsetHdr(e){this.uniforms.offsetHdr.value.fromArray(e)}get offsetSdr(){return this.uniforms.offsetSdr.value.toArray()}set offsetSdr(e){this.uniforms.offsetSdr.value.fromArray(e)}get gainMapMin(){return this.uniforms.gainMapMin.value.toArray()}set gainMapMin(e){this.uniforms.gainMapMin.value.fromArray(e)}get gainMapMax(){return this.uniforms.gainMapMax.value.toArray()}set gainMapMax(e){this.uniforms.gainMapMax.value.fromArray(e)}get gamma(){const e=this.uniforms.gamma.value;return[1/e.x,1/e.y,1/e.z]}set gamma(e){const o=this.uniforms.gamma.value;o.x=1/e[0],o.y=1/e[1],o.z=1/e[2]}get hdrCapacityMin(){return this._hdrCapacityMin}set hdrCapacityMin(e){this._hdrCapacityMin=e,this.calculateWeight()}get hdrCapacityMax(){return this._hdrCapacityMax}set hdrCapacityMax(e){this._hdrCapacityMax=e,this.calculateWeight()}get maxDisplayBoost(){return this._maxDisplayBoost}set maxDisplayBoost(e){this._maxDisplayBoost=Math.max(1,Math.min(65504,e)),this.calculateWeight()}calculateWeight(){const e=(Math.log2(this._maxDisplayBoost)-this._hdrCapacityMin)/(this._hdrCapacityMax-this._hdrCapacityMin);this.uniforms.weightFactor.value=Math.max(0,Math.min(1,e))}}class GainMapNotFoundError extends Error{}class XMPMetadataNotFoundError extends Error{}const getAttribute=(a,e,o)=>{var s;let d;const c=(s=a.attributes.getNamedItem(e))===null||s===void 0?void 0:s.nodeValue;if(c)d=c;else{const h=a.getElementsByTagName(e)[0];if(h){const _=h.getElementsByTagName("rdf:li");if(_.length===3)d=Array.from(_).map(bt=>bt.innerHTML);else throw new Error(`Gainmap metadata contains an array of items for ${e} but its length is not 3`)}else{if(o)return o;throw new Error(`Can't find ${e} in gainmap metadata`)}}return d},extractXMP=a=>{var e,o;let s;typeof TextDecoder<"u"?s=new TextDecoder().decode(a):s=a.toString();let d=s.indexOf("<x:xmpmeta");const c=new DOMParser;for(;d!==-1;){const h=s.indexOf("x:xmpmeta>",d);s.slice(d,h+10);const _=s.slice(d,h+10);try{const g=c.parseFromString(_,"text/xml").getElementsByTagName("rdf:Description")[0],j=getAttribute(g,"hdrgm:GainMapMin","0"),b=getAttribute(g,"hdrgm:GainMapMax"),Et=getAttribute(g,"hdrgm:Gamma","1"),It=getAttribute(g,"hdrgm:OffsetSDR","0.015625"),zt=getAttribute(g,"hdrgm:OffsetHDR","0.015625");let er=(e=g.attributes.getNamedItem("hdrgm:HDRCapacityMin"))===null||e===void 0?void 0:e.nodeValue;er||(er="0");const Hn=(o=g.attributes.getNamedItem("hdrgm:HDRCapacityMax"))===null||o===void 0?void 0:o.nodeValue;if(!Hn)throw new Error("Incomplete gainmap metadata");return{gainMapMin:Array.isArray(j)?j.map(Qt=>parseFloat(Qt)):[parseFloat(j),parseFloat(j),parseFloat(j)],gainMapMax:Array.isArray(b)?b.map(Qt=>parseFloat(Qt)):[parseFloat(b),parseFloat(b),parseFloat(b)],gamma:Array.isArray(Et)?Et.map(Qt=>parseFloat(Qt)):[parseFloat(Et),parseFloat(Et),parseFloat(Et)],offsetSdr:Array.isArray(It)?It.map(Qt=>parseFloat(Qt)):[parseFloat(It),parseFloat(It),parseFloat(It)],offsetHdr:Array.isArray(zt)?zt.map(Qt=>parseFloat(Qt)):[parseFloat(zt),parseFloat(zt),parseFloat(zt)],hdrCapacityMin:parseFloat(er),hdrCapacityMax:parseFloat(Hn)}}catch{}d=s.indexOf("<x:xmpmeta",h)}};class MPFExtractor{constructor(e){this.options={debug:e&&e.debug!==void 0?e.debug:!1,extractFII:e&&e.extractFII!==void 0?e.extractFII:!0,extractNonFII:e&&e.extractNonFII!==void 0?e.extractNonFII:!0}}extract(e){return new Promise((o,s)=>{const d=this.options.debug,c=new DataView(e.buffer);if(c.getUint16(0)!==65496){s(new Error("Not a valid jpeg"));return}const h=c.byteLength;let _=2,bt=0,g;for(;_<h;){if(++bt>250){s(new Error(`Found no marker after ${bt} loops 😵`));return}if(c.getUint8(_)!==255){s(new Error(`Not a valid marker at offset 0x${_.toString(16)}, found: 0x${c.getUint8(_).toString(16)}`));return}if(g=c.getUint8(_+1),d&&console.log(`Marker: ${g.toString(16)}`),g===226){d&&console.log("Found APP2 marker (0xffe2)");const j=_+4;if(c.getUint32(j)===1297106432){const b=j+4;let Et;if(c.getUint16(b)===18761)Et=!1;else if(c.getUint16(b)===19789)Et=!0;else{s(new Error("No valid endianness marker found in TIFF header"));return}if(c.getUint16(b+2,!Et)!==42){s(new Error("Not valid TIFF data! (no 0x002A marker)"));return}const It=c.getUint32(b+4,!Et);if(It<8){s(new Error("Not valid TIFF data! (First offset less than 8)"));return}const zt=b+It,er=c.getUint16(zt,!Et),Hn=zt+2;let Qt=0;for(let e0=Hn;e0<Hn+12*er;e0+=12)c.getUint16(e0,!Et)===45057&&(Qt=c.getUint32(e0+8,!Et));const fr=zt+2+er*12+4,jr=[];for(let e0=fr;e0<fr+Qt*16;e0+=16){const t0={MPType:c.getUint32(e0,!Et),size:c.getUint32(e0+4,!Et),dataOffset:c.getUint32(e0+8,!Et),dependantImages:c.getUint32(e0+12,!Et),start:-1,end:-1,isFII:!1};t0.dataOffset?(t0.start=b+t0.dataOffset,t0.isFII=!1):(t0.start=0,t0.isFII=!0),t0.end=t0.start+t0.size,jr.push(t0)}if(this.options.extractNonFII&&jr.length){const e0=new Blob([c]),t0=[];for(const o0 of jr){if(o0.isFII&&!this.options.extractFII)continue;const l0=e0.slice(o0.start,o0.end+1,"image/jpeg");t0.push(l0)}o(t0)}}}_+=2+c.getUint16(_+2)}})}}const extractGainmapFromJPEG=async a=>{const e=extractXMP(a);if(!e)throw new XMPMetadataNotFoundError("Gain map XMP metadata not found");const s=await new MPFExtractor({extractFII:!0,extractNonFII:!0}).extract(a);if(s.length!==2)throw new GainMapNotFoundError("Gain map recovery image not found");return{sdr:new Uint8Array(await s[0].arrayBuffer()),gainMap:new Uint8Array(await s[1].arrayBuffer()),metadata:e}},getHTMLImageFromBlob=a=>new Promise((e,o)=>{const s=document.createElement("img");s.onload=()=>{e(s)},s.onerror=d=>{o(d)},s.src=URL.createObjectURL(a)});class LoaderBase extends Loader{constructor(e,o){super(o),e&&(this._renderer=e),this._internalLoadingManager=new LoadingManager}setRenderer(e){return this._renderer=e,this}setRenderTargetOptions(e){return this._renderTargetOptions=e,this}prepareQuadRenderer(){this._renderer||console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");const e=new GainMapDecoderMaterial({gainMapMax:[1,1,1],gainMapMin:[0,0,0],gamma:[1,1,1],offsetHdr:[1,1,1],offsetSdr:[1,1,1],hdrCapacityMax:1,hdrCapacityMin:0,maxDisplayBoost:1,gainMap:new Texture,sdr:new Texture});return new QuadRenderer({width:16,height:16,type:HalfFloatType,colorSpace:LinearSRGBColorSpace,material:e,renderer:this._renderer,renderTargetOptions:this._renderTargetOptions})}async render(e,o,s,d){const c=d?new Blob([d],{type:"image/jpeg"}):void 0,h=new Blob([s],{type:"image/jpeg"});let _,bt,g=!1;if(typeof createImageBitmap>"u"){const Et=await Promise.all([c?getHTMLImageFromBlob(c):Promise.resolve(void 0),getHTMLImageFromBlob(h)]);bt=Et[0],_=Et[1],g=!0}else{const Et=await Promise.all([c?createImageBitmap(c,{imageOrientation:"flipY"}):Promise.resolve(void 0),createImageBitmap(h,{imageOrientation:"flipY"})]);bt=Et[0],_=Et[1]}const j=new Texture(bt||new ImageData(2,2),UVMapping,ClampToEdgeWrapping,ClampToEdgeWrapping,LinearFilter,LinearMipMapLinearFilter,RGBAFormat,UnsignedByteType,1,LinearSRGBColorSpace);j.flipY=g,j.needsUpdate=!0;const b=new Texture(_,UVMapping,ClampToEdgeWrapping,ClampToEdgeWrapping,LinearFilter,LinearMipMapLinearFilter,RGBAFormat,UnsignedByteType,1,SRGBColorSpace);b.flipY=g,b.needsUpdate=!0,e.width=_.width,e.height=_.height,e.material.gainMap=j,e.material.sdr=b,e.material.gainMapMin=o.gainMapMin,e.material.gainMapMax=o.gainMapMax,e.material.offsetHdr=o.offsetHdr,e.material.offsetSdr=o.offsetSdr,e.material.gamma=o.gamma,e.material.hdrCapacityMin=o.hdrCapacityMin,e.material.hdrCapacityMax=o.hdrCapacityMax,e.material.maxDisplayBoost=Math.pow(2,o.hdrCapacityMax),e.material.needsUpdate=!0,e.render()}}class GainMapLoader extends LoaderBase{load([e,o,s],d,c,h){const _=this.prepareQuadRenderer();let bt,g,j;const b=async()=>{if(bt&&g&&j){try{await this.render(_,j,bt,g)}catch(g0){this.manager.itemError(e),this.manager.itemError(o),this.manager.itemError(s),typeof h=="function"&&h(g0),_.disposeOnDemandRenderer();return}typeof d=="function"&&d(_),this.manager.itemEnd(e),this.manager.itemEnd(o),this.manager.itemEnd(s),_.disposeOnDemandRenderer()}};let Et=!0,It=0,zt=0,er=!0,Hn=0,Qt=0,cr=!0,fr=0,jr=0;const e0=()=>{if(typeof c=="function"){const g0=It+Hn+fr,i0=zt+Qt+jr,f0=Et&&er&&cr;c(new ProgressEvent("progress",{lengthComputable:f0,loaded:i0,total:g0}))}};this.manager.itemStart(e),this.manager.itemStart(o),this.manager.itemStart(s);const t0=new FileLoader(this._internalLoadingManager);t0.setResponseType("arraybuffer"),t0.setRequestHeader(this.requestHeader),t0.setPath(this.path),t0.setWithCredentials(this.withCredentials),t0.load(e,async g0=>{if(typeof g0=="string")throw new Error("Invalid sdr buffer");bt=g0,await b()},g0=>{Et=g0.lengthComputable,zt=g0.loaded,It=g0.total,e0()},g0=>{this.manager.itemError(e),typeof h=="function"&&h(g0)});const o0=new FileLoader(this._internalLoadingManager);o0.setResponseType("arraybuffer"),o0.setRequestHeader(this.requestHeader),o0.setPath(this.path),o0.setWithCredentials(this.withCredentials),o0.load(o,async g0=>{if(typeof g0=="string")throw new Error("Invalid gainmap buffer");g=g0,await b()},g0=>{er=g0.lengthComputable,Qt=g0.loaded,Hn=g0.total,e0()},g0=>{this.manager.itemError(o),typeof h=="function"&&h(g0)});const l0=new FileLoader(this._internalLoadingManager);return l0.setRequestHeader(this.requestHeader),l0.setPath(this.path),l0.setWithCredentials(this.withCredentials),l0.load(s,async g0=>{if(typeof g0!="string")throw new Error("Invalid metadata string");j=JSON.parse(g0),await b()},g0=>{cr=g0.lengthComputable,jr=g0.loaded,fr=g0.total,e0()},g0=>{this.manager.itemError(s),typeof h=="function"&&h(g0)}),_}}class HDRJPGLoader extends LoaderBase{load(e,o,s,d){const c=this.prepareQuadRenderer(),h=new FileLoader(this._internalLoadingManager);return h.setResponseType("arraybuffer"),h.setRequestHeader(this.requestHeader),h.setPath(this.path),h.setWithCredentials(this.withCredentials),this.manager.itemStart(e),h.load(e,async _=>{if(typeof _=="string")throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");const bt=new Uint8Array(_);let g,j,b;try{const Et=await extractGainmapFromJPEG(bt);g=Et.sdr,j=Et.gainMap,b=Et.metadata}catch(Et){if(Et instanceof XMPMetadataNotFoundError||Et instanceof GainMapNotFoundError)console.warn(`Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),b={gainMapMin:[0,0,0],gainMapMax:[1,1,1],gamma:[1,1,1],hdrCapacityMin:0,hdrCapacityMax:1,offsetHdr:[0,0,0],offsetSdr:[0,0,0]},g=bt;else throw Et}try{await this.render(c,b,g,j)}catch(Et){this.manager.itemError(e),typeof d=="function"&&d(Et),c.disposeOnDemandRenderer();return}typeof o=="function"&&o(c),this.manager.itemEnd(e),c.disposeOnDemandRenderer()},s,_=>{this.manager.itemError(e),typeof d=="function"&&d(_)}),c}}const presetsObj={apartment:"lebombo_1k.hdr",city:"potsdamer_platz_1k.hdr",dawn:"kiara_1_dawn_1k.hdr",forest:"forest_slope_1k.hdr",lobby:"st_fagans_interior_1k.hdr",night:"dikhololo_night_1k.hdr",park:"rooitou_park_1k.hdr",studio:"studio_small_03_1k.hdr",sunset:"venice_sunset_1k.hdr",warehouse:"empty_warehouse_01_1k.hdr"},CUBEMAP_ROOT="https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",isArray=a=>Array.isArray(a);function useEnvironment({files:a=["/px.png","/nx.png","/py.png","/ny.png","/pz.png","/nz.png"],path:e="",preset:o=void 0,encoding:s=void 0,extensions:d}={}){var c;let h=null,_=!1,bt;if(o){if(!(o in presetsObj))throw new Error("Preset must be one of: "+Object.keys(presetsObj).join(", "));a=presetsObj[o],e=CUBEMAP_ROOT}const g=isArray(a)&&a.length===6,j=isArray(a)&&a.length===3&&a.some(Hn=>Hn.endsWith("json")),b=isArray(a)?a[0]:a;if(_=isArray(a),bt=g?"cube":j?"webp":b.startsWith("data:application/exr")?"exr":b.startsWith("data:application/hdr")?"hdr":b.startsWith("data:image/jpeg")?"jpg":(c=b.split(".").pop())==null||(c=c.split("?"))==null||(c=c.shift())==null?void 0:c.toLowerCase(),h=bt==="cube"?CubeTextureLoader:bt==="hdr"?RGBELoader:bt==="exr"?EXRLoader:bt==="jpg"||bt==="jpeg"?HDRJPGLoader:bt==="webp"?GainMapLoader:null,!h)throw new Error("useEnvironment: Unrecognized file extension: "+a);const Et=useThree(Hn=>Hn.gl),It=useLoader(h,_?[a]:a,Hn=>{(bt==="webp"||bt==="jpg"||bt==="jpeg")&&Hn.setRenderer(Et),Hn.setPath==null||Hn.setPath(e),d&&d(Hn)});let zt=_?It[0]:It;if(bt==="jpg"||bt==="jpeg"||bt==="webp"){var er;zt=(er=zt.renderTarget)==null?void 0:er.texture}return zt.mapping=g?CubeReflectionMapping:EquirectangularReflectionMapping,"colorSpace"in zt?zt.colorSpace=s??g?"srgb":"srgb-linear":zt.encoding=s??g?sRGBEncoding:LinearEncoding,zt}const isRef=a=>a.current&&a.current.isScene,resolveScene=a=>isRef(a)?a.current:a;function setEnvProps(a,e,o,s,d={}){var c,h,_,bt,g;d={backgroundBlurriness:(c=d.blur)!==null&&c!==void 0?c:0,backgroundIntensity:1,backgroundRotation:[0,0,0],environmentIntensity:1,environmentRotation:[0,0,0],...d};const j=resolveScene(e||o),b=j.background,Et=j.environment,It={backgroundBlurriness:j.backgroundBlurriness,backgroundIntensity:j.backgroundIntensity,backgroundRotation:(h=(_=j.backgroundRotation)==null||_.clone==null?void 0:_.clone())!==null&&h!==void 0?h:[0,0,0],environmentIntensity:j.environmentIntensity,environmentRotation:(bt=(g=j.environmentRotation)==null||g.clone==null?void 0:g.clone())!==null&&bt!==void 0?bt:[0,0,0]};return a!=="only"&&(j.environment=s),a&&(j.background=s),applyProps(j,d),()=>{a!=="only"&&(j.environment=Et),a&&(j.background=b),applyProps(j,It)}}function EnvironmentMap({scene:a,background:e=!1,map:o,...s}){const d=useThree(c=>c.scene);return reactExports.useLayoutEffect(()=>{if(o)return setEnvProps(e,a,d,o,s)}),null}function EnvironmentCube({background:a=!1,scene:e,blur:o,backgroundBlurriness:s,backgroundIntensity:d,backgroundRotation:c,environmentIntensity:h,environmentRotation:_,...bt}){const g=useEnvironment(bt),j=useThree(b=>b.scene);return reactExports.useLayoutEffect(()=>setEnvProps(a,e,j,g,{blur:o,backgroundBlurriness:s,backgroundIntensity:d,backgroundRotation:c,environmentIntensity:h,environmentRotation:_})),null}function EnvironmentPortal({children:a,near:e=1,far:o=1e3,resolution:s=256,frames:d=1,map:c,background:h=!1,blur:_,backgroundBlurriness:bt,backgroundIntensity:g,backgroundRotation:j,environmentIntensity:b,environmentRotation:Et,scene:It,files:zt,path:er,preset:Hn=void 0,extensions:Qt}){const cr=useThree(l0=>l0.gl),fr=useThree(l0=>l0.scene),jr=reactExports.useRef(null),[e0]=reactExports.useState(()=>new Scene),t0=reactExports.useMemo(()=>{const l0=new WebGLCubeRenderTarget(s);return l0.texture.type=HalfFloatType,l0},[s]);reactExports.useLayoutEffect(()=>(d===1&&jr.current.update(cr,e0),setEnvProps(h,It,fr,t0.texture,{blur:_,backgroundBlurriness:bt,backgroundIntensity:g,backgroundRotation:j,environmentIntensity:b,environmentRotation:Et})),[a,e0,t0.texture,It,fr,h,d,cr]);let o0=1;return useFrame(()=>{(d===1/0||o0<d)&&(jr.current.update(cr,e0),o0++)}),reactExports.createElement(reactExports.Fragment,null,createPortal(reactExports.createElement(reactExports.Fragment,null,a,reactExports.createElement("cubeCamera",{ref:jr,args:[e,o,t0]}),zt||Hn?reactExports.createElement(EnvironmentCube,{background:!0,files:zt,preset:Hn,path:er,extensions:Qt}):c?reactExports.createElement(EnvironmentMap,{background:!0,map:c,extensions:Qt}):null),e0))}function EnvironmentGround(a){var e,o,s,d;const c=useEnvironment(a),h=a.map||c;reactExports.useMemo(()=>extend({GroundProjectedEnvImpl:GroundProjectedEnv}),[]);const _=reactExports.useMemo(()=>[h],[h]),bt=(e=a.ground)==null?void 0:e.height,g=(o=a.ground)==null?void 0:o.radius,j=(s=(d=a.ground)==null?void 0:d.scale)!==null&&s!==void 0?s:1e3;return reactExports.createElement(reactExports.Fragment,null,reactExports.createElement(EnvironmentMap,_extends({},a,{map:h})),reactExports.createElement("groundProjectedEnvImpl",{args:_,scale:j,height:bt,radius:g}))}function Environment(a){return a.ground?reactExports.createElement(EnvironmentGround,a):a.map?reactExports.createElement(EnvironmentMap,a):a.children?reactExports.createElement(EnvironmentPortal,a):reactExports.createElement(EnvironmentCube,a)}const accumulativeContext=reactExports.createContext(null),RandomizedLight=reactExports.forwardRef(({castShadow:a=!0,bias:e=.001,mapSize:o=512,size:s=5,near:d=.5,far:c=500,frames:h=1,position:_=[0,0,0],radius:bt=1,amount:g=8,intensity:j=version>=155?Math.PI:1,ambient:b=.5,...Et},It)=>{const zt=reactExports.useRef(null),er=new Vector3(..._).length(),Hn=reactExports.useContext(accumulativeContext),Qt=reactExports.useCallback(()=>{let fr;if(zt.current)for(let jr=0;jr<zt.current.children.length;jr++)if(fr=zt.current.children[jr],Math.random()>b)fr.position.set(_[0]+MathUtils.randFloatSpread(bt),_[1]+MathUtils.randFloatSpread(bt),_[2]+MathUtils.randFloatSpread(bt));else{let e0=Math.acos(2*Math.random()-1)-Math.PI/2,t0=2*Math.PI*Math.random();fr.position.set(Math.cos(e0)*Math.cos(t0)*er,Math.abs(Math.cos(e0)*Math.sin(t0)*er),Math.sin(e0)*er)}},[bt,b,er,..._]),cr=reactExports.useMemo(()=>({update:Qt}),[Qt]);return reactExports.useImperativeHandle(It,()=>cr,[cr]),reactExports.useLayoutEffect(()=>{var fr;const jr=zt.current;return Hn&&((fr=Hn.lights)==null||fr.set(jr.uuid,cr)),()=>{var e0;return void(Hn==null||(e0=Hn.lights)==null?void 0:e0.delete(jr.uuid))}},[Hn,cr]),reactExports.createElement("group",_extends({ref:zt},Et),Array.from({length:g},(fr,jr)=>reactExports.createElement("directionalLight",{key:jr,castShadow:a,"shadow-bias":e,"shadow-mapSize":[o,o],intensity:j/g},reactExports.createElement("orthographicCamera",{attach:"shadow-camera",args:[-s,s,s,-s,d,c]}))))});function calcPosFromAngles(a,e,o=new Vector3){const s=Math.PI*(a-.5),d=2*Math.PI*(e-.5);return o.x=Math.cos(d),o.y=Math.sin(s),o.z=Math.sin(d),o}const Sky=reactExports.forwardRef(({inclination:a=.6,azimuth:e=.1,distance:o=1e3,mieCoefficient:s=.005,mieDirectionalG:d=.8,rayleigh:c=.5,turbidity:h=10,sunPosition:_=calcPosFromAngles(a,e),...bt},g)=>{const j=reactExports.useMemo(()=>new Vector3().setScalar(o),[o]),[b]=reactExports.useState(()=>new Sky$1);return reactExports.createElement("primitive",_extends({object:b,ref:g,"material-uniforms-mieCoefficient-value":s,"material-uniforms-mieDirectionalG-value":d,"material-uniforms-rayleigh-value":c,"material-uniforms-sunPosition-value":_,"material-uniforms-turbidity-value":h,scale:j},bt))}),Lighting=()=>jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment,{children:[jsxRuntimeExports.jsx(RandomizedLight,{amount:4,radius:9,intensity:.55,ambient:.25,position:[5,5,-10]}),jsxRuntimeExports.jsx(RandomizedLight,{amount:4,radius:5,intensity:.25,ambient:.55,position:[-5,5,-9]})]}),CameraRig=({children:a})=>{const e=reactExports.useRef();return jsxRuntimeExports.jsx("group",{ref:e,children:a})},basePath="/visual-experience/",defaultModelPath=`${basePath}/models/shirt_baked_2.glb`,Shirt=({modelPath:a=defaultModelPath,hexColor:e=16777215,texture:o,scale:s=new Vector3(1,1,1)},d)=>{const{nodes:c,materials:h}=useGLTF(a),_=useTexture({aoMap:`${basePath}/textures/wool/wool_texture_ao.jpg`,roughnessMap:`${basePath}/textures/wool/wool_texture_rough.jpg`,metalnessMap:`${basePath}/textures/wool/wool_texture_metal.jpg`,normalMap:`${basePath}/textures/wool/wool_texture_normal.jpg`}),bt=useTexture({map:`${basePath}/textures/cotton/Fabric_001_COLOR.jpg`,aoMap:`${basePath}/textures/cotton/Fabric_001_OCC.jpg`,roughnessMap:`${basePath}/textures/cotton/Fabric_001_ROUGH.jpg`,normalMap:`${basePath}/textures/cotton/Fabric_001_NORM.jpg`});return reactExports.useEffect(()=>{o==="Wool"?(h.lambert1.aoMap=_.aoMap,h.lambert1.roughnessMap=_.roughnessMap,h.lambert1.metalnessMap=_.metalnessMap,h.lambert1.normalMap=_.normalMap):o==="Cotton"?(h.lambert1.map=bt.map,h.lambert1.roughnessMap=bt.roughnessMap,h.lambert1.normalMap=bt.normalMap,h.lambert1.aoMap=bt.aoMap):(h.lambert1.map=null,h.lambert1.roughnessMap=null,h.lambert1.normalMap=null,h.lambert1.aoMap=null,h.lambert1.metalnessMap=null),h.lambert1.needsUpdate=!0},[o,_,bt,h.lambert1]),h.lambert1.color=new Color(e),jsxRuntimeExports.jsx("group",{...d,dispose:null,children:jsxRuntimeExports.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:c.T_Shirt_male.geometry,material:h.lambert1,position:[.419,0,0],scale:s,rotation:[Math.PI/2,0,0]})})};useGLTF.preload(defaultModelPath);extend({useGLTF,Environment,Center,OrbitControls,Canvas});const ThreeScene=({position:a=[0,0,2.5],fov:e=25,hexColor:o,texture:s,scale:d=new Vector3(1,1,1)})=>jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment,{children:jsxRuntimeExports.jsxs(Canvas,{shadows:!0,camera:{position:a,fov:e},gl:{preserveDrawingBuffer:!0},eventSource:document.getElementById("root"),eventPrefix:"client",children:[jsxRuntimeExports.jsx("ambientLight",{intensity:2}),jsxRuntimeExports.jsx(OrbitControls,{enableZoom:!1}),jsxRuntimeExports.jsx(Environment,{files:"https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/potsdamer_platz_1k.hdr"}),jsxRuntimeExports.jsx(Sky,{distance:45e4,sunPosition:[0,1,0],inclination:0,azimuth:.25}),jsxRuntimeExports.jsxs(CameraRig,{children:[jsxRuntimeExports.jsx(Lighting,{}),jsxRuntimeExports.jsx(Center,{children:jsxRuntimeExports.jsx(Float,{speed:1,rotationIntensity:.5,floatIntensity:1,floatingRange:[-0,.1],children:jsxRuntimeExports.jsx(Shirt,{hexColor:o,texture:s,scale:d})})})]})]})}),Overlay=({setParentHexColor:a,setParentScale:e,handleFileUpload:o,setParentTexture:s})=>{const[d,c]=reactExports.useState("#000000"),[h,_]=reactExports.useState(new Vector3(1,1,1)),[bt,g]=reactExports.useState("None"),j=Hn=>parseInt(Hn.slice(1),16),b=Hn=>{const Qt=Hn.target.value;c(Qt),a(j(Qt))},Et=Hn=>{const Qt=Hn.target.value;g(Qt),s(Qt)},It=(Hn,Qt)=>{const cr=h.clone();cr[Hn]=Qt,_(cr),e(cr)},zt=()=>{const Hn=document.querySelector("canvas");if(Hn){const Qt=document.createElement("a");Qt.setAttribute("download","canvas.png");const cr=Hn.toDataURL("image/png").replace("image/png","image/octet-stream");Qt.setAttribute("href",cr),Qt.click()}else console.error("Canvas element not found.")},er=Hn=>{const Qt=Hn.target.files&&Hn.target.files[0];Qt&&o(Qt)};return jsxRuntimeExports.jsx("div",{style:{position:"absolute",top:0,left:0,width:"100%",height:"100%",pointerEvents:"auto"},children:jsxRuntimeExports.jsxs("div",{className:"customizer",children:[jsxRuntimeExports.jsx("div",{className:"color-options",children:jsxRuntimeExports.jsx("input",{placeholder:"Color",type:"color",className:"color-picker",value:d,onChange:b})}),jsxRuntimeExports.jsx("div",{className:"texture-options",children:jsxRuntimeExports.jsxs("select",{value:bt,onChange:Et,children:[jsxRuntimeExports.jsx("option",{value:"None",children:"None"}),jsxRuntimeExports.jsx("option",{value:"Cotton",children:"Cotton"}),jsxRuntimeExports.jsx("option",{value:"Wool",children:"Wool"})]})}),jsxRuntimeExports.jsxs("div",{className:"scale-sliders",children:[jsxRuntimeExports.jsxs("label",{children:["X:",jsxRuntimeExports.jsx("input",{type:"range",min:"0",max:"2",step:"0.01",value:h.x,onChange:Hn=>It("x",parseFloat(Hn.target.value))})]}),jsxRuntimeExports.jsxs("label",{children:["Y:",jsxRuntimeExports.jsx("input",{type:"range",min:"0",max:"2",step:"0.01",value:h.y,onChange:Hn=>It("y",parseFloat(Hn.target.value))})]}),jsxRuntimeExports.jsxs("label",{children:["Z:",jsxRuntimeExports.jsx("input",{type:"range",min:"0",max:"2",step:"0.01",value:h.z,onChange:Hn=>It("z",parseFloat(Hn.target.value))})]})]}),jsxRuntimeExports.jsx("button",{onClick:zt,children:"Download"}),jsxRuntimeExports.jsx("input",{type:"file",onChange:er,accept:"image/*",style:{display:"none"},id:"file-upload"}),jsxRuntimeExports.jsx("label",{htmlFor:"file-upload",style:{cursor:"pointer"},children:"Upload Image"})]})})},getSrc=a=>typeof a=="string"?a:a.src,getArgs=({amount:a=3,format:e="array",group:o=20,sample:s=10}={})=>({amount:a,format:e,group:o,sample:s}),format=(a,e)=>{const o=a.map(s=>{const d=Array.isArray(s)?s:s.split(",").map(Number);return e.format==="hex"?rgbToHex(d):d});return e.amount===1||o.length===1?o[0]:o},group=(a,e)=>{const o=Math.round(a/e)*e;return Math.min(o,255)},rgbToHex=a=>"#"+a.map(e=>{const o=e.toString(16);return o.length===1?"0"+o:o}).join(""),getImageData=a=>new Promise((e,o)=>{const s=document.createElement("canvas"),d=s.getContext("2d"),c=new Image;c.onload=()=>{s.height=c.height,s.width=c.width,d.drawImage(c,0,0);const h=d.getImageData(0,0,c.width,c.height).data;e(h)},c.onerror=()=>o(Error("Image loading failed.")),c.crossOrigin="",c.src=a}),getProminent=(a,e)=>{const o=4*e.sample,s={};for(let d=0;d<a.length;d+=o)if(a[d+3]>0){const h=[group(a[d],e.group),group(a[d+1],e.group),group(a[d+2],e.group)].join();s[h]=s[h]?s[h]+1:1}return format(Object.entries(s).sort(([d,c],[h,_])=>c>_?-1:1).slice(0,e.amount).map(([d])=>d),e)},process$1=(a,e,o)=>new Promise((s,d)=>getImageData(getSrc(e)).then(c=>s(a(c,getArgs(o)))).catch(c=>d(c))),prominent=(a,e)=>process$1(getProminent,a,e);function iota$1(a){for(var e=new Array(a),o=0;o<a;++o)e[o]=o;return e}var iota_1=iota$1;/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */var isBuffer_1=function(a){return a!=null&&(isBuffer$1(a)||isSlowBuffer(a)||!!a._isBuffer)};function isBuffer$1(a){return!!a.constructor&&typeof a.constructor.isBuffer=="function"&&a.constructor.isBuffer(a)}function isSlowBuffer(a){return typeof a.readFloatLE=="function"&&typeof a.slice=="function"&&isBuffer$1(a.slice(0,0))}var iota=iota_1,isBuffer=isBuffer_1,hasTypedArrays=typeof Float64Array<"u";function compare1st(a,e){return a[0]-e[0]}function order(){var a=this.stride,e=new Array(a.length),o;for(o=0;o<e.length;++o)e[o]=[Math.abs(a[o]),o];e.sort(compare1st);var s=new Array(e.length);for(o=0;o<s.length;++o)s[o]=e[o][1];return s}function compileConstructor(a,e){var o=["View",e,"d",a].join("");e<0&&(o="View_Nil"+a);var s=a==="generic";if(e===-1){var d="function "+o+"(a){this.data=a;};var proto="+o+".prototype;proto.dtype='"+a+"';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new "+o+"(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_"+o+"(a){return new "+o+"(a);}",er=new Function(d);return er()}else if(e===0){var d="function "+o+"(a,d) {this.data = a;this.offset = d};var proto="+o+".prototype;proto.dtype='"+a+"';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function "+o+"_copy() {return new "+o+"(this.data,this.offset)};proto.pick=function "+o+"_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function "+o+"_get(){return "+(s?"this.data.get(this.offset)":"this.data[this.offset]")+"};proto.set=function "+o+"_set(v){return "+(s?"this.data.set(this.offset,v)":"this.data[this.offset]=v")+"};return function construct_"+o+"(a,b,c,d){return new "+o+"(a,d)}",er=new Function("TrivialArray",d);return er(CACHED_CONSTRUCTORS[a][0])}var d=["'use strict'"],c=iota(e),h=c.map(function(Hn){return"i"+Hn}),_="this.offset+"+c.map(function(Hn){return"this.stride["+Hn+"]*i"+Hn}).join("+"),bt=c.map(function(Hn){return"b"+Hn}).join(","),g=c.map(function(Hn){return"c"+Hn}).join(",");d.push("function "+o+"(a,"+bt+","+g+",d){this.data=a","this.shape=["+bt+"]","this.stride=["+g+"]","this.offset=d|0}","var proto="+o+".prototype","proto.dtype='"+a+"'","proto.dimension="+e),d.push("Object.defineProperty(proto,'size',{get:function "+o+"_size(){return "+c.map(function(Hn){return"this.shape["+Hn+"]"}).join("*"),"}})"),e===1?d.push("proto.order=[0]"):(d.push("Object.defineProperty(proto,'order',{get:"),e<4?(d.push("function "+o+"_order(){"),e===2?d.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})"):e===3&&d.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})")):d.push("ORDER})")),d.push("proto.set=function "+o+"_set("+h.join(",")+",v){"),s?d.push("return this.data.set("+_+",v)}"):d.push("return this.data["+_+"]=v}"),d.push("proto.get=function "+o+"_get("+h.join(",")+"){"),s?d.push("return this.data.get("+_+")}"):d.push("return this.data["+_+"]}"),d.push("proto.index=function "+o+"_index(",h.join(),"){return "+_+"}"),d.push("proto.hi=function "+o+"_hi("+h.join(",")+"){return new "+o+"(this.data,"+c.map(function(Hn){return["(typeof i",Hn,"!=='number'||i",Hn,"<0)?this.shape[",Hn,"]:i",Hn,"|0"].join("")}).join(",")+","+c.map(function(Hn){return"this.stride["+Hn+"]"}).join(",")+",this.offset)}");var j=c.map(function(Hn){return"a"+Hn+"=this.shape["+Hn+"]"}),b=c.map(function(Hn){return"c"+Hn+"=this.stride["+Hn+"]"});d.push("proto.lo=function "+o+"_lo("+h.join(",")+"){var b=this.offset,d=0,"+j.join(",")+","+b.join(","));for(var Et=0;Et<e;++Et)d.push("if(typeof i"+Et+"==='number'&&i"+Et+">=0){d=i"+Et+"|0;b+=c"+Et+"*d;a"+Et+"-=d}");d.push("return new "+o+"(this.data,"+c.map(function(Hn){return"a"+Hn}).join(",")+","+c.map(function(Hn){return"c"+Hn}).join(",")+",b)}"),d.push("proto.step=function "+o+"_step("+h.join(",")+"){var "+c.map(function(Hn){return"a"+Hn+"=this.shape["+Hn+"]"}).join(",")+","+c.map(function(Hn){return"b"+Hn+"=this.stride["+Hn+"]"}).join(",")+",c=this.offset,d=0,ceil=Math.ceil");for(var Et=0;Et<e;++Et)d.push("if(typeof i"+Et+"==='number'){d=i"+Et+"|0;if(d<0){c+=b"+Et+"*(a"+Et+"-1);a"+Et+"=ceil(-a"+Et+"/d)}else{a"+Et+"=ceil(a"+Et+"/d)}b"+Et+"*=d}");d.push("return new "+o+"(this.data,"+c.map(function(Hn){return"a"+Hn}).join(",")+","+c.map(function(Hn){return"b"+Hn}).join(",")+",c)}");for(var It=new Array(e),zt=new Array(e),Et=0;Et<e;++Et)It[Et]="a[i"+Et+"]",zt[Et]="b[i"+Et+"]";d.push("proto.transpose=function "+o+"_transpose("+h+"){"+h.map(function(Hn,Qt){return Hn+"=("+Hn+"===undefined?"+Qt+":"+Hn+"|0)"}).join(";"),"var a=this.shape,b=this.stride;return new "+o+"(this.data,"+It.join(",")+","+zt.join(",")+",this.offset)}"),d.push("proto.pick=function "+o+"_pick("+h+"){var a=[],b=[],c=this.offset");for(var Et=0;Et<e;++Et)d.push("if(typeof i"+Et+"==='number'&&i"+Et+">=0){c=(c+this.stride["+Et+"]*i"+Et+")|0}else{a.push(this.shape["+Et+"]);b.push(this.stride["+Et+"])}");d.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"),d.push("return function construct_"+o+"(data,shape,stride,offset){return new "+o+"(data,"+c.map(function(Hn){return"shape["+Hn+"]"}).join(",")+","+c.map(function(Hn){return"stride["+Hn+"]"}).join(",")+",offset)}");var er=new Function("CTOR_LIST","ORDER",d.join(`
`));return er(CACHED_CONSTRUCTORS[a],order)}function arrayDType(a){if(isBuffer(a))return"buffer";if(hasTypedArrays)switch(Object.prototype.toString.call(a)){case"[object Float64Array]":return"float64";case"[object Float32Array]":return"float32";case"[object Int8Array]":return"int8";case"[object Int16Array]":return"int16";case"[object Int32Array]":return"int32";case"[object Uint8Array]":return"uint8";case"[object Uint16Array]":return"uint16";case"[object Uint32Array]":return"uint32";case"[object Uint8ClampedArray]":return"uint8_clamped";case"[object BigInt64Array]":return"bigint64";case"[object BigUint64Array]":return"biguint64"}return Array.isArray(a)?"array":"generic"}var CACHED_CONSTRUCTORS={float32:[],float64:[],int8:[],int16:[],int32:[],uint8:[],uint16:[],uint32:[],array:[],uint8_clamped:[],bigint64:[],biguint64:[],buffer:[],generic:[]};function wrappedNDArrayCtor(a,e,o,s){if(a===void 0){var g=CACHED_CONSTRUCTORS.array[0];return g([])}else typeof a=="number"&&(a=[a]);e===void 0&&(e=[a.length]);var d=e.length;if(o===void 0){o=new Array(d);for(var c=d-1,h=1;c>=0;--c)o[c]=h,h*=e[c]}if(s===void 0){s=0;for(var c=0;c<d;++c)o[c]<0&&(s-=(e[c]-1)*o[c])}for(var _=arrayDType(a),bt=CACHED_CONSTRUCTORS[_];bt.length<=d+1;)bt.push(compileConstructor(_,bt.length-1));var g=bt[d+1];return g(a,e,o,s)}var ndarray=wrappedNDArrayCtor;const ndarray4=getDefaultExportFromCjs(ndarray);/*!
 * ONNX Runtime Web v1.17.3
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var Od$1=Object.create,Dn$1=Object.defineProperty,Id$1=Object.getOwnPropertyDescriptor,Sd$1=Object.getOwnPropertyNames,Ad$1=Object.getPrototypeOf,Pd$1=Object.prototype.hasOwnProperty,E=(a,e)=>()=>(a&&(e=a(a=0)),e),me=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),Pr$1=(a,e)=>{for(var o in e)Dn$1(a,o,{get:e[o],enumerable:!0})},Ha=(a,e,o,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let d of Sd$1(e))!Pd$1.call(a,d)&&d!==o&&Dn$1(a,d,{get:()=>e[d],enumerable:!(s=Id$1(e,d))||s.enumerable});return a},Er$1=(a,e,o)=>(o=a!=null?Od$1(Ad$1(a)):{},Ha(e||!a||!a.__esModule?Dn$1(o,"default",{value:a,enumerable:!0}):o,a)),or$1=a=>Ha(Dn$1({},"__esModule",{value:!0}),a),Ln,ir$1,Dr,Ed$1,Fn$1,Cn$1=E(()=>{Ln=new Map,ir$1=[],Dr=(a,e,o)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let s=Ln.get(a);if(s===void 0)Ln.set(a,{backend:e,priority:o});else{if(s.priority>o)return;if(s.priority===o&&s.backend!==e)throw new Error(`cannot register backend "${a}" using priority ${o}`)}if(o>=0){let d=ir$1.indexOf(a);d!==-1&&ir$1.splice(d,1);for(let c=0;c<ir$1.length;c++)if(Ln.get(ir$1[c]).priority<=o){ir$1.splice(c,0,a);return}ir$1.push(a)}return}throw new TypeError("not a valid backend")},Ed$1=async a=>{let e=Ln.get(a);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let o=!!e.initPromise;try{return o||(e.initPromise=e.backend.init(a)),await e.initPromise,e.initialized=!0,e.backend}catch(s){return o||(e.error=`${s}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},Fn$1=async a=>{let e=a.executionProviders||[],o=e.map(bt=>typeof bt=="string"?bt:bt.name),s=o.length===0?ir$1:o,d,c=[],h=new Set;for(let bt of s){let g=await Ed$1(bt);typeof g=="string"?c.push({name:bt,err:g}):(d||(d=g),d===g&&h.add(bt))}if(!d)throw new Error(`no available backend found. ERR: ${c.map(bt=>`[${bt.name}] ${bt.err}`).join(", ")}`);for(let{name:bt,err:g}of c)o.includes(bt)&&console.warn(`removing requested execution provider "${bt}" from session options because it is not available: ${g}`);let _=e.filter(bt=>h.has(typeof bt=="string"?bt:bt.name));return[d,new Proxy(a,{get:(bt,g)=>g==="executionProviders"?_:Reflect.get(bt,g)})]}}),qa=E(()=>{Cn$1()}),ja,Ya=E(()=>{ja="1.17.3"}),Xa,it$1,Ho$1=E(()=>{Ya(),Xa="warning",it$1={wasm:{},webgl:{},webgpu:{},versions:{common:ja},set logLevel(a){if(a!==void 0){if(typeof a!="string"||["verbose","info","warning","error","fatal"].indexOf(a)===-1)throw new Error(`Unsupported logging level: ${a}`);Xa=a}},get logLevel(){return Xa}},Object.defineProperty(it$1,"logLevel",{enumerable:!0})}),Z,Ka=E(()=>{Ho$1(),Z=it$1}),Ja,Za,Qa=E(()=>{Ja=(a,e)=>{let o=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);o.width=a.dims[3],o.height=a.dims[2];let s=o.getContext("2d");if(s!=null){let d,c;(e==null?void 0:e.tensorLayout)!==void 0&&e.tensorLayout==="NHWC"?(d=a.dims[2],c=a.dims[3]):(d=a.dims[3],c=a.dims[2]);let h=(e==null?void 0:e.format)!==void 0?e.format:"RGB",_=e==null?void 0:e.norm,bt,g;_===void 0||_.mean===void 0?bt=[255,255,255,255]:typeof _.mean=="number"?bt=[_.mean,_.mean,_.mean,_.mean]:(bt=[_.mean[0],_.mean[1],_.mean[2],0],_.mean[3]!==void 0&&(bt[3]=_.mean[3])),_===void 0||_.bias===void 0?g=[0,0,0,0]:typeof _.bias=="number"?g=[_.bias,_.bias,_.bias,_.bias]:(g=[_.bias[0],_.bias[1],_.bias[2],0],_.bias[3]!==void 0&&(g[3]=_.bias[3]));let j=c*d,b=0,Et=j,It=j*2,zt=-1;h==="RGBA"?(b=0,Et=j,It=j*2,zt=j*3):h==="RGB"?(b=0,Et=j,It=j*2):h==="RBG"&&(b=0,It=j,Et=j*2);for(let er=0;er<c;er++)for(let Hn=0;Hn<d;Hn++){let Qt=(a.data[b++]-g[0])*bt[0],cr=(a.data[Et++]-g[1])*bt[1],fr=(a.data[It++]-g[2])*bt[2],jr=zt===-1?255:(a.data[zt++]-g[3])*bt[3];s.fillStyle="rgba("+Qt+","+cr+","+fr+","+jr+")",s.fillRect(Hn,er,1,1)}if("toDataURL"in o)return o.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Za=(a,e)=>{let o=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),s;if(o!=null){let d,c,h;(e==null?void 0:e.tensorLayout)!==void 0&&e.tensorLayout==="NHWC"?(d=a.dims[2],c=a.dims[1],h=a.dims[3]):(d=a.dims[3],c=a.dims[2],h=a.dims[1]);let _=e!==void 0&&e.format!==void 0?e.format:"RGB",bt=e==null?void 0:e.norm,g,j;bt===void 0||bt.mean===void 0?g=[255,255,255,255]:typeof bt.mean=="number"?g=[bt.mean,bt.mean,bt.mean,bt.mean]:(g=[bt.mean[0],bt.mean[1],bt.mean[2],255],bt.mean[3]!==void 0&&(g[3]=bt.mean[3])),bt===void 0||bt.bias===void 0?j=[0,0,0,0]:typeof bt.bias=="number"?j=[bt.bias,bt.bias,bt.bias,bt.bias]:(j=[bt.bias[0],bt.bias[1],bt.bias[2],0],bt.bias[3]!==void 0&&(j[3]=bt.bias[3]));let b=c*d;if(e!==void 0&&(e.format!==void 0&&h===4&&e.format!=="RGBA"||h===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let Et=4,It=0,zt=1,er=2,Hn=3,Qt=0,cr=b,fr=b*2,jr=-1;_==="RGBA"?(Qt=0,cr=b,fr=b*2,jr=b*3):_==="RGB"?(Qt=0,cr=b,fr=b*2):_==="RBG"&&(Qt=0,fr=b,cr=b*2),s=o.createImageData(d,c);for(let e0=0;e0<c*d;It+=Et,zt+=Et,er+=Et,Hn+=Et,e0++)s.data[It]=(a.data[Qt++]-j[0])*g[0],s.data[zt]=(a.data[cr++]-j[1])*g[1],s.data[er]=(a.data[fr++]-j[2])*g[2],s.data[Hn]=jr===-1?255:(a.data[jr++]-j[3])*g[3]}else throw new Error("Can not access image data");return s}}),qo$1,es$1,ts$1,rs$1,ns$1,os$1=E(()=>{$n$1(),qo$1=(a,e)=>{if(a===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:o,width:s}=e,d=e.norm??{mean:255,bias:0},c,h;typeof d.mean=="number"?c=[d.mean,d.mean,d.mean,d.mean]:c=[d.mean[0],d.mean[1],d.mean[2],d.mean[3]??255],typeof d.bias=="number"?h=[d.bias,d.bias,d.bias,d.bias]:h=[d.bias[0],d.bias[1],d.bias[2],d.bias[3]??0];let _=e.format!==void 0?e.format:"RGBA",bt=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",g=o*s,j=bt==="RGBA"?new Float32Array(g*4):new Float32Array(g*3),b=4,Et=0,It=1,zt=2,er=3,Hn=0,Qt=g,cr=g*2,fr=-1;_==="RGB"&&(b=3,Et=0,It=1,zt=2,er=-1),bt==="RGBA"?fr=g*3:bt==="RBG"?(Hn=0,cr=g,Qt=g*2):bt==="BGR"&&(cr=0,Qt=g,Hn=g*2);for(let jr=0;jr<g;jr++,Et+=b,zt+=b,It+=b,er+=b)j[Hn++]=(a[Et]+h[0])/c[0],j[Qt++]=(a[It]+h[1])/c[1],j[cr++]=(a[zt]+h[2])/c[2],fr!==-1&&er!==-1&&(j[fr++]=(a[er]+h[3])/c[3]);return bt==="RGBA"?new Xe$1("float32",j,[1,4,o,s]):new Xe$1("float32",j,[1,3,o,s])},es$1=async(a,e)=>{let o=typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement,s=typeof ImageData<"u"&&a instanceof ImageData,d=typeof ImageBitmap<"u"&&a instanceof ImageBitmap,c=typeof a=="string",h,_=e??{},bt=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},g=j=>j instanceof HTMLCanvasElement||j instanceof OffscreenCanvas?j.getContext("2d"):null;if(o){let j=bt();j.width=a.width,j.height=a.height;let b=g(j);if(b!=null){let Et=a.height,It=a.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(Et=e.resizedHeight,It=e.resizedWidth),e!==void 0){if(_=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");_.tensorFormat="RGBA",_.height=Et,_.width=It}else _.tensorFormat="RGBA",_.height=Et,_.width=It;b.drawImage(a,0,0),h=b.getImageData(0,0,It,Et).data}else throw new Error("Can not access image data")}else if(s){let j,b;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(j=e.resizedHeight,b=e.resizedWidth):(j=a.height,b=a.width),e!==void 0&&(_=e),_.format="RGBA",_.height=j,_.width=b,e!==void 0){let Et=bt();Et.width=b,Et.height=j;let It=g(Et);if(It!=null)It.putImageData(a,0,0),h=It.getImageData(0,0,b,j).data;else throw new Error("Can not access image data")}else h=a.data}else if(d){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let j=bt();j.width=a.width,j.height=a.height;let b=g(j);if(b!=null){let Et=a.height,It=a.width;return b.drawImage(a,0,0,It,Et),h=b.getImageData(0,0,It,Et).data,_.height=Et,_.width=It,qo$1(h,_)}else throw new Error("Can not access image data")}else{if(c)return new Promise((j,b)=>{let Et=bt(),It=g(Et);if(!a||!It)return b();let zt=new Image;zt.crossOrigin="Anonymous",zt.src=a,zt.onload=()=>{Et.width=zt.width,Et.height=zt.height,It.drawImage(zt,0,0,Et.width,Et.height);let er=It.getImageData(0,0,Et.width,Et.height);_.height=Et.height,_.width=Et.width,j(qo$1(er.data,_))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(h!==void 0)return qo$1(h,_);throw new Error("Input data provided is not supported - aborted tensor creation")},ts$1=(a,e)=>{let{width:o,height:s,download:d,dispose:c}=e,h=[1,s,o,4];return new Xe$1({location:"texture",type:"float32",texture:a,dims:h,download:d,dispose:c})},rs$1=(a,e)=>{let{dataType:o,dims:s,download:d,dispose:c}=e;return new Xe$1({location:"gpu-buffer",type:o??"float32",gpuBuffer:a,dims:s,download:d,dispose:c})},ns$1=(a,e,o)=>new Xe$1({location:"cpu-pinned",type:a,data:e,dims:o??[e.length]})}),ar$1,tn$1,is$1,as$1,ss$1=E(()=>{ar$1=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),tn$1=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),is$1=!1,as$1=()=>{if(!is$1){is$1=!0;let a=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,o=typeof Float16Array<"u"&&Float16Array.from;a&&(ar$1.set("int64",BigInt64Array),tn$1.set(BigInt64Array,"int64")),e&&(ar$1.set("uint64",BigUint64Array),tn$1.set(BigUint64Array,"uint64")),o?(ar$1.set("float16",Float16Array),tn$1.set(Float16Array,"float16")):ar$1.set("float16",Uint16Array)}}}),us$1,ls$1,fs$1=E(()=>{$n$1(),us$1=a=>{let e=1;for(let o=0;o<a.length;o++){let s=a[o];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${o}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${o}] must be a non-negative integer, got: ${s}`);e*=s}return e},ls$1=(a,e)=>{switch(a.location){case"cpu":return new Xe$1(a.type,a.data,e);case"cpu-pinned":return new Xe$1({location:"cpu-pinned",data:a.data,type:a.type,dims:e});case"texture":return new Xe$1({location:"texture",texture:a.texture,type:a.type,dims:e});case"gpu-buffer":return new Xe$1({location:"gpu-buffer",gpuBuffer:a.gpuBuffer,type:a.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${a.location} is not supported`)}}}),Xe$1,$n$1=E(()=>{Qa(),os$1(),ss$1(),fs$1(),Xe$1=class{constructor(a,e,o){as$1();let s,d;if(typeof a=="object"&&"location"in a)switch(this.dataLocation=a.location,s=a.type,d=a.dims,a.location){case"cpu-pinned":{let h=ar$1.get(s);if(!h)throw new TypeError(`unsupported type "${s}" to create tensor from pinned buffer`);if(!(a.data instanceof h))throw new TypeError(`buffer should be of type ${h.name}`);this.cpuData=a.data;break}case"texture":{if(s!=="float32")throw new TypeError(`unsupported type "${s}" to create tensor from texture`);this.gpuTextureData=a.texture,this.downloader=a.download,this.disposer=a.dispose;break}case"gpu-buffer":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint8"&&s!=="bool")throw new TypeError(`unsupported type "${s}" to create tensor from gpu buffer`);this.gpuBufferData=a.gpuBuffer,this.downloader=a.download,this.disposer=a.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let h,_;if(typeof a=="string")if(s=a,_=o,a==="string"){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");h=e}else{let bt=ar$1.get(a);if(bt===void 0)throw new TypeError(`Unsupported tensor type: ${a}.`);if(Array.isArray(e)){if(a==="float16"&&bt===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");a==="uint64"||a==="int64"?h=bt.from(e,BigInt):h=bt.from(e)}else if(e instanceof bt)h=e;else throw new TypeError(`A ${s} tensor's data must be type of ${bt}`)}else if(_=e,Array.isArray(a)){if(a.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let bt=typeof a[0];if(bt==="string")s="string",h=a;else if(bt==="boolean")s="bool",h=Uint8Array.from(a);else throw new TypeError(`Invalid element type of data array: ${bt}.`)}else{let bt=tn$1.get(a.constructor);if(bt===void 0)throw new TypeError(`Unsupported type for tensor data: ${a.constructor}.`);s=bt,h=a}if(_===void 0)_=[h.length];else if(!Array.isArray(_))throw new TypeError("A tensor's dims must be a number array");d=_,this.cpuData=h,this.dataLocation="cpu"}let c=us$1(d);if(this.cpuData&&c!==this.cpuData.length)throw new Error(`Tensor's size(${c}) does not match data length(${this.cpuData.length}).`);this.type=s,this.dims=d,this.size=c}static async fromImage(a,e){return es$1(a,e)}static fromTexture(a,e){return ts$1(a,e)}static fromGpuBuffer(a,e){return rs$1(a,e)}static fromPinnedBuffer(a,e,o){return ns$1(a,e,o)}toDataURL(a){return Ja(this,a)}toImageData(a){return Za(this,a)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(a){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=e,a&&this.disposer&&(this.disposer(),this.disposer=void 0),e}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(a){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return ls$1(this,a)}}}),Re,kn$1=E(()=>{$n$1(),Re=Xe$1}),cs$1,ps$1,sr$1,ur,jo$1=E(()=>{Ho$1(),cs$1=(a,e)=>{(typeof it$1.trace>"u"?!it$1.wasm.trace:!it$1.trace)||console.timeStamp(`${a}::ORT::${e}`)},ps$1=(a,e)=>{var d;let o=((d=new Error().stack)==null?void 0:d.split(/\r\n|\r|\n/g))||[],s=!1;for(let c=0;c<o.length;c++){if(s&&!o[c].includes("TRACE_FUNC")){let h=`FUNC_${a}::${o[c].trim().split(" ")[1]}`;e&&(h+=`::${e}`),cs$1("CPU",h);return}o[c].includes("TRACE_FUNC")&&(s=!0)}},sr$1=a=>{(typeof it$1.trace>"u"?!it$1.wasm.trace:!it$1.trace)||ps$1("BEGIN",a)},ur=a=>{(typeof it$1.trace>"u"?!it$1.wasm.trace:!it$1.trace)||ps$1("END",a)}}),Bn$1,ds$1=E(()=>{Cn$1(),kn$1(),jo$1(),Bn$1=class cA{constructor(e){this.handler=e}async run(e,o,s){sr$1();let d={},c={};if(typeof e!="object"||e===null||e instanceof Re||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let h=!0;if(typeof o=="object"){if(o===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(o instanceof Re)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(o)){if(o.length===0)throw new TypeError("'fetches' cannot be an empty array.");h=!1;for(let g of o){if(typeof g!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(g)===-1)throw new RangeError(`'fetches' contains invalid output name: ${g}.`);d[g]=null}if(typeof s=="object"&&s!==null)c=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let g=!1,j=Object.getOwnPropertyNames(o);for(let b of this.outputNames)if(j.indexOf(b)!==-1){let Et=o[b];(Et===null||Et instanceof Re)&&(g=!0,h=!1,d[b]=Et)}if(g){if(typeof s=="object"&&s!==null)c=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else c=o}}else if(typeof o<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let g of this.inputNames)if(typeof e[g]>"u")throw new Error(`input '${g}' is missing in 'feeds'.`);if(h)for(let g of this.outputNames)d[g]=null;let _=await this.handler.run(e,d,c),bt={};for(let g in _)if(Object.hasOwnProperty.call(_,g)){let j=_[g];j instanceof Re?bt[g]=j:bt[g]=new Re(j.type,j.data,j.dims)}return ur(),bt}async release(){return this.handler.dispose()}static async create(e,o,s,d){sr$1();let c,h={};if(typeof e=="string"){if(c=e,typeof o=="object"&&o!==null)h=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(c=e,typeof o=="object"&&o!==null)h=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let j=e,b=0,Et=e.byteLength;if(typeof o=="object"&&o!==null)h=o;else if(typeof o=="number"){if(b=o,!Number.isSafeInteger(b))throw new RangeError("'byteOffset' must be an integer.");if(b<0||b>=j.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${j.byteLength}).`);if(Et=e.byteLength-b,typeof s=="number"){if(Et=s,!Number.isSafeInteger(Et))throw new RangeError("'byteLength' must be an integer.");if(Et<=0||b+Et>j.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${j.byteLength-b}].`);if(typeof d=="object"&&d!==null)h=d;else if(typeof d<"u")throw new TypeError("'options' must be an object.")}else if(typeof s<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof o<"u")throw new TypeError("'options' must be an object.");c=new Uint8Array(j,b,Et)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[_,bt]=await Fn$1(h),g=await _.createInferenceSessionHandler(c,bt);return ur(),new cA(g)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),Dd$1,hs$1=E(()=>{ds$1(),Dd$1=Bn$1}),ms$1=E(()=>{}),bs$1=E(()=>{}),gs$1=E(()=>{}),ys$1=E(()=>{}),Ld$1,Nn,Ts$1=E(()=>{Cn$1(),kn$1(),Ld$1="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",Nn=class dA{constructor(e,o,s){this.handler=e,this.hasOptimizerModel=o,this.hasEvalModel=s}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(e,o){let s=e.evalModel||"",d=e.optimizerModel||"",c=o||{},[h,_]=await Fn$1(c);if(h.createTrainingSessionHandler){let bt=await h.createTrainingSessionHandler(e.checkpointState,e.trainModel,s,d,_);return new dA(bt,!!e.optimizerModel,!!e.evalModel)}else throw new Error(Ld$1)}typeNarrowingForRunStep(e,o,s,d,c){let h={},_={};if(typeof s!="object"||s===null||s instanceof Re||Array.isArray(s))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let bt=!0;if(typeof d=="object"){if(d===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(d instanceof Re)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(d)){if(d.length===0)throw new TypeError("'fetches' cannot be an empty array.");bt=!1;for(let g of d){if(typeof g!="string")throw new TypeError("'fetches' must be a string array or an object.");if(o.indexOf(g)===-1)throw new RangeError(`'fetches' contains invalid output name: ${g}.`);h[g]=null}if(typeof c=="object"&&c!==null)_=c;else if(typeof c<"u")throw new TypeError("'options' must be an object.")}else{let g=!1,j=Object.getOwnPropertyNames(d);for(let b of o)if(j.indexOf(b)!==-1){let Et=d[b];(Et===null||Et instanceof Re)&&(g=!0,bt=!1,h[b]=Et)}if(g){if(typeof c=="object"&&c!==null)_=c;else if(typeof c<"u")throw new TypeError("'options' must be an object.")}else _=d}}else if(typeof d<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let g of e)if(typeof s[g]>"u")throw new Error(`input '${g}' is missing in 'feeds'.`);if(bt)for(let g of o)h[g]=null;return[h,_]}convertHandlerReturnTypeToMapOfTensors(e){let o={};for(let s in e)if(Object.hasOwnProperty.call(e,s)){let d=e[s];d instanceof Re?o[s]=d:o[s]=new Re(d.type,d.data,d.dims)}return o}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,o,s){let[d,c]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,o,s),h=await this.handler.runTrainStep(e,d,c);return this.convertHandlerReturnTypeToMapOfTensors(h)}async runOptimizerStep(e){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(e||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(e,o,s){if(this.hasEvalModel){let[d,c]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,o,s),h=await this.handler.runEvalStep(e,d,c);return this.convertHandlerReturnTypeToMapOfTensors(h)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,o=!0){let s=await this.getParametersSize(o);if(e.length!==4*s)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,o)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}}}),Fd$1,xs$1=E(()=>{Ts$1(),Fd$1=Nn}),Yo$1={};Pr$1(Yo$1,{InferenceSession:()=>Dd$1,TRACE:()=>cs$1,TRACE_FUNC_BEGIN:()=>sr$1,TRACE_FUNC_END:()=>ur,Tensor:()=>Re,TrainingSession:()=>Fd$1,env:()=>Z,registerBackend:()=>Dr});var Tt=E(()=>{qa(),Ka(),hs$1(),kn$1(),ms$1(),bs$1(),jo$1(),gs$1(),ys$1(),xs$1()});function jt$1(a,e,o,s){if(e===void 0)return $d(a);if(o===void 0)Rn$1(a,e);else if(typeof o=="number"&&s===void 0)Rn$1(a,e);else if(typeof o=="string"&&s===void 0)Rn$1(a,o,1,e);else if(typeof o=="string"&&typeof s=="number")Rn$1(a,o,s,e);else throw new TypeError("input is valid")}function $d(a){return{verbose:jt$1.verbose.bind(null,a),info:jt$1.info.bind(null,a),warning:jt$1.warning.bind(null,a),error:jt$1.error.bind(null,a),fatal:jt$1.fatal.bind(null,a)}}function Rn$1(a,e,o,s){let d=rn$1[s||""]||rn$1[""];vs$1[a]<vs$1[d.minimalSeverity]||(d.logDateTime&&(e=`${new Date().toISOString()}|${e}`),d.logSourceLocation,Cd$1[d.provider].log(a,e,s))}var Xo$1,Ko$1,vs$1,Cd$1,_s$1,rn$1,ce,Gn,Un,zn$1,Mn$1,at$1=E(()=>{Xo$1=class{log(a,e,o){}},Ko$1=class{log(a,e,o){console.log(`${this.color(a)} ${o?"\x1B[35m"+o+"\x1B[0m ":""}${e}`)}color(a){switch(a){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${a}`)}}},vs$1={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},Cd$1={none:new Xo$1,console:new Ko$1},_s$1={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},rn$1={"":_s$1},(a=>{function e(g,j){a("verbose",g,j)}a.verbose=e;function o(g,j){a("info",g,j)}a.info=o;function s(g,j){a("warning",g,j)}a.warning=s;function d(g,j){a("error",g,j)}a.error=d;function c(g,j){a("fatal",g,j)}a.fatal=c;function h(g){rn$1={},_("",g||{})}a.reset=h;function _(g,j){if(g==="*")h(j);else{let b=rn$1[g]||_s$1;rn$1[g]={provider:j.provider||b.provider,minimalSeverity:j.minimalSeverity||b.minimalSeverity,logDateTime:j.logDateTime===void 0?b.logDateTime:j.logDateTime,logSourceLocation:j.logSourceLocation===void 0?b.logSourceLocation:j.logSourceLocation}}}a.set=_;function bt(g){let j={};g.logLevel&&(j.minimalSeverity=g.logLevel),_("",j)}a.setWithEnv=bt})(jt$1||(jt$1={})),ce=jt$1,Gn=class{constructor(a,e,o,s,d,c){this.category=a,this.name=e,this.startTime=o,this.endCallback=s,this.timer=d,this.ctx=c}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},Un=class{constructor(a,e,o,s){this.category=a,this.name=e,this.startTime=o,this.endTime=s}},zn$1=class{constructor(a,e,o){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=a===void 0?1e4:a,this._flushBatchSize=e===void 0?10:e,this._flushIntervalInMilliseconds=o===void 0?5e3:o}static create(a){return a===void 0?new this:new this(a.maxNumberEvents,a.flushBatchSize,a.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=Mn$1(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(a,e,o,s){let d=this._started?this.begin(a,e,s):void 0,c=!1,h=o();if(h&&typeof h.then=="function")return c=!0,new Promise((_,bt)=>{h.then(async g=>{d&&await d.end(),_(g)},async g=>{d&&await d.end(),bt(g)})});if(!c&&d){let _=d.end();if(_&&typeof _.then=="function")return new Promise((bt,g)=>{_.then(()=>{bt(h)},j=>{g(j)})})}return h}begin(a,e,o){if(!this._started)throw new Error("profiler is not started yet");if(o===void 0){let s=Mn$1();return this.flush(s),new Gn(a,e,s,d=>this.endSync(d))}else{let s=o.beginTimer();return new Gn(a,e,0,async d=>this.end(d),s,o)}}async end(a){let e=await a.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new Un(a.category,a.name,a.startTime,e)),this.flush(e))}endSync(a){let e=Mn$1();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new Un(a.category,a.name,a.startTime,e)),this.flush(e))}logOneEvent(a){ce.verbose(`Profiler.${a.category}`,`${(a.endTime-a.startTime).toFixed(2)}ms on event '${a.name}' at ${a.endTime.toFixed(2)}`)}flush(a){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||a-this._flushTime>=this._flushIntervalInMilliseconds){for(let e=this._flushPointer;this._flushPointer<e+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=Mn$1()}}get started(){return this._started}},Mn$1=typeof performance<"u"&&performance.now?()=>performance.now():Date.now});function Os$1(a,e,o){for(let s of o){let d=s[0],c=s[1],h=s[2],_=s[3],bt=s[4];if(a.opType===d){for(let g of e)if((g.domain===c||g.domain==="ai.onnx"&&c==="")&&kd$1(g.version,h))return{opImpl:_,opInit:bt}}}throw new TypeError(`cannot resolve operator '${a.opType}' with opsets: ${e.map(s=>`${s.domain||"ai.onnx"} v${s.version}`).join(", ")}`)}function kd$1(a,e){if(e.endsWith("+")){let o=Number.parseInt(e.substring(0,e.length-1),10);return!isNaN(o)&&o<=a}else if(e.split("-").length===2){let o=e.split("-"),s=Number.parseInt(o[0],10),d=Number.parseInt(o[1],10);return!isNaN(s)&&!isNaN(d)&&s<=a&&a<=d}else return Number.parseInt(e,10)===a}var Is$1=E(()=>{}),Ss=me(a=>{a.__esModule=!0;var e=function(){function o(s){if(!s)throw new TypeError("Invalid argument; `value` has no value.");this.value=o.EMPTY,s&&o.isGuid(s)&&(this.value=s)}return o.isGuid=function(s){var d=s.toString();return s&&(s instanceof o||o.validator.test(d))},o.create=function(){return new o([o.gen(2),o.gen(1),o.gen(1),o.gen(1),o.gen(3)].join("-"))},o.createEmpty=function(){return new o("emptyguid")},o.parse=function(s){return new o(s)},o.raw=function(){return[o.gen(2),o.gen(1),o.gen(1),o.gen(1),o.gen(3)].join("-")},o.gen=function(s){for(var d="",c=0;c<s;c++)d+=((1+Math.random())*65536|0).toString(16).substring(1);return d},o.prototype.equals=function(s){return o.isGuid(s)&&this.value===s.toString()},o.prototype.isEmpty=function(){return this.value===o.EMPTY},o.prototype.toString=function(){return this.value},o.prototype.toJSON=function(){return{value:this.value}},o.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),o.EMPTY="00000000-0000-0000-0000-000000000000",o}();a.Guid=e});function be$1(a,e,o){this.low=a|0,this.high=e|0,this.unsigned=!!o}function je(a){return(a&&a.__isLong__)===!0}function As$1(a){var e=Math.clz32(a&-a);return a?31-e:e}function lr(a,e){var o,s,d;return e?(a>>>=0,(d=0<=a&&a<256)&&(s=Es$1[a],s)?s:(o=le(a,0,!0),d&&(Es$1[a]=o),o)):(a|=0,(d=-128<=a&&a<128)&&(s=Ps$1[a],s)?s:(o=le(a,a<0?-1:0,!1),d&&(Ps$1[a]=o),o))}function ut(a,e){if(isNaN(a))return e?Vt:xt$1;if(e){if(a<0)return Vt;if(a>=Cs$1)return Bs$1}else{if(a<=-Ls$1)return tt;if(a+1>=Ls$1)return ks$1}return a<0?ut(-a,e).neg():le(a%Fr|0,a/Fr|0,e)}function le(a,e,o){return new be$1(a,e,o)}function Qo$1(a,e,o){if(a.length===0)throw Error("empty string");if(typeof e=="number"?(o=e,e=!1):e=!!e,a==="NaN"||a==="Infinity"||a==="+Infinity"||a==="-Infinity")return e?Vt:xt$1;if(o=o||10,o<2||36<o)throw RangeError("radix");var s;if((s=a.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return Qo$1(a.substring(1),e,o).neg();for(var d=ut(Vn(o,8)),c=xt$1,h=0;h<a.length;h+=8){var _=Math.min(8,a.length-h),bt=parseInt(a.substring(h,h+_),o);if(_<8){var g=ut(Vn(o,_));c=c.mul(g).add(ut(bt))}else c=c.mul(d),c=c.add(ut(bt))}return c.unsigned=e,c}function wt(a,e){return typeof a=="number"?ut(a,e):typeof a=="string"?Qo$1(a,e):le(a.low,a.high,typeof e=="boolean"?e:a.unsigned)}var st$1,Ps$1,Es$1,Vn,Ds$1,Nd$1,Fr,Cs$1,Ls$1,Fs$1,xt$1,Vt,Lr,$s$1,Zo$1,ks$1,Bs$1,tt,$,Wt,ei=E(()=>{st$1=null;try{st$1=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}be$1.prototype.__isLong__,Object.defineProperty(be$1.prototype,"__isLong__",{value:!0}),be$1.isLong=je,Ps$1={},Es$1={},be$1.fromInt=lr,be$1.fromNumber=ut,be$1.fromBits=le,Vn=Math.pow,be$1.fromString=Qo$1,be$1.fromValue=wt,Ds$1=65536,Nd$1=1<<24,Fr=Ds$1*Ds$1,Cs$1=Fr*Fr,Ls$1=Cs$1/2,Fs$1=lr(Nd$1),xt$1=lr(0),be$1.ZERO=xt$1,Vt=lr(0,!0),be$1.UZERO=Vt,Lr=lr(1),be$1.ONE=Lr,$s$1=lr(1,!0),be$1.UONE=$s$1,Zo$1=lr(-1),be$1.NEG_ONE=Zo$1,ks$1=le(-1,2147483647,!1),be$1.MAX_VALUE=ks$1,Bs$1=le(-1,-1,!0),be$1.MAX_UNSIGNED_VALUE=Bs$1,tt=le(0,-2147483648,!1),be$1.MIN_VALUE=tt,$=be$1.prototype,$.toInt=function(){return this.unsigned?this.low>>>0:this.low},$.toNumber=function(){return this.unsigned?(this.high>>>0)*Fr+(this.low>>>0):this.high*Fr+(this.low>>>0)},$.toString=function(a){if(a=a||10,a<2||36<a)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(tt)){var e=ut(a),o=this.div(e),s=o.mul(e).sub(this);return o.toString(a)+s.toInt().toString(a)}else return"-"+this.neg().toString(a);for(var d=ut(Vn(a,6),this.unsigned),c=this,h="";;){var _=c.div(d),bt=c.sub(_.mul(d)).toInt()>>>0,g=bt.toString(a);if(c=_,c.isZero())return g+h;for(;g.length<6;)g="0"+g;h=""+g+h}},$.getHighBits=function(){return this.high},$.getHighBitsUnsigned=function(){return this.high>>>0},$.getLowBits=function(){return this.low},$.getLowBitsUnsigned=function(){return this.low>>>0},$.getNumBitsAbs=function(){if(this.isNegative())return this.eq(tt)?64:this.neg().getNumBitsAbs();for(var a=this.high!=0?this.high:this.low,e=31;e>0&&!(a&1<<e);e--);return this.high!=0?e+33:e+1},$.isZero=function(){return this.high===0&&this.low===0},$.eqz=$.isZero,$.isNegative=function(){return!this.unsigned&&this.high<0},$.isPositive=function(){return this.unsigned||this.high>=0},$.isOdd=function(){return(this.low&1)===1},$.isEven=function(){return(this.low&1)===0},$.equals=function(a){return je(a)||(a=wt(a)),this.unsigned!==a.unsigned&&this.high>>>31===1&&a.high>>>31===1?!1:this.high===a.high&&this.low===a.low},$.eq=$.equals,$.notEquals=function(a){return!this.eq(a)},$.neq=$.notEquals,$.ne=$.notEquals,$.lessThan=function(a){return this.comp(a)<0},$.lt=$.lessThan,$.lessThanOrEqual=function(a){return this.comp(a)<=0},$.lte=$.lessThanOrEqual,$.le=$.lessThanOrEqual,$.greaterThan=function(a){return this.comp(a)>0},$.gt=$.greaterThan,$.greaterThanOrEqual=function(a){return this.comp(a)>=0},$.gte=$.greaterThanOrEqual,$.ge=$.greaterThanOrEqual,$.compare=function(a){if(je(a)||(a=wt(a)),this.eq(a))return 0;var e=this.isNegative(),o=a.isNegative();return e&&!o?-1:!e&&o?1:this.unsigned?a.high>>>0>this.high>>>0||a.high===this.high&&a.low>>>0>this.low>>>0?-1:1:this.sub(a).isNegative()?-1:1},$.comp=$.compare,$.negate=function(){return!this.unsigned&&this.eq(tt)?tt:this.not().add(Lr)},$.neg=$.negate,$.add=function(a){je(a)||(a=wt(a));var e=this.high>>>16,o=this.high&65535,s=this.low>>>16,d=this.low&65535,c=a.high>>>16,h=a.high&65535,_=a.low>>>16,bt=a.low&65535,g=0,j=0,b=0,Et=0;return Et+=d+bt,b+=Et>>>16,Et&=65535,b+=s+_,j+=b>>>16,b&=65535,j+=o+h,g+=j>>>16,j&=65535,g+=e+c,g&=65535,le(b<<16|Et,g<<16|j,this.unsigned)},$.subtract=function(a){return je(a)||(a=wt(a)),this.add(a.neg())},$.sub=$.subtract,$.multiply=function(a){if(this.isZero())return this;if(je(a)||(a=wt(a)),st$1){var e=st$1.mul(this.low,this.high,a.low,a.high);return le(e,st$1.get_high(),this.unsigned)}if(a.isZero())return this.unsigned?Vt:xt$1;if(this.eq(tt))return a.isOdd()?tt:xt$1;if(a.eq(tt))return this.isOdd()?tt:xt$1;if(this.isNegative())return a.isNegative()?this.neg().mul(a.neg()):this.neg().mul(a).neg();if(a.isNegative())return this.mul(a.neg()).neg();if(this.lt(Fs$1)&&a.lt(Fs$1))return ut(this.toNumber()*a.toNumber(),this.unsigned);var o=this.high>>>16,s=this.high&65535,d=this.low>>>16,c=this.low&65535,h=a.high>>>16,_=a.high&65535,bt=a.low>>>16,g=a.low&65535,j=0,b=0,Et=0,It=0;return It+=c*g,Et+=It>>>16,It&=65535,Et+=d*g,b+=Et>>>16,Et&=65535,Et+=c*bt,b+=Et>>>16,Et&=65535,b+=s*g,j+=b>>>16,b&=65535,b+=d*bt,j+=b>>>16,b&=65535,b+=c*_,j+=b>>>16,b&=65535,j+=o*g+s*bt+d*_+c*h,j&=65535,le(Et<<16|It,j<<16|b,this.unsigned)},$.mul=$.multiply,$.divide=function(a){if(je(a)||(a=wt(a)),a.isZero())throw Error("division by zero");if(st$1){if(!this.unsigned&&this.high===-2147483648&&a.low===-1&&a.high===-1)return this;var e=(this.unsigned?st$1.div_u:st$1.div_s)(this.low,this.high,a.low,a.high);return le(e,st$1.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Vt:xt$1;var o,s,d;if(this.unsigned){if(a.unsigned||(a=a.toUnsigned()),a.gt(this))return Vt;if(a.gt(this.shru(1)))return $s$1;d=Vt}else{if(this.eq(tt)){if(a.eq(Lr)||a.eq(Zo$1))return tt;if(a.eq(tt))return Lr;var c=this.shr(1);return o=c.div(a).shl(1),o.eq(xt$1)?a.isNegative()?Lr:Zo$1:(s=this.sub(a.mul(o)),d=o.add(s.div(a)),d)}else if(a.eq(tt))return this.unsigned?Vt:xt$1;if(this.isNegative())return a.isNegative()?this.neg().div(a.neg()):this.neg().div(a).neg();if(a.isNegative())return this.div(a.neg()).neg();d=xt$1}for(s=this;s.gte(a);){o=Math.max(1,Math.floor(s.toNumber()/a.toNumber()));for(var h=Math.ceil(Math.log(o)/Math.LN2),_=h<=48?1:Vn(2,h-48),bt=ut(o),g=bt.mul(a);g.isNegative()||g.gt(s);)o-=_,bt=ut(o,this.unsigned),g=bt.mul(a);bt.isZero()&&(bt=Lr),d=d.add(bt),s=s.sub(g)}return d},$.div=$.divide,$.modulo=function(a){if(je(a)||(a=wt(a)),st$1){var e=(this.unsigned?st$1.rem_u:st$1.rem_s)(this.low,this.high,a.low,a.high);return le(e,st$1.get_high(),this.unsigned)}return this.sub(this.div(a).mul(a))},$.mod=$.modulo,$.rem=$.modulo,$.not=function(){return le(~this.low,~this.high,this.unsigned)},$.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},$.clz=$.countLeadingZeros,$.countTrailingZeros=function(){return this.low?As$1(this.low):As$1(this.high)+32},$.ctz=$.countTrailingZeros,$.and=function(a){return je(a)||(a=wt(a)),le(this.low&a.low,this.high&a.high,this.unsigned)},$.or=function(a){return je(a)||(a=wt(a)),le(this.low|a.low,this.high|a.high,this.unsigned)},$.xor=function(a){return je(a)||(a=wt(a)),le(this.low^a.low,this.high^a.high,this.unsigned)},$.shiftLeft=function(a){return je(a)&&(a=a.toInt()),(a&=63)===0?this:a<32?le(this.low<<a,this.high<<a|this.low>>>32-a,this.unsigned):le(0,this.low<<a-32,this.unsigned)},$.shl=$.shiftLeft,$.shiftRight=function(a){return je(a)&&(a=a.toInt()),(a&=63)===0?this:a<32?le(this.low>>>a|this.high<<32-a,this.high>>a,this.unsigned):le(this.high>>a-32,this.high>=0?0:-1,this.unsigned)},$.shr=$.shiftRight,$.shiftRightUnsigned=function(a){return je(a)&&(a=a.toInt()),(a&=63)===0?this:a<32?le(this.low>>>a|this.high<<32-a,this.high>>>a,this.unsigned):a===32?le(this.high,0,this.unsigned):le(this.high>>>a-32,0,this.unsigned)},$.shru=$.shiftRightUnsigned,$.shr_u=$.shiftRightUnsigned,$.rotateLeft=function(a){var e;return je(a)&&(a=a.toInt()),(a&=63)===0?this:a===32?le(this.high,this.low,this.unsigned):a<32?(e=32-a,le(this.low<<a|this.high>>>e,this.high<<a|this.low>>>e,this.unsigned)):(a-=32,e=32-a,le(this.high<<a|this.low>>>e,this.low<<a|this.high>>>e,this.unsigned))},$.rotl=$.rotateLeft,$.rotateRight=function(a){var e;return je(a)&&(a=a.toInt()),(a&=63)===0?this:a===32?le(this.high,this.low,this.unsigned):a<32?(e=32-a,le(this.high<<e|this.low>>>a,this.low<<e|this.high>>>a,this.unsigned)):(a-=32,e=32-a,le(this.low<<e|this.high>>>a,this.high<<e|this.low>>>a,this.unsigned))},$.rotr=$.rotateRight,$.toSigned=function(){return this.unsigned?le(this.low,this.high,!1):this},$.toUnsigned=function(){return this.unsigned?this:le(this.low,this.high,!0)},$.toBytes=function(a){return a?this.toBytesLE():this.toBytesBE()},$.toBytesLE=function(){var a=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,a&255,a>>>8&255,a>>>16&255,a>>>24]},$.toBytesBE=function(){var a=this.high,e=this.low;return[a>>>24,a>>>16&255,a>>>8&255,a&255,e>>>24,e>>>16&255,e>>>8&255,e&255]},be$1.fromBytes=function(a,e,o){return o?be$1.fromBytesLE(a,e):be$1.fromBytesBE(a,e)},be$1.fromBytesLE=function(a,e){return new be$1(a[0]|a[1]<<8|a[2]<<16|a[3]<<24,a[4]|a[5]<<8|a[6]<<16|a[7]<<24,e)},be$1.fromBytesBE=function(a,e){return new be$1(a[4]<<24|a[5]<<16|a[6]<<8|a[7],a[0]<<24|a[1]<<16|a[2]<<8|a[3],e)},Wt=be$1}),O,Wn=E(()=>{O={},O.Offset,O.Table,O.SIZEOF_SHORT=2,O.SIZEOF_INT=4,O.FILE_IDENTIFIER_LENGTH=4,O.SIZE_PREFIX_LENGTH=4,O.Encoding={UTF8_BYTES:1,UTF16_STRING:2},O.int32=new Int32Array(2),O.float32=new Float32Array(O.int32.buffer),O.float64=new Float64Array(O.int32.buffer),O.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,O.Long=function(a,e){this.low=a|0,this.high=e|0},O.Long.create=function(a,e){return a==0&&e==0?O.Long.ZERO:new O.Long(a,e)},O.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296},O.Long.prototype.equals=function(a){return this.low==a.low&&this.high==a.high},O.Long.ZERO=new O.Long(0,0),O.Builder=function(a){if(a)var e=a;else var e=1024;this.bb=O.ByteBuffer.allocate(e),this.space=e,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},O.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},O.Builder.prototype.forceDefaults=function(a){this.force_defaults=a},O.Builder.prototype.dataBuffer=function(){return this.bb},O.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},O.Builder.prototype.prep=function(a,e){a>this.minalign&&(this.minalign=a);for(var o=~(this.bb.capacity()-this.space+e)+1&a-1;this.space<o+a+e;){var s=this.bb.capacity();this.bb=O.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-s}this.pad(o)},O.Builder.prototype.pad=function(a){for(var e=0;e<a;e++)this.bb.writeInt8(--this.space,0)},O.Builder.prototype.writeInt8=function(a){this.bb.writeInt8(this.space-=1,a)},O.Builder.prototype.writeInt16=function(a){this.bb.writeInt16(this.space-=2,a)},O.Builder.prototype.writeInt32=function(a){this.bb.writeInt32(this.space-=4,a)},O.Builder.prototype.writeInt64=function(a){this.bb.writeInt64(this.space-=8,a)},O.Builder.prototype.writeFloat32=function(a){this.bb.writeFloat32(this.space-=4,a)},O.Builder.prototype.writeFloat64=function(a){this.bb.writeFloat64(this.space-=8,a)},O.Builder.prototype.addInt8=function(a){this.prep(1,0),this.writeInt8(a)},O.Builder.prototype.addInt16=function(a){this.prep(2,0),this.writeInt16(a)},O.Builder.prototype.addInt32=function(a){this.prep(4,0),this.writeInt32(a)},O.Builder.prototype.addInt64=function(a){this.prep(8,0),this.writeInt64(a)},O.Builder.prototype.addFloat32=function(a){this.prep(4,0),this.writeFloat32(a)},O.Builder.prototype.addFloat64=function(a){this.prep(8,0),this.writeFloat64(a)},O.Builder.prototype.addFieldInt8=function(a,e,o){(this.force_defaults||e!=o)&&(this.addInt8(e),this.slot(a))},O.Builder.prototype.addFieldInt16=function(a,e,o){(this.force_defaults||e!=o)&&(this.addInt16(e),this.slot(a))},O.Builder.prototype.addFieldInt32=function(a,e,o){(this.force_defaults||e!=o)&&(this.addInt32(e),this.slot(a))},O.Builder.prototype.addFieldInt64=function(a,e,o){(this.force_defaults||!e.equals(o))&&(this.addInt64(e),this.slot(a))},O.Builder.prototype.addFieldFloat32=function(a,e,o){(this.force_defaults||e!=o)&&(this.addFloat32(e),this.slot(a))},O.Builder.prototype.addFieldFloat64=function(a,e,o){(this.force_defaults||e!=o)&&(this.addFloat64(e),this.slot(a))},O.Builder.prototype.addFieldOffset=function(a,e,o){(this.force_defaults||e!=o)&&(this.addOffset(e),this.slot(a))},O.Builder.prototype.addFieldStruct=function(a,e,o){e!=o&&(this.nested(e),this.slot(a))},O.Builder.prototype.nested=function(a){if(a!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},O.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},O.Builder.prototype.slot=function(a){this.vtable[a]=this.offset()},O.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},O.Builder.growByteBuffer=function(a){var e=a.capacity();if(e&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var o=e<<1,s=O.ByteBuffer.allocate(o);return s.setPosition(o-e),s.bytes().set(a.bytes(),o-e),s},O.Builder.prototype.addOffset=function(a){this.prep(O.SIZEOF_INT,0),this.writeInt32(this.offset()-a+O.SIZEOF_INT)},O.Builder.prototype.startObject=function(a){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=a;for(var e=0;e<a;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()},O.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var a=this.offset(),e=this.vtable_in_use-1;e>=0&&this.vtable[e]==0;e--);for(var o=e+1;e>=0;e--)this.addInt16(this.vtable[e]!=0?a-this.vtable[e]:0);var s=2;this.addInt16(a-this.object_start);var d=(o+s)*O.SIZEOF_SHORT;this.addInt16(d);var c=0,h=this.space;e:for(e=0;e<this.vtables.length;e++){var _=this.bb.capacity()-this.vtables[e];if(d==this.bb.readInt16(_)){for(var bt=O.SIZEOF_SHORT;bt<d;bt+=O.SIZEOF_SHORT)if(this.bb.readInt16(h+bt)!=this.bb.readInt16(_+bt))continue e;c=this.vtables[e];break}}return c?(this.space=this.bb.capacity()-a,this.bb.writeInt32(this.space,c-a)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-a,this.offset()-a)),this.isNested=!1,a},O.Builder.prototype.finish=function(a,e,o){var s=o?O.SIZE_PREFIX_LENGTH:0;if(e){var d=e;if(this.prep(this.minalign,O.SIZEOF_INT+O.FILE_IDENTIFIER_LENGTH+s),d.length!=O.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+O.FILE_IDENTIFIER_LENGTH);for(var c=O.FILE_IDENTIFIER_LENGTH-1;c>=0;c--)this.writeInt8(d.charCodeAt(c))}this.prep(this.minalign,O.SIZEOF_INT+s),this.addOffset(a),s&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},O.Builder.prototype.finishSizePrefixed=function(a,e){this.finish(a,e,!0)},O.Builder.prototype.requiredField=function(a,e){var o=this.bb.capacity()-a,s=o-this.bb.readInt32(o),d=this.bb.readInt16(s+e)!=0;if(!d)throw new Error("FlatBuffers: field "+e+" must be set")},O.Builder.prototype.startVector=function(a,e,o){this.notNested(),this.vector_num_elems=e,this.prep(O.SIZEOF_INT,a*e),this.prep(o,a*e)},O.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},O.Builder.prototype.createString=function(a){if(a instanceof Uint8Array)var e=a;else for(var e=[],o=0;o<a.length;){var s,d=a.charCodeAt(o++);if(d<55296||d>=56320)s=d;else{var c=a.charCodeAt(o++);s=(d<<10)+c+-56613888}s<128?e.push(s):(s<2048?e.push(s>>6&31|192):(s<65536?e.push(s>>12&15|224):e.push(s>>18&7|240,s>>12&63|128),e.push(s>>6&63|128)),e.push(s&63|128))}this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length);for(var o=0,h=this.space,_=this.bb.bytes();o<e.length;o++)_[h++]=e[o];return this.endVector()},O.Builder.prototype.createLong=function(a,e){return O.Long.create(a,e)},O.ByteBuffer=function(a){this.bytes_=a,this.position_=0},O.ByteBuffer.allocate=function(a){return new O.ByteBuffer(new Uint8Array(a))},O.ByteBuffer.prototype.clear=function(){this.position_=0},O.ByteBuffer.prototype.bytes=function(){return this.bytes_},O.ByteBuffer.prototype.position=function(){return this.position_},O.ByteBuffer.prototype.setPosition=function(a){this.position_=a},O.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},O.ByteBuffer.prototype.readInt8=function(a){return this.readUint8(a)<<24>>24},O.ByteBuffer.prototype.readUint8=function(a){return this.bytes_[a]},O.ByteBuffer.prototype.readInt16=function(a){return this.readUint16(a)<<16>>16},O.ByteBuffer.prototype.readUint16=function(a){return this.bytes_[a]|this.bytes_[a+1]<<8},O.ByteBuffer.prototype.readInt32=function(a){return this.bytes_[a]|this.bytes_[a+1]<<8|this.bytes_[a+2]<<16|this.bytes_[a+3]<<24},O.ByteBuffer.prototype.readUint32=function(a){return this.readInt32(a)>>>0},O.ByteBuffer.prototype.readInt64=function(a){return new O.Long(this.readInt32(a),this.readInt32(a+4))},O.ByteBuffer.prototype.readUint64=function(a){return new O.Long(this.readUint32(a),this.readUint32(a+4))},O.ByteBuffer.prototype.readFloat32=function(a){return O.int32[0]=this.readInt32(a),O.float32[0]},O.ByteBuffer.prototype.readFloat64=function(a){return O.int32[O.isLittleEndian?0:1]=this.readInt32(a),O.int32[O.isLittleEndian?1:0]=this.readInt32(a+4),O.float64[0]},O.ByteBuffer.prototype.writeInt8=function(a,e){this.bytes_[a]=e},O.ByteBuffer.prototype.writeUint8=function(a,e){this.bytes_[a]=e},O.ByteBuffer.prototype.writeInt16=function(a,e){this.bytes_[a]=e,this.bytes_[a+1]=e>>8},O.ByteBuffer.prototype.writeUint16=function(a,e){this.bytes_[a]=e,this.bytes_[a+1]=e>>8},O.ByteBuffer.prototype.writeInt32=function(a,e){this.bytes_[a]=e,this.bytes_[a+1]=e>>8,this.bytes_[a+2]=e>>16,this.bytes_[a+3]=e>>24},O.ByteBuffer.prototype.writeUint32=function(a,e){this.bytes_[a]=e,this.bytes_[a+1]=e>>8,this.bytes_[a+2]=e>>16,this.bytes_[a+3]=e>>24},O.ByteBuffer.prototype.writeInt64=function(a,e){this.writeInt32(a,e.low),this.writeInt32(a+4,e.high)},O.ByteBuffer.prototype.writeUint64=function(a,e){this.writeUint32(a,e.low),this.writeUint32(a+4,e.high)},O.ByteBuffer.prototype.writeFloat32=function(a,e){O.float32[0]=e,this.writeInt32(a,O.int32[0])},O.ByteBuffer.prototype.writeFloat64=function(a,e){O.float64[0]=e,this.writeInt32(a,O.int32[O.isLittleEndian?0:1]),this.writeInt32(a+4,O.int32[O.isLittleEndian?1:0])},O.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+O.SIZEOF_INT+O.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var a="",e=0;e<O.FILE_IDENTIFIER_LENGTH;e++)a+=String.fromCharCode(this.readInt8(this.position_+O.SIZEOF_INT+e));return a},O.ByteBuffer.prototype.__offset=function(a,e){var o=a-this.readInt32(a);return e<this.readInt16(o)?this.readInt16(o+e):0},O.ByteBuffer.prototype.__union=function(a,e){return a.bb_pos=e+this.readInt32(e),a.bb=this,a},O.ByteBuffer.prototype.__string=function(a,e){a+=this.readInt32(a);var o=this.readInt32(a),s="",d=0;if(a+=O.SIZEOF_INT,e===O.Encoding.UTF8_BYTES)return this.bytes_.subarray(a,a+o);for(;d<o;){var c,h=this.readUint8(a+d++);if(h<192)c=h;else{var _=this.readUint8(a+d++);if(h<224)c=(h&31)<<6|_&63;else{var bt=this.readUint8(a+d++);if(h<240)c=(h&15)<<12|(_&63)<<6|bt&63;else{var g=this.readUint8(a+d++);c=(h&7)<<18|(_&63)<<12|(bt&63)<<6|g&63}}}c<65536?s+=String.fromCharCode(c):(c-=65536,s+=String.fromCharCode((c>>10)+55296,(c&1023)+56320))}return s},O.ByteBuffer.prototype.__indirect=function(a){return a+this.readInt32(a)},O.ByteBuffer.prototype.__vector=function(a){return a+this.readInt32(a)+O.SIZEOF_INT},O.ByteBuffer.prototype.__vector_len=function(a){return this.readInt32(a+this.readInt32(a))},O.ByteBuffer.prototype.__has_identifier=function(a){if(a.length!=O.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+O.FILE_IDENTIFIER_LENGTH);for(var e=0;e<O.FILE_IDENTIFIER_LENGTH;e++)if(a.charCodeAt(e)!=this.readInt8(this.position_+O.SIZEOF_INT+e))return!1;return!0},O.ByteBuffer.prototype.createLong=function(a,e){return O.Long.create(a,e)}}),W,nn$1=E(()=>{Wn(),(a=>{(e=>{(o=>{(s=>(s[s.UNDEFINED=0]="UNDEFINED",s[s.FLOAT=1]="FLOAT",s[s.INT=2]="INT",s[s.STRING=3]="STRING",s[s.TENSOR=4]="TENSOR",s[s.GRAPH=5]="GRAPH",s[s.FLOATS=6]="FLOATS",s[s.INTS=7]="INTS",s[s.STRINGS=8]="STRINGS",s[s.TENSORS=9]="TENSORS",s[s.GRAPHS=10]="GRAPHS",s[s.SPARSE_TENSOR=11]="SPARSE_TENSOR",s[s.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(o.AttributeType||(o.AttributeType={}))})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{(s=>(s[s.UNKNOWN=0]="UNKNOWN",s[s.VALUE=1]="VALUE",s[s.PARAM=2]="PARAM"))(o.DimensionValueType||(o.DimensionValueType={}))})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{(s=>(s[s.UNDEFINED=0]="UNDEFINED",s[s.FLOAT=1]="FLOAT",s[s.UINT8=2]="UINT8",s[s.INT8=3]="INT8",s[s.UINT16=4]="UINT16",s[s.INT16=5]="INT16",s[s.INT32=6]="INT32",s[s.INT64=7]="INT64",s[s.STRING=8]="STRING",s[s.BOOL=9]="BOOL",s[s.FLOAT16=10]="FLOAT16",s[s.DOUBLE=11]="DOUBLE",s[s.UINT32=12]="UINT32",s[s.UINT64=13]="UINT64",s[s.COMPLEX64=14]="COMPLEX64",s[s.COMPLEX128=15]="COMPLEX128",s[s.BFLOAT16=16]="BFLOAT16",s[s.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",s[s.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",s[s.FLOAT8E5M2=19]="FLOAT8E5M2",s[s.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(o.TensorDataType||(o.TensorDataType={}))})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{(s=>(s[s.Primitive=0]="Primitive",s[s.Fused=1]="Fused"))(o.NodeType||(o.NodeType={}))})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{(s=>(s[s.NONE=0]="NONE",s[s.tensor_type=1]="tensor_type",s[s.sequence_type=2]="sequence_type",s[s.map_type=3]="map_type"))(o.TypeInfoValue||(o.TypeInfoValue={}))})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsShape(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsShape(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}dim(c,h){let _=this.bb.__offset(this.bb_pos,4);return _?(h||new a.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+c*4),this.bb):null}dimLength(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.__vector_len(this.bb_pos+c):0}static startShape(c){c.startObject(1)}static addDim(c,h){c.addFieldOffset(0,h,0)}static createDimVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startDimVector(c,h){c.startVector(4,h,4)}static endShape(c){return c.endObject()}static createShape(c,h){return s.startShape(c),s.addDim(c,h),s.endShape(c)}}o.Shape=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsDimension(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsDimension(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}value(c){let h=this.bb.__offset(this.bb_pos,4);return h?(c||new a.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+h),this.bb):null}denotation(c){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__string(this.bb_pos+h,c):null}static startDimension(c){c.startObject(2)}static addValue(c,h){c.addFieldOffset(0,h,0)}static addDenotation(c,h){c.addFieldOffset(1,h,0)}static endDimension(c){return c.endObject()}static createDimension(c,h,_){return s.startDimension(c),s.addValue(c,h),s.addDenotation(c,_),s.endDimension(c)}}o.Dimension=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsDimensionValue(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsDimensionValue(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}dimType(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.readInt8(this.bb_pos+c):0}dimValue(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.readInt64(this.bb_pos+c):this.bb.createLong(0,0)}dimParam(c){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.__string(this.bb_pos+h,c):null}static startDimensionValue(c){c.startObject(3)}static addDimType(c,h){c.addFieldInt8(0,h,0)}static addDimValue(c,h){c.addFieldInt64(1,h,c.createLong(0,0))}static addDimParam(c,h){c.addFieldOffset(2,h,0)}static endDimensionValue(c){return c.endObject()}static createDimensionValue(c,h,_,bt){return s.startDimensionValue(c),s.addDimType(c,h),s.addDimValue(c,_),s.addDimParam(c,bt),s.endDimensionValue(c)}}o.DimensionValue=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsTensorTypeAndShape(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsTensorTypeAndShape(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}elemType(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.readInt32(this.bb_pos+c):0}shape(c){let h=this.bb.__offset(this.bb_pos,6);return h?(c||new a.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+h),this.bb):null}static startTensorTypeAndShape(c){c.startObject(2)}static addElemType(c,h){c.addFieldInt32(0,h,0)}static addShape(c,h){c.addFieldOffset(1,h,0)}static endTensorTypeAndShape(c){return c.endObject()}static createTensorTypeAndShape(c,h,_){return s.startTensorTypeAndShape(c),s.addElemType(c,h),s.addShape(c,_),s.endTensorTypeAndShape(c)}}o.TensorTypeAndShape=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsMapType(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsMapType(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}keyType(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.readInt32(this.bb_pos+c):0}valueType(c){let h=this.bb.__offset(this.bb_pos,6);return h?(c||new a.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+h),this.bb):null}static startMapType(c){c.startObject(2)}static addKeyType(c,h){c.addFieldInt32(0,h,0)}static addValueType(c,h){c.addFieldOffset(1,h,0)}static endMapType(c){return c.endObject()}static createMapType(c,h,_){return s.startMapType(c),s.addKeyType(c,h),s.addValueType(c,_),s.endMapType(c)}}o.MapType=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsSequenceType(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsSequenceType(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}elemType(c){let h=this.bb.__offset(this.bb_pos,4);return h?(c||new a.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+h),this.bb):null}static startSequenceType(c){c.startObject(1)}static addElemType(c,h){c.addFieldOffset(0,h,0)}static endSequenceType(c){return c.endObject()}static createSequenceType(c,h){return s.startSequenceType(c),s.addElemType(c,h),s.endSequenceType(c)}}o.SequenceType=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(c,h,_,bt){return c.prep(4,12),c.writeInt32(bt),c.writeInt32(_),c.writeInt32(h),c.offset()}}o.EdgeEnd=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsNodeEdge(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsNodeEdge(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}nodeIndex(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.readUint32(this.bb_pos+c):0}inputEdges(c,h){let _=this.bb.__offset(this.bb_pos,6);return _?(h||new a.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+_)+c*12,this.bb):null}inputEdgesLength(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__vector_len(this.bb_pos+c):0}outputEdges(c,h){let _=this.bb.__offset(this.bb_pos,8);return _?(h||new a.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+_)+c*12,this.bb):null}outputEdgesLength(){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.__vector_len(this.bb_pos+c):0}static startNodeEdge(c){c.startObject(3)}static addNodeIndex(c,h){c.addFieldInt32(0,h,0)}static addInputEdges(c,h){c.addFieldOffset(1,h,0)}static startInputEdgesVector(c,h){c.startVector(12,h,4)}static addOutputEdges(c,h){c.addFieldOffset(2,h,0)}static startOutputEdgesVector(c,h){c.startVector(12,h,4)}static endNodeEdge(c){return c.endObject()}static createNodeEdge(c,h,_,bt){return s.startNodeEdge(c),s.addNodeIndex(c,h),s.addInputEdges(c,_),s.addOutputEdges(c,bt),s.endNodeEdge(c)}}o.NodeEdge=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsNode(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsNode(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}name(c){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.__string(this.bb_pos+h,c):null}docString(c){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__string(this.bb_pos+h,c):null}domain(c){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.__string(this.bb_pos+h,c):null}sinceVersion(){let c=this.bb.__offset(this.bb_pos,10);return c?this.bb.readInt32(this.bb_pos+c):0}index(){let c=this.bb.__offset(this.bb_pos,12);return c?this.bb.readUint32(this.bb_pos+c):0}opType(c){let h=this.bb.__offset(this.bb_pos,14);return h?this.bb.__string(this.bb_pos+h,c):null}type(){let c=this.bb.__offset(this.bb_pos,16);return c?this.bb.readInt32(this.bb_pos+c):0}executionProviderType(c){let h=this.bb.__offset(this.bb_pos,18);return h?this.bb.__string(this.bb_pos+h,c):null}inputs(c,h){let _=this.bb.__offset(this.bb_pos,20);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+c*4,h):null}inputsLength(){let c=this.bb.__offset(this.bb_pos,20);return c?this.bb.__vector_len(this.bb_pos+c):0}outputs(c,h){let _=this.bb.__offset(this.bb_pos,22);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+c*4,h):null}outputsLength(){let c=this.bb.__offset(this.bb_pos,22);return c?this.bb.__vector_len(this.bb_pos+c):0}attributes(c,h){let _=this.bb.__offset(this.bb_pos,24);return _?(h||new a.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+c*4),this.bb):null}attributesLength(){let c=this.bb.__offset(this.bb_pos,24);return c?this.bb.__vector_len(this.bb_pos+c):0}inputArgCounts(c){let h=this.bb.__offset(this.bb_pos,26);return h?this.bb.readInt32(this.bb.__vector(this.bb_pos+h)+c*4):0}inputArgCountsLength(){let c=this.bb.__offset(this.bb_pos,26);return c?this.bb.__vector_len(this.bb_pos+c):0}inputArgCountsArray(){let c=this.bb.__offset(this.bb_pos,26);return c?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+c),this.bb.__vector_len(this.bb_pos+c)):null}implicitInputs(c,h){let _=this.bb.__offset(this.bb_pos,28);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+c*4,h):null}implicitInputsLength(){let c=this.bb.__offset(this.bb_pos,28);return c?this.bb.__vector_len(this.bb_pos+c):0}static startNode(c){c.startObject(13)}static addName(c,h){c.addFieldOffset(0,h,0)}static addDocString(c,h){c.addFieldOffset(1,h,0)}static addDomain(c,h){c.addFieldOffset(2,h,0)}static addSinceVersion(c,h){c.addFieldInt32(3,h,0)}static addIndex(c,h){c.addFieldInt32(4,h,0)}static addOpType(c,h){c.addFieldOffset(5,h,0)}static addType(c,h){c.addFieldInt32(6,h,0)}static addExecutionProviderType(c,h){c.addFieldOffset(7,h,0)}static addInputs(c,h){c.addFieldOffset(8,h,0)}static createInputsVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startInputsVector(c,h){c.startVector(4,h,4)}static addOutputs(c,h){c.addFieldOffset(9,h,0)}static createOutputsVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startOutputsVector(c,h){c.startVector(4,h,4)}static addAttributes(c,h){c.addFieldOffset(10,h,0)}static createAttributesVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startAttributesVector(c,h){c.startVector(4,h,4)}static addInputArgCounts(c,h){c.addFieldOffset(11,h,0)}static createInputArgCountsVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addInt32(h[_]);return c.endVector()}static startInputArgCountsVector(c,h){c.startVector(4,h,4)}static addImplicitInputs(c,h){c.addFieldOffset(12,h,0)}static createImplicitInputsVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startImplicitInputsVector(c,h){c.startVector(4,h,4)}static endNode(c){return c.endObject()}static createNode(c,h,_,bt,g,j,b,Et,It,zt,er,Hn,Qt,cr){return s.startNode(c),s.addName(c,h),s.addDocString(c,_),s.addDomain(c,bt),s.addSinceVersion(c,g),s.addIndex(c,j),s.addOpType(c,b),s.addType(c,Et),s.addExecutionProviderType(c,It),s.addInputs(c,zt),s.addOutputs(c,er),s.addAttributes(c,Hn),s.addInputArgCounts(c,Qt),s.addImplicitInputs(c,cr),s.endNode(c)}}o.Node=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsValueInfo(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsValueInfo(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}name(c){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.__string(this.bb_pos+h,c):null}docString(c){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__string(this.bb_pos+h,c):null}type(c){let h=this.bb.__offset(this.bb_pos,8);return h?(c||new a.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+h),this.bb):null}static startValueInfo(c){c.startObject(3)}static addName(c,h){c.addFieldOffset(0,h,0)}static addDocString(c,h){c.addFieldOffset(1,h,0)}static addType(c,h){c.addFieldOffset(2,h,0)}static endValueInfo(c){return c.endObject()}static createValueInfo(c,h,_,bt){return s.startValueInfo(c),s.addName(c,h),s.addDocString(c,_),s.addType(c,bt),s.endValueInfo(c)}}o.ValueInfo=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsTypeInfo(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsTypeInfo(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}denotation(c){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.__string(this.bb_pos+h,c):null}valueType(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.readUint8(this.bb_pos+c):0}value(c){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.__union(c,this.bb_pos+h):null}static startTypeInfo(c){c.startObject(3)}static addDenotation(c,h){c.addFieldOffset(0,h,0)}static addValueType(c,h){c.addFieldInt8(1,h,0)}static addValue(c,h){c.addFieldOffset(2,h,0)}static endTypeInfo(c){return c.endObject()}static createTypeInfo(c,h,_,bt){return s.startTypeInfo(c),s.addDenotation(c,h),s.addValueType(c,_),s.addValue(c,bt),s.endTypeInfo(c)}}o.TypeInfo=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsOperatorSetId(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsOperatorSetId(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}domain(c){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.__string(this.bb_pos+h,c):null}version(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.readInt64(this.bb_pos+c):this.bb.createLong(0,0)}static startOperatorSetId(c){c.startObject(2)}static addDomain(c,h){c.addFieldOffset(0,h,0)}static addVersion(c,h){c.addFieldInt64(1,h,c.createLong(0,0))}static endOperatorSetId(c){return c.endObject()}static createOperatorSetId(c,h,_){return s.startOperatorSetId(c),s.addDomain(c,h),s.addVersion(c,_),s.endOperatorSetId(c)}}o.OperatorSetId=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsTensor(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsTensor(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}name(c){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.__string(this.bb_pos+h,c):null}docString(c){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__string(this.bb_pos+h,c):null}dims(c){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.readInt64(this.bb.__vector(this.bb_pos+h)+c*8):this.bb.createLong(0,0)}dimsLength(){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.__vector_len(this.bb_pos+c):0}dataType(){let c=this.bb.__offset(this.bb_pos,10);return c?this.bb.readInt32(this.bb_pos+c):0}rawData(c){let h=this.bb.__offset(this.bb_pos,12);return h?this.bb.readUint8(this.bb.__vector(this.bb_pos+h)+c):0}rawDataLength(){let c=this.bb.__offset(this.bb_pos,12);return c?this.bb.__vector_len(this.bb_pos+c):0}rawDataArray(){let c=this.bb.__offset(this.bb_pos,12);return c?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+c),this.bb.__vector_len(this.bb_pos+c)):null}stringData(c,h){let _=this.bb.__offset(this.bb_pos,14);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+c*4,h):null}stringDataLength(){let c=this.bb.__offset(this.bb_pos,14);return c?this.bb.__vector_len(this.bb_pos+c):0}static startTensor(c){c.startObject(6)}static addName(c,h){c.addFieldOffset(0,h,0)}static addDocString(c,h){c.addFieldOffset(1,h,0)}static addDims(c,h){c.addFieldOffset(2,h,0)}static createDimsVector(c,h){c.startVector(8,h.length,8);for(let _=h.length-1;_>=0;_--)c.addInt64(h[_]);return c.endVector()}static startDimsVector(c,h){c.startVector(8,h,8)}static addDataType(c,h){c.addFieldInt32(3,h,0)}static addRawData(c,h){c.addFieldOffset(4,h,0)}static createRawDataVector(c,h){c.startVector(1,h.length,1);for(let _=h.length-1;_>=0;_--)c.addInt8(h[_]);return c.endVector()}static startRawDataVector(c,h){c.startVector(1,h,1)}static addStringData(c,h){c.addFieldOffset(5,h,0)}static createStringDataVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startStringDataVector(c,h){c.startVector(4,h,4)}static endTensor(c){return c.endObject()}static createTensor(c,h,_,bt,g,j,b){return s.startTensor(c),s.addName(c,h),s.addDocString(c,_),s.addDims(c,bt),s.addDataType(c,g),s.addRawData(c,j),s.addStringData(c,b),s.endTensor(c)}}o.Tensor=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsSparseTensor(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsSparseTensor(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}values(c){let h=this.bb.__offset(this.bb_pos,4);return h?(c||new a.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+h),this.bb):null}indices(c){let h=this.bb.__offset(this.bb_pos,6);return h?(c||new a.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+h),this.bb):null}dims(c){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.readInt64(this.bb.__vector(this.bb_pos+h)+c*8):this.bb.createLong(0,0)}dimsLength(){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.__vector_len(this.bb_pos+c):0}static startSparseTensor(c){c.startObject(3)}static addValues(c,h){c.addFieldOffset(0,h,0)}static addIndices(c,h){c.addFieldOffset(1,h,0)}static addDims(c,h){c.addFieldOffset(2,h,0)}static createDimsVector(c,h){c.startVector(8,h.length,8);for(let _=h.length-1;_>=0;_--)c.addInt64(h[_]);return c.endVector()}static startDimsVector(c,h){c.startVector(8,h,8)}static endSparseTensor(c){return c.endObject()}static createSparseTensor(c,h,_,bt){return s.startSparseTensor(c),s.addValues(c,h),s.addIndices(c,_),s.addDims(c,bt),s.endSparseTensor(c)}}o.SparseTensor=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsAttribute(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsAttribute(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}name(c){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.__string(this.bb_pos+h,c):null}docString(c){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.__string(this.bb_pos+h,c):null}type(){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.readInt32(this.bb_pos+c):0}f(){let c=this.bb.__offset(this.bb_pos,10);return c?this.bb.readFloat32(this.bb_pos+c):0}i(){let c=this.bb.__offset(this.bb_pos,12);return c?this.bb.readInt64(this.bb_pos+c):this.bb.createLong(0,0)}s(c){let h=this.bb.__offset(this.bb_pos,14);return h?this.bb.__string(this.bb_pos+h,c):null}t(c){let h=this.bb.__offset(this.bb_pos,16);return h?(c||new a.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+h),this.bb):null}g(c){let h=this.bb.__offset(this.bb_pos,18);return h?(c||new a.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+h),this.bb):null}floats(c){let h=this.bb.__offset(this.bb_pos,20);return h?this.bb.readFloat32(this.bb.__vector(this.bb_pos+h)+c*4):0}floatsLength(){let c=this.bb.__offset(this.bb_pos,20);return c?this.bb.__vector_len(this.bb_pos+c):0}floatsArray(){let c=this.bb.__offset(this.bb_pos,20);return c?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+c),this.bb.__vector_len(this.bb_pos+c)):null}ints(c){let h=this.bb.__offset(this.bb_pos,22);return h?this.bb.readInt64(this.bb.__vector(this.bb_pos+h)+c*8):this.bb.createLong(0,0)}intsLength(){let c=this.bb.__offset(this.bb_pos,22);return c?this.bb.__vector_len(this.bb_pos+c):0}strings(c,h){let _=this.bb.__offset(this.bb_pos,24);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+c*4,h):null}stringsLength(){let c=this.bb.__offset(this.bb_pos,24);return c?this.bb.__vector_len(this.bb_pos+c):0}tensors(c,h){let _=this.bb.__offset(this.bb_pos,26);return _?(h||new a.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+c*4),this.bb):null}tensorsLength(){let c=this.bb.__offset(this.bb_pos,26);return c?this.bb.__vector_len(this.bb_pos+c):0}graphs(c,h){let _=this.bb.__offset(this.bb_pos,28);return _?(h||new a.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+c*4),this.bb):null}graphsLength(){let c=this.bb.__offset(this.bb_pos,28);return c?this.bb.__vector_len(this.bb_pos+c):0}static startAttribute(c){c.startObject(13)}static addName(c,h){c.addFieldOffset(0,h,0)}static addDocString(c,h){c.addFieldOffset(1,h,0)}static addType(c,h){c.addFieldInt32(2,h,0)}static addF(c,h){c.addFieldFloat32(3,h,0)}static addI(c,h){c.addFieldInt64(4,h,c.createLong(0,0))}static addS(c,h){c.addFieldOffset(5,h,0)}static addT(c,h){c.addFieldOffset(6,h,0)}static addG(c,h){c.addFieldOffset(7,h,0)}static addFloats(c,h){c.addFieldOffset(8,h,0)}static createFloatsVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addFloat32(h[_]);return c.endVector()}static startFloatsVector(c,h){c.startVector(4,h,4)}static addInts(c,h){c.addFieldOffset(9,h,0)}static createIntsVector(c,h){c.startVector(8,h.length,8);for(let _=h.length-1;_>=0;_--)c.addInt64(h[_]);return c.endVector()}static startIntsVector(c,h){c.startVector(8,h,8)}static addStrings(c,h){c.addFieldOffset(10,h,0)}static createStringsVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startStringsVector(c,h){c.startVector(4,h,4)}static addTensors(c,h){c.addFieldOffset(11,h,0)}static createTensorsVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startTensorsVector(c,h){c.startVector(4,h,4)}static addGraphs(c,h){c.addFieldOffset(12,h,0)}static createGraphsVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startGraphsVector(c,h){c.startVector(4,h,4)}static endAttribute(c){return c.endObject()}static createAttribute(c,h,_,bt,g,j,b,Et,It,zt,er,Hn,Qt,cr){return s.startAttribute(c),s.addName(c,h),s.addDocString(c,_),s.addType(c,bt),s.addF(c,g),s.addI(c,j),s.addS(c,b),s.addT(c,Et),s.addG(c,It),s.addFloats(c,zt),s.addInts(c,er),s.addStrings(c,Hn),s.addTensors(c,Qt),s.addGraphs(c,cr),s.endAttribute(c)}}o.Attribute=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsGraph(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsGraph(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}initializers(c,h){let _=this.bb.__offset(this.bb_pos,4);return _?(h||new a.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+c*4),this.bb):null}initializersLength(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.__vector_len(this.bb_pos+c):0}nodeArgs(c,h){let _=this.bb.__offset(this.bb_pos,6);return _?(h||new a.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+c*4),this.bb):null}nodeArgsLength(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__vector_len(this.bb_pos+c):0}nodes(c,h){let _=this.bb.__offset(this.bb_pos,8);return _?(h||new a.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+c*4),this.bb):null}nodesLength(){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.__vector_len(this.bb_pos+c):0}maxNodeIndex(){let c=this.bb.__offset(this.bb_pos,10);return c?this.bb.readUint32(this.bb_pos+c):0}nodeEdges(c,h){let _=this.bb.__offset(this.bb_pos,12);return _?(h||new a.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+c*4),this.bb):null}nodeEdgesLength(){let c=this.bb.__offset(this.bb_pos,12);return c?this.bb.__vector_len(this.bb_pos+c):0}inputs(c,h){let _=this.bb.__offset(this.bb_pos,14);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+c*4,h):null}inputsLength(){let c=this.bb.__offset(this.bb_pos,14);return c?this.bb.__vector_len(this.bb_pos+c):0}outputs(c,h){let _=this.bb.__offset(this.bb_pos,16);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+c*4,h):null}outputsLength(){let c=this.bb.__offset(this.bb_pos,16);return c?this.bb.__vector_len(this.bb_pos+c):0}sparseInitializers(c,h){let _=this.bb.__offset(this.bb_pos,18);return _?(h||new a.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+c*4),this.bb):null}sparseInitializersLength(){let c=this.bb.__offset(this.bb_pos,18);return c?this.bb.__vector_len(this.bb_pos+c):0}static startGraph(c){c.startObject(8)}static addInitializers(c,h){c.addFieldOffset(0,h,0)}static createInitializersVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startInitializersVector(c,h){c.startVector(4,h,4)}static addNodeArgs(c,h){c.addFieldOffset(1,h,0)}static createNodeArgsVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startNodeArgsVector(c,h){c.startVector(4,h,4)}static addNodes(c,h){c.addFieldOffset(2,h,0)}static createNodesVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startNodesVector(c,h){c.startVector(4,h,4)}static addMaxNodeIndex(c,h){c.addFieldInt32(3,h,0)}static addNodeEdges(c,h){c.addFieldOffset(4,h,0)}static createNodeEdgesVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startNodeEdgesVector(c,h){c.startVector(4,h,4)}static addInputs(c,h){c.addFieldOffset(5,h,0)}static createInputsVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startInputsVector(c,h){c.startVector(4,h,4)}static addOutputs(c,h){c.addFieldOffset(6,h,0)}static createOutputsVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startOutputsVector(c,h){c.startVector(4,h,4)}static addSparseInitializers(c,h){c.addFieldOffset(7,h,0)}static createSparseInitializersVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startSparseInitializersVector(c,h){c.startVector(4,h,4)}static endGraph(c){return c.endObject()}static createGraph(c,h,_,bt,g,j,b,Et,It){return s.startGraph(c),s.addInitializers(c,h),s.addNodeArgs(c,_),s.addNodes(c,bt),s.addMaxNodeIndex(c,g),s.addNodeEdges(c,j),s.addInputs(c,b),s.addOutputs(c,Et),s.addSparseInitializers(c,It),s.endGraph(c)}}o.Graph=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsModel(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsModel(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}irVersion(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.readInt64(this.bb_pos+c):this.bb.createLong(0,0)}opsetImport(c,h){let _=this.bb.__offset(this.bb_pos,6);return _?(h||new a.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+c*4),this.bb):null}opsetImportLength(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__vector_len(this.bb_pos+c):0}producerName(c){let h=this.bb.__offset(this.bb_pos,8);return h?this.bb.__string(this.bb_pos+h,c):null}producerVersion(c){let h=this.bb.__offset(this.bb_pos,10);return h?this.bb.__string(this.bb_pos+h,c):null}domain(c){let h=this.bb.__offset(this.bb_pos,12);return h?this.bb.__string(this.bb_pos+h,c):null}modelVersion(){let c=this.bb.__offset(this.bb_pos,14);return c?this.bb.readInt64(this.bb_pos+c):this.bb.createLong(0,0)}docString(c){let h=this.bb.__offset(this.bb_pos,16);return h?this.bb.__string(this.bb_pos+h,c):null}graph(c){let h=this.bb.__offset(this.bb_pos,18);return h?(c||new a.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+h),this.bb):null}graphDocString(c){let h=this.bb.__offset(this.bb_pos,20);return h?this.bb.__string(this.bb_pos+h,c):null}static startModel(c){c.startObject(9)}static addIrVersion(c,h){c.addFieldInt64(0,h,c.createLong(0,0))}static addOpsetImport(c,h){c.addFieldOffset(1,h,0)}static createOpsetImportVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startOpsetImportVector(c,h){c.startVector(4,h,4)}static addProducerName(c,h){c.addFieldOffset(2,h,0)}static addProducerVersion(c,h){c.addFieldOffset(3,h,0)}static addDomain(c,h){c.addFieldOffset(4,h,0)}static addModelVersion(c,h){c.addFieldInt64(5,h,c.createLong(0,0))}static addDocString(c,h){c.addFieldOffset(6,h,0)}static addGraph(c,h){c.addFieldOffset(7,h,0)}static addGraphDocString(c,h){c.addFieldOffset(8,h,0)}static endModel(c){return c.endObject()}static createModel(c,h,_,bt,g,j,b,Et,It,zt){return s.startModel(c),s.addIrVersion(c,h),s.addOpsetImport(c,_),s.addProducerName(c,bt),s.addProducerVersion(c,g),s.addDomain(c,j),s.addModelVersion(c,b),s.addDocString(c,Et),s.addGraph(c,It),s.addGraphDocString(c,zt),s.endModel(c)}}o.Model=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsKernelCreateInfos(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsKernelCreateInfos(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}nodeIndices(c){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.readUint32(this.bb.__vector(this.bb_pos+h)+c*4):0}nodeIndicesLength(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.__vector_len(this.bb_pos+c):0}nodeIndicesArray(){let c=this.bb.__offset(this.bb_pos,4);return c?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+c),this.bb.__vector_len(this.bb_pos+c)):null}kernelDefHashes(c){let h=this.bb.__offset(this.bb_pos,6);return h?this.bb.readUint64(this.bb.__vector(this.bb_pos+h)+c*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__vector_len(this.bb_pos+c):0}static startKernelCreateInfos(c){c.startObject(2)}static addNodeIndices(c,h){c.addFieldOffset(0,h,0)}static createNodeIndicesVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addInt32(h[_]);return c.endVector()}static startNodeIndicesVector(c,h){c.startVector(4,h,4)}static addKernelDefHashes(c,h){c.addFieldOffset(1,h,0)}static createKernelDefHashesVector(c,h){c.startVector(8,h.length,8);for(let _=h.length-1;_>=0;_--)c.addInt64(h[_]);return c.endVector()}static startKernelDefHashesVector(c,h){c.startVector(8,h,8)}static endKernelCreateInfos(c){return c.endObject()}static createKernelCreateInfos(c,h,_){return s.startKernelCreateInfos(c),s.addNodeIndices(c,h),s.addKernelDefHashes(c,_),s.endKernelCreateInfos(c)}}o.KernelCreateInfos=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsSubGraphSessionState(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsSubGraphSessionState(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}graphId(c){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.__string(this.bb_pos+h,c):null}sessionState(c){let h=this.bb.__offset(this.bb_pos,6);return h?(c||new a.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+h),this.bb):null}static startSubGraphSessionState(c){c.startObject(2)}static addGraphId(c,h){c.addFieldOffset(0,h,0)}static addSessionState(c,h){c.addFieldOffset(1,h,0)}static endSubGraphSessionState(c){let h=c.endObject();return c.requiredField(h,4),h}static createSubGraphSessionState(c,h,_){return s.startSubGraphSessionState(c),s.addGraphId(c,h),s.addSessionState(c,_),s.endSubGraphSessionState(c)}}o.SubGraphSessionState=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsSessionState(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsSessionState(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}kernels(c){let h=this.bb.__offset(this.bb_pos,4);return h?(c||new a.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+h),this.bb):null}subGraphSessionStates(c,h){let _=this.bb.__offset(this.bb_pos,6);return _?(h||new a.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+c*4),this.bb):null}subGraphSessionStatesLength(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__vector_len(this.bb_pos+c):0}static startSessionState(c){c.startObject(2)}static addKernels(c,h){c.addFieldOffset(0,h,0)}static addSubGraphSessionStates(c,h){c.addFieldOffset(1,h,0)}static createSubGraphSessionStatesVector(c,h){c.startVector(4,h.length,4);for(let _=h.length-1;_>=0;_--)c.addOffset(h[_]);return c.endVector()}static startSubGraphSessionStatesVector(c,h){c.startVector(4,h,4)}static endSessionState(c){return c.endObject()}static createSessionState(c,h,_){return s.startSessionState(c),s.addKernels(c,h),s.addSubGraphSessionStates(c,_),s.endSessionState(c)}}o.SessionState=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={})),(a=>{(e=>{(o=>{class s{constructor(){this.bb=null,this.bb_pos=0}__init(c,h){return this.bb_pos=c,this.bb=h,this}static getRootAsInferenceSession(c,h){return(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsInferenceSession(c,h){return c.setPosition(c.position()+O.SIZE_PREFIX_LENGTH),(h||new s).__init(c.readInt32(c.position())+c.position(),c)}static bufferHasIdentifier(c){return c.__has_identifier("ORTM")}ortVersion(c){let h=this.bb.__offset(this.bb_pos,4);return h?this.bb.__string(this.bb_pos+h,c):null}model(c){let h=this.bb.__offset(this.bb_pos,6);return h?(c||new a.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+h),this.bb):null}sessionState(c){let h=this.bb.__offset(this.bb_pos,8);return h?(c||new a.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+h),this.bb):null}static startInferenceSession(c){c.startObject(3)}static addOrtVersion(c,h){c.addFieldOffset(0,h,0)}static addModel(c,h){c.addFieldOffset(1,h,0)}static addSessionState(c,h){c.addFieldOffset(2,h,0)}static endInferenceSession(c){return c.endObject()}static finishInferenceSessionBuffer(c,h){c.finish(h,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(c,h){c.finish(h,"ORTM",!0)}static createInferenceSession(c,h,_,bt){return s.startInferenceSession(c),s.addOrtVersion(c,h),s.addModel(c,_),s.addSessionState(c,bt),s.endInferenceSession(c)}}o.InferenceSession=s})(e.fbs||(e.fbs={}))})(a.experimental||(a.experimental={}))})(W||(W={}))}),Rs$1=me((a,e)=>{e.exports=o;function o(s,d){for(var c=new Array(arguments.length-1),h=0,_=2,bt=!0;_<arguments.length;)c[h++]=arguments[_++];return new Promise(function(g,j){c[h]=function(b){if(bt)if(bt=!1,b)j(b);else{for(var Et=new Array(arguments.length-1),It=0;It<Et.length;)Et[It++]=arguments[It];g.apply(null,Et)}};try{s.apply(d||null,c)}catch(b){bt&&(bt=!1,j(b))}})}}),zs$1=me(a=>{var e=a;e.length=function(h){var _=h.length;if(!_)return 0;for(var bt=0;--_%4>1&&h.charAt(_)==="=";)++bt;return Math.ceil(h.length*3)/4-bt};var o=new Array(64),s=new Array(123);for(d=0;d<64;)s[o[d]=d<26?d+65:d<52?d+71:d<62?d-4:d-59|43]=d++;var d;e.encode=function(h,_,bt){for(var g=null,j=[],b=0,Et=0,It;_<bt;){var zt=h[_++];switch(Et){case 0:j[b++]=o[zt>>2],It=(zt&3)<<4,Et=1;break;case 1:j[b++]=o[It|zt>>4],It=(zt&15)<<2,Et=2;break;case 2:j[b++]=o[It|zt>>6],j[b++]=o[zt&63],Et=0;break}b>8191&&((g||(g=[])).push(String.fromCharCode.apply(String,j)),b=0)}return Et&&(j[b++]=o[It],j[b++]=61,Et===1&&(j[b++]=61)),g?(b&&g.push(String.fromCharCode.apply(String,j.slice(0,b))),g.join("")):String.fromCharCode.apply(String,j.slice(0,b))};var c="invalid encoding";e.decode=function(h,_,bt){for(var g=bt,j=0,b,Et=0;Et<h.length;){var It=h.charCodeAt(Et++);if(It===61&&j>1)break;if((It=s[It])===void 0)throw Error(c);switch(j){case 0:b=It,j=1;break;case 1:_[bt++]=b<<2|(It&48)>>4,b=It,j=2;break;case 2:_[bt++]=(b&15)<<4|(It&60)>>2,b=It,j=3;break;case 3:_[bt++]=(b&3)<<6|It,j=0;break}}if(j===1)throw Error(c);return bt-g},e.test=function(h){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(h)}}),Ws$1=me((a,e)=>{e.exports=o;function o(){this._listeners={}}o.prototype.on=function(s,d,c){return(this._listeners[s]||(this._listeners[s]=[])).push({fn:d,ctx:c||this}),this},o.prototype.off=function(s,d){if(s===void 0)this._listeners={};else if(d===void 0)this._listeners[s]=[];else for(var c=this._listeners[s],h=0;h<c.length;)c[h].fn===d?c.splice(h,1):++h;return this},o.prototype.emit=function(s){var d=this._listeners[s];if(d){for(var c=[],h=1;h<arguments.length;)c.push(arguments[h++]);for(h=0;h<d.length;)d[h].fn.apply(d[h++].ctx,c)}return this}}),Js$1=me((a,e)=>{e.exports=o(o);function o(_){return typeof Float32Array<"u"?function(){var bt=new Float32Array([-0]),g=new Uint8Array(bt.buffer),j=g[3]===128;function b(er,Hn,Qt){bt[0]=er,Hn[Qt]=g[0],Hn[Qt+1]=g[1],Hn[Qt+2]=g[2],Hn[Qt+3]=g[3]}function Et(er,Hn,Qt){bt[0]=er,Hn[Qt]=g[3],Hn[Qt+1]=g[2],Hn[Qt+2]=g[1],Hn[Qt+3]=g[0]}_.writeFloatLE=j?b:Et,_.writeFloatBE=j?Et:b;function It(er,Hn){return g[0]=er[Hn],g[1]=er[Hn+1],g[2]=er[Hn+2],g[3]=er[Hn+3],bt[0]}function zt(er,Hn){return g[3]=er[Hn],g[2]=er[Hn+1],g[1]=er[Hn+2],g[0]=er[Hn+3],bt[0]}_.readFloatLE=j?It:zt,_.readFloatBE=j?zt:It}():function(){function bt(j,b,Et,It){var zt=b<0?1:0;if(zt&&(b=-b),b===0)j(1/b>0?0:2147483648,Et,It);else if(isNaN(b))j(2143289344,Et,It);else if(b>34028234663852886e22)j((zt<<31|2139095040)>>>0,Et,It);else if(b<11754943508222875e-54)j((zt<<31|Math.round(b/1401298464324817e-60))>>>0,Et,It);else{var er=Math.floor(Math.log(b)/Math.LN2),Hn=Math.round(b*Math.pow(2,-er)*8388608)&8388607;j((zt<<31|er+127<<23|Hn)>>>0,Et,It)}}_.writeFloatLE=bt.bind(null,s),_.writeFloatBE=bt.bind(null,d);function g(j,b,Et){var It=j(b,Et),zt=(It>>31)*2+1,er=It>>>23&255,Hn=It&8388607;return er===255?Hn?NaN:zt*(1/0):er===0?zt*1401298464324817e-60*Hn:zt*Math.pow(2,er-150)*(Hn+8388608)}_.readFloatLE=g.bind(null,c),_.readFloatBE=g.bind(null,h)}(),typeof Float64Array<"u"?function(){var bt=new Float64Array([-0]),g=new Uint8Array(bt.buffer),j=g[7]===128;function b(er,Hn,Qt){bt[0]=er,Hn[Qt]=g[0],Hn[Qt+1]=g[1],Hn[Qt+2]=g[2],Hn[Qt+3]=g[3],Hn[Qt+4]=g[4],Hn[Qt+5]=g[5],Hn[Qt+6]=g[6],Hn[Qt+7]=g[7]}function Et(er,Hn,Qt){bt[0]=er,Hn[Qt]=g[7],Hn[Qt+1]=g[6],Hn[Qt+2]=g[5],Hn[Qt+3]=g[4],Hn[Qt+4]=g[3],Hn[Qt+5]=g[2],Hn[Qt+6]=g[1],Hn[Qt+7]=g[0]}_.writeDoubleLE=j?b:Et,_.writeDoubleBE=j?Et:b;function It(er,Hn){return g[0]=er[Hn],g[1]=er[Hn+1],g[2]=er[Hn+2],g[3]=er[Hn+3],g[4]=er[Hn+4],g[5]=er[Hn+5],g[6]=er[Hn+6],g[7]=er[Hn+7],bt[0]}function zt(er,Hn){return g[7]=er[Hn],g[6]=er[Hn+1],g[5]=er[Hn+2],g[4]=er[Hn+3],g[3]=er[Hn+4],g[2]=er[Hn+5],g[1]=er[Hn+6],g[0]=er[Hn+7],bt[0]}_.readDoubleLE=j?It:zt,_.readDoubleBE=j?zt:It}():function(){function bt(j,b,Et,It,zt,er){var Hn=It<0?1:0;if(Hn&&(It=-It),It===0)j(0,zt,er+b),j(1/It>0?0:2147483648,zt,er+Et);else if(isNaN(It))j(0,zt,er+b),j(2146959360,zt,er+Et);else if(It>17976931348623157e292)j(0,zt,er+b),j((Hn<<31|2146435072)>>>0,zt,er+Et);else{var Qt;if(It<22250738585072014e-324)Qt=It/5e-324,j(Qt>>>0,zt,er+b),j((Hn<<31|Qt/4294967296)>>>0,zt,er+Et);else{var cr=Math.floor(Math.log(It)/Math.LN2);cr===1024&&(cr=1023),Qt=It*Math.pow(2,-cr),j(Qt*4503599627370496>>>0,zt,er+b),j((Hn<<31|cr+1023<<20|Qt*1048576&1048575)>>>0,zt,er+Et)}}}_.writeDoubleLE=bt.bind(null,s,0,4),_.writeDoubleBE=bt.bind(null,d,4,0);function g(j,b,Et,It,zt){var er=j(It,zt+b),Hn=j(It,zt+Et),Qt=(Hn>>31)*2+1,cr=Hn>>>20&2047,fr=4294967296*(Hn&1048575)+er;return cr===2047?fr?NaN:Qt*(1/0):cr===0?Qt*5e-324*fr:Qt*Math.pow(2,cr-1075)*(fr+4503599627370496)}_.readDoubleLE=g.bind(null,c,0,4),_.readDoubleBE=g.bind(null,h,4,0)}(),_}function s(_,bt,g){bt[g]=_&255,bt[g+1]=_>>>8&255,bt[g+2]=_>>>16&255,bt[g+3]=_>>>24}function d(_,bt,g){bt[g]=_>>>24,bt[g+1]=_>>>16&255,bt[g+2]=_>>>8&255,bt[g+3]=_&255}function c(_,bt){return(_[bt]|_[bt+1]<<8|_[bt+2]<<16|_[bt+3]<<24)>>>0}function h(_,bt){return(_[bt]<<24|_[bt+1]<<16|_[bt+2]<<8|_[bt+3])>>>0}}),Zs$1=me((exports,module)=>{module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(a){}return null}}),eu$1=me(a=>{var e=a;e.length=function(o){for(var s=0,d=0,c=0;c<o.length;++c)d=o.charCodeAt(c),d<128?s+=1:d<2048?s+=2:(d&64512)===55296&&(o.charCodeAt(c+1)&64512)===56320?(++c,s+=4):s+=3;return s},e.read=function(o,s,d){var c=d-s;if(c<1)return"";for(var h=null,_=[],bt=0,g;s<d;)g=o[s++],g<128?_[bt++]=g:g>191&&g<224?_[bt++]=(g&31)<<6|o[s++]&63:g>239&&g<365?(g=((g&7)<<18|(o[s++]&63)<<12|(o[s++]&63)<<6|o[s++]&63)-65536,_[bt++]=55296+(g>>10),_[bt++]=56320+(g&1023)):_[bt++]=(g&15)<<12|(o[s++]&63)<<6|o[s++]&63,bt>8191&&((h||(h=[])).push(String.fromCharCode.apply(String,_)),bt=0);return h?(bt&&h.push(String.fromCharCode.apply(String,_.slice(0,bt))),h.join("")):String.fromCharCode.apply(String,_.slice(0,bt))},e.write=function(o,s,d){for(var c=d,h,_,bt=0;bt<o.length;++bt)h=o.charCodeAt(bt),h<128?s[d++]=h:h<2048?(s[d++]=h>>6|192,s[d++]=h&63|128):(h&64512)===55296&&((_=o.charCodeAt(bt+1))&64512)===56320?(h=65536+((h&1023)<<10)+(_&1023),++bt,s[d++]=h>>18|240,s[d++]=h>>12&63|128,s[d++]=h>>6&63|128,s[d++]=h&63|128):(s[d++]=h>>12|224,s[d++]=h>>6&63|128,s[d++]=h&63|128);return d-c}}),ru$1=me((a,e)=>{e.exports=o;function o(s,d,c){var h=c||8192,_=h>>>1,bt=null,g=h;return function(j){if(j<1||j>_)return s(j);g+j>h&&(bt=s(h),g=0);var b=d.call(bt,g,g+=j);return g&7&&(g=(g|7)+1),b}}}),ou$1=me((a,e)=>{e.exports=s;var o=Xt();function s(_,bt){this.lo=_>>>0,this.hi=bt>>>0}var d=s.zero=new s(0,0);d.toNumber=function(){return 0},d.zzEncode=d.zzDecode=function(){return this},d.length=function(){return 1};var c=s.zeroHash="\0\0\0\0\0\0\0\0";s.fromNumber=function(_){if(_===0)return d;var bt=_<0;bt&&(_=-_);var g=_>>>0,j=(_-g)/4294967296>>>0;return bt&&(j=~j>>>0,g=~g>>>0,++g>4294967295&&(g=0,++j>4294967295&&(j=0))),new s(g,j)},s.from=function(_){if(typeof _=="number")return s.fromNumber(_);if(o.isString(_))if(o.Long)_=o.Long.fromString(_);else return s.fromNumber(parseInt(_,10));return _.low||_.high?new s(_.low>>>0,_.high>>>0):d},s.prototype.toNumber=function(_){if(!_&&this.hi>>>31){var bt=~this.lo+1>>>0,g=~this.hi>>>0;return bt||(g=g+1>>>0),-(bt+g*4294967296)}return this.lo+this.hi*4294967296},s.prototype.toLong=function(_){return o.Long?new o.Long(this.lo|0,this.hi|0,!!_):{low:this.lo|0,high:this.hi|0,unsigned:!!_}};var h=String.prototype.charCodeAt;s.fromHash=function(_){return _===c?d:new s((h.call(_,0)|h.call(_,1)<<8|h.call(_,2)<<16|h.call(_,3)<<24)>>>0,(h.call(_,4)|h.call(_,5)<<8|h.call(_,6)<<16|h.call(_,7)<<24)>>>0)},s.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},s.prototype.zzEncode=function(){var _=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^_)>>>0,this.lo=(this.lo<<1^_)>>>0,this},s.prototype.zzDecode=function(){var _=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^_)>>>0,this.hi=(this.hi>>>1^_)>>>0,this},s.prototype.length=function(){var _=this.lo,bt=(this.lo>>>28|this.hi<<4)>>>0,g=this.hi>>>24;return g===0?bt===0?_<16384?_<128?1:2:_<2097152?3:4:bt<16384?bt<128?5:6:bt<2097152?7:8:g<128?9:10}}),Xt=me(a=>{var e=a;e.asPromise=Rs$1(),e.base64=zs$1(),e.EventEmitter=Ws$1(),e.float=Js$1(),e.inquire=Zs$1(),e.utf8=eu$1(),e.pool=ru$1(),e.LongBits=ou$1(),e.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node),e.global=e.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||a,e.emptyArray=Object.freeze?Object.freeze([]):[],e.emptyObject=Object.freeze?Object.freeze({}):{},e.isInteger=Number.isInteger||function(d){return typeof d=="number"&&isFinite(d)&&Math.floor(d)===d},e.isString=function(d){return typeof d=="string"||d instanceof String},e.isObject=function(d){return d&&typeof d=="object"},e.isset=e.isSet=function(d,c){var h=d[c];return h!=null&&d.hasOwnProperty(c)?typeof h!="object"||(Array.isArray(h)?h.length:Object.keys(h).length)>0:!1},e.Buffer=function(){try{var d=e.inquire("buffer").Buffer;return d.prototype.utf8Write?d:null}catch{return null}}(),e._Buffer_from=null,e._Buffer_allocUnsafe=null,e.newBuffer=function(d){return typeof d=="number"?e.Buffer?e._Buffer_allocUnsafe(d):new e.Array(d):e.Buffer?e._Buffer_from(d):typeof Uint8Array>"u"?d:new Uint8Array(d)},e.Array=typeof Uint8Array<"u"?Uint8Array:Array,e.Long=e.global.dcodeIO&&e.global.dcodeIO.Long||e.global.Long||e.inquire("long"),e.key2Re=/^true|false|0|1$/,e.key32Re=/^-?(?:0|[1-9][0-9]*)$/,e.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,e.longToHash=function(d){return d?e.LongBits.from(d).toHash():e.LongBits.zeroHash},e.longFromHash=function(d,c){var h=e.LongBits.fromHash(d);return e.Long?e.Long.fromBits(h.lo,h.hi,c):h.toNumber(!!c)};function o(d,c,h){for(var _=Object.keys(c),bt=0;bt<_.length;++bt)(d[_[bt]]===void 0||!h)&&(d[_[bt]]=c[_[bt]]);return d}e.merge=o,e.lcFirst=function(d){return d.charAt(0).toLowerCase()+d.substring(1)};function s(d){function c(h,_){if(!(this instanceof c))return new c(h,_);Object.defineProperty(this,"message",{get:function(){return h}}),Error.captureStackTrace?Error.captureStackTrace(this,c):Object.defineProperty(this,"stack",{value:new Error().stack||""}),_&&o(this,_)}return c.prototype=Object.create(Error.prototype,{constructor:{value:c,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return d},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),c}e.newError=s,e.ProtocolError=s("ProtocolError"),e.oneOfGetter=function(d){for(var c={},h=0;h<d.length;++h)c[d[h]]=1;return function(){for(var _=Object.keys(this),bt=_.length-1;bt>-1;--bt)if(c[_[bt]]===1&&this[_[bt]]!==void 0&&this[_[bt]]!==null)return _[bt]}},e.oneOfSetter=function(d){return function(c){for(var h=0;h<d.length;++h)d[h]!==c&&delete this[d[h]]}},e.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},e._configure=function(){var d=e.Buffer;if(!d){e._Buffer_from=e._Buffer_allocUnsafe=null;return}e._Buffer_from=d.from!==Uint8Array.from&&d.from||function(c,h){return new d(c,h)},e._Buffer_allocUnsafe=d.allocUnsafe||function(c){return new d(c)}}}),li$1=me((a,e)=>{e.exports=j;var o=Xt(),s,d=o.LongBits,c=o.base64,h=o.utf8;function _(cr,fr,jr){this.fn=cr,this.len=fr,this.next=void 0,this.val=jr}function bt(){}function g(cr){this.head=cr.head,this.tail=cr.tail,this.len=cr.len,this.next=cr.states}function j(){this.len=0,this.head=new _(bt,0,0),this.tail=this.head,this.states=null}var b=function(){return o.Buffer?function(){return(j.create=function(){return new s})()}:function(){return new j}};j.create=b(),j.alloc=function(cr){return new o.Array(cr)},o.Array!==Array&&(j.alloc=o.pool(j.alloc,o.Array.prototype.subarray)),j.prototype._push=function(cr,fr,jr){return this.tail=this.tail.next=new _(cr,fr,jr),this.len+=fr,this};function Et(cr,fr,jr){fr[jr]=cr&255}function It(cr,fr,jr){for(;cr>127;)fr[jr++]=cr&127|128,cr>>>=7;fr[jr]=cr}function zt(cr,fr){this.len=cr,this.next=void 0,this.val=fr}zt.prototype=Object.create(_.prototype),zt.prototype.fn=It,j.prototype.uint32=function(cr){return this.len+=(this.tail=this.tail.next=new zt((cr=cr>>>0)<128?1:cr<16384?2:cr<2097152?3:cr<268435456?4:5,cr)).len,this},j.prototype.int32=function(cr){return cr<0?this._push(er,10,d.fromNumber(cr)):this.uint32(cr)},j.prototype.sint32=function(cr){return this.uint32((cr<<1^cr>>31)>>>0)};function er(cr,fr,jr){for(;cr.hi;)fr[jr++]=cr.lo&127|128,cr.lo=(cr.lo>>>7|cr.hi<<25)>>>0,cr.hi>>>=7;for(;cr.lo>127;)fr[jr++]=cr.lo&127|128,cr.lo=cr.lo>>>7;fr[jr++]=cr.lo}j.prototype.uint64=function(cr){var fr=d.from(cr);return this._push(er,fr.length(),fr)},j.prototype.int64=j.prototype.uint64,j.prototype.sint64=function(cr){var fr=d.from(cr).zzEncode();return this._push(er,fr.length(),fr)},j.prototype.bool=function(cr){return this._push(Et,1,cr?1:0)};function Hn(cr,fr,jr){fr[jr]=cr&255,fr[jr+1]=cr>>>8&255,fr[jr+2]=cr>>>16&255,fr[jr+3]=cr>>>24}j.prototype.fixed32=function(cr){return this._push(Hn,4,cr>>>0)},j.prototype.sfixed32=j.prototype.fixed32,j.prototype.fixed64=function(cr){var fr=d.from(cr);return this._push(Hn,4,fr.lo)._push(Hn,4,fr.hi)},j.prototype.sfixed64=j.prototype.fixed64,j.prototype.float=function(cr){return this._push(o.float.writeFloatLE,4,cr)},j.prototype.double=function(cr){return this._push(o.float.writeDoubleLE,8,cr)};var Qt=o.Array.prototype.set?function(cr,fr,jr){fr.set(cr,jr)}:function(cr,fr,jr){for(var e0=0;e0<cr.length;++e0)fr[jr+e0]=cr[e0]};j.prototype.bytes=function(cr){var fr=cr.length>>>0;if(!fr)return this._push(Et,1,0);if(o.isString(cr)){var jr=j.alloc(fr=c.length(cr));c.decode(cr,jr,0),cr=jr}return this.uint32(fr)._push(Qt,fr,cr)},j.prototype.string=function(cr){var fr=h.length(cr);return fr?this.uint32(fr)._push(h.write,fr,cr):this._push(Et,1,0)},j.prototype.fork=function(){return this.states=new g(this),this.head=this.tail=new _(bt,0,0),this.len=0,this},j.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new _(bt,0,0),this.len=0),this},j.prototype.ldelim=function(){var cr=this.head,fr=this.tail,jr=this.len;return this.reset().uint32(jr),jr&&(this.tail.next=cr.next,this.tail=fr,this.len+=jr),this},j.prototype.finish=function(){for(var cr=this.head.next,fr=this.constructor.alloc(this.len),jr=0;cr;)cr.fn(cr.val,fr,jr),jr+=cr.len,cr=cr.next;return fr},j._configure=function(cr){s=cr,j.create=b(),s._configure()}}),du$1=me((a,e)=>{e.exports=d;var o=li$1();(d.prototype=Object.create(o.prototype)).constructor=d;var s=Xt();function d(){o.call(this)}d._configure=function(){d.alloc=s._Buffer_allocUnsafe,d.writeBytesBuffer=s.Buffer&&s.Buffer.prototype instanceof Uint8Array&&s.Buffer.prototype.set.name==="set"?function(h,_,bt){_.set(h,bt)}:function(h,_,bt){if(h.copy)h.copy(_,bt,0,h.length);else for(var g=0;g<h.length;)_[bt++]=h[g++]}},d.prototype.bytes=function(h){s.isString(h)&&(h=s._Buffer_from(h,"base64"));var _=h.length>>>0;return this.uint32(_),_&&this._push(d.writeBytesBuffer,_,h),this};function c(h,_,bt){h.length<40?s.utf8.write(h,_,bt):_.utf8Write?_.utf8Write(h,bt):_.write(h,bt)}d.prototype.string=function(h){var _=s.Buffer.byteLength(h);return this.uint32(_),_&&this._push(c,_,h),this},d._configure()}),pi$1=me((a,e)=>{e.exports=_;var o=Xt(),s,d=o.LongBits,c=o.utf8;function h(It,zt){return RangeError("index out of range: "+It.pos+" + "+(zt||1)+" > "+It.len)}function _(It){this.buf=It,this.pos=0,this.len=It.length}var bt=typeof Uint8Array<"u"?function(It){if(It instanceof Uint8Array||Array.isArray(It))return new _(It);throw Error("illegal buffer")}:function(It){if(Array.isArray(It))return new _(It);throw Error("illegal buffer")},g=function(){return o.Buffer?function(It){return(_.create=function(zt){return o.Buffer.isBuffer(zt)?new s(zt):bt(zt)})(It)}:bt};_.create=g(),_.prototype._slice=o.Array.prototype.subarray||o.Array.prototype.slice,_.prototype.uint32=function(){var It=4294967295;return function(){if(It=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(It=(It|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(It=(It|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(It=(It|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(It=(It|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return It;if((this.pos+=5)>this.len)throw this.pos=this.len,h(this,10);return It}}(),_.prototype.int32=function(){return this.uint32()|0},_.prototype.sint32=function(){var It=this.uint32();return It>>>1^-(It&1)|0};function j(){var It=new d(0,0),zt=0;if(this.len-this.pos>4){for(;zt<4;++zt)if(It.lo=(It.lo|(this.buf[this.pos]&127)<<zt*7)>>>0,this.buf[this.pos++]<128)return It;if(It.lo=(It.lo|(this.buf[this.pos]&127)<<28)>>>0,It.hi=(It.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return It;zt=0}else{for(;zt<3;++zt){if(this.pos>=this.len)throw h(this);if(It.lo=(It.lo|(this.buf[this.pos]&127)<<zt*7)>>>0,this.buf[this.pos++]<128)return It}return It.lo=(It.lo|(this.buf[this.pos++]&127)<<zt*7)>>>0,It}if(this.len-this.pos>4){for(;zt<5;++zt)if(It.hi=(It.hi|(this.buf[this.pos]&127)<<zt*7+3)>>>0,this.buf[this.pos++]<128)return It}else for(;zt<5;++zt){if(this.pos>=this.len)throw h(this);if(It.hi=(It.hi|(this.buf[this.pos]&127)<<zt*7+3)>>>0,this.buf[this.pos++]<128)return It}throw Error("invalid varint encoding")}_.prototype.bool=function(){return this.uint32()!==0};function b(It,zt){return(It[zt-4]|It[zt-3]<<8|It[zt-2]<<16|It[zt-1]<<24)>>>0}_.prototype.fixed32=function(){if(this.pos+4>this.len)throw h(this,4);return b(this.buf,this.pos+=4)},_.prototype.sfixed32=function(){if(this.pos+4>this.len)throw h(this,4);return b(this.buf,this.pos+=4)|0};function Et(){if(this.pos+8>this.len)throw h(this,8);return new d(b(this.buf,this.pos+=4),b(this.buf,this.pos+=4))}_.prototype.float=function(){if(this.pos+4>this.len)throw h(this,4);var It=o.float.readFloatLE(this.buf,this.pos);return this.pos+=4,It},_.prototype.double=function(){if(this.pos+8>this.len)throw h(this,4);var It=o.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,It},_.prototype.bytes=function(){var It=this.uint32(),zt=this.pos,er=this.pos+It;if(er>this.len)throw h(this,It);return this.pos+=It,Array.isArray(this.buf)?this.buf.slice(zt,er):zt===er?new this.buf.constructor(0):this._slice.call(this.buf,zt,er)},_.prototype.string=function(){var It=this.bytes();return c.read(It,0,It.length)},_.prototype.skip=function(It){if(typeof It=="number"){if(this.pos+It>this.len)throw h(this,It);this.pos+=It}else do if(this.pos>=this.len)throw h(this);while(this.buf[this.pos++]&128);return this},_.prototype.skipType=function(It){switch(It){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(It=this.uint32()&7)!==4;)this.skipType(It);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+It+" at offset "+this.pos)}return this},_._configure=function(It){s=It,_.create=g(),s._configure();var zt=o.Long?"toLong":"toNumber";o.merge(_.prototype,{int64:function(){return j.call(this)[zt](!1)},uint64:function(){return j.call(this)[zt](!0)},sint64:function(){return j.call(this).zzDecode()[zt](!1)},fixed64:function(){return Et.call(this)[zt](!0)},sfixed64:function(){return Et.call(this)[zt](!1)}})}}),vu$1=me((a,e)=>{e.exports=d;var o=pi$1();(d.prototype=Object.create(o.prototype)).constructor=d;var s=Xt();function d(c){o.call(this,c)}d._configure=function(){s.Buffer&&(d.prototype._slice=s.Buffer.prototype.slice)},d.prototype.string=function(){var c=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+c,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+c,this.len))},d._configure()}),Ou$1=me((a,e)=>{e.exports=s;var o=Xt();(s.prototype=Object.create(o.EventEmitter.prototype)).constructor=s;function s(d,c,h){if(typeof d!="function")throw TypeError("rpcImpl must be a function");o.EventEmitter.call(this),this.rpcImpl=d,this.requestDelimited=!!c,this.responseDelimited=!!h}s.prototype.rpcCall=function d(c,h,_,bt,g){if(!bt)throw TypeError("request must be specified");var j=this;if(!g)return o.asPromise(d,j,c,h,_,bt);if(!j.rpcImpl){setTimeout(function(){g(Error("already ended"))},0);return}try{return j.rpcImpl(c,h[j.requestDelimited?"encodeDelimited":"encode"](bt).finish(),function(b,Et){if(b)return j.emit("error",b,c),g(b);if(Et===null){j.end(!0);return}if(!(Et instanceof _))try{Et=_[j.responseDelimited?"decodeDelimited":"decode"](Et)}catch(It){return j.emit("error",It,c),g(It)}return j.emit("data",Et,c),g(null,Et)})}catch(b){j.emit("error",b,c),setTimeout(function(){g(b)},0);return}},s.prototype.end=function(d){return this.rpcImpl&&(d||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}}),Su$1=me(a=>{var e=a;e.Service=Ou$1()}),Pu$1=me((a,e)=>{e.exports={}}),Lu$1=me(a=>{var e=a;e.build="minimal",e.Writer=li$1(),e.BufferWriter=du$1(),e.Reader=pi$1(),e.BufferReader=vu$1(),e.util=Xt(),e.rpc=Su$1(),e.roots=Pu$1(),e.configure=o;function o(){e.util._configure(),e.Writer._configure(e.BufferWriter),e.Reader._configure(e.BufferReader)}o()}),Cu$1=me((a,e)=>{e.exports=Lu$1()}),$r=me((a,e)=>{var o=Cu$1(),s=o.Reader,d=o.Writer,c=o.util,h=o.roots.default||(o.roots.default={});h.onnx=function(){var _={};return _.Version=function(){var bt={},g=Object.create(bt);return g[bt[0]="_START_VERSION"]=0,g[bt[1]="IR_VERSION_2017_10_10"]=1,g[bt[2]="IR_VERSION_2017_10_30"]=2,g[bt[3]="IR_VERSION_2017_11_3"]=3,g[bt[4]="IR_VERSION_2019_1_22"]=4,g[bt[5]="IR_VERSION_2019_3_18"]=5,g[bt[6]="IR_VERSION_2019_9_19"]=6,g[bt[7]="IR_VERSION_2020_5_8"]=7,g[bt[8]="IR_VERSION_2021_7_30"]=8,g[bt[9]="IR_VERSION"]=9,g}(),_.AttributeProto=function(){function bt(g){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],g)for(var j=Object.keys(g),b=0;b<j.length;++b)g[j[b]]!=null&&(this[j[b]]=g[j[b]])}return bt.prototype.name="",bt.prototype.refAttrName="",bt.prototype.docString="",bt.prototype.type=0,bt.prototype.f=0,bt.prototype.i=c.Long?c.Long.fromBits(0,0,!1):0,bt.prototype.s=c.newBuffer([]),bt.prototype.t=null,bt.prototype.g=null,bt.prototype.sparseTensor=null,bt.prototype.tp=null,bt.prototype.floats=c.emptyArray,bt.prototype.ints=c.emptyArray,bt.prototype.strings=c.emptyArray,bt.prototype.tensors=c.emptyArray,bt.prototype.graphs=c.emptyArray,bt.prototype.sparseTensors=c.emptyArray,bt.prototype.typeProtos=c.emptyArray,bt.create=function(g){return new bt(g)},bt.encode=function(g,j){if(j||(j=d.create()),g.name!=null&&Object.hasOwnProperty.call(g,"name")&&j.uint32(10).string(g.name),g.f!=null&&Object.hasOwnProperty.call(g,"f")&&j.uint32(21).float(g.f),g.i!=null&&Object.hasOwnProperty.call(g,"i")&&j.uint32(24).int64(g.i),g.s!=null&&Object.hasOwnProperty.call(g,"s")&&j.uint32(34).bytes(g.s),g.t!=null&&Object.hasOwnProperty.call(g,"t")&&h.onnx.TensorProto.encode(g.t,j.uint32(42).fork()).ldelim(),g.g!=null&&Object.hasOwnProperty.call(g,"g")&&h.onnx.GraphProto.encode(g.g,j.uint32(50).fork()).ldelim(),g.floats!=null&&g.floats.length){j.uint32(58).fork();for(var b=0;b<g.floats.length;++b)j.float(g.floats[b]);j.ldelim()}if(g.ints!=null&&g.ints.length){j.uint32(66).fork();for(var b=0;b<g.ints.length;++b)j.int64(g.ints[b]);j.ldelim()}if(g.strings!=null&&g.strings.length)for(var b=0;b<g.strings.length;++b)j.uint32(74).bytes(g.strings[b]);if(g.tensors!=null&&g.tensors.length)for(var b=0;b<g.tensors.length;++b)h.onnx.TensorProto.encode(g.tensors[b],j.uint32(82).fork()).ldelim();if(g.graphs!=null&&g.graphs.length)for(var b=0;b<g.graphs.length;++b)h.onnx.GraphProto.encode(g.graphs[b],j.uint32(90).fork()).ldelim();if(g.docString!=null&&Object.hasOwnProperty.call(g,"docString")&&j.uint32(106).string(g.docString),g.tp!=null&&Object.hasOwnProperty.call(g,"tp")&&h.onnx.TypeProto.encode(g.tp,j.uint32(114).fork()).ldelim(),g.typeProtos!=null&&g.typeProtos.length)for(var b=0;b<g.typeProtos.length;++b)h.onnx.TypeProto.encode(g.typeProtos[b],j.uint32(122).fork()).ldelim();if(g.type!=null&&Object.hasOwnProperty.call(g,"type")&&j.uint32(160).int32(g.type),g.refAttrName!=null&&Object.hasOwnProperty.call(g,"refAttrName")&&j.uint32(170).string(g.refAttrName),g.sparseTensor!=null&&Object.hasOwnProperty.call(g,"sparseTensor")&&h.onnx.SparseTensorProto.encode(g.sparseTensor,j.uint32(178).fork()).ldelim(),g.sparseTensors!=null&&g.sparseTensors.length)for(var b=0;b<g.sparseTensors.length;++b)h.onnx.SparseTensorProto.encode(g.sparseTensors[b],j.uint32(186).fork()).ldelim();return j},bt.encodeDelimited=function(g,j){return this.encode(g,j).ldelim()},bt.decode=function(g,j){g instanceof s||(g=s.create(g));for(var b=j===void 0?g.len:g.pos+j,Et=new h.onnx.AttributeProto;g.pos<b;){var It=g.uint32();switch(It>>>3){case 1:{Et.name=g.string();break}case 21:{Et.refAttrName=g.string();break}case 13:{Et.docString=g.string();break}case 20:{Et.type=g.int32();break}case 2:{Et.f=g.float();break}case 3:{Et.i=g.int64();break}case 4:{Et.s=g.bytes();break}case 5:{Et.t=h.onnx.TensorProto.decode(g,g.uint32());break}case 6:{Et.g=h.onnx.GraphProto.decode(g,g.uint32());break}case 22:{Et.sparseTensor=h.onnx.SparseTensorProto.decode(g,g.uint32());break}case 14:{Et.tp=h.onnx.TypeProto.decode(g,g.uint32());break}case 7:{if(Et.floats&&Et.floats.length||(Et.floats=[]),(It&7)===2)for(var zt=g.uint32()+g.pos;g.pos<zt;)Et.floats.push(g.float());else Et.floats.push(g.float());break}case 8:{if(Et.ints&&Et.ints.length||(Et.ints=[]),(It&7)===2)for(var zt=g.uint32()+g.pos;g.pos<zt;)Et.ints.push(g.int64());else Et.ints.push(g.int64());break}case 9:{Et.strings&&Et.strings.length||(Et.strings=[]),Et.strings.push(g.bytes());break}case 10:{Et.tensors&&Et.tensors.length||(Et.tensors=[]),Et.tensors.push(h.onnx.TensorProto.decode(g,g.uint32()));break}case 11:{Et.graphs&&Et.graphs.length||(Et.graphs=[]),Et.graphs.push(h.onnx.GraphProto.decode(g,g.uint32()));break}case 23:{Et.sparseTensors&&Et.sparseTensors.length||(Et.sparseTensors=[]),Et.sparseTensors.push(h.onnx.SparseTensorProto.decode(g,g.uint32()));break}case 15:{Et.typeProtos&&Et.typeProtos.length||(Et.typeProtos=[]),Et.typeProtos.push(h.onnx.TypeProto.decode(g,g.uint32()));break}default:g.skipType(It&7);break}}return Et},bt.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},bt.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.name!=null&&g.hasOwnProperty("name")&&!c.isString(g.name))return"name: string expected";if(g.refAttrName!=null&&g.hasOwnProperty("refAttrName")&&!c.isString(g.refAttrName))return"refAttrName: string expected";if(g.docString!=null&&g.hasOwnProperty("docString")&&!c.isString(g.docString))return"docString: string expected";if(g.type!=null&&g.hasOwnProperty("type"))switch(g.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(g.f!=null&&g.hasOwnProperty("f")&&typeof g.f!="number")return"f: number expected";if(g.i!=null&&g.hasOwnProperty("i")&&!c.isInteger(g.i)&&!(g.i&&c.isInteger(g.i.low)&&c.isInteger(g.i.high)))return"i: integer|Long expected";if(g.s!=null&&g.hasOwnProperty("s")&&!(g.s&&typeof g.s.length=="number"||c.isString(g.s)))return"s: buffer expected";if(g.t!=null&&g.hasOwnProperty("t")){var j=h.onnx.TensorProto.verify(g.t);if(j)return"t."+j}if(g.g!=null&&g.hasOwnProperty("g")){var j=h.onnx.GraphProto.verify(g.g);if(j)return"g."+j}if(g.sparseTensor!=null&&g.hasOwnProperty("sparseTensor")){var j=h.onnx.SparseTensorProto.verify(g.sparseTensor);if(j)return"sparseTensor."+j}if(g.tp!=null&&g.hasOwnProperty("tp")){var j=h.onnx.TypeProto.verify(g.tp);if(j)return"tp."+j}if(g.floats!=null&&g.hasOwnProperty("floats")){if(!Array.isArray(g.floats))return"floats: array expected";for(var b=0;b<g.floats.length;++b)if(typeof g.floats[b]!="number")return"floats: number[] expected"}if(g.ints!=null&&g.hasOwnProperty("ints")){if(!Array.isArray(g.ints))return"ints: array expected";for(var b=0;b<g.ints.length;++b)if(!c.isInteger(g.ints[b])&&!(g.ints[b]&&c.isInteger(g.ints[b].low)&&c.isInteger(g.ints[b].high)))return"ints: integer|Long[] expected"}if(g.strings!=null&&g.hasOwnProperty("strings")){if(!Array.isArray(g.strings))return"strings: array expected";for(var b=0;b<g.strings.length;++b)if(!(g.strings[b]&&typeof g.strings[b].length=="number"||c.isString(g.strings[b])))return"strings: buffer[] expected"}if(g.tensors!=null&&g.hasOwnProperty("tensors")){if(!Array.isArray(g.tensors))return"tensors: array expected";for(var b=0;b<g.tensors.length;++b){var j=h.onnx.TensorProto.verify(g.tensors[b]);if(j)return"tensors."+j}}if(g.graphs!=null&&g.hasOwnProperty("graphs")){if(!Array.isArray(g.graphs))return"graphs: array expected";for(var b=0;b<g.graphs.length;++b){var j=h.onnx.GraphProto.verify(g.graphs[b]);if(j)return"graphs."+j}}if(g.sparseTensors!=null&&g.hasOwnProperty("sparseTensors")){if(!Array.isArray(g.sparseTensors))return"sparseTensors: array expected";for(var b=0;b<g.sparseTensors.length;++b){var j=h.onnx.SparseTensorProto.verify(g.sparseTensors[b]);if(j)return"sparseTensors."+j}}if(g.typeProtos!=null&&g.hasOwnProperty("typeProtos")){if(!Array.isArray(g.typeProtos))return"typeProtos: array expected";for(var b=0;b<g.typeProtos.length;++b){var j=h.onnx.TypeProto.verify(g.typeProtos[b]);if(j)return"typeProtos."+j}}return null},bt.fromObject=function(g){if(g instanceof h.onnx.AttributeProto)return g;var j=new h.onnx.AttributeProto;switch(g.name!=null&&(j.name=String(g.name)),g.refAttrName!=null&&(j.refAttrName=String(g.refAttrName)),g.docString!=null&&(j.docString=String(g.docString)),g.type){default:if(typeof g.type=="number"){j.type=g.type;break}break;case"UNDEFINED":case 0:j.type=0;break;case"FLOAT":case 1:j.type=1;break;case"INT":case 2:j.type=2;break;case"STRING":case 3:j.type=3;break;case"TENSOR":case 4:j.type=4;break;case"GRAPH":case 5:j.type=5;break;case"SPARSE_TENSOR":case 11:j.type=11;break;case"TYPE_PROTO":case 13:j.type=13;break;case"FLOATS":case 6:j.type=6;break;case"INTS":case 7:j.type=7;break;case"STRINGS":case 8:j.type=8;break;case"TENSORS":case 9:j.type=9;break;case"GRAPHS":case 10:j.type=10;break;case"SPARSE_TENSORS":case 12:j.type=12;break;case"TYPE_PROTOS":case 14:j.type=14;break}if(g.f!=null&&(j.f=Number(g.f)),g.i!=null&&(c.Long?(j.i=c.Long.fromValue(g.i)).unsigned=!1:typeof g.i=="string"?j.i=parseInt(g.i,10):typeof g.i=="number"?j.i=g.i:typeof g.i=="object"&&(j.i=new c.LongBits(g.i.low>>>0,g.i.high>>>0).toNumber())),g.s!=null&&(typeof g.s=="string"?c.base64.decode(g.s,j.s=c.newBuffer(c.base64.length(g.s)),0):g.s.length>=0&&(j.s=g.s)),g.t!=null){if(typeof g.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");j.t=h.onnx.TensorProto.fromObject(g.t)}if(g.g!=null){if(typeof g.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");j.g=h.onnx.GraphProto.fromObject(g.g)}if(g.sparseTensor!=null){if(typeof g.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");j.sparseTensor=h.onnx.SparseTensorProto.fromObject(g.sparseTensor)}if(g.tp!=null){if(typeof g.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");j.tp=h.onnx.TypeProto.fromObject(g.tp)}if(g.floats){if(!Array.isArray(g.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");j.floats=[];for(var b=0;b<g.floats.length;++b)j.floats[b]=Number(g.floats[b])}if(g.ints){if(!Array.isArray(g.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");j.ints=[];for(var b=0;b<g.ints.length;++b)c.Long?(j.ints[b]=c.Long.fromValue(g.ints[b])).unsigned=!1:typeof g.ints[b]=="string"?j.ints[b]=parseInt(g.ints[b],10):typeof g.ints[b]=="number"?j.ints[b]=g.ints[b]:typeof g.ints[b]=="object"&&(j.ints[b]=new c.LongBits(g.ints[b].low>>>0,g.ints[b].high>>>0).toNumber())}if(g.strings){if(!Array.isArray(g.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");j.strings=[];for(var b=0;b<g.strings.length;++b)typeof g.strings[b]=="string"?c.base64.decode(g.strings[b],j.strings[b]=c.newBuffer(c.base64.length(g.strings[b])),0):g.strings[b].length>=0&&(j.strings[b]=g.strings[b])}if(g.tensors){if(!Array.isArray(g.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");j.tensors=[];for(var b=0;b<g.tensors.length;++b){if(typeof g.tensors[b]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");j.tensors[b]=h.onnx.TensorProto.fromObject(g.tensors[b])}}if(g.graphs){if(!Array.isArray(g.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");j.graphs=[];for(var b=0;b<g.graphs.length;++b){if(typeof g.graphs[b]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");j.graphs[b]=h.onnx.GraphProto.fromObject(g.graphs[b])}}if(g.sparseTensors){if(!Array.isArray(g.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");j.sparseTensors=[];for(var b=0;b<g.sparseTensors.length;++b){if(typeof g.sparseTensors[b]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");j.sparseTensors[b]=h.onnx.SparseTensorProto.fromObject(g.sparseTensors[b])}}if(g.typeProtos){if(!Array.isArray(g.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");j.typeProtos=[];for(var b=0;b<g.typeProtos.length;++b){if(typeof g.typeProtos[b]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");j.typeProtos[b]=h.onnx.TypeProto.fromObject(g.typeProtos[b])}}return j},bt.toObject=function(g,j){j||(j={});var b={};if((j.arrays||j.defaults)&&(b.floats=[],b.ints=[],b.strings=[],b.tensors=[],b.graphs=[],b.typeProtos=[],b.sparseTensors=[]),j.defaults){if(b.name="",b.f=0,c.Long){var Et=new c.Long(0,0,!1);b.i=j.longs===String?Et.toString():j.longs===Number?Et.toNumber():Et}else b.i=j.longs===String?"0":0;j.bytes===String?b.s="":(b.s=[],j.bytes!==Array&&(b.s=c.newBuffer(b.s))),b.t=null,b.g=null,b.docString="",b.tp=null,b.type=j.enums===String?"UNDEFINED":0,b.refAttrName="",b.sparseTensor=null}if(g.name!=null&&g.hasOwnProperty("name")&&(b.name=g.name),g.f!=null&&g.hasOwnProperty("f")&&(b.f=j.json&&!isFinite(g.f)?String(g.f):g.f),g.i!=null&&g.hasOwnProperty("i")&&(typeof g.i=="number"?b.i=j.longs===String?String(g.i):g.i:b.i=j.longs===String?c.Long.prototype.toString.call(g.i):j.longs===Number?new c.LongBits(g.i.low>>>0,g.i.high>>>0).toNumber():g.i),g.s!=null&&g.hasOwnProperty("s")&&(b.s=j.bytes===String?c.base64.encode(g.s,0,g.s.length):j.bytes===Array?Array.prototype.slice.call(g.s):g.s),g.t!=null&&g.hasOwnProperty("t")&&(b.t=h.onnx.TensorProto.toObject(g.t,j)),g.g!=null&&g.hasOwnProperty("g")&&(b.g=h.onnx.GraphProto.toObject(g.g,j)),g.floats&&g.floats.length){b.floats=[];for(var It=0;It<g.floats.length;++It)b.floats[It]=j.json&&!isFinite(g.floats[It])?String(g.floats[It]):g.floats[It]}if(g.ints&&g.ints.length){b.ints=[];for(var It=0;It<g.ints.length;++It)typeof g.ints[It]=="number"?b.ints[It]=j.longs===String?String(g.ints[It]):g.ints[It]:b.ints[It]=j.longs===String?c.Long.prototype.toString.call(g.ints[It]):j.longs===Number?new c.LongBits(g.ints[It].low>>>0,g.ints[It].high>>>0).toNumber():g.ints[It]}if(g.strings&&g.strings.length){b.strings=[];for(var It=0;It<g.strings.length;++It)b.strings[It]=j.bytes===String?c.base64.encode(g.strings[It],0,g.strings[It].length):j.bytes===Array?Array.prototype.slice.call(g.strings[It]):g.strings[It]}if(g.tensors&&g.tensors.length){b.tensors=[];for(var It=0;It<g.tensors.length;++It)b.tensors[It]=h.onnx.TensorProto.toObject(g.tensors[It],j)}if(g.graphs&&g.graphs.length){b.graphs=[];for(var It=0;It<g.graphs.length;++It)b.graphs[It]=h.onnx.GraphProto.toObject(g.graphs[It],j)}if(g.docString!=null&&g.hasOwnProperty("docString")&&(b.docString=g.docString),g.tp!=null&&g.hasOwnProperty("tp")&&(b.tp=h.onnx.TypeProto.toObject(g.tp,j)),g.typeProtos&&g.typeProtos.length){b.typeProtos=[];for(var It=0;It<g.typeProtos.length;++It)b.typeProtos[It]=h.onnx.TypeProto.toObject(g.typeProtos[It],j)}if(g.type!=null&&g.hasOwnProperty("type")&&(b.type=j.enums===String?h.onnx.AttributeProto.AttributeType[g.type]===void 0?g.type:h.onnx.AttributeProto.AttributeType[g.type]:g.type),g.refAttrName!=null&&g.hasOwnProperty("refAttrName")&&(b.refAttrName=g.refAttrName),g.sparseTensor!=null&&g.hasOwnProperty("sparseTensor")&&(b.sparseTensor=h.onnx.SparseTensorProto.toObject(g.sparseTensor,j)),g.sparseTensors&&g.sparseTensors.length){b.sparseTensors=[];for(var It=0;It<g.sparseTensors.length;++It)b.sparseTensors[It]=h.onnx.SparseTensorProto.toObject(g.sparseTensors[It],j)}return b},bt.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},bt.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.AttributeProto"},bt.AttributeType=function(){var g={},j=Object.create(g);return j[g[0]="UNDEFINED"]=0,j[g[1]="FLOAT"]=1,j[g[2]="INT"]=2,j[g[3]="STRING"]=3,j[g[4]="TENSOR"]=4,j[g[5]="GRAPH"]=5,j[g[11]="SPARSE_TENSOR"]=11,j[g[13]="TYPE_PROTO"]=13,j[g[6]="FLOATS"]=6,j[g[7]="INTS"]=7,j[g[8]="STRINGS"]=8,j[g[9]="TENSORS"]=9,j[g[10]="GRAPHS"]=10,j[g[12]="SPARSE_TENSORS"]=12,j[g[14]="TYPE_PROTOS"]=14,j}(),bt}(),_.ValueInfoProto=function(){function bt(g){if(g)for(var j=Object.keys(g),b=0;b<j.length;++b)g[j[b]]!=null&&(this[j[b]]=g[j[b]])}return bt.prototype.name="",bt.prototype.type=null,bt.prototype.docString="",bt.create=function(g){return new bt(g)},bt.encode=function(g,j){return j||(j=d.create()),g.name!=null&&Object.hasOwnProperty.call(g,"name")&&j.uint32(10).string(g.name),g.type!=null&&Object.hasOwnProperty.call(g,"type")&&h.onnx.TypeProto.encode(g.type,j.uint32(18).fork()).ldelim(),g.docString!=null&&Object.hasOwnProperty.call(g,"docString")&&j.uint32(26).string(g.docString),j},bt.encodeDelimited=function(g,j){return this.encode(g,j).ldelim()},bt.decode=function(g,j){g instanceof s||(g=s.create(g));for(var b=j===void 0?g.len:g.pos+j,Et=new h.onnx.ValueInfoProto;g.pos<b;){var It=g.uint32();switch(It>>>3){case 1:{Et.name=g.string();break}case 2:{Et.type=h.onnx.TypeProto.decode(g,g.uint32());break}case 3:{Et.docString=g.string();break}default:g.skipType(It&7);break}}return Et},bt.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},bt.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.name!=null&&g.hasOwnProperty("name")&&!c.isString(g.name))return"name: string expected";if(g.type!=null&&g.hasOwnProperty("type")){var j=h.onnx.TypeProto.verify(g.type);if(j)return"type."+j}return g.docString!=null&&g.hasOwnProperty("docString")&&!c.isString(g.docString)?"docString: string expected":null},bt.fromObject=function(g){if(g instanceof h.onnx.ValueInfoProto)return g;var j=new h.onnx.ValueInfoProto;if(g.name!=null&&(j.name=String(g.name)),g.type!=null){if(typeof g.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");j.type=h.onnx.TypeProto.fromObject(g.type)}return g.docString!=null&&(j.docString=String(g.docString)),j},bt.toObject=function(g,j){j||(j={});var b={};return j.defaults&&(b.name="",b.type=null,b.docString=""),g.name!=null&&g.hasOwnProperty("name")&&(b.name=g.name),g.type!=null&&g.hasOwnProperty("type")&&(b.type=h.onnx.TypeProto.toObject(g.type,j)),g.docString!=null&&g.hasOwnProperty("docString")&&(b.docString=g.docString),b},bt.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},bt.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.ValueInfoProto"},bt}(),_.NodeProto=function(){function bt(g){if(this.input=[],this.output=[],this.attribute=[],g)for(var j=Object.keys(g),b=0;b<j.length;++b)g[j[b]]!=null&&(this[j[b]]=g[j[b]])}return bt.prototype.input=c.emptyArray,bt.prototype.output=c.emptyArray,bt.prototype.name="",bt.prototype.opType="",bt.prototype.domain="",bt.prototype.attribute=c.emptyArray,bt.prototype.docString="",bt.create=function(g){return new bt(g)},bt.encode=function(g,j){if(j||(j=d.create()),g.input!=null&&g.input.length)for(var b=0;b<g.input.length;++b)j.uint32(10).string(g.input[b]);if(g.output!=null&&g.output.length)for(var b=0;b<g.output.length;++b)j.uint32(18).string(g.output[b]);if(g.name!=null&&Object.hasOwnProperty.call(g,"name")&&j.uint32(26).string(g.name),g.opType!=null&&Object.hasOwnProperty.call(g,"opType")&&j.uint32(34).string(g.opType),g.attribute!=null&&g.attribute.length)for(var b=0;b<g.attribute.length;++b)h.onnx.AttributeProto.encode(g.attribute[b],j.uint32(42).fork()).ldelim();return g.docString!=null&&Object.hasOwnProperty.call(g,"docString")&&j.uint32(50).string(g.docString),g.domain!=null&&Object.hasOwnProperty.call(g,"domain")&&j.uint32(58).string(g.domain),j},bt.encodeDelimited=function(g,j){return this.encode(g,j).ldelim()},bt.decode=function(g,j){g instanceof s||(g=s.create(g));for(var b=j===void 0?g.len:g.pos+j,Et=new h.onnx.NodeProto;g.pos<b;){var It=g.uint32();switch(It>>>3){case 1:{Et.input&&Et.input.length||(Et.input=[]),Et.input.push(g.string());break}case 2:{Et.output&&Et.output.length||(Et.output=[]),Et.output.push(g.string());break}case 3:{Et.name=g.string();break}case 4:{Et.opType=g.string();break}case 7:{Et.domain=g.string();break}case 5:{Et.attribute&&Et.attribute.length||(Et.attribute=[]),Et.attribute.push(h.onnx.AttributeProto.decode(g,g.uint32()));break}case 6:{Et.docString=g.string();break}default:g.skipType(It&7);break}}return Et},bt.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},bt.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.input!=null&&g.hasOwnProperty("input")){if(!Array.isArray(g.input))return"input: array expected";for(var j=0;j<g.input.length;++j)if(!c.isString(g.input[j]))return"input: string[] expected"}if(g.output!=null&&g.hasOwnProperty("output")){if(!Array.isArray(g.output))return"output: array expected";for(var j=0;j<g.output.length;++j)if(!c.isString(g.output[j]))return"output: string[] expected"}if(g.name!=null&&g.hasOwnProperty("name")&&!c.isString(g.name))return"name: string expected";if(g.opType!=null&&g.hasOwnProperty("opType")&&!c.isString(g.opType))return"opType: string expected";if(g.domain!=null&&g.hasOwnProperty("domain")&&!c.isString(g.domain))return"domain: string expected";if(g.attribute!=null&&g.hasOwnProperty("attribute")){if(!Array.isArray(g.attribute))return"attribute: array expected";for(var j=0;j<g.attribute.length;++j){var b=h.onnx.AttributeProto.verify(g.attribute[j]);if(b)return"attribute."+b}}return g.docString!=null&&g.hasOwnProperty("docString")&&!c.isString(g.docString)?"docString: string expected":null},bt.fromObject=function(g){if(g instanceof h.onnx.NodeProto)return g;var j=new h.onnx.NodeProto;if(g.input){if(!Array.isArray(g.input))throw TypeError(".onnx.NodeProto.input: array expected");j.input=[];for(var b=0;b<g.input.length;++b)j.input[b]=String(g.input[b])}if(g.output){if(!Array.isArray(g.output))throw TypeError(".onnx.NodeProto.output: array expected");j.output=[];for(var b=0;b<g.output.length;++b)j.output[b]=String(g.output[b])}if(g.name!=null&&(j.name=String(g.name)),g.opType!=null&&(j.opType=String(g.opType)),g.domain!=null&&(j.domain=String(g.domain)),g.attribute){if(!Array.isArray(g.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");j.attribute=[];for(var b=0;b<g.attribute.length;++b){if(typeof g.attribute[b]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");j.attribute[b]=h.onnx.AttributeProto.fromObject(g.attribute[b])}}return g.docString!=null&&(j.docString=String(g.docString)),j},bt.toObject=function(g,j){j||(j={});var b={};if((j.arrays||j.defaults)&&(b.input=[],b.output=[],b.attribute=[]),j.defaults&&(b.name="",b.opType="",b.docString="",b.domain=""),g.input&&g.input.length){b.input=[];for(var Et=0;Et<g.input.length;++Et)b.input[Et]=g.input[Et]}if(g.output&&g.output.length){b.output=[];for(var Et=0;Et<g.output.length;++Et)b.output[Et]=g.output[Et]}if(g.name!=null&&g.hasOwnProperty("name")&&(b.name=g.name),g.opType!=null&&g.hasOwnProperty("opType")&&(b.opType=g.opType),g.attribute&&g.attribute.length){b.attribute=[];for(var Et=0;Et<g.attribute.length;++Et)b.attribute[Et]=h.onnx.AttributeProto.toObject(g.attribute[Et],j)}return g.docString!=null&&g.hasOwnProperty("docString")&&(b.docString=g.docString),g.domain!=null&&g.hasOwnProperty("domain")&&(b.domain=g.domain),b},bt.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},bt.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.NodeProto"},bt}(),_.TrainingInfoProto=function(){function bt(g){if(this.initializationBinding=[],this.updateBinding=[],g)for(var j=Object.keys(g),b=0;b<j.length;++b)g[j[b]]!=null&&(this[j[b]]=g[j[b]])}return bt.prototype.initialization=null,bt.prototype.algorithm=null,bt.prototype.initializationBinding=c.emptyArray,bt.prototype.updateBinding=c.emptyArray,bt.create=function(g){return new bt(g)},bt.encode=function(g,j){if(j||(j=d.create()),g.initialization!=null&&Object.hasOwnProperty.call(g,"initialization")&&h.onnx.GraphProto.encode(g.initialization,j.uint32(10).fork()).ldelim(),g.algorithm!=null&&Object.hasOwnProperty.call(g,"algorithm")&&h.onnx.GraphProto.encode(g.algorithm,j.uint32(18).fork()).ldelim(),g.initializationBinding!=null&&g.initializationBinding.length)for(var b=0;b<g.initializationBinding.length;++b)h.onnx.StringStringEntryProto.encode(g.initializationBinding[b],j.uint32(26).fork()).ldelim();if(g.updateBinding!=null&&g.updateBinding.length)for(var b=0;b<g.updateBinding.length;++b)h.onnx.StringStringEntryProto.encode(g.updateBinding[b],j.uint32(34).fork()).ldelim();return j},bt.encodeDelimited=function(g,j){return this.encode(g,j).ldelim()},bt.decode=function(g,j){g instanceof s||(g=s.create(g));for(var b=j===void 0?g.len:g.pos+j,Et=new h.onnx.TrainingInfoProto;g.pos<b;){var It=g.uint32();switch(It>>>3){case 1:{Et.initialization=h.onnx.GraphProto.decode(g,g.uint32());break}case 2:{Et.algorithm=h.onnx.GraphProto.decode(g,g.uint32());break}case 3:{Et.initializationBinding&&Et.initializationBinding.length||(Et.initializationBinding=[]),Et.initializationBinding.push(h.onnx.StringStringEntryProto.decode(g,g.uint32()));break}case 4:{Et.updateBinding&&Et.updateBinding.length||(Et.updateBinding=[]),Et.updateBinding.push(h.onnx.StringStringEntryProto.decode(g,g.uint32()));break}default:g.skipType(It&7);break}}return Et},bt.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},bt.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.initialization!=null&&g.hasOwnProperty("initialization")){var j=h.onnx.GraphProto.verify(g.initialization);if(j)return"initialization."+j}if(g.algorithm!=null&&g.hasOwnProperty("algorithm")){var j=h.onnx.GraphProto.verify(g.algorithm);if(j)return"algorithm."+j}if(g.initializationBinding!=null&&g.hasOwnProperty("initializationBinding")){if(!Array.isArray(g.initializationBinding))return"initializationBinding: array expected";for(var b=0;b<g.initializationBinding.length;++b){var j=h.onnx.StringStringEntryProto.verify(g.initializationBinding[b]);if(j)return"initializationBinding."+j}}if(g.updateBinding!=null&&g.hasOwnProperty("updateBinding")){if(!Array.isArray(g.updateBinding))return"updateBinding: array expected";for(var b=0;b<g.updateBinding.length;++b){var j=h.onnx.StringStringEntryProto.verify(g.updateBinding[b]);if(j)return"updateBinding."+j}}return null},bt.fromObject=function(g){if(g instanceof h.onnx.TrainingInfoProto)return g;var j=new h.onnx.TrainingInfoProto;if(g.initialization!=null){if(typeof g.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");j.initialization=h.onnx.GraphProto.fromObject(g.initialization)}if(g.algorithm!=null){if(typeof g.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");j.algorithm=h.onnx.GraphProto.fromObject(g.algorithm)}if(g.initializationBinding){if(!Array.isArray(g.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");j.initializationBinding=[];for(var b=0;b<g.initializationBinding.length;++b){if(typeof g.initializationBinding[b]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");j.initializationBinding[b]=h.onnx.StringStringEntryProto.fromObject(g.initializationBinding[b])}}if(g.updateBinding){if(!Array.isArray(g.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");j.updateBinding=[];for(var b=0;b<g.updateBinding.length;++b){if(typeof g.updateBinding[b]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");j.updateBinding[b]=h.onnx.StringStringEntryProto.fromObject(g.updateBinding[b])}}return j},bt.toObject=function(g,j){j||(j={});var b={};if((j.arrays||j.defaults)&&(b.initializationBinding=[],b.updateBinding=[]),j.defaults&&(b.initialization=null,b.algorithm=null),g.initialization!=null&&g.hasOwnProperty("initialization")&&(b.initialization=h.onnx.GraphProto.toObject(g.initialization,j)),g.algorithm!=null&&g.hasOwnProperty("algorithm")&&(b.algorithm=h.onnx.GraphProto.toObject(g.algorithm,j)),g.initializationBinding&&g.initializationBinding.length){b.initializationBinding=[];for(var Et=0;Et<g.initializationBinding.length;++Et)b.initializationBinding[Et]=h.onnx.StringStringEntryProto.toObject(g.initializationBinding[Et],j)}if(g.updateBinding&&g.updateBinding.length){b.updateBinding=[];for(var Et=0;Et<g.updateBinding.length;++Et)b.updateBinding[Et]=h.onnx.StringStringEntryProto.toObject(g.updateBinding[Et],j)}return b},bt.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},bt.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.TrainingInfoProto"},bt}(),_.ModelProto=function(){function bt(g){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],g)for(var j=Object.keys(g),b=0;b<j.length;++b)g[j[b]]!=null&&(this[j[b]]=g[j[b]])}return bt.prototype.irVersion=c.Long?c.Long.fromBits(0,0,!1):0,bt.prototype.opsetImport=c.emptyArray,bt.prototype.producerName="",bt.prototype.producerVersion="",bt.prototype.domain="",bt.prototype.modelVersion=c.Long?c.Long.fromBits(0,0,!1):0,bt.prototype.docString="",bt.prototype.graph=null,bt.prototype.metadataProps=c.emptyArray,bt.prototype.trainingInfo=c.emptyArray,bt.prototype.functions=c.emptyArray,bt.create=function(g){return new bt(g)},bt.encode=function(g,j){if(j||(j=d.create()),g.irVersion!=null&&Object.hasOwnProperty.call(g,"irVersion")&&j.uint32(8).int64(g.irVersion),g.producerName!=null&&Object.hasOwnProperty.call(g,"producerName")&&j.uint32(18).string(g.producerName),g.producerVersion!=null&&Object.hasOwnProperty.call(g,"producerVersion")&&j.uint32(26).string(g.producerVersion),g.domain!=null&&Object.hasOwnProperty.call(g,"domain")&&j.uint32(34).string(g.domain),g.modelVersion!=null&&Object.hasOwnProperty.call(g,"modelVersion")&&j.uint32(40).int64(g.modelVersion),g.docString!=null&&Object.hasOwnProperty.call(g,"docString")&&j.uint32(50).string(g.docString),g.graph!=null&&Object.hasOwnProperty.call(g,"graph")&&h.onnx.GraphProto.encode(g.graph,j.uint32(58).fork()).ldelim(),g.opsetImport!=null&&g.opsetImport.length)for(var b=0;b<g.opsetImport.length;++b)h.onnx.OperatorSetIdProto.encode(g.opsetImport[b],j.uint32(66).fork()).ldelim();if(g.metadataProps!=null&&g.metadataProps.length)for(var b=0;b<g.metadataProps.length;++b)h.onnx.StringStringEntryProto.encode(g.metadataProps[b],j.uint32(114).fork()).ldelim();if(g.trainingInfo!=null&&g.trainingInfo.length)for(var b=0;b<g.trainingInfo.length;++b)h.onnx.TrainingInfoProto.encode(g.trainingInfo[b],j.uint32(162).fork()).ldelim();if(g.functions!=null&&g.functions.length)for(var b=0;b<g.functions.length;++b)h.onnx.FunctionProto.encode(g.functions[b],j.uint32(202).fork()).ldelim();return j},bt.encodeDelimited=function(g,j){return this.encode(g,j).ldelim()},bt.decode=function(g,j){g instanceof s||(g=s.create(g));for(var b=j===void 0?g.len:g.pos+j,Et=new h.onnx.ModelProto;g.pos<b;){var It=g.uint32();switch(It>>>3){case 1:{Et.irVersion=g.int64();break}case 8:{Et.opsetImport&&Et.opsetImport.length||(Et.opsetImport=[]),Et.opsetImport.push(h.onnx.OperatorSetIdProto.decode(g,g.uint32()));break}case 2:{Et.producerName=g.string();break}case 3:{Et.producerVersion=g.string();break}case 4:{Et.domain=g.string();break}case 5:{Et.modelVersion=g.int64();break}case 6:{Et.docString=g.string();break}case 7:{Et.graph=h.onnx.GraphProto.decode(g,g.uint32());break}case 14:{Et.metadataProps&&Et.metadataProps.length||(Et.metadataProps=[]),Et.metadataProps.push(h.onnx.StringStringEntryProto.decode(g,g.uint32()));break}case 20:{Et.trainingInfo&&Et.trainingInfo.length||(Et.trainingInfo=[]),Et.trainingInfo.push(h.onnx.TrainingInfoProto.decode(g,g.uint32()));break}case 25:{Et.functions&&Et.functions.length||(Et.functions=[]),Et.functions.push(h.onnx.FunctionProto.decode(g,g.uint32()));break}default:g.skipType(It&7);break}}return Et},bt.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},bt.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.irVersion!=null&&g.hasOwnProperty("irVersion")&&!c.isInteger(g.irVersion)&&!(g.irVersion&&c.isInteger(g.irVersion.low)&&c.isInteger(g.irVersion.high)))return"irVersion: integer|Long expected";if(g.opsetImport!=null&&g.hasOwnProperty("opsetImport")){if(!Array.isArray(g.opsetImport))return"opsetImport: array expected";for(var j=0;j<g.opsetImport.length;++j){var b=h.onnx.OperatorSetIdProto.verify(g.opsetImport[j]);if(b)return"opsetImport."+b}}if(g.producerName!=null&&g.hasOwnProperty("producerName")&&!c.isString(g.producerName))return"producerName: string expected";if(g.producerVersion!=null&&g.hasOwnProperty("producerVersion")&&!c.isString(g.producerVersion))return"producerVersion: string expected";if(g.domain!=null&&g.hasOwnProperty("domain")&&!c.isString(g.domain))return"domain: string expected";if(g.modelVersion!=null&&g.hasOwnProperty("modelVersion")&&!c.isInteger(g.modelVersion)&&!(g.modelVersion&&c.isInteger(g.modelVersion.low)&&c.isInteger(g.modelVersion.high)))return"modelVersion: integer|Long expected";if(g.docString!=null&&g.hasOwnProperty("docString")&&!c.isString(g.docString))return"docString: string expected";if(g.graph!=null&&g.hasOwnProperty("graph")){var b=h.onnx.GraphProto.verify(g.graph);if(b)return"graph."+b}if(g.metadataProps!=null&&g.hasOwnProperty("metadataProps")){if(!Array.isArray(g.metadataProps))return"metadataProps: array expected";for(var j=0;j<g.metadataProps.length;++j){var b=h.onnx.StringStringEntryProto.verify(g.metadataProps[j]);if(b)return"metadataProps."+b}}if(g.trainingInfo!=null&&g.hasOwnProperty("trainingInfo")){if(!Array.isArray(g.trainingInfo))return"trainingInfo: array expected";for(var j=0;j<g.trainingInfo.length;++j){var b=h.onnx.TrainingInfoProto.verify(g.trainingInfo[j]);if(b)return"trainingInfo."+b}}if(g.functions!=null&&g.hasOwnProperty("functions")){if(!Array.isArray(g.functions))return"functions: array expected";for(var j=0;j<g.functions.length;++j){var b=h.onnx.FunctionProto.verify(g.functions[j]);if(b)return"functions."+b}}return null},bt.fromObject=function(g){if(g instanceof h.onnx.ModelProto)return g;var j=new h.onnx.ModelProto;if(g.irVersion!=null&&(c.Long?(j.irVersion=c.Long.fromValue(g.irVersion)).unsigned=!1:typeof g.irVersion=="string"?j.irVersion=parseInt(g.irVersion,10):typeof g.irVersion=="number"?j.irVersion=g.irVersion:typeof g.irVersion=="object"&&(j.irVersion=new c.LongBits(g.irVersion.low>>>0,g.irVersion.high>>>0).toNumber())),g.opsetImport){if(!Array.isArray(g.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");j.opsetImport=[];for(var b=0;b<g.opsetImport.length;++b){if(typeof g.opsetImport[b]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");j.opsetImport[b]=h.onnx.OperatorSetIdProto.fromObject(g.opsetImport[b])}}if(g.producerName!=null&&(j.producerName=String(g.producerName)),g.producerVersion!=null&&(j.producerVersion=String(g.producerVersion)),g.domain!=null&&(j.domain=String(g.domain)),g.modelVersion!=null&&(c.Long?(j.modelVersion=c.Long.fromValue(g.modelVersion)).unsigned=!1:typeof g.modelVersion=="string"?j.modelVersion=parseInt(g.modelVersion,10):typeof g.modelVersion=="number"?j.modelVersion=g.modelVersion:typeof g.modelVersion=="object"&&(j.modelVersion=new c.LongBits(g.modelVersion.low>>>0,g.modelVersion.high>>>0).toNumber())),g.docString!=null&&(j.docString=String(g.docString)),g.graph!=null){if(typeof g.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");j.graph=h.onnx.GraphProto.fromObject(g.graph)}if(g.metadataProps){if(!Array.isArray(g.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");j.metadataProps=[];for(var b=0;b<g.metadataProps.length;++b){if(typeof g.metadataProps[b]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");j.metadataProps[b]=h.onnx.StringStringEntryProto.fromObject(g.metadataProps[b])}}if(g.trainingInfo){if(!Array.isArray(g.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");j.trainingInfo=[];for(var b=0;b<g.trainingInfo.length;++b){if(typeof g.trainingInfo[b]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");j.trainingInfo[b]=h.onnx.TrainingInfoProto.fromObject(g.trainingInfo[b])}}if(g.functions){if(!Array.isArray(g.functions))throw TypeError(".onnx.ModelProto.functions: array expected");j.functions=[];for(var b=0;b<g.functions.length;++b){if(typeof g.functions[b]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");j.functions[b]=h.onnx.FunctionProto.fromObject(g.functions[b])}}return j},bt.toObject=function(g,j){j||(j={});var b={};if((j.arrays||j.defaults)&&(b.opsetImport=[],b.metadataProps=[],b.trainingInfo=[],b.functions=[]),j.defaults){if(c.Long){var Et=new c.Long(0,0,!1);b.irVersion=j.longs===String?Et.toString():j.longs===Number?Et.toNumber():Et}else b.irVersion=j.longs===String?"0":0;if(b.producerName="",b.producerVersion="",b.domain="",c.Long){var Et=new c.Long(0,0,!1);b.modelVersion=j.longs===String?Et.toString():j.longs===Number?Et.toNumber():Et}else b.modelVersion=j.longs===String?"0":0;b.docString="",b.graph=null}if(g.irVersion!=null&&g.hasOwnProperty("irVersion")&&(typeof g.irVersion=="number"?b.irVersion=j.longs===String?String(g.irVersion):g.irVersion:b.irVersion=j.longs===String?c.Long.prototype.toString.call(g.irVersion):j.longs===Number?new c.LongBits(g.irVersion.low>>>0,g.irVersion.high>>>0).toNumber():g.irVersion),g.producerName!=null&&g.hasOwnProperty("producerName")&&(b.producerName=g.producerName),g.producerVersion!=null&&g.hasOwnProperty("producerVersion")&&(b.producerVersion=g.producerVersion),g.domain!=null&&g.hasOwnProperty("domain")&&(b.domain=g.domain),g.modelVersion!=null&&g.hasOwnProperty("modelVersion")&&(typeof g.modelVersion=="number"?b.modelVersion=j.longs===String?String(g.modelVersion):g.modelVersion:b.modelVersion=j.longs===String?c.Long.prototype.toString.call(g.modelVersion):j.longs===Number?new c.LongBits(g.modelVersion.low>>>0,g.modelVersion.high>>>0).toNumber():g.modelVersion),g.docString!=null&&g.hasOwnProperty("docString")&&(b.docString=g.docString),g.graph!=null&&g.hasOwnProperty("graph")&&(b.graph=h.onnx.GraphProto.toObject(g.graph,j)),g.opsetImport&&g.opsetImport.length){b.opsetImport=[];for(var It=0;It<g.opsetImport.length;++It)b.opsetImport[It]=h.onnx.OperatorSetIdProto.toObject(g.opsetImport[It],j)}if(g.metadataProps&&g.metadataProps.length){b.metadataProps=[];for(var It=0;It<g.metadataProps.length;++It)b.metadataProps[It]=h.onnx.StringStringEntryProto.toObject(g.metadataProps[It],j)}if(g.trainingInfo&&g.trainingInfo.length){b.trainingInfo=[];for(var It=0;It<g.trainingInfo.length;++It)b.trainingInfo[It]=h.onnx.TrainingInfoProto.toObject(g.trainingInfo[It],j)}if(g.functions&&g.functions.length){b.functions=[];for(var It=0;It<g.functions.length;++It)b.functions[It]=h.onnx.FunctionProto.toObject(g.functions[It],j)}return b},bt.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},bt.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.ModelProto"},bt}(),_.StringStringEntryProto=function(){function bt(g){if(g)for(var j=Object.keys(g),b=0;b<j.length;++b)g[j[b]]!=null&&(this[j[b]]=g[j[b]])}return bt.prototype.key="",bt.prototype.value="",bt.create=function(g){return new bt(g)},bt.encode=function(g,j){return j||(j=d.create()),g.key!=null&&Object.hasOwnProperty.call(g,"key")&&j.uint32(10).string(g.key),g.value!=null&&Object.hasOwnProperty.call(g,"value")&&j.uint32(18).string(g.value),j},bt.encodeDelimited=function(g,j){return this.encode(g,j).ldelim()},bt.decode=function(g,j){g instanceof s||(g=s.create(g));for(var b=j===void 0?g.len:g.pos+j,Et=new h.onnx.StringStringEntryProto;g.pos<b;){var It=g.uint32();switch(It>>>3){case 1:{Et.key=g.string();break}case 2:{Et.value=g.string();break}default:g.skipType(It&7);break}}return Et},bt.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},bt.verify=function(g){return typeof g!="object"||g===null?"object expected":g.key!=null&&g.hasOwnProperty("key")&&!c.isString(g.key)?"key: string expected":g.value!=null&&g.hasOwnProperty("value")&&!c.isString(g.value)?"value: string expected":null},bt.fromObject=function(g){if(g instanceof h.onnx.StringStringEntryProto)return g;var j=new h.onnx.StringStringEntryProto;return g.key!=null&&(j.key=String(g.key)),g.value!=null&&(j.value=String(g.value)),j},bt.toObject=function(g,j){j||(j={});var b={};return j.defaults&&(b.key="",b.value=""),g.key!=null&&g.hasOwnProperty("key")&&(b.key=g.key),g.value!=null&&g.hasOwnProperty("value")&&(b.value=g.value),b},bt.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},bt.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.StringStringEntryProto"},bt}(),_.TensorAnnotation=function(){function bt(g){if(this.quantParameterTensorNames=[],g)for(var j=Object.keys(g),b=0;b<j.length;++b)g[j[b]]!=null&&(this[j[b]]=g[j[b]])}return bt.prototype.tensorName="",bt.prototype.quantParameterTensorNames=c.emptyArray,bt.create=function(g){return new bt(g)},bt.encode=function(g,j){if(j||(j=d.create()),g.tensorName!=null&&Object.hasOwnProperty.call(g,"tensorName")&&j.uint32(10).string(g.tensorName),g.quantParameterTensorNames!=null&&g.quantParameterTensorNames.length)for(var b=0;b<g.quantParameterTensorNames.length;++b)h.onnx.StringStringEntryProto.encode(g.quantParameterTensorNames[b],j.uint32(18).fork()).ldelim();return j},bt.encodeDelimited=function(g,j){return this.encode(g,j).ldelim()},bt.decode=function(g,j){g instanceof s||(g=s.create(g));for(var b=j===void 0?g.len:g.pos+j,Et=new h.onnx.TensorAnnotation;g.pos<b;){var It=g.uint32();switch(It>>>3){case 1:{Et.tensorName=g.string();break}case 2:{Et.quantParameterTensorNames&&Et.quantParameterTensorNames.length||(Et.quantParameterTensorNames=[]),Et.quantParameterTensorNames.push(h.onnx.StringStringEntryProto.decode(g,g.uint32()));break}default:g.skipType(It&7);break}}return Et},bt.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},bt.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.tensorName!=null&&g.hasOwnProperty("tensorName")&&!c.isString(g.tensorName))return"tensorName: string expected";if(g.quantParameterTensorNames!=null&&g.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(g.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var j=0;j<g.quantParameterTensorNames.length;++j){var b=h.onnx.StringStringEntryProto.verify(g.quantParameterTensorNames[j]);if(b)return"quantParameterTensorNames."+b}}return null},bt.fromObject=function(g){if(g instanceof h.onnx.TensorAnnotation)return g;var j=new h.onnx.TensorAnnotation;if(g.tensorName!=null&&(j.tensorName=String(g.tensorName)),g.quantParameterTensorNames){if(!Array.isArray(g.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");j.quantParameterTensorNames=[];for(var b=0;b<g.quantParameterTensorNames.length;++b){if(typeof g.quantParameterTensorNames[b]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");j.quantParameterTensorNames[b]=h.onnx.StringStringEntryProto.fromObject(g.quantParameterTensorNames[b])}}return j},bt.toObject=function(g,j){j||(j={});var b={};if((j.arrays||j.defaults)&&(b.quantParameterTensorNames=[]),j.defaults&&(b.tensorName=""),g.tensorName!=null&&g.hasOwnProperty("tensorName")&&(b.tensorName=g.tensorName),g.quantParameterTensorNames&&g.quantParameterTensorNames.length){b.quantParameterTensorNames=[];for(var Et=0;Et<g.quantParameterTensorNames.length;++Et)b.quantParameterTensorNames[Et]=h.onnx.StringStringEntryProto.toObject(g.quantParameterTensorNames[Et],j)}return b},bt.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},bt.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.TensorAnnotation"},bt}(),_.GraphProto=function(){function bt(g){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],g)for(var j=Object.keys(g),b=0;b<j.length;++b)g[j[b]]!=null&&(this[j[b]]=g[j[b]])}return bt.prototype.node=c.emptyArray,bt.prototype.name="",bt.prototype.initializer=c.emptyArray,bt.prototype.sparseInitializer=c.emptyArray,bt.prototype.docString="",bt.prototype.input=c.emptyArray,bt.prototype.output=c.emptyArray,bt.prototype.valueInfo=c.emptyArray,bt.prototype.quantizationAnnotation=c.emptyArray,bt.create=function(g){return new bt(g)},bt.encode=function(g,j){if(j||(j=d.create()),g.node!=null&&g.node.length)for(var b=0;b<g.node.length;++b)h.onnx.NodeProto.encode(g.node[b],j.uint32(10).fork()).ldelim();if(g.name!=null&&Object.hasOwnProperty.call(g,"name")&&j.uint32(18).string(g.name),g.initializer!=null&&g.initializer.length)for(var b=0;b<g.initializer.length;++b)h.onnx.TensorProto.encode(g.initializer[b],j.uint32(42).fork()).ldelim();if(g.docString!=null&&Object.hasOwnProperty.call(g,"docString")&&j.uint32(82).string(g.docString),g.input!=null&&g.input.length)for(var b=0;b<g.input.length;++b)h.onnx.ValueInfoProto.encode(g.input[b],j.uint32(90).fork()).ldelim();if(g.output!=null&&g.output.length)for(var b=0;b<g.output.length;++b)h.onnx.ValueInfoProto.encode(g.output[b],j.uint32(98).fork()).ldelim();if(g.valueInfo!=null&&g.valueInfo.length)for(var b=0;b<g.valueInfo.length;++b)h.onnx.ValueInfoProto.encode(g.valueInfo[b],j.uint32(106).fork()).ldelim();if(g.quantizationAnnotation!=null&&g.quantizationAnnotation.length)for(var b=0;b<g.quantizationAnnotation.length;++b)h.onnx.TensorAnnotation.encode(g.quantizationAnnotation[b],j.uint32(114).fork()).ldelim();if(g.sparseInitializer!=null&&g.sparseInitializer.length)for(var b=0;b<g.sparseInitializer.length;++b)h.onnx.SparseTensorProto.encode(g.sparseInitializer[b],j.uint32(122).fork()).ldelim();return j},bt.encodeDelimited=function(g,j){return this.encode(g,j).ldelim()},bt.decode=function(g,j){g instanceof s||(g=s.create(g));for(var b=j===void 0?g.len:g.pos+j,Et=new h.onnx.GraphProto;g.pos<b;){var It=g.uint32();switch(It>>>3){case 1:{Et.node&&Et.node.length||(Et.node=[]),Et.node.push(h.onnx.NodeProto.decode(g,g.uint32()));break}case 2:{Et.name=g.string();break}case 5:{Et.initializer&&Et.initializer.length||(Et.initializer=[]),Et.initializer.push(h.onnx.TensorProto.decode(g,g.uint32()));break}case 15:{Et.sparseInitializer&&Et.sparseInitializer.length||(Et.sparseInitializer=[]),Et.sparseInitializer.push(h.onnx.SparseTensorProto.decode(g,g.uint32()));break}case 10:{Et.docString=g.string();break}case 11:{Et.input&&Et.input.length||(Et.input=[]),Et.input.push(h.onnx.ValueInfoProto.decode(g,g.uint32()));break}case 12:{Et.output&&Et.output.length||(Et.output=[]),Et.output.push(h.onnx.ValueInfoProto.decode(g,g.uint32()));break}case 13:{Et.valueInfo&&Et.valueInfo.length||(Et.valueInfo=[]),Et.valueInfo.push(h.onnx.ValueInfoProto.decode(g,g.uint32()));break}case 14:{Et.quantizationAnnotation&&Et.quantizationAnnotation.length||(Et.quantizationAnnotation=[]),Et.quantizationAnnotation.push(h.onnx.TensorAnnotation.decode(g,g.uint32()));break}default:g.skipType(It&7);break}}return Et},bt.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},bt.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.node!=null&&g.hasOwnProperty("node")){if(!Array.isArray(g.node))return"node: array expected";for(var j=0;j<g.node.length;++j){var b=h.onnx.NodeProto.verify(g.node[j]);if(b)return"node."+b}}if(g.name!=null&&g.hasOwnProperty("name")&&!c.isString(g.name))return"name: string expected";if(g.initializer!=null&&g.hasOwnProperty("initializer")){if(!Array.isArray(g.initializer))return"initializer: array expected";for(var j=0;j<g.initializer.length;++j){var b=h.onnx.TensorProto.verify(g.initializer[j]);if(b)return"initializer."+b}}if(g.sparseInitializer!=null&&g.hasOwnProperty("sparseInitializer")){if(!Array.isArray(g.sparseInitializer))return"sparseInitializer: array expected";for(var j=0;j<g.sparseInitializer.length;++j){var b=h.onnx.SparseTensorProto.verify(g.sparseInitializer[j]);if(b)return"sparseInitializer."+b}}if(g.docString!=null&&g.hasOwnProperty("docString")&&!c.isString(g.docString))return"docString: string expected";if(g.input!=null&&g.hasOwnProperty("input")){if(!Array.isArray(g.input))return"input: array expected";for(var j=0;j<g.input.length;++j){var b=h.onnx.ValueInfoProto.verify(g.input[j]);if(b)return"input."+b}}if(g.output!=null&&g.hasOwnProperty("output")){if(!Array.isArray(g.output))return"output: array expected";for(var j=0;j<g.output.length;++j){var b=h.onnx.ValueInfoProto.verify(g.output[j]);if(b)return"output."+b}}if(g.valueInfo!=null&&g.hasOwnProperty("valueInfo")){if(!Array.isArray(g.valueInfo))return"valueInfo: array expected";for(var j=0;j<g.valueInfo.length;++j){var b=h.onnx.ValueInfoProto.verify(g.valueInfo[j]);if(b)return"valueInfo."+b}}if(g.quantizationAnnotation!=null&&g.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(g.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var j=0;j<g.quantizationAnnotation.length;++j){var b=h.onnx.TensorAnnotation.verify(g.quantizationAnnotation[j]);if(b)return"quantizationAnnotation."+b}}return null},bt.fromObject=function(g){if(g instanceof h.onnx.GraphProto)return g;var j=new h.onnx.GraphProto;if(g.node){if(!Array.isArray(g.node))throw TypeError(".onnx.GraphProto.node: array expected");j.node=[];for(var b=0;b<g.node.length;++b){if(typeof g.node[b]!="object")throw TypeError(".onnx.GraphProto.node: object expected");j.node[b]=h.onnx.NodeProto.fromObject(g.node[b])}}if(g.name!=null&&(j.name=String(g.name)),g.initializer){if(!Array.isArray(g.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");j.initializer=[];for(var b=0;b<g.initializer.length;++b){if(typeof g.initializer[b]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");j.initializer[b]=h.onnx.TensorProto.fromObject(g.initializer[b])}}if(g.sparseInitializer){if(!Array.isArray(g.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");j.sparseInitializer=[];for(var b=0;b<g.sparseInitializer.length;++b){if(typeof g.sparseInitializer[b]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");j.sparseInitializer[b]=h.onnx.SparseTensorProto.fromObject(g.sparseInitializer[b])}}if(g.docString!=null&&(j.docString=String(g.docString)),g.input){if(!Array.isArray(g.input))throw TypeError(".onnx.GraphProto.input: array expected");j.input=[];for(var b=0;b<g.input.length;++b){if(typeof g.input[b]!="object")throw TypeError(".onnx.GraphProto.input: object expected");j.input[b]=h.onnx.ValueInfoProto.fromObject(g.input[b])}}if(g.output){if(!Array.isArray(g.output))throw TypeError(".onnx.GraphProto.output: array expected");j.output=[];for(var b=0;b<g.output.length;++b){if(typeof g.output[b]!="object")throw TypeError(".onnx.GraphProto.output: object expected");j.output[b]=h.onnx.ValueInfoProto.fromObject(g.output[b])}}if(g.valueInfo){if(!Array.isArray(g.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");j.valueInfo=[];for(var b=0;b<g.valueInfo.length;++b){if(typeof g.valueInfo[b]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");j.valueInfo[b]=h.onnx.ValueInfoProto.fromObject(g.valueInfo[b])}}if(g.quantizationAnnotation){if(!Array.isArray(g.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");j.quantizationAnnotation=[];for(var b=0;b<g.quantizationAnnotation.length;++b){if(typeof g.quantizationAnnotation[b]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");j.quantizationAnnotation[b]=h.onnx.TensorAnnotation.fromObject(g.quantizationAnnotation[b])}}return j},bt.toObject=function(g,j){j||(j={});var b={};if((j.arrays||j.defaults)&&(b.node=[],b.initializer=[],b.input=[],b.output=[],b.valueInfo=[],b.quantizationAnnotation=[],b.sparseInitializer=[]),j.defaults&&(b.name="",b.docString=""),g.node&&g.node.length){b.node=[];for(var Et=0;Et<g.node.length;++Et)b.node[Et]=h.onnx.NodeProto.toObject(g.node[Et],j)}if(g.name!=null&&g.hasOwnProperty("name")&&(b.name=g.name),g.initializer&&g.initializer.length){b.initializer=[];for(var Et=0;Et<g.initializer.length;++Et)b.initializer[Et]=h.onnx.TensorProto.toObject(g.initializer[Et],j)}if(g.docString!=null&&g.hasOwnProperty("docString")&&(b.docString=g.docString),g.input&&g.input.length){b.input=[];for(var Et=0;Et<g.input.length;++Et)b.input[Et]=h.onnx.ValueInfoProto.toObject(g.input[Et],j)}if(g.output&&g.output.length){b.output=[];for(var Et=0;Et<g.output.length;++Et)b.output[Et]=h.onnx.ValueInfoProto.toObject(g.output[Et],j)}if(g.valueInfo&&g.valueInfo.length){b.valueInfo=[];for(var Et=0;Et<g.valueInfo.length;++Et)b.valueInfo[Et]=h.onnx.ValueInfoProto.toObject(g.valueInfo[Et],j)}if(g.quantizationAnnotation&&g.quantizationAnnotation.length){b.quantizationAnnotation=[];for(var Et=0;Et<g.quantizationAnnotation.length;++Et)b.quantizationAnnotation[Et]=h.onnx.TensorAnnotation.toObject(g.quantizationAnnotation[Et],j)}if(g.sparseInitializer&&g.sparseInitializer.length){b.sparseInitializer=[];for(var Et=0;Et<g.sparseInitializer.length;++Et)b.sparseInitializer[Et]=h.onnx.SparseTensorProto.toObject(g.sparseInitializer[Et],j)}return b},bt.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},bt.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.GraphProto"},bt}(),_.TensorProto=function(){function bt(g){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],g)for(var j=Object.keys(g),b=0;b<j.length;++b)g[j[b]]!=null&&(this[j[b]]=g[j[b]])}return bt.prototype.dims=c.emptyArray,bt.prototype.dataType=0,bt.prototype.segment=null,bt.prototype.floatData=c.emptyArray,bt.prototype.int32Data=c.emptyArray,bt.prototype.stringData=c.emptyArray,bt.prototype.int64Data=c.emptyArray,bt.prototype.name="",bt.prototype.docString="",bt.prototype.rawData=c.newBuffer([]),bt.prototype.externalData=c.emptyArray,bt.prototype.dataLocation=0,bt.prototype.doubleData=c.emptyArray,bt.prototype.uint64Data=c.emptyArray,bt.create=function(g){return new bt(g)},bt.encode=function(g,j){if(j||(j=d.create()),g.dims!=null&&g.dims.length){j.uint32(10).fork();for(var b=0;b<g.dims.length;++b)j.int64(g.dims[b]);j.ldelim()}if(g.dataType!=null&&Object.hasOwnProperty.call(g,"dataType")&&j.uint32(16).int32(g.dataType),g.segment!=null&&Object.hasOwnProperty.call(g,"segment")&&h.onnx.TensorProto.Segment.encode(g.segment,j.uint32(26).fork()).ldelim(),g.floatData!=null&&g.floatData.length){j.uint32(34).fork();for(var b=0;b<g.floatData.length;++b)j.float(g.floatData[b]);j.ldelim()}if(g.int32Data!=null&&g.int32Data.length){j.uint32(42).fork();for(var b=0;b<g.int32Data.length;++b)j.int32(g.int32Data[b]);j.ldelim()}if(g.stringData!=null&&g.stringData.length)for(var b=0;b<g.stringData.length;++b)j.uint32(50).bytes(g.stringData[b]);if(g.int64Data!=null&&g.int64Data.length){j.uint32(58).fork();for(var b=0;b<g.int64Data.length;++b)j.int64(g.int64Data[b]);j.ldelim()}if(g.name!=null&&Object.hasOwnProperty.call(g,"name")&&j.uint32(66).string(g.name),g.rawData!=null&&Object.hasOwnProperty.call(g,"rawData")&&j.uint32(74).bytes(g.rawData),g.doubleData!=null&&g.doubleData.length){j.uint32(82).fork();for(var b=0;b<g.doubleData.length;++b)j.double(g.doubleData[b]);j.ldelim()}if(g.uint64Data!=null&&g.uint64Data.length){j.uint32(90).fork();for(var b=0;b<g.uint64Data.length;++b)j.uint64(g.uint64Data[b]);j.ldelim()}if(g.docString!=null&&Object.hasOwnProperty.call(g,"docString")&&j.uint32(98).string(g.docString),g.externalData!=null&&g.externalData.length)for(var b=0;b<g.externalData.length;++b)h.onnx.StringStringEntryProto.encode(g.externalData[b],j.uint32(106).fork()).ldelim();return g.dataLocation!=null&&Object.hasOwnProperty.call(g,"dataLocation")&&j.uint32(112).int32(g.dataLocation),j},bt.encodeDelimited=function(g,j){return this.encode(g,j).ldelim()},bt.decode=function(g,j){g instanceof s||(g=s.create(g));for(var b=j===void 0?g.len:g.pos+j,Et=new h.onnx.TensorProto;g.pos<b;){var It=g.uint32();switch(It>>>3){case 1:{if(Et.dims&&Et.dims.length||(Et.dims=[]),(It&7)===2)for(var zt=g.uint32()+g.pos;g.pos<zt;)Et.dims.push(g.int64());else Et.dims.push(g.int64());break}case 2:{Et.dataType=g.int32();break}case 3:{Et.segment=h.onnx.TensorProto.Segment.decode(g,g.uint32());break}case 4:{if(Et.floatData&&Et.floatData.length||(Et.floatData=[]),(It&7)===2)for(var zt=g.uint32()+g.pos;g.pos<zt;)Et.floatData.push(g.float());else Et.floatData.push(g.float());break}case 5:{if(Et.int32Data&&Et.int32Data.length||(Et.int32Data=[]),(It&7)===2)for(var zt=g.uint32()+g.pos;g.pos<zt;)Et.int32Data.push(g.int32());else Et.int32Data.push(g.int32());break}case 6:{Et.stringData&&Et.stringData.length||(Et.stringData=[]),Et.stringData.push(g.bytes());break}case 7:{if(Et.int64Data&&Et.int64Data.length||(Et.int64Data=[]),(It&7)===2)for(var zt=g.uint32()+g.pos;g.pos<zt;)Et.int64Data.push(g.int64());else Et.int64Data.push(g.int64());break}case 8:{Et.name=g.string();break}case 12:{Et.docString=g.string();break}case 9:{Et.rawData=g.bytes();break}case 13:{Et.externalData&&Et.externalData.length||(Et.externalData=[]),Et.externalData.push(h.onnx.StringStringEntryProto.decode(g,g.uint32()));break}case 14:{Et.dataLocation=g.int32();break}case 10:{if(Et.doubleData&&Et.doubleData.length||(Et.doubleData=[]),(It&7)===2)for(var zt=g.uint32()+g.pos;g.pos<zt;)Et.doubleData.push(g.double());else Et.doubleData.push(g.double());break}case 11:{if(Et.uint64Data&&Et.uint64Data.length||(Et.uint64Data=[]),(It&7)===2)for(var zt=g.uint32()+g.pos;g.pos<zt;)Et.uint64Data.push(g.uint64());else Et.uint64Data.push(g.uint64());break}default:g.skipType(It&7);break}}return Et},bt.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},bt.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.dims!=null&&g.hasOwnProperty("dims")){if(!Array.isArray(g.dims))return"dims: array expected";for(var j=0;j<g.dims.length;++j)if(!c.isInteger(g.dims[j])&&!(g.dims[j]&&c.isInteger(g.dims[j].low)&&c.isInteger(g.dims[j].high)))return"dims: integer|Long[] expected"}if(g.dataType!=null&&g.hasOwnProperty("dataType")&&!c.isInteger(g.dataType))return"dataType: integer expected";if(g.segment!=null&&g.hasOwnProperty("segment")){var b=h.onnx.TensorProto.Segment.verify(g.segment);if(b)return"segment."+b}if(g.floatData!=null&&g.hasOwnProperty("floatData")){if(!Array.isArray(g.floatData))return"floatData: array expected";for(var j=0;j<g.floatData.length;++j)if(typeof g.floatData[j]!="number")return"floatData: number[] expected"}if(g.int32Data!=null&&g.hasOwnProperty("int32Data")){if(!Array.isArray(g.int32Data))return"int32Data: array expected";for(var j=0;j<g.int32Data.length;++j)if(!c.isInteger(g.int32Data[j]))return"int32Data: integer[] expected"}if(g.stringData!=null&&g.hasOwnProperty("stringData")){if(!Array.isArray(g.stringData))return"stringData: array expected";for(var j=0;j<g.stringData.length;++j)if(!(g.stringData[j]&&typeof g.stringData[j].length=="number"||c.isString(g.stringData[j])))return"stringData: buffer[] expected"}if(g.int64Data!=null&&g.hasOwnProperty("int64Data")){if(!Array.isArray(g.int64Data))return"int64Data: array expected";for(var j=0;j<g.int64Data.length;++j)if(!c.isInteger(g.int64Data[j])&&!(g.int64Data[j]&&c.isInteger(g.int64Data[j].low)&&c.isInteger(g.int64Data[j].high)))return"int64Data: integer|Long[] expected"}if(g.name!=null&&g.hasOwnProperty("name")&&!c.isString(g.name))return"name: string expected";if(g.docString!=null&&g.hasOwnProperty("docString")&&!c.isString(g.docString))return"docString: string expected";if(g.rawData!=null&&g.hasOwnProperty("rawData")&&!(g.rawData&&typeof g.rawData.length=="number"||c.isString(g.rawData)))return"rawData: buffer expected";if(g.externalData!=null&&g.hasOwnProperty("externalData")){if(!Array.isArray(g.externalData))return"externalData: array expected";for(var j=0;j<g.externalData.length;++j){var b=h.onnx.StringStringEntryProto.verify(g.externalData[j]);if(b)return"externalData."+b}}if(g.dataLocation!=null&&g.hasOwnProperty("dataLocation"))switch(g.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(g.doubleData!=null&&g.hasOwnProperty("doubleData")){if(!Array.isArray(g.doubleData))return"doubleData: array expected";for(var j=0;j<g.doubleData.length;++j)if(typeof g.doubleData[j]!="number")return"doubleData: number[] expected"}if(g.uint64Data!=null&&g.hasOwnProperty("uint64Data")){if(!Array.isArray(g.uint64Data))return"uint64Data: array expected";for(var j=0;j<g.uint64Data.length;++j)if(!c.isInteger(g.uint64Data[j])&&!(g.uint64Data[j]&&c.isInteger(g.uint64Data[j].low)&&c.isInteger(g.uint64Data[j].high)))return"uint64Data: integer|Long[] expected"}return null},bt.fromObject=function(g){if(g instanceof h.onnx.TensorProto)return g;var j=new h.onnx.TensorProto;if(g.dims){if(!Array.isArray(g.dims))throw TypeError(".onnx.TensorProto.dims: array expected");j.dims=[];for(var b=0;b<g.dims.length;++b)c.Long?(j.dims[b]=c.Long.fromValue(g.dims[b])).unsigned=!1:typeof g.dims[b]=="string"?j.dims[b]=parseInt(g.dims[b],10):typeof g.dims[b]=="number"?j.dims[b]=g.dims[b]:typeof g.dims[b]=="object"&&(j.dims[b]=new c.LongBits(g.dims[b].low>>>0,g.dims[b].high>>>0).toNumber())}if(g.dataType!=null&&(j.dataType=g.dataType|0),g.segment!=null){if(typeof g.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");j.segment=h.onnx.TensorProto.Segment.fromObject(g.segment)}if(g.floatData){if(!Array.isArray(g.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");j.floatData=[];for(var b=0;b<g.floatData.length;++b)j.floatData[b]=Number(g.floatData[b])}if(g.int32Data){if(!Array.isArray(g.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");j.int32Data=[];for(var b=0;b<g.int32Data.length;++b)j.int32Data[b]=g.int32Data[b]|0}if(g.stringData){if(!Array.isArray(g.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");j.stringData=[];for(var b=0;b<g.stringData.length;++b)typeof g.stringData[b]=="string"?c.base64.decode(g.stringData[b],j.stringData[b]=c.newBuffer(c.base64.length(g.stringData[b])),0):g.stringData[b].length>=0&&(j.stringData[b]=g.stringData[b])}if(g.int64Data){if(!Array.isArray(g.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");j.int64Data=[];for(var b=0;b<g.int64Data.length;++b)c.Long?(j.int64Data[b]=c.Long.fromValue(g.int64Data[b])).unsigned=!1:typeof g.int64Data[b]=="string"?j.int64Data[b]=parseInt(g.int64Data[b],10):typeof g.int64Data[b]=="number"?j.int64Data[b]=g.int64Data[b]:typeof g.int64Data[b]=="object"&&(j.int64Data[b]=new c.LongBits(g.int64Data[b].low>>>0,g.int64Data[b].high>>>0).toNumber())}if(g.name!=null&&(j.name=String(g.name)),g.docString!=null&&(j.docString=String(g.docString)),g.rawData!=null&&(typeof g.rawData=="string"?c.base64.decode(g.rawData,j.rawData=c.newBuffer(c.base64.length(g.rawData)),0):g.rawData.length>=0&&(j.rawData=g.rawData)),g.externalData){if(!Array.isArray(g.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");j.externalData=[];for(var b=0;b<g.externalData.length;++b){if(typeof g.externalData[b]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");j.externalData[b]=h.onnx.StringStringEntryProto.fromObject(g.externalData[b])}}switch(g.dataLocation){default:if(typeof g.dataLocation=="number"){j.dataLocation=g.dataLocation;break}break;case"DEFAULT":case 0:j.dataLocation=0;break;case"EXTERNAL":case 1:j.dataLocation=1;break}if(g.doubleData){if(!Array.isArray(g.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");j.doubleData=[];for(var b=0;b<g.doubleData.length;++b)j.doubleData[b]=Number(g.doubleData[b])}if(g.uint64Data){if(!Array.isArray(g.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");j.uint64Data=[];for(var b=0;b<g.uint64Data.length;++b)c.Long?(j.uint64Data[b]=c.Long.fromValue(g.uint64Data[b])).unsigned=!0:typeof g.uint64Data[b]=="string"?j.uint64Data[b]=parseInt(g.uint64Data[b],10):typeof g.uint64Data[b]=="number"?j.uint64Data[b]=g.uint64Data[b]:typeof g.uint64Data[b]=="object"&&(j.uint64Data[b]=new c.LongBits(g.uint64Data[b].low>>>0,g.uint64Data[b].high>>>0).toNumber(!0))}return j},bt.toObject=function(g,j){j||(j={});var b={};if((j.arrays||j.defaults)&&(b.dims=[],b.floatData=[],b.int32Data=[],b.stringData=[],b.int64Data=[],b.doubleData=[],b.uint64Data=[],b.externalData=[]),j.defaults&&(b.dataType=0,b.segment=null,b.name="",j.bytes===String?b.rawData="":(b.rawData=[],j.bytes!==Array&&(b.rawData=c.newBuffer(b.rawData))),b.docString="",b.dataLocation=j.enums===String?"DEFAULT":0),g.dims&&g.dims.length){b.dims=[];for(var Et=0;Et<g.dims.length;++Et)typeof g.dims[Et]=="number"?b.dims[Et]=j.longs===String?String(g.dims[Et]):g.dims[Et]:b.dims[Et]=j.longs===String?c.Long.prototype.toString.call(g.dims[Et]):j.longs===Number?new c.LongBits(g.dims[Et].low>>>0,g.dims[Et].high>>>0).toNumber():g.dims[Et]}if(g.dataType!=null&&g.hasOwnProperty("dataType")&&(b.dataType=g.dataType),g.segment!=null&&g.hasOwnProperty("segment")&&(b.segment=h.onnx.TensorProto.Segment.toObject(g.segment,j)),g.floatData&&g.floatData.length){b.floatData=[];for(var Et=0;Et<g.floatData.length;++Et)b.floatData[Et]=j.json&&!isFinite(g.floatData[Et])?String(g.floatData[Et]):g.floatData[Et]}if(g.int32Data&&g.int32Data.length){b.int32Data=[];for(var Et=0;Et<g.int32Data.length;++Et)b.int32Data[Et]=g.int32Data[Et]}if(g.stringData&&g.stringData.length){b.stringData=[];for(var Et=0;Et<g.stringData.length;++Et)b.stringData[Et]=j.bytes===String?c.base64.encode(g.stringData[Et],0,g.stringData[Et].length):j.bytes===Array?Array.prototype.slice.call(g.stringData[Et]):g.stringData[Et]}if(g.int64Data&&g.int64Data.length){b.int64Data=[];for(var Et=0;Et<g.int64Data.length;++Et)typeof g.int64Data[Et]=="number"?b.int64Data[Et]=j.longs===String?String(g.int64Data[Et]):g.int64Data[Et]:b.int64Data[Et]=j.longs===String?c.Long.prototype.toString.call(g.int64Data[Et]):j.longs===Number?new c.LongBits(g.int64Data[Et].low>>>0,g.int64Data[Et].high>>>0).toNumber():g.int64Data[Et]}if(g.name!=null&&g.hasOwnProperty("name")&&(b.name=g.name),g.rawData!=null&&g.hasOwnProperty("rawData")&&(b.rawData=j.bytes===String?c.base64.encode(g.rawData,0,g.rawData.length):j.bytes===Array?Array.prototype.slice.call(g.rawData):g.rawData),g.doubleData&&g.doubleData.length){b.doubleData=[];for(var Et=0;Et<g.doubleData.length;++Et)b.doubleData[Et]=j.json&&!isFinite(g.doubleData[Et])?String(g.doubleData[Et]):g.doubleData[Et]}if(g.uint64Data&&g.uint64Data.length){b.uint64Data=[];for(var Et=0;Et<g.uint64Data.length;++Et)typeof g.uint64Data[Et]=="number"?b.uint64Data[Et]=j.longs===String?String(g.uint64Data[Et]):g.uint64Data[Et]:b.uint64Data[Et]=j.longs===String?c.Long.prototype.toString.call(g.uint64Data[Et]):j.longs===Number?new c.LongBits(g.uint64Data[Et].low>>>0,g.uint64Data[Et].high>>>0).toNumber(!0):g.uint64Data[Et]}if(g.docString!=null&&g.hasOwnProperty("docString")&&(b.docString=g.docString),g.externalData&&g.externalData.length){b.externalData=[];for(var Et=0;Et<g.externalData.length;++Et)b.externalData[Et]=h.onnx.StringStringEntryProto.toObject(g.externalData[Et],j)}return g.dataLocation!=null&&g.hasOwnProperty("dataLocation")&&(b.dataLocation=j.enums===String?h.onnx.TensorProto.DataLocation[g.dataLocation]===void 0?g.dataLocation:h.onnx.TensorProto.DataLocation[g.dataLocation]:g.dataLocation),b},bt.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},bt.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.TensorProto"},bt.DataType=function(){var g={},j=Object.create(g);return j[g[0]="UNDEFINED"]=0,j[g[1]="FLOAT"]=1,j[g[2]="UINT8"]=2,j[g[3]="INT8"]=3,j[g[4]="UINT16"]=4,j[g[5]="INT16"]=5,j[g[6]="INT32"]=6,j[g[7]="INT64"]=7,j[g[8]="STRING"]=8,j[g[9]="BOOL"]=9,j[g[10]="FLOAT16"]=10,j[g[11]="DOUBLE"]=11,j[g[12]="UINT32"]=12,j[g[13]="UINT64"]=13,j[g[14]="COMPLEX64"]=14,j[g[15]="COMPLEX128"]=15,j[g[16]="BFLOAT16"]=16,j[g[17]="FLOAT8E4M3FN"]=17,j[g[18]="FLOAT8E4M3FNUZ"]=18,j[g[19]="FLOAT8E5M2"]=19,j[g[20]="FLOAT8E5M2FNUZ"]=20,j}(),bt.Segment=function(){function g(j){if(j)for(var b=Object.keys(j),Et=0;Et<b.length;++Et)j[b[Et]]!=null&&(this[b[Et]]=j[b[Et]])}return g.prototype.begin=c.Long?c.Long.fromBits(0,0,!1):0,g.prototype.end=c.Long?c.Long.fromBits(0,0,!1):0,g.create=function(j){return new g(j)},g.encode=function(j,b){return b||(b=d.create()),j.begin!=null&&Object.hasOwnProperty.call(j,"begin")&&b.uint32(8).int64(j.begin),j.end!=null&&Object.hasOwnProperty.call(j,"end")&&b.uint32(16).int64(j.end),b},g.encodeDelimited=function(j,b){return this.encode(j,b).ldelim()},g.decode=function(j,b){j instanceof s||(j=s.create(j));for(var Et=b===void 0?j.len:j.pos+b,It=new h.onnx.TensorProto.Segment;j.pos<Et;){var zt=j.uint32();switch(zt>>>3){case 1:{It.begin=j.int64();break}case 2:{It.end=j.int64();break}default:j.skipType(zt&7);break}}return It},g.decodeDelimited=function(j){return j instanceof s||(j=new s(j)),this.decode(j,j.uint32())},g.verify=function(j){return typeof j!="object"||j===null?"object expected":j.begin!=null&&j.hasOwnProperty("begin")&&!c.isInteger(j.begin)&&!(j.begin&&c.isInteger(j.begin.low)&&c.isInteger(j.begin.high))?"begin: integer|Long expected":j.end!=null&&j.hasOwnProperty("end")&&!c.isInteger(j.end)&&!(j.end&&c.isInteger(j.end.low)&&c.isInteger(j.end.high))?"end: integer|Long expected":null},g.fromObject=function(j){if(j instanceof h.onnx.TensorProto.Segment)return j;var b=new h.onnx.TensorProto.Segment;return j.begin!=null&&(c.Long?(b.begin=c.Long.fromValue(j.begin)).unsigned=!1:typeof j.begin=="string"?b.begin=parseInt(j.begin,10):typeof j.begin=="number"?b.begin=j.begin:typeof j.begin=="object"&&(b.begin=new c.LongBits(j.begin.low>>>0,j.begin.high>>>0).toNumber())),j.end!=null&&(c.Long?(b.end=c.Long.fromValue(j.end)).unsigned=!1:typeof j.end=="string"?b.end=parseInt(j.end,10):typeof j.end=="number"?b.end=j.end:typeof j.end=="object"&&(b.end=new c.LongBits(j.end.low>>>0,j.end.high>>>0).toNumber())),b},g.toObject=function(j,b){b||(b={});var Et={};if(b.defaults){if(c.Long){var It=new c.Long(0,0,!1);Et.begin=b.longs===String?It.toString():b.longs===Number?It.toNumber():It}else Et.begin=b.longs===String?"0":0;if(c.Long){var It=new c.Long(0,0,!1);Et.end=b.longs===String?It.toString():b.longs===Number?It.toNumber():It}else Et.end=b.longs===String?"0":0}return j.begin!=null&&j.hasOwnProperty("begin")&&(typeof j.begin=="number"?Et.begin=b.longs===String?String(j.begin):j.begin:Et.begin=b.longs===String?c.Long.prototype.toString.call(j.begin):b.longs===Number?new c.LongBits(j.begin.low>>>0,j.begin.high>>>0).toNumber():j.begin),j.end!=null&&j.hasOwnProperty("end")&&(typeof j.end=="number"?Et.end=b.longs===String?String(j.end):j.end:Et.end=b.longs===String?c.Long.prototype.toString.call(j.end):b.longs===Number?new c.LongBits(j.end.low>>>0,j.end.high>>>0).toNumber():j.end),Et},g.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},g.getTypeUrl=function(j){return j===void 0&&(j="type.googleapis.com"),j+"/onnx.TensorProto.Segment"},g}(),bt.DataLocation=function(){var g={},j=Object.create(g);return j[g[0]="DEFAULT"]=0,j[g[1]="EXTERNAL"]=1,j}(),bt}(),_.SparseTensorProto=function(){function bt(g){if(this.dims=[],g)for(var j=Object.keys(g),b=0;b<j.length;++b)g[j[b]]!=null&&(this[j[b]]=g[j[b]])}return bt.prototype.values=null,bt.prototype.indices=null,bt.prototype.dims=c.emptyArray,bt.create=function(g){return new bt(g)},bt.encode=function(g,j){if(j||(j=d.create()),g.values!=null&&Object.hasOwnProperty.call(g,"values")&&h.onnx.TensorProto.encode(g.values,j.uint32(10).fork()).ldelim(),g.indices!=null&&Object.hasOwnProperty.call(g,"indices")&&h.onnx.TensorProto.encode(g.indices,j.uint32(18).fork()).ldelim(),g.dims!=null&&g.dims.length){j.uint32(26).fork();for(var b=0;b<g.dims.length;++b)j.int64(g.dims[b]);j.ldelim()}return j},bt.encodeDelimited=function(g,j){return this.encode(g,j).ldelim()},bt.decode=function(g,j){g instanceof s||(g=s.create(g));for(var b=j===void 0?g.len:g.pos+j,Et=new h.onnx.SparseTensorProto;g.pos<b;){var It=g.uint32();switch(It>>>3){case 1:{Et.values=h.onnx.TensorProto.decode(g,g.uint32());break}case 2:{Et.indices=h.onnx.TensorProto.decode(g,g.uint32());break}case 3:{if(Et.dims&&Et.dims.length||(Et.dims=[]),(It&7)===2)for(var zt=g.uint32()+g.pos;g.pos<zt;)Et.dims.push(g.int64());else Et.dims.push(g.int64());break}default:g.skipType(It&7);break}}return Et},bt.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},bt.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.values!=null&&g.hasOwnProperty("values")){var j=h.onnx.TensorProto.verify(g.values);if(j)return"values."+j}if(g.indices!=null&&g.hasOwnProperty("indices")){var j=h.onnx.TensorProto.verify(g.indices);if(j)return"indices."+j}if(g.dims!=null&&g.hasOwnProperty("dims")){if(!Array.isArray(g.dims))return"dims: array expected";for(var b=0;b<g.dims.length;++b)if(!c.isInteger(g.dims[b])&&!(g.dims[b]&&c.isInteger(g.dims[b].low)&&c.isInteger(g.dims[b].high)))return"dims: integer|Long[] expected"}return null},bt.fromObject=function(g){if(g instanceof h.onnx.SparseTensorProto)return g;var j=new h.onnx.SparseTensorProto;if(g.values!=null){if(typeof g.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");j.values=h.onnx.TensorProto.fromObject(g.values)}if(g.indices!=null){if(typeof g.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");j.indices=h.onnx.TensorProto.fromObject(g.indices)}if(g.dims){if(!Array.isArray(g.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");j.dims=[];for(var b=0;b<g.dims.length;++b)c.Long?(j.dims[b]=c.Long.fromValue(g.dims[b])).unsigned=!1:typeof g.dims[b]=="string"?j.dims[b]=parseInt(g.dims[b],10):typeof g.dims[b]=="number"?j.dims[b]=g.dims[b]:typeof g.dims[b]=="object"&&(j.dims[b]=new c.LongBits(g.dims[b].low>>>0,g.dims[b].high>>>0).toNumber())}return j},bt.toObject=function(g,j){j||(j={});var b={};if((j.arrays||j.defaults)&&(b.dims=[]),j.defaults&&(b.values=null,b.indices=null),g.values!=null&&g.hasOwnProperty("values")&&(b.values=h.onnx.TensorProto.toObject(g.values,j)),g.indices!=null&&g.hasOwnProperty("indices")&&(b.indices=h.onnx.TensorProto.toObject(g.indices,j)),g.dims&&g.dims.length){b.dims=[];for(var Et=0;Et<g.dims.length;++Et)typeof g.dims[Et]=="number"?b.dims[Et]=j.longs===String?String(g.dims[Et]):g.dims[Et]:b.dims[Et]=j.longs===String?c.Long.prototype.toString.call(g.dims[Et]):j.longs===Number?new c.LongBits(g.dims[Et].low>>>0,g.dims[Et].high>>>0).toNumber():g.dims[Et]}return b},bt.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},bt.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.SparseTensorProto"},bt}(),_.TensorShapeProto=function(){function bt(g){if(this.dim=[],g)for(var j=Object.keys(g),b=0;b<j.length;++b)g[j[b]]!=null&&(this[j[b]]=g[j[b]])}return bt.prototype.dim=c.emptyArray,bt.create=function(g){return new bt(g)},bt.encode=function(g,j){if(j||(j=d.create()),g.dim!=null&&g.dim.length)for(var b=0;b<g.dim.length;++b)h.onnx.TensorShapeProto.Dimension.encode(g.dim[b],j.uint32(10).fork()).ldelim();return j},bt.encodeDelimited=function(g,j){return this.encode(g,j).ldelim()},bt.decode=function(g,j){g instanceof s||(g=s.create(g));for(var b=j===void 0?g.len:g.pos+j,Et=new h.onnx.TensorShapeProto;g.pos<b;){var It=g.uint32();switch(It>>>3){case 1:{Et.dim&&Et.dim.length||(Et.dim=[]),Et.dim.push(h.onnx.TensorShapeProto.Dimension.decode(g,g.uint32()));break}default:g.skipType(It&7);break}}return Et},bt.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},bt.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.dim!=null&&g.hasOwnProperty("dim")){if(!Array.isArray(g.dim))return"dim: array expected";for(var j=0;j<g.dim.length;++j){var b=h.onnx.TensorShapeProto.Dimension.verify(g.dim[j]);if(b)return"dim."+b}}return null},bt.fromObject=function(g){if(g instanceof h.onnx.TensorShapeProto)return g;var j=new h.onnx.TensorShapeProto;if(g.dim){if(!Array.isArray(g.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");j.dim=[];for(var b=0;b<g.dim.length;++b){if(typeof g.dim[b]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");j.dim[b]=h.onnx.TensorShapeProto.Dimension.fromObject(g.dim[b])}}return j},bt.toObject=function(g,j){j||(j={});var b={};if((j.arrays||j.defaults)&&(b.dim=[]),g.dim&&g.dim.length){b.dim=[];for(var Et=0;Et<g.dim.length;++Et)b.dim[Et]=h.onnx.TensorShapeProto.Dimension.toObject(g.dim[Et],j)}return b},bt.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},bt.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.TensorShapeProto"},bt.Dimension=function(){function g(b){if(b)for(var Et=Object.keys(b),It=0;It<Et.length;++It)b[Et[It]]!=null&&(this[Et[It]]=b[Et[It]])}g.prototype.dimValue=null,g.prototype.dimParam=null,g.prototype.denotation="";var j;return Object.defineProperty(g.prototype,"value",{get:c.oneOfGetter(j=["dimValue","dimParam"]),set:c.oneOfSetter(j)}),g.create=function(b){return new g(b)},g.encode=function(b,Et){return Et||(Et=d.create()),b.dimValue!=null&&Object.hasOwnProperty.call(b,"dimValue")&&Et.uint32(8).int64(b.dimValue),b.dimParam!=null&&Object.hasOwnProperty.call(b,"dimParam")&&Et.uint32(18).string(b.dimParam),b.denotation!=null&&Object.hasOwnProperty.call(b,"denotation")&&Et.uint32(26).string(b.denotation),Et},g.encodeDelimited=function(b,Et){return this.encode(b,Et).ldelim()},g.decode=function(b,Et){b instanceof s||(b=s.create(b));for(var It=Et===void 0?b.len:b.pos+Et,zt=new h.onnx.TensorShapeProto.Dimension;b.pos<It;){var er=b.uint32();switch(er>>>3){case 1:{zt.dimValue=b.int64();break}case 2:{zt.dimParam=b.string();break}case 3:{zt.denotation=b.string();break}default:b.skipType(er&7);break}}return zt},g.decodeDelimited=function(b){return b instanceof s||(b=new s(b)),this.decode(b,b.uint32())},g.verify=function(b){if(typeof b!="object"||b===null)return"object expected";var Et={};if(b.dimValue!=null&&b.hasOwnProperty("dimValue")&&(Et.value=1,!c.isInteger(b.dimValue)&&!(b.dimValue&&c.isInteger(b.dimValue.low)&&c.isInteger(b.dimValue.high))))return"dimValue: integer|Long expected";if(b.dimParam!=null&&b.hasOwnProperty("dimParam")){if(Et.value===1)return"value: multiple values";if(Et.value=1,!c.isString(b.dimParam))return"dimParam: string expected"}return b.denotation!=null&&b.hasOwnProperty("denotation")&&!c.isString(b.denotation)?"denotation: string expected":null},g.fromObject=function(b){if(b instanceof h.onnx.TensorShapeProto.Dimension)return b;var Et=new h.onnx.TensorShapeProto.Dimension;return b.dimValue!=null&&(c.Long?(Et.dimValue=c.Long.fromValue(b.dimValue)).unsigned=!1:typeof b.dimValue=="string"?Et.dimValue=parseInt(b.dimValue,10):typeof b.dimValue=="number"?Et.dimValue=b.dimValue:typeof b.dimValue=="object"&&(Et.dimValue=new c.LongBits(b.dimValue.low>>>0,b.dimValue.high>>>0).toNumber())),b.dimParam!=null&&(Et.dimParam=String(b.dimParam)),b.denotation!=null&&(Et.denotation=String(b.denotation)),Et},g.toObject=function(b,Et){Et||(Et={});var It={};return Et.defaults&&(It.denotation=""),b.dimValue!=null&&b.hasOwnProperty("dimValue")&&(typeof b.dimValue=="number"?It.dimValue=Et.longs===String?String(b.dimValue):b.dimValue:It.dimValue=Et.longs===String?c.Long.prototype.toString.call(b.dimValue):Et.longs===Number?new c.LongBits(b.dimValue.low>>>0,b.dimValue.high>>>0).toNumber():b.dimValue,Et.oneofs&&(It.value="dimValue")),b.dimParam!=null&&b.hasOwnProperty("dimParam")&&(It.dimParam=b.dimParam,Et.oneofs&&(It.value="dimParam")),b.denotation!=null&&b.hasOwnProperty("denotation")&&(It.denotation=b.denotation),It},g.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},g.getTypeUrl=function(b){return b===void 0&&(b="type.googleapis.com"),b+"/onnx.TensorShapeProto.Dimension"},g}(),bt}(),_.TypeProto=function(){function bt(j){if(j)for(var b=Object.keys(j),Et=0;Et<b.length;++Et)j[b[Et]]!=null&&(this[b[Et]]=j[b[Et]])}bt.prototype.tensorType=null,bt.prototype.sequenceType=null,bt.prototype.mapType=null,bt.prototype.optionalType=null,bt.prototype.sparseTensorType=null,bt.prototype.denotation="";var g;return Object.defineProperty(bt.prototype,"value",{get:c.oneOfGetter(g=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:c.oneOfSetter(g)}),bt.create=function(j){return new bt(j)},bt.encode=function(j,b){return b||(b=d.create()),j.tensorType!=null&&Object.hasOwnProperty.call(j,"tensorType")&&h.onnx.TypeProto.Tensor.encode(j.tensorType,b.uint32(10).fork()).ldelim(),j.sequenceType!=null&&Object.hasOwnProperty.call(j,"sequenceType")&&h.onnx.TypeProto.Sequence.encode(j.sequenceType,b.uint32(34).fork()).ldelim(),j.mapType!=null&&Object.hasOwnProperty.call(j,"mapType")&&h.onnx.TypeProto.Map.encode(j.mapType,b.uint32(42).fork()).ldelim(),j.denotation!=null&&Object.hasOwnProperty.call(j,"denotation")&&b.uint32(50).string(j.denotation),j.sparseTensorType!=null&&Object.hasOwnProperty.call(j,"sparseTensorType")&&h.onnx.TypeProto.SparseTensor.encode(j.sparseTensorType,b.uint32(66).fork()).ldelim(),j.optionalType!=null&&Object.hasOwnProperty.call(j,"optionalType")&&h.onnx.TypeProto.Optional.encode(j.optionalType,b.uint32(74).fork()).ldelim(),b},bt.encodeDelimited=function(j,b){return this.encode(j,b).ldelim()},bt.decode=function(j,b){j instanceof s||(j=s.create(j));for(var Et=b===void 0?j.len:j.pos+b,It=new h.onnx.TypeProto;j.pos<Et;){var zt=j.uint32();switch(zt>>>3){case 1:{It.tensorType=h.onnx.TypeProto.Tensor.decode(j,j.uint32());break}case 4:{It.sequenceType=h.onnx.TypeProto.Sequence.decode(j,j.uint32());break}case 5:{It.mapType=h.onnx.TypeProto.Map.decode(j,j.uint32());break}case 9:{It.optionalType=h.onnx.TypeProto.Optional.decode(j,j.uint32());break}case 8:{It.sparseTensorType=h.onnx.TypeProto.SparseTensor.decode(j,j.uint32());break}case 6:{It.denotation=j.string();break}default:j.skipType(zt&7);break}}return It},bt.decodeDelimited=function(j){return j instanceof s||(j=new s(j)),this.decode(j,j.uint32())},bt.verify=function(j){if(typeof j!="object"||j===null)return"object expected";var b={};if(j.tensorType!=null&&j.hasOwnProperty("tensorType")){b.value=1;{var Et=h.onnx.TypeProto.Tensor.verify(j.tensorType);if(Et)return"tensorType."+Et}}if(j.sequenceType!=null&&j.hasOwnProperty("sequenceType")){if(b.value===1)return"value: multiple values";b.value=1;{var Et=h.onnx.TypeProto.Sequence.verify(j.sequenceType);if(Et)return"sequenceType."+Et}}if(j.mapType!=null&&j.hasOwnProperty("mapType")){if(b.value===1)return"value: multiple values";b.value=1;{var Et=h.onnx.TypeProto.Map.verify(j.mapType);if(Et)return"mapType."+Et}}if(j.optionalType!=null&&j.hasOwnProperty("optionalType")){if(b.value===1)return"value: multiple values";b.value=1;{var Et=h.onnx.TypeProto.Optional.verify(j.optionalType);if(Et)return"optionalType."+Et}}if(j.sparseTensorType!=null&&j.hasOwnProperty("sparseTensorType")){if(b.value===1)return"value: multiple values";b.value=1;{var Et=h.onnx.TypeProto.SparseTensor.verify(j.sparseTensorType);if(Et)return"sparseTensorType."+Et}}return j.denotation!=null&&j.hasOwnProperty("denotation")&&!c.isString(j.denotation)?"denotation: string expected":null},bt.fromObject=function(j){if(j instanceof h.onnx.TypeProto)return j;var b=new h.onnx.TypeProto;if(j.tensorType!=null){if(typeof j.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");b.tensorType=h.onnx.TypeProto.Tensor.fromObject(j.tensorType)}if(j.sequenceType!=null){if(typeof j.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");b.sequenceType=h.onnx.TypeProto.Sequence.fromObject(j.sequenceType)}if(j.mapType!=null){if(typeof j.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");b.mapType=h.onnx.TypeProto.Map.fromObject(j.mapType)}if(j.optionalType!=null){if(typeof j.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");b.optionalType=h.onnx.TypeProto.Optional.fromObject(j.optionalType)}if(j.sparseTensorType!=null){if(typeof j.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");b.sparseTensorType=h.onnx.TypeProto.SparseTensor.fromObject(j.sparseTensorType)}return j.denotation!=null&&(b.denotation=String(j.denotation)),b},bt.toObject=function(j,b){b||(b={});var Et={};return b.defaults&&(Et.denotation=""),j.tensorType!=null&&j.hasOwnProperty("tensorType")&&(Et.tensorType=h.onnx.TypeProto.Tensor.toObject(j.tensorType,b),b.oneofs&&(Et.value="tensorType")),j.sequenceType!=null&&j.hasOwnProperty("sequenceType")&&(Et.sequenceType=h.onnx.TypeProto.Sequence.toObject(j.sequenceType,b),b.oneofs&&(Et.value="sequenceType")),j.mapType!=null&&j.hasOwnProperty("mapType")&&(Et.mapType=h.onnx.TypeProto.Map.toObject(j.mapType,b),b.oneofs&&(Et.value="mapType")),j.denotation!=null&&j.hasOwnProperty("denotation")&&(Et.denotation=j.denotation),j.sparseTensorType!=null&&j.hasOwnProperty("sparseTensorType")&&(Et.sparseTensorType=h.onnx.TypeProto.SparseTensor.toObject(j.sparseTensorType,b),b.oneofs&&(Et.value="sparseTensorType")),j.optionalType!=null&&j.hasOwnProperty("optionalType")&&(Et.optionalType=h.onnx.TypeProto.Optional.toObject(j.optionalType,b),b.oneofs&&(Et.value="optionalType")),Et},bt.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},bt.getTypeUrl=function(j){return j===void 0&&(j="type.googleapis.com"),j+"/onnx.TypeProto"},bt.Tensor=function(){function j(b){if(b)for(var Et=Object.keys(b),It=0;It<Et.length;++It)b[Et[It]]!=null&&(this[Et[It]]=b[Et[It]])}return j.prototype.elemType=0,j.prototype.shape=null,j.create=function(b){return new j(b)},j.encode=function(b,Et){return Et||(Et=d.create()),b.elemType!=null&&Object.hasOwnProperty.call(b,"elemType")&&Et.uint32(8).int32(b.elemType),b.shape!=null&&Object.hasOwnProperty.call(b,"shape")&&h.onnx.TensorShapeProto.encode(b.shape,Et.uint32(18).fork()).ldelim(),Et},j.encodeDelimited=function(b,Et){return this.encode(b,Et).ldelim()},j.decode=function(b,Et){b instanceof s||(b=s.create(b));for(var It=Et===void 0?b.len:b.pos+Et,zt=new h.onnx.TypeProto.Tensor;b.pos<It;){var er=b.uint32();switch(er>>>3){case 1:{zt.elemType=b.int32();break}case 2:{zt.shape=h.onnx.TensorShapeProto.decode(b,b.uint32());break}default:b.skipType(er&7);break}}return zt},j.decodeDelimited=function(b){return b instanceof s||(b=new s(b)),this.decode(b,b.uint32())},j.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.elemType!=null&&b.hasOwnProperty("elemType")&&!c.isInteger(b.elemType))return"elemType: integer expected";if(b.shape!=null&&b.hasOwnProperty("shape")){var Et=h.onnx.TensorShapeProto.verify(b.shape);if(Et)return"shape."+Et}return null},j.fromObject=function(b){if(b instanceof h.onnx.TypeProto.Tensor)return b;var Et=new h.onnx.TypeProto.Tensor;if(b.elemType!=null&&(Et.elemType=b.elemType|0),b.shape!=null){if(typeof b.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");Et.shape=h.onnx.TensorShapeProto.fromObject(b.shape)}return Et},j.toObject=function(b,Et){Et||(Et={});var It={};return Et.defaults&&(It.elemType=0,It.shape=null),b.elemType!=null&&b.hasOwnProperty("elemType")&&(It.elemType=b.elemType),b.shape!=null&&b.hasOwnProperty("shape")&&(It.shape=h.onnx.TensorShapeProto.toObject(b.shape,Et)),It},j.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},j.getTypeUrl=function(b){return b===void 0&&(b="type.googleapis.com"),b+"/onnx.TypeProto.Tensor"},j}(),bt.Sequence=function(){function j(b){if(b)for(var Et=Object.keys(b),It=0;It<Et.length;++It)b[Et[It]]!=null&&(this[Et[It]]=b[Et[It]])}return j.prototype.elemType=null,j.create=function(b){return new j(b)},j.encode=function(b,Et){return Et||(Et=d.create()),b.elemType!=null&&Object.hasOwnProperty.call(b,"elemType")&&h.onnx.TypeProto.encode(b.elemType,Et.uint32(10).fork()).ldelim(),Et},j.encodeDelimited=function(b,Et){return this.encode(b,Et).ldelim()},j.decode=function(b,Et){b instanceof s||(b=s.create(b));for(var It=Et===void 0?b.len:b.pos+Et,zt=new h.onnx.TypeProto.Sequence;b.pos<It;){var er=b.uint32();switch(er>>>3){case 1:{zt.elemType=h.onnx.TypeProto.decode(b,b.uint32());break}default:b.skipType(er&7);break}}return zt},j.decodeDelimited=function(b){return b instanceof s||(b=new s(b)),this.decode(b,b.uint32())},j.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.elemType!=null&&b.hasOwnProperty("elemType")){var Et=h.onnx.TypeProto.verify(b.elemType);if(Et)return"elemType."+Et}return null},j.fromObject=function(b){if(b instanceof h.onnx.TypeProto.Sequence)return b;var Et=new h.onnx.TypeProto.Sequence;if(b.elemType!=null){if(typeof b.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");Et.elemType=h.onnx.TypeProto.fromObject(b.elemType)}return Et},j.toObject=function(b,Et){Et||(Et={});var It={};return Et.defaults&&(It.elemType=null),b.elemType!=null&&b.hasOwnProperty("elemType")&&(It.elemType=h.onnx.TypeProto.toObject(b.elemType,Et)),It},j.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},j.getTypeUrl=function(b){return b===void 0&&(b="type.googleapis.com"),b+"/onnx.TypeProto.Sequence"},j}(),bt.Map=function(){function j(b){if(b)for(var Et=Object.keys(b),It=0;It<Et.length;++It)b[Et[It]]!=null&&(this[Et[It]]=b[Et[It]])}return j.prototype.keyType=0,j.prototype.valueType=null,j.create=function(b){return new j(b)},j.encode=function(b,Et){return Et||(Et=d.create()),b.keyType!=null&&Object.hasOwnProperty.call(b,"keyType")&&Et.uint32(8).int32(b.keyType),b.valueType!=null&&Object.hasOwnProperty.call(b,"valueType")&&h.onnx.TypeProto.encode(b.valueType,Et.uint32(18).fork()).ldelim(),Et},j.encodeDelimited=function(b,Et){return this.encode(b,Et).ldelim()},j.decode=function(b,Et){b instanceof s||(b=s.create(b));for(var It=Et===void 0?b.len:b.pos+Et,zt=new h.onnx.TypeProto.Map;b.pos<It;){var er=b.uint32();switch(er>>>3){case 1:{zt.keyType=b.int32();break}case 2:{zt.valueType=h.onnx.TypeProto.decode(b,b.uint32());break}default:b.skipType(er&7);break}}return zt},j.decodeDelimited=function(b){return b instanceof s||(b=new s(b)),this.decode(b,b.uint32())},j.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.keyType!=null&&b.hasOwnProperty("keyType")&&!c.isInteger(b.keyType))return"keyType: integer expected";if(b.valueType!=null&&b.hasOwnProperty("valueType")){var Et=h.onnx.TypeProto.verify(b.valueType);if(Et)return"valueType."+Et}return null},j.fromObject=function(b){if(b instanceof h.onnx.TypeProto.Map)return b;var Et=new h.onnx.TypeProto.Map;if(b.keyType!=null&&(Et.keyType=b.keyType|0),b.valueType!=null){if(typeof b.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");Et.valueType=h.onnx.TypeProto.fromObject(b.valueType)}return Et},j.toObject=function(b,Et){Et||(Et={});var It={};return Et.defaults&&(It.keyType=0,It.valueType=null),b.keyType!=null&&b.hasOwnProperty("keyType")&&(It.keyType=b.keyType),b.valueType!=null&&b.hasOwnProperty("valueType")&&(It.valueType=h.onnx.TypeProto.toObject(b.valueType,Et)),It},j.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},j.getTypeUrl=function(b){return b===void 0&&(b="type.googleapis.com"),b+"/onnx.TypeProto.Map"},j}(),bt.Optional=function(){function j(b){if(b)for(var Et=Object.keys(b),It=0;It<Et.length;++It)b[Et[It]]!=null&&(this[Et[It]]=b[Et[It]])}return j.prototype.elemType=null,j.create=function(b){return new j(b)},j.encode=function(b,Et){return Et||(Et=d.create()),b.elemType!=null&&Object.hasOwnProperty.call(b,"elemType")&&h.onnx.TypeProto.encode(b.elemType,Et.uint32(10).fork()).ldelim(),Et},j.encodeDelimited=function(b,Et){return this.encode(b,Et).ldelim()},j.decode=function(b,Et){b instanceof s||(b=s.create(b));for(var It=Et===void 0?b.len:b.pos+Et,zt=new h.onnx.TypeProto.Optional;b.pos<It;){var er=b.uint32();switch(er>>>3){case 1:{zt.elemType=h.onnx.TypeProto.decode(b,b.uint32());break}default:b.skipType(er&7);break}}return zt},j.decodeDelimited=function(b){return b instanceof s||(b=new s(b)),this.decode(b,b.uint32())},j.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.elemType!=null&&b.hasOwnProperty("elemType")){var Et=h.onnx.TypeProto.verify(b.elemType);if(Et)return"elemType."+Et}return null},j.fromObject=function(b){if(b instanceof h.onnx.TypeProto.Optional)return b;var Et=new h.onnx.TypeProto.Optional;if(b.elemType!=null){if(typeof b.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");Et.elemType=h.onnx.TypeProto.fromObject(b.elemType)}return Et},j.toObject=function(b,Et){Et||(Et={});var It={};return Et.defaults&&(It.elemType=null),b.elemType!=null&&b.hasOwnProperty("elemType")&&(It.elemType=h.onnx.TypeProto.toObject(b.elemType,Et)),It},j.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},j.getTypeUrl=function(b){return b===void 0&&(b="type.googleapis.com"),b+"/onnx.TypeProto.Optional"},j}(),bt.SparseTensor=function(){function j(b){if(b)for(var Et=Object.keys(b),It=0;It<Et.length;++It)b[Et[It]]!=null&&(this[Et[It]]=b[Et[It]])}return j.prototype.elemType=0,j.prototype.shape=null,j.create=function(b){return new j(b)},j.encode=function(b,Et){return Et||(Et=d.create()),b.elemType!=null&&Object.hasOwnProperty.call(b,"elemType")&&Et.uint32(8).int32(b.elemType),b.shape!=null&&Object.hasOwnProperty.call(b,"shape")&&h.onnx.TensorShapeProto.encode(b.shape,Et.uint32(18).fork()).ldelim(),Et},j.encodeDelimited=function(b,Et){return this.encode(b,Et).ldelim()},j.decode=function(b,Et){b instanceof s||(b=s.create(b));for(var It=Et===void 0?b.len:b.pos+Et,zt=new h.onnx.TypeProto.SparseTensor;b.pos<It;){var er=b.uint32();switch(er>>>3){case 1:{zt.elemType=b.int32();break}case 2:{zt.shape=h.onnx.TensorShapeProto.decode(b,b.uint32());break}default:b.skipType(er&7);break}}return zt},j.decodeDelimited=function(b){return b instanceof s||(b=new s(b)),this.decode(b,b.uint32())},j.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.elemType!=null&&b.hasOwnProperty("elemType")&&!c.isInteger(b.elemType))return"elemType: integer expected";if(b.shape!=null&&b.hasOwnProperty("shape")){var Et=h.onnx.TensorShapeProto.verify(b.shape);if(Et)return"shape."+Et}return null},j.fromObject=function(b){if(b instanceof h.onnx.TypeProto.SparseTensor)return b;var Et=new h.onnx.TypeProto.SparseTensor;if(b.elemType!=null&&(Et.elemType=b.elemType|0),b.shape!=null){if(typeof b.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");Et.shape=h.onnx.TensorShapeProto.fromObject(b.shape)}return Et},j.toObject=function(b,Et){Et||(Et={});var It={};return Et.defaults&&(It.elemType=0,It.shape=null),b.elemType!=null&&b.hasOwnProperty("elemType")&&(It.elemType=b.elemType),b.shape!=null&&b.hasOwnProperty("shape")&&(It.shape=h.onnx.TensorShapeProto.toObject(b.shape,Et)),It},j.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},j.getTypeUrl=function(b){return b===void 0&&(b="type.googleapis.com"),b+"/onnx.TypeProto.SparseTensor"},j}(),bt}(),_.OperatorSetIdProto=function(){function bt(g){if(g)for(var j=Object.keys(g),b=0;b<j.length;++b)g[j[b]]!=null&&(this[j[b]]=g[j[b]])}return bt.prototype.domain="",bt.prototype.version=c.Long?c.Long.fromBits(0,0,!1):0,bt.create=function(g){return new bt(g)},bt.encode=function(g,j){return j||(j=d.create()),g.domain!=null&&Object.hasOwnProperty.call(g,"domain")&&j.uint32(10).string(g.domain),g.version!=null&&Object.hasOwnProperty.call(g,"version")&&j.uint32(16).int64(g.version),j},bt.encodeDelimited=function(g,j){return this.encode(g,j).ldelim()},bt.decode=function(g,j){g instanceof s||(g=s.create(g));for(var b=j===void 0?g.len:g.pos+j,Et=new h.onnx.OperatorSetIdProto;g.pos<b;){var It=g.uint32();switch(It>>>3){case 1:{Et.domain=g.string();break}case 2:{Et.version=g.int64();break}default:g.skipType(It&7);break}}return Et},bt.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},bt.verify=function(g){return typeof g!="object"||g===null?"object expected":g.domain!=null&&g.hasOwnProperty("domain")&&!c.isString(g.domain)?"domain: string expected":g.version!=null&&g.hasOwnProperty("version")&&!c.isInteger(g.version)&&!(g.version&&c.isInteger(g.version.low)&&c.isInteger(g.version.high))?"version: integer|Long expected":null},bt.fromObject=function(g){if(g instanceof h.onnx.OperatorSetIdProto)return g;var j=new h.onnx.OperatorSetIdProto;return g.domain!=null&&(j.domain=String(g.domain)),g.version!=null&&(c.Long?(j.version=c.Long.fromValue(g.version)).unsigned=!1:typeof g.version=="string"?j.version=parseInt(g.version,10):typeof g.version=="number"?j.version=g.version:typeof g.version=="object"&&(j.version=new c.LongBits(g.version.low>>>0,g.version.high>>>0).toNumber())),j},bt.toObject=function(g,j){j||(j={});var b={};if(j.defaults)if(b.domain="",c.Long){var Et=new c.Long(0,0,!1);b.version=j.longs===String?Et.toString():j.longs===Number?Et.toNumber():Et}else b.version=j.longs===String?"0":0;return g.domain!=null&&g.hasOwnProperty("domain")&&(b.domain=g.domain),g.version!=null&&g.hasOwnProperty("version")&&(typeof g.version=="number"?b.version=j.longs===String?String(g.version):g.version:b.version=j.longs===String?c.Long.prototype.toString.call(g.version):j.longs===Number?new c.LongBits(g.version.low>>>0,g.version.high>>>0).toNumber():g.version),b},bt.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},bt.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.OperatorSetIdProto"},bt}(),_.OperatorStatus=function(){var bt={},g=Object.create(bt);return g[bt[0]="EXPERIMENTAL"]=0,g[bt[1]="STABLE"]=1,g}(),_.FunctionProto=function(){function bt(g){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],g)for(var j=Object.keys(g),b=0;b<j.length;++b)g[j[b]]!=null&&(this[j[b]]=g[j[b]])}return bt.prototype.name="",bt.prototype.input=c.emptyArray,bt.prototype.output=c.emptyArray,bt.prototype.attribute=c.emptyArray,bt.prototype.attributeProto=c.emptyArray,bt.prototype.node=c.emptyArray,bt.prototype.docString="",bt.prototype.opsetImport=c.emptyArray,bt.prototype.domain="",bt.create=function(g){return new bt(g)},bt.encode=function(g,j){if(j||(j=d.create()),g.name!=null&&Object.hasOwnProperty.call(g,"name")&&j.uint32(10).string(g.name),g.input!=null&&g.input.length)for(var b=0;b<g.input.length;++b)j.uint32(34).string(g.input[b]);if(g.output!=null&&g.output.length)for(var b=0;b<g.output.length;++b)j.uint32(42).string(g.output[b]);if(g.attribute!=null&&g.attribute.length)for(var b=0;b<g.attribute.length;++b)j.uint32(50).string(g.attribute[b]);if(g.node!=null&&g.node.length)for(var b=0;b<g.node.length;++b)h.onnx.NodeProto.encode(g.node[b],j.uint32(58).fork()).ldelim();if(g.docString!=null&&Object.hasOwnProperty.call(g,"docString")&&j.uint32(66).string(g.docString),g.opsetImport!=null&&g.opsetImport.length)for(var b=0;b<g.opsetImport.length;++b)h.onnx.OperatorSetIdProto.encode(g.opsetImport[b],j.uint32(74).fork()).ldelim();if(g.domain!=null&&Object.hasOwnProperty.call(g,"domain")&&j.uint32(82).string(g.domain),g.attributeProto!=null&&g.attributeProto.length)for(var b=0;b<g.attributeProto.length;++b)h.onnx.AttributeProto.encode(g.attributeProto[b],j.uint32(90).fork()).ldelim();return j},bt.encodeDelimited=function(g,j){return this.encode(g,j).ldelim()},bt.decode=function(g,j){g instanceof s||(g=s.create(g));for(var b=j===void 0?g.len:g.pos+j,Et=new h.onnx.FunctionProto;g.pos<b;){var It=g.uint32();switch(It>>>3){case 1:{Et.name=g.string();break}case 4:{Et.input&&Et.input.length||(Et.input=[]),Et.input.push(g.string());break}case 5:{Et.output&&Et.output.length||(Et.output=[]),Et.output.push(g.string());break}case 6:{Et.attribute&&Et.attribute.length||(Et.attribute=[]),Et.attribute.push(g.string());break}case 11:{Et.attributeProto&&Et.attributeProto.length||(Et.attributeProto=[]),Et.attributeProto.push(h.onnx.AttributeProto.decode(g,g.uint32()));break}case 7:{Et.node&&Et.node.length||(Et.node=[]),Et.node.push(h.onnx.NodeProto.decode(g,g.uint32()));break}case 8:{Et.docString=g.string();break}case 9:{Et.opsetImport&&Et.opsetImport.length||(Et.opsetImport=[]),Et.opsetImport.push(h.onnx.OperatorSetIdProto.decode(g,g.uint32()));break}case 10:{Et.domain=g.string();break}default:g.skipType(It&7);break}}return Et},bt.decodeDelimited=function(g){return g instanceof s||(g=new s(g)),this.decode(g,g.uint32())},bt.verify=function(g){if(typeof g!="object"||g===null)return"object expected";if(g.name!=null&&g.hasOwnProperty("name")&&!c.isString(g.name))return"name: string expected";if(g.input!=null&&g.hasOwnProperty("input")){if(!Array.isArray(g.input))return"input: array expected";for(var j=0;j<g.input.length;++j)if(!c.isString(g.input[j]))return"input: string[] expected"}if(g.output!=null&&g.hasOwnProperty("output")){if(!Array.isArray(g.output))return"output: array expected";for(var j=0;j<g.output.length;++j)if(!c.isString(g.output[j]))return"output: string[] expected"}if(g.attribute!=null&&g.hasOwnProperty("attribute")){if(!Array.isArray(g.attribute))return"attribute: array expected";for(var j=0;j<g.attribute.length;++j)if(!c.isString(g.attribute[j]))return"attribute: string[] expected"}if(g.attributeProto!=null&&g.hasOwnProperty("attributeProto")){if(!Array.isArray(g.attributeProto))return"attributeProto: array expected";for(var j=0;j<g.attributeProto.length;++j){var b=h.onnx.AttributeProto.verify(g.attributeProto[j]);if(b)return"attributeProto."+b}}if(g.node!=null&&g.hasOwnProperty("node")){if(!Array.isArray(g.node))return"node: array expected";for(var j=0;j<g.node.length;++j){var b=h.onnx.NodeProto.verify(g.node[j]);if(b)return"node."+b}}if(g.docString!=null&&g.hasOwnProperty("docString")&&!c.isString(g.docString))return"docString: string expected";if(g.opsetImport!=null&&g.hasOwnProperty("opsetImport")){if(!Array.isArray(g.opsetImport))return"opsetImport: array expected";for(var j=0;j<g.opsetImport.length;++j){var b=h.onnx.OperatorSetIdProto.verify(g.opsetImport[j]);if(b)return"opsetImport."+b}}return g.domain!=null&&g.hasOwnProperty("domain")&&!c.isString(g.domain)?"domain: string expected":null},bt.fromObject=function(g){if(g instanceof h.onnx.FunctionProto)return g;var j=new h.onnx.FunctionProto;if(g.name!=null&&(j.name=String(g.name)),g.input){if(!Array.isArray(g.input))throw TypeError(".onnx.FunctionProto.input: array expected");j.input=[];for(var b=0;b<g.input.length;++b)j.input[b]=String(g.input[b])}if(g.output){if(!Array.isArray(g.output))throw TypeError(".onnx.FunctionProto.output: array expected");j.output=[];for(var b=0;b<g.output.length;++b)j.output[b]=String(g.output[b])}if(g.attribute){if(!Array.isArray(g.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");j.attribute=[];for(var b=0;b<g.attribute.length;++b)j.attribute[b]=String(g.attribute[b])}if(g.attributeProto){if(!Array.isArray(g.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");j.attributeProto=[];for(var b=0;b<g.attributeProto.length;++b){if(typeof g.attributeProto[b]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");j.attributeProto[b]=h.onnx.AttributeProto.fromObject(g.attributeProto[b])}}if(g.node){if(!Array.isArray(g.node))throw TypeError(".onnx.FunctionProto.node: array expected");j.node=[];for(var b=0;b<g.node.length;++b){if(typeof g.node[b]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");j.node[b]=h.onnx.NodeProto.fromObject(g.node[b])}}if(g.docString!=null&&(j.docString=String(g.docString)),g.opsetImport){if(!Array.isArray(g.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");j.opsetImport=[];for(var b=0;b<g.opsetImport.length;++b){if(typeof g.opsetImport[b]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");j.opsetImport[b]=h.onnx.OperatorSetIdProto.fromObject(g.opsetImport[b])}}return g.domain!=null&&(j.domain=String(g.domain)),j},bt.toObject=function(g,j){j||(j={});var b={};if((j.arrays||j.defaults)&&(b.input=[],b.output=[],b.attribute=[],b.node=[],b.opsetImport=[],b.attributeProto=[]),j.defaults&&(b.name="",b.docString="",b.domain=""),g.name!=null&&g.hasOwnProperty("name")&&(b.name=g.name),g.input&&g.input.length){b.input=[];for(var Et=0;Et<g.input.length;++Et)b.input[Et]=g.input[Et]}if(g.output&&g.output.length){b.output=[];for(var Et=0;Et<g.output.length;++Et)b.output[Et]=g.output[Et]}if(g.attribute&&g.attribute.length){b.attribute=[];for(var Et=0;Et<g.attribute.length;++Et)b.attribute[Et]=g.attribute[Et]}if(g.node&&g.node.length){b.node=[];for(var Et=0;Et<g.node.length;++Et)b.node[Et]=h.onnx.NodeProto.toObject(g.node[Et],j)}if(g.docString!=null&&g.hasOwnProperty("docString")&&(b.docString=g.docString),g.opsetImport&&g.opsetImport.length){b.opsetImport=[];for(var Et=0;Et<g.opsetImport.length;++Et)b.opsetImport[Et]=h.onnx.OperatorSetIdProto.toObject(g.opsetImport[Et],j)}if(g.domain!=null&&g.hasOwnProperty("domain")&&(b.domain=g.domain),g.attributeProto&&g.attributeProto.length){b.attributeProto=[];for(var Et=0;Et<g.attributeProto.length;++Et)b.attributeProto[Et]=h.onnx.AttributeProto.toObject(g.attributeProto[Et],j)}return b},bt.prototype.toJSON=function(){return this.constructor.toObject(this,o.util.toJSONOptions)},bt.getTypeUrl=function(g){return g===void 0&&(g="type.googleapis.com"),g+"/onnx.FunctionProto"},bt}(),_}(),e.exports=h});function kr$1(a,e){if(!a)throw new Error(typeof e=="string"?e:e())}function ln$1(a){return new TextDecoder().decode(a)}var ye,pr,hi$1,Ke,Xn$1,Ve,nt$1,U,un$1,dr,hr,mr,fe=E(()=>{Wn(),ei(),ye=Er$1($r()),br(),pr=class{static arraysEqual(a,e){if(a.length!==e.length)return!1;for(let o=0;o<a.length;o++)if(a[o]!==e[o])return!1;return!0}},hi$1=class{static preprocessInputShapes(a,e){let o=a.length===1?[1,a[0]]:a,s=e.length===1?[e[0],1]:e;return[o,s]}static postprocessOutputShape(a,e,o){e===1&&a.splice(a.length-2,1),o===1&&a.pop()}static calcMatMulShape(a,e){return a[1]!==e[0]?void 0:[a[0],e[1]]}},Ke=class MS{static calcShape(e,o,s=!1){let d=e.length,c=o.length;if(d===0)return o;if(c===0)return e;let h=Math.max(e.length,o.length),_=new Array(h);if(s){if(d<2||c<2)return;let bt=hi$1.calcMatMulShape([e[d-2],e[d-1]],[o[c-2],o[c-1]]);if(bt===void 0)return;[_[h-2],_[h-1]]=bt}for(let bt=s?3:1;bt<=h;bt++){let g=d-bt<0?1:e[d-bt],j=c-bt<0?1:o[c-bt];if(g!==j&&g>1&&j>1)return;_[h-bt]=Math.max(g,j)}return _}static index(e,o){let s=new Array(o.length);return MS.fillIndex(e,o,s),s}static fillIndex(e,o,s){let d=e.length-o.length;for(let c=0;c<o.length;c++)s[c]=e[d+c]%o[c]}static calc(e,o,s,d,c){let h=MS.calcShape(e.dims,o.dims);if(h){if(d&&!U.areEqual(h,e.dims))return;let _=U.size(h),bt=d?e:new Ce(h,c||e.type);if(h.length===0)bt.set([],s(e.get([]),o.get([])));else{let g=new Array(h.length),j=new Array(e.dims.length),b=new Array(o.dims.length),Et=0,It=0,zt=!1,er=!1;e.dims.length===0&&(Et=e.get([]),zt=!0),o.dims.length===0&&(It=o.get([]),er=!0);let Hn;for(let Qt=0;Qt<_;Qt++){Hn=Qt;for(let cr=h.length-1;cr>=0;cr--)g[cr]=Hn%h[cr],Hn=Math.floor(Hn/h[cr]);zt||(MS.fillIndex(g,e.dims,j),Et=e.get(j)),er||(MS.fillIndex(g,o.dims,b),It=o.get(b)),bt.set(g,s(Et,It))}}return bt}}static isValidBroadcast(e,o){let s=e.length,d=o.length;if(s>d)return!1;for(let c=1;c<=s;c++)if(e[s-c]!==1&&e[s-c]!==o[d-c])return!1;return!0}static getBroadcastDims(e,o){let s=e.length,d=[];for(let c=0;c<s;c++){let h=s-1-c,_=e[h]||1;(o[o.length-1-c]||1)>1&&_===1&&d.unshift(h)}return d}},Xn$1=class{static getShapeOfGemmResult(a,e,o,s,d){if(a.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let c,h,_;e?(c=a[1],h=a[0]):(c=a[0],h=a[1]);let bt=-1;if(s?(_=o[0],bt=1):(_=o[1],bt=0),o[bt]!==h)throw new Error("dimension mismatch");if(c<=0||_<=0||h<=0)throw new Error("invalid shape specified");if(d&&!Ke.isValidBroadcast(d,[c,_]))throw new Error("gemm: invalid bias shape for broadcast");return[c,_,h]}},Ve=class mT{static tensorDataTypeFromProto(e){switch(e){case ye.onnx.TensorProto.DataType.INT8:return"int8";case ye.onnx.TensorProto.DataType.UINT8:return"uint8";case ye.onnx.TensorProto.DataType.BOOL:return"bool";case ye.onnx.TensorProto.DataType.INT16:return"int16";case ye.onnx.TensorProto.DataType.UINT16:return"uint16";case ye.onnx.TensorProto.DataType.INT32:return"int32";case ye.onnx.TensorProto.DataType.UINT32:return"uint32";case ye.onnx.TensorProto.DataType.FLOAT:return"float32";case ye.onnx.TensorProto.DataType.DOUBLE:return"float64";case ye.onnx.TensorProto.DataType.STRING:return"string";case ye.onnx.TensorProto.DataType.INT64:return"int32";case ye.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${ye.onnx.TensorProto.DataType[e]}`)}}static tensorDataTypeStringToEnum(e){switch(e){case"int8":return ye.onnx.TensorProto.DataType.INT8;case"uint8":return ye.onnx.TensorProto.DataType.UINT8;case"bool":return ye.onnx.TensorProto.DataType.BOOL;case"int16":return ye.onnx.TensorProto.DataType.INT16;case"uint16":return ye.onnx.TensorProto.DataType.UINT16;case"int32":return ye.onnx.TensorProto.DataType.INT32;case"uint32":return ye.onnx.TensorProto.DataType.UINT32;case"float32":return ye.onnx.TensorProto.DataType.FLOAT;case"float64":return ye.onnx.TensorProto.DataType.DOUBLE;case"string":return ye.onnx.TensorProto.DataType.STRING;case"int64":return ye.onnx.TensorProto.DataType.INT64;case"uint64":return ye.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${e}`)}}static tensorDimsFromProto(e){return e.map(o=>Wt.isLong(o)?o.toNumber():o)}static tensorValueTypeFromProto(e){return{tensorType:mT.tensorDataTypeFromProto(e.elemType),shape:{dims:mT.tensorDimsFromProto(e.shape.dim.map(o=>o.dimValue))}}}static tensorDimsFromORTFormat(e){let o=[];for(let s=0;s<e.dimsLength();s++)o.push(nt$1.longToNumber(e.dims(s)));return o}static tensorAttributesFromORTFormat(e){let o=[];for(let s=0;s<e.attributesLength();s++)o.push(e.attributes(s));return o}},nt$1=class{static longToNumber(a,e){return Wt.isLong(a)?a.toNumber():a instanceof O.Long?Wt.fromValue({low:a.low,high:a.high,unsigned:e??!1}).toNumber():a}static isLong(a){return Wt.isLong(a)||a instanceof O.Long}},U=class Nx{static size(e){return Nx.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,o){if(o<0||o>e.length)throw new Error(`invalid dimension of ${o} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return Nx.getSizeFromDimensionRange(e,o,e.length)}static sizeToDimension(e,o){if(o<0||o>e.length)throw new Error(`invalid dimension of ${o} for sizeToDimension as Tensor has ${e.length} dimensions.`);return Nx.getSizeFromDimensionRange(e,0,o)}static getSizeFromDimensionRange(e,o,s){let d=1;for(let c=o;c<s;c++){if(e[c]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");d*=e[c]}return d}static computeStrides(e){let o=e.length;if(o===0)return[];if(o===1)return[1];let s=new Array(o);s[o-1]=1,s[o-2]=e[o-1];for(let d=o-3;d>=0;--d)s[d]=s[d+1]*e[d+1];return s}static transpose(e){return e.slice().reverse()}static indicesToOffset(e,o,s){s===void 0&&(s=e.length);let d=0;for(let c=0;c<s;++c)d+=o[c]*e[c];return d}static offsetToIndices(e,o){let s=o.length;if(s===0)return[];if(s===1)return[e*o[0]];let d=new Array(o.length);for(let c=0;c<d.length-1;++c)d[c]=Math.floor(e/o[c]),e-=d[c]*o[c];return d[d.length-1]=e,d}static normalizeAxis(e,o){if(e<-o&&e>=o)throw new Error("unsupported axis for this operation.");return e<0?e+o:e}static normalizeAxes(e,o){return e.map(s=>this.normalizeAxis(s,o))}static incrementIndex(e,o,s){if(o.length===0||e.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(s===void 0)s=o.length;else if(s<=0||s>o.length)throw new Error("Incorrect axis to increment on");for(let d=s-1;d>=0&&(e[d]++,!(e[d]<o[d]));--d)e[d]=0}static calculateReshapedDims(e,o){if(o.length===0){if(e.length===0||Nx.size(e)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let s=o.length,d=new Array(s),c=-1,h=1;for(let bt=0;bt<s;bt++){if(o[bt]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(o[bt]===-1){if(c!==-1)throw new Error("at most one dimension in shape hints can be -1");c=bt}else{if(o[bt]===0){if(bt>=e.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");d[bt]=e[bt]}else d[bt]=o[bt];h*=d[bt]}}let _=Nx.size(e);if(c!==-1){if(_%h!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${o}]`);d[c]=_/h}else if(h!==_)throw new Error("reshapedDims and originalDims don't have matching sizes");return d}static sortBasedOnPerm(e,o){return o?o.map(s=>e[s]):e.slice().reverse()}static padShape(e,o){let s=e.length;return e.map((d,c)=>d+o[c]+o[c+s])}static areEqual(e,o){return e.length!==o.length?!1:e.every((s,d)=>s===o[d])}static validateDimsAndCalcSize(e){if(e.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let o=1;for(let s of e){if(!Number.isInteger(s))throw new TypeError(`Invalid shape: ${s} is not an integer`);if(s<0||s>2147483647)throw new TypeError(`Invalid shape: length ${s} is not allowed`);o*=s}return o}static flattenShape(e,o){o<0&&(o+=e.length);let s=e.reduce((c,h)=>c*h,1),d=e.slice(o).reduce((c,h)=>c*h,1);return[s/d,d]}static squeezeShape(e,o){let s=new Array;o=Nx.normalizeAxes(o,e.length);for(let d=0;d<e.length;d++){let c=o.indexOf(d)>=0;if(c&&e[d]!==1)throw new Error("squeeze an axis of size different than 1");(o.length===0&&e[d]>1||o.length>0&&!c)&&s.push(e[d])}return s}static unsqueezeShape(e,o){let s=new Array(e.length+o.length);s.fill(0);for(let c=0;c<o.length;c++){let h=Nx.normalizeAxis(o[c],s.length);if(h>=s.length)throw new Error("'axes' has an out of range axis");if(s[h]!==0)throw new Error("'axes' has a duplicate axis");s[h]=1}let d=0;for(let c=0;c<s.length;c++)s[c]===0&&(s[c]=e[d++]);if(d!==e.length)throw new Error("the unsqueezed dimension could not be established");return s}},un$1=class fA{static splitShape(e,o,s,d){if(s.length===0){if(!d)throw new Error("need to know number of outputs when the 'split' attribute is not specified");fA.determineSplit(e[o],d,s)}let c=[],h=[0];for(let _=0;_<s.length;++_){_!==0&&h.push(h[_-1]+s[_-1]);let bt=e.slice();bt[o]=s[_],c.push(bt)}return[c,h]}static determineSplit(e,o,s){if(e%o!==0)throw new Error("cannot split tensor to equal sized parts");for(let d=0;d<o;++d)s.push(e/o)}},dr=class IS{static adjustPoolAttributes(e,o,s,d,c,h){if(!e&&s.length!==o.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let _=0;_<o.length-2;_++)_>=s.length?s.push(o[_+2]):s[_]=o[_+2];for(let _=0;_<s.length;_++)if(_<d.length){if(d[_]<0)throw new Error("strides should be greater than or equal to 1")}else d.push(1);for(let _=0;_<s.length;_++)if(_<c.length){if(c[_]<0)throw new Error("dilations should be greater than or equal to 1")}else c.push(1);for(let _=0;_<s.length*2;_++)if(_<h.length){if(h[_]<0)throw new Error("pad should be greater than or equal to 1")}else h.push(0);for(let _=0;_<s.length;_++){if(s[_]<=0)throw new Error("kernel shapes need to be greater than 0");if(h[_]>=s[_]||h[_+s.length]>=s[_])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,o,s,d,c,h){if(h){if(c.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(o.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(d.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let _=0;_<e.length-2;_++)IS.adjustPadAndReturnShape(e[_+2],o[_],s[_],d[_],c,_,_+e.length-2,h)}}static computePoolOutputShape(e,o,s,d,c,h,_){if(o.length<=0)throw new Error("input shape must be of size greater than 0");let bt=[o[0],o[1]];return IS.computeShapeHelper(e,o,bt,s,d,c,h,_),bt}static computeConvOutputShape(e,o,s,d,c,h,_){if(e.length<=0||o.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let bt=[e[0],o[0]];return IS.computeShapeHelper(!1,e,bt,s,d,c,h,_),bt}static computeShapeHelper(e,o,s,d,c,h,_,bt){if(e)for(let g=0;g<o.length-2;g++)s.push(1);else for(let g=0;g<o.length-2;g++)s.push(IS.adjustPadAndReturnShape(o[g+2],d[g],c[g],h[g],_,g,g+o.length-2,bt))}static adjustPadAndReturnShape(e,o,s,d,c,h,_,bt){let g=s*(d-1)+1;if(bt&&bt!=="NOTSET")switch(bt){case"VALID":return c[h]=0,c[_]=0,Math.floor((e-g)/o+1);case"SAME_LOWER":case"SAME_UPPER":if(s!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let j=((e+o-1)/o-1)*o+d-e;return c[h]=Math.floor(bt==="SAME_LOWER"?(j+1)/2:j/2),c[_]=j-c[h],Math.floor((e+j-d)/o+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+c[h]+c[_]-g)/o+1)}},hr=-34028234663852886e22,mr=34028234663852886e22});function jd$1(a){switch(a){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${a}`)}}function ku$1(a){switch(a){case re$1.onnx.TensorProto.DataType.UINT8:case re$1.onnx.TensorProto.DataType.INT8:case re$1.onnx.TensorProto.DataType.BOOL:return 1;case re$1.onnx.TensorProto.DataType.UINT16:case re$1.onnx.TensorProto.DataType.INT16:return 2;case re$1.onnx.TensorProto.DataType.FLOAT:case re$1.onnx.TensorProto.DataType.INT32:case re$1.onnx.TensorProto.DataType.UINT32:return 4;case re$1.onnx.TensorProto.DataType.INT64:case re$1.onnx.TensorProto.DataType.DOUBLE:case re$1.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${re$1.onnx.TensorProto.DataType[a]}`)}}function Yd$1(a,e){return new(Ru$1(e))(a)}function Ru$1(a){switch(a){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function bi$1(a,e){if(e===re$1.onnx.TensorProto.DataType.INT64||e===mi$1.TensorDataType.INT64){if(a.greaterThanOrEqual(2147483648)||a.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(e===re$1.onnx.TensorProto.DataType.UINT32||e===mi$1.TensorDataType.UINT32||e===re$1.onnx.TensorProto.DataType.UINT64||e===mi$1.TensorDataType.UINT64){if(a.greaterThanOrEqual(4294967296)||a.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${re$1.onnx.TensorProto.DataType[e]}`);return a.toNumber()}function Bu$1(a,e,o){switch(e){case re$1.onnx.TensorProto.DataType.BOOL:case re$1.onnx.TensorProto.DataType.UINT8:return a.getUint8(o);case re$1.onnx.TensorProto.DataType.INT8:return a.getInt8(o);case re$1.onnx.TensorProto.DataType.UINT16:return a.getUint16(o,!0);case re$1.onnx.TensorProto.DataType.INT16:return a.getInt16(o,!0);case re$1.onnx.TensorProto.DataType.FLOAT:return a.getFloat32(o,!0);case re$1.onnx.TensorProto.DataType.INT32:return a.getInt32(o,!0);case re$1.onnx.TensorProto.DataType.UINT32:return a.getUint32(o,!0);case re$1.onnx.TensorProto.DataType.INT64:return bi$1(Wt.fromBits(a.getUint32(o,!0),a.getUint32(o+4,!0),!1),e);case re$1.onnx.TensorProto.DataType.DOUBLE:return a.getFloat64(o,!0);case re$1.onnx.TensorProto.DataType.UINT64:return bi$1(Wt.fromBits(a.getUint32(o,!0),a.getUint32(o+4,!0),!0),e);default:throw new Error(`cannot read from DataView for type ${re$1.onnx.TensorProto.DataType[e]}`)}}var Nu$1,re$1,mi$1,Ce,br=E(()=>{Nu$1=Er$1(Ss()),ei(),nn$1(),re$1=Er$1($r()),fe(),mi$1=W.experimental.fbs,Ce=class BE{constructor(e,o,s,d,c,h=Nu$1.Guid.create()){this.dims=e,this.type=o,this.dataProvider=s,this.asyncDataProvider=d,this.cache=c,this.dataId=h,this.size=U.validateDimsAndCalcSize(e);let _=this.size,bt=s===void 0&&d===void 0&&c===void 0;if(c!==void 0&&c.length!==_)throw new RangeError("Input dims doesn't match data length.");if(o==="string"){if(c!==void 0&&(!Array.isArray(c)||!c.every(g=>typeof g=="string")))throw new TypeError("cache should be a string array");bt&&(this.cache=new Array(_))}else{if(c!==void 0){let g=Ru$1(o);if(!(c instanceof g))throw new TypeError(`cache should be type ${g.name}`)}if(bt){let g=new ArrayBuffer(_*jd$1(o));this.cache=Yd$1(g,o)}}}get data(){if(this.cache===void 0){let e=this.dataProvider(this.dataId);if(e.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=e}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(e){return this.data[U.indicesToOffset(e,this.strides)]}set(e,o){this.data[U.indicesToOffset(e,this.strides)]=o}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=U.computeStrides(this.dims)),this._strides}static fromProto(e){if(!e)throw new Error("cannot construct Value from an empty tensor");let o=Ve.tensorDataTypeFromProto(e.dataType),s=Ve.tensorDimsFromProto(e.dims),d=new BE(s,o);if(o==="string")e.stringData.forEach((c,h)=>{d.data[h]=ln$1(c)});else if(e.rawData&&typeof e.rawData.byteLength=="number"&&e.rawData.byteLength>0){let c=d.data,h=new DataView(e.rawData.buffer,e.rawData.byteOffset,e.rawData.byteLength),_=ku$1(e.dataType),bt=e.rawData.byteLength/_;if(e.rawData.byteLength%_!==0)throw new Error("invalid buffer length");if(c.length!==bt)throw new Error("buffer length mismatch");for(let g=0;g<bt;g++){let j=Bu$1(h,e.dataType,g*_);c[g]=j}}else{let c;switch(e.dataType){case re$1.onnx.TensorProto.DataType.FLOAT:c=e.floatData;break;case re$1.onnx.TensorProto.DataType.INT32:case re$1.onnx.TensorProto.DataType.INT16:case re$1.onnx.TensorProto.DataType.UINT16:case re$1.onnx.TensorProto.DataType.INT8:case re$1.onnx.TensorProto.DataType.UINT8:case re$1.onnx.TensorProto.DataType.BOOL:c=e.int32Data;break;case re$1.onnx.TensorProto.DataType.INT64:c=e.int64Data;break;case re$1.onnx.TensorProto.DataType.DOUBLE:c=e.doubleData;break;case re$1.onnx.TensorProto.DataType.UINT32:case re$1.onnx.TensorProto.DataType.UINT64:c=e.uint64Data;break;default:throw new Error("unspecific error")}if(c==null)throw new Error("failed to populate data from a tensorproto value");let h=d.data;if(h.length!==c.length)throw new Error("array length mismatch");for(let _=0;_<c.length;_++){let bt=c[_];Wt.isLong(bt)?h[_]=bi$1(bt,e.dataType):h[_]=bt}}return d}static fromData(e,o,s){return new BE(o,s,void 0,void 0,e)}static fromOrtTensor(e){if(!e)throw new Error("cannot construct Value from an empty tensor");let o=Ve.tensorDimsFromORTFormat(e),s=Ve.tensorDataTypeFromProto(e.dataType()),d=new BE(o,s);if(s==="string")for(let c=0;c<e.stringDataLength();c++)d.data[c]=e.stringData(c);else if(e.rawDataArray()&&typeof e.rawDataLength()=="number"&&e.rawDataLength()>0){let c=d.data,h=new DataView(e.rawDataArray().buffer,e.rawDataArray().byteOffset,e.rawDataLength()),_=ku$1(e.dataType()),bt=e.rawDataLength()/_;if(e.rawDataLength()%_!==0)throw new Error("invalid buffer length");if(c.length!==bt)throw new Error("buffer length mismatch");for(let g=0;g<bt;g++){let j=Bu$1(h,e.dataType(),g*_);c[g]=j}}return d}}});function q$1(a){return a===1?Xd$1:Kd$1}function Mu$1(a){let e=q$1(a);return`${e.version}
      precision highp float;
      ${e.attribute} vec3 position;
      ${e.attribute} vec2 textureCoord;

      ${e.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`}function Gu$1(a){let e=q$1(a);return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFrag} vec2 TexCoords;
    ${e.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `}function Uu$1(a,e){let o=q$1(a);return`
  void main() {
    int indices[${e}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${o.output} = result;
  }
  `}var Xd$1,Kd$1,xe=E(()=>{Xd$1={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},Kd$1={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}}),ae=E(()=>{});async function gi$1(a,e=s=>0,o){return new Promise((s,d)=>{let c=0,h=()=>{if(a()){s();return}c++;let _=e(c);if(o!=null&&c>=o){d();return}setTimeout(h,_)};h()})}function Kn$1(a){return kr$1(typeof a<"u"&&a.length!==0,()=>"empty string found for sampler name"),"get"+a.charAt(0).toUpperCase()+a.slice(1)}function zu$1(a){return kr$1(typeof a<"u"&&a.length!==0,()=>"empty string found for sampler name"),"get"+a.charAt(0).toUpperCase()+a.slice(1)+"AtOutCoords"}function Br(a,e){let o=JSON.parse(JSON.stringify(a));return o=e,o}function Nr(a,e){return e.map(o=>a[o]).join(", ")}function Je(a){if(a<=1)return"int";if(a===2)return"ivec2";if(a===3)return"ivec3";if(a===4)return"ivec4";if(a===5)return"ivec5";if(a===6)return"ivec6";throw Error(`GPU for rank ${a} is not yet supported`)}function Ot(a=6){return["x","y","z","w","u","v"].slice(0,a)}var kt=E(()=>{fe()});function Jd$1(a,e){return Ot(e).map(o=>`${a}.${o}`)}function Rr$1(a,e){return e===1?[a]:Jd$1(a,e)}function Bt$1(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}var gr=E(()=>{kt()});function Qd$1(a,e,o){if(a===0)return"false";if(a===1)return`rc > ${e[0]}`;let s="";for(let d=a-2;d<a;d++)s+=`${o[d]} >= ${e[d-a+2]}`,d<a-1&&(s+="||");return s}function eh(a,e){let o=a.length;if(o===0)return"getA(), 0, 0, 0";if(o===1)return`getA(rc),
            rc + 1 >= ${a[0]} ? 0. : getA(rc + 1),
            0, 0`;let s="r, c",d="r, cp1",c="rp1, c",h="rp1, cp1",_="";if(o>2)for(let bt=0;bt<o-2;++bt)_=_+`${e[bt]},`;return`getA(${_}${s}),
          rEdge ? 0. : getA(${_}${c}),
          cEdge ? 0. : getA(${_}${d}),
          rEdge || cEdge ? 0. : getA(${_}${h})`}function th(a,e,o,s){return a===0||a===1?"":`
    int r = ${e[a-2]};
    int c = ${e[a-1]};
    int rp1 = ${e[a-2]} + 1;
    int cp1 = ${e[a-1]} + 1;
    bool rEdge = rp1 >= ${s};
    bool cEdge = cp1 >= ${o};
    `}var Vu$1,Zd$1,Wu$1,Hu$1=E(()=>{xe(),ae(),kt(),gr(),Vu$1={name:"pack",inputNames:["A"],inputTypes:[1]},Zd$1=(a,e)=>{let o=q$1(a.session.backend.glContext.version),s=e.dims,d=s.length,c=e.dims.length,h=Je(c),_=Rr$1("rc",c),bt=th(c,_,s[s.length-2],s[s.length-1]),g;d===0?g=[1,1]:d===1?g=[s[0],1]:g=[s[c-1],s[c-2]];let j=Qd$1(c,g,_),b=eh(s,_),Et=`
        void main() {
          ${h} rc = getOutputCoords();

          if(${j}) {
            ${o.output} = vec4(0);
          } else {
            ${bt}

            ${o.output} = vec4(${b});
          }
        }
      `;return{...Vu$1,hasMain:!0,output:{dims:e.dims,type:e.type,textureType:2},shaderSource:Et}},Wu$1=(a,e)=>({...Vu$1,get:()=>Zd$1(a,e)})});function yi$1(a){if(a.length===0)return[1,1,1];let e=1;for(let o=0;o<a.length-2;++o)e*=a[o];return[e,a.length>1?a[a.length-2]:1,a[a.length-1]]}function ju$1(a,e){let o=!1;return a.length===0||e.length===0?o=!0:a.length<2||e.length<2?o=a[a.length-1]===e[e.length-1]:o=a[a.length-1]===e[e.length-1]&&a[a.length-2]===e[e.length-2],o}function oh(a){let e=U.computeStrides(a),o=["b","r","c"],s="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e.map((d,c)=>{let h=`int ${o[c]} = ${s} / ${d}`,_=c===e.length-1?`int ${o[c+1]} = ${s} - ${o[c]} * ${d}`:`index -= ${o[c]} * ${d}`;return`${h}; ${_};`}).join("")}
      return ivec3(b, r, c);
    }
  `}function ih(a){let e=U.computeStrides(a);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;
  }
`}var rh,nh,qu$1,Yu$1=E(()=>{fe(),xe(),ae(),gr(),rh=a=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${a}`}),nh=(a,e,o,s)=>{let d=e.dims,c=s,h="";for(let g=0;g<4;g++){let j="";switch(g){case 0:j="outputCoords = rc;";break;case 1:j="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:j="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:j="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}h+=`
        ${j}
        ${g>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${g}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${g>0?"}":""}
      `}let _=q$1(a.session.backend.glContext.version),bt=`
      ${oh(d)}
      ${ih(c)}
      ${Bt$1()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${c[2]};
        int cols = ${c[1]};

        ${h}
        ${_.output} = result;
      }
    `;return{...o,output:{dims:c,type:e.type,textureType:2},shaderSource:bt,hasMain:!0}},qu$1=(a,e,o)=>{let s=rh(o);return{...s,get:()=>nh(a,e,s,o)}}}),Ti$1,Xu$1=E(()=>{xe(),ae(),Ti$1=(a,e)=>{let o=e.shape,s=q$1(a.session.backend.glContext.version),d=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${s.texture2D}(X,TexCoords).r;
      ${s.output} = encodeAsUint8(value);
    }`,c={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:o,type:e.tensor.type,textureType:3},shaderSource:d,hasMain:!0};return a.executeProgram(c,[e.tensor])}});function sh(a,e){if(a===1)return"rc";let o="";for(let s=0;s<a;s++)o+=e[s],s<a-1&&(o+=",");return o}var Ku$1,ah,Ju$1,Zu$1=E(()=>{xe(),ae(),kt(),gr(),Ku$1={name:"unpack",inputNames:["A"],inputTypes:[2]},ah=(a,e)=>{let o=e.dims.length,s=Rr$1("rc",o),d=s.slice(-2),c=Je(o),h=Bt$1(),_=e.dims.length===0?"":sh(o,s),bt=o<=1?"rc":`vec2(${d.join(",")})`,g=q$1(a.session.backend.glContext.version),j=`
    ${h}
    void main() {
      ${c} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${_});

       ${g.output} = vec4(getChannel(packedInput, ${bt}), 0, 0, 0);
     }
   `;return{...Ku$1,hasMain:!0,output:{dims:e.dims,type:e.type,textureType:0},shaderSource:j}},Ju$1=(a,e)=>({...Ku$1,get:()=>ah(a,e)})}),Jn$1,fn$1,Zn$1,cn$1=E(()=>{at$1(),Jn$1=class{constructor(a,e=1){if(e===1)this.internalFormat=a.R32F,this.format=a.RED,this.textureType=a.FLOAT,this.channelSize=e;else if(e===4)this.internalFormat=a.RGBA32F,this.format=a.RGBA,this.textureType=a.FLOAT,this.channelSize=e;else throw new Error(`Invalid number of channels: ${e}`)}encode(a,e){let o,s;return a.constructor!==Float32Array&&(ce.warning("Encoder","data was not of type Float32; creating new Float32Array"),s=new Float32Array(a)),e*this.channelSize>a.length?(ce.warning("Encoder","Source data too small. Allocating larger array"),s=a,o=this.allocate(e*this.channelSize),s.forEach((d,c)=>o[c]=d)):(s=a,o=s),o}allocate(a){return new Float32Array(a*4)}decode(a,e){return this.channelSize===1?a.filter((o,s)=>s%4===0).subarray(0,e):a.subarray(0,e)}},fn$1=class{constructor(a,e=1,o){if(e!==1&&e!==4)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=a.RGBA,this.format=a.RGBA,this.channelSize=e,this.textureType=o||a.FLOAT}encode(a,e){let o=a;return this.channelSize===1&&(ce.verbose("Encoder","Exploding into a larger array"),o=this.allocate(e),a.forEach((s,d)=>o[d*4]=s)),o}allocate(a){return new Float32Array(a*4)}decode(a,e){return this.channelSize===1?a.filter((o,s)=>s%4===0).subarray(0,e):a.subarray(0,e)}},Zn$1=class{constructor(a,e=1){if(this.channelSize=4,e===1)this.internalFormat=a.ALPHA,this.format=a.ALPHA,this.textureType=a.UNSIGNED_BYTE,this.channelSize=e;else if(e===4)this.internalFormat=a.RGBA,this.format=a.RGBA,this.textureType=a.UNSIGNED_BYTE,this.channelSize=e;else throw new Error(`Invalid number of channels: ${e}`)}encode(a,e){return new Uint8Array(a.buffer,a.byteOffset,a.byteLength)}allocate(a){return new Uint8Array(a*this.channelSize)}decode(a,e){if(a instanceof Uint8Array)return a.subarray(0,e);throw new Error(`Invalid array type: ${a.constructor}`)}}}),pn$1,Qu$1,xi$1,el$1=E(()=>{fe(),ae(),pn$1=(a,e,o)=>{let s=o===0||o===1?1:4,d=o===2,c=o===1||o===2,h=o===4?e.length-1:void 0,_=o===4?e.map((bt,g)=>g===e.length-1?bt*4:bt):void 0;return xi$1(a,e,s,_,{isPacked:d,reverseWH:c,breakAxis:h})},Qu$1=(a,e,o)=>{let s=pn$1(a,e,o);return[s.width,s.height]},xi$1=(a,e,o=1,s,d)=>{let c=!!(d&&d.isPacked),[h,_]=a.computeTextureWH(c&&s||e,d),bt=e.length,g=e.slice(0);if(bt===0&&(g=[1]),o===1)s=e;else if(c){if(o!==4)throw new Error("a packed texture must be 4-channel");s=e,bt>0&&(g[bt-1]=Math.ceil(g[bt-1]/2)),bt>1&&(g[bt-2]=Math.ceil(g[bt-2]/2))}else if(!s)throw new Error("Unpacked shape is needed when using channels > 1");return{width:h,height:_,channels:o,isPacked:c,shape:g,strides:U.computeStrides(g),unpackedShape:s,reversedWH:d&&d.reverseWH}}}),lh,Qn$1,rl$1=E(()=>{at$1(),br(),fe(),Hu$1(),Yu$1(),Xu$1(),Zu$1(),cn$1(),el$1(),ae(),lh=(a,e)=>{let o=e.map(d=>`${d.unpackedShape.join(",")};${d.width}x${d.height}`).join("_"),s=a.name;return a.cacheHint&&(s+="["+a.cacheHint+"]"),s+=":"+o,s},Qn$1=class{constructor(a){this.session=a,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(a,e){return Qu$1(this.session.layoutStrategy,a,e)}executeProgram(a,e){if(e.length<a.inputNames.length)throw new Error(`Input size mustn't be less than ${a.inputNames.length}.`);if(a.inputNames.length!==a.inputTypes.length)throw new Error("input names size does not match input types");let o=[];for(let bt=0;bt<a.inputNames.length;++bt)o[bt]=this.getOrCreateTextureData(e[bt],a.inputTypes[bt]);let s=lh(a,o),d=this.session.programManager.getArtifact(s),c=d?d.programInfo:typeof a.get=="function"?a.get():a,h=pn$1(this.session.layoutStrategy,c.output.dims,c.output.textureType),_=this.createTextureData(h,c.output.type);return d||(d=this.session.programManager.build(c,o,_),this.session.programManager.setArtifact(s,d)),this.runProgram(d,o,_),_}run(a,e){return this.executeProgram(a,e).tensor}runProgram(a,e,o){for(let s=0;s<e.length;++s)if(!!e[s].isPacked!=(a.programInfo.inputTypes[s]===2))throw new Error(`input[${s}] property packed inconsistent`);if(!!o.isPacked!=(a.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(a,e,o)}getOrCreateTextureData(a,e){let o=this.getTextureData(a.dataId,e===2);if(!o&&(o=this.getTextureData(a.dataId,e!==2),o))return e===2?this.pack(o):this.unpack(o);if(!o){let s=pn$1(this.session.layoutStrategy,a.dims,e);if(e===4){let d=a.dims;if(d.length===4){let c=[d[0],Math.ceil(d[1]*d[2]*d[3]/4)],h=pn$1(this.session.layoutStrategy,c,e),_=a.numberData;if(d[1]*d[2]*d[3]%4!==0){let bt=d[0],g=d[1]*d[2]*d[3],j=Math.ceil(g*1/4)*4,b=bt*j;_=new Float32Array(b);for(let Et=0;Et<bt;++Et){let It=Et*g,zt=Et*j+Et%1*g;_.set(a.numberData.subarray(It,It+g),zt)}}return this.createTextureData(h,a.type,_,a,1)}}if(e===2){let d=xi$1(this.session.layoutStrategy,a.dims,1,[],{reverseWH:!0}),c=this.createTextureData(d,a.type,a.numberData,a,1);o=this.pack(c)}else o=this.createTextureData(s,a.type,a.numberData,a,1)}return o}createTextureDataFromLayoutBindTensor(a,e,o,s){return this.createTextureData(a,e,o,s,1)}createTextureData(a,e,o,s,d){ce.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(a)}]`);let c=this.session.textureManager.createTextureFromLayout(e,a,o,d);return this.createTextureDataFromTexture(a,e,c,s)}reshapeUnpacked(a,e){let o=this.getOrCreateTextureData(a,0),s={channels:o.channels,height:o.height,width:o.width,shape:e.length!==0?e:[1],strides:U.computeStrides(e),unpackedShape:e};return this.createTextureDataFromTexture(s,a.type,o.texture).tensor}reshapePacked(a,e){let o=this.getOrCreateTextureData(a,2);if(ju$1(a.dims,e)){let _={channels:o.channels,height:o.height,width:o.width,shape:e.length!==0?e:[1],strides:U.computeStrides(e),unpackedShape:e,isPacked:!0};return this.createTextureDataFromTexture(_,a.type,o.texture).tensor}let s=yi$1(a.dims),d=yi$1(e),c=this.reshapePacked(a,s),h=this.run(qu$1(this,c,d),[c]);return this.reshapePacked(h,e)}cast(a,e){let o=this.getOrCreateTextureData(a,0);return this.createTextureDataFromTexture(o,e,o.texture).tensor}createTextureDataFromTexture(a,e,o,s,d){let c={...a,tensor:s||new Ce(a.unpackedShape,e,h=>this.readTexture(c),async h=>this.readTextureAsync(c),void 0,d),texture:o};return this.setTextureData(c.tensor.dataId,c,a.isPacked),c}getTextureData(a,e=!1){return this.session.isInitializer(a)?this.session.getTextureData(a,e):e?this.packedTextureDataCache.get(a):this.unpackedTextureDataCache.get(a)}setTextureData(a,e,o=!1){this.session.isInitializer(a)?this.session.setTextureData(a,e,o):(o?this.packedTextureDataCache:this.unpackedTextureDataCache).set(a,e)}isTextureLayoutCached(a,e=!1){return!!this.getTextureData(a.dataId,e)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(a=>this.session.textureManager.releaseTexture(a)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(a=>this.session.textureManager.releaseTexture(a)),this.unpackedTextureDataCache=new Map}readTexture(a){return a.isPacked?this.readTexture(this.unpack(a)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(a,a.tensor.type,a.channels):this.session.textureManager.readUint8TextureAsFloat(Ti$1(this,a))}async readTextureAsync(a){return a.isPacked?this.readTextureAsync(this.unpack(a)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(a,a.tensor.type,a.channels):this.session.textureManager.readUint8TextureAsFloat(Ti$1(this,a))}pack(a){return this.executeProgram(Wu$1(this,a.tensor),[a.tensor])}unpack(a){return this.executeProgram(Ju$1(this,a.tensor),[a.tensor])}}}),wi$1,ee,Ge$1=E(()=>{wi$1=class{constructor(a){Object.assign(this,a)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(a=>`${this[a]}`).join(";")),this.key}},ee=a=>new wi$1(a)}),nl$1,ol$1,il$1,fh,ch,al$1=E(()=>{Ge$1(),xe(),ae(),nl$1={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},ol$1=(a,e,o)=>(ch(e),[a.run({...nl$1,cacheHint:o.cacheKey,get:()=>fh(a,e,o)},e)]),il$1=a=>{let e=a.attributes.getFloat("epsilon",1e-5),o=a.attributes.getFloat("momentum",.9),s=a.attributes.getInt("spatial",1);return ee({epsilon:e,momentum:o,spatial:s})},fh=(a,e,o)=>{let s=q$1(a.session.backend.glContext.version),d=e[0].dims.length,[c,h]=a.calculateTextureWidthAndHeight(e[1].dims,0),_=`
  float process(int[${d}] indices) {
    vec2 position = offsetToCoords(indices[1], ${c}, ${h});
    float scale = getColorAsFloat(${s.texture2D}(Scale, position));
    float mean = getColorAsFloat(${s.texture2D}(Mean, position));
    float variance = getColorAsFloat(${s.texture2D}(Variance, position));
    float b = getColorAsFloat(${s.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${o.epsilon})) ) + b;
  }`;return{...nl$1,output:{dims:e[0].dims,type:e[0].type,textureType:0},shaderSource:_}},ch=a=>{if(!a||a.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let e=a[0],o=a[1],s=a[2],d=a[3],c=a[4];if(e.dims.length<3||o.dims.length!==1||s.dims.length!==1||d.dims.length!==1||c.dims.length!==1)throw new Error("invalid input shape.");if(o.dims[0]!==e.dims[1]||s.dims[0]!==e.dims[1]||d.dims[0]!==e.dims[1]||c.dims[0]!==e.dims[1])throw new Error("invalid input shape.");if(e.type!=="float32"&&e.type!=="float64"||o.type!=="float32"&&o.type!=="float64"||s.type!=="float32"&&s.type!=="float64"||d.type!=="float32"&&d.type!=="float64"||c.type!=="float32"&&c.type!=="float64")throw new Error("invalid input tensor types.")}}),eo$1,ft,R,dn$1,to$1,Ht$1=E(()=>{eo$1=class{constructor(a,e,o,s){this.glContext=a,this.programInfo=e,this.inputTextureLayouts=o,this.outputTextureLayout=s}},ft=class{constructor(a){this.context=a}},R=class{constructor(a,e){this.routineBody=a,this.dependencies=e}},dn$1=class{constructor(a,e,o){this.name=a,o?this.dependencies=o:this.dependencies=[],e&&(this.routineBody=e)}addDependency(a){a&&this.dependencies.push(a)}},to$1=class{static returnOrderedNodes(a){if(!a||a.length===0)return[];if(a.length===1)return a;let e=new Set,o=new Set,s=new Array;return this.createOrderedNodes(a,e,o,s),s}static createOrderedNodes(a,e,o,s){for(let d=0;d<a.length;++d)this.dfsTraverse(a[d],e,o,s)}static dfsTraverse(a,e,o,s){if(!a||o.has(a.name))return;if(e.has(a.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");e.add(a.name);let d=a.dependencies;if(d&&d.length>0)for(let c=0;c<d.length;++c)this.dfsTraverse(d[c],e,o,s);s.push(a),o.add(a.name),e.delete(a.name)}}});function dh(){let a="add_";return{body:`
  float ${a}(float a, float b) {
    return a + b;
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:a,type:0}}function hh(){let a="div_";return{body:`
  float ${a}(float a, float b) {
    return a / b;
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:a,type:0}}function mh(){let a="mul_";return{body:`
  float ${a}(float a, float b) {
    return a * b;
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:a,type:0}}function bh(){let a="sub_";return{body:`
  float ${a}(float a, float b) {
    return a - b;
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:a,type:0}}function gh(){let a="equal_";return{body:`
  float ${a}(float a, float b) {
    return float(a == b);
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:a,type:0}}function yh(){let a="greater_";return{body:`
  float ${a}(float a, float b) {
    return float(a > b);
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:a,type:0}}function Th(){let a="less_";return{body:`
  float ${a}(float a, float b) {
    return float(a < b);
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:a,type:0}}function xh(){let a="and_";return{body:`
  float ${a}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:a,type:0}}function wh(){let a="or_";return{body:`
  float ${a}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:a,type:0}}function vh(){let a="xor_";return{body:`
  float ${a}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:a,type:0}}function _h(){return Ih("pow")}function Oh(){let a="prelu_";return{body:`
  float ${a}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${a}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:a,type:0}}function Ih(a){let e=`${a}_`;return{body:`
  float ${e}(float a, float b) {
    return ${a}(a, b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return ${a}(v1, v2);
  }
  `,name:e,type:0}}var ct$1,Sh,sl$1,ul$1,ll$1,fl$1,cl$1,pl$1,dl$1,hl$1,ml$1,bl$1,gl$1,yl$1,Tl$1=E(()=>{fe(),Ht$1(),xe(),ae(),ct$1=(a,e,o,s=e[0].type,d)=>{let c=a.session.pack?2:0;return{name:o.name,inputNames:["A","B"],inputTypes:[c,c],cacheHint:d,get:()=>Sh(a,e,o,s)}},Sh=(a,e,o,s=e[0].type)=>{let d=a.session.pack?2:0,c=!U.areEqual(e[0].dims,e[1].dims),h=e[0].dims,_=a.session.pack;if(c){let j=Ke.calcShape(e[0].dims,e[1].dims,!1);if(!j)throw new Error("Can't perform binary op on the given tensors");h=j;let b=h.length,Et=e[0].dims.length!==0?e[0].dims.length:1,It=e[1].dims.length!==0?e[1].dims.length:1,zt=e[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",er=e[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",Hn=q$1(a.session.backend.glContext.version),Qt=_?`
      ${o.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${o.name}(a, b);
        ${Hn.output} = result;
      }`:`
      ${o.body}
      float process(int indices[${b}]) {
        int aindices[${Et}];
        int bindices[${It}];
        ${zt}
        ${er}
        return ${o.name}(_A(aindices), _B(bindices));
      }`;return{name:o.name,inputNames:["A","B"],inputTypes:[d,d],output:{dims:h,type:s,textureType:d},shaderSource:Qt,hasMain:_}}let bt=q$1(a.session.backend.glContext.version),g=`
    ${o.body}
    void main() {
      vec4 v1 = ${bt.texture2D}(A, TexCoords);
      vec4 v2 = ${bt.texture2D}(B, TexCoords);
      vec4 result = ${o.name}(v1, v2);
      ${bt.output} = result;
    }
    `;return{name:o.name,inputNames:["A","B"],inputTypes:[d,d],output:{dims:e[0].dims,type:s,textureType:d},shaderSource:g,hasMain:!0}},sl$1=(a,e)=>[a.run(ct$1(a,e,dh()),e)],ul$1=(a,e)=>[a.run(ct$1(a,e,xh(),"bool"),e)],ll$1=(a,e)=>[a.run(ct$1(a,e,hh()),e)],fl$1=(a,e)=>[a.run(ct$1(a,e,gh(),"bool"),e)],cl$1=(a,e)=>[a.run(ct$1(a,e,yh(),"bool"),e)],pl$1=(a,e)=>[a.run(ct$1(a,e,Th(),"bool"),e)],dl$1=(a,e)=>[a.run(ct$1(a,e,mh()),e)],hl$1=(a,e)=>[a.run(ct$1(a,e,wh(),"bool"),e)],ml$1=(a,e)=>[a.run(ct$1(a,e,_h()),e)],bl$1=(a,e)=>[a.run(ct$1(a,e,Oh()),e)],gl$1=(a,e)=>[a.run(ct$1(a,e,bh()),e)],yl$1=(a,e)=>[a.run(ct$1(a,e,vh(),"bool"),e)]}),xl$1,wl$1,Ph,vl$1=E(()=>{fe(),xl$1=(a,e,o)=>(Ph(e),[a.cast(e[0],o)]),wl$1=a=>Ve.tensorDataTypeFromProto(a.attributes.getInt("to")),Ph=a=>{if(!a||a.length!==1)throw new Error("Cast requires 1 input.");if(a[0].type==="string")throw new Error("Invalid input type.")}}),Eh,Dh,_l$1,ro$1,Ol$1=E(()=>{xe(),ae(),kt(),gr(),Eh=(a,e)=>({name:"Concat (packed)",inputNames:Array.from({length:a},(o,s)=>`X${s}`),inputTypes:Array(a).fill(2),cacheHint:e}),Dh=(a,e,o,s)=>{let d=o[0].dims.slice();if(s>=d.length||s<-1*d.length)throw new Error("axis specified for concat doesn't match input dimensionality");s<0&&(s=d.length+s);let c=d.slice(0);for(let e0=1;e0<o.length;e0++){let t0=o[e0].dims.slice();for(let o0=0;o0<d.length;o0++)if(o0===s)c[s]+=t0[o0];else if(d[o0]!==t0[o0])throw new Error("non concat dimensions must match")}let h=c.length,_=Rr$1("coords",h),bt=Je(h),g=Bt$1(),j=o.map(e0=>e0.dims),b=Ot(h),Et=new Array(j.length-1);Et[0]=j[0][s];for(let e0=1;e0<Et.length;e0++)Et[e0]=Et[e0-1]+j[e0][s];let It=b[s],zt=b.slice(-2),er=b.join(),Hn=`if (${It} < ${Et[0]}) {
        return getChannel(
            getX0(${er}), vec2(${zt.join()}));
        }`;for(let e0=1;e0<Et.length;e0++){let t0=Et[e0-1];Hn+=`
            if (${It} < ${Et[e0]}  && ${It} >= ${Et[e0-1]}) {
              return getChannel(
                getX${e0}(${ro$1(b,It,t0)}),
                vec2(${ro$1(zt,It,t0)}));
            }`}let Qt=Et.length,cr=Et[Et.length-1];Hn+=`
            return getChannel(
              getX${Qt}(${ro$1(b,It,cr)}),
              vec2(${ro$1(zt,It,cr)}));`;let fr=q$1(a.session.backend.glContext.version),jr=`
          ${g}
          float getValue(${b.map(e0=>"int "+e0)}) {
            ${Hn}
          }

          void main() {
            ${bt} coords = getOutputCoords();
            int lastDim = coords.${b[h-1]};
            coords.${b[h-1]} = coords.${b[h-2]};
            coords.${b[h-2]} = lastDim;

            vec4 result = vec4(getValue(${_}), 0., 0., 0.);

            ${_[h-1]} = ${_[h-1]} + 1;
            if (${_[h-1]} < ${c[h-1]}) {
              result.g = getValue(${_});
            }

            ${_[h-2]} = ${_[h-2]} + 1;
            if (${_[h-2]} < ${c[h-2]}) {
              result.a = getValue(${_});
            }

            ${_[h-1]} = ${_[h-1]} - 1;
            if (${_[h-2]} < ${c[h-2]} &&
                ${_[h-1]} < ${c[h-1]}) {
              result.b = getValue(${_});
            }
            ${fr.output} = result;
          }
        `;return{...e,output:{dims:c,type:o[0].type,textureType:2},shaderSource:jr,hasMain:!0}},_l$1=(a,e,o)=>{let s=Eh(e.length,o.cacheKey);return{...s,get:()=>Dh(a,s,e,o.axis)}},ro$1=(a,e,o)=>{let s=a.indexOf(e);return a.map((d,c)=>c===s?`${d} - ${o}`:d).join()}}),Il$1,Lh,Fh,Ch,Sl$1,$h,kh,Bh,Al$1,Nh,Pl$1=E(()=>{Ge$1(),ae(),Ol$1(),Il$1=(a,e,o)=>(Nh(e),a.session.pack&&e[0].dims.length>1?[a.run(_l$1(a,e,o),e)]:[a.run(Ch(a,e,o),e)]),Lh=(a,e)=>({name:"Concat",inputNames:Array.from({length:a},(o,s)=>`X${s}`),inputTypes:Array(a).fill(0),cacheHint:e}),Fh=(a,e,o,s)=>{let d=o[0].dims.slice();if(s>=d.length||s<-1*d.length)throw new Error("axis specified for concat doesn't match input dimensionality");s<0&&(s=d.length+s);let c=d.slice(0);for(let It=1;It<o.length;It++){let zt=o[It].dims.slice();for(let er=0;er<d.length;er++)if(er===s)c[s]+=zt[er];else if(d[er]!==zt[er])throw new Error("non concat dimensions must match")}let h=c.length,_=new Array(o.length),bt=0;for(let It=0;It<_.length;++It)bt+=o[It].dims[s],_[It]=bt;let g="";o.length<5?g=Sl$1(_):g=$h(_);let j=kh(o.length,h),b=Bh(_),Et=`
        ${j}
        ${b}
        ${g}
        float process(int indices[${h}]) {
          int textureIndex = getTextureWhereDataResides (indices[${s}]);

          if(textureIndex != 0) {
            indices[${s}] = indices[${s}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...e,output:{dims:c,type:o[0].type,textureType:0},shaderSource:Et}},Ch=(a,e,o)=>{let s=Lh(e.length,o.cacheKey);return{...s,get:()=>Fh(a,s,e,o.axis)}},Sl$1=a=>`int getTextureWhereDataResides(int index) {
      ${a.map((e,o)=>`if(index<${e}) {return ${o};}
`).join("")}
    }`,$h=a=>Sl$1(a),kh=(a,e)=>{let o=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];for(let s=0;s<a;++s)s===0?o.push(`	if (textureIndex == ${s}) { return _X${s}(indices); }`):s===a-1?o.push(`	else { return _X${s}(indices); }`):o.push(`	else if (textureIndex == ${s}) { return _X${s}(indices); }`);return o.push("	}"),o.join(`
`)},Bh=a=>{let e=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let o=0;o<a.length;++o)o===0?e.push(`	if (index == ${o}) { return ${a[o]}; }`):o===a.length-1?e.push(`	else { return ${a[o]}; }`):e.push(`	else if (index == ${o}) { return ${a[o]}; }`);return e.push("	}"),e.join(`
`)},Al$1=a=>ee({axis:a.attributes.getInt("axis")}),Nh=a=>{if(!a||a.length<1)throw new Error("too few inputs");let e=a[0].type,o=a[0].dims.length;if(e==="string")throw new Error("string tensor is not supported yet");for(let s of a){if(s.type!==e)throw new Error("input tensors should be one type");if(s.dims.length!==o)throw new Error("input tensors should have the same shape")}}});function Rh(){return pt("abs")}function Mh(){return pt("acos")}function Gh(){return pt("asin")}function Uh(){return pt("atan")}function zh(){return pt("ceil")}function Vh(){return pt("cos")}function Wh(a){let e="elu";return{body:`
  const float alpha = float(${a});

  float ${e}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));
  }
  `,name:e,type:0}}function Hh(){return pt("exp")}function qh(){return pt("floor")}function vi$1(a,e){let o="clip";return{body:`
  const float min = float(${a});
  const float max = float(${e});

  float ${o}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${o}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:o,type:0}}function jh(){let a="indentity";return{body:`
  float ${a}_(float a) {
    return a;
  }
  vec4 ${a}_(vec4 v) {
    return v;
  }
  `,name:a,type:0}}function Yh(a){let e="leakyRelu";return{body:`
  const float alpha = float(${a});

  float ${e}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));
  }
  `,name:e,type:0}}function Xh(){return pt("log")}function Kh(){let a="neg";return{body:`
  float ${a}_(float a) {
    return -a;
  }
  vec4 ${a}_(vec4 v) {
    return -v;
  }
  `,name:a,type:0}}function Jh(){let a="not";return{body:`
  float ${a}_(float a) {
    return float( ! bool(a) );
  }
  bool ${a}_(bool a) {
    return !a;
  }
  vec4 ${a}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${a}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:a,type:0}}function Zh(){return pt("sin")}function _i$1(){let a="relu";return{body:`
  float ${a}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${a}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:a,type:0}}function Oi$1(){let a="sigmoid";return{body:`
  float ${a}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${a}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:a,type:0}}function Qh(){return pt("sqrt")}function em(){return pt("tan")}function tm(){let a="tanh";return{body:`
  float ${a}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${a}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:a,type:0}}function pt(a){return{body:`
  float ${a}_(float a) {
    return ${a}(a);
  }
  vec4 ${a}_(vec4 v) {
    return ${a}(v);
  }
  `,name:a,type:0}}var rm,De$1,El$1,Dl$1,Ll$1,Fl$1,Ii$1,Cl$1,$l$1,nm,kl$1,Bl$1,Nl$1,Rl$1,Ml$1,Gl$1,Si$1,Ul$1,zl$1,Vl$1,Wl$1,Hl$1,ql$1,jl$1,Yl$1,Xl,Kl$1,Jl,Ai$1=E(()=>{Ge$1(),fe(),Ht$1(),xe(),ae(),rm=(a,e,o,s)=>{let d=a.session.pack?2:0,c=q$1(a.session.backend.glContext.version);return{...e,output:{dims:o.dims,type:o.type,textureType:d},shaderSource:`
     ${s.body}
     void main() {
       vec4 v = ${c.texture2D}(A, TexCoords);
       v = ${s.name}_(v);
       ${c.output} = v;
     }
     `,hasMain:!0}},De$1=(a,e,o,s)=>{let d=a.session.pack?2:0,c={name:o.name,inputTypes:[d],inputNames:["A"],cacheHint:s};return{...c,get:()=>rm(a,c,e,o)}},El$1=(a,e)=>[a.run(De$1(a,e[0],Rh()),e)],Dl$1=(a,e)=>[a.run(De$1(a,e[0],Mh()),e)],Ll$1=(a,e)=>[a.run(De$1(a,e[0],Gh()),e)],Fl$1=(a,e)=>[a.run(De$1(a,e[0],Uh()),e)],Ii$1=(a,e,o)=>[a.run(De$1(a,e[0],vi$1(o.min,o.max),o.cacheKey),e)],Cl$1=a=>ee({min:a.attributes.getFloat("min",hr),max:a.attributes.getFloat("max",mr)}),$l$1=(a,e)=>{let o=nm(a,e);return Ii$1(a,[e[0]],o)},nm=(a,e)=>{if(e.length>=3&&(!a.session.isInitializer(e[1].dataId)||!a.session.isInitializer(e[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let o=e.length>=3?e[1].numberData[0]:hr,s=e.length>=3?e[2].numberData[0]:mr;return ee({min:o,max:s})},kl$1=(a,e)=>[a.run(De$1(a,e[0],zh()),e)],Bl$1=(a,e)=>[a.run(De$1(a,e[0],Vh()),e)],Nl$1=(a,e,o)=>[a.run(De$1(a,e[0],Wh(o.alpha),o.cacheKey),e)],Rl$1=a=>ee({alpha:a.attributes.getFloat("alpha",1)}),Ml$1=(a,e)=>[a.run(De$1(a,e[0],Hh()),e)],Gl$1=(a,e)=>[a.run(De$1(a,e[0],qh()),e)],Si$1=(a,e)=>[a.run(De$1(a,e[0],jh()),e)],Ul$1=(a,e,o)=>[a.run(De$1(a,e[0],Yh(o.alpha),o.cacheKey),e)],zl$1=a=>ee({alpha:a.attributes.getFloat("alpha",.01)}),Vl$1=(a,e)=>[a.run(De$1(a,e[0],Xh()),e)],Wl$1=(a,e)=>[a.run(De$1(a,e[0],Kh()),e)],Hl$1=(a,e)=>[a.run(De$1(a,e[0],Jh()),e)],ql$1=(a,e)=>[a.run(De$1(a,e[0],_i$1()),e)],jl$1=(a,e)=>[a.run(De$1(a,e[0],Oi$1()),e)],Yl$1=(a,e)=>[a.run(De$1(a,e[0],Zh()),e)],Xl=(a,e)=>[a.run(De$1(a,e[0],Qh()),e)],Kl$1=(a,e)=>[a.run(De$1(a,e[0],em()),e)],Jl=(a,e)=>[a.run(De$1(a,e[0],tm()),e)]});function Nt(a){let e;switch(a.activation){case"Relu":e=_i$1();break;case"Sigmoid":e=Oi$1();break;case"Clip":e=vi$1(a.clipMin,a.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let o=e.name,s=e.body,d=`value = ${o}_(value);`;return{activationFunction:s,applyActivation:d}}var Mr,yr=E(()=>{fe(),Ai$1(),Mr=a=>{let e=a.getString("activation","");if(e==="Clip"){let[o,s]=a.getFloats("activation_params",[hr,mr]);return{activation:e,clipMax:s,clipMin:o,activationCacheKey:`${e}:${o},${s}`}}return{activation:e,activationCacheKey:e}}}),im,am,Zl,Ql=E(()=>{at$1(),xe(),ae(),no$1(),yr(),im=(a,e)=>({name:"GroupedConv",inputNames:a?["X","W","Bias"]:["X","W"],inputTypes:a?[0,0,0]:[0,0],cacheHint:e}),am=(a,e,o,s)=>{let d=e.length>2?"value += getBias(output_channel);":"",c=e[0].dims.slice(),h=e[1].dims.slice(),_=h[0]/s.group;ce.verbose("GroupedConv",`autpPad:${s.autoPad}, dilations:${s.dilations}, group:${s.group}, kernelShape:${s.kernelShape}, pads:${s.pads}, strides:${s.strides}`);let bt=Gr(c,h,s.dilations,s.pads,s.strides),g=q$1(a.session.backend.glContext.version),{activationFunction:j,applyActivation:b}=Nt(s),Et=`
  const ivec2 strides = ivec2(${s.strides[0]}, ${s.strides[1]});
  const ivec2 pads = ivec2(${s.pads[0]}, ${s.pads[1]});
  ${j}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${_};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${h[1]}; wInChannel++) {
      int input_channel = group_id * ${h[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${h[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${s.dilations[0]};

        if (xHeight < 0 || xHeight >= ${c[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${h[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${s.dilations[1]};
          if (xWidth < 0 || xWidth >= ${c[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${d}
    ${b}
    ${g.output} = vec4(value, .0, .0, .0);
  }
`;return{...o,output:{dims:bt,type:e[0].type,textureType:0},shaderSource:Et,hasMain:!0}},Zl=(a,e,o)=>{let s=im(e.length>2,o.cacheKey);return{...s,get:()=>am(a,e,s,o)}}}),sm,um,ef$1,tf$1=E(()=>{xe(),ae(),gr(),sm=a=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:a}),um=(a,e,o,s,d,c)=>{let h=o.dims,_=s.dims,bt=2,g=3,j=d.length,b=[_[1]*_[2]*_[3],d[2]*d[3]],Et=_[2]*_[3],It=Bt$1(),zt=q$1(a.session.backend.glContext.version),er="";for(let Qt=0;Qt<=1;Qt++)for(let cr=0;cr<=1;cr++)er+=`
            blockIndex = rc.x + ${cr};
            pos = rc.y + ${Qt};

            if(blockIndex < ${b[1]} && pos < ${b[0]}) {
              offsetY = int(blockIndex / (${d[j-1]})) * ${c.strides[0]} -
                ${c.pads[0]};
              d0 = offsetY + ${c.dilations[0]} * (imod(pos, ${Et}) / ${_[2]});

              if(d0 < ${h[bt]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${d[j-1]}) * ${c.strides[1]} -
                  ${c.pads[1]};
                d1 = offsetX + ${c.dilations[1]} * imod(imod(pos, ${Et}), ${_[2]});

                if(d1 < ${h[g]} && d1 >= 0) {

                  ch = int(float(pos)/ ${Et}.);
                    innerDims = vec2(d0, d1);
                    result[${Qt*2+cr}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let Hn=`
      ${It}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${er}
          ${zt.output} = result;
      }
            `;return{...e,output:{dims:b,type:o.type,textureType:2},shaderSource:Hn,hasMain:!0}},ef$1=(a,e,o,s,d)=>{let c=sm(d.cacheKey);return{...c,get:()=>um(a,c,e,o,s,d)}}});function fm(a,e,o){let s=e[0].dims,d=e[1].dims,c=Ke.calcShape(s,d,!0);if(!c)throw new Error("Can't use matmul on the given tensors");let h=Je(c.length),_=Ot(),{activationFunction:bt,applyActivation:g}=Nt(o),j=e.length>2,b=j?"value += getBiasForMatmul();":"",Et=j?`${Ei$1(h,_,e[2].dims,c,!1)}`:"",It=c.length,zt=s.length,er=d.length,Hn=s[s.length-1],Qt=`
    ${bt}
    ${Et}
    float process(int indices[${It}]) {
        int a[${zt}];
        int b[${er}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${Hn}; ++k) {
            a[${zt-1}] = k;
            b[${er-2}] = k;
            value += _A(a) * _B(b);
        }
        ${b}
        ${g}
        return value;
    }`;return{...a,output:{dims:c,type:e[0].type,textureType:0},shaderSource:Qt}}function Pi$1(a,e){let o=lm(a.length>2,e.activationCacheKey);return{...o,get:()=>fm(o,a,e)}}function Ei$1(a,e,o,s,d){let c="",h=o.length,_=s.length,bt=_-h;_<2&&h>0?c="coords":c=o.map((Et,It)=>`coords.${e[It+bt]}`).join(", ");let g=Ke.getBroadcastDims(o,s).map(Et=>`coords.${e[Et+bt]} = 0;`).join(`
`),j=U.size(o)===1,b="vec4(outputValue.xx, outputValue.yy)";return j&&(b="vec4(outputValue.x)"),d?`
vec4 getBiasForMatmul() {
  ${a} coords = getOutputCoords();
  ${g}
  vec4 outputValue = getBias(${c});
  return ${b};
}`:`
float getBiasForMatmul() {
  ${a} coords = getOutputCoords();
  ${g}
  return getBias(coords.x);
}`}var rf$1,nf$1,lm,cm,oo$1=E(()=>{fe(),ae(),kt(),yr(),Di(),rf$1=(a,e,o)=>(cm(e),a.session.pack?[a.run(io(a,e,o),e)]:[a.run(Pi$1(e,o),e)]),nf$1=a=>Mr(a.attributes),lm=(a,e)=>({name:"MatMul",inputNames:a?["A","B","Bias"]:["A","B"],inputTypes:a?[0,0,0]:[0,0],cacheHint:e}),cm=a=>{if(!a||a.length!==2)throw new Error("MatMul requires 2 inputs.");if(a[0].dims[a[0].dims.length-1]!==a[1].dims[a[1].dims.length-2])throw new Error("shared dimension does not match.");if(a[0].type!=="float32"&&a[0].type!=="float64"||a[1].type!=="float32"&&a[1].type!=="float64")throw new Error("inputs should be float type");if(a[0].type!==a[1].type)throw new Error("inputs types should match")}});function hm(a,e,o,s){let d=[],c=[],h=o[0].dims,_=o[1].dims,bt=h.length,g=_.length,j=s.length,b=j-bt,Et=j-g;d=h.map((cr,fr)=>`coords.${e[fr+b]}`),d[bt-1]="i*2",d.join(", "),c=_.map((cr,fr)=>`coords.${e[fr+Et]}`),c[g-2]="i*2",c.join(", ");let It=Ke.getBroadcastDims(h,s),zt=Ke.getBroadcastDims(_,s),er=It.map(cr=>`coords.${e[cr+b]} = 0;`).join(`
`),Hn=zt.map(cr=>`coords.${e[cr+Et]} = 0;`).join(`
`),Qt=`int lastDim = coords.${e[j-1]};
  coords.${e[j-1]} = coords.${e[j-2]};
  coords.${e[j-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${a} coords = getOutputCoords();
  ${Qt}
  ${er}
  vec4 outputValue = getA(${d});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${a} coords = getOutputCoords();
  ${Qt}
  ${Hn}
  vec4 outputValue = getB(${c});
  return outputValue;
}`}function mm(a,e){let o="";for(let s=0;s<e-2;s++)o+=`rc.${a[s]}, `;return o+=`rc.${a[e-2]}, i*2`,o}function bm(a,e){let o="";for(let s=0;s<e-2;s++)o+=`rc.${a[s]}, `;return o+=`i*2, rc.${a[e-1]}`,o}var pm,dm,io,Di=E(()=>{fe(),xe(),ae(),kt(),yr(),oo$1(),pm=(a,e)=>({name:"MatMul (packed)",inputNames:a?["A","B","Bias"]:["A","B"],inputTypes:a?[2,2,2]:[2,2],cacheHint:e}),dm=(a,e,o,s)=>{let d=o.length>2,c=d?"value += getBiasForMatmul();":"",h=o[0].dims,_=o[1].dims,bt=Ke.calcShape(h,_,!0),g=!U.areEqual(o[0].dims,o[1].dims);if(!bt)throw new Error("Can't use matmul on the given tensors");let j=h[h.length-1],b=Math.ceil(j/2),Et=h.length,It=_.length,zt=q$1(a.session.backend.glContext.version),er=Je(bt.length),Hn=bt.length,Qt=Ot(),{activationFunction:cr,applyActivation:fr}=Nt(s),jr=d?`${Ei$1(er,Qt,o[2].dims,bt,!0)}`:"",e0=g?`${hm(er,Qt,o,bt)}`:"",t0=g?"getAAtOutCoordsMatmul(i)":`getA(${mm(Qt,Et)})`,o0=g?"getBAtOutCoordsMatmul(i)":`getB(${bm(Qt,It)})`,l0=g?"":`${er} rc =
          getOutputCoords(); int lastDim = rc.${Qt[Hn-1]}; rc.${Qt[Hn-1]} =
          rc.${Qt[Hn-2]}; rc.${Qt[Hn-2]} = lastDim;
      `,g0=`
            ${e0}
            ${jr}
            ${cr}
            void main() {
              ${l0}

              vec4 value = vec4(0);
              for (int i = 0; i < ${b}; i++) {
                vec4 a = ${t0};
                vec4 b = ${o0};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${c}
              ${fr}
              ${zt.output} = value;
            }`;return{...e,output:{dims:bt,type:o[0].type,textureType:2},shaderSource:g0,hasMain:!0}},io=(a,e,o)=>{let s=pm(e.length>2,o.activationCacheKey);return{...s,get:()=>dm(a,s,e,o)}}}),of$1,af$1=E(()=>{no$1(),tf$1(),Di(),of$1=(a,e,o)=>{let s=e[0].dims,d=e[1].dims,c=Gr(s,d,o.dilations,o.pads,o.strides),h=a.run(ef$1(a,e[0],e[1],c,o),[e[0]]),_=a.reshapePacked(e[1],[d[0],d[1]*d[2]*d[3]]),bt=e.length===3?[_,h,e[2]]:[_,h],g=a.run(io(a,bt,o),bt);return a.reshapePacked(g,c)}}),gm,ym,sf$1,Li$1,Fi$1=E(()=>{ae(),gm=a=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:a}),ym=(a,e,o,s,d,c)=>{let h=o.dims,_=s.dims,bt=d.length,g=Li$1(h,_,d,4),j=`
        const int XC = ${h[1]};
        const int XH = ${h[2]};
        const int XW = ${h[3]};
        const int KH = ${c.kernelShape[0]};
        const int KW = ${c.kernelShape[1]};
        const int dilationH = ${c.dilations[0]};
        const int dilationW = ${c.dilations[1]};
        const int strideH = ${c.strides[0]};
        const int strideW = ${c.strides[1]};
        const int padH = ${c.pads[0]};
        const int padW = ${c.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${bt}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${h.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...e,output:{dims:g,type:o.type,textureType:4},shaderSource:j}},sf$1=(a,e,o,s,d)=>{let c=gm(d.cacheKey);return{...c,get:()=>ym(a,c,e,o,s,d)}},Li$1=(a,e,o,s=4)=>[o[0],o[2],o[3],Math.ceil(a[1]*e[2]*e[3]/s)]}),Tm,xm,uf$1,lf$1=E(()=>{fe(),xe(),ae(),yr(),Fi$1(),Tm=(a,e)=>({name:"ConvDotProduct",inputNames:a?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:a?[0,4,0]:[0,4],cacheKey:e.activationCacheKey}),xm=(a,e,o,s,d)=>{let c=o[0].dims,h=o[1].dims,_=[h[0],Math.ceil(c[1]*h[2]*h[3]/4)],bt=Li$1(c,h,s),[g,j]=a.calculateTextureWidthAndHeight(_,4),b=U.computeStrides(bt),[Et,It]=a.calculateTextureWidthAndHeight(bt,4),zt=s.length,er=o.length<3?"0.0":"_B(b)",Hn=Math.ceil(c[1]*h[2]*h[3]/4),{activationFunction:Qt,applyActivation:cr}=Nt(d),fr=q$1(a.session.backend.glContext.version),jr=`
${Qt}
float process(int indices[${zt}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${b[0]} + im2col[1] * ${b[1]} + im2col[2] * ${b[2]};
  int kernelOffset = indices[1] * ${_[1]};
  float value = ${er};
  for (int i = 0; i < ${Hn}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${Et}, ${It});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${g}, ${j});
    value += dot(${fr.texture2D}(Im2Col, im2colCoords), ${fr.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${cr}
  return value;
}`;return{...e,output:{dims:s,type:o[0].type,textureType:0},shaderSource:jr}},uf$1=(a,e,o,s)=>{let d=Tm(e.length>2,s);return{...d,get:()=>xm(a,d,e,o,s)}}}),Gr,Ci$1,wm,vm,_m,Om,$i$1,Im,no$1=E(()=>{Ge$1(),fe(),Ql(),af$1(),lf$1(),yr(),Fi$1(),oo$1(),Gr=(a,e,o,s,d)=>{let c=a[0],h=a.slice(2),_=h.length,bt=e[0],g=e.slice(2).map((b,Et)=>b+(b-1)*(o[Et]-1)),j=h.map((b,Et)=>b+s[Et]+s[Et+_]).map((b,Et)=>Math.floor((b-g[Et]+d[Et])/d[Et]));return[c,bt].concat(...j)},Ci$1=(a,e,o)=>(Im(e,o),wm(a,e,o)),wm=(a,e,o)=>{let s=Om(o,e),d=a.session.pack,c=s.kernelShape[0]===1&&s.kernelShape[1]===1;return s.group>1?[a.run(Zl(a,e,s),e)]:c&&d?[vm(a,e,s)]:d&&e[0].dims.length===4&&e[0].dims[0]===1&&!c?[of$1(a,e,s)]:[_m(a,e,s)]},vm=(a,e,o)=>{let s=e[0].dims,d=e[1].dims,c=Gr(s,d,o.dilations,o.pads,o.strides),h=a.reshapeUnpacked(e[0],[s[1],s[2]*s[3]]),_=a.reshapeUnpacked(e[1],[d[0],d[1]]),bt=e.length>2?[_,h,e[2]]:[_,h],g=a.run(Pi$1(bt,o),bt);return a.reshapeUnpacked(g,c)},_m=(a,e,o)=>{let s=e[0].dims,d=e[1].dims,c=Gr(s,d,o.dilations,o.pads,o.strides),h=a.run(sf$1(a,e[0],e[1],c,o),[e[0]]),_=e.length===3?[h,e[1],e[2]]:[h,e[1]];return a.run(uf$1(a,e,c,o),_)},Om=(a,e)=>{let o=a.kernelShape.slice();if(a.kernelShape.length===0)for(let c=2;c<e[1].dims.length;++c)o.push(e[1].dims[c]);let s=a.pads.slice();dr.adjustPadsBasedOnAutoPad(e[0].dims,a.strides,a.dilations,o,s,a.autoPad);let d=Object.assign({},a);return Object.assign(d,{kernelShape:o,pads:s,cacheKey:a.cacheKey}),d},$i$1=a=>{let e=a.attributes,o=Mr(e),s=e.getString("auto_pad","NOTSET"),d=e.getInts("dilations",[1,1]),c=e.getInt("group",1),h=e.getInts("kernel_shape",[]),_=e.getInts("pads",[0,0,0,0]),bt=e.getInts("strides",[1,1]);return ee({autoPad:s,dilations:d,group:c,kernelShape:h,pads:_,strides:bt,...o})},Im=(a,e)=>{if(!a||a.length!==2&&a.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(a[0].dims.length!==4||a[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let o=a[0].dims[1],s=a[1].dims[1]*e.group;if(o!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(a.length===3&&(a[2].dims.length!==1||a[1].dims[0]!==a[2].dims[0]))throw new Error("invalid bias");let d=a[0].dims.length-2;if(e.dilations.length!==d)throw new Error(`dilations should be ${d}D`);if(e.strides.length!==d)throw new Error(`strides should be ${d}D`);if(e.pads.length!==d*2)throw new Error(`pads should be ${d*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==a[1].dims.length-2)throw new Error("invalid kernel shape");if(a[0].type!=="float32"||a[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(a.length===3&&a[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}}),Sm,Am,Pm,ff$1,Em,Dm,Lm,Fm,Cm,$m,cf,km,pf=E(()=>{Ge$1(),xe(),ae(),yr(),Sm=(a,e,o,s,d,c)=>(a-1)*e+o+(s-1)*d+1-c,Am=(a,e,o,s,d)=>{let c=Math.floor(a/2);e==="SAME_UPPER"?(o[s]=c,o[d]=a-c):e==="SAME_LOWER"&&(o[s]=a-c,o[d]=c)},Pm=(a,e,o,s,d,c,h,_)=>{let bt=a.length-2,g=_.length===0;for(let j=0;j<bt;++j){let b=g?a[j+2]*c[j]:_[j],Et=Sm(a[j+2],c[j],d[j],e[j],o[j],b);Am(Et,s,d,j,j+bt),g&&_.push(c[j]*(a[j+2]-1)+h[j]+(e[j]-1)*o[j]+1-d[j]-d[j+bt])}},ff$1=(a,e,o)=>(km(e,o),Em(a,e,o)),Em=(a,e,o)=>{let s=$m(o,e);return[Cm(a,e,s)]},Dm=(a,e)=>({name:"ConvTranspose",inputNames:a?["X","W","B"]:["X","W"],inputTypes:a?[0,0,0]:[0,0],cacheHint:e}),Lm=(a,e,o,s)=>{let d=e.length>2?"getB(output_channel)":"0.0",c=e[0].dims,h=e[1].dims,_=h[1],bt=h[0]/s.group,g=[e[0].dims[0],e[1].dims[1]*s.group,...s.outputShape],j=q$1(a.session.backend.glContext.version),{activationFunction:b,applyActivation:Et}=Nt(s),It=`
  const ivec2 strides = ivec2(${s.strides[0]}, ${s.strides[1]});
  const ivec2 pads = ivec2(${s.pads[0]}, ${s.pads[1]});
  ${b}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${_};
    int wOutChannel = output_channel - group_id * ${_};

    float value = ${d};
    for (int inChannelOffset = 0; inChannelOffset < ${bt}; inChannelOffset++) {
      int input_channel = group_id * ${bt} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${h[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${h[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${s.dilations[0]}, wHOff * ${s.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${c[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${c[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${Et}
    ${j.output} = vec4(value, .0, .0, .0);
  }
`;return{...o,output:{dims:g,type:e[0].type,textureType:0},shaderSource:It,hasMain:!0}},Fm=(a,e,o)=>{let s=Dm(e.length>2,o.cacheKey);return{...s,get:()=>Lm(a,e,s,o)}},Cm=(a,e,o)=>a.run(Fm(a,e,o),e),$m=(a,e)=>{let o=a.kernelShape.slice();if(a.kernelShape.length===0)for(let _=2;_<e[1].dims.length;++_)o.push(e[1].dims[_]);let s=a.pads.slice(),d=a.outputShape.slice(),c=e[0].dims;Pm(c,o,a.dilations,a.autoPad,s,a.strides,a.outputPadding,d);let h=Object.assign({},a);return Object.assign(h,{kernelShape:o,pads:s,outputShape:d,cacheKey:a.cacheKey}),h},cf=a=>{let e=a.attributes,o=Mr(e),s=e.getString("auto_pad","NOTSET"),d=e.getInts("dilations",[1,1]),c=e.getInt("group",1),h=e.getInts("kernel_shape",[]),_=e.getInts("output_padding",[0,0]),bt=e.getInts("output_shape",[]),g=e.getInts("pads",[0,0,0,0]),j=e.getInts("strides",[1,1]);return ee({autoPad:s,dilations:d,group:c,kernelShape:h,outputPadding:_,outputShape:bt,pads:g,strides:j,...o})},km=(a,e)=>{if(!a||a.length!==2&&a.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(a[0].dims.length!==4||a[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let o=a[0].dims[1],s=a[1].dims[0];if(o!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let d=a[1].dims[1]*e.group;if(a.length===3&&(a[2].dims.length!==1||a[2].dims[0]!==d))throw new Error("invalid bias");let c=a[0].dims.length-2;if(e.dilations.length!==c)throw new Error(`dilations should be ${c}D`);if(e.strides.length!==c)throw new Error(`strides should be ${c}D`);if(e.pads.length!==c*2)throw new Error(`pads should be ${c*2}D`);if(e.outputPadding.length!==c)throw new Error(`output_padding should be ${c}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==a[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==a[0].dims.length-2)throw new Error("invalid output shape");if(a[0].type!=="float32"||a[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(a.length===3&&a[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}}),df$1,Tr$1,hf$1,Bm,mf$1,Nm,Rm,Mm,ao$1=E(()=>{Ge$1(),fe(),ae(),df$1={name:"Transpose",inputNames:["A"],inputTypes:[0]},Tr$1=(a,e,o)=>(Mm(e),[a.run({...df$1,cacheHint:o.cacheKey,get:()=>Bm(a,e[0],o.perm)},e)]),hf$1=a=>ee({perm:a.attributes.getInts("perm",[])}),Bm=(a,e,o)=>{let s=e.dims;o=mf$1(s,o);let d=Nm(s,o),c=s.length,h=`
      ${Rm("perm",o,c)}
      float process(int indices[${c}]) {
        int a[${c}];
        perm(a, indices);
        return _A(a);
      }`;return{...df$1,output:{dims:d,type:e.type,textureType:0},shaderSource:h}},mf$1=(a,e)=>(e&&e.length!==a.length&&(e=[...a.keys()].reverse()),e),Nm=(a,e)=>(e=mf$1(a,e),U.sortBasedOnPerm(a,e)),Rm=(a,e,o)=>{let s=[];s.push(`void ${a}(out int a[${o}], int src[${o}]) {`);for(let d=0;d<o;++d)s.push(`	a[${e[d]}]=src[${d}];`);return s.push("	}"),s.join(`
`)},Mm=a=>{if(!a||a.length!==1)throw new Error("Transpose requires 1 input.");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("input should be float tensor")}}),bf,gf$1,Gm,yf=E(()=>{ao$1(),bf=(a,e,o)=>{Gm(e);let s=o.blocksize,d=s*s,c=o.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],h=o.mode==="DCR"?[e[0].dims[0],s,s,e[0].dims[1]/d,e[0].dims[2],e[0].dims[3]]:[e[0].dims[0],e[0].dims[1]/d,s,s,e[0].dims[2],e[0].dims[3]],_=a.reshapeUnpacked(e[0],h),bt={perm:c,cacheKey:`${c}`},[g]=Tr$1(a,[_],bt),j=[e[0].dims[0],e[0].dims[1]/d,e[0].dims[2]*s,e[0].dims[3]*s];return[a.reshapeUnpacked(g,j)]},gf$1=a=>{let e=a.attributes.getInt("blocksize");if(e<1)throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);let o=a.attributes.getString("mode","DCR");if(o!=="DCR"&&o!=="CRD")throw new Error(`unrecognized mode: ${o} for DepthToSpace`);return{mode:o,blocksize:e}},Gm=a=>{if(a.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${a.length}`);if(a[0].type==="string"||a[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}}),Tf,xf,Um,wf=E(()=>{fe(),Tf=(a,e,o)=>{Um(e,o);let s=U.flattenShape(e[0].dims,o);return[a.reshapeUnpacked(e[0],s)]},xf=a=>a.attributes.getInt("axis",1),Um=(a,e)=>{if(!a||a.length!==1)throw new Error("Flatten requires 1 input.");let o=a[0].dims.length;if(o===0)throw new Error("scalar tensor is not supported.");if(e<-o||e>o)throw new Error("Invalid axis");if(a[0].type==="string")throw new Error("string tensor is not supported.")}}),Jt,hn$1=E(()=>{Jt=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]}),vf,_f,zm,Vm,Wm,Hm,Of=E(()=>{Ge$1(),hn$1(),fe(),ae(),vf=(a,e,o)=>(Hm(e,o.axis),[a.run(Wm(a,e,o),e)]),_f=a=>ee({axis:a.attributes.getInt("axis",0)}),zm={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},Vm=(a,e,o,s)=>{let d=o[0].dims.slice(),c=o[1].dims.slice(),h=new Array(d.length+c.length-1);s=U.normalizeAxis(s,d.length);let _=[];for(let Et=0;Et<h.length;Et++)Et<s?(h[Et]=d[Et],_.push(`inputIdx[${Et}] = outputIdx[${Et}];`)):Et<s+c.length?(h[Et]=c[Et-s],_.push(`indexDataIdx[${Et-s}] = outputIdx[${Et}];`)):(h[Et]=d[Et-c.length+1],_.push(`inputIdx[${Et-c.length+1}] = outputIdx[${Et}];`));let bt=h.length||1,g=d.length,j=c.length||1,b=`
      float process(int outputIdx[${bt}]) {
        int inputIdx[${g}];
        int indexDataIdx[${j}];
        indexDataIdx[0] = 0;
        ${_.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${s}] = idx < 0 ? idx + ${d[s]} : idx;
        return _A(inputIdx);
      }`;return{...e,output:{dims:h,type:o[0].type,textureType:0},shaderSource:b}},Wm=(a,e,o)=>{let s={...zm,cacheHint:o.cacheKey};return{...s,get:()=>Vm(a,s,e,o.axis)}},Hm=(a,e)=>{if(!a||a.length!==2)throw new Error("Gather requires 2 inputs.");let o=a[0].dims.length;if(o<1)throw new Error("Invalid input shape.");if(e<-o||e>o-1)throw new Error("Invalid axis.");if(Jt.indexOf(a[0].type)===-1)throw new Error("Invaid input type.");if(a[1].type!=="int32"&&a[1].type!=="int16")throw new Error("Invaid input type.")}}),ki$1,If,Sf,Af,qm,jm,Ym,Pf=E(()=>{Ge$1(),fe(),ae(),ki$1=(a,e,o)=>(Ym(e,o),[a.run(qm(e,o),e)]),If=(a,e)=>{let o=a.attributes.getInt("transA",0)!==0,s=a.attributes.getInt("transB",0)!==0,d=a.attributes.getFloat("alpha",1),c=a.attributes.getFloat("beta",1);return ee({transA:o,transB:s,alpha:d,beta:c,isOptionalC:e})},Sf=a=>If(a,!1),Af=a=>If(a,!0),qm=(a,e)=>{let o={name:"Gemm",inputNames:a.length===3?["A","B","C"]:["A","B"],inputTypes:a.length===3?[0,0,0]:[0,0],key:e.cacheKey};return{...o,get:()=>jm(o,a,e)}},jm=(a,e,o)=>{let s=e[0].dims.slice(),d=e[1].dims.slice(),[c,h]=Xn$1.getShapeOfGemmResult(s,o.transA,d,o.transB,e.length===3?e[2].dims:void 0),_=[c,h];if(!_)throw new Error("Can't use gemm on the given tensors");let bt=s[s.length-1],g="";o.transA&&(bt=s[0]),o.transA&&o.transB?g="value += _A_T(a) * _B_T(b);":o.transA&&!o.transB?g="value += _A_T(a) * _B(b);":!o.transA&&o.transB?g="value += _A(a) * _B_T(b);":!o.transA&&!o.transB&&(g="value += _A(a) * _B(b);");let j=_.length,b=e.length===3?`int c[${e[2].dims.length}];`:"",Et=e.length===3?"bcastIndices_C(indices, c);":"",It=e.length===3?"value += beta * _C(c);":"",zt=`
      float process(int indices[${j}]) {
          int a[${j}];
          int b[${j}];
          ${b}

          copyVec(indices, a);
          copyVec(indices, b);
          ${Et}

          float value = 0.0;
          for (int k=0; k<${bt}; ++k) {
              a[${j-1}] = k;
              b[${j-2}] = k;
              ${g}
          }

          value = value * alpha;
          ${It}
          return value;
      }`;return{...a,output:{dims:_,type:e[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:o.alpha},{name:"beta",type:"float",data:o.beta}],shaderSource:zt}},Ym=(a,e)=>{if(!a)throw new Error("Input is missing");if(e.isOptionalC&&(a.length<2||a.length>3))throw new Error("Invaid input shape.");if(!e.isOptionalC&&a.length!==3)throw new Error("Gemm requires 3 inputs");if(a.length===3&&a[2].dims.length!==1&&a[2].dims.length!==2)throw new Error("Invalid input shape of C");if(a[0].type!=="float32"&&a[0].type!=="float64"||a[1].type!=="float32"&&a[1].type!=="float64"||a.length===3&&a[2].type!=="float32"&&a[2].type!=="float64")throw new Error("Invalid input type.");if(a[0].type!==a[1].type||a.length===3&&a[0].type!==a[2].type)throw new Error("Input types are mismatched")}}),Ef,Df,Xm,Km,Jm,Zm,Qm,Lf=E(()=>{Ge$1(),ae(),Ef=(a,e,o)=>(Qm(e),[a.run(Jm(a,e,o),e)]),Df=a=>{let e=a.attributes.getFloat("scale"),o=a.attributes.getFloats("bias");return ee({scale:e,bias:o})},Xm={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},Km=(a,e,o,s)=>{let d=o[0].dims.slice(),c=d.length,h=`
      ${Zm(s.bias.length)}
      float process(int indices[${c}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...e,output:{dims:d,type:o[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:s.bias.length,data:s.bias},{name:"scale",type:"float",data:s.scale}],shaderSource:h}},Jm=(a,e,o)=>{let s={...Xm,cacheHint:o.cacheKey};return{...s,get:()=>Km(a,s,e,o)}},Zm=a=>{let e=[`float getBias(float bias[${a}], int channel) {`];for(let o=0;o<a;++o)o===0?e.push(`	if (channel == ${o}) { return bias[${o}]; }`):o===a-1?e.push(`	else { return bias[${o}]; }`):e.push(`	else if (channel == ${o}) { return bias[${o}]; }`);return e.push("	}"),e.join(`
`)},Qm=a=>{if(!a||a.length!==1)throw new Error("ImageScaler requires 1 input.");if(a[0].dims.length!==4)throw new Error("Invalid input shape.");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type.")}}),Cf,$f,Ff,eb,tb,rb,nb,ob,ib,kf=E(()=>{xe(),ae(),Cf=(a,e,o)=>{ib(e);let s=a.run(tb(e[0]),e);return[a.run(ob(a,e[0],o,s.dims),[e[0],s,e[1],e[2]])]},$f=a=>a.attributes.getFloat("epsilon",1e-5),Ff={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},eb=(a,e)=>{let o=e.dims.slice(),s=o[1],d=o[2]*o[3],c=[o[0],s],h=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${o[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${o[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${d});
        temp = 0.0;
        for(int a2=0; a2<${o[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${o[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${d});

        return v;
      }`;return{...a,output:{dims:c,type:e.type,textureType:4},shaderSource:h}},tb=a=>({...Ff,get:()=>eb(Ff,a)}),rb={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},nb=(a,e,o,s,d)=>{let c=q$1(a.session.backend.glContext.version),[h,_]=a.calculateTextureWidthAndHeight(d,4),[bt,g]=[h/4,_],j=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${bt}, ${g});
        return ${c.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...e,output:{dims:o.dims,type:o.type,textureType:0},variables:[{name:"epsilon",type:"float",data:s}],shaderSource:j}},ob=(a,e,o,s)=>{let d={...rb,cacheHint:`${o}`};return{...d,get:()=>nb(a,d,e,o,s)}},ib=a=>{if(!a||a.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let e=a[0],o=a[1],s=a[2];if(e.dims.length<3||o.dims.length!==1||s.dims.length!==1)throw new Error("Invalid input shape.");if(o.dims[0]!==e.dims[1]||s.dims[0]!==e.dims[1])throw new Error("Input shapes are mismatched.");if(e.type!=="float32"&&e.type!=="float64"||o.type!=="float32"&&o.type!=="float64"||s.type!=="float32"&&s.type!=="float64")throw new Error("Invalid input type.");if(a[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}});function ab(a,e){let o=a[0].dims[1],s=a[0].dims.length,d=-Math.floor((e.size-1)/2),c=Math.ceil((e.size-1)/2),h=`float(${e.alpha}) / float(${e.size})`,_=`float(${e.bias})`,bt=`float(${e.beta})`,g=`
    float process(int indices[${s}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${d}; i <= ${c}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${o}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${_} + ${h} * square_sum, ${bt});
    }`;return{...Rf,cacheHint:e.cacheKey,output:{dims:a[0].dims,type:a[0].type,textureType:0},shaderSource:g}}function sb(a,e){return{...Rf,cacheHint:e.cacheKey,get:()=>ab(a,e)}}var Bf,Nf,Rf,ub,Mf=E(()=>{Ge$1(),ae(),Bf=(a,e,o)=>(ub(e),[a.run(sb(e,o),e)]),Nf=a=>{let e=a.attributes.getFloat("alpha",1e-4),o=a.attributes.getFloat("beta",.75),s=a.attributes.getFloat("bias",1),d=a.attributes.getInt("size");return ee({alpha:e,beta:o,bias:s,size:d})},Rf={name:"LRN",inputNames:["X"],inputTypes:[0]},ub=a=>{if(!a||a.length!==1)throw new Error("LRN requires 1 input.");if(a[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(a[0].type!=="float32")throw new Error("input should be float type")}}),lb,Bi,Gf,Uf,zf,fb,cb,pb,db,hb,mb,bb,gb,Vf=E(()=>{Ge$1(),fe(),xe(),ae(),lb={name:"Pad",inputNames:["A"],inputTypes:[0]},Bi=(a,e,o)=>(pb(e),[a.run({...lb,cacheHint:o.cacheKey,get:()=>cb(a,e[0],o)},e)]),Gf=a=>{let e=a.attributes.getString("mode","constant"),o=a.attributes.getFloat("value",0),s=a.attributes.getInts("pads");return ee({mode:e,value:o,pads:s})},Uf=(a,e,o)=>{db(e);let s=fb(a,e,o);return Bi(a,[e[0]],s)},zf=a=>a.attributes.getString("mode","constant"),fb=(a,e,o)=>{if(!a.session.isInitializer(e[1].dataId)||e.length>=3&&!a.session.isInitializer(e[2].dataId))throw new Error("dynamic pad attributes are not allowed");let s=Array.from(e[1].integerData),d=e.length>=3?e[2].floatData[0]:0;return ee({mode:o,pads:s,value:d})},cb=(a,e,o)=>{let s=U.padShape(e.dims.slice(),o.pads),d=s.length,c=`
      ${hb(a,e,o)}
      float process(int[${d}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:s,type:e.type,textureType:0},shaderSource:c}},pb=a=>{if(!a||a.length!==1)throw new Error("Pad requires 1 input");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type.")},db=a=>{if(!a||a.length!==2&&a.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(a[1].type!=="int32")throw new Error("Invalid input type.");if(a.length>=3&&a[2].type==="string")throw new Error("Invalid input type.")},hb=(a,e,o)=>{let s=q$1(a.session.backend.glContext.version),[d,c]=a.calculateTextureWidthAndHeight(e.dims,0),h=U.computeStrides(e.dims);switch(o.mode){case"constant":return mb(s,e.dims,h,d,c,o.pads,o.value);case"reflect":return bb(s,e.dims,h,d,c,o.pads);case"edge":return gb(s,e.dims,h,d,c,o.pads);default:throw new Error("Invalid mode")}},mb=(a,e,o,s,d,c,h)=>{let _=e.length,bt="";for(let g=_-1;g>=0;--g)bt+=`
        k = m[${g}] - ${c[g]};
        if (k < 0)  return constant;
        if (k >= ${e[g]}) return constant;
        offset += k * ${o[g]};
        `;return`
      float padA(int m[${_}]) {
        const float constant = float(${h});
        int offset = 0;
        int k = 0;
        ${bt}
        vec2 coords = offsetToCoords(offset, ${s}, ${d});
        float value = getColorAsFloat(${a.texture2D}(A, coords));
        return value;
      }
      `},bb=(a,e,o,s,d,c)=>{let h=e.length,_="";for(let bt=h-1;bt>=0;--bt)_+=`
        k = m[${bt}] - ${c[bt]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(e[bt]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${e[bt]}) { k = _2n_1 - k; }
        }
        offset += k * ${o[bt]};
        `;return`
      float padA(int m[${h}]) {
        int offset = 0;
        int k = 0;
        ${_}
        vec2 coords = offsetToCoords(offset, ${s}, ${d});
        float value = getColorAsFloat(${a.texture2D}(A, coords));
        return value;
      }
      `},gb=(a,e,o,s,d,c)=>{let h=e.length,_="";for(let bt=h-1;bt>=0;--bt)_+=`
        k = m[${bt}] - ${c[bt]};
        if (k < 0)  k = 0;
        if (k >= ${e[bt]}) k = ${e[bt]-1};
        offset += k * ${o[bt]};
      `;return`
      float padA(int m[${h}]) {
        int offset = 0;
        int k = 0;
        ${_}
        vec2 coords = offsetToCoords(offset, ${s}, ${d});
        float value = getColorAsFloat(${a.texture2D}(A, coords));
        return value;
      }
      `}}),Hf,qf,jf,Yf,Xf,Kf,Jf,Zf,Qf,yb,Wf,ec$1,uo$1,tc$1,so$1,Tb,rc$1=E(()=>{Ge$1(),fe(),ae(),Hf=(a,e,o)=>{uo$1(e);let s={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:o.cacheKey};return[a.run({...s,get:()=>jf(e,s,!1,o)},e)]},qf=a=>{let e=a.attributes.getString("auto_pad","NOTSET"),o=a.attributes.getInt("ceil_mode",0),s=a.attributes.getInt("count_include_pad",0)!==0,d=a.attributes.getInts("kernel_shape"),c=a.attributes.getInts("strides",[]),h=a.attributes.getInts("pads",[]);if(o!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ee({autoPad:e,ceilMode:o,countIncludePad:s,kernelShape:d,strides:c,pads:h})},jf=(a,e,o,s)=>{let[d,c]=Qf(a,s,o),h=U.size(d.kernelShape),_="value += _X(x);",bt="";d.countIncludePad?bt+=`value /= float(${h});`:bt+=`value /= float(${h} - pad);`;let g=`
        ${tc$1(a[0].dims,d,_,bt,"0.0")}
      `;return{...e,output:{dims:c,type:a[0].type,textureType:0},shaderSource:g}},Yf=(a,e,o)=>{uo$1(e);let s={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${o.countIncludePad}`};return[a.run({...s,get:()=>jf(e,s,!0,o)},e)]},Xf=a=>{let e=a.attributes.getInt("count_include_pad",0)!==0;return ee({autoPad:"",ceilMode:0,countIncludePad:e,kernelShape:[],strides:[],pads:[]})},Kf=(a,e,o)=>{uo$1(e);let s={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:o.cacheKey};return[a.run({...s,get:()=>Zf(e,s,!1,o)},e)]},Jf=a=>{let e=a.attributes.getString("auto_pad","NOTSET"),o=a.attributes.getInt("ceil_mode",0),s=a.attributes.getInts("kernel_shape"),d=a.attributes.getInts("strides",[]),c=a.attributes.getInts("pads",[]),h=a.attributes.getInt("storage_order",0),_=a.attributes.getInts("dilations",[]);if(h!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ee({autoPad:e,ceilMode:o,countIncludePad:!1,kernelShape:s,strides:d,pads:c,storageOrder:h,dilations:_})},Zf=(a,e,o,s)=>{let[d,c]=Qf(a,s,o),h=`
      value = max(_X(x), value);
    `,_="",bt=`
      ${tc$1(a[0].dims,d,h,_,"-1e5")}
    `;return{...e,output:{dims:c,type:a[0].type,textureType:0},shaderSource:bt}},Qf=(a,e,o)=>{let s=a[0].dims.slice(),d=Object.hasOwnProperty.call(e,"dilations"),c=e.kernelShape.slice(),h=e.strides.slice(),_=d?e.dilations.slice():[],bt=e.pads.slice();dr.adjustPoolAttributes(o,s,c,h,_,bt);let g=dr.computePoolOutputShape(o,s,h,_,c,bt,e.autoPad),j=Object.assign({},e);return d?Object.assign(j,{kernelShape:c,strides:h,pads:bt,dilations:_,cacheKey:e.cacheKey}):Object.assign(j,{kernelShape:c,strides:h,pads:bt,cacheKey:e.cacheKey}),[j,g]},yb={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Wf={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},ec$1=(a,e)=>(uo$1(e),[a.run({...Wf,get:()=>Zf(e,Wf,!0,yb)},e)]),uo$1=a=>{if(!a||a.length!==1)throw new Error("Pool ops requires 1 input.");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type.")},tc$1=(a,e,o,s,d)=>{let c=a.length;if(e.kernelShape.length<=2){let h=e.kernelShape[e.kernelShape.length-1],_=e.strides[e.strides.length-1],bt=e.pads[e.pads.length/2-1],g=e.pads[e.pads.length-1],j=a[c-1],b="",Et="",It="";if(bt+g!==0?b=`
          for (int i = 0; i < ${h}; i++) {
            x[${c} - 1] = indices[${c} - 1] * ${_} - ${bt} + i;
            if (x[${c} - 1] < 0 || x[${c} - 1] >= ${j}) {
              pad++;
              continue;
            }
            ${o}
          }`:b=`
          for (int i = 0; i < ${h}; i++) {
            x[${c} - 1] = indices[${c} - 1] * ${_} - ${bt} + i;
            ${o}
          }`,e.kernelShape.length===2){let zt=e.kernelShape[e.kernelShape.length-2],er=e.strides[e.strides.length-2],Hn=e.pads[e.pads.length/2-2],Qt=e.pads[e.pads.length-2],cr=a[c-2];Hn+Qt!==0?Et=`
            for (int j = 0; j < ${zt}; j++) {
              x[${c} - 2] = indices[${c} - 2] * ${er} - ${Hn} + j;
              if (x[${c} - 2] < 0 || x[${c} - 2] >= ${cr}) {
                pad+= ${h};
                continue;
              }
          `:Et=`
            for (int j = 0; j < ${zt}; j++) {
              x[${c} - 2] = indices[${c} - 2] * ${er} - ${Hn} + j;
            `,It=`
          }
        `}return`
        float process(int indices[${c}]) {
          int x[${c}];
          copyVec(indices, x);

          float value = ${d};
          int pad = 0;
          ${Et}
          ${b}
          ${It}
          ${s}
          return value;
        }
      `}else{let h=U.size(e.kernelShape),_=U.computeStrides(e.kernelShape),bt=_.length,g=e.pads.length,j=Tb(bt),b=so$1(a,"inputDims"),Et=so$1(e.pads,"pads"),It=so$1(_,"kernelStrides"),zt=so$1(e.strides,"strides"),er=e.pads.reduce((Qt,cr)=>Qt+cr),Hn="";return er?Hn=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${o}
          }`:Hn=`
          }
          ${o}
        `,`
        ${j}
        float process(int indices[${c}]) {
          int x[${c}];
          copyVec(indices, x);
          int offset[${bt}];
          int pads[${g}];
          int inputDims[${c}];
          int kernelStrides[${bt}];
          int strides[${bt}];
          ${Et}
          ${b}
          ${zt}
          ${It}

          float value = ${d};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${h}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${c} - ${bt}; j < ${c}; j++) {
              x[j] = indices[j] * strides[j - ${c} + ${bt}]
                + offset[j - ${c} + ${bt}] - pads[j - 2];
              ${Hn}
          }
          ${s}

          return value;
        }
      `}},so$1=(a,e)=>{let o="";for(let s=0;s<a.length;s++)o+=`
      ${e}[${s}] = ${a[s]};
    `;return o},Tb=a=>`
  void offsetToIndices(int offset, int[${a}] strides, out int[${a}] indices) {
    if (${a} == 0) {
      return;
    }
    for (int i = 0; i < ${a} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${a} - 1] = offset;
  }`}),xr,Zt,xb,wb,nc$1,oc$1,ic$1,ac$1,sc$1,uc$1,lc$1,fc$1=E(()=>{Ge$1(),hn$1(),fe(),ae(),xr=(a,e,o,s,d)=>{wb(e);let c={name:s,inputNames:["A"],inputTypes:[0]};return[a.run({...c,cacheHint:o.cacheKey,get:()=>xb(a,e,o,s,d,c)},e)]},Zt=a=>{let e=a.attributes.getInts("axes",[]),o=a.attributes.getInt("keepdims",1)===1;return ee({axes:e,keepDims:o})},xb=(a,e,o,s,d,c)=>{let h=[],_=e[0].dims.length||1,bt=[],g=U.normalizeAxes(o.axes,e[0].dims.length),j=d(e,g),b=j[1];for(let It=0;It<e[0].dims.length;It++)g.indexOf(It)>=0||g.length===0?(o.keepDims&&h.push(1),b=`
          for(int j${It} = 0; j${It} < ${e[0].dims[It]}; j${It}++) {
            inputIdx[${It}] = j${It};
            ${b}
          }`):(bt.push(`inputIdx[${It}] = outputIdx[${h.length}];`),h.push(e[0].dims[It]));let Et=`
      float process(int outputIdx[${h.length||1}]) {
        float value;                 // final result
        int inputIdx[${_}];      // addressing input data
        ${bt.join(`
`)}
        ${j[0]}       // init ops for reduce max/min
        ${b}
        ${j[2]}       // final computation for reduce mean
        return value;
      }`;return{...c,output:{dims:h,type:e[0].type,textureType:0},shaderSource:Et}},wb=a=>{if(!a||a.length!==1)throw new Error("Reduce op requires 1 input.");if(Jt.indexOf(a[0].type)===-1)throw new Error("Invalid input type.")},nc$1=(a,e,o)=>xr(a,e,o,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),oc$1=(a,e,o)=>xr(a,e,o,"ReduceMean",(s,d)=>{let c=1;for(let h=0;h<s[0].dims.length;h++)(d.indexOf(h)>=0||d.length===0)&&(c*=s[0].dims[h]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${c}.;`]}),ic$1=(a,e,o)=>xr(a,e,o,"ReduceMax",(s,d)=>{let c=[];for(let h=0;h<s[0].dims.length;h++)(d.indexOf(h)>=0||d.length===0)&&c.push(`inputIdx[${h}] = 0;`);return[`${c.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),ac$1=(a,e,o)=>xr(a,e,o,"ReduceMin",(s,d)=>{let c=[];for(let h=0;h<s[0].dims.length;h++)(d.indexOf(h)>=0||d.length===0)&&c.push(`inputIdx[${h}] = 0;`);return[`${c.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),sc$1=(a,e,o)=>xr(a,e,o,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),uc$1=(a,e,o)=>xr(a,e,o,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),lc$1=(a,e,o)=>xr(a,e,o,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])}),cc$1,pc$1=E(()=>{fe(),cc$1=(a,e)=>{let o=U.calculateReshapedDims(e[0].dims,e[1].integerData);return a.session.pack?[a.reshapePacked(e[0],o)]:[a.reshapeUnpacked(e[0],o)]}}),dc$1,Ni$1,hc$1,mc$1,mn$1,vb,Ri$1,lo$1,Mi$1=E(()=>{Ge$1(),xe(),ae(),dc$1={name:"Upsample",inputNames:["X"],inputTypes:[0]},Ni$1=(a,e,o)=>(Ri$1(e,o),[a.run({...dc$1,cacheHint:o.cacheKey,get:()=>vb(a,e,o)},e)]),hc$1=a=>mn$1(a,7),mc$1=a=>mn$1(a,9),mn$1=(a,e)=>{let o=e>=10,s=a.attributes.getString("mode","nearest");if(s!=="nearest"&&s!=="linear"&&(e<11||s!=="cubic"))throw new Error(`unrecognized mode: ${s}`);let d=[];e<9&&(d=a.attributes.getFloats("scales"),lo$1(d,s,o));let c=a.attributes.getFloat("extrapolation_value",0),h=e>10?a.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(h)===-1)throw new Error(`coordinate_transform_mode '${h}' is not supported`);let _=h==="tf_crop_and_resize",bt=_,g=s==="nearest"&&e>=11?a.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(g)===-1)throw new Error(`nearest_mode '${g}' is not supported`);let j=a.attributes.getFloat("cubic_coeff_a",-.75),b=a.attributes.getInt("exclude_outside",0)!==0;if(b&&s!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let Et=e<11?!0:s==="nearest"&&h==="asymmetric"&&g==="floor",It=0,zt=0,er=0;return e>10?a.inputs.length>2?(It=1,zt=2,er=3):(zt=1,er=2):e===9&&(zt=1),ee({opset:e,isResize:o,mode:s,scales:d,extrapolationValue:c,coordinateTransformMode:h,useExtrapolation:bt,needRoiInput:_,nearestMode:g,cubicCoefficientA:j,excludeOutside:b,useNearest2xOptimization:Et,roiInputIdx:It,scalesInputIdx:zt,sizesInputIdx:er})},vb=(a,e,o)=>{let s=q$1(a.session.backend.glContext.version),[d,c]=a.calculateTextureWidthAndHeight(e[0].dims,0),h=e[0].dims.map((er,Hn)=>Math.floor(er*o.scales[Hn])),[_,bt]=a.calculateTextureWidthAndHeight(h,0),g=h.length,j=new Array(g),b=new Array(g),Et=`
      int output_pitches[${g}];
      int input_pitches[${g}];
      `;for(let er=g-1;er>=0;er--)j[er]=er===g-1?1:j[er+1]*h[er+1],b[er]=er===g-1?1:b[er+1]*e[0].dims[er+1],Et+=`
        output_pitches[${er}] = ${j[er]};
        input_pitches[${er}] = ${b[er]};
        `;let It=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${d}, ${c});
        float value = getColorAsFloat(${s.texture2D}(X, coords));
        return value;
      }
      `,zt=o.mode==="nearest"?`
    ${It}
    float process(int indices[${g}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${_}, ${bt});

      ${Et}

      int d, m;
      for (int dim = 0; dim < ${g}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:g===4?`
    ${It}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${_}, ${bt});

      ${Et}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${It}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${_}, ${bt});

      ${Et}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...dc$1,output:{dims:h,type:e[0].type,textureType:0},shaderSource:zt,variables:[{name:"scales",type:"int",arrayLength:o.scales.length,data:o.scales.map(er=>Math.ceil(er))}]}},Ri$1=(a,e)=>{if(!a||e.opset<9&&a.length!==1||e.opset>=9&&e.opset<11&&a.length!==2||e.opset>=11&&a.length<2)throw new Error("invalid inputs.");if(e.scales.length>0&&a[0].dims.length!==e.scales.length)throw new Error("Invalid input shape.");if(a[0].type==="string")throw new Error("Invalid input tensor types.")},lo$1=(a,e,o)=>{if(o){for(let s of a)if(s<=0)throw new Error("Scale value should be greater than 0.")}else for(let s of a)if(s<1)throw new Error("Scale value should be greater than or equal to 1.");if((e==="linear"||e==="cubic")&&a.length!==2&&(a.length!==4||a[0]!==1||a[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${o?"Resize":"Upsample"} opeartor.`)}}),Gi,Ui$1,bc$1,gc$1,_b,Ob,Ib,Sb,yc$1=E(()=>{xe(),ae(),kt(),gr(),Mi$1(),Gi={name:"Resize",inputNames:["A"],inputTypes:[2]},Ui$1=(a,e,o)=>(Ri$1(e,o),[a.run({...Gi,cacheHint:o.cacheKey,get:()=>_b(a,e,o)},e)]),bc$1=a=>mn$1(a,10),gc$1=a=>mn$1(a,11),_b=(a,e,o)=>{let s=q$1(a.session.backend.glContext.version),[d,c]=Ob(e,o);if(d.every(cr=>cr===1)&&o.coordinateTransformMode!=="tf_crop_and_resize")return{...Gi,output:{dims:c,type:e[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${s.texture2D}(X, TexCoords);
                    ${s.output} = v;
                }`};let h=c.length;if(h<2)throw new Error(`output dimension should be at least 2, but got ${h}`);let _=c[h-2],bt=c[h-1],g=e[0].dims;if(h!==g.length)throw new Error(`output dimension should match input ${g.length}, but got ${h}`);let j=g[h-2],b=g[h-1],Et=d[h-2],It=d[h-1],zt="";if(o.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${o.mode}'`);switch(o.coordinateTransformMode){case"asymmetric":zt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":zt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":zt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${bt}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${_}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${bt}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${_}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":zt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${bt}.0 - 1.0, ${_}.0 - 1.0, ${bt}.0 - 1.0,
                            ${_}.0 - 1.0);
                        vec4 original = vec4(${b}.0 - 1.0, ${j}.0 - 1.0, ${b}.0 - 1.0,
                            ${j}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${o.coordinateTransformMode}'`)}let er=Je(h),Hn=Bt$1(),Qt=`
            const vec2 inputWH = vec2(${j}.0, ${b}.0);
            const vec4 scaleWHWH = vec4(float(${Et}), float(${It}), float(${Et}), float(${It}));
            ${Hn}
            ${zt}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${er} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${_-1};
                bool hasNextCol = rc.z < ${bt-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${s.output} = vec4(newValue);
            }
        `;return{...Gi,output:{dims:c,type:e[0].type,textureType:2},hasMain:!0,shaderSource:Qt}},Ob=(a,e)=>{let o=a[0].dims,s=e.scales,d;if(s.length===0){let h=a[e.scalesInputIdx];if(h&&h.size!==0){if(a[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");s=Ib(h,e.mode,e.isResize)}else{let _=a[e.sizesInputIdx];if(!_||_.size===0)throw new Error("Either scales or sizes MUST be provided as input.");d=Array.from(_.integerData),s=Sb(d,o,e.mode,e.isResize)}}else if(a[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let c=d||o.map((h,_)=>Math.floor(h*s[_]));return[s,c]},Ib=(a,e,o)=>{let s=Array.from(a.floatData);return lo$1(s,e,o),s},Sb=(a,e,o,s)=>{let d=e.length,c=new Array(d);for(let h=0,_=d;h<_;h++)if(e[h]===0){if(a[h]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");c[h]=1}else c[h]=a[h]/e[h];return lo$1(c,o,s),c}}),Tc$1,Ab,xc$1=E(()=>{br(),Tc$1=(a,e)=>(Ab(e),[new Ce([e[0].dims.length],"int32",void 0,void 0,new Int32Array(e[0].dims))]),Ab=a=>{if(!a||a.length!==1)throw new Error("Shape requires 1 input.")}}),zi$1,wc$1,vc,_c$1,Pb,Oc$1,Eb,Db,Ic$1=E(()=>{Ge$1(),hn$1(),fe(),ae(),zi$1={name:"Slice",inputNames:["A"],inputTypes:[0]},wc$1=(a,e,o)=>(Pb(e),[a.run({...zi$1,cacheHint:o.cacheKey,get:()=>_c$1(a,e[0],o)},e)]),vc=a=>{let e=a.attributes.getInts("starts"),o=a.attributes.getInts("ends"),s=a.attributes.getInts("axes",[]);return ee({starts:e,ends:o,axes:s})},_c$1=(a,e,o)=>{let s=o.axes.length===0?e.dims.slice(0).map((j,b)=>b):o.axes,d=U.normalizeAxes(s,e.dims.length),c=o.starts.map((j,b)=>j>e.dims[d[b]]-1?e.dims[d[b]]:U.normalizeAxis(j,e.dims[d[b]])),h=o.ends.map((j,b)=>j>e.dims[d[b]]-1?e.dims[d[b]]:U.normalizeAxis(j,e.dims[d[b]])),_=e.dims.slice(),bt=[];for(let j=0;j<d.length;j++)_[d[j]]=h[j]-c[j],c[j]>0&&bt.push(`outputIdx[${d[j]}] += ${c[j]};`);let g=`
      float process(int outputIdx[${_.length}]) {
        ${bt.join(`
      `)}
        return _A(outputIdx);
      }`;return{...zi$1,output:{dims:_,type:e.type,textureType:0},shaderSource:g}},Pb=a=>{if(!a||a.length!==1)throw new Error("Slice requires 1 input.");if(Jt.indexOf(a[0].type)===-1)throw new Error("Invalid input type.")},Oc$1=(a,e)=>{Db(e);let o=Eb(a,e);return[a.run({...zi$1,cacheHint:o.cacheKey,get:()=>_c$1(a,e[0],o)},[e[0]])]},Eb=(a,e)=>{if(!a.session.isInitializer(e[1].dataId)||!a.session.isInitializer(e[2].dataId)||e.length>=4&&!a.session.isInitializer(e[3].dataId)||e.length>=5&&!a.session.isInitializer(e[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(e.length>=5&&e[4].integerData.some(h=>h!==1))throw new Error("currently non-1 steps is not supported for Slice");let o=Array.from(e[1].integerData),s=Array.from(e[2].integerData),d=e.length>=4?Array.from(e[3].integerData):[],c=`${d};${o};${s}`;return{starts:o,ends:s,axes:d,cacheKey:c}},Db=a=>{if(!a||a.length<3||a.length>5)throw new Error("Invalid input number.");if(a[1].type!=="int32"||a[1].dims.length!==1)throw new Error("Invalid input type.");if(a[2].type!=="int32"||a[2].dims.length!==1)throw new Error("Invalid input type.");if(a.length>=4&&(a[3].type!=="int32"||a[3].dims.length!==1))throw new Error("Invalid input type.");if(a.length>=5&&(a[4].type!=="int32"||a[4].dims.length!==1))throw new Error("Invalid input type.")}}),Sc$1,Ac$1,Pc$1,Ec$1,Dc$1,Lc$1,Fc$1,Cc$1,Lb,Fb,Cb,$c$1,kc$1=E(()=>{Ge$1(),fe(),xe(),ae(),ao$1(),Sc$1={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},Ac$1={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},Pc$1={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},Ec$1=(a,e,o)=>{$c$1(e);let s=e[0].dims.slice(),d=U.normalizeAxis(o.axis,s.length),c=U.sizeToDimension(s,d),h=U.sizeFromDimension(s,d);return Cc$1(a,e,o,c,h)},Dc$1=a=>ee({axis:a.attributes.getInt("axis",1)}),Lc$1=a=>ee({axis:a.attributes.getInt("axis",-1)}),Fc$1=(a,e,o)=>{$c$1(e);let s=e[0].dims.slice(),d=U.normalizeAxis(o.axis,s.length),c=s.length,h=d!==c-1,_=[],bt=[],g=[],j;h&&(bt=Array.from({length:c}).map((zt,er)=>er),bt[d]=c-1,bt[c-1]=d,bt.map(zt=>_.push(s[zt])),j=ee({perm:bt}),g=Tr$1(a,e,j));let b=h?U.sizeToDimension(_,c-1):U.sizeToDimension(s,c-1),Et=h?U.sizeFromDimension(_,c-1):U.sizeFromDimension(s,c-1),It=Cc$1(a,h?g:e,o,b,Et);return h?Tr$1(a,It,j):It},Cc$1=(a,e,o,s,d)=>{let c=Lb(a,e[0],s,d,[s]),h=a.run({...Sc$1,cacheHint:o.cacheKey,get:()=>c},e),_=Fb(a,e[0],s,d,c.output.dims,[s]),bt=a.run({...Ac$1,cacheHint:o.cacheKey,get:()=>_},[e[0],h]),g=Cb(a,e[0],s,d,c.output.dims,_.output.dims);return[a.run({...Pc$1,cacheHint:o.cacheKey,get:()=>g},[e[0],h,bt])]},Lb=(a,e,o,s,d)=>{let[c,h]=a.calculateTextureWidthAndHeight(e.dims,0),_=d.length;if(o<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(d.length!==1)throw new Error("Dimensionality of the output should be 1");if(d[0]!==o)throw new Error("Shape of the output should be equal to logical row count");let bt=q$1(a.session.backend.glContext.version),g=`
      float process(int[${_}] indices) {
        int logical_row_start_offset = indices[0] * ${s};

        float max = getColorAsFloat(${bt.texture2D}(A, offsetToCoords(logical_row_start_offset, ${c},
        ${h} )));
        for(int i=1; i<${s}; ++i)
        {
          float current = getColorAsFloat(${bt.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${c}, ${h})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...Sc$1,output:{dims:d,type:e.type,textureType:0},shaderSource:g}},Fb=(a,e,o,s,d,c)=>{let[h,_]=a.calculateTextureWidthAndHeight(e.dims,0),bt=c.length;if(o<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(c.length!==1)throw new Error("Dimensionality of the output should be 1");if(c[0]!==o)throw new Error("Shape of the output should be equal to logical row count");if(d.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(d[0]!==o)throw new Error("Shape of the intermediate results should be equal to logical row count");let g=q$1(a.session.backend.glContext.version),j=`
      float process(int[${bt}] indices) {
        int logical_row_start_offset = indices[0] * ${s};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${s}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${g.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${h}, ${_}))) - max);
        }

        return norm_factor;
      }`;return{...Ac$1,output:{dims:c,type:e.type,textureType:0},shaderSource:j}},Cb=(a,e,o,s,d,c)=>{let[h,_]=a.calculateTextureWidthAndHeight(e.dims,0),bt=e.dims.length;if(o<1||s<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(d.length!==1||c.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(d[0]!==o||c[0]!==o)throw new Error("Shape of the intermediate results should be equal to logical row count");let g=`
      float process(int[${bt}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${h}, ${_});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${s};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...Pc$1,output:{dims:e.dims,type:e.type,textureType:0},shaderSource:g}},$c$1=a=>{if(!a||a.length!==1)throw new Error("Softmax requires 1 input.");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type")}}),Bc$1,Nc$1,Rc$1,$b,kb,Bb,Mc$1=E(()=>{Ge$1(),fe(),ae(),Bc$1={name:"Split",inputNames:["A"],inputTypes:[0]},Nc$1=(a,e,o)=>{Bb(e);let s=U.normalizeAxis(o.axis,e[0].dims.length),d=$b(a,e,s,o),c=[];for(let h=0;h<d;++h)c.push(a.run({...Bc$1,cacheHint:`${o.cacheKey};${h}`,get:()=>kb(a,e[0],o,s,h)},e));return c},Rc$1=a=>{let e=a.attributes.getInt("axis",0),o=a.attributes.getInts("split",[]),s=a.outputs.length;return ee({axis:e,split:o,numOutputs:s})},$b=(a,e,o,s)=>{let[,d]=un$1.splitShape(e[0].dims,o,s.split,s.numOutputs);return d.length},kb=(a,e,o,s,d)=>{let[c,h]=un$1.splitShape(e.dims,s,o.split,o.numOutputs),_=h[d],bt=c[d],g=`
      float process(int indices[${bt.length}]) {
        indices[${s}] += ${_};
        return _A(indices);
      }
    `;return{...Bc$1,cacheHint:`${o.cacheKey}:${d}`,output:{dims:bt,type:e.type,textureType:0},shaderSource:g}},Bb=a=>{if(!a||a.length!==1)throw new Error("Split requires one input.");if(a[0].type!=="int8"&&a[0].type!=="uint8"&&a[0].type!=="int16"&&a[0].type!=="uint16"&&a[0].type!=="int32"&&a[0].type!=="uint32"&&a[0].type!=="float32"&&a[0].type!=="float64"&&a[0].type!=="bool")throw new Error("Invalid input type.")}}),Vi$1,Gc$1,Uc$1,Nb,Rb,zc$1=E(()=>{fe(),Vi$1=(a,e,o)=>{Nb(e);let s=U.squeezeShape(e[0].dims,o);return[a.reshapeUnpacked(e[0],s)]},Gc$1=(a,e)=>(Rb(e),Vi$1(a,[e[0]],Array.from(e[1].integerData))),Uc$1=a=>a.attributes.getInts("axes"),Nb=a=>{if(!a||a.length!==1)throw new Error("Squeeze requires 1 input.");if(a[0].type==="string")throw new Error("invalid input tensor types.")},Rb=a=>{if(!a||a.length!==2)throw new Error("Squeeze requires 2 inputs.");if(a[1].type!=="int32")throw new Error("Invalid input type.")}}),Vc$1,Mb,Gb,Wc$1=E(()=>{xe(),ae(),Vc$1=(a,e)=>{Gb(e);let o={name:"Sum",inputNames:e.map((s,d)=>`X${d}`),inputTypes:new Array(e.length).fill(0)};return[a.run({...o,get:()=>Mb(a,e,o)},e)]},Mb=(a,e,o)=>{let s=q$1(a.session.backend.glContext.version),d=e[0].dims.slice(),c=`
      void main() {
        vec4 result = ${e.map((h,_)=>`${s.texture2D}(X${_},TexCoords)`).join(" + ")};
        ${s.output} = result;
      }
    `;return{...o,output:{dims:d,type:e[0].type,textureType:0},hasMain:!0,shaderSource:c}},Gb=a=>{if(!a||a.length===0)throw new Error("Sum requires inputs.");let e=a[0].dims.length;for(let o=1;o<a.length;o++){if(e!==a[o].dims.length)throw new Error("Input shapes are mismatched.");for(let s=0;s<e;s++)if(a[0].dims[s]!==a[o].dims[s])throw new Error("Input shapes are not matched.")}if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type.");for(let o=1;o<a.length;o++)if(a[0].type!==a[o].type)throw new Error("Input types are not matched.")}}),Hc$1,Ub,zb,qc$1=E(()=>{hn$1(),ae(),Hc$1=(a,e)=>{zb(e);let o={name:"Tile",inputNames:["A"],inputTypes:[0]};return[a.run({...o,get:()=>Ub(a,e,o)},e)]},Ub=(a,e,o)=>{let s=e[0].dims.slice(),d=new Array(s.length),c=[];for(let bt=0;bt<s.length;bt++)d[bt]=s[bt]*e[1].numberData[bt],c.push(`inputIdx[${bt}] = int(mod(float(outputIdx[${bt}]), ${s[bt]}.));`);let h=d.length,_=`
      float process(int outputIdx[${h}]) {
        int inputIdx[${h}];
        ${c.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...o,output:{dims:d,type:e[0].type,textureType:0},shaderSource:_}},zb=a=>{if(!a||a.length!==2)throw new Error("Tile requires 2 input.");if(a[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(a[1].dims[0]!==a[0].dims.length)throw new Error("Invalid input shape.");if(Jt.indexOf(a[0].type)===-1)throw new Error("Invalid input type.");if(a[1].type!=="int32"&&a[1].type!=="int16")throw new Error("Invalid repeat type.")}}),Wi$1,jc$1,Yc$1,Vb,Wb,Xc$1=E(()=>{fe(),Wi$1=(a,e,o)=>{Vb(e);let s=U.unsqueezeShape(e[0].dims,o);return[a.reshapeUnpacked(e[0],s)]},jc$1=(a,e)=>(Wb(e),Wi$1(a,[e[0]],Array.from(e[1].integerData))),Yc$1=a=>a.attributes.getInts("axes"),Vb=a=>{if(!a||a.length!==1)throw new Error("Unsqueeze requires 1 input.");if(a[0].type==="string")throw new Error("invalid input tensor types.")},Wb=a=>{if(!a||a.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(a[1].type!=="int32")throw new Error("Invalid input type.")}}),Kc$1,Jc$1=E(()=>{al$1(),Tl$1(),vl$1(),Pl$1(),no$1(),pf(),yf(),wf(),Of(),Pf(),Lf(),kf(),Mf(),oo$1(),Vf(),rc$1(),fc$1(),pc$1(),yc$1(),xc$1(),Ic$1(),kc$1(),Mc$1(),zc$1(),Wc$1(),qc$1(),ao$1(),Ai$1(),Xc$1(),Mi$1(),Kc$1=[["Abs","","6+",El$1],["Acos","","7+",Dl$1],["Add","","7+",sl$1],["And","","7+",ul$1],["Asin","","7+",Ll$1],["Atan","","7+",Fl$1],["AveragePool","","7+",Hf,qf],["BatchNormalization","","7+",ol$1,il$1],["Cast","","6+",xl$1,wl$1],["Ceil","","6+",kl$1],["Clip","","6-10",Ii$1,Cl$1],["Clip","","11+",$l$1],["Concat","","4+",Il$1,Al$1],["Conv","","1+",Ci$1,$i$1],["ConvTranspose","","1+",ff$1,cf],["Cos","","7+",Bl$1],["Div","","7+",ll$1],["Dropout","","7+",Si$1],["DepthToSpace","","1+",bf,gf$1],["Equal","","7+",fl$1],["Elu","","6+",Nl$1,Rl$1],["Exp","","6+",Ml$1],["Flatten","","1+",Tf,xf],["Floor","","6+",Gl$1],["FusedConv","com.microsoft","1+",Ci$1,$i$1],["Gather","","1+",vf,_f],["Gemm","","7-10",ki$1,Sf],["Gemm","","11+",ki$1,Af],["GlobalAveragePool","","1+",Yf,Xf],["GlobalMaxPool","","1+",ec$1],["Greater","","7+",cl$1],["Identity","","1+",Si$1],["ImageScaler","","1+",Ef,Df],["InstanceNormalization","","6+",Cf,$f],["LeakyRelu","","6+",Ul$1,zl$1],["Less","","7+",pl$1],["LRN","","1+",Bf,Nf],["Log","","6+",Vl$1],["MatMul","","1+",rf$1,nf$1],["MaxPool","","1+",Kf,Jf],["Mul","","7+",dl$1],["Neg","","6+",Wl$1],["Not","","1+",Hl$1],["Or","","7+",hl$1],["Pad","","2-10",Bi,Gf],["Pad","","11+",Uf,zf],["Pow","","7+",ml$1],["PRelu","","7+",bl$1],["ReduceLogSum","","1+",uc$1,Zt],["ReduceMax","","1+",ic$1,Zt],["ReduceMean","","1+",oc$1,Zt],["ReduceMin","","1+",ac$1,Zt],["ReduceProd","","1+",sc$1,Zt],["ReduceSum","","1-12",nc$1,Zt],["ReduceSumSquare","","1+",lc$1,Zt],["Relu","","6+",ql$1],["Reshape","","5+",cc$1],["Resize","","10",Ui$1,bc$1],["Resize","","11+",Ui$1,gc$1],["Shape","","1+",Tc$1],["Sigmoid","","6+",jl$1],["Sin","","7+",Yl$1],["Slice","","10+",Oc$1],["Slice","","1-9",wc$1,vc],["Softmax","","1-12",Ec$1,Dc$1],["Softmax","","13+",Fc$1,Lc$1],["Split","","2-12",Nc$1,Rc$1],["Sqrt","","6+",Xl],["Squeeze","","1-12",Vi$1,Uc$1],["Squeeze","","13+",Gc$1],["Sub","","7+",gl$1],["Sum","","6+",Vc$1],["Tan","","7+",Kl$1],["Tanh","","6+",Jl],["Tile","","6+",Hc$1],["Transpose","","1+",Tr$1,hf$1],["Upsample","","7-8",Ni$1,hc$1],["Upsample","","9",Ni$1,mc$1],["Unsqueeze","","1-12",Wi$1,Yc$1],["Unsqueeze","","13+",jc$1],["Xor","","7+",yl$1]]});function Qc$1(a){let e={},o;for(;(o=Zc$1.exec(a))!==null;){let s=o[3].split(",").map(d=>{let c=d.trim().split(" ");return c&&c.length===2?{type:c[0],name:c[1]}:null}).filter(d=>d!==null);e[o[2]]={params:s,body:o[4]}}for(let s in e){let d=Hb.replace("__FUNC__",s),c=new RegExp(d,"gm");for(;(o=c.exec(a))!==null;){let h=o[1],_=o[2],bt=o[3].split(","),g=h?`${h} ${_};`:"",j=e[s].body,b="";e[s].params.forEach((It,zt)=>{It&&(b+=`${It.type} ${It.name} = ${bt[zt]};
`)}),j=`${b}
 ${j}`,j=j.replace("return",`${_} = `);let Et=`
      ${g}
      {
        ${j}
      }
      `;a=a.replace(o[0],Et)}}return a=a.replace(Zc$1,""),a}var Zc$1,Hb,ep$1=E(()=>{Zc$1=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,Hb="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"});function Ur(a,e){let o=[],s=[],d=e!=null&&Array.isArray(e)&&e.length===0,c=e==null||d?null:qb(e,a).sort(),h=0;for(let _=0;_<a.length;++_){if(c!=null){if(c[h]===_&&a[_]!==1)throw new Error(`Can't squeeze axis ${_} since its dim '${a[_]}' is not 1`);(c[h]==null||c[h]>_)&&a[_]===1&&(o.push(a[_]),s.push(_)),c[h]<=_&&h++}a[_]!==1&&(o.push(a[_]),s.push(_))}return{newShape:o,keptDims:s}}function qb(a,e){let o=e.length;return a=a==null?e.map((s,d)=>d):[].concat(a),kr$1(a.every(s=>s>=-o&&s<o),()=>`All values in axis param must be in range [-${o}, ${o}) but got axis ${a}`),kr$1(a.every(jb),()=>`All values in axis param must be integers but got axis ${a}`),a.map(s=>s<0?o+s:s)}function jb(a){return a%1===0}function Yb(a){if(a.length===0)return 1;let e=a[0];for(let o=1;o<a.length;o++)e*=a[o];return e}function tp$1(a){let e=Math.ceil(Math.sqrt(a));return[e,Math.ceil(a/e)]}var fo$1,Hi=E(()=>{at$1(),fe(),fo$1=class{constructor(a){this.maxTextureSize=a}computeTextureWH(a,e){let o=this.computeTexture(a,e);return e&&e.isPacked&&(o[0]/=2,o[1]/=2),e&&e.reverseWH?[o[1],o[0]]:o}computeTexture(a,e){let o=e&&e.isPacked;if(a.length===0)return o?[2,2]:[1,1];let s=this.maxTextureSize;if(e&&e.breakAxis!==void 0){let h=e.breakAxis>=a.length?1:a.slice(e.breakAxis).reduce((bt,g)=>bt*g),_=e.breakAxis<=0?1:a.slice(0,e.breakAxis).reduce((bt,g)=>bt*g);if(h>s||_>s)ce.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${a}, breakAxis:${e.breakAxis}`);else return[h,_]}let d=a.slice(0);o&&(s=s*2,d=d.map((h,_)=>_>=d.length-2?d[_]%2===0?d[_]:d[_]+1:d[_]),d.length===1&&(d=[2,d[0]])),d.length!==2&&(d=Ur(d).newShape);let c=Yb(d);return d.length<=1&&c<=s?[1,c]:d.length===2&&d[0]<=s&&d[1]<=s?d:d.length===3&&d[0]*d[1]<=s&&d[2]<=s?[d[0]*d[1],d[2]]:d.length===3&&d[0]<=s&&d[1]*d[2]<=s?[d[0],d[1]*d[2]]:d.length===4&&d[0]*d[1]*d[2]<=s&&d[3]<=s?[d[0]*d[1]*d[2],d[3]]:d.length===4&&d[0]<=s&&d[1]*d[2]*d[3]<=s?[d[0],d[1]*d[2]*d[3]]:o?tp$1(c/4).map(h=>h*2):tp$1(c)}}}),co$1,rp$1=E(()=>{fe(),Ht$1(),xe(),Hi(),kt(),co$1=class extends ft{constructor(a){super(a)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let a="offsetToCoords";return{offsetToCoords:new R(`
      vec2 ${a}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){let a="coordsToOffset";return{coordsToOffset:new R(`
      int ${a}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let a=this.context.outputTextureLayout;return a.isPacked?this.getPackedOutputSamplingSnippet(a):this.getUnpackedOutputSamplingSnippet(a)}getPackedOutputSamplingSnippet(a){let e=a.unpackedShape,o=[a.width,a.height],s={},d="getOutputCoords";switch(e.length){case 0:s[d]=this.getOutputScalarCoords();break;case 1:s[d]=this.getOutputPacked1DCoords(e,o);break;case 2:s[d]=this.getOutputPacked2DCoords(e,o);break;case 3:s[d]=this.getOutputPacked3DCoords(e,o);break;default:s[d]=this.getOutputPackedNDCoords(e,o)}let c=`
      void setOutput(vec4 val) {
        ${q$1(this.context.glContext.version).output} = val;
      }
    `,h="floatTextureSetRGBA";return s[h]=new R(c),s}getUnpackedOutputSamplingSnippet(a){let e=a.unpackedShape,o=[a.width,a.height],s={},d="getOutputCoords";switch(e.length){case 0:s[d]=this.getOutputScalarCoords();break;case 1:s[d]=this.getOutputUnpacked1DCoords(e,o);break;case 2:s[d]=this.getOutputUnpacked2DCoords(e,o);break;case 3:s[d]=this.getOutputUnpacked3DCoords(e,o);break;case 4:s[d]=this.getOutputUnpacked4DCoords(e,o);break;case 5:s[d]=this.getOutputUnpacked5DCoords(e,o);break;case 6:s[d]=this.getOutputUnpacked6DCoords(e,o);break;default:throw new Error(`Unsupported output dimensionality: ${e.length}`)}let c=`
        void setOutput(float val) {
          ${q$1(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,h="floatTextureSetR";return s[h]=new R(c),s}getOutputScalarCoords(){return new R(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(a,e){let o=e,s="";return o[0]===1?(s=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${o[1]}.0);
          }
        `,new R(s)):o[1]===1?(s=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${o[0]}.0);
          }
        `,new R(s)):(s=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${o[0]}, ${o[1]}));
          return 2 * (resTexRC.y * ${o[0]} + resTexRC.x);
        }
      `,new R(s))}getOutputPacked2DCoords(a,e){let o="";if(pr.arraysEqual(a,e))return o=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${e[0]}, ${e[1]}));
        }
      `,new R(o);let s=e,d=Math.ceil(a[1]/2);return o=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${s[0]}, ${s[1]}));

          int index = resTexRC.y * ${s[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${d}) * 2;
          int c = 2 * (index / ${d});

          return ivec2(r, c);
        }
      `,new R(o)}getOutputPacked3DCoords(a,e){let o=[e[0],e[1]],s=Math.ceil(a[2]/2),d=s*Math.ceil(a[1]/2),c=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));
          int index = resTexRC.y * ${o[0]} + resTexRC.x;

          int b = index / ${d};
          index -= b * ${d};

          // reverse r and c order for packed texture
          int r = imod(index, ${s}) * 2;
          int c = 2 * (index / ${s});

          return ivec3(b, r, c);
        }
      `;return new R(c)}getOutputPackedNDCoords(a,e){let o=[e[0],e[1]],s=Math.ceil(a[a.length-1]/2),d=s*Math.ceil(a[a.length-2]/2),c=d,h="",_="b, r, c";for(let g=2;g<a.length-1;g++)c*=a[a.length-g-1],h=`
      int b${g} = index / ${c};
      index -= b${g} * ${c};
    `+h,_=`b${g}, `+_;let bt=`
      ivec${a.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${o[0]}, ${o[1]}));
        int index = resTexRC.y * ${o[0]} + resTexRC.x;

        ${h}

        int b = index / ${d};
        index -= b * ${d};

        // reverse r and c order for packed texture
        int r = imod(index, ${s}) * 2;
        int c = 2 * (index / ${s});

        return ivec${a.length}(${_});
      }
    `;return new R(bt)}getOutputUnpacked1DCoords(a,e){let o=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));
          return resTexRC.y * ${e[0]} + resTexRC.x;
        }
      `;return new R(o)}getOutputUnpacked2DCoords(a,e){let o=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));
          int index = resTexRC.y * ${e[0]} + resTexRC.x;
          int r = index / ${a[1]};
          int c = index - r * ${a[1]};
          return ivec2(r, c);
        }
      `;return new R(o)}getOutputUnpacked3DCoords(a,e){let o="",s=a.length,d=null;s<2&&(d=[]),d=new Array(s-1),d[s-2]=a[s-1];for(let _=s-3;_>=0;--_)d[_]=d[_+1]*a[_+1];let c=["r","c","d"],h=d.map((_,bt)=>{let g=`int ${c[bt]} = index / ${_}`,j=bt===d.length-1?`int ${c[bt+1]} = index - ${c[bt]} * ${_}`:`index -= ${c[bt]} * ${_}`;return`${g}; ${j};`}).join("");return o=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));
          int index = resTexRC.y * ${e[0]} + resTexRC.x;
          ${h}
          return ivec3(r, c, d);
        }
      `,new R(o)}getOutputUnpacked4DCoords(a,e){let o="",s=a.length,d=null;s<2&&(d=[]),d=new Array(s-1),d[s-2]=a[s-1];for(let _=s-3;_>=0;--_)d[_]=d[_+1]*a[_+1];let c=["r","c","d","d2"],h=d.map((_,bt)=>{let g=`int ${c[bt]} = index / ${_}`,j=bt===d.length-1?`int ${c[bt+1]} = index - ${c[bt]} * ${_}`:`index -= ${c[bt]} * ${_}`;return`${g}; ${j};`}).join("");return o=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));
          int index = resTexRC.y * ${e[0]} + resTexRC.x;
          ${h}
          return ivec4(r, c, d, d2);
        }
      `,new R(o)}getOutputUnpacked5DCoords(a,e){let o="",s=a.length,d=null;s<2&&(d=[]),d=new Array(s-1),d[s-2]=a[s-1];for(let _=s-3;_>=0;--_)d[_]=d[_+1]*a[_+1];let c=["r","c","d","d2","d3"],h=d.map((_,bt)=>{let g=`int ${c[bt]} = index / ${_}`,j=bt===d.length-1?`int ${c[bt+1]} = index - ${c[bt]} * ${_}`:`index -= ${c[bt]} * ${_}`;return`${g}; ${j};`}).join("");return o=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));
          int index = resTexRC.y * ${e[0]} + resTexRC.x;
          ${h}
          return ivec5(r, c, d, d2, d3);
        }
      `,new R(o)}getOutputUnpacked6DCoords(a,e){let o="",s=a.length,d=null;s<2&&(d=[]),d=new Array(s-1),d[s-2]=a[s-1];for(let _=s-3;_>=0;--_)d[_]=d[_+1]*a[_+1];let c=["r","c","d","d2","d3","d4"],h=d.map((_,bt)=>{let g=`int ${c[bt]} = index / ${_}`,j=bt===d.length-1?`int ${c[bt+1]} = index - ${c[bt]} * ${_}`:`index -= ${c[bt]} * ${_}`;return`${g}; ${j};`}).join("");return o=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${e[0]}, ${e[1]}));
         int index = resTexRC.y * ${e[0]} + resTexRC.x;
         ${h}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new R(o)}getCommonUtilFuncs(){let a={},e="uvFromFlat";a[e]=new R(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),e="packedUVfrom1D",a[e]=new R(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),e="packedUVfrom2D",a[e]=new R(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),e="packedUVfrom3D",a[e]=new R(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),e="sampleTexture";let o=q$1(this.context.glContext.version);return a[e]=new R(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${o.texture2D}(textureSampler, uv).r;
        }`),a}getInputsSamplingSnippets(){let a={},e=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((o,s)=>{let d=this.context.inputTextureLayouts[s],c=Kn$1(o);d.isPacked?a[c]=this.getPackedSamplerFromInput(c,o,d):a[c]=this.getUnpackedSamplerFromInput(c,o,d);let h=zu$1(o);d.unpackedShape.length<=e.unpackedShape.length&&(d.isPacked?a[h]=this.getPackedSamplerAtOutputCoords(h,d,e,o):a[h]=this.getUnpackedSamplerAtOutputCoords(h,d,e,o))}),a}getPackedSamplerAtOutputCoords(a,e,o,s){let d=e.unpackedShape,c=o.unpackedShape,h=Kn$1(s),_=d.length,bt=c.length,g=Ke.getBroadcastDims(d,c),j=Je(bt),b=bt-_,Et,It=Ot();_===0?Et="":bt<2&&g.length>=1?Et="coords = 0;":Et=g.map(jr=>`coords.${It[jr+b]} = 0;`).join(`
`);let zt="";bt<2&&_>0?zt="coords":zt=d.map((jr,e0)=>`coords.${It[e0+b]}`).join(", ");let er="return outputValue;",Hn=U.size(d)===1,Qt=U.size(c)===1;if(_===1&&!Hn&&!Qt)er=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(Hn&&!Qt)bt===1?er=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:er=`
          return vec4(outputValue.x);
        `;else if(g.length){let jr=_-2,e0=_-1;g.indexOf(jr)>-1&&g.indexOf(e0)>-1?er="return vec4(outputValue.x);":g.indexOf(jr)>-1?er="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":g.indexOf(e0)>-1&&(er="return vec4(outputValue.xx, outputValue.zz);")}let cr=`
        int lastDim = coords.${It[bt-1]};
        coords.${It[bt-1]} = coords.${It[bt-2]};
        coords.${It[bt-2]} = lastDim;
      `,fr=`
      vec4 ${a}() {
        ${j} coords = getOutputCoords();
        ${cr}
        ${Et}
        vec4 outputValue = ${h}(${zt});
        ${er}
      }
    `;return new R(fr,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(a,e,o,s){let d=[o.width,o.height],c=[e.width,e.height],h=e.unpackedShape.length,_=o.unpackedShape.length,bt=e.unpackedShape,g=o.unpackedShape,j=Kn$1(s);if(h===_&&pr.arraysEqual(c,d)){let cr=`
          float ${a}() {
            return sampleTexture(${s}, TexCoords);
          }
        `;return new R(cr,["coordinates.sampleTexture"])}let b=Je(_),Et=Ke.getBroadcastDims(bt,g),It=_-h,zt,er=Ot();h===0?zt="":_<2&&Et.length>=1?zt="coords = 0;":zt=Et.map(cr=>`coords.${er[cr+It]} = 0;`).join(`
`);let Hn="";_<2&&h>0?Hn="coords":Hn=e.unpackedShape.map((cr,fr)=>`coords.${er[fr+It]}`).join(", ");let Qt=`
        float ${a}() {
          ${b} coords = getOutputCoords();
          ${zt}
          return ${j}(${Hn});
        }
      `;return new R(Qt,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(a,e,o){switch(o.unpackedShape.length){case 0:return this.getPackedSamplerScalar(a,e);case 1:return this.getPackedSampler1D(a,e,o);case 2:return this.getPackedSampler2D(a,e,o);case 3:return this.getPackedSampler3D(a,e,o);default:return this.getPackedSamplerND(a,e,o)}}getUnpackedSamplerFromInput(a,e,o){let s=o.unpackedShape;switch(s.length){case 0:return this.getUnpackedSamplerScalar(a,e,o);case 1:return this.getUnpackedSampler1D(a,e,o);case 2:return this.getUnpackedSampler2D(a,e,o);case 3:return this.getUnpackedSampler3D(a,e,o);case 4:return this.getUnpackedSampler4D(a,e,o);case 5:return this.getUnpackedSampler5D(a,e,o);case 6:return this.getUnpackedSampler6D(a,e,o);default:throw new Error(`Unsupported dimension ${s.length}-D`)}}getPackedSamplerScalar(a,e){let o=q$1(this.context.glContext.version),s=`
          vec4 ${a}() {
            return ${o.texture2D}(${e}, halfCR);
          }
        `;return new R(s)}getPackedSampler1D(a,e,o){let s=[o.width,o.height],d=[s[1],s[0]],c=q$1(this.context.glContext.version),h=`vec4 ${a}(int index) {
      vec2 uv = packedUVfrom1D(
      ${d[0]}, ${d[1]}, index);
      return ${c.texture2D}(${e}, uv);
    }`;return new R(h,["coordinates.packedUVfrom1D"])}getPackedSampler2D(a,e,o){let s=o.unpackedShape,d=[o.width,o.height],c=q$1(this.context.glContext.version),h=d[0],_=d[1];if(d!=null&&pr.arraysEqual(s,d)){let b=`vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${_}.0, ${h}.0);
        return ${c.texture2D}(${e}, uv);
      }`;return new R(b)}let bt=d,g=Math.ceil(s[1]/2),j=`vec4 ${a}(int row, int col) {
      vec2 uv = packedUVfrom2D(${bt[1]}, ${bt[0]}, ${g}, row, col);
      return ${c.texture2D}(${e}, uv);
    }`;return new R(j,["coordinates.packedUVfrom2D"])}getPackedSampler3D(a,e,o){let s=o.unpackedShape,d=[o.width,o.height],c=[d[0],d[1]],h=q$1(this.context.glContext.version);if(s[0]===1){let Et=s.slice(1),It=[1,2],zt=Br(s,Et),er=["b","row","col"],Hn=JSON.parse(JSON.stringify(o));Hn.unpackedShape=zt;let Qt=this.getPackedSamplerFromInput(a,e,Hn),cr=`${Qt.routineBody}
      vec4 ${a}(int b, int row, int col) {
        return ${a}(${Nr(er,It)});
      } `;return new R(cr,Qt.dependencies)}let _=c[0],bt=c[1],g=Math.ceil(s[2]/2),j=g*Math.ceil(s[1]/2),b=`vec4 ${a}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${bt}, ${_}, ${j}, ${g}, b, row, col);
      return ${h.texture2D}(${e}, uv);}`;return new R(b,["coordinates.packedUVfrom3D"])}getPackedSamplerND(a,e,o){let s=o.unpackedShape,d=s.length,c=[o.width,o.height],h=q$1(this.context.glContext.version),_=[c[0],c[1]],bt=_[1],g=_[0],j=Math.ceil(s[d-1]/2),b=j*Math.ceil(s[d-2]/2),Et="int b, int row, int col",It=`b * ${b} + (row / 2) * ${j} + (col / 2)`;for(let er=2;er<d-1;er++)Et=`int b${er}, `+Et,b*=s[d-er-1],It=`b${er} * ${b} + `+It;let zt=`vec4 ${a}(${Et}) {
      int index = ${It};
      int texR = index / ${g};
      int texC = index - texR * ${g};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${g}, ${bt});
      return ${h.texture2D}(${e}, uv);
    }`;return new R(zt)}getUnpackedSamplerScalar(a,e,o){let[s,d]=[o.width,o.height];if(s===1&&d===1){let h=`
          float ${a}() {
            return sampleTexture(${e}, halfCR);
          }
        `;return new R(h,["coordinates.sampleTexture"])}let c=`
        float ${a}() {
          int offset_${e} = coordsToOffset(TexCoords, ${s}, ${d});
          vec2 uv = uvFromFlat(${s}, ${d}, offset_${e});
          return sampleTexture(${e}, uv);
        }
      `;return new R(c,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(a,e,o){let s=o.width,d=o.height;if(d===1&&s===1){let h=`
        float ${a}(int index) {
          return sampleTexture(${e}, halfCR);
        }
      `;return new R(h,["coordinates.sampleTexture"])}if(d===1){let h=`
          float ${a}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${s}.0, 0.5);
            return sampleTexture(${e}, uv);
          }
        `;return new R(h,["coordinates.sampleTexture"])}if(s===1){let h=`
          float ${a}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${d}.0);
            return sampleTexture(${e}, uv);
          }
        `;return new R(h,["coordinates.sampleTexture"])}let c=`
        float ${a}(int index) {
          vec2 uv = uvFromFlat(${s}, ${d}, index);
          return sampleTexture(${e}, uv);
        }
      `;return new R(c,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(a,e,o){let s=o.unpackedShape,d=[o.height,o.width];if(d!=null&&pr.arraysEqual(s,d)){let b=d[1],Et=d[0],It=`
          float ${a}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${b}.0, ${Et}.0);
            return sampleTexture(${e}, uv);
          }
        `;return new R(It,["coordinates.sampleTexture"])}let{newShape:c,keptDims:h}=Ur(s),_=c;if(_.length<s.length){let b=Br(s,_),Et=JSON.parse(JSON.stringify(o));Et.unpackedShape=b;let It=["col","row"],zt=`
          ${this.getUnpackedSamplerFromInput(a,e,Et).routineBody}
          float ${a}(int row, int col) {
            return ${a}(${Nr(It,h)});
          }
        `;return new R(zt,["coordinates.sampleTexture"])}let bt=d[1],g=d[0];if(g===1){let b=`
          float ${a}(int row, int col) {
            int offset_${e} = coordsToOffset(TexCoords, ${bt}, ${g});
            float index = dot(vec3(row, col, offset_${e}), vec3(${s[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${bt}.0);
            return sampleTexture(${e}, uv);
          }
        `;return new R(b,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(bt===1){let b=`
          float ${a}(int row, int col) {
            int offset_${e} = coordsToOffset(TexCoords, ${bt}, ${g});
            float index = dot(vec3(row, col, offset_${e}), vec3(${s[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${g}.0, 0.5);
            return sampleTexture(${e}, uv);
          }
        `;return new R(b,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let j=`
        float ${a}(int row, int col) {
          int index = col * ${s[1]} + row;
          vec2 uv = uvFromFlat(${bt}, ${g}, index);
          return sampleTexture(${e}, uv);
        }
      `;return new R(j,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(a,e,o){let s=o.unpackedShape,d=s[1]*s[2],c=s[2],{newShape:h,keptDims:_}=Ur(s),bt=h;if(bt.length<s.length){let Et=Br(s,bt),It=["batch","col","row"],zt=JSON.parse(JSON.stringify(o));zt.unpackedShape=Et;let er=this.getUnpackedSamplerFromInput(a,e,zt),Hn=_.reverse(),Qt=`
          ${er.routineBody}
          float ${a}(int batch, int row, int col) {
            return ${a}(${Nr(It,Hn)});
          }
        `;return new R(Qt,er.dependencies)}let g=o.width,j=o.height,b=`
          float ${a}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${d} + col * ${c} + row;
            vec2 uv = uvFromFlat(${g}, ${j}, index);
            return sampleTexture(${e}, uv);
          }
      `;return new R(b,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(a,e,o){let s=o.unpackedShape,d=s[3],c=s[2]*d,h=s[1]*c,_=o.width,bt=o.height,g=`
        float ${a}(int row, int col, int depth, int depth2) {
          int index = row * ${h} + col * ${c} +
              depth2 * ${d} + depth;
          vec2 uv = uvFromFlat(${_}, ${bt}, index);
          return sampleTexture(${e}, uv);
        }
      `;return new R(g,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(a,e,o){let s=o.unpackedShape,d=s[4],c=s[3]*d,h=s[2]*c,_=s[1]*h,{newShape:bt,keptDims:g}=Ur(s);if(bt.length<s.length){let It=Br(s,bt),zt=["row","col","depth","depth2","depth3"],er=JSON.parse(JSON.stringify(o));er.unpackedShape=It;let Hn=`
          ${this.getUnpackedSamplerFromInput(a,e,er).routineBody}
          float ${a}(int row, int col, int depth, int depth2, int depth3) {
            return ${a}(${Nr(zt,g)});
          }
        `;return new R(Hn,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let j=o.width,b=o.height,Et=`
        float ${a}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${_} + col * ${h} + depth * ${c} +
          depth3 * ${d} + depth2;
          vec2 uv = uvFromFlat(${j}, ${b}, index);
          return sampleTexture(${e}, uv);
        }
      `;return new R(Et,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(a,e,o){let s=o.unpackedShape,d=s[5],c=s[4]*d,h=s[3]*c,_=s[2]*h,bt=s[1]*_,{newShape:g,keptDims:j}=Ur(s);if(g.length<s.length){let zt=Br(s,g),er=["row","col","depth","depth2","depth3","depth4"],Hn=JSON.parse(JSON.stringify(o));Hn.unpackedShape=zt;let Qt=`
            ${this.getUnpackedSamplerFromInput(a,e,Hn).routineBody}
            float ${a}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${a}(${Nr(er,j)});
            }
          `;return new R(Qt,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let b=o.width,Et=o.height,It=`
          float ${a}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${bt} + col * ${_} + depth * ${h} +
            depth2 * ${c} + depth3 * ${d} + depth4;
            vec2 uv = uvFromFlat(${b}, ${Et}, index);
            return sampleTexture(${e}, uv);
          }
        `;return new R(It,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let a=this.context.outputTextureLayout,e=a.shape.length,o=a.strides,s=a.width,d=a.height,c=[];for(let _=0;_<e-1;++_)c.push(`
        c[${_}] = offset / ${o[_]};`),c.push(`
        offset -= c[${_}] * ${o[_]};`);c.push(`
        c[${e-1}] = offset;`);let h=`
      void toVec(vec2 texCoords, out int c[${e}]) {
        int offset = coordsToOffset(texCoords, ${s}, ${d});
        ${c.join("")}
      }
      void toVec(int offset, out int c[${e}]) {
        ${c.join("")}
      }
    `;return{toVec:new R(h,["coordinates.coordsToOffset"])}}valueFrom(){let a={};return this.context.programInfo.inputNames.forEach((e,o)=>{let s=this.context.inputTextureLayouts[o],d=(s.unpackedShape.length>0?s.unpackedShape:s.shape).length,c=`_${e}`;a[c]=new R(this.getValueFromSingle(e,d,s.width,s.height,!1),[`shapeUtils.indicesToOffset${c}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),c=c+"_T",a[c]=new R(this.getValueFromSingle(e,d,s.width,s.height,!0),[`shapeUtils.indicesToOffset${c}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),a}getValueFromSingle(a,e,o,s,d){let c=`_${a}`;d&&(c=c+"_T");let h=q$1(this.context.glContext.version);return`
        float ${c}(int m[${e}]) {
          int offset = indicesToOffset${c}(m);
          vec2 coords = offsetToCoords(offset, ${o}, ${s});
          float value = getColorAsFloat(${h.texture2D}(${a}, coords));
          return value;
        }
        `}getPackedValueFrom(a,e,o,s,d){let c=`_${a}_Pack`;d&&(c=c+"_T");let h=q$1(this.context.glContext.version);return`
        vec4 ${c}(int m[${e}]) {
          int offset = indicesToOffset_${a}(m);
          vec2 coords = offsetToCoords(offset, ${o}, ${s});
          return ${h.texture2D}(${a}, coords);
        }
        `}}}),po$1,np$1=E(()=>{Ht$1(),po$1=class gT extends ft{constructor(e){super(e)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new R(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new R(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let e=gT.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new R(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${e}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let e=gT.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new R(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${e}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let e=new ArrayBuffer(4),o=new Uint32Array(e),s=new Uint8Array(e);if(o[0]=3735928559,s[0]===239)return!0;if(s[0]===222)return!1;throw new Error("unknown endianness")}}}),ho$1,op$1=E(()=>{Ht$1(),xe(),ho$1=class extends ft{constructor(a){super(a)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let a=q$1(this.context.glContext.version);return{setFragColor:new R(`
        void setFragColor(float value) {
            ${a.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new R(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}}),mo$1,ip$1=E(()=>{Ht$1(),mo$1=class RS extends ft{constructor(e){super(e)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let e=this.context.outputTextureLayout.shape.length,o={};return this.context.programInfo.inputNames.forEach((s,d)=>{let c=this.context.inputTextureLayouts[d].unpackedShape;if(c.length<=e){let h=c.length,_=e-h,bt=`bcastIndices_${s}`,g="";for(let b=0;b<h;++b)g+=`
          realIndices[${b}] = int( mod(float(bcastedIndices[${_+b}]), ${c[b]}.0) );
          `;let j=`
        void ${bt} (int bcastedIndices[${e}], out int realIndices[${h}]) {
          ${g}
        }
        `;o[bt]=new R(j)}}),o}bcastMatmulIndex(){let e=this.context.outputTextureLayout.shape.length,o={};return this.context.programInfo.inputNames.forEach((s,d)=>{let c=this.context.inputTextureLayouts[d].shape;if(!(c.length<2||c.length>e)){let h=c.length,_=e-h,bt=`bcastMatmulIndices_${s}`,g="";for(let b=0;b<h-2;++b)g+=`
          realIndices[${b}] = int( mod(float(bcastedIndices[${_+b}]), ${c[b]}.0) );
          `;let j=`
        void ${bt}(int bcastedIndices[${e}], out int realIndices[${h}]) {
          ${g}
          realIndices[${h-1}] = bcastedIndices[${e-1}];
          realIndices[${h-2}] = bcastedIndices[${e-2}];
        }
        `;o[bt]=new R(j)}}),o}indicesToOffset(){let e={};return this.context.programInfo.inputNames.forEach((o,s)=>{let d=this.context.inputTextureLayouts[s].shape,c=this.context.inputTextureLayouts[s].strides,h=d.length,_=`indicesToOffset_${o}`;e[_]=new R(RS.indexToOffsetSingle(_,h,c)),_=`indicesToOffset_${o}_T`,e[_]=new R(RS.indexToOffsetSingle(_,h,c.slice().reverse()))}),e}static indexToOffsetSingle(e,o,s){let d="";for(let c=o-1;c>=0;--c)d+=`
        offset += indices[${c}] * ${s[c]};
        `;return`
      int ${e}(int indices[${o}]) {
        int offset = 0;
        ${d}
        return offset;
      }
      `}offsetToIndices(){let e={};return this.context.programInfo.inputNames.forEach((o,s)=>{let d=this.context.inputTextureLayouts[s].shape,c=this.context.inputTextureLayouts[s].strides,h=d.length,_=`offsetToIndices_${o}`;e[_]=new R(RS.offsetToIndicesSingle(_,h,c)),_=`offsetToIndices_${o}_T`,e[_]=new R(RS.offsetToIndicesSingle(_,h,c.slice().reverse()))}),e}static offsetToIndicesSingle(e,o,s){let d=[];for(let c=0;c<o-1;++c)d.push(`
      indices[${c}] = offset / ${s[c]};`),d.push(`
        offset -= indices[${c}] * ${s[c]};`);return d.push(`
      indices[${o-1}] = offset;`),`
      void ${e}(int offset, out int indices[${o}]) {
        ${d.join("")}
      }
      `}incrementIndices(){let e={};return this.context.programInfo.inputNames.forEach((o,s)=>{let d=this.context.inputTextureLayouts[s].shape,c=d.length,h=`incrementIndices_${o}`,_="";for(let g=0;g<c;++g)_+=`
        shape[${g}] = ${d[g]};`;let bt=`
        void ${h}(int axis, out int indices[${c}]) {
          int shape[${c}];
          ${_};
          for(int i = ${c} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;e[h]=new R(bt)}),e}}}),bo$1,ap$1=E(()=>{Ht$1(),bo$1=class extends ft{constructor(a){super(a)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let a=this.context.outputTextureLayout.shape.length,e={add:"+=",sub:"-=",mul:"*=",div:"/="},o={};for(let s in e){let d=`${s}Vec`,c="";for(let _=0;_<a;++_)c+=`
          dest[${_}] ${e[s]} src[${_}];
          `;let h=`
        void ${d}(int src[${a}], out int dest[${a}]) {
          ${c}
        }
        `;o[d]=new R(h)}return o}copyVec(){let a=this.context.outputTextureLayout.shape.length,e="";for(let s=0;s<a;++s)e+=`
        dest[${s}] = src[${s}];
        `;let o=`
      void copyVec(int src[${a}], out int dest[${a}]) {
        ${e}
      }
      `;return{copyVec:new R(o)}}setVecItem(){let a=this.context.outputTextureLayout.shape.length,e=`
        if(index < 0)
            index =${a} + index;
        if (index == 0)
            m[0] = value;
        `;for(let s=1;s<a-1;++s)e+=`
        else if (index == ${s})
            m[${s}] = value;
            `;e+=`
        else
            m[${a-1}] = value;
        `;let o=`
      void setVecItem(out int m[${a}], int index, int value) {
        ${e}
      }
        `;return{setVecItem:new R(o)}}getVecItem(){let a=this.context.outputTextureLayout.shape.length,e=`
        if(index < 0)
            index = ${a} + index;
        if (index == 0)
            return m[0];
      `;for(let s=1;s<a-1;++s)e+=`
        else if (index == ${s})
            return m[${s}];
      `;e+=`
        else
            return m[${a-1}];
        `;let o=`
      int getVecItem(int m[${a}], int index) {
        ${e}
      }
    `;return{getVecItem:new R(o)}}}}),qi$1,sp$1=E(()=>{rp$1(),np$1(),op$1(),ip$1(),ap$1(),qi$1={encoding:po$1,fragcolor:ho$1,vec:bo$1,shapeUtils:mo$1,coordinates:co$1}}),go$1,up$1=E(()=>{Ht$1(),ep$1(),sp$1(),xe(),go$1=class{constructor(a,e,o,s){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new eo$1(a,e,o,s),Object.keys(qi$1).forEach(c=>{let h=new qi$1[c](this.context);this.libs[c]=h});let d=this.glslLibRoutineDependencyGraph;for(let c in this.libs){let h=this.libs[c].getFunctions();for(let _ in h){let bt=c+"."+_,g;d[bt]?(g=d[bt],g.routineBody=h[_].routineBody):(g=new dn$1(bt,h[_].routineBody),d[bt]=g);let j=h[_].dependencies;if(j)for(let b=0;b<j.length;++b)if(d[j[b]])g.addDependency(d[j[b]]);else{let Et=new dn$1(j[b]);d[j[b]]=Et,g.addDependency(Et)}}}}preprocess(){let a=this.context.programInfo,e=a.shaderSource;return this.context.programInfo.hasMain||(e=`${e}
      ${Uu$1(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),e=Qc$1(e),`${Gu$1(this.context.glContext.version)}
    ${this.getUniforms(a.inputNames,a.variables)}
    ${this.getImports(e)}
    ${e}`}getImports(a){let e=this.selectGlslLibRoutinesToBeIncluded(a);if(e.length===0)return"";let o="";for(let s=0;s<e.length;++s)if(e[s].routineBody)o+=e[s].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${e[s].name}`);return o}selectGlslLibRoutinesToBeIncluded(a){let e=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(o=>{let s=o.split(".")[1];a.indexOf(s)!==-1&&e.push(this.glslLibRoutineDependencyGraph[o])}),to$1.returnOrderedNodes(e)}getUniforms(a,e){let o=[];if(a)for(let s of a)o.push(`uniform sampler2D ${s};`);if(e)for(let s of e)o.push(`uniform ${s.type} ${s.name}${s.arrayLength?`[${s.arrayLength}]`:""};`);return o.join(`
`)}}}),yo$1,lp$1=E(()=>{Tt(),at$1(),up$1(),xe(),yo$1=class{constructor(a,e,o){this.profiler=a,this.glContext=e,this.textureLayoutStrategy=o,this.repo=new Map,this.attributesBound=!1}getArtifact(a){return this.repo.get(a)}setArtifact(a,e){this.repo.set(a,e)}run(a,e,o){this.profiler.event("op",`ProgramManager.run ${a.programInfo.name??"unknown kernel"}`,()=>{let s=this.glContext.gl,d=a.program;s.useProgram(d);try{this.bindOutput(o),this.attributesBound||this.bindAttributes(a.attribLocations),this.bindUniforms(a.uniformLocations,a.programInfo.variables??[],e)}catch(c){throw ce.error("ProgramManager",a.programInfo.shaderSource),c}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(a=>this.glContext.deleteProgram(a.program))}build(a,e,o){return this.profiler.event("backend","ProgramManager.build",()=>{let s=new go$1(this.glContext,a,e,o),d=s.preprocess(),c=this.compile(d);return{programInfo:a,program:c,uniformLocations:this.getUniformLocations(c,s.context.programInfo.inputNames,s.context.programInfo.variables),attribLocations:this.getAttribLocations(c)}})}compile(a){if(!this.vertexShader){ce.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let s=Mu$1(this.glContext.version);this.vertexShader=this.glContext.compileShader(s,this.glContext.gl.VERTEX_SHADER)}Z.debug&&ce.verbose("ProrgramManager",`FragShader:
${a}
`);let e=this.glContext.compileShader(a,this.glContext.gl.FRAGMENT_SHADER),o=this.glContext.createProgram(this.vertexShader,e);return this.glContext.deleteShader(e),o}bindOutput(a){let e=a.width,o=a.height;ce.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${e}/${o}, shape=${a.shape}, type=${a.tensor.type}`),this.glContext.attachFramebuffer(a.texture,e,o)}bindAttributes(a){let e=a.position,o=a.textureCoord;this.glContext.setVertexAttributes(e,o),this.attributesBound=!0}bindUniforms(a,e,o){var c;let s=this.glContext.gl,d=0;for(let{name:h,type:_,location:bt,arrayLength:g}of a){let j=(c=e.find(b=>b.name===h))==null?void 0:c.data;if(_!=="sampler2D"&&!j)throw new Error(`variable '${h}' does not have data defined in program info`);switch(_){case"sampler2D":this.bindTexture(o[d],bt,d),d++;break;case"float":g?s.uniform1fv(bt,j):s.uniform1f(bt,j);break;case"int":g?s.uniform1iv(bt,j):s.uniform1i(bt,j);break;default:throw new Error(`Uniform not implemented: ${_}`)}}}bindTexture(a,e,o){this.glContext.bindTextureToUniform(a.texture,o,e)}getAttribLocations(a){return{position:this.getAttribLocation(a,"position"),textureCoord:this.getAttribLocation(a,"textureCoord")}}getUniformLocations(a,e,o){let s=[];if(e)for(let d of e)s.push({name:d,type:"sampler2D",location:this.getUniformLocation(a,d)});if(o)for(let d of o)s.push({...d,location:this.getUniformLocation(a,d.name)});return s}getUniformLocation(a,e){let o=this.glContext.gl.getUniformLocation(a,e);if(o===null)throw new Error(`Uniform ${e} not found.`);return o}getAttribLocation(a,e){return this.glContext.gl.getAttribLocation(a,e)}}}),To$1,fp$1=E(()=>{at$1(),cn$1(),To$1=class{constructor(a,e,o,s){this.glContext=a,this.layoutStrategy=e,this.profiler=o,this.config=s,this.pendingRead=new Map,s.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(a,e,o,s){let d=this.toEncoderType(a),c=this.glContext.getEncoder(d,e.channels||1,s);if(e.isPacked&&s===1)throw new Error("not implemented");let h=e.width,_=e.height,bt,g;if(this.config.reuseTextures){bt=`${h}x${_}_${c.format}_${c.internalFormat}_${c.textureType}`,g=this.inUseTextures.get(bt),g||(g=[],this.inUseTextures.set(bt,g));let b=this.idleTextures.get(bt);if(b&&b.length>0){let Et=b.pop();return g.push(Et),s===1&&this.glContext.updateTexture(Et,h,_,c,this.toTextureData(a,o)),Et}}ce.verbose("TextureManager",`Creating new texture of size ${e.width}x${e.height}`);let j=this.glContext.allocateTexture(h,_,c,this.toTextureData(a,o));return this.config.reuseTextures&&(g.push(j),this.textureLookup.set(j,bt)),j}readTexture(a,e,o){return o||(o=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let s=a.shape.reduce((c,h)=>c*h)*o,d=this.glContext.readTexture(a.texture,a.width,a.height,s,this.toEncoderType(e),o);return this.toTensorData(e,d)})}async readTextureAsync(a,e,o){let s=a.tensor.dataId;if(o||(o=1),this.pendingRead.has(s)){let d=this.pendingRead.get(s);return new Promise(c=>d==null?void 0:d.push(c))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(s,[]);let d=a.shape.reduce((bt,g)=>bt*g)*o;await this.glContext.createAndWaitForFence();let c=this.glContext.readTexture(a.texture,a.width,a.height,d,this.toEncoderType(e),o),h=this.toTensorData(e,c),_=this.pendingRead.get(s);return this.pendingRead.delete(s),_==null||_.forEach(bt=>bt(h)),h})}readUint8TextureAsFloat(a){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let e=a.shape.reduce((s,d)=>s*d),o=this.glContext.readTexture(a.texture,a.width,a.height,e*4,"byte",4);return new Float32Array(o.buffer,o.byteOffset,e)})}releaseTexture(a,e){let o;if(this.config.reuseTextures&&(o=this.textureLookup.get(a.texture),o)){e&&this.textureLookup.delete(o);let s=this.inUseTextures.get(o);if(s){let d=s.indexOf(a.texture);if(d!==-1){s.splice(d,1);let c=this.idleTextures.get(o);c||(c=[],this.idleTextures.set(o,c)),c.push(a.texture)}}}(!o||e)&&(ce.verbose("TextureManager",`Deleting texture of size ${a.width}x${a.height}`),this.glContext.deleteTexture(a.texture))}toTensorData(a,e){switch(a){case"int16":return e instanceof Int16Array?e:Int16Array.from(e);case"int32":return e instanceof Int32Array?e:Int32Array.from(e);case"int8":return e instanceof Int8Array?e:Int8Array.from(e);case"uint16":return e instanceof Uint16Array?e:Uint16Array.from(e);case"uint32":return e instanceof Uint32Array?e:Uint32Array.from(e);case"uint8":case"bool":return e instanceof Uint8Array?e:Uint8Array.from(e);case"float32":return e instanceof Float32Array?e:Float32Array.from(e);case"float64":return e instanceof Float64Array?e:Float64Array.from(e);default:throw new Error(`TensorData type ${a} is not supported`)}}toTextureData(a,e){if(e)return e instanceof Float32Array?e:new Float32Array(e)}toEncoderType(a){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}}),xo$1,cp$1=E(()=>{at$1(),Is$1(),rl$1(),Jc$1(),lp$1(),Hi(),fp$1(),xo$1=class{constructor(a,e){this.backend=a,this.context=e,this.layoutStrategy=new fo$1(a.glContext.maxTextureSize),this.programManager=new yo$1(this.context.profiler,a.glContext,this.layoutStrategy),this.textureManager=new To$1(a.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:a.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=a.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new Qn$1(this)}onGraphInitialized(a){let e=a.getValues().filter(o=>o.from===-1&&o.tensor).map(o=>o.tensor.dataId);this.initializers=new Set(e)}isInitializer(a){return this.initializers?this.initializers.has(a):!1}addInitializer(a){this.initializers.add(a)}getTextureData(a,e){return e?this.packedTextureDataCache.get(a):this.unpackedTextureDataCache.get(a)}setTextureData(a,e,o=!1){ce.verbose("WebGLSessionHandler","Storing Texture data in cache"),o?this.packedTextureDataCache.set(a,e):this.unpackedTextureDataCache.set(a,e)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(a=>this.textureManager.releaseTexture(a,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(a=>this.textureManager.releaseTexture(a,!0)),this.unpackedTextureDataCache=new Map}resolve(a,e,o){let s=Os$1(a,e,Kc$1);return{impl:s.opImpl,context:s.opInit?s.opInit(a,o):a}}}});function Xb(a){let e=0;for(;e<a.length&&a[e]();++e);return e-1}var bn$1,pp$1=E(()=>{Tt(),cn$1(),cn$1(),kt(),bn$1=class{constructor(a,e){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=a,this.version=e,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(a,e,o,s){let d=this.gl,c=d.createTexture();d.bindTexture(d.TEXTURE_2D,c),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MIN_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_MAG_FILTER,d.NEAREST),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_S,d.CLAMP_TO_EDGE),d.texParameteri(d.TEXTURE_2D,d.TEXTURE_WRAP_T,d.CLAMP_TO_EDGE);let h=s?o.encode(s,a*e):null;return d.texImage2D(d.TEXTURE_2D,0,o.internalFormat,a,e,0,o.format,o.textureType,h),this.checkError(),c}updateTexture(a,e,o,s,d){let c=this.gl;c.bindTexture(c.TEXTURE_2D,a);let h=s.encode(d,e*o);c.texSubImage2D(c.TEXTURE_2D,0,0,0,e,o,s.format,s.textureType,h),this.checkError()}attachFramebuffer(a,e,o){let s=this.gl;s.bindTexture(s.TEXTURE_2D,a),s.bindFramebuffer(s.FRAMEBUFFER,this.framebuffer),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,a,0),this.checkError(),s.viewport(0,0,e,o),s.scissor(0,0,e,o)}readTexture(a,e,o,s,d,c){let h=this.gl;c||(c=1),this.frameBufferBound||this.attachFramebuffer(a,e,o);let _=this.getEncoder(d,c),bt=_.allocate(e*o);return h.bindTexture(h.TEXTURE_2D,a),h.framebufferTexture2D(h.FRAMEBUFFER,h.COLOR_ATTACHMENT0,h.TEXTURE_2D,a,0),h.readPixels(0,0,e,o,h.RGBA,_.textureType,bt),this.checkError(),_.decode(bt,s)}isFramebufferReady(){return!0}getActiveTexture(){let a=this.gl;return`TEXTURE${a.getParameter(this.gl.ACTIVE_TEXTURE)-a.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(a,e){let o=this.gl;o.vertexAttribPointer(a,3,o.FLOAT,!1,20,0),o.enableVertexAttribArray(a),e!==-1&&(o.vertexAttribPointer(e,2,o.FLOAT,!1,20,12),o.enableVertexAttribArray(e)),this.checkError()}createProgram(a,e){let o=this.gl,s=o.createProgram();return o.attachShader(s,a),o.attachShader(s,e),o.linkProgram(s),s}compileShader(a,e){let o=this.gl,s=o.createShader(e);if(!s)throw new Error(`createShader() returned null with type ${e}`);if(o.shaderSource(s,a),o.compileShader(s),o.getShaderParameter(s,o.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${o.getShaderInfoLog(s)}
Shader source:
${a}`);return s}deleteShader(a){this.gl.deleteShader(a)}bindTextureToUniform(a,e,o){let s=this.gl;s.activeTexture(s.TEXTURE0+e),this.checkError(),s.bindTexture(s.TEXTURE_2D,a),this.checkError(),s.uniform1i(o,e),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(Z.debug){let a=this.gl,e=a.getError(),o="";switch(e){case a.NO_ERROR:return;case a.INVALID_ENUM:o="INVALID_ENUM";break;case a.INVALID_VALUE:o="INVALID_VALUE";break;case a.INVALID_OPERATION:o="INVALID_OPERATION";break;case a.INVALID_FRAMEBUFFER_OPERATION:o="INVALID_FRAMEBUFFER_OPERATION";break;case a.OUT_OF_MEMORY:o="OUT_OF_MEMORY";break;case a.CONTEXT_LOST_WEBGL:o="CONTEXT_LOST_WEBGL";break;default:o=`Unknown WebGL Error: ${e.toString(16)}`}throw new Error(o)}}deleteTexture(a){this.gl.deleteTexture(a)}deleteProgram(a){this.gl.deleteProgram(a)}getEncoder(a,e,o=0){if(this.version===2)return new Jn$1(this.gl,e);switch(a){case"float":return o===1||this.isRenderFloat32Supported?new fn$1(this.gl,e):new fn$1(this.gl,e,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new Zn$1(this.gl,e);default:throw new Error(`Invalid dataType: ${a}`)}}clearActiveTextures(){let a=this.gl;for(let e=0;e<this.maxTextureImageUnits;++e)a.activeTexture(a.TEXTURE0+e),a.bindTexture(a.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let a=this.gl;a.bindFramebuffer(a.FRAMEBUFFER,null),a.deleteFramebuffer(this.framebuffer),a.bindBuffer(a.ARRAY_BUFFER,null),a.deleteBuffer(this.vertexbuffer),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,null),a.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let a=this.gl,e=a.createBuffer();if(!e)throw new Error("createBuffer() returned null");let o=this.createDefaultGeometry();return a.bindBuffer(a.ARRAY_BUFFER,e),a.bufferData(a.ARRAY_BUFFER,o,a.STATIC_DRAW),this.checkError(),e}createFramebuffer(){let a=this.gl.createFramebuffer();if(!a)throw new Error("createFramebuffer returned null");return a}queryVitalParameters(){let a=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=a.getParameter(a.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let a=this.gl,e=a.createTexture();a.bindTexture(a.TEXTURE_2D,e);let o=this.version===2?a.RGBA32F:a.RGBA;a.texImage2D(a.TEXTURE_2D,0,o,1,1,0,a.RGBA,a.FLOAT,null);let s=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,s),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e,0);let d=a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE;return a.bindTexture(a.TEXTURE_2D,null),a.bindFramebuffer(a.FRAMEBUFFER,null),a.deleteTexture(e),a.deleteFramebuffer(s),d}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let a=this.gl,e,o,s,d,c;try{e=a.createTexture(),o=a.createFramebuffer(),a.bindTexture(a.TEXTURE_2D,e);let h=this.version===2?a.RGBA32F:a.RGBA;return a.texImage2D(a.TEXTURE_2D,0,h,1,1,0,a.RGBA,a.FLOAT,null),a.bindFramebuffer(a.FRAMEBUFFER,o),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e,0),a.enable(a.BLEND),s=a.createShader(a.VERTEX_SHADER),!s||(a.shaderSource(s,"void main(){}"),a.compileShader(s),d=a.createShader(a.FRAGMENT_SHADER),!d)||(a.shaderSource(d,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),a.compileShader(d),c=a.createProgram(),!c)?!1:(a.attachShader(c,s),a.attachShader(c,d),a.linkProgram(c),a.useProgram(c),a.drawArrays(a.POINTS,0,1),a.getError()===a.NO_ERROR)}finally{a.disable(a.BLEND),c&&a.deleteProgram(c),s&&a.deleteShader(s),d&&a.deleteShader(d),o&&(a.bindFramebuffer(a.FRAMEBUFFER,null),a.deleteFramebuffer(o)),e&&(a.bindTexture(a.TEXTURE_2D,null),a.deleteTexture(e))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let a=this.gl,e=this.disjointTimerQueryWebgl2Extension,o=a.createQuery();return a.beginQuery(e.TIME_ELAPSED_EXT,o),o}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let a=this.gl,e=this.disjointTimerQueryWebgl2Extension;a.endQuery(e.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(a){let e=!1,o=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let s=this.gl,d=this.disjointTimerQueryWebgl2Extension;e=s.getQueryParameter(a,s.QUERY_RESULT_AVAILABLE),o=s.getParameter(d.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return e&&!o}getTimerResult(a){let e=0;if(this.version===2){let o=this.gl;e=o.getQueryParameter(a,o.QUERY_RESULT),o.deleteQuery(a)}else throw new Error("WebGL1 profiling currently not supported");return e/1e6}async waitForQueryAndGetTime(a){return await gi$1(()=>this.isTimerResultAvailable(a)),this.getTimerResult(a)}async createAndWaitForFence(){let a=this.createFence(this.gl);return this.pollFence(a)}createFence(a){let e,o=a,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);return a.flush(),s===null?e=()=>!0:e=()=>{let d=o.clientWaitSync(s,0,0);return d===o.ALREADY_SIGNALED||d===o.CONDITION_SATISFIED},{query:s,isFencePassed:e}}async pollFence(a){return new Promise(e=>{this.addItemToPoll(()=>a.isFencePassed(),()=>e())})}pollItems(){let a=Xb(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=a;++e){let{resolveFn:o}=this.itemsToPoll[e];o()}this.itemsToPoll=this.itemsToPoll.slice(a+1)}async addItemToPoll(a,e){this.itemsToPoll.push({isDoneFn:a,resolveFn:e}),!(this.itemsToPoll.length>1)&&await gi$1(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function ji$1(a){let e;if((!a||a==="webgl2")&&"webgl2"in zr?e=zr.webgl2:(!a||a==="webgl")&&"webgl"in zr&&(e=zr.webgl),!e)try{let s=Jb();e=dp$1(s,a)}catch{let s=Kb();e=dp$1(s,a)}a=a||e.version===1?"webgl":"webgl2";let o=e.gl;return zr[a]=e,o.isContextLost()?(delete zr[a],ji$1(a)):(o.disable(o.DEPTH_TEST),o.disable(o.STENCIL_TEST),o.disable(o.BLEND),o.disable(o.DITHER),o.disable(o.POLYGON_OFFSET_FILL),o.disable(o.SAMPLE_COVERAGE),o.enable(o.SCISSOR_TEST),o.enable(o.CULL_FACE),o.cullFace(o.BACK),e)}function dp$1(a,e){let o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},s,d=o;if((!e||e==="webgl2")&&(s=a.getContext("webgl2",d),s))try{return new bn$1(s,2)}catch(c){ce.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${c}`)}if((!e||e==="webgl")&&(s=a.getContext("webgl",d)||a.getContext("experimental-webgl",d),s))try{return new bn$1(s,1)}catch(c){ce.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${c}`)}throw new Error("WebGL is not supported")}function Kb(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let a=document.createElement("canvas");return a.width=1,a.height=1,a}function Jb(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var zr,hp$1=E(()=>{at$1(),pp$1(),zr={}}),wo$1,mp$1=E(()=>{Tt(),at$1(),cp$1(),hp$1(),wo$1=class{get contextId(){return Z.webgl.contextId}set contextId(a){Z.webgl.contextId=a}get matmulMaxBatchSize(){return Z.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(a){Z.webgl.matmulMaxBatchSize=a}get textureCacheMode(){return Z.webgl.textureCacheMode}set textureCacheMode(a){Z.webgl.textureCacheMode=a}get pack(){return Z.webgl.pack}set pack(a){Z.webgl.pack=a}get async(){return Z.webgl.async}set async(a){Z.webgl.async=a}initialize(){try{return this.glContext=ji$1(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),ce.setWithEnv(Z),Z.webgl.context||Object.defineProperty(Z.webgl,"context",{value:this.glContext.gl}),ce.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(a){return ce.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${a}`),!1}}createSessionHandler(a){return new xo$1(this,a)}dispose(){this.glContext.dispose()}}});async function Yi$1(a){if(a){let e=typeof a=="string"?[a]:a;for(let o of e){let s=bp$1.get(o);if(s)return s;let d=await Qb(o);if(d)return d}}else return Yi$1(["webgl"]);throw new Error("no available backend to use")}async function Qb(a){let e=Zb;if(typeof e[a]<"u"&&eg(e[a])){let o=e[a],s=o.initialize();if(typeof s=="object"&&"then"in s&&(s=await s),s)return bp$1.set(a,o),o}}function eg(a){let e=a;return"initialize"in e&&typeof e.initialize=="function"&&"createSessionHandler"in e&&typeof e.createSessionHandler=="function"&&"dispose"in e&&typeof e.dispose=="function"}var bp$1,Zb,gp$1=E(()=>{mp$1(),bp$1=new Map,Zb={webgl:new wo$1}}),Xi$1,vo$1,yp$1=E(()=>{at$1(),Xi$1=class{constructor(a,e){this.op=a,this.node=e}},vo$1=class{constructor(a,e,o){this.graph=a,this.profiler=o,this.initialize(e)}initialize(a){this.profiler.event("session","ExecutionPlan.initialize",()=>{let e=this.graph.getNodes();if(e.length!==a.length)throw new Error("The size of nodes and OPs do not match.");this._ops=a.map((o,s)=>new Xi$1(o,e[s])),this.reset(),this._starter=[],this._ops.forEach((o,s)=>{let d=!0;for(let c of o.node.inputs)if(!this._values[c]&&this.graph.getInputIndices().indexOf(c)===-1){d=!1;break}d&&this._starter.push(s)})})}reset(){this._values=this.graph.getValues().map(a=>a.tensor)}async execute(a,e){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let o=a.createInferenceHandler(),s=this.graph.getInputIndices();if(e.length!==s.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${e.length} expected: ${s.length}`);e.forEach((g,j)=>{let b=s[j];this._values[b]=g});let d=this._starter.slice(0),c=this.graph.getValues(),h=this.graph.getNodes(),_=0;for(;_<d.length;){let g=d[_++],j=this._ops[g],b=j.node.inputs.map(er=>this._values[er]);if(b.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${j.node}`);let Et=b;ce.verbose("ExecPlan",`Runing op:${j.node.name} (${Et.map((er,Hn)=>`'${j.node.inputs[Hn]}': ${er.type}[${er.dims.join(",")}]`).join(", ")})`);let It=await this.profiler.event("node",j.node.name,async()=>j.op.impl(o,Et,j.op.context));if(It.length!==j.node.outputs.length)throw new Error("the size of output does not match model definition.");It.forEach((er,Hn)=>{let Qt=j.node.outputs[Hn];if(this._values[Qt])throw new Error(`output [${Qt}] already has value: op:${j.node.name}`);this._values[Qt]=er});let zt=new Set;It.forEach((er,Hn)=>{let Qt=j.node.outputs[Hn];for(let cr of c[Qt].to){let fr=h[cr],jr=!0;for(let e0 of fr.inputs)if(!this._values[e0]){jr=!1;break}jr&&zt.add(cr)}}),d.push(...zt)}let bt=[];for(let g=0;g<this.graph.getOutputIndices().length;g++){let j=this.graph.getOutputIndices()[g],b=this._values[j];if(b===void 0)throw new Error(`required output [${j}] does not have value`);j===0?await b.getData():b.data,bt.push(b)}return ce.verbose("ExecPlan","disposing of inferenceHandler"),o.dispose(),bt})}}}),oe,dt$1,gn$1,Tp$1=E(()=>{nn$1(),oe=Er$1($r()),br(),fe(),dt$1=W.experimental.fbs,gn$1=class OS{constructor(e){if(this._attributes=new Map,e!=null){for(let o of e)o instanceof oe.onnx.AttributeProto?this._attributes.set(o.name,[OS.getValue(o),OS.getType(o)]):o instanceof dt$1.Attribute&&this._attributes.set(o.name(),[OS.getValue(o),OS.getType(o)]);if(this._attributes.size<e.length)throw new Error("duplicated attribute names")}}set(e,o,s){this._attributes.set(e,[s,o])}delete(e){this._attributes.delete(e)}getFloat(e,o){return this.get(e,"float",o)}getInt(e,o){return this.get(e,"int",o)}getString(e,o){return this.get(e,"string",o)}getTensor(e,o){return this.get(e,"tensor",o)}getFloats(e,o){return this.get(e,"floats",o)}getInts(e,o){return this.get(e,"ints",o)}getStrings(e,o){return this.get(e,"strings",o)}getTensors(e,o){return this.get(e,"tensors",o)}get(e,o,s){let d=this._attributes.get(e);if(d===void 0){if(s!==void 0)return s;throw new Error(`required attribute not found: ${e}`)}if(d[1]!==o)throw new Error(`type mismatch: expected ${o} but got ${d[1]}`);return d[0]}static getType(e){let o=e instanceof oe.onnx.AttributeProto?e.type:e.type();switch(o){case oe.onnx.AttributeProto.AttributeType.FLOAT:return"float";case oe.onnx.AttributeProto.AttributeType.INT:return"int";case oe.onnx.AttributeProto.AttributeType.STRING:return"string";case oe.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case oe.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case oe.onnx.AttributeProto.AttributeType.INTS:return"ints";case oe.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case oe.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${oe.onnx.AttributeProto.AttributeType[o]}`)}}static getValue(e){let o=e instanceof oe.onnx.AttributeProto?e.type:e.type();if(o===oe.onnx.AttributeProto.AttributeType.GRAPH||o===oe.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let s=this.getValueNoCheck(e);if(o===oe.onnx.AttributeProto.AttributeType.INT&&nt$1.isLong(s))return nt$1.longToNumber(s);if(o===oe.onnx.AttributeProto.AttributeType.INTS){let d=s,c=new Array(d.length);for(let h=0;h<d.length;h++){let _=d[h];c[h]=nt$1.longToNumber(_)}return c}if(o===oe.onnx.AttributeProto.AttributeType.TENSOR)return e instanceof oe.onnx.AttributeProto?Ce.fromProto(s):Ce.fromOrtTensor(s);if(o===oe.onnx.AttributeProto.AttributeType.TENSORS){if(e instanceof oe.onnx.AttributeProto)return s.map(d=>Ce.fromProto(d));if(e instanceof dt$1.Attribute)return s.map(d=>Ce.fromOrtTensor(d))}return o===oe.onnx.AttributeProto.AttributeType.STRING&&e instanceof oe.onnx.AttributeProto?ln$1(s):o===oe.onnx.AttributeProto.AttributeType.STRINGS&&e instanceof oe.onnx.AttributeProto?s.map(ln$1):s}static getValueNoCheck(e){return e instanceof oe.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(e):this.getValueNoCheckFromOrtFormat(e)}static getValueNoCheckFromOnnxFormat(e){switch(e.type){case oe.onnx.AttributeProto.AttributeType.FLOAT:return e.f;case oe.onnx.AttributeProto.AttributeType.INT:return e.i;case oe.onnx.AttributeProto.AttributeType.STRING:return e.s;case oe.onnx.AttributeProto.AttributeType.TENSOR:return e.t;case oe.onnx.AttributeProto.AttributeType.GRAPH:return e.g;case oe.onnx.AttributeProto.AttributeType.FLOATS:return e.floats;case oe.onnx.AttributeProto.AttributeType.INTS:return e.ints;case oe.onnx.AttributeProto.AttributeType.STRINGS:return e.strings;case oe.onnx.AttributeProto.AttributeType.TENSORS:return e.tensors;case oe.onnx.AttributeProto.AttributeType.GRAPHS:return e.graphs;default:throw new Error(`unsupported attribute type: ${oe.onnx.AttributeProto.AttributeType[e.type]}`)}}static getValueNoCheckFromOrtFormat(e){switch(e.type()){case dt$1.AttributeType.FLOAT:return e.f();case dt$1.AttributeType.INT:return e.i();case dt$1.AttributeType.STRING:return e.s();case dt$1.AttributeType.TENSOR:return e.t();case dt$1.AttributeType.GRAPH:return e.g();case dt$1.AttributeType.FLOATS:return e.floatsArray();case dt$1.AttributeType.INTS:{let o=[];for(let s=0;s<e.intsLength();s++)o.push(e.ints(s));return o}case dt$1.AttributeType.STRINGS:{let o=[];for(let s=0;s<e.stringsLength();s++)o.push(e.strings(s));return o}case dt$1.AttributeType.TENSORS:{let o=[];for(let s=0;s<e.tensorsLength();s++)o.push(e.tensors(s));return o}default:throw new Error(`unsupported attribute type: ${dt$1.AttributeType[e.type()]}`)}}}}),Ji$1,_o$1,Zi$1,Rt,Oo$1,Ki$1,xp$1=E(()=>{Tp$1(),nn$1(),Ji$1=Er$1($r()),br(),fe(),_o$1=W.experimental.fbs,Zi$1={from:(a,e)=>new Ki$1(a,e)},Rt=class{constructor(a){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,a&&(this.type=Ve.tensorValueTypeFromProto(a.type.tensorType))}get from(){return this._from}get to(){return this._to}},Oo$1=class{constructor(a,e){a instanceof Ji$1.onnx.NodeProto?(this.name=a.name,this.opType=a.opType,this.attributes=new gn$1(a.attribute)):a instanceof _o$1.Node&&(this.name=e??a.name(),this.opType=a.opType(),this.attributes=new gn$1(Ve.tensorAttributesFromORTFormat(a))),this.inputs=[],this.outputs=[],this.executeNode=!0}},Ki$1=class{constructor(a,e){if(!a)throw new TypeError("graph is empty");this.buildGraph(a),this.transformGraph(e),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(a){if(a instanceof Ji$1.onnx.GraphProto)this.buildGraphFromOnnxFormat(a);else if(a instanceof _o$1.Graph)this.buildGraphFromOrtFormat(a);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(a){let e=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let o=new Map;if(!a.input)throw new Error("missing information in graph: input");let s=[];for(let d of a.input){if(e.has(d.name))throw new Error(`duplicated input name: ${d.name}`);let c=this._allData.push(new Rt(d))-1;e.set(d.name,c),s.push(d.name)}if(!a.initializer)throw new Error("missing information in graph: initializer");for(let d of a.initializer){let c=e.get(d.name);if(c===void 0){let h=new Rt;h.type={shape:{dims:Ve.tensorDimsFromProto(d.dims)},tensorType:Ve.tensorDataTypeFromProto(d.dataType)},c=this._allData.push(h)-1,e.set(d.name,c)}this._allData[c]._from=-1,this._allData[c].tensor=Ce.fromProto(d)}for(let d=0;d<this._allData.length;d++)this._allData[d].tensor||(this._allInputIndices.push(d),this._allInputNames.push(s[d]));if(!a.output)throw new Error("missing information in graph: output");for(let d of a.output){if(e.has(d.name))throw new Error(`duplicated output name: ${d.name}`);let c=this._allData.push(new Rt(d))-1;e.set(d.name,c),this._allOutputIndices.push(c),this._allOutputNames.push(d.name)}if(!a.node)throw new Error("missing information in graph: node");for(let d of a.node){if(!d.name)for(let h=0;;h++){let _=`unnamed_${d.opType}_${h}`;if(!o.has(_)){d.name=_;break}}if(o.has(d.name))throw new Error(`duplicated node name: ${d.name}`);let c=this._nodes.push(new Oo$1(d))-1;o.set(d.name,c)}for(let d=0;d<this._nodes.length;d++){let c=this._nodes[d],h=a.node[d];if(!h.output)throw new Error(`missing output for node: ${h.name}`);for(let _ of h.output){let bt=e.get(_);if(typeof bt>"u"&&(bt=this._allData.push(new Rt)-1,e.set(_,bt)),c.outputs.push(bt),this._allData[bt]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${bt}`);if(this._allData[bt]._from=d,h.opType==="Constant"){if(!h.attribute||h.attribute.length!==1||!h.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!h.output||h.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");c.outputs.pop(),c.executeNode=!1,this._allData[bt]._from=-1,this._allData[bt].tensor=Ce.fromProto(h.attribute[0].t)}}}for(let d=0;d<this._nodes.length;d++){let c=this._nodes[d],h=a.node[d];if(!h.input)throw new Error(`missing input for node: ${h.name}`);for(let _ of h.input){let bt=e.get(_);if(typeof bt>"u"){if(_===""&&(h.input.length===3||h.input.length===4)&&h.opType==="Resize")continue;throw new Error(`unrecognized input '${_}' for node: ${h.name}`)}c.inputs.push(bt),this._allData[bt]._to.push(d)}}return!0}buildGraphFromOrtFormat(a){var d,c,h;let e=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let o=new Map,s=[];for(let _=0;_<a.inputsLength();_++){let bt=a.inputs(_);if(e.has(bt))throw new Error(`duplicated input name: ${bt}`);for(let g=0;g<a.nodeArgsLength();g++)if(((d=a.nodeArgs(g))==null?void 0:d.name())===bt){let j=new Rt;if(((h=(c=a.nodeArgs(g))==null?void 0:c.type())==null?void 0:h.valueType())!==_o$1.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let b=a.nodeArgs(g).type().value(new _o$1.TensorTypeAndShape),Et=Ve.tensorDataTypeFromProto(b.elemType()),It=b.shape(),zt=[];for(let Hn=0;Hn<It.dimLength();Hn++)zt.push(nt$1.longToNumber(It.dim(Hn).value().dimValue()));j.type={shape:{dims:zt},tensorType:Et};let er=this._allData.push(j)-1;e.set(bt,er),s.push(bt)}}for(let _=0;_<a.initializersLength();_++){let bt=a.initializers(_),g=e.get(bt.name());if(g===void 0){let j=new Rt,b=Ve.tensorDimsFromORTFormat(bt),Et=Ve.tensorDataTypeFromProto(bt.dataType());j.type={shape:{dims:b},tensorType:Et},g=this._allData.push(j)-1,e.set(bt.name(),g)}this._allData[g]._from=-1,this._allData[g].tensor=Ce.fromOrtTensor(bt)}for(let _=0;_<this._allData.length;_++)this._allData[_].tensor||(this._allInputIndices.push(_),this._allInputNames.push(s[_]));for(let _=0;_<a.outputsLength();_++){let bt=a.outputs(_);if(e.has(bt))throw new Error(`duplicated output name: ${bt}`);let g=this._allData.push(new Rt)-1;e.set(bt,g),this._allOutputIndices.push(g),this._allOutputNames.push(bt)}if(!a.nodes)throw new Error("missing information in graph: node");for(let _=0;_<a.nodesLength();_++){let bt=a.nodes(_),g=bt.name();if(!g)for(let b=0;g=`unnamed_${bt.opType()}_${b}`,!!o.has(g);b++);if(o.has(g))throw new Error(`duplicated node name: ${g}`);let j=this._nodes.push(new Oo$1(bt,g))-1;o.set(g,j)}for(let _=0;_<this._nodes.length;_++){let bt=this._nodes[_],g=a.nodes(_);if(g==null)throw new Error(`No node exists at index ${_}`);if((g==null?void 0:g.outputsLength())===0)throw new Error(`missing output for node: ${g.name}`);for(let j=0;j<(g==null?void 0:g.outputsLength());j++){let b=g==null?void 0:g.outputs(j),Et=e.get(b);if(typeof Et>"u"&&(Et=this._allData.push(new Rt)-1,e.set(b,Et)),bt.outputs.push(Et),this._allData[Et]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${Et}`);if(this._allData[Et]._from=_,g.opType()==="Constant"){if(g.attributesLength()!==1||!g.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(g.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");bt.outputs.pop(),bt.executeNode=!1,this._allData[Et]._from=-1,this._allData[Et].tensor=Ce.fromOrtTensor(g.attributes(0).t())}}}for(let _=0;_<this._nodes.length;_++){let bt=this._nodes[_],g=a.nodes(_);if(g.inputsLength()===0)throw new Error(`missing input for node: ${g.name}`);for(let j=0;j<g.inputsLength();j++){let b=g.inputs(j),Et=e.get(b);if(typeof Et>"u")throw new Error(`unrecognized input '${b}' for node: ${g.name()}`);bt.inputs.push(Et),this._allData[Et]._to.push(_)}}}checkIsAcyclic(){let a=new Set;this._allInputIndices.forEach(s=>{this._allData[s]._to.forEach(d=>{a.add(d)})});let e=Array.from(a),o=new Array(this._nodes.length).fill("white");for(;e.length>0;){let s=e.pop();o[s]==="gray"?o[s]="black":(e.push(s),o[s]="gray",this._nodes[s].outputs.forEach(d=>{let c=this._allData[d];if(typeof c.tensor<"u")throw new Error("node outputs should not be initialized");if(c._from!==s)throw new Error("from property of the Value object doesn't match index of Node being processed");c._to.forEach(h=>{if(o[h]==="gray")throw new Error("model graph is cyclic");o[h]==="white"&&e.push(h)})}))}}transformGraph(a){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),a&&a.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let a=0,e=new Array(this._nodes.length,0),o=0;for(let s=0;s<this._nodes.length;s++)e[s]=o,this._nodes[s].executeNode?(o!==s&&(this._nodes[o]=this._nodes[s]),o++):this._nodes[s].outputs.forEach(d=>{this._allData[d]._from=-2});this._nodes.splice(o,this._nodes.length-o);for(let s=0;s<this._allData.length;s++){let d=this._allData[s];d._from!==void 0&&d._from!==-1&&d._from!==-2&&(d._from=e[d._from]);for(let c=0;c<d._to.length;c++)if(d._to[c]>=0)d._to[c]=e[d._to[c]];else throw new Error("Trying to update a removed node")}a=0;for(let s=0;s<this._allData.length;s++){if(this._allData[s].from===-2&&this._allOutputIndices.indexOf(s+a)===-1){a++,this._allData.splice(s,1),s--;continue}if(a>0){let d=-1;this._allData[s].from!==void 0&&this._allData[s].from!==-1?(d=this._nodes[this._allData[s].from].outputs.indexOf(s+a),d!==-1&&(this._nodes[this._allData[s].from].outputs[d]=s)):(d=this._allInputIndices.indexOf(s+a),d!==-1&&(this._allInputIndices[d]=s)),this._allData[s].to.forEach(c=>{d=this._nodes[c].inputs.indexOf(s+a),d!==-1&&(this._nodes[c].inputs[d]=s)}),this._allData[s].to.length===0&&(d=this._allOutputIndices.indexOf(s+a),d!==-1&&(this._allOutputIndices[d]=s))}}}deleteNode(a){let e=this._nodes[a];if(e.outputs.length>1){for(let h=1;h<e.outputs.length;h++)if(this._allData[e.outputs[h]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}e.executeNode=!1;let o=e.inputs[0],s=e.outputs[0],d=this._allData[s].to;for(let h=0;h<e.inputs.length;h++){let _=this._allData[e.inputs[h]].to.indexOf(a);if(_===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[e.inputs[h]].to.splice(_,1)}this._allData[s]._to=[];let c=this._allOutputIndices.indexOf(s);if(c!==-1&&(this._allOutputIndices[c]=o),d&&d.length>0)for(let h of d){let _=this._nodes[h].inputs.indexOf(s);if(_===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[h].inputs[_]=o,this._allData[o].to.push(h)}}removeAllDropoutNodes(){let a=0;for(let e of this._nodes){if(e.opType==="Dropout"){if(e.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(e.outputs.length!==1&&e.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(e.outputs.length===2&&this._allData[e.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(a)}a++}}removeAllIdentityNodes(){let a=0;for(let e of this._nodes)e.opType==="Identity"&&this.deleteNode(a),a++}isActivation(a){switch(a.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let a of this._nodes)if(a.opType==="Conv"){let e=this._allData[a.outputs[0]]._to;if(e.length===1&&this.isActivation(this._nodes[e[0]])){let o=this._nodes[e[0]];if(o.opType==="Clip")if(o.inputs.length===1)try{a.attributes.set("activation_params","floats",[o.attributes.getFloat("min"),o.attributes.getFloat("max")])}catch{a.attributes.set("activation_params","floats",[hr,mr])}else if(o.inputs.length>=3&&this._allData[o.inputs[1]].tensor!==void 0&&this._allData[o.inputs[2]].tensor!==void 0)a.attributes.set("activation_params","floats",[this._allData[o.inputs[1]].tensor.floatData[0],this._allData[o.inputs[2]].tensor.floatData[0]]);else continue;a.attributes.set("activation","string",o.opType),this.deleteNode(e[0])}}}}}),wp$1,tg,Io$1,vp$1=E(()=>{Wn(),xp$1(),nn$1(),wp$1=Er$1($r()),fe(),tg=W.experimental.fbs,Io$1=class{constructor(){}load(a,e,o){if(!o)try{this.loadFromOnnxFormat(a,e);return}catch(s){if(o!==void 0)throw s}this.loadFromOrtFormat(a,e)}loadFromOnnxFormat(a,e){let o=wp$1.onnx.ModelProto.decode(a);if(nt$1.longToNumber(o.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=o.opsetImport.map(s=>({domain:s.domain,version:nt$1.longToNumber(s.version)})),this._graph=Zi$1.from(o.graph,e)}loadFromOrtFormat(a,e){let o=new O.ByteBuffer(a),s=tg.InferenceSession.getRootAsInferenceSession(o).model();if(nt$1.longToNumber(s.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let d=0;d<s.opsetImportLength();d++){let c=s.opsetImport(d);this._opsets.push({domain:c==null?void 0:c.domain(),version:nt$1.longToNumber(c.version())})}this._graph=Zi$1.from(s.graph(),e)}get graph(){return this._graph}get opsets(){return this._opsets}}}),So$1,_p=E(()=>{gp$1(),yp$1(),at$1(),vp$1(),So$1=class{constructor(a={}){this._initialized=!1,this.backendHint=a.backendHint,this.profiler=zn$1.create(a.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(a,e,o){await this.profiler.event("session","Session.loadModel",async()=>{let s=await Yi$1(this.backendHint);if(this.sessionHandler=s.createSessionHandler(this.context),this._model=new Io$1,typeof a=="string"){let d=a.endsWith(".ort");if(typeof process<"u"&&process.versions&&process.versions.node){let c=await(void 0)(a);this.initialize(c,d)}else{let c=await(await fetch(a)).arrayBuffer();this.initialize(new Uint8Array(c),d)}}else if(ArrayBuffer.isView(a))this.initialize(a);else{let d=new Uint8Array(a,e||0,o||a.byteLength);this.initialize(d)}})}initialize(a,e){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let o=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(a,o,e),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new vo$1(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(a){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let e=this.normalizeAndValidateInputs(a),o=await this._executionPlan.execute(this.sessionHandler,e);return this.createOutput(o)})}normalizeAndValidateInputs(a){let e=this._model.graph.getInputNames();if(Array.isArray(a)){if(a.length!==e.length)throw new Error(`incorrect input array length: expected ${e.length} but got ${a.length}`)}else{if(a.size!==e.length)throw new Error(`incorrect input map size: expected ${e.length} but got ${a.size}`);let o=new Array(a.size),s=0;for(let d=0;d<e.length;++d){let c=a.get(e[d]);if(!c)throw new Error(`missing input tensor for: '${name}'`);o[s++]=c}a=o}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let o=this._model.graph.getInputIndices(),s=this._model.graph.getValues(),d=new Array(o.length);for(let c=0;c<o.length;++c){let h=s[o[c]];d[c]=h.type.shape.dims,this.context.graphInputTypes.push(h.type.tensorType),this.context.graphInputDims.push(a[c].dims)}this.validateInputTensorDims(d,a,!0)}else this.validateInputTensorDims(this.context.graphInputDims,a,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,a),a}validateInputTensorTypes(a,e){for(let o=0;o<e.length;o++){let s=a[o],d=e[o].type;if(s!==d)throw new Error(`input tensor[${o}] check failed: expected type '${s}' but got ${d}`)}}validateInputTensorDims(a,e,o){for(let s=0;s<e.length;s++){let d=a[s],c=e[s].dims;if(!this.compareTensorDims(d,c,o))throw new Error(`input tensor[${s}] check failed: expected shape '[${d.join(",")}]' but got [${c.join(",")}]`)}}compareTensorDims(a,e,o){if(a.length!==e.length)return!1;for(let s=0;s<a.length;++s)if(a[s]!==e[s]&&(!o||a[s]!==0))return!1;return!0}createOutput(a){let e=this._model.graph.getOutputNames();if(a.length!==e.length)throw new Error("expected number of outputs do not match number of generated outputs");let o=new Map;for(let s=0;s<e.length;++s)o.set(e[s],a[s]);return o}initializeOps(a){let e=a.getNodes();this._ops=new Array(e.length);for(let o=0;o<e.length;o++)this._ops[o]=this.sessionHandler.resolve(e[o],this._model.opsets,a)}}}),Ao$1,Op$1=E(()=>{Tt(),br(),Ao$1=class{constructor(a){this.session=a,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(a,e,o){let s=new Map;for(let h in a)if(Object.hasOwnProperty.call(a,h)){let _=a[h];s.set(h,new Ce(_.dims,_.type,void 0,void 0,_.data))}let d=await this.session.run(s),c={};return d.forEach((h,_)=>{c[_]=new Re(h.type,h.data,h.dims)}),c}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}}),Ip$1={};Pr$1(Ip$1,{onnxjsBackend:()=>ng});var Qi$1,ng,Sp$1=E(()=>{_p(),Op$1(),Qi$1=class{async init(){}async createInferenceSessionHandler(a,e){let o=new So$1(e);return typeof a=="string"?await o.loadModel(a):await o.loadModel(a),new Ao$1(o)}},ng=new Qi$1}),ea={};Pr$1(ea,{createReadStream:()=>Ap$1,readFile:()=>og,readFileSync:()=>ig});var og,ig,Ap$1,ta=E(()=>{og=void 0,ig=void 0,Ap$1=void 0}),ra$1={};Pr$1(ra$1,{join:()=>ag});var ag,na$1=E(()=>{ag=void 0}),Dp$1=me((a,e)=>{var o=(()=>{var s=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(s=s||__filename),function(d={}){var c=d,h,_;c.ready=new Promise((d0,v0)=>{h=d0,_=v0});var bt=Object.assign({},c),g="./this.program",j=typeof window=="object",b=typeof importScripts=="function",Et=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",It="",zt,er,Hn;if(Et){var Qt=(ta(),or$1(ea)),cr=(na$1(),or$1(ra$1));It=b?cr.dirname(It)+"/":__dirname+"/",zt=(d0,v0)=>(d0=k0(d0)?new URL(d0):cr.normalize(d0),Qt.readFileSync(d0,v0?void 0:"utf8")),Hn=d0=>(d0=zt(d0,!0),d0.buffer||(d0=new Uint8Array(d0)),d0),er=(d0,v0,N0,F0=!0)=>{d0=k0(d0)?new URL(d0):cr.normalize(d0),Qt.readFile(d0,F0?void 0:"utf8",(sy,xy)=>{sy?N0(sy):v0(F0?xy.buffer:xy)})},!c.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),c.inspect=()=>"[Emscripten Module object]"}else(j||b)&&(b?It=self.location.href:typeof document<"u"&&document.currentScript&&(It=document.currentScript.src),s&&(It=s),It.indexOf("blob:")!==0?It=It.substr(0,It.replace(/[?#].*/,"").lastIndexOf("/")+1):It="",zt=d0=>{var v0=new XMLHttpRequest;return v0.open("GET",d0,!1),v0.send(null),v0.responseText},b&&(Hn=d0=>{var v0=new XMLHttpRequest;return v0.open("GET",d0,!1),v0.responseType="arraybuffer",v0.send(null),new Uint8Array(v0.response)}),er=(d0,v0,N0)=>{var F0=new XMLHttpRequest;F0.open("GET",d0,!0),F0.responseType="arraybuffer",F0.onload=()=>{F0.status==200||F0.status==0&&F0.response?v0(F0.response):N0()},F0.onerror=N0,F0.send(null)});var fr=console.log.bind(console),jr=console.error.bind(console);Object.assign(c,bt),bt=null,typeof WebAssembly!="object"&&w0("no native wasm support detected");var e0,t0=!1,o0,l0,g0,i0,f0;function C0(){var d0=e0.buffer;c.HEAP8=o0=new Int8Array(d0),c.HEAP16=new Int16Array(d0),c.HEAPU8=l0=new Uint8Array(d0),c.HEAPU16=new Uint16Array(d0),c.HEAP32=g0=new Int32Array(d0),c.HEAPU32=i0=new Uint32Array(d0),c.HEAPF32=new Float32Array(d0),c.HEAPF64=f0=new Float64Array(d0)}var Z0=[],R0=[],Y0=[],H0=0,ty=null;function w0(d0){throw d0="Aborted("+d0+")",jr(d0),t0=!0,d0=new WebAssembly.RuntimeError(d0+". Build with -sASSERTIONS for more info."),_(d0),d0}var L0=d0=>d0.startsWith("data:application/octet-stream;base64,"),k0=d0=>d0.startsWith("file://"),T0;if(T0="ort-wasm.wasm",!L0(T0)){var q0=T0;T0=c.locateFile?c.locateFile(q0,It):It+q0}function vy(d0){if(Hn)return Hn(d0);throw"both async and sync fetching of the wasm failed"}function J0(d0){if(j||b){if(typeof fetch=="function"&&!k0(d0))return fetch(d0,{credentials:"same-origin"}).then(v0=>{if(!v0.ok)throw"failed to load wasm binary file at '"+d0+"'";return v0.arrayBuffer()}).catch(()=>vy(d0));if(er)return new Promise((v0,N0)=>{er(d0,F0=>v0(new Uint8Array(F0)),N0)})}return Promise.resolve().then(()=>vy(d0))}function cy(d0,v0,N0){return J0(d0).then(F0=>WebAssembly.instantiate(F0,v0)).then(F0=>F0).then(N0,F0=>{jr(`failed to asynchronously prepare wasm: ${F0}`),w0(F0)})}function Ty(d0,v0){var N0=T0;return typeof WebAssembly.instantiateStreaming!="function"||L0(N0)||k0(N0)||Et||typeof fetch!="function"?cy(N0,d0,v0):fetch(N0,{credentials:"same-origin"}).then(F0=>WebAssembly.instantiateStreaming(F0,d0).then(v0,function(sy){return jr(`wasm streaming compile failed: ${sy}`),jr("falling back to ArrayBuffer instantiation"),cy(N0,d0,v0)}))}var Uy,Qy={920016:(d0,v0,N0,F0)=>{if(typeof c>"u"||!c.za)return 1;if(d0=Ay(d0>>>0),d0.startsWith("./")&&(d0=d0.substring(2)),d0=c.za.get(d0),!d0)return 2;if(v0>>>=0,N0>>>=0,v0+N0>d0.byteLength)return 3;try{return l0.set(d0.subarray(v0,v0+N0),F0>>>0>>>0),0}catch{return 4}}};function Zy(d0){this.xa=d0-24,this.Ha=function(v0){i0[this.xa+4>>>2>>>0]=v0},this.Ga=function(v0){i0[this.xa+8>>>2>>>0]=v0},this.Aa=function(v0,N0){this.Fa(),this.Ha(v0),this.Ga(N0)},this.Fa=function(){i0[this.xa+16>>>2>>>0]=0}}var iv=0,zy=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,B0=(d0,v0,N0)=>{v0>>>=0;var F0=v0+N0;for(N0=v0;d0[N0]&&!(N0>=F0);)++N0;if(16<N0-v0&&d0.buffer&&zy)return zy.decode(d0.subarray(v0,N0));for(F0="";v0<N0;){var sy=d0[v0++];if(sy&128){var xy=d0[v0++]&63;if((sy&224)==192)F0+=String.fromCharCode((sy&31)<<6|xy);else{var ev=d0[v0++]&63;sy=(sy&240)==224?(sy&15)<<12|xy<<6|ev:(sy&7)<<18|xy<<12|ev<<6|d0[v0++]&63,65536>sy?F0+=String.fromCharCode(sy):(sy-=65536,F0+=String.fromCharCode(55296|sy>>10,56320|sy&1023))}}else F0+=String.fromCharCode(sy)}return F0},Ay=(d0,v0)=>(d0>>>=0)?B0(l0,d0,v0):"",hy=d0=>{for(var v0=0,N0=0;N0<d0.length;++N0){var F0=d0.charCodeAt(N0);127>=F0?v0++:2047>=F0?v0+=2:55296<=F0&&57343>=F0?(v0+=4,++N0):v0+=3}return v0},Ly=(d0,v0,N0,F0)=>{if(N0>>>=0,!(0<F0))return 0;var sy=N0;F0=N0+F0-1;for(var xy=0;xy<d0.length;++xy){var ev=d0.charCodeAt(xy);if(55296<=ev&&57343>=ev){var Sv=d0.charCodeAt(++xy);ev=65536+((ev&1023)<<10)|Sv&1023}if(127>=ev){if(N0>=F0)break;v0[N0++>>>0]=ev}else{if(2047>=ev){if(N0+1>=F0)break;v0[N0++>>>0]=192|ev>>6}else{if(65535>=ev){if(N0+2>=F0)break;v0[N0++>>>0]=224|ev>>12}else{if(N0+3>=F0)break;v0[N0++>>>0]=240|ev>>18,v0[N0++>>>0]=128|ev>>12&63}v0[N0++>>>0]=128|ev>>6&63}v0[N0++>>>0]=128|ev&63}}return v0[N0>>>0]=0,N0-sy},Iy=d0=>d0%4===0&&(d0%100!==0||d0%400===0),Jy=[0,31,60,91,121,152,182,213,244,274,305,335],Gy=[0,31,59,90,120,151,181,212,243,273,304,334],sv=d0=>{var v0=hy(d0)+1,N0=Hy(v0);return N0&&Ly(d0,l0,N0,v0),N0},yv=[],I0={},b0=()=>{if(!uy){var d0={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"},v0;for(v0 in I0)I0[v0]===void 0?delete d0[v0]:d0[v0]=I0[v0];var N0=[];for(v0 in d0)N0.push(`${v0}=${d0[v0]}`);uy=N0}return uy},uy,Ey=[null,[],[]],Dy=[31,29,31,30,31,30,31,31,30,31,30,31],By=[31,28,31,30,31,30,31,31,30,31,30,31];function bv(d0){var v0=Array(hy(d0)+1);return Ly(d0,v0,0,v0.length),v0}function av(d0,v0,N0,F0){function sy(wy,Zv,Xv){for(wy=typeof wy=="number"?wy.toString():wy||"";wy.length<Zv;)wy=Xv[0]+wy;return wy}function xy(wy,Zv){return sy(wy,Zv,"0")}function ev(wy,Zv){function Xv(Rv){return 0>Rv?-1:0<Rv?1:0}var v_;return(v_=Xv(wy.getFullYear()-Zv.getFullYear()))===0&&(v_=Xv(wy.getMonth()-Zv.getMonth()))===0&&(v_=Xv(wy.getDate()-Zv.getDate())),v_}function Sv(wy){switch(wy.getDay()){case 0:return new Date(wy.getFullYear()-1,11,29);case 1:return wy;case 2:return new Date(wy.getFullYear(),0,3);case 3:return new Date(wy.getFullYear(),0,2);case 4:return new Date(wy.getFullYear(),0,1);case 5:return new Date(wy.getFullYear()-1,11,31);case 6:return new Date(wy.getFullYear()-1,11,30)}}function kv(wy){var Zv=wy.ta;for(wy=new Date(new Date(wy.ua+1900,0,1).getTime());0<Zv;){var Xv=wy.getMonth(),v_=(Iy(wy.getFullYear())?Dy:By)[Xv];if(Zv>v_-wy.getDate())Zv-=v_-wy.getDate()+1,wy.setDate(1),11>Xv?wy.setMonth(Xv+1):(wy.setMonth(0),wy.setFullYear(wy.getFullYear()+1));else{wy.setDate(wy.getDate()+Zv);break}}return Xv=new Date(wy.getFullYear()+1,0,4),Zv=Sv(new Date(wy.getFullYear(),0,4)),Xv=Sv(Xv),0>=ev(Zv,wy)?0>=ev(Xv,wy)?wy.getFullYear()+1:wy.getFullYear():wy.getFullYear()-1}d0>>>=0,v0>>>=0,N0>>>=0,F0>>>=0;var Vv=i0[F0+40>>>2>>>0];F0={Da:g0[F0>>>2>>>0],Ca:g0[F0+4>>>2>>>0],va:g0[F0+8>>>2>>>0],ya:g0[F0+12>>>2>>>0],wa:g0[F0+16>>>2>>>0],ua:g0[F0+20>>>2>>>0],oa:g0[F0+24>>>2>>>0],ta:g0[F0+28>>>2>>>0],Ia:g0[F0+32>>>2>>>0],Ba:g0[F0+36>>>2>>>0],Ea:Vv?Ay(Vv):""},N0=Ay(N0),Vv={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var $v in Vv)N0=N0.replace(new RegExp($v,"g"),Vv[$v]);var ov="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),C_="January February March April May June July August September October November December".split(" ");Vv={"%a":wy=>ov[wy.oa].substring(0,3),"%A":wy=>ov[wy.oa],"%b":wy=>C_[wy.wa].substring(0,3),"%B":wy=>C_[wy.wa],"%C":wy=>xy((wy.ua+1900)/100|0,2),"%d":wy=>xy(wy.ya,2),"%e":wy=>sy(wy.ya,2," "),"%g":wy=>kv(wy).toString().substring(2),"%G":wy=>kv(wy),"%H":wy=>xy(wy.va,2),"%I":wy=>(wy=wy.va,wy==0?wy=12:12<wy&&(wy-=12),xy(wy,2)),"%j":wy=>{for(var Zv=0,Xv=0;Xv<=wy.wa-1;Zv+=(Iy(wy.ua+1900)?Dy:By)[Xv++]);return xy(wy.ya+Zv,3)},"%m":wy=>xy(wy.wa+1,2),"%M":wy=>xy(wy.Ca,2),"%n":()=>`
`,"%p":wy=>0<=wy.va&&12>wy.va?"AM":"PM","%S":wy=>xy(wy.Da,2),"%t":()=>"	","%u":wy=>wy.oa||7,"%U":wy=>xy(Math.floor((wy.ta+7-wy.oa)/7),2),"%V":wy=>{var Zv=Math.floor((wy.ta+7-(wy.oa+6)%7)/7);if(2>=(wy.oa+371-wy.ta-2)%7&&Zv++,Zv)Zv==53&&(Xv=(wy.oa+371-wy.ta)%7,Xv==4||Xv==3&&Iy(wy.ua)||(Zv=1));else{Zv=52;var Xv=(wy.oa+7-wy.ta-1)%7;(Xv==4||Xv==5&&Iy(wy.ua%400-1))&&Zv++}return xy(Zv,2)},"%w":wy=>wy.oa,"%W":wy=>xy(Math.floor((wy.ta+7-(wy.oa+6)%7)/7),2),"%y":wy=>(wy.ua+1900).toString().substring(2),"%Y":wy=>wy.ua+1900,"%z":wy=>{wy=wy.Ba;var Zv=0<=wy;return wy=Math.abs(wy)/60,(Zv?"+":"-")+("0000"+(wy/60*100+wy%60)).slice(-4)},"%Z":wy=>wy.Ea,"%%":()=>"%"},N0=N0.replace(/%%/g,"\0\0");for($v in Vv)N0.includes($v)&&(N0=N0.replace(new RegExp($v,"g"),Vv[$v](F0)));return N0=N0.replace(/\0\0/g,"%"),$v=bv(N0),$v.length>v0?0:(o0.set($v,d0>>>0),$v.length-1)}var Wy={a:function(d0,v0,N0){throw d0>>>=0,new Zy(d0).Aa(v0>>>0,N0>>>0),iv=d0,iv},e:function(){return 0},H:function(){},x:function(){},z:function(){},J:function(){return 0},F:function(){},A:function(){},E:function(){},g:function(){},y:function(){},v:function(){},G:function(){},w:function(){},k:()=>1,n:function(d0,v0,N0){d0=v0+2097152>>>0<4194305-!!d0?(d0>>>0)+4294967296*v0:NaN,N0>>>=0,d0=new Date(1e3*d0),g0[N0>>>2>>>0]=d0.getUTCSeconds(),g0[N0+4>>>2>>>0]=d0.getUTCMinutes(),g0[N0+8>>>2>>>0]=d0.getUTCHours(),g0[N0+12>>>2>>>0]=d0.getUTCDate(),g0[N0+16>>>2>>>0]=d0.getUTCMonth(),g0[N0+20>>>2>>>0]=d0.getUTCFullYear()-1900,g0[N0+24>>>2>>>0]=d0.getUTCDay(),g0[N0+28>>>2>>>0]=(d0.getTime()-Date.UTC(d0.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(d0,v0,N0){d0=v0+2097152>>>0<4194305-!!d0?(d0>>>0)+4294967296*v0:NaN,N0>>>=0,d0=new Date(1e3*d0),g0[N0>>>2>>>0]=d0.getSeconds(),g0[N0+4>>>2>>>0]=d0.getMinutes(),g0[N0+8>>>2>>>0]=d0.getHours(),g0[N0+12>>>2>>>0]=d0.getDate(),g0[N0+16>>>2>>>0]=d0.getMonth(),g0[N0+20>>>2>>>0]=d0.getFullYear()-1900,g0[N0+24>>>2>>>0]=d0.getDay(),g0[N0+28>>>2>>>0]=(Iy(d0.getFullYear())?Jy:Gy)[d0.getMonth()]+d0.getDate()-1|0,g0[N0+36>>>2>>>0]=-(60*d0.getTimezoneOffset()),v0=new Date(d0.getFullYear(),6,1).getTimezoneOffset();var F0=new Date(d0.getFullYear(),0,1).getTimezoneOffset();g0[N0+32>>>2>>>0]=(v0!=F0&&d0.getTimezoneOffset()==Math.min(F0,v0))|0},p:function(d0){d0>>>=0;var v0=new Date(g0[d0+20>>>2>>>0]+1900,g0[d0+16>>>2>>>0],g0[d0+12>>>2>>>0],g0[d0+8>>>2>>>0],g0[d0+4>>>2>>>0],g0[d0>>>2>>>0],0),N0=g0[d0+32>>>2>>>0],F0=v0.getTimezoneOffset(),sy=new Date(v0.getFullYear(),6,1).getTimezoneOffset(),xy=new Date(v0.getFullYear(),0,1).getTimezoneOffset(),ev=Math.min(xy,sy);return 0>N0?g0[d0+32>>>2>>>0]=+(sy!=xy&&ev==F0):0<N0!=(ev==F0)&&(sy=Math.max(xy,sy),v0.setTime(v0.getTime()+6e4*((0<N0?ev:sy)-F0))),g0[d0+24>>>2>>>0]=v0.getDay(),g0[d0+28>>>2>>>0]=(Iy(v0.getFullYear())?Jy:Gy)[v0.getMonth()]+v0.getDate()-1|0,g0[d0>>>2>>>0]=v0.getSeconds(),g0[d0+4>>>2>>>0]=v0.getMinutes(),g0[d0+8>>>2>>>0]=v0.getHours(),g0[d0+12>>>2>>>0]=v0.getDate(),g0[d0+16>>>2>>>0]=v0.getMonth(),g0[d0+20>>>2>>>0]=v0.getYear(),d0=v0.getTime(),isNaN(d0)?(g0[uv()>>>2>>>0]=61,d0=-1):d0/=1e3,wv((Uy=d0,1<=+Math.abs(Uy)?0<Uy?+Math.floor(Uy/4294967296)>>>0:~~+Math.ceil((Uy-+(~~Uy>>>0))/4294967296)>>>0:0)),d0>>>0},l:function(){return-52},m:function(){},t:function(d0,v0,N0){function F0(kv){return(kv=kv.toTimeString().match(/\(([A-Za-z ]+)\)$/))?kv[1]:"GMT"}N0>>>=0;var sy=new Date().getFullYear(),xy=new Date(sy,0,1),ev=new Date(sy,6,1);sy=xy.getTimezoneOffset();var Sv=ev.getTimezoneOffset();i0[d0>>>0>>>2>>>0]=60*Math.max(sy,Sv),g0[v0>>>0>>>2>>>0]=+(sy!=Sv),d0=F0(xy),v0=F0(ev),d0=sv(d0),v0=sv(v0),Sv<sy?(i0[N0>>>2>>>0]=d0,i0[N0+4>>>2>>>0]=v0):(i0[N0>>>2>>>0]=v0,i0[N0+4>>>2>>>0]=d0)},d:()=>{w0("")},B:function(d0,v0,N0){d0>>>=0,v0>>>=0,N0>>>=0,yv.length=0;for(var F0;F0=l0[v0++>>>0];){var sy=F0!=105;sy&=F0!=112,N0+=sy&&N0%8?4:0,yv.push(F0==112?i0[N0>>>2>>>0]:F0==105?g0[N0>>>2>>>0]:f0[N0>>>3>>>0]),N0+=sy?8:4}return Qy[d0].apply(null,yv)},h:()=>Date.now(),u:function(){return 4294901760},b:()=>performance.now(),I:function(d0,v0,N0){return v0>>>=0,l0.copyWithin(d0>>>0>>>0,v0>>>0,v0+(N0>>>0)>>>0)},s:function(d0){d0>>>=0;var v0=l0.length;if(4294901760<d0)return!1;for(var N0=1;4>=N0;N0*=2){var F0=v0*(1+.2/N0);F0=Math.min(F0,d0+100663296);var sy=Math;F0=Math.max(d0,F0);e:{sy=(sy.min.call(sy,4294901760,F0+(65536-F0%65536)%65536)-e0.buffer.byteLength+65535)/65536;try{e0.grow(sy),C0();var xy=1;break e}catch{}xy=void 0}if(xy)return!0}return!1},C:function(d0,v0){d0>>>=0,v0>>>=0;var N0=0;return b0().forEach((F0,sy)=>{var xy=v0+N0;for(sy=i0[d0+4*sy>>>2>>>0]=xy,xy=0;xy<F0.length;++xy)o0[sy++>>>0>>>0]=F0.charCodeAt(xy);o0[sy>>>0>>>0]=0,N0+=F0.length+1}),0},D:function(d0,v0){d0>>>=0,v0>>>=0;var N0=b0();i0[d0>>>2>>>0]=N0.length;var F0=0;return N0.forEach(sy=>F0+=sy.length+1),i0[v0>>>2>>>0]=F0,0},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(d0,v0,N0,F0){v0>>>=0,N0>>>=0,F0>>>=0;for(var sy=0,xy=0;xy<N0;xy++){var ev=i0[v0>>>2>>>0],Sv=i0[v0+4>>>2>>>0];v0+=8;for(var kv=0;kv<Sv;kv++){var Vv=l0[ev+kv>>>0],$v=Ey[d0];Vv===0||Vv===10?((d0===1?fr:jr)(B0($v,0)),$v.length=0):$v.push(Vv)}sy+=Sv}return i0[F0>>>2>>>0]=sy,0},r:av,c:function(d0,v0,N0,F0){return av(d0>>>0,v0>>>0,N0>>>0,F0>>>0)}},my=function(){function d0(N0){return my=N0.exports,my=oy(),e0=my.K,C0(),R0.unshift(my.L),H0--,H0==0&&ty&&(N0=ty,ty=null,N0()),my}var v0={a:Wy};if(H0++,c.instantiateWasm)try{return c.instantiateWasm(v0,d0)}catch(N0){jr(`Module.instantiateWasm callback failed with error: ${N0}`),_(N0)}return Ty(v0,function(N0){d0(N0.instance)}).catch(_),{}}();c._OrtInit=(d0,v0)=>(c._OrtInit=my.M)(d0,v0),c._OrtGetLastError=(d0,v0)=>(c._OrtGetLastError=my.N)(d0,v0),c._OrtCreateSessionOptions=(d0,v0,N0,F0,sy,xy,ev,Sv,kv,Vv)=>(c._OrtCreateSessionOptions=my.O)(d0,v0,N0,F0,sy,xy,ev,Sv,kv,Vv),c._OrtAppendExecutionProvider=(d0,v0)=>(c._OrtAppendExecutionProvider=my.P)(d0,v0),c._OrtAddFreeDimensionOverride=(d0,v0,N0)=>(c._OrtAddFreeDimensionOverride=my.Q)(d0,v0,N0),c._OrtAddSessionConfigEntry=(d0,v0,N0)=>(c._OrtAddSessionConfigEntry=my.R)(d0,v0,N0),c._OrtReleaseSessionOptions=d0=>(c._OrtReleaseSessionOptions=my.S)(d0),c._OrtCreateSession=(d0,v0,N0)=>(c._OrtCreateSession=my.T)(d0,v0,N0),c._OrtReleaseSession=d0=>(c._OrtReleaseSession=my.U)(d0),c._OrtGetInputOutputCount=(d0,v0,N0)=>(c._OrtGetInputOutputCount=my.V)(d0,v0,N0),c._OrtGetInputName=(d0,v0)=>(c._OrtGetInputName=my.W)(d0,v0),c._OrtGetOutputName=(d0,v0)=>(c._OrtGetOutputName=my.X)(d0,v0),c._OrtFree=d0=>(c._OrtFree=my.Y)(d0),c._OrtCreateTensor=(d0,v0,N0,F0,sy,xy)=>(c._OrtCreateTensor=my.Z)(d0,v0,N0,F0,sy,xy),c._OrtGetTensorData=(d0,v0,N0,F0,sy)=>(c._OrtGetTensorData=my._)(d0,v0,N0,F0,sy),c._OrtReleaseTensor=d0=>(c._OrtReleaseTensor=my.$)(d0),c._OrtCreateRunOptions=(d0,v0,N0,F0)=>(c._OrtCreateRunOptions=my.aa)(d0,v0,N0,F0),c._OrtAddRunConfigEntry=(d0,v0,N0)=>(c._OrtAddRunConfigEntry=my.ba)(d0,v0,N0),c._OrtReleaseRunOptions=d0=>(c._OrtReleaseRunOptions=my.ca)(d0),c._OrtCreateBinding=d0=>(c._OrtCreateBinding=my.da)(d0),c._OrtBindInput=(d0,v0,N0)=>(c._OrtBindInput=my.ea)(d0,v0,N0),c._OrtBindOutput=(d0,v0,N0,F0)=>(c._OrtBindOutput=my.fa)(d0,v0,N0,F0),c._OrtClearBoundOutputs=d0=>(c._OrtClearBoundOutputs=my.ga)(d0),c._OrtReleaseBinding=d0=>(c._OrtReleaseBinding=my.ha)(d0),c._OrtRunWithBinding=(d0,v0,N0,F0,sy)=>(c._OrtRunWithBinding=my.ia)(d0,v0,N0,F0,sy),c._OrtRun=(d0,v0,N0,F0,sy,xy,ev,Sv)=>(c._OrtRun=my.ja)(d0,v0,N0,F0,sy,xy,ev,Sv),c._OrtEndProfiling=d0=>(c._OrtEndProfiling=my.ka)(d0);var uv=()=>(uv=my.la)(),Hy=c._malloc=d0=>(Hy=c._malloc=my.ma)(d0);c._free=d0=>(c._free=my.na)(d0);var wv=d0=>(wv=my.pa)(d0),mv=()=>(mv=my.qa)(),cv=d0=>(cv=my.ra)(d0),O0=d0=>(O0=my.sa)(d0);function oy(){var d0=my;d0=Object.assign({},d0);var v0=F0=>()=>F0()>>>0,N0=F0=>sy=>F0(sy)>>>0;return d0.la=v0(d0.la),d0.ma=N0(d0.ma),d0.qa=v0(d0.qa),d0.sa=N0(d0.sa),d0}c.stackAlloc=O0,c.stackSave=mv,c.stackRestore=cv,c.UTF8ToString=Ay,c.stringToUTF8=(d0,v0,N0)=>Ly(d0,l0,v0,N0),c.lengthBytesUTF8=hy;var Py;ty=function d0(){Py||nv(),Py||(ty=d0)};function nv(){if(!(0<H0)){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;){var d0=c.preRun.shift();Z0.unshift(d0)}for(;0<Z0.length;)Z0.shift()(c);if(!(0<H0||Py||(Py=!0,c.calledRun=!0,t0))){for(;0<R0.length;)R0.shift()(c);for(h(c);0<Y0.length;)Y0.shift()(c)}}}return nv(),d.ready}})();typeof a=="object"&&typeof e=="object"?e.exports=o:typeof define=="function"&&define.amd&&define([],()=>o)}),Lp$1=me(()=>{}),Fp$1=me(()=>{}),Cp$1={};Pr$1(Cp$1,{cpus:()=>sg});var sg,$p$1=E(()=>{sg=void 0}),Np$1=me((a,e)=>{var o=(()=>{var s=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(s=s||__filename),function(d={}){function c(){return Y0.buffer!=L0.buffer&&J0(),L0}function h(){return Y0.buffer!=L0.buffer&&J0(),k0}function _(){return Y0.buffer!=L0.buffer&&J0(),T0}function bt(){return Y0.buffer!=L0.buffer&&J0(),q0}function g(){return Y0.buffer!=L0.buffer&&J0(),vy}var j=d,b,Et;j.ready=new Promise((u0,M0)=>{b=u0,Et=M0});var It=Object.assign({},j),zt="./this.program",er=(u0,M0)=>{throw M0},Hn=typeof window=="object",Qt=typeof importScripts=="function",cr=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",fr=j.ENVIRONMENT_IS_PTHREAD||!1,jr="";function e0(u0){return j.locateFile?j.locateFile(u0,jr):jr+u0}var t0,o0,l0;if(cr){var g0=(ta(),or$1(ea)),i0=(na$1(),or$1(ra$1));jr=Qt?i0.dirname(jr)+"/":__dirname+"/",t0=(M0,G0)=>(M0=hy(M0)?new URL(M0):i0.normalize(M0),g0.readFileSync(M0,G0?void 0:"utf8")),l0=M0=>(M0=t0(M0,!0),M0.buffer||(M0=new Uint8Array(M0)),M0),o0=(M0,G0,X0,Ky=!0)=>{M0=hy(M0)?new URL(M0):i0.normalize(M0),g0.readFile(M0,Ky?void 0:"utf8",(Xy,_v)=>{Xy?X0(Xy):G0(Ky?_v.buffer:_v)})},!j.thisProgram&&1<process.argv.length&&(zt=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),er=(M0,G0)=>{throw process.exitCode=M0,G0},j.inspect=()=>"[Emscripten Module object]";let u0;try{u0=Lp$1()}catch(M0){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),M0}global.Worker=u0.Worker}else(Hn||Qt)&&(Qt?jr=self.location.href:typeof document<"u"&&document.currentScript&&(jr=document.currentScript.src),typeof s<"u"&&s&&(jr=s),jr.indexOf("blob:")!==0?jr=jr.substr(0,jr.replace(/[?#].*/,"").lastIndexOf("/")+1):jr="",cr||(t0=u0=>{var M0=new XMLHttpRequest;return M0.open("GET",u0,!1),M0.send(null),M0.responseText},Qt&&(l0=u0=>{var M0=new XMLHttpRequest;return M0.open("GET",u0,!1),M0.responseType="arraybuffer",M0.send(null),new Uint8Array(M0.response)}),o0=(u0,M0,G0)=>{var X0=new XMLHttpRequest;X0.open("GET",u0,!0),X0.responseType="arraybuffer",X0.onload=()=>{X0.status==200||X0.status==0&&X0.response?M0(X0.response):G0()},X0.onerror=G0,X0.send(null)}));cr&&typeof performance>"u"&&(global.performance=Fp$1().performance);var f0=console.log.bind(console),C0=console.error.bind(console);cr&&(f0=(...u0)=>g0.writeSync(1,u0.join(" ")+`
`),C0=(...u0)=>g0.writeSync(2,u0.join(" ")+`
`));var Z0=f0,R0=C0;Object.assign(j,It),It=null,typeof WebAssembly!="object"&&B0("no native wasm support detected");var Y0,H0,ty=!1,w0,L0,k0,T0,q0,vy;function J0(){var u0=Y0.buffer;j.HEAP8=L0=new Int8Array(u0),j.HEAP16=new Int16Array(u0),j.HEAPU8=k0=new Uint8Array(u0),j.HEAPU16=new Uint16Array(u0),j.HEAP32=T0=new Int32Array(u0),j.HEAPU32=q0=new Uint32Array(u0),j.HEAPF32=new Float32Array(u0),j.HEAPF64=vy=new Float64Array(u0)}var cy=16777216;if(fr)Y0=j.wasmMemory;else if(j.wasmMemory)Y0=j.wasmMemory;else if(Y0=new WebAssembly.Memory({initial:cy/65536,maximum:65536,shared:!0}),!(Y0.buffer instanceof SharedArrayBuffer))throw R0("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),cr&&R0("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");J0(),cy=Y0.buffer.byteLength;var Ty=[],Uy=[],Qy=[],Zy=0,iv=null;function zy(){if(Zy--,Zy==0&&iv){var u0=iv;iv=null,u0()}}function B0(u0){throw u0="Aborted("+u0+")",R0(u0),ty=!0,w0=1,u0=new WebAssembly.RuntimeError(u0+". Build with -sASSERTIONS for more info."),Et(u0),u0}var Ay=u0=>u0.startsWith("data:application/octet-stream;base64,"),hy=u0=>u0.startsWith("file://"),Ly;Ly="ort-wasm-threaded.wasm",Ay(Ly)||(Ly=e0(Ly));function Iy(u0){if(l0)return l0(u0);throw"both async and sync fetching of the wasm failed"}function Jy(u0){if(Hn||Qt){if(typeof fetch=="function"&&!hy(u0))return fetch(u0,{credentials:"same-origin"}).then(M0=>{if(!M0.ok)throw"failed to load wasm binary file at '"+u0+"'";return M0.arrayBuffer()}).catch(()=>Iy(u0));if(o0)return new Promise((M0,G0)=>{o0(u0,X0=>M0(new Uint8Array(X0)),G0)})}return Promise.resolve().then(()=>Iy(u0))}function Gy(u0,M0,G0){return Jy(u0).then(X0=>WebAssembly.instantiate(X0,M0)).then(X0=>X0).then(G0,X0=>{R0(`failed to asynchronously prepare wasm: ${X0}`),B0(X0)})}function sv(u0,M0){var G0=Ly;return typeof WebAssembly.instantiateStreaming!="function"||Ay(G0)||hy(G0)||cr||typeof fetch!="function"?Gy(G0,u0,M0):fetch(G0,{credentials:"same-origin"}).then(X0=>WebAssembly.instantiateStreaming(X0,u0).then(M0,function(Ky){return R0(`wasm streaming compile failed: ${Ky}`),R0("falling back to ArrayBuffer instantiation"),Gy(G0,u0,M0)}))}var yv,I0={921388:(u0,M0,G0,X0)=>{if(typeof j>"u"||!j.cb)return 1;if(u0=av(u0>>>0),u0.startsWith("./")&&(u0=u0.substring(2)),u0=j.cb.get(u0),!u0)return 2;if(M0>>>=0,G0>>>=0,X0>>>=0,M0+G0>u0.byteLength)return 3;try{return h().set(u0.subarray(M0,M0+G0),X0>>>0),0}catch{return 4}}};function b0(u0){this.name="ExitStatus",this.message=`Program terminated with exit(${u0})`,this.status=u0}var uy=u0=>{u0.terminate(),u0.onmessage=()=>{}},Ey=u0=>{O0.Pa.length==0&&(mv(),O0.Ya(O0.Pa[0]));var M0=O0.Pa.pop();if(!M0)return 6;O0.Qa.push(M0),O0.Ma[u0.Oa]=M0,M0.Oa=u0.Oa;var G0={cmd:"run",start_routine:u0.kb,arg:u0.hb,pthread_ptr:u0.Oa};return cr&&M0.unref(),M0.postMessage(G0,u0.qb),0},Dy=0,By=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,bv=(u0,M0,G0)=>{M0>>>=0;var X0=M0+G0;for(G0=M0;u0[G0]&&!(G0>=X0);)++G0;if(16<G0-M0&&u0.buffer&&By)return By.decode(u0.buffer instanceof SharedArrayBuffer?u0.slice(M0,G0):u0.subarray(M0,G0));for(X0="";M0<G0;){var Ky=u0[M0++];if(Ky&128){var Xy=u0[M0++]&63;if((Ky&224)==192)X0+=String.fromCharCode((Ky&31)<<6|Xy);else{var _v=u0[M0++]&63;Ky=(Ky&240)==224?(Ky&15)<<12|Xy<<6|_v:(Ky&7)<<18|Xy<<12|_v<<6|u0[M0++]&63,65536>Ky?X0+=String.fromCharCode(Ky):(Ky-=65536,X0+=String.fromCharCode(55296|Ky>>10,56320|Ky&1023))}}else X0+=String.fromCharCode(Ky)}return X0},av=(u0,M0)=>(u0>>>=0)?bv(h(),u0,M0):"",Wy=u0=>{var M0=S1();return u0=u0(),vw(M0),u0};function my(u0,M0){var G0=arguments.length-2,X0=arguments;return Wy(()=>{for(var Ky=Hw(8*G0),Xy=Ky>>>3,_v=0;_v<G0;_v++){var A_=X0[2+_v];g()[Xy+_v>>>0]=A_}return S_(u0,G0,Ky,M0)})}function uv(u0){var M0;if(fr)return my(0,1,u0);w0=u0,0<Dy||(O0.lb(),(M0=j.onExit)==null||M0.call(j,u0),ty=!0),er(u0,new b0(u0))}var Hy=u0=>{if(w0=u0,fr)throw Py(u0),"unwind";uv(u0)};function wv(){for(var u0=j.numThreads;u0--;)mv();Ty.unshift(()=>{Zy++,cv(()=>zy())})}function mv(){var u0=e0("ort-wasm-threaded.worker.js");u0=new Worker(u0),O0.Pa.push(u0)}function cv(u0){fr?u0():Promise.all(O0.Pa.map(O0.Ya)).then(u0)}var O0={Pa:[],Qa:[],bb:[],Ma:{},Wa(){fr?(O0.receiveObjectTransfer=O0.jb,O0.threadInitTLS=O0.ab,O0.setExitStatus=O0.$a):wv()},$a:u0=>w0=u0,tb:["$terminateWorker"],lb:()=>{for(var u0 of O0.Qa)uy(u0);for(u0 of O0.Pa)uy(u0);O0.Pa=[],O0.Qa=[],O0.Ma=[]},Za:u0=>{var M0=u0.Oa;delete O0.Ma[M0],O0.Pa.push(u0),O0.Qa.splice(O0.Qa.indexOf(u0),1),u0.Oa=0,B_(M0)},jb(){},ab(){O0.bb.forEach(u0=>u0())},Ya:u0=>new Promise(M0=>{u0.onmessage=Xy=>{Xy=Xy.data;var _v=Xy.cmd;if(Xy.targetThread&&Xy.targetThread!=Ov()){var A_=O0.Ma[Xy.targetThread];A_?A_.postMessage(Xy,Xy.transferList):R0(`Internal error! Worker sent a message "${_v}" to target pthread ${Xy.targetThread}, but that thread no longer exists!`)}else _v==="checkMailbox"?j0():_v==="spawnThread"?Ey(Xy):_v==="cleanupThread"?O0.Za(O0.Ma[Xy.thread]):_v==="killThread"?(Xy=Xy.thread,_v=O0.Ma[Xy],delete O0.Ma[Xy],uy(_v),B_(Xy),O0.Qa.splice(O0.Qa.indexOf(_v),1),_v.Oa=0):_v==="cancelThread"?O0.Ma[Xy.thread].postMessage({cmd:"cancel"}):_v==="loaded"?(u0.loaded=!0,cr&&!u0.Oa&&u0.unref(),M0(u0)):_v==="alert"?alert(`Thread ${Xy.threadId}: ${Xy.text}`):Xy.target==="setimmediate"?u0.postMessage(Xy):_v==="callHandler"?j[Xy.handler](...Xy.args):_v&&R0(`worker sent an unknown command ${_v}`)},u0.onerror=Xy=>{throw R0(`worker sent an error! ${Xy.filename}:${Xy.lineno}: ${Xy.message}`),Xy},cr&&(u0.on("message",Xy=>u0.onmessage({data:Xy})),u0.on("error",Xy=>u0.onerror(Xy)));var G0=[],X0=["onExit"],Ky;for(Ky of X0)j.hasOwnProperty(Ky)&&G0.push(Ky);u0.postMessage({cmd:"load",handlers:G0,urlOrBlob:j.mainScriptUrlOrBlob||s,wasmMemory:Y0,wasmModule:H0})})};j.PThread=O0;var oy=u0=>{for(;0<u0.length;)u0.shift()(j)};j.establishStackSpace=()=>{var u0=Ov(),M0=bt()[u0+52>>>2>>>0];u0=bt()[u0+56>>>2>>>0],m1(M0,M0-u0),vw(M0)};function Py(u0){if(fr)return my(1,0,u0);Hy(u0)}var nv=[],d0;j.invokeEntryPoint=(u0,M0)=>{var G0=nv[u0];G0||(u0>=nv.length&&(nv.length=u0+1),nv[u0]=G0=d0.get(u0)),u0=G0(M0),0<Dy?O0.$a(u0):z_(u0)};function v0(u0){this.Va=u0-24,this.gb=function(M0){bt()[this.Va+4>>>2>>>0]=M0},this.fb=function(M0){bt()[this.Va+8>>>2>>>0]=M0},this.Wa=function(M0,G0){this.eb(),this.gb(M0),this.fb(G0)},this.eb=function(){bt()[this.Va+16>>>2>>>0]=0}}var N0=0;function F0(u0,M0,G0,X0){return fr?my(2,1,u0,M0,G0,X0):sy(u0,M0,G0,X0)}function sy(u0,M0,G0,X0){if(u0>>>=0,M0>>>=0,G0>>>=0,X0>>>=0,typeof SharedArrayBuffer>"u")return R0("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Ky=[];return fr&&Ky.length===0?F0(u0,M0,G0,X0):(u0={kb:G0,Oa:u0,hb:X0,qb:Ky},fr?(u0.sb="spawnThread",postMessage(u0,Ky),0):Ey(u0))}function xy(u0,M0,G0){return fr?my(3,1,u0,M0,G0):0}function ev(u0,M0){if(fr)return my(4,1,u0,M0)}var Sv=u0=>{for(var M0=0,G0=0;G0<u0.length;++G0){var X0=u0.charCodeAt(G0);127>=X0?M0++:2047>=X0?M0+=2:55296<=X0&&57343>=X0?(M0+=4,++G0):M0+=3}return M0},kv=(u0,M0,G0,X0)=>{if(G0>>>=0,!(0<X0))return 0;var Ky=G0;X0=G0+X0-1;for(var Xy=0;Xy<u0.length;++Xy){var _v=u0.charCodeAt(Xy);if(55296<=_v&&57343>=_v){var A_=u0.charCodeAt(++Xy);_v=65536+((_v&1023)<<10)|A_&1023}if(127>=_v){if(G0>=X0)break;M0[G0++>>>0]=_v}else{if(2047>=_v){if(G0+1>=X0)break;M0[G0++>>>0]=192|_v>>6}else{if(65535>=_v){if(G0+2>=X0)break;M0[G0++>>>0]=224|_v>>12}else{if(G0+3>=X0)break;M0[G0++>>>0]=240|_v>>18,M0[G0++>>>0]=128|_v>>12&63}M0[G0++>>>0]=128|_v>>6&63}M0[G0++>>>0]=128|_v&63}}return M0[G0>>>0]=0,G0-Ky},Vv=(u0,M0,G0)=>kv(u0,h(),M0,G0);function $v(u0,M0){if(fr)return my(5,1,u0,M0)}function ov(u0,M0,G0){if(fr)return my(6,1,u0,M0,G0)}function C_(u0,M0,G0){return fr?my(7,1,u0,M0,G0):0}function wy(u0,M0){if(fr)return my(8,1,u0,M0)}function Zv(u0,M0,G0){if(fr)return my(9,1,u0,M0,G0)}function Xv(u0,M0,G0,X0){if(fr)return my(10,1,u0,M0,G0,X0)}function v_(u0,M0,G0,X0){if(fr)return my(11,1,u0,M0,G0,X0)}function Rv(u0,M0,G0,X0){if(fr)return my(12,1,u0,M0,G0,X0)}function i1(u0){if(fr)return my(13,1,u0)}function h1(u0,M0){if(fr)return my(14,1,u0,M0)}function m0(u0,M0,G0){if(fr)return my(15,1,u0,M0,G0)}function E0(u0){u0>>>=0,typeof Atomics.rb=="function"&&(Atomics.rb(_(),u0>>>2,u0).value.then(j0),u0+=128,Atomics.store(_(),u0>>>2,1))}j.__emscripten_thread_mailbox_await=E0;var j0=()=>{var u0=Ov();if(u0&&(E0(u0),u0=D1,!ty))try{if(u0(),!(0<Dy))try{fr?z_(w0):Hy(w0)}catch(M0){M0 instanceof b0||M0=="unwind"||er(1,M0)}}catch(M0){M0 instanceof b0||M0=="unwind"||er(1,M0)}};j.checkMailbox=j0;var h0=[],$0=u0=>u0%4===0&&(u0%100!==0||u0%400===0),P0=[0,31,60,91,121,152,182,213,244,274,305,335],Yr=[0,31,59,90,120,151,181,212,243,273,304,334];function r0(u0,M0,G0,X0,Ky,Xy,_v,A_){return fr?my(16,1,u0,M0,G0,X0,Ky,Xy,_v,A_):-52}function p0(u0,M0,G0,X0,Ky,Xy,_v){if(fr)return my(17,1,u0,M0,G0,X0,Ky,Xy,_v)}var _0=u0=>{var M0=Sv(u0)+1,G0=Qv(M0);return G0&&Vv(u0,G0,M0),G0},D0=[],V0={},yy=()=>{if(!ly){var u0={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:zt||"./this.program"},M0;for(M0 in V0)V0[M0]===void 0?delete u0[M0]:u0[M0]=V0[M0];var G0=[];for(M0 in u0)G0.push(`${M0}=${u0[M0]}`);ly=G0}return ly},ly;function gy(u0,M0){if(fr)return my(18,1,u0,M0);u0>>>=0,M0>>>=0;var G0=0;return yy().forEach((X0,Ky)=>{var Xy=M0+G0;for(Ky=bt()[u0+4*Ky>>>2>>>0]=Xy,Xy=0;Xy<X0.length;++Xy)c()[Ky++>>>0>>>0]=X0.charCodeAt(Xy);c()[Ky>>>0>>>0]=0,G0+=X0.length+1}),0}function ky(u0,M0){if(fr)return my(19,1,u0,M0);u0>>>=0,M0>>>=0;var G0=yy();bt()[u0>>>2>>>0]=G0.length;var X0=0;return G0.forEach(Ky=>X0+=Ky.length+1),bt()[M0>>>2>>>0]=X0,0}function jy(u0){return fr?my(20,1,u0):52}function rv(u0,M0,G0,X0){return fr?my(21,1,u0,M0,G0,X0):52}function dv(u0,M0,G0,X0,Ky){return fr?my(22,1,u0,M0,G0,X0,Ky):70}var K0=[null,[],[]];function Cy(u0,M0,G0,X0){if(fr)return my(23,1,u0,M0,G0,X0);M0>>>=0,G0>>>=0,X0>>>=0;for(var Ky=0,Xy=0;Xy<G0;Xy++){var _v=bt()[M0>>>2>>>0],A_=bt()[M0+4>>>2>>>0];M0+=8;for(var y_=0;y_<A_;y_++){var $_=h()[_v+y_>>>0],G_=K0[u0];$_===0||$_===10?((u0===1?Z0:R0)(bv(G_,0)),G_.length=0):G_.push($_)}Ky+=A_}return bt()[X0>>>2>>>0]=Ky,0}var lv=[31,29,31,30,31,30,31,31,30,31,30,31],vv=[31,28,31,30,31,30,31,31,30,31,30,31];function Mv(u0){var M0=Array(Sv(u0)+1);return kv(u0,M0,0,M0.length),M0}var f_=(u0,M0)=>{c().set(u0,M0>>>0)};function b_(u0,M0,G0,X0){function Ky(Ry,t_,Pv){for(Ry=typeof Ry=="number"?Ry.toString():Ry||"";Ry.length<t_;)Ry=Pv[0]+Ry;return Ry}function Xy(Ry,t_){return Ky(Ry,t_,"0")}function _v(Ry,t_){function Pv(t1){return 0>t1?-1:0<t1?1:0}var l_;return(l_=Pv(Ry.getFullYear()-t_.getFullYear()))===0&&(l_=Pv(Ry.getMonth()-t_.getMonth()))===0&&(l_=Pv(Ry.getDate()-t_.getDate())),l_}function A_(Ry){switch(Ry.getDay()){case 0:return new Date(Ry.getFullYear()-1,11,29);case 1:return Ry;case 2:return new Date(Ry.getFullYear(),0,3);case 3:return new Date(Ry.getFullYear(),0,2);case 4:return new Date(Ry.getFullYear(),0,1);case 5:return new Date(Ry.getFullYear()-1,11,31);case 6:return new Date(Ry.getFullYear()-1,11,30)}}function y_(Ry){var t_=Ry.Ra;for(Ry=new Date(new Date(Ry.Sa+1900,0,1).getTime());0<t_;){var Pv=Ry.getMonth(),l_=($0(Ry.getFullYear())?lv:vv)[Pv];if(t_>l_-Ry.getDate())t_-=l_-Ry.getDate()+1,Ry.setDate(1),11>Pv?Ry.setMonth(Pv+1):(Ry.setMonth(0),Ry.setFullYear(Ry.getFullYear()+1));else{Ry.setDate(Ry.getDate()+t_);break}}return Pv=new Date(Ry.getFullYear()+1,0,4),t_=A_(new Date(Ry.getFullYear(),0,4)),Pv=A_(Pv),0>=_v(t_,Ry)?0>=_v(Pv,Ry)?Ry.getFullYear()+1:Ry.getFullYear():Ry.getFullYear()-1}u0>>>=0,M0>>>=0,G0>>>=0,X0>>>=0;var $_=bt()[X0+40>>>2>>>0];X0={ob:_()[X0>>>2>>>0],nb:_()[X0+4>>>2>>>0],Ta:_()[X0+8>>>2>>>0],Xa:_()[X0+12>>>2>>>0],Ua:_()[X0+16>>>2>>>0],Sa:_()[X0+20>>>2>>>0],Na:_()[X0+24>>>2>>>0],Ra:_()[X0+28>>>2>>>0],ub:_()[X0+32>>>2>>>0],mb:_()[X0+36>>>2>>>0],pb:$_?av($_):""},G0=av(G0),$_={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var G_ in $_)G0=G0.replace(new RegExp(G_,"g"),$_[G_]);var aw="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ww="January February March April May June July August September October November December".split(" ");$_={"%a":Ry=>aw[Ry.Na].substring(0,3),"%A":Ry=>aw[Ry.Na],"%b":Ry=>Ww[Ry.Ua].substring(0,3),"%B":Ry=>Ww[Ry.Ua],"%C":Ry=>Xy((Ry.Sa+1900)/100|0,2),"%d":Ry=>Xy(Ry.Xa,2),"%e":Ry=>Ky(Ry.Xa,2," "),"%g":Ry=>y_(Ry).toString().substring(2),"%G":Ry=>y_(Ry),"%H":Ry=>Xy(Ry.Ta,2),"%I":Ry=>(Ry=Ry.Ta,Ry==0?Ry=12:12<Ry&&(Ry-=12),Xy(Ry,2)),"%j":Ry=>{for(var t_=0,Pv=0;Pv<=Ry.Ua-1;t_+=($0(Ry.Sa+1900)?lv:vv)[Pv++]);return Xy(Ry.Xa+t_,3)},"%m":Ry=>Xy(Ry.Ua+1,2),"%M":Ry=>Xy(Ry.nb,2),"%n":()=>`
`,"%p":Ry=>0<=Ry.Ta&&12>Ry.Ta?"AM":"PM","%S":Ry=>Xy(Ry.ob,2),"%t":()=>"	","%u":Ry=>Ry.Na||7,"%U":Ry=>Xy(Math.floor((Ry.Ra+7-Ry.Na)/7),2),"%V":Ry=>{var t_=Math.floor((Ry.Ra+7-(Ry.Na+6)%7)/7);if(2>=(Ry.Na+371-Ry.Ra-2)%7&&t_++,t_)t_==53&&(Pv=(Ry.Na+371-Ry.Ra)%7,Pv==4||Pv==3&&$0(Ry.Sa)||(t_=1));else{t_=52;var Pv=(Ry.Na+7-Ry.Ra-1)%7;(Pv==4||Pv==5&&$0(Ry.Sa%400-1))&&t_++}return Xy(t_,2)},"%w":Ry=>Ry.Na,"%W":Ry=>Xy(Math.floor((Ry.Ra+7-(Ry.Na+6)%7)/7),2),"%y":Ry=>(Ry.Sa+1900).toString().substring(2),"%Y":Ry=>Ry.Sa+1900,"%z":Ry=>{Ry=Ry.mb;var t_=0<=Ry;return Ry=Math.abs(Ry)/60,(t_?"+":"-")+("0000"+(Ry/60*100+Ry%60)).slice(-4)},"%Z":Ry=>Ry.pb,"%%":()=>"%"},G0=G0.replace(/%%/g,"\0\0");for(G_ in $_)G0.includes(G_)&&(G0=G0.replace(new RegExp(G_,"g"),$_[G_](X0)));return G0=G0.replace(/\0\0/g,"%"),G_=Mv(G0),G_.length>M0?0:(f_(G_,u0),G_.length-1)}O0.Wa();var x_=[uv,Py,F0,xy,ev,$v,ov,C_,wy,Zv,Xv,v_,Rv,i1,h1,m0,r0,p0,gy,ky,jy,rv,dv,Cy],o_={b:function(u0,M0,G0){throw u0>>>=0,new v0(u0).Wa(M0>>>0,G0>>>0),N0=u0,N0},L:function(u0){s_(u0>>>0,!Qt,1,!Hn,131072,!1),O0.ab()},j:function(u0){u0>>>=0,fr?postMessage({cmd:"cleanupThread",thread:u0}):O0.Za(O0.Ma[u0])},H:sy,h:xy,S:ev,D:$v,F:ov,T:C_,Q:wy,J:Zv,P:Xv,n:v_,E:Rv,B:i1,R:h1,C:m0,p:()=>1,z:function(u0,M0){u0>>>=0,u0==M0>>>0?setTimeout(()=>j0()):fr?postMessage({targetThread:u0,cmd:"checkMailbox"}):(u0=O0.Ma[u0])&&u0.postMessage({cmd:"checkMailbox"})},I:function(u0,M0,G0,X0){M0>>>=0,h0.length=G0,X0=X0>>>0>>>3;for(var Ky=0;Ky<G0;Ky++)h0[Ky]=g()[X0+Ky>>>0];return u0=0>u0?I0[-u0-1]:x_[u0],O0.ib=M0,M0=u0.apply(null,h0),O0.ib=0,M0},K:E0,o:function(u0){cr&&O0.Ma[u0>>>0].ref()},s:function(u0,M0,G0){u0=M0+2097152>>>0<4194305-!!u0?(u0>>>0)+4294967296*M0:NaN,G0>>>=0,u0=new Date(1e3*u0),_()[G0>>>2>>>0]=u0.getUTCSeconds(),_()[G0+4>>>2>>>0]=u0.getUTCMinutes(),_()[G0+8>>>2>>>0]=u0.getUTCHours(),_()[G0+12>>>2>>>0]=u0.getUTCDate(),_()[G0+16>>>2>>>0]=u0.getUTCMonth(),_()[G0+20>>>2>>>0]=u0.getUTCFullYear()-1900,_()[G0+24>>>2>>>0]=u0.getUTCDay(),u0=(u0.getTime()-Date.UTC(u0.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,_()[G0+28>>>2>>>0]=u0},t:function(u0,M0,G0){u0=M0+2097152>>>0<4194305-!!u0?(u0>>>0)+4294967296*M0:NaN,G0>>>=0,u0=new Date(1e3*u0),_()[G0>>>2>>>0]=u0.getSeconds(),_()[G0+4>>>2>>>0]=u0.getMinutes(),_()[G0+8>>>2>>>0]=u0.getHours(),_()[G0+12>>>2>>>0]=u0.getDate(),_()[G0+16>>>2>>>0]=u0.getMonth(),_()[G0+20>>>2>>>0]=u0.getFullYear()-1900,_()[G0+24>>>2>>>0]=u0.getDay(),M0=($0(u0.getFullYear())?P0:Yr)[u0.getMonth()]+u0.getDate()-1|0,_()[G0+28>>>2>>>0]=M0,_()[G0+36>>>2>>>0]=-(60*u0.getTimezoneOffset()),M0=new Date(u0.getFullYear(),6,1).getTimezoneOffset();var X0=new Date(u0.getFullYear(),0,1).getTimezoneOffset();u0=(M0!=X0&&u0.getTimezoneOffset()==Math.min(X0,M0))|0,_()[G0+32>>>2>>>0]=u0},u:function(u0){u0>>>=0;var M0=new Date(_()[u0+20>>>2>>>0]+1900,_()[u0+16>>>2>>>0],_()[u0+12>>>2>>>0],_()[u0+8>>>2>>>0],_()[u0+4>>>2>>>0],_()[u0>>>2>>>0],0),G0=_()[u0+32>>>2>>>0],X0=M0.getTimezoneOffset(),Ky=new Date(M0.getFullYear(),6,1).getTimezoneOffset(),Xy=new Date(M0.getFullYear(),0,1).getTimezoneOffset(),_v=Math.min(Xy,Ky);return 0>G0?_()[u0+32>>>2>>>0]=+(Ky!=Xy&&_v==X0):0<G0!=(_v==X0)&&(Ky=Math.max(Xy,Ky),M0.setTime(M0.getTime()+6e4*((0<G0?_v:Ky)-X0))),_()[u0+24>>>2>>>0]=M0.getDay(),G0=($0(M0.getFullYear())?P0:Yr)[M0.getMonth()]+M0.getDate()-1|0,_()[u0+28>>>2>>>0]=G0,_()[u0>>>2>>>0]=M0.getSeconds(),_()[u0+4>>>2>>>0]=M0.getMinutes(),_()[u0+8>>>2>>>0]=M0.getHours(),_()[u0+12>>>2>>>0]=M0.getDate(),_()[u0+16>>>2>>>0]=M0.getMonth(),_()[u0+20>>>2>>>0]=M0.getYear(),u0=M0.getTime(),isNaN(u0)?(_()[w_()>>>2>>>0]=61,u0=-1):u0/=1e3,B1((yv=u0,1<=+Math.abs(yv)?0<yv?+Math.floor(yv/4294967296)>>>0:~~+Math.ceil((yv-+(~~yv>>>0))/4294967296)>>>0:0)),u0>>>0},q:r0,r:p0,y:function(u0,M0,G0){function X0($_){return($_=$_.toTimeString().match(/\(([A-Za-z ]+)\)$/))?$_[1]:"GMT"}u0>>>=0,M0>>>=0,G0>>>=0;var Ky=new Date().getFullYear(),Xy=new Date(Ky,0,1),_v=new Date(Ky,6,1);Ky=Xy.getTimezoneOffset();var A_=_v.getTimezoneOffset(),y_=Math.max(Ky,A_);bt()[u0>>>2>>>0]=60*y_,_()[M0>>>2>>>0]=+(Ky!=A_),u0=X0(Xy),M0=X0(_v),u0=_0(u0),M0=_0(M0),A_<Ky?(bt()[G0>>>2>>>0]=u0,bt()[G0+4>>>2>>>0]=M0):(bt()[G0>>>2>>>0]=M0,bt()[G0+4>>>2>>>0]=u0)},c:()=>{B0("")},O:function(u0,M0,G0){u0>>>=0,M0>>>=0,G0>>>=0,D0.length=0;for(var X0;X0=h()[M0++>>>0];){var Ky=X0!=105;Ky&=X0!=112,G0+=Ky&&G0%8?4:0,D0.push(X0==112?bt()[G0>>>2>>>0]:X0==105?_()[G0>>>2>>>0]:g()[G0>>>3>>>0]),G0+=Ky?8:4}return I0[u0].apply(null,D0)},k:()=>{},i:()=>Date.now(),U:()=>{throw Dy+=1,"unwind"},A:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:()=>cr?($p$1(),or$1(Cp$1)).cpus().length:navigator.hardwareConcurrency,x:function(u0){u0>>>=0;var M0=h().length;if(u0<=M0||4294901760<u0)return!1;for(var G0=1;4>=G0;G0*=2){var X0=M0*(1+.2/G0);X0=Math.min(X0,u0+100663296);var Ky=Math;X0=Math.max(u0,X0);e:{Ky=(Ky.min.call(Ky,4294901760,X0+(65536-X0%65536)%65536)-Y0.buffer.byteLength+65535)/65536;try{Y0.grow(Ky),J0();var Xy=1;break e}catch{}Xy=void 0}if(Xy)return!0}return!1},M:gy,N:ky,G:Hy,g:jy,m:rv,v:dv,l:Cy,a:Y0||j.wasmMemory,w:b_,d:function(u0,M0,G0,X0){return b_(u0>>>0,M0>>>0,G0>>>0,X0>>>0)}},Yy=function(){function u0(G0,X0){return Yy=G0.exports,Yy=Cw(),O0.bb.push(Yy.za),d0=Yy.Aa,Uy.unshift(Yy.V),H0=X0,zy(),Yy}var M0={a:o_};if(Zy++,j.instantiateWasm)try{return j.instantiateWasm(M0,u0)}catch(G0){R0(`Module.instantiateWasm callback failed with error: ${G0}`),Et(G0)}return sv(M0,function(G0){u0(G0.instance,G0.module)}).catch(Et),{}}();j._OrtInit=(u0,M0)=>(j._OrtInit=Yy.W)(u0,M0),j._OrtGetLastError=(u0,M0)=>(j._OrtGetLastError=Yy.X)(u0,M0),j._OrtCreateSessionOptions=(u0,M0,G0,X0,Ky,Xy,_v,A_,y_,$_)=>(j._OrtCreateSessionOptions=Yy.Y)(u0,M0,G0,X0,Ky,Xy,_v,A_,y_,$_),j._OrtAppendExecutionProvider=(u0,M0)=>(j._OrtAppendExecutionProvider=Yy.Z)(u0,M0),j._OrtAddFreeDimensionOverride=(u0,M0,G0)=>(j._OrtAddFreeDimensionOverride=Yy._)(u0,M0,G0),j._OrtAddSessionConfigEntry=(u0,M0,G0)=>(j._OrtAddSessionConfigEntry=Yy.$)(u0,M0,G0),j._OrtReleaseSessionOptions=u0=>(j._OrtReleaseSessionOptions=Yy.aa)(u0),j._OrtCreateSession=(u0,M0,G0)=>(j._OrtCreateSession=Yy.ba)(u0,M0,G0),j._OrtReleaseSession=u0=>(j._OrtReleaseSession=Yy.ca)(u0),j._OrtGetInputOutputCount=(u0,M0,G0)=>(j._OrtGetInputOutputCount=Yy.da)(u0,M0,G0),j._OrtGetInputName=(u0,M0)=>(j._OrtGetInputName=Yy.ea)(u0,M0),j._OrtGetOutputName=(u0,M0)=>(j._OrtGetOutputName=Yy.fa)(u0,M0),j._OrtFree=u0=>(j._OrtFree=Yy.ga)(u0),j._OrtCreateTensor=(u0,M0,G0,X0,Ky,Xy)=>(j._OrtCreateTensor=Yy.ha)(u0,M0,G0,X0,Ky,Xy),j._OrtGetTensorData=(u0,M0,G0,X0,Ky)=>(j._OrtGetTensorData=Yy.ia)(u0,M0,G0,X0,Ky),j._OrtReleaseTensor=u0=>(j._OrtReleaseTensor=Yy.ja)(u0),j._OrtCreateRunOptions=(u0,M0,G0,X0)=>(j._OrtCreateRunOptions=Yy.ka)(u0,M0,G0,X0),j._OrtAddRunConfigEntry=(u0,M0,G0)=>(j._OrtAddRunConfigEntry=Yy.la)(u0,M0,G0),j._OrtReleaseRunOptions=u0=>(j._OrtReleaseRunOptions=Yy.ma)(u0),j._OrtCreateBinding=u0=>(j._OrtCreateBinding=Yy.na)(u0),j._OrtBindInput=(u0,M0,G0)=>(j._OrtBindInput=Yy.oa)(u0,M0,G0),j._OrtBindOutput=(u0,M0,G0,X0)=>(j._OrtBindOutput=Yy.pa)(u0,M0,G0,X0),j._OrtClearBoundOutputs=u0=>(j._OrtClearBoundOutputs=Yy.qa)(u0),j._OrtReleaseBinding=u0=>(j._OrtReleaseBinding=Yy.ra)(u0),j._OrtRunWithBinding=(u0,M0,G0,X0,Ky)=>(j._OrtRunWithBinding=Yy.sa)(u0,M0,G0,X0,Ky),j._OrtRun=(u0,M0,G0,X0,Ky,Xy,_v,A_)=>(j._OrtRun=Yy.ta)(u0,M0,G0,X0,Ky,Xy,_v,A_),j._OrtEndProfiling=u0=>(j._OrtEndProfiling=Yy.ua)(u0);var w_=()=>(w_=Yy.va)(),Ov=j._pthread_self=()=>(Ov=j._pthread_self=Yy.wa)(),Qv=j._malloc=u0=>(Qv=j._malloc=Yy.xa)(u0);j._free=u0=>(j._free=Yy.ya)(u0),j.__emscripten_tls_init=()=>(j.__emscripten_tls_init=Yy.za)();var s_=j.__emscripten_thread_init=(u0,M0,G0,X0,Ky,Xy)=>(s_=j.__emscripten_thread_init=Yy.Ba)(u0,M0,G0,X0,Ky,Xy);j.__emscripten_thread_crashed=()=>(j.__emscripten_thread_crashed=Yy.Ca)();var S_=(u0,M0,G0,X0)=>(S_=Yy.Da)(u0,M0,G0,X0),B_=u0=>(B_=Yy.Ea)(u0),z_=j.__emscripten_thread_exit=u0=>(z_=j.__emscripten_thread_exit=Yy.Fa)(u0),D1=()=>(D1=Yy.Ga)(),B1=u0=>(B1=Yy.Ha)(u0),m1=(u0,M0)=>(m1=Yy.Ia)(u0,M0),S1=()=>(S1=Yy.Ja)(),vw=u0=>(vw=Yy.Ka)(u0),Hw=u0=>(Hw=Yy.La)(u0);function Cw(){var u0=Yy;u0=Object.assign({},u0);var M0=X0=>()=>X0()>>>0,G0=X0=>Ky=>X0(Ky)>>>0;return u0.va=M0(u0.va),u0.wa=M0(u0.wa),u0.xa=G0(u0.xa),u0.emscripten_main_runtime_thread_id=M0(u0.emscripten_main_runtime_thread_id),u0.Ja=M0(u0.Ja),u0.La=G0(u0.La),u0}j.wasmMemory=Y0,j.stackAlloc=Hw,j.stackSave=S1,j.stackRestore=vw,j.keepRuntimeAlive=()=>0<Dy,j.UTF8ToString=av,j.stringToUTF8=Vv,j.lengthBytesUTF8=Sv,j.ExitStatus=b0,j.PThread=O0;var H1;iv=function u0(){H1||W1(),H1||(iv=u0)};function W1(){if(!(0<Zy))if(fr)b(j),fr||oy(Uy),startWorker(j);else{if(j.preRun)for(typeof j.preRun=="function"&&(j.preRun=[j.preRun]);j.preRun.length;)Ty.unshift(j.preRun.shift());oy(Ty),0<Zy||H1||(H1=!0,j.calledRun=!0,ty||(fr||oy(Uy),b(j),fr||oy(Qy)))}}return W1(),d.ready}})();typeof a=="object"&&typeof e=="object"?e.exports=o:typeof define=="function"&&define.amd&&define([],()=>o)}),Rp$1=me((a,e)=>{e.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed?.(),a}}self.onmessage=handleMessage;\n'}),Gp$1,lg,aa$1,sa$1,Po$1,Mp$1,fg,cg,pg,Up$1,Le,Vr=E(()=>{Gp$1=Dp$1(),lg=Np$1(),sa$1=!1,Po$1=!1,Mp$1=!1,fg=a=>{if(a===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+a+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+a+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},cg=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},pg=(a,e)=>a?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":e?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Up$1=async a=>{if(sa$1)return Promise.resolve();if(Po$1)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Mp$1)throw new Error("previous call to 'initializeWebAssembly()' failed.");Po$1=!0;let e=a.initTimeout,o=a.numThreads,s=a.simd,d=fg(o),c=s&&cg(),h=a.wasmPaths,_=typeof h=="string"?h:void 0,bt=pg(c,d),g=typeof h=="object"?h[bt]:void 0,j=!1,b=[];if(e>0&&b.push(new Promise(Et=>{setTimeout(()=>{j=!0,Et()},e)})),b.push(new Promise((Et,It)=>{let zt=d?lg:Gp$1,er={locateFile:(Hn,Qt)=>d&&Hn.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([Rp$1()],{type:"text/javascript"})):Hn.endsWith(".wasm")?g||(_??Qt)+bt:Qt+Hn};if(d)if(er.numThreads=o,typeof Blob>"u")er.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let Hn=`var ortWasmThreaded=${zt.toString()};`;er.mainScriptUrlOrBlob=new Blob([Hn],{type:"text/javascript"})}zt(er).then(Hn=>{Po$1=!1,sa$1=!0,aa$1=Hn,Et()},Hn=>{Po$1=!1,Mp$1=!0,It(Hn)})})),await Promise.race(b),j)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},Le=()=>{if(sa$1&&aa$1)return aa$1;throw new Error("WebAssembly is not initialized yet.")}}),_e$1,yn$1,Oe$1,Eo$1=E(()=>{Vr(),_e$1=(a,e)=>{let o=Le(),s=o.lengthBytesUTF8(a)+1,d=o._malloc(s);return o.stringToUTF8(a,d,s),e.push(d),d},yn$1=(a,e,o,s)=>{if(typeof a=="object"&&a!==null){if(o.has(a))throw new Error("Circular reference in options");o.add(a)}Object.entries(a).forEach(([d,c])=>{let h=e?e+d:d;if(typeof c=="object")yn$1(c,h+".",o,s);else if(typeof c=="string"||typeof c=="number")s(h,c.toString());else if(typeof c=="boolean")s(h,c?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof c}`)})},Oe$1=a=>{let e=Le(),o=e.stackSave();try{let s=e.stackAlloc(8);e._OrtGetLastError(s,s+4);let d=e.HEAP32[s/4],c=e.HEAPU32[s/4+1],h=c?e.UTF8ToString(c):"";throw new Error(`${a} ERROR_CODE: ${d}, ERROR_MESSAGE: ${h}`)}finally{e.stackRestore(o)}}}),zp$1,Vp$1=E(()=>{Vr(),Eo$1(),zp$1=a=>{let e=Le(),o=0,s=[],d=a||{};try{if((a==null?void 0:a.logSeverityLevel)===void 0)d.logSeverityLevel=2;else if(typeof a.logSeverityLevel!="number"||!Number.isInteger(a.logSeverityLevel)||a.logSeverityLevel<0||a.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${a.logSeverityLevel}`);if((a==null?void 0:a.logVerbosityLevel)===void 0)d.logVerbosityLevel=0;else if(typeof a.logVerbosityLevel!="number"||!Number.isInteger(a.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${a.logVerbosityLevel}`);(a==null?void 0:a.terminate)===void 0&&(d.terminate=!1);let c=0;return(a==null?void 0:a.tag)!==void 0&&(c=_e$1(a.tag,s)),o=e._OrtCreateRunOptions(d.logSeverityLevel,d.logVerbosityLevel,!!d.terminate,c),o===0&&Oe$1("Can't create run options."),(a==null?void 0:a.extra)!==void 0&&yn$1(a.extra,"",new WeakSet,(h,_)=>{let bt=_e$1(h,s),g=_e$1(_,s);e._OrtAddRunConfigEntry(o,bt,g)!==0&&Oe$1(`Can't set a run config entry: ${h} - ${_}.`)}),[o,s]}catch(c){throw o!==0&&e._OrtReleaseRunOptions(o),s.forEach(h=>e._free(h)),c}}}),dg,hg,mg,bg,Wp$1,Hp$1=E(()=>{Vr(),Eo$1(),dg=a=>{switch(a){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${a}`)}},hg=a=>{switch(a){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${a}`)}},mg=a=>{a.extra||(a.extra={}),a.extra.session||(a.extra.session={});let e=a.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),a.executionProviders&&a.executionProviders.some(o=>(typeof o=="string"?o:o.name)==="webgpu")&&(a.enableMemPattern=!1)},bg=(a,e,o)=>{for(let s of e){let d=typeof s=="string"?s:s.name;switch(d){case"webnn":if(d="WEBNN",typeof s!="string"){let h=s;if(h!=null&&h.deviceType){let _=_e$1("deviceType",o),bt=_e$1(h.deviceType,o);Le()._OrtAddSessionConfigEntry(a,_,bt)!==0&&Oe$1(`Can't set a session config entry: 'deviceType' - ${h.deviceType}.`)}if(h!=null&&h.numThreads){let _=h.numThreads;(typeof _!="number"||!Number.isInteger(_)||_<0)&&(_=0);let bt=_e$1("numThreads",o),g=_e$1(_.toString(),o);Le()._OrtAddSessionConfigEntry(a,bt,g)!==0&&Oe$1(`Can't set a session config entry: 'numThreads' - ${h.numThreads}.`)}if(h!=null&&h.powerPreference){let _=_e$1("powerPreference",o),bt=_e$1(h.powerPreference,o);Le()._OrtAddSessionConfigEntry(a,_,bt)!==0&&Oe$1(`Can't set a session config entry: 'powerPreference' - ${h.powerPreference}.`)}}break;case"webgpu":if(d="JS",typeof s!="string"){let h=s;if(h!=null&&h.preferredLayout){if(h.preferredLayout!=="NCHW"&&h.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${h.preferredLayout}`);let _=_e$1("preferredLayout",o),bt=_e$1(h.preferredLayout,o);Le()._OrtAddSessionConfigEntry(a,_,bt)!==0&&Oe$1(`Can't set a session config entry: 'preferredLayout' - ${h.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${d}`)}let c=_e$1(d,o);Le()._OrtAppendExecutionProvider(a,c)!==0&&Oe$1(`Can't append execution provider: ${d}.`)}},Wp$1=a=>{let e=Le(),o=0,s=[],d=a||{};mg(d);try{let c=dg(d.graphOptimizationLevel??"all"),h=hg(d.executionMode??"sequential"),_=typeof d.logId=="string"?_e$1(d.logId,s):0,bt=d.logSeverityLevel??2;if(!Number.isInteger(bt)||bt<0||bt>4)throw new Error(`log serverity level is not valid: ${bt}`);let g=d.logVerbosityLevel??0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);let j=typeof d.optimizedModelFilePath=="string"?_e$1(d.optimizedModelFilePath,s):0;if(o=e._OrtCreateSessionOptions(c,!!d.enableCpuMemArena,!!d.enableMemPattern,h,!!d.enableProfiling,0,_,bt,g,j),o===0&&Oe$1("Can't create session options."),d.executionProviders&&bg(o,d.executionProviders,s),d.enableGraphCapture!==void 0){if(typeof d.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${d.enableGraphCapture}`);let b=_e$1("enableGraphCapture",s),Et=_e$1(d.enableGraphCapture.toString(),s);e._OrtAddSessionConfigEntry(o,b,Et)!==0&&Oe$1(`Can't set a session config entry: 'enableGraphCapture' - ${d.enableGraphCapture}.`)}if(d.freeDimensionOverrides)for(let[b,Et]of Object.entries(d.freeDimensionOverrides)){if(typeof b!="string")throw new Error(`free dimension override name must be a string: ${b}`);if(typeof Et!="number"||!Number.isInteger(Et)||Et<0)throw new Error(`free dimension override value must be a non-negative integer: ${Et}`);let It=_e$1(b,s);e._OrtAddFreeDimensionOverride(o,It,Et)!==0&&Oe$1(`Can't set a free dimension override: ${b} - ${Et}.`)}return d.extra!==void 0&&yn$1(d.extra,"",new WeakSet,(b,Et)=>{let It=_e$1(b,s),zt=_e$1(Et,s);e._OrtAddSessionConfigEntry(o,It,zt)!==0&&Oe$1(`Can't set a session config entry: ${b} - ${Et}.`)}),[o,s]}catch(c){throw o!==0&&e._OrtReleaseSessionOptions(o),s.forEach(h=>e._free(h)),c}}}),ua$1,qp$1,la$1,jp$1,Yp$1,Do$1,Xp$1,fa$1=E(()=>{ua$1=a=>{switch(a){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${a}`)}},qp$1=a=>{switch(a){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${a}`)}},la$1=a=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][a],jp$1=a=>{switch(a){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${a}`)}},Yp$1=a=>{switch(a){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${a}`)}},Do$1=a=>a==="float32"||a==="float16"||a==="int32"||a==="int64"||a==="uint32"||a==="uint8"||a==="bool",Xp$1=a=>{switch(a){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${a}`)}}}),Tn$1,ca$1=E(()=>{Tn$1=async a=>{if(typeof a=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(a))}catch(e){if(e.code==="ERR_FS_FILE_TOO_LARGE"){let o=(void 0)(a),s=[];for await(let d of o)s.push(d);return new Uint8Array(Buffer.concat(s))}throw e}else{let e=await fetch(a);if(!e.ok)throw new Error(`failed to load external data file: ${a}`);let o=e.headers.get("Content-Length"),s=o?parseInt(o,10):0;if(s<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${a}, no response body.`);let d=e.body.getReader(),c;try{c=new ArrayBuffer(s)}catch(_){if(_ instanceof RangeError){let bt=Math.ceil(s/65536);c=new WebAssembly.Memory({initial:bt,maximum:bt}).buffer}else throw _}let h=0;for(;;){let{done:_,value:bt}=await d.read();if(_)break;let g=bt.byteLength;new Uint8Array(c,h,g).set(bt),h+=g}return new Uint8Array(c,0,s)}}else return a instanceof Blob?new Uint8Array(await a.arrayBuffer()):a instanceof Uint8Array?a:new Uint8Array(a)}}),gg,Jp$1,Zp$1,Wr,yg,pa$1,Qp$1,ed,Kp$1,td,rd,nd,od=E(()=>{Vp$1(),Hp$1(),fa$1(),Vr(),Eo$1(),ca$1(),gg=(a,e)=>{Le()._OrtInit(a,e)!==0&&Oe$1("Can't initialize onnxruntime.")},Jp$1=async a=>{gg(a.wasm.numThreads,Yp$1(a.logLevel))},Zp$1=async(a,e)=>{},Wr=new Map,yg=a=>{let e=Le(),o=e.stackSave();try{let s=e.stackAlloc(8);return e._OrtGetInputOutputCount(a,s,s+4)!==0&&Oe$1("Can't get session input/output count."),[e.HEAP32[s/4],e.HEAP32[s/4+1]]}finally{e.stackRestore(o)}},pa$1=a=>{let e=Le(),o=e._malloc(a.byteLength);if(o===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${a.byteLength}.`);return e.HEAPU8.set(a,o),[o,a.byteLength]},Qp$1=async(a,e)=>{var j;let o,s,d=Le();Array.isArray(a)?[o,s]=a:a.buffer===d.HEAPU8.buffer?[o,s]=[a.byteOffset,a.byteLength]:[o,s]=pa$1(a);let c=0,h=0,_=[],bt=[],g=[];try{if([h,_]=Wp$1(e),(e==null?void 0:e.externalData)&&d.mountExternalData){let cr=[];for(let fr of e.externalData){let jr=typeof fr=="string"?fr:fr.path;cr.push(Tn$1(typeof fr=="string"?fr:fr.data).then(e0=>{d.mountExternalData(jr,e0)}))}await Promise.all(cr)}c=await d._OrtCreateSession(o,s,h),c===0&&Oe$1("Can't create a session.");let[b,Et]=yg(c),It=!!(e!=null&&e.enableGraphCapture),zt=[],er=[],Hn=[];for(let cr=0;cr<b;cr++){let fr=d._OrtGetInputName(c,cr);fr===0&&Oe$1("Can't get an input name."),bt.push(fr),zt.push(d.UTF8ToString(fr))}for(let cr=0;cr<Et;cr++){let fr=d._OrtGetOutputName(c,cr);fr===0&&Oe$1("Can't get an output name."),g.push(fr);let jr=d.UTF8ToString(fr);er.push(jr)}return Wr.set(c,[c,bt,g,null,It,!1]),[c,zt,er]}catch(b){throw bt.forEach(Et=>d._OrtFree(Et)),g.forEach(Et=>d._OrtFree(Et)),c!==0&&d._OrtReleaseSession(c),b}finally{d._free(o),h!==0&&d._OrtReleaseSessionOptions(h),_.forEach(b=>d._free(b)),(j=d.unmountExternalData)==null||j.call(d)}},ed=a=>{var bt;let e=Le(),o=Wr.get(a);if(!o)throw new Error(`cannot release session. invalid session id: ${a}`);let[s,d,c,h,_]=o;h&&(_&&e._OrtClearBoundOutputs(h.handle),e._OrtReleaseBinding(h.handle)),(bt=e.jsepOnReleaseSession)==null||bt.call(e,a),d.forEach(g=>e._OrtFree(g)),c.forEach(g=>e._OrtFree(g)),e._OrtReleaseSession(s),Wr.delete(a)},Kp$1=(a,e,o,s,d,c=!1)=>{if(!a){e.push(0);return}let h=Le(),_=a[0],bt=a[1],g=a[3],j,b;if(_==="string"&&g==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(c&&g!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${d} when enableGraphCapture is true.`);if(g==="gpu-buffer"){let zt=a[2].gpuBuffer,er=la$1(ua$1(_));b=bt.reduce((Qt,cr)=>Qt*cr,1)*er;let Hn=h.jsepRegisterBuffer;if(!Hn)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');j=Hn(s,d,zt,b)}else{let zt=a[2];if(Array.isArray(zt)){b=4*zt.length,j=h._malloc(b),o.push(j);let er=j/4;for(let Hn=0;Hn<zt.length;Hn++){if(typeof zt[Hn]!="string")throw new TypeError(`tensor data at index ${Hn} is not a string`);h.HEAPU32[er++]=_e$1(zt[Hn],o)}}else b=zt.byteLength,j=h._malloc(b),o.push(j),h.HEAPU8.set(new Uint8Array(zt.buffer,zt.byteOffset,b),j)}let Et=h.stackSave(),It=h.stackAlloc(4*bt.length);try{let zt=It/4;bt.forEach(Hn=>h.HEAP32[zt++]=Hn);let er=h._OrtCreateTensor(ua$1(_),j,b,It,bt.length,Xp$1(g));er===0&&Oe$1(`Can't create tensor for input/output. session=${s}, index=${d}.`),e.push(er)}finally{h.stackRestore(Et)}},td=async(a,e,o,s,d,c)=>{var g0;let h=Le(),_=Wr.get(a);if(!_)throw new Error(`cannot run inference. invalid session id: ${a}`);let bt=_[0],g=_[1],j=_[2],b=_[3],Et=_[4];_[5];let It=e.length,zt=s.length,er=0,Hn=[],Qt=[],cr=[],fr=[],jr=h.stackSave(),e0=h.stackAlloc(It*4),t0=h.stackAlloc(It*4),o0=h.stackAlloc(zt*4),l0=h.stackAlloc(zt*4);try{[er,Hn]=zp$1(c);for(let H0=0;H0<It;H0++)Kp$1(o[H0],Qt,fr,a,e[H0],Et);for(let H0=0;H0<zt;H0++)Kp$1(d[H0],cr,fr,a,It+s[H0],Et);let i0=e0/4,f0=t0/4,C0=o0/4,Z0=l0/4;for(let H0=0;H0<It;H0++)h.HEAPU32[i0++]=Qt[H0],h.HEAPU32[f0++]=g[e[H0]];for(let H0=0;H0<zt;H0++)h.HEAPU32[C0++]=cr[H0],h.HEAPU32[Z0++]=j[s[H0]];(g0=h.jsepOnRunStart)==null||g0.call(h,bt);let R0;R0=await h._OrtRun(bt,t0,e0,It,l0,zt,o0,er),R0!==0&&Oe$1("failed to call OrtRun().");let Y0=[];for(let H0=0;H0<zt;H0++){let ty=h.HEAPU32[o0/4+H0];if(ty===cr[H0]){Y0.push(d[H0]);continue}let w0=h.stackSave(),L0=h.stackAlloc(4*4),k0=!1,T0,q0=0;try{h._OrtGetTensorData(ty,L0,L0+4,L0+8,L0+12)!==0&&Oe$1(`Can't access output tensor data on index ${H0}.`);let vy=L0/4,J0=h.HEAPU32[vy++];q0=h.HEAPU32[vy++];let cy=h.HEAPU32[vy++],Ty=h.HEAPU32[vy++],Uy=[];for(let iv=0;iv<Ty;iv++)Uy.push(h.HEAPU32[cy/4+iv]);h._OrtFree(cy);let Qy=Uy.reduce((iv,zy)=>iv*zy,1);T0=qp$1(J0);let Zy=b==null?void 0:b.outputPreferredLocations[s[H0]];if(T0==="string"){if(Zy==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let iv=[],zy=q0/4;for(let B0=0;B0<Qy;B0++){let Ay=h.HEAPU32[zy++],hy=B0===Qy-1?void 0:h.HEAPU32[zy]-Ay;iv.push(h.UTF8ToString(Ay,hy))}Y0.push([T0,Uy,iv,"cpu"])}else if(Zy==="gpu-buffer"&&Qy>0){let iv=h.jsepGetBuffer;if(!iv)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let zy=iv(q0),B0=la$1(J0);if(B0===void 0||!Do$1(T0))throw new Error(`Unsupported data type: ${T0}`);k0=!0,Y0.push([T0,Uy,{gpuBuffer:zy,download:h.jsepCreateDownloader(zy,Qy*B0,T0),dispose:()=>{h._OrtReleaseTensor(ty)}},"gpu-buffer"])}else{let iv=jp$1(T0),zy=new iv(Qy);new Uint8Array(zy.buffer,zy.byteOffset,zy.byteLength).set(h.HEAPU8.subarray(q0,q0+zy.byteLength)),Y0.push([T0,Uy,zy,"cpu"])}}finally{h.stackRestore(w0),T0==="string"&&q0&&h._free(q0),k0||h._OrtReleaseTensor(ty)}}return b&&!Et&&(h._OrtClearBoundOutputs(b.handle),Wr.set(a,[bt,g,j,b,Et,!1])),Y0}finally{h.stackRestore(jr),Qt.forEach(i0=>h._OrtReleaseTensor(i0)),cr.forEach(i0=>h._OrtReleaseTensor(i0)),fr.forEach(i0=>h._free(i0)),er!==0&&h._OrtReleaseRunOptions(er),Hn.forEach(i0=>h._free(i0))}},rd=a=>{let e=Le(),o=Wr.get(a);if(!o)throw new Error("invalid session id");let s=o[0],d=e._OrtEndProfiling(s);d===0&&Oe$1("Can't get an profile file name."),e._OrtFree(d)},nd=a=>{let e=[];for(let o of a){let s=o[2];!Array.isArray(s)&&"buffer"in s&&e.push(s.buffer)}return e}}),id=me((a,e)=>{e.exports='/*!\n * ONNX Runtime Web v1.17.3\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var Et=Object.defineProperty;var Jr=Object.getOwnPropertyDescriptor;var Xr=Object.getOwnPropertyNames;var Qr=Object.prototype.hasOwnProperty;var St=(u,c)=>()=>(u&&(c=u(u=0)),c);var tt=(u,c)=>()=>(c||u((c={exports:{}}).exports,c),c.exports),At=(u,c)=>{for(var a in c)Et(u,a,{get:c[a],enumerable:!0})},Zr=(u,c,a,h)=>{if(c&&typeof c=="object"||typeof c=="function")for(let f of Xr(c))!Qr.call(u,f)&&f!==a&&Et(u,f,{get:()=>c[f],enumerable:!(h=Jr(c,f))||h.enumerable});return u};var rt=u=>Zr(Et({},"__esModule",{value:!0}),u);var Tt={};At(Tt,{createReadStream:()=>dr,readFile:()=>Kr,readFileSync:()=>en});var Kr,en,dr,Mt=St(()=>{Kr=void 0,en=void 0,dr=void 0});var Ct={};At(Ct,{join:()=>tn});var tn,Dt=St(()=>{tn=void 0});var gr=tt((mr,Ft)=>{"use strict";var pr=(()=>{var u=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(u=u||__filename),function(c={}){var a=c,h,f;a.ready=new Promise((r,o)=>{h=r,f=o});var w=Object.assign({},a),g="./this.program",i=typeof window=="object",E=typeof importScripts=="function",P=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",U="",D,x,K;if(P){var R=(Mt(),rt(Tt)),I=(Dt(),rt(Ct));U=E?I.dirname(U)+"/":__dirname+"/",D=(r,o)=>(r=ve(r)?new URL(r):I.normalize(r),R.readFileSync(r,o?void 0:"utf8")),K=r=>(r=D(r,!0),r.buffer||(r=new Uint8Array(r)),r),x=(r,o,s,m=!0)=>{r=ve(r)?new URL(r):I.normalize(r),R.readFile(r,m?void 0:"utf8",(O,A)=>{O?s(O):o(m?A.buffer:A)})},!a.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),a.inspect=()=>"[Emscripten Module object]"}else(i||E)&&(E?U=self.location.href:typeof document<"u"&&document.currentScript&&(U=document.currentScript.src),u&&(U=u),U.indexOf("blob:")!==0?U=U.substr(0,U.replace(/[?#].*/,"").lastIndexOf("/")+1):U="",D=r=>{var o=new XMLHttpRequest;return o.open("GET",r,!1),o.send(null),o.responseText},E&&(K=r=>{var o=new XMLHttpRequest;return o.open("GET",r,!1),o.responseType="arraybuffer",o.send(null),new Uint8Array(o.response)}),x=(r,o,s)=>{var m=new XMLHttpRequest;m.open("GET",r,!0),m.responseType="arraybuffer",m.onload=()=>{m.status==200||m.status==0&&m.response?o(m.response):s()},m.onerror=s,m.send(null)});var v=console.log.bind(console),k=console.error.bind(console);Object.assign(a,w),w=null,typeof WebAssembly!="object"&&F("no native wasm support detected");var W,H=!1,se,ee,S,j,Ce;function Ue(){var r=W.buffer;a.HEAP8=se=new Int8Array(r),a.HEAP16=new Int16Array(r),a.HEAPU8=ee=new Uint8Array(r),a.HEAPU16=new Uint16Array(r),a.HEAP32=S=new Int32Array(r),a.HEAPU32=j=new Uint32Array(r),a.HEAPF32=new Float32Array(r),a.HEAPF64=Ce=new Float64Array(r)}var ce=[],ne=[],Q=[],Oe=0,he=null,ae=null;function F(r){throw r="Aborted("+r+")",k(r),H=!0,r=new WebAssembly.RuntimeError(r+". Build with -sASSERTIONS for more info."),f(r),r}var ye=r=>r.startsWith("data:application/octet-stream;base64,"),ve=r=>r.startsWith("file://"),fe;if(fe="ort-wasm.wasm",!ye(fe)){var _e=fe;fe=a.locateFile?a.locateFile(_e,U):U+_e}function Y(r){if(K)return K(r);throw"both async and sync fetching of the wasm failed"}function pe(r){if(i||E){if(typeof fetch=="function"&&!ve(r))return fetch(r,{credentials:"same-origin"}).then(o=>{if(!o.ok)throw"failed to load wasm binary file at \'"+r+"\'";return o.arrayBuffer()}).catch(()=>Y(r));if(x)return new Promise((o,s)=>{x(r,m=>o(new Uint8Array(m)),s)})}return Promise.resolve().then(()=>Y(r))}function Ie(r,o,s){return pe(r).then(m=>WebAssembly.instantiate(m,o)).then(m=>m).then(s,m=>{k(`failed to asynchronously prepare wasm: ${m}`),F(m)})}function Ee(r,o){var s=fe;return typeof WebAssembly.instantiateStreaming!="function"||ye(s)||ve(s)||P||typeof fetch!="function"?Ie(s,r,o):fetch(s,{credentials:"same-origin"}).then(m=>WebAssembly.instantiateStreaming(m,r).then(o,function(O){return k(`wasm streaming compile failed: ${O}`),k("falling back to ArrayBuffer instantiation"),Ie(s,r,o)}))}var be,we={920016:(r,o,s,m)=>{if(typeof a>"u"||!a.za)return 1;if(r=z(r>>>0),r.startsWith("./")&&(r=r.substring(2)),r=a.za.get(r),!r)return 2;if(o>>>=0,s>>>=0,o+s>r.byteLength)return 3;try{return ee.set(r.subarray(o,o+s),m>>>0>>>0),0}catch{return 4}}};function Le(r){this.xa=r-24,this.Ha=function(o){j[this.xa+4>>>2>>>0]=o},this.Ga=function(o){j[this.xa+8>>>2>>>0]=o},this.Aa=function(o,s){this.Fa(),this.Ha(o),this.Ga(s)},this.Fa=function(){j[this.xa+16>>>2>>>0]=0}}var me=0,Se=0,De=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,te=(r,o,s)=>{o>>>=0;var m=o+s;for(s=o;r[s]&&!(s>=m);)++s;if(16<s-o&&r.buffer&&De)return De.decode(r.subarray(o,s));for(m="";o<s;){var O=r[o++];if(O&128){var A=r[o++]&63;if((O&224)==192)m+=String.fromCharCode((O&31)<<6|A);else{var L=r[o++]&63;O=(O&240)==224?(O&15)<<12|A<<6|L:(O&7)<<18|A<<12|L<<6|r[o++]&63,65536>O?m+=String.fromCharCode(O):(O-=65536,m+=String.fromCharCode(55296|O>>10,56320|O&1023))}}else m+=String.fromCharCode(O)}return m},z=(r,o)=>(r>>>=0)?te(ee,r,o):"",le=r=>{for(var o=0,s=0;s<r.length;++s){var m=r.charCodeAt(s);127>=m?o++:2047>=m?o+=2:55296<=m&&57343>=m?(o+=4,++s):o+=3}return o},Fe=(r,o,s,m)=>{if(s>>>=0,!(0<m))return 0;var O=s;m=s+m-1;for(var A=0;A<r.length;++A){var L=r.charCodeAt(A);if(55296<=L&&57343>=L){var re=r.charCodeAt(++A);L=65536+((L&1023)<<10)|re&1023}if(127>=L){if(s>=m)break;o[s++>>>0]=L}else{if(2047>=L){if(s+1>=m)break;o[s++>>>0]=192|L>>6}else{if(65535>=L){if(s+2>=m)break;o[s++>>>0]=224|L>>12}else{if(s+3>=m)break;o[s++>>>0]=240|L>>18,o[s++>>>0]=128|L>>12&63}o[s++>>>0]=128|L>>6&63}o[s++>>>0]=128|L&63}}return o[s>>>0]=0,s-O},Ae=r=>r%4===0&&(r%100!==0||r%400===0),qe=[0,31,60,91,121,152,182,213,244,274,305,335],at=[0,31,59,90,120,151,181,212,243,273,304,334],xe=r=>{var o=le(r)+1,s=st(o);return s&&Fe(r,ee,s,o),s},Ne=[],Re={},He=()=>{if(!Ge){var r={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"},o;for(o in Re)Re[o]===void 0?delete r[o]:r[o]=Re[o];var s=[];for(o in r)s.push(`${o}=${r[o]}`);Ge=s}return Ge},Ge,Be=[null,[],[]],Ve=[31,29,31,30,31,30,31,31,30,31,30,31],Je=[31,28,31,30,31,30,31,31,30,31,30,31];function $e(r){var o=Array(le(r)+1);return Fe(r,o,0,o.length),o}function ot(r,o,s,m){function O(d,B,$){for(d=typeof d=="number"?d.toString():d||"";d.length<B;)d=$[0]+d;return d}function A(d,B){return O(d,B,"0")}function L(d,B){function $(et){return 0>et?-1:0<et?1:0}var Te;return(Te=$(d.getFullYear()-B.getFullYear()))===0&&(Te=$(d.getMonth()-B.getMonth()))===0&&(Te=$(d.getDate()-B.getDate())),Te}function re(d){switch(d.getDay()){case 0:return new Date(d.getFullYear()-1,11,29);case 1:return d;case 2:return new Date(d.getFullYear(),0,3);case 3:return new Date(d.getFullYear(),0,2);case 4:return new Date(d.getFullYear(),0,1);case 5:return new Date(d.getFullYear()-1,11,31);case 6:return new Date(d.getFullYear()-1,11,30)}}function de(d){var B=d.ta;for(d=new Date(new Date(d.ua+1900,0,1).getTime());0<B;){var $=d.getMonth(),Te=(Ae(d.getFullYear())?Ve:Je)[$];if(B>Te-d.getDate())B-=Te-d.getDate()+1,d.setDate(1),11>$?d.setMonth($+1):(d.setMonth(0),d.setFullYear(d.getFullYear()+1));else{d.setDate(d.getDate()+B);break}}return $=new Date(d.getFullYear()+1,0,4),B=re(new Date(d.getFullYear(),0,4)),$=re($),0>=L(B,d)?0>=L($,d)?d.getFullYear()+1:d.getFullYear():d.getFullYear()-1}r>>>=0,o>>>=0,s>>>=0,m>>>=0;var ie=j[m+40>>>2>>>0];m={Da:S[m>>>2>>>0],Ca:S[m+4>>>2>>>0],va:S[m+8>>>2>>>0],ya:S[m+12>>>2>>>0],wa:S[m+16>>>2>>>0],ua:S[m+20>>>2>>>0],oa:S[m+24>>>2>>>0],ta:S[m+28>>>2>>>0],Ia:S[m+32>>>2>>>0],Ba:S[m+36>>>2>>>0],Ea:ie?z(ie):""},s=z(s),ie={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ue in ie)s=s.replace(new RegExp(ue,"g"),ie[ue]);var Ze="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ke="January February March April May June July August September October November December".split(" ");ie={"%a":d=>Ze[d.oa].substring(0,3),"%A":d=>Ze[d.oa],"%b":d=>Ke[d.wa].substring(0,3),"%B":d=>Ke[d.wa],"%C":d=>A((d.ua+1900)/100|0,2),"%d":d=>A(d.ya,2),"%e":d=>O(d.ya,2," "),"%g":d=>de(d).toString().substring(2),"%G":d=>de(d),"%H":d=>A(d.va,2),"%I":d=>(d=d.va,d==0?d=12:12<d&&(d-=12),A(d,2)),"%j":d=>{for(var B=0,$=0;$<=d.wa-1;B+=(Ae(d.ua+1900)?Ve:Je)[$++]);return A(d.ya+B,3)},"%m":d=>A(d.wa+1,2),"%M":d=>A(d.Ca,2),"%n":()=>`\n`,"%p":d=>0<=d.va&&12>d.va?"AM":"PM","%S":d=>A(d.Da,2),"%t":()=>"	","%u":d=>d.oa||7,"%U":d=>A(Math.floor((d.ta+7-d.oa)/7),2),"%V":d=>{var B=Math.floor((d.ta+7-(d.oa+6)%7)/7);if(2>=(d.oa+371-d.ta-2)%7&&B++,B)B==53&&($=(d.oa+371-d.ta)%7,$==4||$==3&&Ae(d.ua)||(B=1));else{B=52;var $=(d.oa+7-d.ta-1)%7;($==4||$==5&&Ae(d.ua%400-1))&&B++}return A(B,2)},"%w":d=>d.oa,"%W":d=>A(Math.floor((d.ta+7-(d.oa+6)%7)/7),2),"%y":d=>(d.ua+1900).toString().substring(2),"%Y":d=>d.ua+1900,"%z":d=>{d=d.Ba;var B=0<=d;return d=Math.abs(d)/60,(B?"+":"-")+("0000"+(d/60*100+d%60)).slice(-4)},"%Z":d=>d.Ea,"%%":()=>"%"},s=s.replace(/%%/g,"\\0\\0");for(ue in ie)s.includes(ue)&&(s=s.replace(new RegExp(ue,"g"),ie[ue](m)));return s=s.replace(/\\0\\0/g,"%"),ue=$e(s),ue.length>o?0:(se.set(ue,r>>>0),ue.length-1)}var G={a:function(r,o,s){throw r>>>=0,new Le(r).Aa(o>>>0,s>>>0),me=r,Se++,me},e:function(){return 0},H:function(){},x:function(){},z:function(){},J:function(){return 0},F:function(){},A:function(){},E:function(){},g:function(){},y:function(){},v:function(){},G:function(){},w:function(){},k:()=>1,n:function(r,o,s){r=o+2097152>>>0<4194305-!!r?(r>>>0)+4294967296*o:NaN,s>>>=0,r=new Date(1e3*r),S[s>>>2>>>0]=r.getUTCSeconds(),S[s+4>>>2>>>0]=r.getUTCMinutes(),S[s+8>>>2>>>0]=r.getUTCHours(),S[s+12>>>2>>>0]=r.getUTCDate(),S[s+16>>>2>>>0]=r.getUTCMonth(),S[s+20>>>2>>>0]=r.getUTCFullYear()-1900,S[s+24>>>2>>>0]=r.getUTCDay(),S[s+28>>>2>>>0]=(r.getTime()-Date.UTC(r.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(r,o,s){r=o+2097152>>>0<4194305-!!r?(r>>>0)+4294967296*o:NaN,s>>>=0,r=new Date(1e3*r),S[s>>>2>>>0]=r.getSeconds(),S[s+4>>>2>>>0]=r.getMinutes(),S[s+8>>>2>>>0]=r.getHours(),S[s+12>>>2>>>0]=r.getDate(),S[s+16>>>2>>>0]=r.getMonth(),S[s+20>>>2>>>0]=r.getFullYear()-1900,S[s+24>>>2>>>0]=r.getDay(),S[s+28>>>2>>>0]=(Ae(r.getFullYear())?qe:at)[r.getMonth()]+r.getDate()-1|0,S[s+36>>>2>>>0]=-(60*r.getTimezoneOffset()),o=new Date(r.getFullYear(),6,1).getTimezoneOffset();var m=new Date(r.getFullYear(),0,1).getTimezoneOffset();S[s+32>>>2>>>0]=(o!=m&&r.getTimezoneOffset()==Math.min(m,o))|0},p:function(r){r>>>=0;var o=new Date(S[r+20>>>2>>>0]+1900,S[r+16>>>2>>>0],S[r+12>>>2>>>0],S[r+8>>>2>>>0],S[r+4>>>2>>>0],S[r>>>2>>>0],0),s=S[r+32>>>2>>>0],m=o.getTimezoneOffset(),O=new Date(o.getFullYear(),6,1).getTimezoneOffset(),A=new Date(o.getFullYear(),0,1).getTimezoneOffset(),L=Math.min(A,O);return 0>s?S[r+32>>>2>>>0]=+(O!=A&&L==m):0<s!=(L==m)&&(O=Math.max(A,O),o.setTime(o.getTime()+6e4*((0<s?L:O)-m))),S[r+24>>>2>>>0]=o.getDay(),S[r+28>>>2>>>0]=(Ae(o.getFullYear())?qe:at)[o.getMonth()]+o.getDate()-1|0,S[r>>>2>>>0]=o.getSeconds(),S[r+4>>>2>>>0]=o.getMinutes(),S[r+8>>>2>>>0]=o.getHours(),S[r+12>>>2>>>0]=o.getDate(),S[r+16>>>2>>>0]=o.getMonth(),S[r+20>>>2>>>0]=o.getYear(),r=o.getTime(),isNaN(r)?(S[je()>>>2>>>0]=61,r=-1):r/=1e3,Xe((be=r,1<=+Math.abs(be)?0<be?+Math.floor(be/4294967296)>>>0:~~+Math.ceil((be-+(~~be>>>0))/4294967296)>>>0:0)),r>>>0},l:function(){return-52},m:function(){},t:function(r,o,s){function m(de){return(de=de.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?de[1]:"GMT"}s>>>=0;var O=new Date().getFullYear(),A=new Date(O,0,1),L=new Date(O,6,1);O=A.getTimezoneOffset();var re=L.getTimezoneOffset();j[r>>>0>>>2>>>0]=60*Math.max(O,re),S[o>>>0>>>2>>>0]=+(O!=re),r=m(A),o=m(L),r=xe(r),o=xe(o),re<O?(j[s>>>2>>>0]=r,j[s+4>>>2>>>0]=o):(j[s>>>2>>>0]=o,j[s+4>>>2>>>0]=r)},d:()=>{F("")},B:function(r,o,s){r>>>=0,o>>>=0,s>>>=0,Ne.length=0;for(var m;m=ee[o++>>>0];){var O=m!=105;O&=m!=112,s+=O&&s%8?4:0,Ne.push(m==112?j[s>>>2>>>0]:m==105?S[s>>>2>>>0]:Ce[s>>>3>>>0]),s+=O?8:4}return we[r].apply(null,Ne)},h:()=>Date.now(),u:function(){return 4294901760},b:()=>performance.now(),I:function(r,o,s){return o>>>=0,ee.copyWithin(r>>>0>>>0,o>>>0,o+(s>>>0)>>>0)},s:function(r){r>>>=0;var o=ee.length;if(4294901760<r)return!1;for(var s=1;4>=s;s*=2){var m=o*(1+.2/s);m=Math.min(m,r+100663296);var O=Math;m=Math.max(r,m);e:{O=(O.min.call(O,4294901760,m+(65536-m%65536)%65536)-W.buffer.byteLength+65535)/65536;try{W.grow(O),Ue();var A=1;break e}catch{}A=void 0}if(A)return!0}return!1},C:function(r,o){r>>>=0,o>>>=0;var s=0;return He().forEach((m,O)=>{var A=o+s;for(O=j[r+4*O>>>2>>>0]=A,A=0;A<m.length;++A)se[O++>>>0>>>0]=m.charCodeAt(A);se[O>>>0>>>0]=0,s+=m.length+1}),0},D:function(r,o){r>>>=0,o>>>=0;var s=He();j[r>>>2>>>0]=s.length;var m=0;return s.forEach(O=>m+=O.length+1),j[o>>>2>>>0]=m,0},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(r,o,s,m){o>>>=0,s>>>=0,m>>>=0;for(var O=0,A=0;A<s;A++){var L=j[o>>>2>>>0],re=j[o+4>>>2>>>0];o+=8;for(var de=0;de<re;de++){var ie=ee[L+de>>>0],ue=Be[r];ie===0||ie===10?((r===1?v:k)(te(ue,0)),ue.length=0):ue.push(ie)}O+=re}return j[m>>>2>>>0]=O,0},r:ot,c:function(r,o,s,m){return ot(r>>>0,o>>>0,s>>>0,m>>>0)}},C=function(){function r(s){return C=s.exports,C=ut(),W=C.K,Ue(),ne.unshift(C.L),Oe--,Oe==0&&(he!==null&&(clearInterval(he),he=null),ae&&(s=ae,ae=null,s())),C}var o={a:G};if(Oe++,a.instantiateWasm)try{return a.instantiateWasm(o,r)}catch(s){k(`Module.instantiateWasm callback failed with error: ${s}`),f(s)}return Ee(o,function(s){r(s.instance)}).catch(f),{}}();a._OrtInit=(r,o)=>(a._OrtInit=C.M)(r,o),a._OrtGetLastError=(r,o)=>(a._OrtGetLastError=C.N)(r,o),a._OrtCreateSessionOptions=(r,o,s,m,O,A,L,re,de,ie)=>(a._OrtCreateSessionOptions=C.O)(r,o,s,m,O,A,L,re,de,ie),a._OrtAppendExecutionProvider=(r,o)=>(a._OrtAppendExecutionProvider=C.P)(r,o),a._OrtAddFreeDimensionOverride=(r,o,s)=>(a._OrtAddFreeDimensionOverride=C.Q)(r,o,s),a._OrtAddSessionConfigEntry=(r,o,s)=>(a._OrtAddSessionConfigEntry=C.R)(r,o,s),a._OrtReleaseSessionOptions=r=>(a._OrtReleaseSessionOptions=C.S)(r),a._OrtCreateSession=(r,o,s)=>(a._OrtCreateSession=C.T)(r,o,s),a._OrtReleaseSession=r=>(a._OrtReleaseSession=C.U)(r),a._OrtGetInputOutputCount=(r,o,s)=>(a._OrtGetInputOutputCount=C.V)(r,o,s),a._OrtGetInputName=(r,o)=>(a._OrtGetInputName=C.W)(r,o),a._OrtGetOutputName=(r,o)=>(a._OrtGetOutputName=C.X)(r,o),a._OrtFree=r=>(a._OrtFree=C.Y)(r),a._OrtCreateTensor=(r,o,s,m,O,A)=>(a._OrtCreateTensor=C.Z)(r,o,s,m,O,A),a._OrtGetTensorData=(r,o,s,m,O)=>(a._OrtGetTensorData=C._)(r,o,s,m,O),a._OrtReleaseTensor=r=>(a._OrtReleaseTensor=C.$)(r),a._OrtCreateRunOptions=(r,o,s,m)=>(a._OrtCreateRunOptions=C.aa)(r,o,s,m),a._OrtAddRunConfigEntry=(r,o,s)=>(a._OrtAddRunConfigEntry=C.ba)(r,o,s),a._OrtReleaseRunOptions=r=>(a._OrtReleaseRunOptions=C.ca)(r),a._OrtCreateBinding=r=>(a._OrtCreateBinding=C.da)(r),a._OrtBindInput=(r,o,s)=>(a._OrtBindInput=C.ea)(r,o,s),a._OrtBindOutput=(r,o,s,m)=>(a._OrtBindOutput=C.fa)(r,o,s,m),a._OrtClearBoundOutputs=r=>(a._OrtClearBoundOutputs=C.ga)(r),a._OrtReleaseBinding=r=>(a._OrtReleaseBinding=C.ha)(r),a._OrtRunWithBinding=(r,o,s,m,O)=>(a._OrtRunWithBinding=C.ia)(r,o,s,m,O),a._OrtRun=(r,o,s,m,O,A,L,re)=>(a._OrtRun=C.ja)(r,o,s,m,O,A,L,re),a._OrtEndProfiling=r=>(a._OrtEndProfiling=C.ka)(r);var je=()=>(je=C.la)(),st=a._malloc=r=>(st=a._malloc=C.ma)(r);a._free=r=>(a._free=C.na)(r);var Xe=r=>(Xe=C.pa)(r),it=()=>(it=C.qa)(),M=r=>(M=C.ra)(r),ke=r=>(ke=C.sa)(r);function ut(){var r=C;r=Object.assign({},r);var o=m=>()=>m()>>>0,s=m=>O=>m(O)>>>0;return r.la=o(r.la),r.ma=s(r.ma),r.qa=o(r.qa),r.sa=s(r.sa),r}a.stackAlloc=ke,a.stackSave=it,a.stackRestore=M,a.UTF8ToString=z,a.stringToUTF8=(r,o,s)=>Fe(r,ee,o,s),a.lengthBytesUTF8=le;var Pe;ae=function r(){Pe||Qe(),Pe||(ae=r)};function Qe(){if(!(0<Oe)){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;){var r=a.preRun.shift();ce.unshift(r)}for(;0<ce.length;)ce.shift()(a);if(!(0<Oe||Pe||(Pe=!0,a.calledRun=!0,H))){for(;0<ne.length;)ne.shift()(a);for(h(a);0<Q.length;)Q.shift()(a)}}}return Qe(),c.ready}})();typeof mr=="object"&&typeof Ft=="object"?Ft.exports=pr:typeof define=="function"&&define.amd&&define([],()=>pr)});var hr=tt(()=>{});var yr=tt(()=>{});var br={};At(br,{cpus:()=>rn});var rn,wr=St(()=>{rn=void 0});var _r=tt((vr,xt)=>{"use strict";var Or=(()=>{var u=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(u=u||__filename),function(c={}){function a(){return Q.buffer!=F.buffer&&Y(),F}function h(){return Q.buffer!=F.buffer&&Y(),ye}function f(){return Q.buffer!=F.buffer&&Y(),ve}function w(){return Q.buffer!=F.buffer&&Y(),fe}function g(){return Q.buffer!=F.buffer&&Y(),_e}var i=c,E,P;i.ready=new Promise((e,t)=>{E=e,P=t});var U=Object.assign({},i),D="./this.program",x=(e,t)=>{throw t},K=typeof window=="object",R=typeof importScripts=="function",I=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v=i.ENVIRONMENT_IS_PTHREAD||!1,k="";function W(e){return i.locateFile?i.locateFile(e,k):k+e}var H,se,ee;if(I){var S=(Mt(),rt(Tt)),j=(Dt(),rt(Ct));k=R?j.dirname(k)+"/":__dirname+"/",H=(t,n)=>(t=z(t)?new URL(t):j.normalize(t),S.readFileSync(t,n?void 0:"utf8")),ee=t=>(t=H(t,!0),t.buffer||(t=new Uint8Array(t)),t),se=(t,n,l,y=!0)=>{t=z(t)?new URL(t):j.normalize(t),S.readFile(t,y?void 0:"utf8",(b,_)=>{b?l(b):n(y?_.buffer:_)})},!i.thisProgram&&1<process.argv.length&&(D=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),x=(t,n)=>{throw process.exitCode=t,n},i.inspect=()=>"[Emscripten Module object]";let e;try{e=hr()}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}global.Worker=e.Worker}else(K||R)&&(R?k=self.location.href:typeof document<"u"&&document.currentScript&&(k=document.currentScript.src),typeof u<"u"&&u&&(k=u),k.indexOf("blob:")!==0?k=k.substr(0,k.replace(/[?#].*/,"").lastIndexOf("/")+1):k="",I||(H=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},R&&(ee=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),se=(e,t,n)=>{var l=new XMLHttpRequest;l.open("GET",e,!0),l.responseType="arraybuffer",l.onload=()=>{l.status==200||l.status==0&&l.response?t(l.response):n()},l.onerror=n,l.send(null)}));I&&typeof performance>"u"&&(global.performance=yr().performance);var Ce=console.log.bind(console),Ue=console.error.bind(console);I&&(Ce=(...e)=>S.writeSync(1,e.join(" ")+`\n`),Ue=(...e)=>S.writeSync(2,e.join(" ")+`\n`));var ce=Ce,ne=Ue;Object.assign(i,U),U=null,typeof WebAssembly!="object"&&De("no native wasm support detected");var Q,Oe,he=!1,ae,F,ye,ve,fe,_e;function Y(){var e=Q.buffer;i.HEAP8=F=new Int8Array(e),i.HEAP16=new Int16Array(e),i.HEAPU8=ye=new Uint8Array(e),i.HEAPU16=new Uint16Array(e),i.HEAP32=ve=new Int32Array(e),i.HEAPU32=fe=new Uint32Array(e),i.HEAPF32=new Float32Array(e),i.HEAPF64=_e=new Float64Array(e)}var pe=16777216;if(v)Q=i.wasmMemory;else if(i.wasmMemory)Q=i.wasmMemory;else if(Q=new WebAssembly.Memory({initial:pe/65536,maximum:65536,shared:!0}),!(Q.buffer instanceof SharedArrayBuffer))throw ne("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),I&&ne("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Y(),pe=Q.buffer.byteLength;var Ie=[],Ee=[],be=[],we=0,Le=null,me=null;function Se(){if(we--,we==0&&(Le!==null&&(clearInterval(Le),Le=null),me)){var e=me;me=null,e()}}function De(e){throw e="Aborted("+e+")",ne(e),he=!0,ae=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),P(e),e}var te=e=>e.startsWith("data:application/octet-stream;base64,"),z=e=>e.startsWith("file://"),le;le="ort-wasm-threaded.wasm",te(le)||(le=W(le));function Fe(e){if(ee)return ee(e);throw"both async and sync fetching of the wasm failed"}function Ae(e){if(K||R){if(typeof fetch=="function"&&!z(e))return fetch(e,{credentials:"same-origin"}).then(t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()}).catch(()=>Fe(e));if(se)return new Promise((t,n)=>{se(e,l=>t(new Uint8Array(l)),n)})}return Promise.resolve().then(()=>Fe(e))}function qe(e,t,n){return Ae(e).then(l=>WebAssembly.instantiate(l,t)).then(l=>l).then(n,l=>{ne(`failed to asynchronously prepare wasm: ${l}`),De(l)})}function at(e,t){var n=le;return typeof WebAssembly.instantiateStreaming!="function"||te(n)||z(n)||I||typeof fetch!="function"?qe(n,e,t):fetch(n,{credentials:"same-origin"}).then(l=>WebAssembly.instantiateStreaming(l,e).then(t,function(y){return ne(`wasm streaming compile failed: ${y}`),ne("falling back to ArrayBuffer instantiation"),qe(n,e,t)}))}var xe,Ne={921388:(e,t,n,l)=>{if(typeof i>"u"||!i.cb)return 1;if(e=$e(e>>>0),e.startsWith("./")&&(e=e.substring(2)),e=i.cb.get(e),!e)return 2;if(t>>>=0,n>>>=0,l>>>=0,t+n>e.byteLength)return 3;try{return h().set(e.subarray(t,t+n),l>>>0),0}catch{return 4}}};function Re(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var He=e=>{e.terminate(),e.onmessage=()=>{}},Ge=e=>{M.Pa.length==0&&(Xe(),M.Ya(M.Pa[0]));var t=M.Pa.pop();if(!t)return 6;M.Qa.push(t),M.Ma[e.Oa]=t,t.Oa=e.Oa;var n={cmd:"run",start_routine:e.kb,arg:e.hb,pthread_ptr:e.Oa};return I&&t.unref(),t.postMessage(n,e.qb),0},Be=0,Ve=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Je=(e,t,n)=>{t>>>=0;var l=t+n;for(n=t;e[n]&&!(n>=l);)++n;if(16<n-t&&e.buffer&&Ve)return Ve.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(l="";t<n;){var y=e[t++];if(y&128){var b=e[t++]&63;if((y&224)==192)l+=String.fromCharCode((y&31)<<6|b);else{var _=e[t++]&63;y=(y&240)==224?(y&15)<<12|b<<6|_:(y&7)<<18|b<<12|_<<6|e[t++]&63,65536>y?l+=String.fromCharCode(y):(y-=65536,l+=String.fromCharCode(55296|y>>10,56320|y&1023))}}else l+=String.fromCharCode(y)}return l},$e=(e,t)=>(e>>>=0)?Je(h(),e,t):"",ot=e=>{var t=vt();return e=e(),ct(t),e};function G(e,t){var n=arguments.length-2,l=arguments;return ot(()=>{for(var y=_t(8*n),b=y>>>3,_=0;_<n;_++){var J=l[2+_];g()[b+_>>>0]=J}return ar(e,n,y,t)})}function C(e){if(v)return G(0,1,e);ae=e,0<Be||(M.lb(),i.onExit?.(e),he=!0),x(e,new Re(e))}var je=e=>{if(ae=e,v)throw ut(e),"unwind";C(e)};function st(){for(var e=i.numThreads;e--;)Xe();Ie.unshift(()=>{we++,it(()=>Se())})}function Xe(){var e=W("ort-wasm-threaded.worker.js");e=new Worker(e),M.Pa.push(e)}function it(e){v?e():Promise.all(M.Pa.map(M.Ya)).then(e)}var M={Pa:[],Qa:[],bb:[],Ma:{},Wa(){v?(M.receiveObjectTransfer=M.jb,M.threadInitTLS=M.ab,M.setExitStatus=M.$a):st()},$a:e=>ae=e,tb:["$terminateWorker"],lb:()=>{for(var e of M.Qa)He(e);for(e of M.Pa)He(e);M.Pa=[],M.Qa=[],M.Ma=[]},Za:e=>{var t=e.Oa;delete M.Ma[t],M.Pa.push(e),M.Qa.splice(M.Qa.indexOf(e),1),e.Oa=0,wt(t)},jb(){},ab(){M.bb.forEach(e=>e())},Ya:e=>new Promise(t=>{e.onmessage=b=>{b=b.data;var _=b.cmd;if(b.targetThread&&b.targetThread!=lt()){var J=M.Ma[b.targetThread];J?J.postMessage(b,b.transferList):ne(`Internal error! Worker sent a message "${_}" to target pthread ${b.targetThread}, but that thread no longer exists!`)}else _==="checkMailbox"?ft():_==="spawnThread"?Ge(b):_==="cleanupThread"?M.Za(M.Ma[b.thread]):_==="killThread"?(b=b.thread,_=M.Ma[b],delete M.Ma[b],He(_),wt(b),M.Qa.splice(M.Qa.indexOf(_),1),_.Oa=0):_==="cancelThread"?M.Ma[b.thread].postMessage({cmd:"cancel"}):_==="loaded"?(e.loaded=!0,I&&!e.Oa&&e.unref(),t(e)):_==="alert"?alert(`Thread ${b.threadId}: ${b.text}`):b.target==="setimmediate"?e.postMessage(b):_==="callHandler"?i[b.handler](...b.args):_&&ne(`worker sent an unknown command ${_}`)},e.onerror=b=>{throw ne(`worker sent an error! ${b.filename}:${b.lineno}: ${b.message}`),b},I&&(e.on("message",b=>e.onmessage({data:b})),e.on("error",b=>e.onerror(b)));var n=[],l=["onExit"],y;for(y of l)i.hasOwnProperty(y)&&n.push(y);e.postMessage({cmd:"load",handlers:n,urlOrBlob:i.mainScriptUrlOrBlob||u,wasmMemory:Q,wasmModule:Oe})})};i.PThread=M;var ke=e=>{for(;0<e.length;)e.shift()(i)};i.establishStackSpace=()=>{var e=lt(),t=w()[e+52>>>2>>>0];e=w()[e+56>>>2>>>0],ir(t,t-e),ct(t)};function ut(e){if(v)return G(1,0,e);je(e)}var Pe=[],Qe;i.invokeEntryPoint=(e,t)=>{var n=Pe[e];n||(e>=Pe.length&&(Pe.length=e+1),Pe[e]=n=Qe.get(e)),e=n(t),0<Be?M.$a(e):Ot(e)};function r(e){this.Va=e-24,this.gb=function(t){w()[this.Va+4>>>2>>>0]=t},this.fb=function(t){w()[this.Va+8>>>2>>>0]=t},this.Wa=function(t,n){this.eb(),this.gb(t),this.fb(n)},this.eb=function(){w()[this.Va+16>>>2>>>0]=0}}var o=0,s=0;function m(e,t,n,l){return v?G(2,1,e,t,n,l):O(e,t,n,l)}function O(e,t,n,l){if(e>>>=0,t>>>=0,n>>>=0,l>>>=0,typeof SharedArrayBuffer>"u")return ne("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var y=[];return v&&y.length===0?m(e,t,n,l):(e={kb:n,Oa:e,hb:l,qb:y},v?(e.sb="spawnThread",postMessage(e,y),0):Ge(e))}function A(e,t,n){return v?G(3,1,e,t,n):0}function L(e,t){if(v)return G(4,1,e,t)}var re=e=>{for(var t=0,n=0;n<e.length;++n){var l=e.charCodeAt(n);127>=l?t++:2047>=l?t+=2:55296<=l&&57343>=l?(t+=4,++n):t+=3}return t},de=(e,t,n,l)=>{if(n>>>=0,!(0<l))return 0;var y=n;l=n+l-1;for(var b=0;b<e.length;++b){var _=e.charCodeAt(b);if(55296<=_&&57343>=_){var J=e.charCodeAt(++b);_=65536+((_&1023)<<10)|J&1023}if(127>=_){if(n>=l)break;t[n++>>>0]=_}else{if(2047>=_){if(n+1>=l)break;t[n++>>>0]=192|_>>6}else{if(65535>=_){if(n+2>=l)break;t[n++>>>0]=224|_>>12}else{if(n+3>=l)break;t[n++>>>0]=240|_>>18,t[n++>>>0]=128|_>>12&63}t[n++>>>0]=128|_>>6&63}t[n++>>>0]=128|_&63}}return t[n>>>0]=0,n-y},ie=(e,t,n)=>de(e,h(),t,n);function ue(e,t){if(v)return G(5,1,e,t)}function Ze(e,t,n){if(v)return G(6,1,e,t,n)}function Ke(e,t,n){return v?G(7,1,e,t,n):0}function d(e,t){if(v)return G(8,1,e,t)}function B(e,t,n){if(v)return G(9,1,e,t,n)}function $(e,t,n,l){if(v)return G(10,1,e,t,n,l)}function Te(e,t,n,l){if(v)return G(11,1,e,t,n,l)}function et(e,t,n,l){if(v)return G(12,1,e,t,n,l)}function Bt(e){if(v)return G(13,1,e)}function kt(e,t){if(v)return G(14,1,e,t)}function Wt(e,t,n){if(v)return G(15,1,e,t,n)}function mt(e){e>>>=0,typeof Atomics.rb=="function"&&(Atomics.rb(f(),e>>>2,e).value.then(ft),e+=128,Atomics.store(f(),e>>>2,1))}i.__emscripten_thread_mailbox_await=mt;var ft=()=>{var e=lt();if(e&&(mt(e),e=or,!he))try{if(e(),!(0<Be))try{v?Ot(ae):je(ae)}catch(t){t instanceof Re||t=="unwind"||x(1,t)}}catch(t){t instanceof Re||t=="unwind"||x(1,t)}};i.checkMailbox=ft;var gt=[],Ye=e=>e%4===0&&(e%100!==0||e%400===0),Nt=[0,31,60,91,121,152,182,213,244,274,305,335],Ht=[0,31,59,90,120,151,181,212,243,273,304,334];function Gt(e,t,n,l,y,b,_,J){return v?G(16,1,e,t,n,l,y,b,_,J):-52}function $t(e,t,n,l,y,b,_){if(v)return G(17,1,e,t,n,l,y,b,_)}var jt=e=>{var t=re(e)+1,n=rr(t);return n&&ie(e,n,t),n},ht=[],yt={},Yt=()=>{if(!bt){var e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:D||"./this.program"},t;for(t in yt)yt[t]===void 0?delete e[t]:e[t]=yt[t];var n=[];for(t in e)n.push(`${t}=${e[t]}`);bt=n}return bt},bt;function zt(e,t){if(v)return G(18,1,e,t);e>>>=0,t>>>=0;var n=0;return Yt().forEach((l,y)=>{var b=t+n;for(y=w()[e+4*y>>>2>>>0]=b,b=0;b<l.length;++b)a()[y++>>>0>>>0]=l.charCodeAt(b);a()[y>>>0>>>0]=0,n+=l.length+1}),0}function qt(e,t){if(v)return G(19,1,e,t);e>>>=0,t>>>=0;var n=Yt();w()[e>>>2>>>0]=n.length;var l=0;return n.forEach(y=>l+=y.length+1),w()[t>>>2>>>0]=l,0}function Vt(e){return v?G(20,1,e):52}function Jt(e,t,n,l){return v?G(21,1,e,t,n,l):52}function Xt(e,t,n,l,y){return v?G(22,1,e,t,n,l,y):70}var $r=[null,[],[]];function Qt(e,t,n,l){if(v)return G(23,1,e,t,n,l);t>>>=0,n>>>=0,l>>>=0;for(var y=0,b=0;b<n;b++){var _=w()[t>>>2>>>0],J=w()[t+4>>>2>>>0];t+=8;for(var Me=0;Me<J;Me++){var oe=h()[_+Me>>>0],ge=$r[e];oe===0||oe===10?((e===1?ce:ne)(Je(ge,0)),ge.length=0):ge.push(oe)}y+=J}return w()[l>>>2>>>0]=y,0}var Zt=[31,29,31,30,31,30,31,31,30,31,30,31],Kt=[31,28,31,30,31,30,31,31,30,31,30,31];function jr(e){var t=Array(re(e)+1);return de(e,t,0,t.length),t}var Yr=(e,t)=>{a().set(e,t>>>0)};function er(e,t,n,l){function y(p,N,X){for(p=typeof p=="number"?p.toString():p||"";p.length<N;)p=X[0]+p;return p}function b(p,N){return y(p,N,"0")}function _(p,N){function X(cr){return 0>cr?-1:0<cr?1:0}var We;return(We=X(p.getFullYear()-N.getFullYear()))===0&&(We=X(p.getMonth()-N.getMonth()))===0&&(We=X(p.getDate()-N.getDate())),We}function J(p){switch(p.getDay()){case 0:return new Date(p.getFullYear()-1,11,29);case 1:return p;case 2:return new Date(p.getFullYear(),0,3);case 3:return new Date(p.getFullYear(),0,2);case 4:return new Date(p.getFullYear(),0,1);case 5:return new Date(p.getFullYear()-1,11,31);case 6:return new Date(p.getFullYear()-1,11,30)}}function Me(p){var N=p.Ra;for(p=new Date(new Date(p.Sa+1900,0,1).getTime());0<N;){var X=p.getMonth(),We=(Ye(p.getFullYear())?Zt:Kt)[X];if(N>We-p.getDate())N-=We-p.getDate()+1,p.setDate(1),11>X?p.setMonth(X+1):(p.setMonth(0),p.setFullYear(p.getFullYear()+1));else{p.setDate(p.getDate()+N);break}}return X=new Date(p.getFullYear()+1,0,4),N=J(new Date(p.getFullYear(),0,4)),X=J(X),0>=_(N,p)?0>=_(X,p)?p.getFullYear()+1:p.getFullYear():p.getFullYear()-1}e>>>=0,t>>>=0,n>>>=0,l>>>=0;var oe=w()[l+40>>>2>>>0];l={ob:f()[l>>>2>>>0],nb:f()[l+4>>>2>>>0],Ta:f()[l+8>>>2>>>0],Xa:f()[l+12>>>2>>>0],Ua:f()[l+16>>>2>>>0],Sa:f()[l+20>>>2>>>0],Na:f()[l+24>>>2>>>0],Ra:f()[l+28>>>2>>>0],ub:f()[l+32>>>2>>>0],mb:f()[l+36>>>2>>>0],pb:oe?$e(oe):""},n=$e(n),oe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ge in oe)n=n.replace(new RegExp(ge,"g"),oe[ge]);var fr="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),lr="January February March April May June July August September October November December".split(" ");oe={"%a":p=>fr[p.Na].substring(0,3),"%A":p=>fr[p.Na],"%b":p=>lr[p.Ua].substring(0,3),"%B":p=>lr[p.Ua],"%C":p=>b((p.Sa+1900)/100|0,2),"%d":p=>b(p.Xa,2),"%e":p=>y(p.Xa,2," "),"%g":p=>Me(p).toString().substring(2),"%G":p=>Me(p),"%H":p=>b(p.Ta,2),"%I":p=>(p=p.Ta,p==0?p=12:12<p&&(p-=12),b(p,2)),"%j":p=>{for(var N=0,X=0;X<=p.Ua-1;N+=(Ye(p.Sa+1900)?Zt:Kt)[X++]);return b(p.Xa+N,3)},"%m":p=>b(p.Ua+1,2),"%M":p=>b(p.nb,2),"%n":()=>`\n`,"%p":p=>0<=p.Ta&&12>p.Ta?"AM":"PM","%S":p=>b(p.ob,2),"%t":()=>"	","%u":p=>p.Na||7,"%U":p=>b(Math.floor((p.Ra+7-p.Na)/7),2),"%V":p=>{var N=Math.floor((p.Ra+7-(p.Na+6)%7)/7);if(2>=(p.Na+371-p.Ra-2)%7&&N++,N)N==53&&(X=(p.Na+371-p.Ra)%7,X==4||X==3&&Ye(p.Sa)||(N=1));else{N=52;var X=(p.Na+7-p.Ra-1)%7;(X==4||X==5&&Ye(p.Sa%400-1))&&N++}return b(N,2)},"%w":p=>p.Na,"%W":p=>b(Math.floor((p.Ra+7-(p.Na+6)%7)/7),2),"%y":p=>(p.Sa+1900).toString().substring(2),"%Y":p=>p.Sa+1900,"%z":p=>{p=p.mb;var N=0<=p;return p=Math.abs(p)/60,(N?"+":"-")+("0000"+(p/60*100+p%60)).slice(-4)},"%Z":p=>p.pb,"%%":()=>"%"},n=n.replace(/%%/g,"\\0\\0");for(ge in oe)n.includes(ge)&&(n=n.replace(new RegExp(ge,"g"),oe[ge](l)));return n=n.replace(/\\0\\0/g,"%"),ge=jr(n),ge.length>t?0:(Yr(ge,e),ge.length-1)}M.Wa();var zr=[C,ut,m,A,L,ue,Ze,Ke,d,B,$,Te,et,Bt,kt,Wt,Gt,$t,zt,qt,Vt,Jt,Xt,Qt],qr={b:function(e,t,n){throw e>>>=0,new r(e).Wa(t>>>0,n>>>0),o=e,s++,o},L:function(e){nr(e>>>0,!R,1,!K,131072,!1),M.ab()},j:function(e){e>>>=0,v?postMessage({cmd:"cleanupThread",thread:e}):M.Za(M.Ma[e])},H:O,h:A,S:L,D:ue,F:Ze,T:Ke,Q:d,J:B,P:$,n:Te,E:et,B:Bt,R:kt,C:Wt,p:()=>1,z:function(e,t){e>>>=0,e==t>>>0?setTimeout(()=>ft()):v?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=M.Ma[e])&&e.postMessage({cmd:"checkMailbox"})},I:function(e,t,n,l){t>>>=0,gt.length=n,l=l>>>0>>>3;for(var y=0;y<n;y++)gt[y]=g()[l+y>>>0];return e=0>e?Ne[-e-1]:zr[e],M.ib=t,t=e.apply(null,gt),M.ib=0,t},K:mt,o:function(e){I&&M.Ma[e>>>0].ref()},s:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),f()[n>>>2>>>0]=e.getUTCSeconds(),f()[n+4>>>2>>>0]=e.getUTCMinutes(),f()[n+8>>>2>>>0]=e.getUTCHours(),f()[n+12>>>2>>>0]=e.getUTCDate(),f()[n+16>>>2>>>0]=e.getUTCMonth(),f()[n+20>>>2>>>0]=e.getUTCFullYear()-1900,f()[n+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,f()[n+28>>>2>>>0]=e},t:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),f()[n>>>2>>>0]=e.getSeconds(),f()[n+4>>>2>>>0]=e.getMinutes(),f()[n+8>>>2>>>0]=e.getHours(),f()[n+12>>>2>>>0]=e.getDate(),f()[n+16>>>2>>>0]=e.getMonth(),f()[n+20>>>2>>>0]=e.getFullYear()-1900,f()[n+24>>>2>>>0]=e.getDay(),t=(Ye(e.getFullYear())?Nt:Ht)[e.getMonth()]+e.getDate()-1|0,f()[n+28>>>2>>>0]=t,f()[n+36>>>2>>>0]=-(60*e.getTimezoneOffset()),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var l=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=(t!=l&&e.getTimezoneOffset()==Math.min(l,t))|0,f()[n+32>>>2>>>0]=e},u:function(e){e>>>=0;var t=new Date(f()[e+20>>>2>>>0]+1900,f()[e+16>>>2>>>0],f()[e+12>>>2>>>0],f()[e+8>>>2>>>0],f()[e+4>>>2>>>0],f()[e>>>2>>>0],0),n=f()[e+32>>>2>>>0],l=t.getTimezoneOffset(),y=new Date(t.getFullYear(),6,1).getTimezoneOffset(),b=new Date(t.getFullYear(),0,1).getTimezoneOffset(),_=Math.min(b,y);return 0>n?f()[e+32>>>2>>>0]=+(y!=b&&_==l):0<n!=(_==l)&&(y=Math.max(b,y),t.setTime(t.getTime()+6e4*((0<n?_:y)-l))),f()[e+24>>>2>>>0]=t.getDay(),n=(Ye(t.getFullYear())?Nt:Ht)[t.getMonth()]+t.getDate()-1|0,f()[e+28>>>2>>>0]=n,f()[e>>>2>>>0]=t.getSeconds(),f()[e+4>>>2>>>0]=t.getMinutes(),f()[e+8>>>2>>>0]=t.getHours(),f()[e+12>>>2>>>0]=t.getDate(),f()[e+16>>>2>>>0]=t.getMonth(),f()[e+20>>>2>>>0]=t.getYear(),e=t.getTime(),isNaN(e)?(f()[tr()>>>2>>>0]=61,e=-1):e/=1e3,sr((xe=e,1<=+Math.abs(xe)?0<xe?+Math.floor(xe/4294967296)>>>0:~~+Math.ceil((xe-+(~~xe>>>0))/4294967296)>>>0:0)),e>>>0},q:Gt,r:$t,y:function(e,t,n){function l(oe){return(oe=oe.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?oe[1]:"GMT"}e>>>=0,t>>>=0,n>>>=0;var y=new Date().getFullYear(),b=new Date(y,0,1),_=new Date(y,6,1);y=b.getTimezoneOffset();var J=_.getTimezoneOffset(),Me=Math.max(y,J);w()[e>>>2>>>0]=60*Me,f()[t>>>2>>>0]=+(y!=J),e=l(b),t=l(_),e=jt(e),t=jt(t),J<y?(w()[n>>>2>>>0]=e,w()[n+4>>>2>>>0]=t):(w()[n>>>2>>>0]=t,w()[n+4>>>2>>>0]=e)},c:()=>{De("")},O:function(e,t,n){e>>>=0,t>>>=0,n>>>=0,ht.length=0;for(var l;l=h()[t++>>>0];){var y=l!=105;y&=l!=112,n+=y&&n%8?4:0,ht.push(l==112?w()[n>>>2>>>0]:l==105?f()[n>>>2>>>0]:g()[n>>>3>>>0]),n+=y?8:4}return Ne[e].apply(null,ht)},k:()=>{},i:()=>Date.now(),U:()=>{throw Be+=1,"unwind"},A:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:()=>I?(wr(),rt(br)).cpus().length:navigator.hardwareConcurrency,x:function(e){e>>>=0;var t=h().length;if(e<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var l=t*(1+.2/n);l=Math.min(l,e+100663296);var y=Math;l=Math.max(e,l);e:{y=(y.min.call(y,4294901760,l+(65536-l%65536)%65536)-Q.buffer.byteLength+65535)/65536;try{Q.grow(y),Y();var b=1;break e}catch{}b=void 0}if(b)return!0}return!1},M:zt,N:qt,G:je,g:Vt,m:Jt,v:Xt,l:Qt,a:Q||i.wasmMemory,w:er,d:function(e,t,n,l){return er(e>>>0,t>>>0,n>>>0,l>>>0)}},T=function(){function e(n,l){return T=n.exports,T=Vr(),M.bb.push(T.za),Qe=T.Aa,Ee.unshift(T.V),Oe=l,Se(),T}var t={a:qr};if(we++,i.instantiateWasm)try{return i.instantiateWasm(t,e)}catch(n){ne(`Module.instantiateWasm callback failed with error: ${n}`),P(n)}return at(t,function(n){e(n.instance,n.module)}).catch(P),{}}();i._OrtInit=(e,t)=>(i._OrtInit=T.W)(e,t),i._OrtGetLastError=(e,t)=>(i._OrtGetLastError=T.X)(e,t),i._OrtCreateSessionOptions=(e,t,n,l,y,b,_,J,Me,oe)=>(i._OrtCreateSessionOptions=T.Y)(e,t,n,l,y,b,_,J,Me,oe),i._OrtAppendExecutionProvider=(e,t)=>(i._OrtAppendExecutionProvider=T.Z)(e,t),i._OrtAddFreeDimensionOverride=(e,t,n)=>(i._OrtAddFreeDimensionOverride=T._)(e,t,n),i._OrtAddSessionConfigEntry=(e,t,n)=>(i._OrtAddSessionConfigEntry=T.$)(e,t,n),i._OrtReleaseSessionOptions=e=>(i._OrtReleaseSessionOptions=T.aa)(e),i._OrtCreateSession=(e,t,n)=>(i._OrtCreateSession=T.ba)(e,t,n),i._OrtReleaseSession=e=>(i._OrtReleaseSession=T.ca)(e),i._OrtGetInputOutputCount=(e,t,n)=>(i._OrtGetInputOutputCount=T.da)(e,t,n),i._OrtGetInputName=(e,t)=>(i._OrtGetInputName=T.ea)(e,t),i._OrtGetOutputName=(e,t)=>(i._OrtGetOutputName=T.fa)(e,t),i._OrtFree=e=>(i._OrtFree=T.ga)(e),i._OrtCreateTensor=(e,t,n,l,y,b)=>(i._OrtCreateTensor=T.ha)(e,t,n,l,y,b),i._OrtGetTensorData=(e,t,n,l,y)=>(i._OrtGetTensorData=T.ia)(e,t,n,l,y),i._OrtReleaseTensor=e=>(i._OrtReleaseTensor=T.ja)(e),i._OrtCreateRunOptions=(e,t,n,l)=>(i._OrtCreateRunOptions=T.ka)(e,t,n,l),i._OrtAddRunConfigEntry=(e,t,n)=>(i._OrtAddRunConfigEntry=T.la)(e,t,n),i._OrtReleaseRunOptions=e=>(i._OrtReleaseRunOptions=T.ma)(e),i._OrtCreateBinding=e=>(i._OrtCreateBinding=T.na)(e),i._OrtBindInput=(e,t,n)=>(i._OrtBindInput=T.oa)(e,t,n),i._OrtBindOutput=(e,t,n,l)=>(i._OrtBindOutput=T.pa)(e,t,n,l),i._OrtClearBoundOutputs=e=>(i._OrtClearBoundOutputs=T.qa)(e),i._OrtReleaseBinding=e=>(i._OrtReleaseBinding=T.ra)(e),i._OrtRunWithBinding=(e,t,n,l,y)=>(i._OrtRunWithBinding=T.sa)(e,t,n,l,y),i._OrtRun=(e,t,n,l,y,b,_,J)=>(i._OrtRun=T.ta)(e,t,n,l,y,b,_,J),i._OrtEndProfiling=e=>(i._OrtEndProfiling=T.ua)(e);var tr=()=>(tr=T.va)(),lt=i._pthread_self=()=>(lt=i._pthread_self=T.wa)(),rr=i._malloc=e=>(rr=i._malloc=T.xa)(e);i._free=e=>(i._free=T.ya)(e),i.__emscripten_tls_init=()=>(i.__emscripten_tls_init=T.za)();var nr=i.__emscripten_thread_init=(e,t,n,l,y,b)=>(nr=i.__emscripten_thread_init=T.Ba)(e,t,n,l,y,b);i.__emscripten_thread_crashed=()=>(i.__emscripten_thread_crashed=T.Ca)();var ar=(e,t,n,l)=>(ar=T.Da)(e,t,n,l),wt=e=>(wt=T.Ea)(e),Ot=i.__emscripten_thread_exit=e=>(Ot=i.__emscripten_thread_exit=T.Fa)(e),or=()=>(or=T.Ga)(),sr=e=>(sr=T.Ha)(e),ir=(e,t)=>(ir=T.Ia)(e,t),vt=()=>(vt=T.Ja)(),ct=e=>(ct=T.Ka)(e),_t=e=>(_t=T.La)(e);function Vr(){var e=T;e=Object.assign({},e);var t=l=>()=>l()>>>0,n=l=>y=>l(y)>>>0;return e.va=t(e.va),e.wa=t(e.wa),e.xa=n(e.xa),e.emscripten_main_runtime_thread_id=t(e.emscripten_main_runtime_thread_id),e.Ja=t(e.Ja),e.La=n(e.La),e}i.wasmMemory=Q,i.stackAlloc=_t,i.stackSave=vt,i.stackRestore=ct,i.keepRuntimeAlive=()=>0<Be,i.UTF8ToString=$e,i.stringToUTF8=ie,i.lengthBytesUTF8=re,i.ExitStatus=Re,i.PThread=M;var dt;me=function e(){dt||ur(),dt||(me=e)};function ur(){if(!(0<we))if(v)E(i),v||ke(Ee),startWorker(i);else{if(i.preRun)for(typeof i.preRun=="function"&&(i.preRun=[i.preRun]);i.preRun.length;)Ie.unshift(i.preRun.shift());ke(Ie),0<we||dt||(dt=!0,i.calledRun=!0,he||(v||ke(Ee),E(i),v||ke(be)))}}return ur(),c.ready}})();typeof vr=="object"&&typeof xt=="object"?xt.exports=Or:typeof define=="function"&&define.amd&&define([],()=>Or)});var Er=tt((On,nn)=>{nn.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed?.(),a}}self.onmessage=handleMessage;\\n\'});var Ar;Ar=gr();var an=_r(),Pt,Ut=!1,pt=!1,Sr=!1,on=u=>{if(u===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+u+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+u+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},sn=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},un=(u,c)=>u?c?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":c?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Tr=async u=>{if(Ut)return Promise.resolve();if(pt)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Sr)throw new Error("previous call to \'initializeWebAssembly()\' failed.");pt=!0;let c=u.initTimeout,a=u.numThreads,h=u.simd,f=on(a),w=h&&sn(),g=u.wasmPaths,i=typeof g=="string"?g:void 0,E=un(w,f),P=typeof g=="object"?g[E]:void 0,U=!1,D=[];if(c>0&&D.push(new Promise(x=>{setTimeout(()=>{U=!0,x()},c)})),D.push(new Promise((x,K)=>{let R=f?an:Ar,I={locateFile:(v,k)=>f&&v.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([Er()],{type:"text/javascript"})):v.endsWith(".wasm")?P||(i??k)+E:k+v};if(f)if(I.numThreads=a,typeof Blob>"u")I.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let v=`var ortWasmThreaded=${R.toString()};`;I.mainScriptUrlOrBlob=new Blob([v],{type:"text/javascript"})}R(I).then(v=>{pt=!1,Ut=!0,Pt=v,x()},v=>{pt=!1,Sr=!0,K(v)})})),await Promise.race(D),U)throw new Error(`WebAssembly backend initializing failed due to timeout: ${c}ms`)},Z=()=>{if(Ut&&Pt)return Pt;throw new Error("WebAssembly is not initialized yet.")};var q=(u,c)=>{let a=Z(),h=a.lengthBytesUTF8(u)+1,f=a._malloc(h);return a.stringToUTF8(u,f,h),c.push(f),f},nt=(u,c,a,h)=>{if(typeof u=="object"&&u!==null){if(a.has(u))throw new Error("Circular reference in options");a.add(u)}Object.entries(u).forEach(([f,w])=>{let g=c?c+f:f;if(typeof w=="object")nt(w,g+".",a,h);else if(typeof w=="string"||typeof w=="number")h(g,w.toString());else if(typeof w=="boolean")h(g,w?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof w}`)})},V=u=>{let c=Z(),a=c.stackSave();try{let h=c.stackAlloc(8);c._OrtGetLastError(h,h+4);let f=c.HEAP32[h/4],w=c.HEAPU32[h/4+1],g=w?c.UTF8ToString(w):"";throw new Error(`${u} ERROR_CODE: ${f}, ERROR_MESSAGE: ${g}`)}finally{c.stackRestore(a)}};var Mr=u=>{let c=Z(),a=0,h=[],f=u||{};try{if(u?.logSeverityLevel===void 0)f.logSeverityLevel=2;else if(typeof u.logSeverityLevel!="number"||!Number.isInteger(u.logSeverityLevel)||u.logSeverityLevel<0||u.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${u.logSeverityLevel}`);if(u?.logVerbosityLevel===void 0)f.logVerbosityLevel=0;else if(typeof u.logVerbosityLevel!="number"||!Number.isInteger(u.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${u.logVerbosityLevel}`);u?.terminate===void 0&&(f.terminate=!1);let w=0;return u?.tag!==void 0&&(w=q(u.tag,h)),a=c._OrtCreateRunOptions(f.logSeverityLevel,f.logVerbosityLevel,!!f.terminate,w),a===0&&V("Can\'t create run options."),u?.extra!==void 0&&nt(u.extra,"",new WeakSet,(g,i)=>{let E=q(g,h),P=q(i,h);c._OrtAddRunConfigEntry(a,E,P)!==0&&V(`Can\'t set a run config entry: ${g} - ${i}.`)}),[a,h]}catch(w){throw a!==0&&c._OrtReleaseRunOptions(a),h.forEach(g=>c._free(g)),w}};var fn=u=>{switch(u){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${u}`)}},ln=u=>{switch(u){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${u}`)}},cn=u=>{u.extra||(u.extra={}),u.extra.session||(u.extra.session={});let c=u.extra.session;c.use_ort_model_bytes_directly||(c.use_ort_model_bytes_directly="1"),u.executionProviders&&u.executionProviders.some(a=>(typeof a=="string"?a:a.name)==="webgpu")&&(u.enableMemPattern=!1)},dn=(u,c,a)=>{for(let h of c){let f=typeof h=="string"?h:h.name;switch(f){case"webnn":if(f="WEBNN",typeof h!="string"){let g=h;if(g?.deviceType){let i=q("deviceType",a),E=q(g.deviceType,a);Z()._OrtAddSessionConfigEntry(u,i,E)!==0&&V(`Can\'t set a session config entry: \'deviceType\' - ${g.deviceType}.`)}if(g?.numThreads){let i=g.numThreads;(typeof i!="number"||!Number.isInteger(i)||i<0)&&(i=0);let E=q("numThreads",a),P=q(i.toString(),a);Z()._OrtAddSessionConfigEntry(u,E,P)!==0&&V(`Can\'t set a session config entry: \'numThreads\' - ${g.numThreads}.`)}if(g?.powerPreference){let i=q("powerPreference",a),E=q(g.powerPreference,a);Z()._OrtAddSessionConfigEntry(u,i,E)!==0&&V(`Can\'t set a session config entry: \'powerPreference\' - ${g.powerPreference}.`)}}break;case"webgpu":if(f="JS",typeof h!="string"){let g=h;if(g?.preferredLayout){if(g.preferredLayout!=="NCHW"&&g.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${g.preferredLayout}`);let i=q("preferredLayout",a),E=q(g.preferredLayout,a);Z()._OrtAddSessionConfigEntry(u,i,E)!==0&&V(`Can\'t set a session config entry: \'preferredLayout\' - ${g.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${f}`)}let w=q(f,a);Z()._OrtAppendExecutionProvider(u,w)!==0&&V(`Can\'t append execution provider: ${f}.`)}},Cr=u=>{let c=Z(),a=0,h=[],f=u||{};cn(f);try{let w=fn(f.graphOptimizationLevel??"all"),g=ln(f.executionMode??"sequential"),i=typeof f.logId=="string"?q(f.logId,h):0,E=f.logSeverityLevel??2;if(!Number.isInteger(E)||E<0||E>4)throw new Error(`log serverity level is not valid: ${E}`);let P=f.logVerbosityLevel??0;if(!Number.isInteger(P)||P<0||P>4)throw new Error(`log verbosity level is not valid: ${P}`);let U=typeof f.optimizedModelFilePath=="string"?q(f.optimizedModelFilePath,h):0;if(a=c._OrtCreateSessionOptions(w,!!f.enableCpuMemArena,!!f.enableMemPattern,g,!!f.enableProfiling,0,i,E,P,U),a===0&&V("Can\'t create session options."),f.executionProviders&&dn(a,f.executionProviders,h),f.enableGraphCapture!==void 0){if(typeof f.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${f.enableGraphCapture}`);let D=q("enableGraphCapture",h),x=q(f.enableGraphCapture.toString(),h);c._OrtAddSessionConfigEntry(a,D,x)!==0&&V(`Can\'t set a session config entry: \'enableGraphCapture\' - ${f.enableGraphCapture}.`)}if(f.freeDimensionOverrides)for(let[D,x]of Object.entries(f.freeDimensionOverrides)){if(typeof D!="string")throw new Error(`free dimension override name must be a string: ${D}`);if(typeof x!="number"||!Number.isInteger(x)||x<0)throw new Error(`free dimension override value must be a non-negative integer: ${x}`);let K=q(D,h);c._OrtAddFreeDimensionOverride(a,K,x)!==0&&V(`Can\'t set a free dimension override: ${D} - ${x}.`)}return f.extra!==void 0&&nt(f.extra,"",new WeakSet,(D,x)=>{let K=q(D,h),R=q(x,h);c._OrtAddSessionConfigEntry(a,K,R)!==0&&V(`Can\'t set a session config entry: ${D} - ${x}.`)}),[a,h]}catch(w){throw a!==0&&c._OrtReleaseSessionOptions(a),h.forEach(g=>c._free(g)),w}};var Rt=u=>{switch(u){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${u}`)}},Dr=u=>{switch(u){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${u}`)}},It=u=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][u],Fr=u=>{switch(u){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${u}`)}},xr=u=>{switch(u){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${u}`)}},Pr=u=>u==="float32"||u==="float16"||u==="int32"||u==="int64"||u==="uint32"||u==="uint8"||u==="bool",Ur=u=>{switch(u){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${u}`)}};var Rr=async u=>{if(typeof u=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(u))}catch(c){if(c.code==="ERR_FS_FILE_TOO_LARGE"){let a=(void 0)(u),h=[];for await(let f of a)h.push(f);return new Uint8Array(Buffer.concat(h))}throw c}else{let c=await fetch(u);if(!c.ok)throw new Error(`failed to load external data file: ${u}`);let a=c.headers.get("Content-Length"),h=a?parseInt(a,10):0;if(h<1073741824)return new Uint8Array(await c.arrayBuffer());{if(!c.body)throw new Error(`failed to load external data file: ${u}, no response body.`);let f=c.body.getReader(),w;try{w=new ArrayBuffer(h)}catch(i){if(i instanceof RangeError){let E=Math.ceil(h/65536);w=new WebAssembly.Memory({initial:E,maximum:E}).buffer}else throw i}let g=0;for(;;){let{done:i,value:E}=await f.read();if(i)break;let P=E.byteLength;new Uint8Array(w,g,P).set(E),g+=P}return new Uint8Array(w,0,h)}}else return u instanceof Blob?new Uint8Array(await u.arrayBuffer()):u instanceof Uint8Array?u:new Uint8Array(u)};var pn=(u,c)=>{Z()._OrtInit(u,c)!==0&&V("Can\'t initialize onnxruntime.")},Lr=async u=>{pn(u.wasm.numThreads,xr(u.logLevel))},Br=async(u,c)=>{},ze=new Map,mn=u=>{let c=Z(),a=c.stackSave();try{let h=c.stackAlloc(8);return c._OrtGetInputOutputCount(u,h,h+4)!==0&&V("Can\'t get session input/output count."),[c.HEAP32[h/4],c.HEAP32[h/4+1]]}finally{c.stackRestore(a)}},Lt=u=>{let c=Z(),a=c._malloc(u.byteLength);if(a===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${u.byteLength}.`);return c.HEAPU8.set(u,a),[a,u.byteLength]},kr=async(u,c)=>{let a,h,f=Z();Array.isArray(u)?[a,h]=u:u.buffer===f.HEAPU8.buffer?[a,h]=[u.byteOffset,u.byteLength]:[a,h]=Lt(u);let w=0,g=0,i=0,E=[],P=[],U=[];try{if([g,E]=Cr(c),c?.externalData&&f.mountExternalData){let W=[];for(let H of c.externalData){let se=typeof H=="string"?H:H.path;W.push(Rr(typeof H=="string"?H:H.data).then(ee=>{f.mountExternalData(se,ee)}))}await Promise.all(W)}w=await f._OrtCreateSession(a,h,g),w===0&&V("Can\'t create a session.");let[D,x]=mn(w),K=!!c?.enableGraphCapture,R=[],I=[],v=[];for(let W=0;W<D;W++){let H=f._OrtGetInputName(w,W);H===0&&V("Can\'t get an input name."),P.push(H),R.push(f.UTF8ToString(H))}for(let W=0;W<x;W++){let H=f._OrtGetOutputName(w,W);H===0&&V("Can\'t get an output name."),U.push(H);let se=f.UTF8ToString(H);I.push(se)}let k=null;return ze.set(w,[w,P,U,k,K,!1]),[w,R,I]}catch(D){throw P.forEach(x=>f._OrtFree(x)),U.forEach(x=>f._OrtFree(x)),i!==0&&f._OrtReleaseBinding(i),w!==0&&f._OrtReleaseSession(w),D}finally{f._free(a),g!==0&&f._OrtReleaseSessionOptions(g),E.forEach(D=>f._free(D)),f.unmountExternalData?.()}},Wr=u=>{let c=Z(),a=ze.get(u);if(!a)throw new Error(`cannot release session. invalid session id: ${u}`);let[h,f,w,g,i]=a;g&&(i&&c._OrtClearBoundOutputs(g.handle),c._OrtReleaseBinding(g.handle)),c.jsepOnReleaseSession?.(u),f.forEach(E=>c._OrtFree(E)),w.forEach(E=>c._OrtFree(E)),c._OrtReleaseSession(h),ze.delete(u)},Ir=(u,c,a,h,f,w=!1)=>{if(!u){c.push(0);return}let g=Z(),i=u[0],E=u[1],P=u[3],U,D;if(i==="string"&&P==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(w&&P!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${f} when enableGraphCapture is true.`);if(P==="gpu-buffer"){let R=u[2].gpuBuffer,I=It(Rt(i));D=E.reduce((k,W)=>k*W,1)*I;let v=g.jsepRegisterBuffer;if(!v)throw new Error(\'Tensor location "gpu-buffer" is not supported without using WebGPU.\');U=v(h,f,R,D)}else{let R=u[2];if(Array.isArray(R)){D=4*R.length,U=g._malloc(D),a.push(U);let I=U/4;for(let v=0;v<R.length;v++){if(typeof R[v]!="string")throw new TypeError(`tensor data at index ${v} is not a string`);g.HEAPU32[I++]=q(R[v],a)}}else D=R.byteLength,U=g._malloc(D),a.push(U),g.HEAPU8.set(new Uint8Array(R.buffer,R.byteOffset,D),U)}let x=g.stackSave(),K=g.stackAlloc(4*E.length);try{let R=K/4;E.forEach(v=>g.HEAP32[R++]=v);let I=g._OrtCreateTensor(Rt(i),U,D,K,E.length,Ur(P));I===0&&V(`Can\'t create tensor for input/output. session=${h}, index=${f}.`),c.push(I)}finally{g.stackRestore(x)}},Nr=async(u,c,a,h,f,w)=>{let g=Z(),i=ze.get(u);if(!i)throw new Error(`cannot run inference. invalid session id: ${u}`);let E=i[0],P=i[1],U=i[2],D=i[3],x=i[4],K=i[5],R=c.length,I=h.length,v=0,k=[],W=[],H=[],se=[],ee=g.stackSave(),S=g.stackAlloc(R*4),j=g.stackAlloc(R*4),Ce=g.stackAlloc(I*4),Ue=g.stackAlloc(I*4);try{[v,k]=Mr(w);for(let F=0;F<R;F++)Ir(a[F],W,se,u,c[F],x);for(let F=0;F<I;F++)Ir(f[F],H,se,u,R+h[F],x);let ce=S/4,ne=j/4,Q=Ce/4,Oe=Ue/4;for(let F=0;F<R;F++)g.HEAPU32[ce++]=W[F],g.HEAPU32[ne++]=P[c[F]];for(let F=0;F<I;F++)g.HEAPU32[Q++]=H[F],g.HEAPU32[Oe++]=U[h[F]];g.jsepOnRunStart?.(E);let he;he=await g._OrtRun(E,j,S,R,Ue,I,Ce,v),he!==0&&V("failed to call OrtRun().");let ae=[];for(let F=0;F<I;F++){let ye=g.HEAPU32[Ce/4+F];if(ye===H[F]){ae.push(f[F]);continue}let ve=g.stackSave(),fe=g.stackAlloc(4*4),_e=!1,Y,pe=0;try{g._OrtGetTensorData(ye,fe,fe+4,fe+8,fe+12)!==0&&V(`Can\'t access output tensor data on index ${F}.`);let Ee=fe/4,be=g.HEAPU32[Ee++];pe=g.HEAPU32[Ee++];let we=g.HEAPU32[Ee++],Le=g.HEAPU32[Ee++],me=[];for(let te=0;te<Le;te++)me.push(g.HEAPU32[we/4+te]);g._OrtFree(we);let Se=me.reduce((te,z)=>te*z,1);Y=Dr(be);let De=D?.outputPreferredLocations[h[F]];if(Y==="string"){if(De==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let te=[],z=pe/4;for(let le=0;le<Se;le++){let Fe=g.HEAPU32[z++],Ae=le===Se-1?void 0:g.HEAPU32[z]-Fe;te.push(g.UTF8ToString(Fe,Ae))}ae.push([Y,me,te,"cpu"])}else if(De==="gpu-buffer"&&Se>0){let te=g.jsepGetBuffer;if(!te)throw new Error(\'preferredLocation "gpu-buffer" is not supported without using WebGPU.\');let z=te(pe),le=It(be);if(le===void 0||!Pr(Y))throw new Error(`Unsupported data type: ${Y}`);_e=!0,ae.push([Y,me,{gpuBuffer:z,download:g.jsepCreateDownloader(z,Se*le,Y),dispose:()=>{g._OrtReleaseTensor(ye)}},"gpu-buffer"])}else{let te=Fr(Y),z=new te(Se);new Uint8Array(z.buffer,z.byteOffset,z.byteLength).set(g.HEAPU8.subarray(pe,pe+z.byteLength)),ae.push([Y,me,z,"cpu"])}}finally{g.stackRestore(ve),Y==="string"&&pe&&g._free(pe),_e||g._OrtReleaseTensor(ye)}}return D&&!x&&(g._OrtClearBoundOutputs(D.handle),ze.set(u,[E,P,U,D,x,!1])),ae}finally{g.stackRestore(ee),W.forEach(ce=>g._OrtReleaseTensor(ce)),H.forEach(ce=>g._OrtReleaseTensor(ce)),se.forEach(ce=>g._free(ce)),v!==0&&g._OrtReleaseRunOptions(v),k.forEach(ce=>g._free(ce))}},Hr=u=>{let c=Z(),a=ze.get(u);if(!a)throw new Error("invalid session id");let h=a[0],f=c._OrtEndProfiling(h);f===0&&V("Can\'t get an profile file name."),c._OrtFree(f)},Gr=u=>{let c=[];for(let a of u){let h=a[2];!Array.isArray(h)&&"buffer"in h&&c.push(h.buffer)}return c};self.onmessage=u=>{let{type:c,in:a}=u.data;try{switch(c){case"init-wasm":Tr(a.wasm).then(()=>{Lr(a).then(()=>{postMessage({type:c})},h=>{postMessage({type:c,err:h})})},h=>{postMessage({type:c,err:h})});break;case"init-ep":{let{epName:h,env:f}=a;Br(f,h).then(()=>{postMessage({type:c})},w=>{postMessage({type:c,err:w})});break}case"copy-from":{let{buffer:h}=a,f=Lt(h);postMessage({type:c,out:f});break}case"create":{let{model:h,options:f}=a;kr(h,f).then(w=>{postMessage({type:c,out:w})},w=>{postMessage({type:c,err:w})});break}case"release":Wr(a),postMessage({type:c});break;case"run":{let{sessionId:h,inputIndices:f,inputs:w,outputIndices:g,options:i}=a;Nr(h,f,w,g,new Array(g.length).fill(null),i).then(E=>{E.some(P=>P[3]!=="cpu")?postMessage({type:c,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:c,out:E},Gr([...w,...E]))},E=>{postMessage({type:c,err:E})});break}case"end-profiling":Hr(a),postMessage({type:c});break;default:}}catch(h){postMessage({type:c,err:h})}};})();\n'}),wr,ht$1,xn$1,Fo$1,Co$1,da$1,ha$1,Hr,qr,wg,Lo$1,ad,sd,ud,ld$1,fd$1,cd$1,pd$1,ma$1=E(()=>{var a;Tt(),od(),Vr(),wr=()=>!!Z.wasm.proxy&&typeof document<"u",xn$1=!1,Fo$1=!1,Co$1=!1,ha$1=new Map,Hr=(e,o)=>{let s=ha$1.get(e);s?s.push(o):ha$1.set(e,[o])},qr=()=>{if(xn$1||!Fo$1||Co$1||!ht$1)throw new Error("worker not ready")},wg=e=>{switch(e.data.type){case"init-wasm":xn$1=!1,e.data.err?(Co$1=!0,da$1[1](e.data.err)):(Fo$1=!0,da$1[0]());break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let o=ha$1.get(e.data.type);e.data.err?o.shift()[1](e.data.err):o.shift()[0](e.data.out);break}}},Lo$1=typeof document<"u"?(a=document==null?void 0:document.currentScript)==null?void 0:a.src:void 0,ad=async()=>{if(!Fo$1){if(xn$1)throw new Error("multiple calls to 'initWasm()' detected.");if(Co$1)throw new Error("previous call to 'initWasm()' failed.");if(xn$1=!0,wr())return Z.wasm.wasmPaths===void 0&&Lo$1&&Lo$1.indexOf("blob:")!==0&&(Z.wasm.wasmPaths=Lo$1.substr(0,+Lo$1.lastIndexOf("/")+1)),new Promise((e,o)=>{ht$1==null||ht$1.terminate();let s=URL.createObjectURL(new Blob([id()],{type:"text/javascript"}));ht$1=new Worker(s,{name:"ort-wasm-proxy-worker"}),ht$1.onerror=c=>o(c),ht$1.onmessage=wg,URL.revokeObjectURL(s),da$1=[e,o];let d={type:"init-wasm",in:Z};ht$1.postMessage(d)});try{await Up$1(Z.wasm),await Jp$1(Z),Fo$1=!0}catch(e){throw Co$1=!0,e}finally{xn$1=!1}}},sd=async e=>{if(wr())return qr(),new Promise((o,s)=>{Hr("init-ep",[o,s]);let d={type:"init-ep",in:{epName:e,env:Z}};ht$1.postMessage(d)});await Zp$1(Z,e)},ud=async e=>wr()?(qr(),new Promise((o,s)=>{Hr("copy-from",[o,s]);let d={type:"copy-from",in:{buffer:e}};ht$1.postMessage(d,[e.buffer])})):pa$1(e),ld$1=async(e,o)=>{if(wr()){if(o!=null&&o.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return qr(),new Promise((s,d)=>{Hr("create",[s,d]);let c={type:"create",in:{model:e,options:{...o}}},h=[];e instanceof Uint8Array&&h.push(e.buffer),ht$1.postMessage(c,h)})}else return Qp$1(e,o)},fd$1=async e=>{if(wr())return qr(),new Promise((o,s)=>{Hr("release",[o,s]);let d={type:"release",in:e};ht$1.postMessage(d)});ed(e)},cd$1=async(e,o,s,d,c,h)=>{if(wr()){if(s.some(_=>_[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(c.some(_=>_))throw new Error("pre-allocated output tensor is not supported for proxy.");return qr(),new Promise((_,bt)=>{Hr("run",[_,bt]);let g=s,j={type:"run",in:{sessionId:e,inputIndices:o,inputs:g,outputIndices:d,options:h}};ht$1.postMessage(j,nd(g))})}else return td(e,o,s,d,c,h)},pd$1=async e=>{if(wr())return qr(),new Promise((o,s)=>{Hr("end-profiling",[o,s]);let d={type:"end-profiling",in:e};ht$1.postMessage(d)});rd(e)}}),dd$1,vg,$o$1,hd$1=E(()=>{Tt(),ma$1(),fa$1(),ca$1(),dd$1=(a,e)=>{switch(a.location){case"cpu":return[a.type,a.dims,a.data,"cpu"];case"gpu-buffer":return[a.type,a.dims,{gpuBuffer:a.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${a.location} for ${e()}`)}},vg=a=>{switch(a[3]){case"cpu":return new Re(a[0],a[2],a[1]);case"gpu-buffer":{let e=a[0];if(!Do$1(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:o,download:s,dispose:d}=a[2];return Re.fromGpuBuffer(o,{dataType:e,dims:a[1],download:s,dispose:d})}default:throw new Error(`invalid data location: ${a[3]}`)}},$o$1=class{async fetchModelAndCopyToWasmMemory(a){return ud(await Tn$1(a))}async loadModel(a,e){sr$1();let o;typeof a=="string"?typeof process<"u"&&process.versions&&process.versions.node?o=await Tn$1(a):o=await this.fetchModelAndCopyToWasmMemory(a):o=a,[this.sessionId,this.inputNames,this.outputNames]=await ld$1(o,e),ur()}async dispose(){return fd$1(this.sessionId)}async run(a,e,o){sr$1();let s=[],d=[];Object.entries(a).forEach(b=>{let Et=b[0],It=b[1],zt=this.inputNames.indexOf(Et);if(zt===-1)throw new Error(`invalid input '${Et}'`);s.push(It),d.push(zt)});let c=[],h=[];Object.entries(e).forEach(b=>{let Et=b[0],It=b[1],zt=this.outputNames.indexOf(Et);if(zt===-1)throw new Error(`invalid output '${Et}'`);c.push(It),h.push(zt)});let _=s.map((b,Et)=>dd$1(b,()=>`input "${this.inputNames[d[Et]]}"`)),bt=c.map((b,Et)=>b?dd$1(b,()=>`output "${this.outputNames[h[Et]]}"`):null),g=await cd$1(this.sessionId,d,_,h,bt,o),j={};for(let b=0;b<g.length;b++)j[this.outputNames[h[b]]]=c[b]??vg(g[b]);return ur(),j}startProfiling(){}endProfiling(){pd$1(this.sessionId)}}}),_g,ko$1,md$1=E(()=>{Tt(),ma$1(),hd$1(),_g=()=>{if((typeof Z.wasm.initTimeout!="number"||Z.wasm.initTimeout<0)&&(Z.wasm.initTimeout=0),typeof Z.wasm.simd!="boolean"&&(Z.wasm.simd=!0),typeof Z.wasm.proxy!="boolean"&&(Z.wasm.proxy=!1),typeof Z.wasm.trace!="boolean"&&(Z.wasm.trace=!1),typeof Z.wasm.numThreads!="number"||!Number.isInteger(Z.wasm.numThreads)||Z.wasm.numThreads<=0){(typeof self<"u"&&!self.crossOriginIsolated||typeof process<"u"&&process.versions&&process.versions.node)&&(Z.wasm.numThreads=1);let a=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;Z.wasm.numThreads=Math.min(4,Math.ceil((a||1)/2))}},ko$1=class{async init(a){_g(),await ad(),await sd(a)}async createInferenceSessionHandler(a,e){let o=new $o$1;return await o.loadModel(a,e),Promise.resolve(o)}}}),bd$1={};Pr$1(bd$1,{wasmBackend:()=>Og});var Og,gd$1=E(()=>{md$1(),Og=new ko$1});Tt();Tt();Tt();var ws$1="1.17.3",XO=Yo$1;{let a=(Sp$1(),or$1(Ip$1)).onnxjsBackend;Dr("webgl",a,-10)}{let a=(gd$1(),or$1(bd$1)).wasmBackend;Dr("cpu",a,10),Dr("wasm",a,10)}Object.defineProperty(Z.versions,"web",{value:ws$1,enumerable:!0});/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/const ort_cpu=Object.freeze(Object.defineProperty({__proto__:null,get InferenceSession(){return Dd$1},get TRACE(){return cs$1},get TRACE_FUNC_BEGIN(){return sr$1},get TRACE_FUNC_END(){return ur},get Tensor(){return Re},get TrainingSession(){return Fd$1},default:XO,get env(){return Z},get registerBackend(){return Dr}},Symbol.toStringTag,{value:"Module"}));/*!
 * ONNX Runtime Web v1.17.3
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var Fn=Object.defineProperty,ld=Object.getOwnPropertyDescriptor,dd=Object.getOwnPropertyNames,cd=Object.prototype.hasOwnProperty,F=(a,e)=>()=>(a&&(e=a(a=0)),e),tr=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),rr=(a,e)=>{for(var o in e)Fn(a,o,{get:e[o],enumerable:!0})},pd=(a,e,o,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let d of dd(e))!cd.call(a,d)&&d!==o&&Fn(a,d,{get:()=>e[d],enumerable:!(s=ld(e,d))||s.enumerable});return a},Gt=a=>pd(Fn({},"__esModule",{value:!0}),a),Zr,Ht,Lt,fd,Xr,Qr=F(()=>{Zr=new Map,Ht=[],Lt=(a,e,o)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let s=Zr.get(a);if(s===void 0)Zr.set(a,{backend:e,priority:o});else{if(s.priority>o)return;if(s.priority===o&&s.backend!==e)throw new Error(`cannot register backend "${a}" using priority ${o}`)}if(o>=0){let d=Ht.indexOf(a);d!==-1&&Ht.splice(d,1);for(let c=0;c<Ht.length;c++)if(Zr.get(Ht[c]).priority<=o){Ht.splice(c,0,a);return}Ht.push(a)}return}throw new TypeError("not a valid backend")},fd=async a=>{let e=Zr.get(a);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let o=!!e.initPromise;try{return o||(e.initPromise=e.backend.init(a)),await e.initPromise,e.initialized=!0,e.backend}catch(s){return o||(e.error=`${s}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},Xr=async a=>{let e=a.executionProviders||[],o=e.map(bt=>typeof bt=="string"?bt:bt.name),s=o.length===0?Ht:o,d,c=[],h=new Set;for(let bt of s){let g=await fd(bt);typeof g=="string"?c.push({name:bt,err:g}):(d||(d=g),d===g&&h.add(bt))}if(!d)throw new Error(`no available backend found. ERR: ${c.map(bt=>`[${bt.name}] ${bt.err}`).join(", ")}`);for(let{name:bt,err:g}of c)o.includes(bt)&&console.warn(`removing requested execution provider "${bt}" from session options because it is not available: ${g}`);let _=e.filter(bt=>h.has(typeof bt=="string"?bt:bt.name));return[d,new Proxy(a,{get:(bt,g)=>g==="executionProviders"?_:Reflect.get(bt,g)})]}}),ii=F(()=>{Qr()}),oi,si=F(()=>{oi="1.17.3"}),ui,ot,qn=F(()=>{si(),ui="warning",ot={wasm:{},webgl:{},webgpu:{},versions:{common:oi},set logLevel(a){if(a!==void 0){if(typeof a!="string"||["verbose","info","warning","error","fatal"].indexOf(a)===-1)throw new Error(`Unsupported logging level: ${a}`);ui=a}},get logLevel(){return ui}},Object.defineProperty(ot,"logLevel",{enumerable:!0})}),Ae,li=F(()=>{qn(),Ae=ot}),di,ci,pi=F(()=>{di=(a,e)=>{let o=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);o.width=a.dims[3],o.height=a.dims[2];let s=o.getContext("2d");if(s!=null){let d,c;(e==null?void 0:e.tensorLayout)!==void 0&&e.tensorLayout==="NHWC"?(d=a.dims[2],c=a.dims[3]):(d=a.dims[3],c=a.dims[2]);let h=(e==null?void 0:e.format)!==void 0?e.format:"RGB",_=e==null?void 0:e.norm,bt,g;_===void 0||_.mean===void 0?bt=[255,255,255,255]:typeof _.mean=="number"?bt=[_.mean,_.mean,_.mean,_.mean]:(bt=[_.mean[0],_.mean[1],_.mean[2],0],_.mean[3]!==void 0&&(bt[3]=_.mean[3])),_===void 0||_.bias===void 0?g=[0,0,0,0]:typeof _.bias=="number"?g=[_.bias,_.bias,_.bias,_.bias]:(g=[_.bias[0],_.bias[1],_.bias[2],0],_.bias[3]!==void 0&&(g[3]=_.bias[3]));let j=c*d,b=0,Et=j,It=j*2,zt=-1;h==="RGBA"?(b=0,Et=j,It=j*2,zt=j*3):h==="RGB"?(b=0,Et=j,It=j*2):h==="RBG"&&(b=0,It=j,Et=j*2);for(let er=0;er<c;er++)for(let Hn=0;Hn<d;Hn++){let Qt=(a.data[b++]-g[0])*bt[0],cr=(a.data[Et++]-g[1])*bt[1],fr=(a.data[It++]-g[2])*bt[2],jr=zt===-1?255:(a.data[zt++]-g[3])*bt[3];s.fillStyle="rgba("+Qt+","+cr+","+fr+","+jr+")",s.fillRect(Hn,er,1,1)}if("toDataURL"in o)return o.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},ci=(a,e)=>{let o=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),s;if(o!=null){let d,c,h;(e==null?void 0:e.tensorLayout)!==void 0&&e.tensorLayout==="NHWC"?(d=a.dims[2],c=a.dims[1],h=a.dims[3]):(d=a.dims[3],c=a.dims[2],h=a.dims[1]);let _=e!==void 0&&e.format!==void 0?e.format:"RGB",bt=e==null?void 0:e.norm,g,j;bt===void 0||bt.mean===void 0?g=[255,255,255,255]:typeof bt.mean=="number"?g=[bt.mean,bt.mean,bt.mean,bt.mean]:(g=[bt.mean[0],bt.mean[1],bt.mean[2],255],bt.mean[3]!==void 0&&(g[3]=bt.mean[3])),bt===void 0||bt.bias===void 0?j=[0,0,0,0]:typeof bt.bias=="number"?j=[bt.bias,bt.bias,bt.bias,bt.bias]:(j=[bt.bias[0],bt.bias[1],bt.bias[2],0],bt.bias[3]!==void 0&&(j[3]=bt.bias[3]));let b=c*d;if(e!==void 0&&(e.format!==void 0&&h===4&&e.format!=="RGBA"||h===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let Et=4,It=0,zt=1,er=2,Hn=3,Qt=0,cr=b,fr=b*2,jr=-1;_==="RGBA"?(Qt=0,cr=b,fr=b*2,jr=b*3):_==="RGB"?(Qt=0,cr=b,fr=b*2):_==="RBG"&&(Qt=0,fr=b,cr=b*2),s=o.createImageData(d,c);for(let e0=0;e0<c*d;It+=Et,zt+=Et,er+=Et,Hn+=Et,e0++)s.data[It]=(a.data[Qt++]-j[0])*g[0],s.data[zt]=(a.data[cr++]-j[1])*g[1],s.data[er]=(a.data[fr++]-j[2])*g[2],s.data[Hn]=jr===-1?255:(a.data[jr++]-j[3])*g[3]}else throw new Error("Can not access image data");return s}}),jn,fi,mi,hi,gi,yi=F(()=>{Jr(),jn=(a,e)=>{if(a===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:o,width:s}=e,d=e.norm??{mean:255,bias:0},c,h;typeof d.mean=="number"?c=[d.mean,d.mean,d.mean,d.mean]:c=[d.mean[0],d.mean[1],d.mean[2],d.mean[3]??255],typeof d.bias=="number"?h=[d.bias,d.bias,d.bias,d.bias]:h=[d.bias[0],d.bias[1],d.bias[2],d.bias[3]??0];let _=e.format!==void 0?e.format:"RGBA",bt=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",g=o*s,j=bt==="RGBA"?new Float32Array(g*4):new Float32Array(g*3),b=4,Et=0,It=1,zt=2,er=3,Hn=0,Qt=g,cr=g*2,fr=-1;_==="RGB"&&(b=3,Et=0,It=1,zt=2,er=-1),bt==="RGBA"?fr=g*3:bt==="RBG"?(Hn=0,cr=g,Qt=g*2):bt==="BGR"&&(cr=0,Qt=g,Hn=g*2);for(let jr=0;jr<g;jr++,Et+=b,zt+=b,It+=b,er+=b)j[Hn++]=(a[Et]+h[0])/c[0],j[Qt++]=(a[It]+h[1])/c[1],j[cr++]=(a[zt]+h[2])/c[2],fr!==-1&&er!==-1&&(j[fr++]=(a[er]+h[3])/c[3]);return bt==="RGBA"?new rt("float32",j,[1,4,o,s]):new rt("float32",j,[1,3,o,s])},fi=async(a,e)=>{let o=typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement,s=typeof ImageData<"u"&&a instanceof ImageData,d=typeof ImageBitmap<"u"&&a instanceof ImageBitmap,c=typeof a=="string",h,_=e??{},bt=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},g=j=>j instanceof HTMLCanvasElement||j instanceof OffscreenCanvas?j.getContext("2d"):null;if(o){let j=bt();j.width=a.width,j.height=a.height;let b=g(j);if(b!=null){let Et=a.height,It=a.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(Et=e.resizedHeight,It=e.resizedWidth),e!==void 0){if(_=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");_.tensorFormat="RGBA",_.height=Et,_.width=It}else _.tensorFormat="RGBA",_.height=Et,_.width=It;b.drawImage(a,0,0),h=b.getImageData(0,0,It,Et).data}else throw new Error("Can not access image data")}else if(s){let j,b;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(j=e.resizedHeight,b=e.resizedWidth):(j=a.height,b=a.width),e!==void 0&&(_=e),_.format="RGBA",_.height=j,_.width=b,e!==void 0){let Et=bt();Et.width=b,Et.height=j;let It=g(Et);if(It!=null)It.putImageData(a,0,0),h=It.getImageData(0,0,b,j).data;else throw new Error("Can not access image data")}else h=a.data}else if(d){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let j=bt();j.width=a.width,j.height=a.height;let b=g(j);if(b!=null){let Et=a.height,It=a.width;return b.drawImage(a,0,0,It,Et),h=b.getImageData(0,0,It,Et).data,_.height=Et,_.width=It,jn(h,_)}else throw new Error("Can not access image data")}else{if(c)return new Promise((j,b)=>{let Et=bt(),It=g(Et);if(!a||!It)return b();let zt=new Image;zt.crossOrigin="Anonymous",zt.src=a,zt.onload=()=>{Et.width=zt.width,Et.height=zt.height,It.drawImage(zt,0,0,Et.width,Et.height);let er=It.getImageData(0,0,Et.width,Et.height);_.height=Et.height,_.width=Et.width,j(jn(er.data,_))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(h!==void 0)return jn(h,_);throw new Error("Input data provided is not supported - aborted tensor creation")},mi=(a,e)=>{let{width:o,height:s,download:d,dispose:c}=e,h=[1,s,o,4];return new rt({location:"texture",type:"float32",texture:a,dims:h,download:d,dispose:c})},hi=(a,e)=>{let{dataType:o,dims:s,download:d,dispose:c}=e;return new rt({location:"gpu-buffer",type:o??"float32",gpuBuffer:a,dims:s,download:d,dispose:c})},gi=(a,e,o)=>new rt({location:"cpu-pinned",type:a,data:e,dims:o??[e.length]})}),Ft,Sr,bi,wi,vi=F(()=>{Ft=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Sr=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),bi=!1,wi=()=>{if(!bi){bi=!0;let a=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,o=typeof Float16Array<"u"&&Float16Array.from;a&&(Ft.set("int64",BigInt64Array),Sr.set(BigInt64Array,"int64")),e&&(Ft.set("uint64",BigUint64Array),Sr.set(BigUint64Array,"uint64")),o?(Ft.set("float16",Float16Array),Sr.set(Float16Array,"float16")):Ft.set("float16",Uint16Array)}}}),$i,_i,xi=F(()=>{Jr(),$i=a=>{let e=1;for(let o=0;o<a.length;o++){let s=a[o];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${o}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${o}] must be a non-negative integer, got: ${s}`);e*=s}return e},_i=(a,e)=>{switch(a.location){case"cpu":return new rt(a.type,a.data,e);case"cpu-pinned":return new rt({location:"cpu-pinned",data:a.data,type:a.type,dims:e});case"texture":return new rt({location:"texture",texture:a.texture,type:a.type,dims:e});case"gpu-buffer":return new rt({location:"gpu-buffer",gpuBuffer:a.gpuBuffer,type:a.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${a.location} is not supported`)}}}),rt,Jr=F(()=>{pi(),yi(),vi(),xi(),rt=class{constructor(a,e,o){wi();let s,d;if(typeof a=="object"&&"location"in a)switch(this.dataLocation=a.location,s=a.type,d=a.dims,a.location){case"cpu-pinned":{let h=Ft.get(s);if(!h)throw new TypeError(`unsupported type "${s}" to create tensor from pinned buffer`);if(!(a.data instanceof h))throw new TypeError(`buffer should be of type ${h.name}`);this.cpuData=a.data;break}case"texture":{if(s!=="float32")throw new TypeError(`unsupported type "${s}" to create tensor from texture`);this.gpuTextureData=a.texture,this.downloader=a.download,this.disposer=a.dispose;break}case"gpu-buffer":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint8"&&s!=="bool")throw new TypeError(`unsupported type "${s}" to create tensor from gpu buffer`);this.gpuBufferData=a.gpuBuffer,this.downloader=a.download,this.disposer=a.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let h,_;if(typeof a=="string")if(s=a,_=o,a==="string"){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");h=e}else{let bt=Ft.get(a);if(bt===void 0)throw new TypeError(`Unsupported tensor type: ${a}.`);if(Array.isArray(e)){if(a==="float16"&&bt===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");a==="uint64"||a==="int64"?h=bt.from(e,BigInt):h=bt.from(e)}else if(e instanceof bt)h=e;else throw new TypeError(`A ${s} tensor's data must be type of ${bt}`)}else if(_=e,Array.isArray(a)){if(a.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let bt=typeof a[0];if(bt==="string")s="string",h=a;else if(bt==="boolean")s="bool",h=Uint8Array.from(a);else throw new TypeError(`Invalid element type of data array: ${bt}.`)}else{let bt=Sr.get(a.constructor);if(bt===void 0)throw new TypeError(`Unsupported type for tensor data: ${a.constructor}.`);s=bt,h=a}if(_===void 0)_=[h.length];else if(!Array.isArray(_))throw new TypeError("A tensor's dims must be a number array");d=_,this.cpuData=h,this.dataLocation="cpu"}let c=$i(d);if(this.cpuData&&c!==this.cpuData.length)throw new Error(`Tensor's size(${c}) does not match data length(${this.cpuData.length}).`);this.type=s,this.dims=d,this.size=c}static async fromImage(a,e){return fi(a,e)}static fromTexture(a,e){return mi(a,e)}static fromGpuBuffer(a,e){return hi(a,e)}static fromPinnedBuffer(a,e,o){return gi(a,e,o)}toDataURL(a){return di(this,a)}toImageData(a){return ci(this,a)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(a){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=e,a&&this.disposer&&(this.disposer(),this.disposer=void 0),e}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(a){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return _i(this,a)}}}),Ze,en=F(()=>{Jr(),Ze=rt}),tn,Si,st,nt,Kn=F(()=>{qn(),tn=(a,e)=>{(typeof ot.trace>"u"?!ot.wasm.trace:!ot.trace)||console.timeStamp(`${a}::ORT::${e}`)},Si=(a,e)=>{var d;let o=((d=new Error().stack)==null?void 0:d.split(/\r\n|\r|\n/g))||[],s=!1;for(let c=0;c<o.length;c++){if(s&&!o[c].includes("TRACE_FUNC")){let h=`FUNC_${a}::${o[c].trim().split(" ")[1]}`;e&&(h+=`::${e}`),tn("CPU",h);return}o[c].includes("TRACE_FUNC")&&(s=!0)}},st=a=>{(typeof ot.trace>"u"?!ot.wasm.trace:!ot.trace)||Si("BEGIN",a)},nt=a=>{(typeof ot.trace>"u"?!ot.wasm.trace:!ot.trace)||Si("END",a)}}),rn,Ci=F(()=>{Qr(),en(),Kn(),rn=class pA{constructor(e){this.handler=e}async run(e,o,s){st();let d={},c={};if(typeof e!="object"||e===null||e instanceof Ze||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let h=!0;if(typeof o=="object"){if(o===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(o instanceof Ze)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(o)){if(o.length===0)throw new TypeError("'fetches' cannot be an empty array.");h=!1;for(let g of o){if(typeof g!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(g)===-1)throw new RangeError(`'fetches' contains invalid output name: ${g}.`);d[g]=null}if(typeof s=="object"&&s!==null)c=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let g=!1,j=Object.getOwnPropertyNames(o);for(let b of this.outputNames)if(j.indexOf(b)!==-1){let Et=o[b];(Et===null||Et instanceof Ze)&&(g=!0,h=!1,d[b]=Et)}if(g){if(typeof s=="object"&&s!==null)c=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else c=o}}else if(typeof o<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let g of this.inputNames)if(typeof e[g]>"u")throw new Error(`input '${g}' is missing in 'feeds'.`);if(h)for(let g of this.outputNames)d[g]=null;let _=await this.handler.run(e,d,c),bt={};for(let g in _)if(Object.hasOwnProperty.call(_,g)){let j=_[g];j instanceof Ze?bt[g]=j:bt[g]=new Ze(j.type,j.data,j.dims)}return nt(),bt}async release(){return this.handler.dispose()}static async create(e,o,s,d){st();let c,h={};if(typeof e=="string"){if(c=e,typeof o=="object"&&o!==null)h=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(c=e,typeof o=="object"&&o!==null)h=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let j=e,b=0,Et=e.byteLength;if(typeof o=="object"&&o!==null)h=o;else if(typeof o=="number"){if(b=o,!Number.isSafeInteger(b))throw new RangeError("'byteOffset' must be an integer.");if(b<0||b>=j.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${j.byteLength}).`);if(Et=e.byteLength-b,typeof s=="number"){if(Et=s,!Number.isSafeInteger(Et))throw new RangeError("'byteLength' must be an integer.");if(Et<=0||b+Et>j.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${j.byteLength-b}].`);if(typeof d=="object"&&d!==null)h=d;else if(typeof d<"u")throw new TypeError("'options' must be an object.")}else if(typeof s<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof o<"u")throw new TypeError("'options' must be an object.");c=new Uint8Array(j,b,Et)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[_,bt]=await Xr(h),g=await _.createInferenceSessionHandler(c,bt);return nt(),new pA(g)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),md,Ii=F(()=>{Ci(),md=rn}),Ei=F(()=>{}),Ai=F(()=>{}),Ti=F(()=>{}),Oi=F(()=>{}),hd,nn,ki=F(()=>{Qr(),en(),hd="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",nn=class hA{constructor(e,o,s){this.handler=e,this.hasOptimizerModel=o,this.hasEvalModel=s}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(e,o){let s=e.evalModel||"",d=e.optimizerModel||"",c=o||{},[h,_]=await Xr(c);if(h.createTrainingSessionHandler){let bt=await h.createTrainingSessionHandler(e.checkpointState,e.trainModel,s,d,_);return new hA(bt,!!e.optimizerModel,!!e.evalModel)}else throw new Error(hd)}typeNarrowingForRunStep(e,o,s,d,c){let h={},_={};if(typeof s!="object"||s===null||s instanceof Ze||Array.isArray(s))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let bt=!0;if(typeof d=="object"){if(d===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(d instanceof Ze)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(d)){if(d.length===0)throw new TypeError("'fetches' cannot be an empty array.");bt=!1;for(let g of d){if(typeof g!="string")throw new TypeError("'fetches' must be a string array or an object.");if(o.indexOf(g)===-1)throw new RangeError(`'fetches' contains invalid output name: ${g}.`);h[g]=null}if(typeof c=="object"&&c!==null)_=c;else if(typeof c<"u")throw new TypeError("'options' must be an object.")}else{let g=!1,j=Object.getOwnPropertyNames(d);for(let b of o)if(j.indexOf(b)!==-1){let Et=d[b];(Et===null||Et instanceof Ze)&&(g=!0,bt=!1,h[b]=Et)}if(g){if(typeof c=="object"&&c!==null)_=c;else if(typeof c<"u")throw new TypeError("'options' must be an object.")}else _=d}}else if(typeof d<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let g of e)if(typeof s[g]>"u")throw new Error(`input '${g}' is missing in 'feeds'.`);if(bt)for(let g of o)h[g]=null;return[h,_]}convertHandlerReturnTypeToMapOfTensors(e){let o={};for(let s in e)if(Object.hasOwnProperty.call(e,s)){let d=e[s];d instanceof Ze?o[s]=d:o[s]=new Ze(d.type,d.data,d.dims)}return o}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,o,s){let[d,c]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,o,s),h=await this.handler.runTrainStep(e,d,c);return this.convertHandlerReturnTypeToMapOfTensors(h)}async runOptimizerStep(e){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(e||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(e,o,s){if(this.hasEvalModel){let[d,c]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,o,s),h=await this.handler.runEvalStep(e,d,c);return this.convertHandlerReturnTypeToMapOfTensors(h)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,o=!0){let s=await this.getParametersSize(o);if(e.length!==4*s)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,o)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}}}),gd,Pi=F(()=>{ki(),gd=nn}),Yn={};rr(Yn,{InferenceSession:()=>md,TRACE:()=>tn,TRACE_FUNC_BEGIN:()=>st,TRACE_FUNC_END:()=>nt,Tensor:()=>Ze,TrainingSession:()=>gd,env:()=>Ae,registerBackend:()=>Lt});var lt=F(()=>{ii(),li(),Ii(),en(),Ei(),Ai(),Kn(),Ti(),Oi(),Pi()}),Zn={};rr(Zn,{createReadStream:()=>zi,readFile:()=>yd,readFileSync:()=>bd});var yd,bd,zi,Xn=F(()=>{yd=void 0,bd=void 0,zi=void 0}),Qn={};rr(Qn,{join:()=>wd});var wd,Jn=F(()=>{wd=void 0}),Mi=tr((a,e)=>{var o=(()=>{var s=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(s=s||__filename),function(d={}){var c=d,h,_;c.ready=new Promise((Yr,r0)=>{h=Yr,_=r0}),c.mountExternalData=(Yr,r0)=>{(c.Fa||(c.Fa=new Map)).set(Yr,r0)},c.unmountExternalData=()=>{delete c.Fa};let bt=()=>{let Yr=(p0,_0,D0)=>(...V0)=>{let yy=Py,ly=_0==null?void 0:_0();V0=p0(...V0);let gy=_0==null?void 0:_0();return ly!==gy&&(p0=gy,D0(ly),_0=D0=null),Py!=yy?ev():V0},r0=p0=>async(..._0)=>{var D0;try{if(c.Ea)throw Error("Session already started");let V0=c.Ea={Za:_0[0],errors:[]},yy=await p0(..._0);if(c.Ea!==V0)throw Error("Session mismatch");(D0=c.La)==null||D0.flush();let ly=V0.errors;if(0<ly.length){let gy=await Promise.all(ly);if(gy=gy.filter(ky=>ky),0<gy.length)throw Error(gy.join(`
`))}return yy}finally{c.Ea=null}};c._OrtCreateSession=Yr(c._OrtCreateSession,()=>c._OrtCreateSession,p0=>c._OrtCreateSession=p0),c._OrtRun=r0(Yr(c._OrtRun,()=>c._OrtRun,p0=>c._OrtRun=p0)),c._OrtRunWithBinding=r0(Yr(c._OrtRunWithBinding,()=>c._OrtRunWithBinding,p0=>c._OrtRunWithBinding=p0)),c._OrtBindInput=Yr(c._OrtBindInput,()=>c._OrtBindInput,p0=>c._OrtBindInput=p0),bt=void 0};c.jsepInit=(Yr,r0)=>{if(bt==null||bt(),Yr==="webgpu"){[c.La,c.Ra,c.Va,c.Ma,c.Ua,c.sa,c.Wa,c.Ya,c.Sa,c.Ta,c.Xa]=r0;let p0=c.La;c.jsepRegisterBuffer=(_0,D0,V0,yy)=>p0.registerBuffer(_0,D0,V0,yy),c.jsepGetBuffer=_0=>p0.getBuffer(_0),c.jsepCreateDownloader=(_0,D0,V0)=>p0.createDownloader(_0,D0,V0),c.jsepOnReleaseSession=_0=>{p0.onReleaseSession(_0)},c.jsepOnRunStart=_0=>p0.onRunStart(_0)}};var g=Object.assign({},c),j="./this.program",b=(Yr,r0)=>{throw r0},Et=typeof window=="object",It=typeof importScripts=="function",zt=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",er="",Hn,Qt,cr;if(zt){var fr=(Xn(),Gt(Zn)),jr=(Jn(),Gt(Qn));er=It?jr.dirname(er)+"/":__dirname+"/",Hn=(Yr,r0)=>(Yr=J0(Yr)?new URL(Yr):jr.normalize(Yr),fr.readFileSync(Yr,r0?void 0:"utf8")),cr=Yr=>(Yr=Hn(Yr,!0),Yr.buffer||(Yr=new Uint8Array(Yr)),Yr),Qt=(Yr,r0,p0,_0=!0)=>{Yr=J0(Yr)?new URL(Yr):jr.normalize(Yr),fr.readFile(Yr,_0?void 0:"utf8",(D0,V0)=>{D0?p0(D0):r0(_0?V0.buffer:V0)})},!c.thisProgram&&1<process.argv.length&&(j=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),b=(Yr,r0)=>{throw process.exitCode=Yr,r0},c.inspect=()=>"[Emscripten Module object]"}else(Et||It)&&(It?er=self.location.href:typeof document<"u"&&document.currentScript&&(er=document.currentScript.src),s&&(er=s),er.indexOf("blob:")!==0?er=er.substr(0,er.replace(/[?#].*/,"").lastIndexOf("/")+1):er="",Hn=Yr=>{var r0=new XMLHttpRequest;return r0.open("GET",Yr,!1),r0.send(null),r0.responseText},It&&(cr=Yr=>{var r0=new XMLHttpRequest;return r0.open("GET",Yr,!1),r0.responseType="arraybuffer",r0.send(null),new Uint8Array(r0.response)}),Qt=(Yr,r0,p0)=>{var _0=new XMLHttpRequest;_0.open("GET",Yr,!0),_0.responseType="arraybuffer",_0.onload=()=>{_0.status==200||_0.status==0&&_0.response?r0(_0.response):p0()},_0.onerror=p0,_0.send(null)});var e0=console.log.bind(console),t0=console.error.bind(console);Object.assign(c,g),g=null,typeof WebAssembly!="object"&&q0("no native wasm support detected");var o0,l0=!1,g0,i0,f0,C0,Z0,R0,Y0;function H0(){var Yr=o0.buffer;c.HEAP8=i0=new Int8Array(Yr),c.HEAP16=new Int16Array(Yr),c.HEAPU8=f0=new Uint8Array(Yr),c.HEAPU16=new Uint16Array(Yr),c.HEAP32=C0=new Int32Array(Yr),c.HEAPU32=Z0=new Uint32Array(Yr),c.HEAPF32=R0=new Float32Array(Yr),c.HEAPF64=Y0=new Float64Array(Yr)}var ty=[],w0=[],L0=[],k0=0,T0=null;function q0(Yr){throw Yr="Aborted("+Yr+")",t0(Yr),l0=!0,g0=1,Yr=new WebAssembly.RuntimeError(Yr+". Build with -sASSERTIONS for more info."),_(Yr),Yr}var vy=Yr=>Yr.startsWith("data:application/octet-stream;base64,"),J0=Yr=>Yr.startsWith("file://"),cy;if(cy="ort-wasm-simd.wasm",!vy(cy)){var Ty=cy;cy=c.locateFile?c.locateFile(Ty,er):er+Ty}function Uy(Yr){if(cr)return cr(Yr);throw"both async and sync fetching of the wasm failed"}function Qy(Yr){if(Et||It){if(typeof fetch=="function"&&!J0(Yr))return fetch(Yr,{credentials:"same-origin"}).then(r0=>{if(!r0.ok)throw"failed to load wasm binary file at '"+Yr+"'";return r0.arrayBuffer()}).catch(()=>Uy(Yr));if(Qt)return new Promise((r0,p0)=>{Qt(Yr,_0=>r0(new Uint8Array(_0)),p0)})}return Promise.resolve().then(()=>Uy(Yr))}function Zy(Yr,r0,p0){return Qy(Yr).then(_0=>WebAssembly.instantiate(_0,r0)).then(_0=>_0).then(p0,_0=>{t0(`failed to asynchronously prepare wasm: ${_0}`),q0(_0)})}function iv(Yr,r0){var p0=cy;return typeof WebAssembly.instantiateStreaming!="function"||vy(p0)||J0(p0)||zt||typeof fetch!="function"?Zy(p0,Yr,r0):fetch(p0,{credentials:"same-origin"}).then(_0=>WebAssembly.instantiateStreaming(_0,Yr).then(r0,function(D0){return t0(`wasm streaming compile failed: ${D0}`),t0("falling back to ArrayBuffer instantiation"),Zy(p0,Yr,r0)}))}var zy,B0={931760:(Yr,r0,p0,_0)=>{if(typeof c>"u"||!c.Fa)return 1;if(Yr=Gy(Yr>>>0),Yr.startsWith("./")&&(Yr=Yr.substring(2)),Yr=c.Fa.get(Yr),!Yr)return 2;if(r0>>>=0,p0>>>=0,r0+p0>Yr.byteLength)return 3;try{return f0.set(Yr.subarray(r0,r0+p0),_0>>>0>>>0),0}catch{return 4}},932261:()=>{c.Sa()},932292:()=>{c.Ta()},932321:()=>{c.Xa()},932346:Yr=>c.Ra(Yr),932379:Yr=>c.Va(Yr),932411:(Yr,r0,p0)=>{c.Ma(Yr,r0,p0,!0)},932450:(Yr,r0,p0)=>{c.Ma(Yr,r0,p0)},932483:Yr=>{c.sa("Abs",Yr,void 0)},932534:Yr=>{c.sa("Neg",Yr,void 0)},932585:Yr=>{c.sa("Floor",Yr,void 0)},932638:Yr=>{c.sa("Ceil",Yr,void 0)},932690:Yr=>{c.sa("Reciprocal",Yr,void 0)},932748:Yr=>{c.sa("Sqrt",Yr,void 0)},932800:Yr=>{c.sa("Exp",Yr,void 0)},932851:Yr=>{c.sa("Erf",Yr,void 0)},932902:Yr=>{c.sa("Sigmoid",Yr,void 0)},932957:(Yr,r0,p0)=>{c.sa("HardSigmoid",Yr,{alpha:r0,beta:p0})},933036:Yr=>{c.sa("Log",Yr,void 0)},933087:Yr=>{c.sa("Sin",Yr,void 0)},933138:Yr=>{c.sa("Cos",Yr,void 0)},933189:Yr=>{c.sa("Tan",Yr,void 0)},933240:Yr=>{c.sa("Asin",Yr,void 0)},933292:Yr=>{c.sa("Acos",Yr,void 0)},933344:Yr=>{c.sa("Atan",Yr,void 0)},933396:Yr=>{c.sa("Sinh",Yr,void 0)},933448:Yr=>{c.sa("Cosh",Yr,void 0)},933500:Yr=>{c.sa("Asinh",Yr,void 0)},933553:Yr=>{c.sa("Acosh",Yr,void 0)},933606:Yr=>{c.sa("Atanh",Yr,void 0)},933659:Yr=>{c.sa("Tanh",Yr,void 0)},933711:Yr=>{c.sa("Not",Yr,void 0)},933762:(Yr,r0,p0)=>{c.sa("Clip",Yr,{min:r0,max:p0})},933831:Yr=>{c.sa("Clip",Yr,void 0)},933883:(Yr,r0)=>{c.sa("Elu",Yr,{alpha:r0})},933941:Yr=>{c.sa("Relu",Yr,void 0)},933993:(Yr,r0)=>{c.sa("LeakyRelu",Yr,{alpha:r0})},934057:(Yr,r0)=>{c.sa("ThresholdedRelu",Yr,{alpha:r0})},934127:(Yr,r0)=>{c.sa("Cast",Yr,{to:r0})},934185:Yr=>{c.sa("Add",Yr,void 0)},934236:Yr=>{c.sa("Sub",Yr,void 0)},934287:Yr=>{c.sa("Mul",Yr,void 0)},934338:Yr=>{c.sa("Div",Yr,void 0)},934389:Yr=>{c.sa("Pow",Yr,void 0)},934440:Yr=>{c.sa("Equal",Yr,void 0)},934493:Yr=>{c.sa("Greater",Yr,void 0)},934548:Yr=>{c.sa("GreaterOrEqual",Yr,void 0)},934610:Yr=>{c.sa("Less",Yr,void 0)},934662:Yr=>{c.sa("LessOrEqual",Yr,void 0)},934721:(Yr,r0,p0,_0,D0)=>{c.sa("ReduceMean",Yr,{keepDims:!!r0,noopWithEmptyAxes:!!p0,axes:_0?Array.from(C0.subarray(_0>>>0,D0>>>0)):[]})},934880:(Yr,r0,p0,_0,D0)=>{c.sa("ReduceMax",Yr,{keepDims:!!r0,noopWithEmptyAxes:!!p0,axes:_0?Array.from(C0.subarray(_0>>>0,D0>>>0)):[]})},935038:(Yr,r0,p0,_0,D0)=>{c.sa("ReduceMin",Yr,{keepDims:!!r0,noopWithEmptyAxes:!!p0,axes:_0?Array.from(C0.subarray(_0>>>0,D0>>>0)):[]})},935196:(Yr,r0,p0,_0,D0)=>{c.sa("ReduceProd",Yr,{keepDims:!!r0,noopWithEmptyAxes:!!p0,axes:_0?Array.from(C0.subarray(_0>>>0,D0>>>0)):[]})},935355:(Yr,r0,p0,_0,D0)=>{c.sa("ReduceSum",Yr,{keepDims:!!r0,noopWithEmptyAxes:!!p0,axes:_0?Array.from(C0.subarray(_0>>>0,D0>>>0)):[]})},935513:(Yr,r0,p0,_0,D0)=>{c.sa("ReduceL1",Yr,{keepDims:!!r0,noopWithEmptyAxes:!!p0,axes:_0?Array.from(C0.subarray(_0>>>0,D0>>>0)):[]})},935670:(Yr,r0,p0,_0,D0)=>{c.sa("ReduceL2",Yr,{keepDims:!!r0,noopWithEmptyAxes:!!p0,axes:_0?Array.from(C0.subarray(_0>>>0,D0>>>0)):[]})},935827:(Yr,r0,p0,_0,D0)=>{c.sa("ReduceLogSum",Yr,{keepDims:!!r0,noopWithEmptyAxes:!!p0,axes:_0?Array.from(C0.subarray(_0>>>0,D0>>>0)):[]})},935988:(Yr,r0,p0,_0,D0)=>{c.sa("ReduceSumSquare",Yr,{keepDims:!!r0,noopWithEmptyAxes:!!p0,axes:_0?Array.from(C0.subarray(_0>>>0,D0>>>0)):[]})},936152:(Yr,r0,p0,_0,D0)=>{c.sa("ReduceLogSumExp",Yr,{keepDims:!!r0,noopWithEmptyAxes:!!p0,axes:_0?Array.from(C0.subarray(_0>>>0,D0>>>0)):[]})},936316:Yr=>{c.sa("Where",Yr,void 0)},936369:(Yr,r0,p0)=>{c.sa("Transpose",Yr,{perm:r0?Array.from(C0.subarray(r0>>>0,p0>>>0)):[]})},936477:(Yr,r0,p0,_0,D0,V0,yy,ly,gy,ky,jy,rv,dv,K0,Cy)=>{c.sa("ConvTranspose",Yr,{format:gy?"NHWC":"NCHW",autoPad:r0,dilations:[p0],group:_0,kernel_shape:[D0],pads:[V0,yy],strides:[ly],wIsConst:()=>!!i0[ky>>>0],outputPadding:jy?Array.from(C0.subarray(jy>>>0,rv>>>0)):[],outputShape:dv?Array.from(C0.subarray(dv>>>0,K0>>>0)):[],activation:Gy(Cy)})},936879:(Yr,r0,p0,_0,D0,V0,yy,ly,gy,ky,jy,rv,dv,K0)=>{c.sa("ConvTranspose",Yr,{format:ly?"NHWC":"NCHW",autoPad:r0,dilations:Array.from(C0.subarray(p0>>>0,(p0>>>0)+2>>>0)),group:_0,kernelShape:Array.from(C0.subarray(D0>>>0,(D0>>>0)+2>>>0)),pads:Array.from(C0.subarray(V0>>>0,(V0>>>0)+4>>>0)),strides:Array.from(C0.subarray(yy>>>0,(yy>>>0)+2>>>0)),wIsConst:()=>!!i0[gy>>>0],outputPadding:ky?Array.from(C0.subarray(ky>>>0,jy>>>0)):[],outputShape:rv?Array.from(C0.subarray(rv>>>0,dv>>>0)):[],activation:Gy(K0)})},937444:(Yr,r0,p0,_0,D0,V0,yy,ly,gy,ky,jy,rv,dv,K0,Cy)=>{c.sa("ConvTranspose",Yr,{format:gy?"NHWC":"NCHW",autoPad:r0,dilations:[p0],group:_0,kernel_shape:[D0],pads:[V0,yy],strides:[ly],wIsConst:()=>!!i0[ky>>>0],outputPadding:jy?Array.from(C0.subarray(jy>>>0,rv>>>0)):[],outputShape:dv?Array.from(C0.subarray(dv>>>0,K0>>>0)):[],activation:Gy(Cy)})},937846:(Yr,r0,p0,_0,D0,V0,yy,ly,gy,ky,jy,rv,dv,K0)=>{c.sa("ConvTranspose",Yr,{format:ly?"NHWC":"NCHW",autoPad:r0,dilations:Array.from(C0.subarray(p0>>>0,(p0>>>0)+2>>>0)),group:_0,kernelShape:Array.from(C0.subarray(D0>>>0,(D0>>>0)+2>>>0)),pads:Array.from(C0.subarray(V0>>>0,(V0>>>0)+4>>>0)),strides:Array.from(C0.subarray(yy>>>0,(yy>>>0)+2>>>0)),wIsConst:()=>!!i0[gy>>>0],outputPadding:ky?Array.from(C0.subarray(ky>>>0,jy>>>0)):[],outputShape:rv?Array.from(C0.subarray(rv>>>0,dv>>>0)):[],activation:Gy(K0)})},938411:(Yr,r0)=>{c.sa("GlobalAveragePool",Yr,{format:r0?"NHWC":"NCHW"})},938502:(Yr,r0,p0,_0,D0,V0,yy,ly,gy,ky,jy,rv,dv,K0,Cy,lv)=>{c.sa("AveragePool",Yr,{format:lv?"NHWC":"NCHW",auto_pad:r0,ceil_mode:p0,count_include_pad:_0,storage_order:D0,dilations:[V0,yy],kernel_shape:[ly,gy],pads:[ky,jy,rv,dv],strides:[K0,Cy]})},938786:(Yr,r0)=>{c.sa("GlobalAveragePool",Yr,{format:r0?"NHWC":"NCHW"})},938877:(Yr,r0,p0,_0,D0,V0,yy,ly,gy,ky,jy,rv,dv,K0,Cy,lv)=>{c.sa("AveragePool",Yr,{format:lv?"NHWC":"NCHW",auto_pad:r0,ceil_mode:p0,count_include_pad:_0,storage_order:D0,dilations:[V0,yy],kernel_shape:[ly,gy],pads:[ky,jy,rv,dv],strides:[K0,Cy]})},939161:(Yr,r0)=>{c.sa("GlobalMaxPool",Yr,{format:r0?"NHWC":"NCHW"})},939248:(Yr,r0,p0,_0,D0,V0,yy,ly,gy,ky,jy,rv,dv,K0,Cy,lv)=>{c.sa("MaxPool",Yr,{format:lv?"NHWC":"NCHW",auto_pad:r0,ceil_mode:p0,count_include_pad:_0,storage_order:D0,dilations:[V0,yy],kernel_shape:[ly,gy],pads:[ky,jy,rv,dv],strides:[K0,Cy]})},939528:(Yr,r0)=>{c.sa("GlobalMaxPool",Yr,{format:r0?"NHWC":"NCHW"})},939615:(Yr,r0,p0,_0,D0,V0,yy,ly,gy,ky,jy,rv,dv,K0,Cy,lv)=>{c.sa("MaxPool",Yr,{format:lv?"NHWC":"NCHW",auto_pad:r0,ceil_mode:p0,count_include_pad:_0,storage_order:D0,dilations:[V0,yy],kernel_shape:[ly,gy],pads:[ky,jy,rv,dv],strides:[K0,Cy]})},939895:(Yr,r0,p0,_0,D0)=>{c.sa("Gemm",Yr,{alpha:r0,beta:p0,transA:_0,transB:D0})},939999:Yr=>{c.sa("MatMul",Yr,void 0)},940053:(Yr,r0,p0,_0)=>{c.sa("ArgMax",Yr,{keepDims:!!r0,selectLastIndex:!!p0,axis:_0})},940161:(Yr,r0,p0,_0)=>{c.sa("ArgMin",Yr,{keepDims:!!r0,selectLastIndex:!!p0,axis:_0})},940269:(Yr,r0)=>{c.sa("Softmax",Yr,{axis:r0})},940332:(Yr,r0)=>{c.sa("Concat",Yr,{axis:r0})},940392:(Yr,r0,p0,_0,D0)=>{c.sa("Split",Yr,{axis:r0,numOutputs:p0,splitSizes:_0?Array.from(C0.subarray(_0>>>0,D0>>>0)):[]})},940532:Yr=>{c.sa("Expand",Yr,void 0)},940586:(Yr,r0)=>{c.sa("Gather",Yr,{axis:Number(r0)})},940657:(Yr,r0)=>{c.sa("GatherElements",Yr,{axis:Number(r0)})},940736:(Yr,r0,p0,_0,D0,V0,yy,ly,gy,ky,jy)=>{c.sa("Resize",Yr,{antialias:r0,axes:p0?Array.from(C0.subarray(p0>>>0,_0>>>0)):[],coordinateTransformMode:Gy(D0),cubicCoeffA:V0,excludeOutside:yy,extrapolationValue:ly,keepAspectRatioPolicy:Gy(gy),mode:Gy(ky),nearestMode:Gy(jy)})},941082:(Yr,r0,p0,_0,D0,V0,yy)=>{c.sa("Slice",Yr,{starts:r0?Array.from(C0.subarray(r0>>>0,p0>>>0)):[],ends:_0?Array.from(C0.subarray(_0>>>0,D0>>>0)):[],axes:V0?Array.from(C0.subarray(V0>>>0,yy>>>0)):[]})},941298:Yr=>{c.sa("Tile",Yr,void 0)},941350:(Yr,r0,p0)=>{c.sa("LayerNormalization",Yr,{axis:Number(r0),epsilon:Number(p0)})},941457:(Yr,r0,p0)=>{c.sa("InstanceNormalization",Yr,{epsilon:r0,format:p0?"NHWC":"NCHW"})},941571:(Yr,r0,p0)=>{c.sa("InstanceNormalization",Yr,{epsilon:r0,format:p0?"NHWC":"NCHW"})},941685:Yr=>{c.sa("Range",Yr,void 0)},941738:(Yr,r0)=>{c.sa("Einsum",Yr,{equation:Gy(r0)})},941819:(Yr,r0,p0,_0,D0)=>{c.sa("Pad",Yr,{mode:r0,value:p0,pads:_0?Array.from(C0.subarray(_0>>>0,D0>>>0)):[]})},941946:(Yr,r0,p0,_0,D0,V0)=>{c.sa("BatchNormalization",Yr,{epsilon:r0,momentum:p0,spatial:!!D0,trainingMode:!!_0,format:V0?"NHWC":"NCHW"})},942115:(Yr,r0,p0,_0,D0,V0)=>{c.sa("BatchNormalization",Yr,{epsilon:r0,momentum:p0,spatial:!!D0,trainingMode:!!_0,format:V0?"NHWC":"NCHW"})},942284:(Yr,r0,p0)=>{c.sa("CumSum",Yr,{exclusive:Number(r0),reverse:Number(p0)})},942381:(Yr,r0,p0,_0,D0,V0,yy,ly,gy)=>{c.sa("Attention",Yr,{numHeads:r0,isUnidirectional:p0,maskFilterValue:_0,scale:D0,doRotary:V0,qkvHiddenSizes:yy?Array.from(C0.subarray(Number(ly)>>>0,Number(ly)+yy>>>0)):[],pastPresentShareBuffer:!!gy})},942653:Yr=>{c.sa("BiasAdd",Yr,void 0)},942708:Yr=>{c.sa("BiasSplitGelu",Yr,void 0)},942769:Yr=>{c.sa("FastGelu",Yr,void 0)},942825:(Yr,r0,p0,_0,D0,V0,yy,ly,gy,ky,jy,rv,dv)=>{c.sa("Conv",Yr,{format:gy?"NHWC":"NCHW",auto_pad:r0,dilations:[p0],group:_0,kernel_shape:[D0],pads:V0?Array.from(C0.subarray(V0>>>0,yy>>>0)):[],strides:[ly],w_is_const:()=>!!i0[ky>>>0],activation:Gy(jy),activation_params:rv?Array.from(R0.subarray(rv>>>0,dv>>>0)):[]})},943195:(Yr,r0,p0,_0,D0,V0,yy,ly,gy,ky,jy,rv,dv,K0,Cy,lv)=>{c.sa("Conv",Yr,{format:rv?"NHWC":"NCHW",auto_pad:r0,dilations:[p0,_0],group:D0,kernel_shape:[V0,yy],pads:ly?Array.from(C0.subarray(ly>>>0,gy>>>0)):[],strides:[ky,jy],w_is_const:()=>!!i0[dv>>>0],activation:Gy(K0),activation_params:Cy?Array.from(R0.subarray(Cy>>>0,lv>>>0)):[]})},943586:Yr=>{c.sa("Gelu",Yr,void 0)},943638:(Yr,r0,p0,_0,D0,V0)=>{c.sa("MatMulNBits",Yr,{k:r0,n:p0,accuracyLevel:_0,bits:D0,blockSize:V0})},943765:(Yr,r0,p0,_0,D0,V0)=>{c.sa("MultiHeadAttention",Yr,{numHeads:r0,isUnidirectional:p0,maskFilterValue:_0,scale:D0,doRotary:V0})},943924:(Yr,r0)=>{c.sa("SkipLayerNormalization",Yr,{epsilon:r0})},944005:Yr=>{c.Wa(Yr)},944039:(Yr,r0)=>c.Ya(Yr,r0,c.Ea.Za,c.Ea.errors)};function Ay(Yr){this.name="ExitStatus",this.message=`Program terminated with exit(${Yr})`,this.status=Yr}function hy(Yr){this.Ja=Yr-24,this.Pa=function(r0){Z0[this.Ja+4>>>2>>>0]=r0},this.Oa=function(r0){Z0[this.Ja+8>>>2>>>0]=r0},this.eb=function(r0,p0){this.Na(),this.Pa(r0),this.Oa(p0)},this.Na=function(){Z0[this.Ja+16>>>2>>>0]=0}}var Ly=0,Iy=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Jy=(Yr,r0,p0)=>{r0>>>=0;var _0=r0+p0;for(p0=r0;Yr[p0]&&!(p0>=_0);)++p0;if(16<p0-r0&&Yr.buffer&&Iy)return Iy.decode(Yr.subarray(r0,p0));for(_0="";r0<p0;){var D0=Yr[r0++];if(D0&128){var V0=Yr[r0++]&63;if((D0&224)==192)_0+=String.fromCharCode((D0&31)<<6|V0);else{var yy=Yr[r0++]&63;D0=(D0&240)==224?(D0&15)<<12|V0<<6|yy:(D0&7)<<18|V0<<12|yy<<6|Yr[r0++]&63,65536>D0?_0+=String.fromCharCode(D0):(D0-=65536,_0+=String.fromCharCode(55296|D0>>10,56320|D0&1023))}}else _0+=String.fromCharCode(D0)}return _0},Gy=(Yr,r0)=>(Yr>>>=0)?Jy(f0,Yr,r0):"",sv=Yr=>{for(var r0=0,p0=0;p0<Yr.length;++p0){var _0=Yr.charCodeAt(p0);127>=_0?r0++:2047>=_0?r0+=2:55296<=_0&&57343>=_0?(r0+=4,++p0):r0+=3}return r0},yv=(Yr,r0,p0,_0)=>{if(p0>>>=0,!(0<_0))return 0;var D0=p0;_0=p0+_0-1;for(var V0=0;V0<Yr.length;++V0){var yy=Yr.charCodeAt(V0);if(55296<=yy&&57343>=yy){var ly=Yr.charCodeAt(++V0);yy=65536+((yy&1023)<<10)|ly&1023}if(127>=yy){if(p0>=_0)break;r0[p0++>>>0]=yy}else{if(2047>=yy){if(p0+1>=_0)break;r0[p0++>>>0]=192|yy>>6}else{if(65535>=yy){if(p0+2>=_0)break;r0[p0++>>>0]=224|yy>>12}else{if(p0+3>=_0)break;r0[p0++>>>0]=240|yy>>18,r0[p0++>>>0]=128|yy>>12&63}r0[p0++>>>0]=128|yy>>6&63}r0[p0++>>>0]=128|yy&63}}return r0[p0>>>0]=0,p0-D0},I0=Yr=>Yr%4===0&&(Yr%100!==0||Yr%400===0),b0=[0,31,60,91,121,152,182,213,244,274,305,335],uy=[0,31,59,90,120,151,181,212,243,273,304,334],Ey=Yr=>{var r0=sv(Yr)+1,p0=wy(r0);return p0&&yv(Yr,f0,p0,r0),p0},Dy=[],By=(Yr,r0)=>{Dy.length=0;for(var p0;p0=f0[Yr++>>>0];){var _0=p0!=105;_0&=p0!=112,r0+=_0&&r0%8?4:0,Dy.push(p0==112?Z0[r0>>>2>>>0]:p0==105?C0[r0>>>2>>>0]:Y0[r0>>>3>>>0]),r0+=_0?8:4}return Dy},bv={},av=()=>{if(!Wy){var Yr={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:j||"./this.program"},r0;for(r0 in bv)bv[r0]===void 0?delete Yr[r0]:Yr[r0]=bv[r0];var p0=[];for(r0 in Yr)p0.push(`${r0}=${Yr[r0]}`);Wy=p0}return Wy},Wy,my=[null,[],[]],uv=[31,29,31,30,31,30,31,31,30,31,30,31],Hy=[31,28,31,30,31,30,31,31,30,31,30,31];function wv(Yr){var r0=Array(sv(Yr)+1);return yv(Yr,r0,0,r0.length),r0}function mv(Yr,r0,p0,_0){function D0(K0,Cy,lv){for(K0=typeof K0=="number"?K0.toString():K0||"";K0.length<Cy;)K0=lv[0]+K0;return K0}function V0(K0,Cy){return D0(K0,Cy,"0")}function yy(K0,Cy){function lv(Mv){return 0>Mv?-1:0<Mv?1:0}var vv;return(vv=lv(K0.getFullYear()-Cy.getFullYear()))===0&&(vv=lv(K0.getMonth()-Cy.getMonth()))===0&&(vv=lv(K0.getDate()-Cy.getDate())),vv}function ly(K0){switch(K0.getDay()){case 0:return new Date(K0.getFullYear()-1,11,29);case 1:return K0;case 2:return new Date(K0.getFullYear(),0,3);case 3:return new Date(K0.getFullYear(),0,2);case 4:return new Date(K0.getFullYear(),0,1);case 5:return new Date(K0.getFullYear()-1,11,31);case 6:return new Date(K0.getFullYear()-1,11,30)}}function gy(K0){var Cy=K0.Ca;for(K0=new Date(new Date(K0.Da+1900,0,1).getTime());0<Cy;){var lv=K0.getMonth(),vv=(I0(K0.getFullYear())?uv:Hy)[lv];if(Cy>vv-K0.getDate())Cy-=vv-K0.getDate()+1,K0.setDate(1),11>lv?K0.setMonth(lv+1):(K0.setMonth(0),K0.setFullYear(K0.getFullYear()+1));else{K0.setDate(K0.getDate()+Cy);break}}return lv=new Date(K0.getFullYear()+1,0,4),Cy=ly(new Date(K0.getFullYear(),0,4)),lv=ly(lv),0>=yy(Cy,K0)?0>=yy(lv,K0)?K0.getFullYear()+1:K0.getFullYear():K0.getFullYear()-1}Yr>>>=0,r0>>>=0,p0>>>=0,_0>>>=0;var ky=Z0[_0+40>>>2>>>0];_0={bb:C0[_0>>>2>>>0],ab:C0[_0+4>>>2>>>0],Ga:C0[_0+8>>>2>>>0],Ka:C0[_0+12>>>2>>>0],Ha:C0[_0+16>>>2>>>0],Da:C0[_0+20>>>2>>>0],xa:C0[_0+24>>>2>>>0],Ca:C0[_0+28>>>2>>>0],fb:C0[_0+32>>>2>>>0],$a:C0[_0+36>>>2>>>0],cb:ky?Gy(ky):""},p0=Gy(p0),ky={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var jy in ky)p0=p0.replace(new RegExp(jy,"g"),ky[jy]);var rv="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),dv="January February March April May June July August September October November December".split(" ");ky={"%a":K0=>rv[K0.xa].substring(0,3),"%A":K0=>rv[K0.xa],"%b":K0=>dv[K0.Ha].substring(0,3),"%B":K0=>dv[K0.Ha],"%C":K0=>V0((K0.Da+1900)/100|0,2),"%d":K0=>V0(K0.Ka,2),"%e":K0=>D0(K0.Ka,2," "),"%g":K0=>gy(K0).toString().substring(2),"%G":K0=>gy(K0),"%H":K0=>V0(K0.Ga,2),"%I":K0=>(K0=K0.Ga,K0==0?K0=12:12<K0&&(K0-=12),V0(K0,2)),"%j":K0=>{for(var Cy=0,lv=0;lv<=K0.Ha-1;Cy+=(I0(K0.Da+1900)?uv:Hy)[lv++]);return V0(K0.Ka+Cy,3)},"%m":K0=>V0(K0.Ha+1,2),"%M":K0=>V0(K0.ab,2),"%n":()=>`
`,"%p":K0=>0<=K0.Ga&&12>K0.Ga?"AM":"PM","%S":K0=>V0(K0.bb,2),"%t":()=>"	","%u":K0=>K0.xa||7,"%U":K0=>V0(Math.floor((K0.Ca+7-K0.xa)/7),2),"%V":K0=>{var Cy=Math.floor((K0.Ca+7-(K0.xa+6)%7)/7);if(2>=(K0.xa+371-K0.Ca-2)%7&&Cy++,Cy)Cy==53&&(lv=(K0.xa+371-K0.Ca)%7,lv==4||lv==3&&I0(K0.Da)||(Cy=1));else{Cy=52;var lv=(K0.xa+7-K0.Ca-1)%7;(lv==4||lv==5&&I0(K0.Da%400-1))&&Cy++}return V0(Cy,2)},"%w":K0=>K0.xa,"%W":K0=>V0(Math.floor((K0.Ca+7-(K0.xa+6)%7)/7),2),"%y":K0=>(K0.Da+1900).toString().substring(2),"%Y":K0=>K0.Da+1900,"%z":K0=>{K0=K0.$a;var Cy=0<=K0;return K0=Math.abs(K0)/60,(Cy?"+":"-")+("0000"+(K0/60*100+K0%60)).slice(-4)},"%Z":K0=>K0.cb,"%%":()=>"%"},p0=p0.replace(/%%/g,"\0\0");for(jy in ky)p0.includes(jy)&&(p0=p0.replace(new RegExp(jy,"g"),ky[jy](_0)));return p0=p0.replace(/\0\0/g,"%"),jy=wv(p0),jy.length>r0?0:(i0.set(jy,Yr>>>0),jy.length-1)}var cv=Yr=>{try{Yr()}catch(r0){q0(r0)}};function O0(){var Yr=ov,r0={};for(let[p0,_0]of Object.entries(Yr))r0[p0]=typeof _0=="function"?function(){d0.push(p0);try{return _0.apply(null,arguments)}finally{l0||(d0.pop(),Py&&oy===1&&d0.length===0&&(oy=0,cv(m0),typeof Fibers<"u"&&Fibers.gb()))}}:_0;return r0}var oy=0,Py=null,nv=0,d0=[],v0={},N0={},F0=0,sy=null,xy=[];function ev(){return new Promise((Yr,r0)=>{sy={resolve:Yr,reject:r0}})}function Sv(){var Yr=wy(65548),r0=Yr+12;Z0[Yr>>>2>>>0]=r0,Z0[Yr+4>>>2>>>0]=r0+65536,r0=d0[0];var p0=v0[r0];return p0===void 0&&(p0=F0++,v0[r0]=p0,N0[p0]=r0),C0[Yr+8>>>2>>>0]=p0,Yr}function kv(Yr){if(!l0){if(oy===0){var r0=!1,p0=!1;Yr((_0=0)=>{if(!l0&&(nv=_0,r0=!0,p0)){oy=2,cv(()=>E0(Py)),typeof Browser<"u"&&Browser.Ia.Qa&&Browser.Ia.resume(),_0=!1;try{var D0=(0,ov[N0[C0[Py+8>>>2>>>0]]])()}catch(ly){D0=ly,_0=!0}var V0=!1;if(!Py){var yy=sy;yy&&(sy=null,(_0?yy.reject:yy.resolve)(D0),V0=!0)}if(_0&&!V0)throw D0}}),p0=!0,r0||(oy=1,Py=Sv(),typeof Browser<"u"&&Browser.Ia.Qa&&Browser.Ia.pause(),cv(()=>h1(Py)))}else oy===2?(oy=0,cv(j0),Zv(Py),Py=null,xy.forEach(_0=>{var D0;if(!l0)try{_0();try{g0=g0=_0=g0,(D0=c.onExit)==null||D0.call(c,_0),l0=!0,b(_0,new Ay(_0))}catch(V0){V0 instanceof Ay||V0=="unwind"||b(1,V0)}}catch(V0){V0 instanceof Ay||V0=="unwind"||b(1,V0)}})):q0(`invalid state: ${oy}`);return nv}}function Vv(Yr){return kv(r0=>{Yr().then(r0)})}var $v={n:function(Yr,r0,p0){return Vv(async()=>{await c.Ua(Yr,r0,p0)})},a:function(Yr,r0,p0){throw Yr>>>=0,new hy(Yr).eb(r0>>>0,p0>>>0),Ly=Yr,Ly},g:function(){return 0},J:function(){},A:function(){},C:function(){},L:function(){return 0},H:function(){},D:function(){},G:function(){},l:function(){},B:function(){},y:function(){},I:function(){},z:function(){},m:()=>1,q:function(Yr,r0,p0){Yr=r0+2097152>>>0<4194305-!!Yr?(Yr>>>0)+4294967296*r0:NaN,p0>>>=0,Yr=new Date(1e3*Yr),C0[p0>>>2>>>0]=Yr.getUTCSeconds(),C0[p0+4>>>2>>>0]=Yr.getUTCMinutes(),C0[p0+8>>>2>>>0]=Yr.getUTCHours(),C0[p0+12>>>2>>>0]=Yr.getUTCDate(),C0[p0+16>>>2>>>0]=Yr.getUTCMonth(),C0[p0+20>>>2>>>0]=Yr.getUTCFullYear()-1900,C0[p0+24>>>2>>>0]=Yr.getUTCDay(),C0[p0+28>>>2>>>0]=(Yr.getTime()-Date.UTC(Yr.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(Yr,r0,p0){Yr=r0+2097152>>>0<4194305-!!Yr?(Yr>>>0)+4294967296*r0:NaN,p0>>>=0,Yr=new Date(1e3*Yr),C0[p0>>>2>>>0]=Yr.getSeconds(),C0[p0+4>>>2>>>0]=Yr.getMinutes(),C0[p0+8>>>2>>>0]=Yr.getHours(),C0[p0+12>>>2>>>0]=Yr.getDate(),C0[p0+16>>>2>>>0]=Yr.getMonth(),C0[p0+20>>>2>>>0]=Yr.getFullYear()-1900,C0[p0+24>>>2>>>0]=Yr.getDay(),C0[p0+28>>>2>>>0]=(I0(Yr.getFullYear())?b0:uy)[Yr.getMonth()]+Yr.getDate()-1|0,C0[p0+36>>>2>>>0]=-(60*Yr.getTimezoneOffset()),r0=new Date(Yr.getFullYear(),6,1).getTimezoneOffset();var _0=new Date(Yr.getFullYear(),0,1).getTimezoneOffset();C0[p0+32>>>2>>>0]=(r0!=_0&&Yr.getTimezoneOffset()==Math.min(_0,r0))|0},s:function(Yr){Yr>>>=0;var r0=new Date(C0[Yr+20>>>2>>>0]+1900,C0[Yr+16>>>2>>>0],C0[Yr+12>>>2>>>0],C0[Yr+8>>>2>>>0],C0[Yr+4>>>2>>>0],C0[Yr>>>2>>>0],0),p0=C0[Yr+32>>>2>>>0],_0=r0.getTimezoneOffset(),D0=new Date(r0.getFullYear(),6,1).getTimezoneOffset(),V0=new Date(r0.getFullYear(),0,1).getTimezoneOffset(),yy=Math.min(V0,D0);return 0>p0?C0[Yr+32>>>2>>>0]=+(D0!=V0&&yy==_0):0<p0!=(yy==_0)&&(D0=Math.max(V0,D0),r0.setTime(r0.getTime()+6e4*((0<p0?yy:D0)-_0))),C0[Yr+24>>>2>>>0]=r0.getDay(),C0[Yr+28>>>2>>>0]=(I0(r0.getFullYear())?b0:uy)[r0.getMonth()]+r0.getDate()-1|0,C0[Yr>>>2>>>0]=r0.getSeconds(),C0[Yr+4>>>2>>>0]=r0.getMinutes(),C0[Yr+8>>>2>>>0]=r0.getHours(),C0[Yr+12>>>2>>>0]=r0.getDate(),C0[Yr+16>>>2>>>0]=r0.getMonth(),C0[Yr+20>>>2>>>0]=r0.getYear(),Yr=r0.getTime(),isNaN(Yr)?(C0[C_()>>>2>>>0]=61,Yr=-1):Yr/=1e3,Xv((zy=Yr,1<=+Math.abs(zy)?0<zy?+Math.floor(zy/4294967296)>>>0:~~+Math.ceil((zy-+(~~zy>>>0))/4294967296)>>>0:0)),Yr>>>0},o:function(){return-52},p:function(){},w:function(Yr,r0,p0){function _0(gy){return(gy=gy.toTimeString().match(/\(([A-Za-z ]+)\)$/))?gy[1]:"GMT"}p0>>>=0;var D0=new Date().getFullYear(),V0=new Date(D0,0,1),yy=new Date(D0,6,1);D0=V0.getTimezoneOffset();var ly=yy.getTimezoneOffset();Z0[Yr>>>0>>>2>>>0]=60*Math.max(D0,ly),C0[r0>>>0>>>2>>>0]=+(D0!=ly),Yr=_0(V0),r0=_0(yy),Yr=Ey(Yr),r0=Ey(r0),ly<D0?(Z0[p0>>>2>>>0]=Yr,Z0[p0+4>>>2>>>0]=r0):(Z0[p0>>>2>>>0]=r0,Z0[p0+4>>>2>>>0]=Yr)},e:()=>{q0("")},b:function(Yr,r0,p0){return Yr>>>=0,r0=By(r0>>>0,p0>>>0),B0[Yr].apply(null,r0)},i:function(Yr,r0,p0){return Yr>>>=0,r0=By(r0>>>0,p0>>>0),B0[Yr].apply(null,r0)},h:()=>Date.now(),x:function(){return 4294901760},c:()=>performance.now(),K:function(Yr,r0,p0){return r0>>>=0,f0.copyWithin(Yr>>>0>>>0,r0>>>0,r0+(p0>>>0)>>>0)},u:function(Yr){Yr>>>=0;var r0=f0.length;if(4294901760<Yr)return!1;for(var p0=1;4>=p0;p0*=2){var _0=r0*(1+.2/p0);_0=Math.min(_0,Yr+100663296);var D0=Math;_0=Math.max(Yr,_0);e:{D0=(D0.min.call(D0,4294901760,_0+(65536-_0%65536)%65536)-o0.buffer.byteLength+65535)/65536;try{o0.grow(D0),H0();var V0=1;break e}catch{}V0=void 0}if(V0)return!0}return!1},E:function(Yr,r0){Yr>>>=0,r0>>>=0;var p0=0;return av().forEach((_0,D0)=>{var V0=r0+p0;for(D0=Z0[Yr+4*D0>>>2>>>0]=V0,V0=0;V0<_0.length;++V0)i0[D0++>>>0>>>0]=_0.charCodeAt(V0);i0[D0>>>0>>>0]=0,p0+=_0.length+1}),0},F:function(Yr,r0){Yr>>>=0,r0>>>=0;var p0=av();Z0[Yr>>>2>>>0]=p0.length;var _0=0;return p0.forEach(D0=>_0+=D0.length+1),Z0[r0>>>2>>>0]=_0,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(Yr,r0,p0,_0){r0>>>=0,p0>>>=0,_0>>>=0;for(var D0=0,V0=0;V0<p0;V0++){var yy=Z0[r0>>>2>>>0],ly=Z0[r0+4>>>2>>>0];r0+=8;for(var gy=0;gy<ly;gy++){var ky=f0[yy+gy>>>0],jy=my[Yr];ky===0||ky===10?((Yr===1?e0:t0)(Jy(jy,0)),jy.length=0):jy.push(ky)}D0+=ly}return Z0[_0>>>2>>>0]=D0,0},v:mv,d:function(Yr,r0,p0,_0){return mv(Yr>>>0,r0>>>0,p0>>>0,_0>>>0)}},ov=function(){function Yr(p0){return ov=p0.exports,ov=O0(),ov=h0(),o0=ov.M,H0(),w0.unshift(ov.N),k0--,k0==0&&T0&&(p0=T0,T0=null,p0()),ov}var r0={a:$v};if(k0++,c.instantiateWasm)try{return c.instantiateWasm(r0,Yr)}catch(p0){t0(`Module.instantiateWasm callback failed with error: ${p0}`),_(p0)}return iv(r0,function(p0){Yr(p0.instance)}).catch(_),{}}();c._OrtInit=(Yr,r0)=>(c._OrtInit=ov.O)(Yr,r0),c._OrtGetLastError=(Yr,r0)=>(c._OrtGetLastError=ov.P)(Yr,r0),c._OrtCreateSessionOptions=(Yr,r0,p0,_0,D0,V0,yy,ly,gy,ky)=>(c._OrtCreateSessionOptions=ov.Q)(Yr,r0,p0,_0,D0,V0,yy,ly,gy,ky),c._OrtAppendExecutionProvider=(Yr,r0)=>(c._OrtAppendExecutionProvider=ov.R)(Yr,r0),c._OrtAddFreeDimensionOverride=(Yr,r0,p0)=>(c._OrtAddFreeDimensionOverride=ov.S)(Yr,r0,p0),c._OrtAddSessionConfigEntry=(Yr,r0,p0)=>(c._OrtAddSessionConfigEntry=ov.T)(Yr,r0,p0),c._OrtReleaseSessionOptions=Yr=>(c._OrtReleaseSessionOptions=ov.U)(Yr),c._OrtCreateSession=(Yr,r0,p0)=>(c._OrtCreateSession=ov.V)(Yr,r0,p0),c._OrtReleaseSession=Yr=>(c._OrtReleaseSession=ov.W)(Yr),c._OrtGetInputOutputCount=(Yr,r0,p0)=>(c._OrtGetInputOutputCount=ov.X)(Yr,r0,p0),c._OrtGetInputName=(Yr,r0)=>(c._OrtGetInputName=ov.Y)(Yr,r0),c._OrtGetOutputName=(Yr,r0)=>(c._OrtGetOutputName=ov.Z)(Yr,r0),c._OrtFree=Yr=>(c._OrtFree=ov._)(Yr),c._OrtCreateTensor=(Yr,r0,p0,_0,D0,V0)=>(c._OrtCreateTensor=ov.$)(Yr,r0,p0,_0,D0,V0),c._OrtGetTensorData=(Yr,r0,p0,_0,D0)=>(c._OrtGetTensorData=ov.aa)(Yr,r0,p0,_0,D0),c._OrtReleaseTensor=Yr=>(c._OrtReleaseTensor=ov.ba)(Yr),c._OrtCreateRunOptions=(Yr,r0,p0,_0)=>(c._OrtCreateRunOptions=ov.ca)(Yr,r0,p0,_0),c._OrtAddRunConfigEntry=(Yr,r0,p0)=>(c._OrtAddRunConfigEntry=ov.da)(Yr,r0,p0),c._OrtReleaseRunOptions=Yr=>(c._OrtReleaseRunOptions=ov.ea)(Yr),c._OrtCreateBinding=Yr=>(c._OrtCreateBinding=ov.fa)(Yr),c._OrtBindInput=(Yr,r0,p0)=>(c._OrtBindInput=ov.ga)(Yr,r0,p0),c._OrtBindOutput=(Yr,r0,p0,_0)=>(c._OrtBindOutput=ov.ha)(Yr,r0,p0,_0),c._OrtClearBoundOutputs=Yr=>(c._OrtClearBoundOutputs=ov.ia)(Yr),c._OrtReleaseBinding=Yr=>(c._OrtReleaseBinding=ov.ja)(Yr),c._OrtRunWithBinding=(Yr,r0,p0,_0,D0)=>(c._OrtRunWithBinding=ov.ka)(Yr,r0,p0,_0,D0),c._OrtRun=(Yr,r0,p0,_0,D0,V0,yy,ly)=>(c._OrtRun=ov.la)(Yr,r0,p0,_0,D0,V0,yy,ly),c._OrtEndProfiling=Yr=>(c._OrtEndProfiling=ov.ma)(Yr),c._JsepOutput=(Yr,r0,p0)=>(c._JsepOutput=ov.na)(Yr,r0,p0),c._JsepGetNodeName=Yr=>(c._JsepGetNodeName=ov.oa)(Yr);var C_=()=>(C_=ov.pa)(),wy=c._malloc=Yr=>(wy=c._malloc=ov.qa)(Yr),Zv=c._free=Yr=>(Zv=c._free=ov.ra)(Yr),Xv=Yr=>(Xv=ov.ta)(Yr),v_=()=>(v_=ov.ua)(),Rv=Yr=>(Rv=ov.va)(Yr),i1=Yr=>(i1=ov.wa)(Yr),h1=Yr=>(h1=ov.ya)(Yr),m0=()=>(m0=ov.za)(),E0=Yr=>(E0=ov.Aa)(Yr),j0=()=>(j0=ov.Ba)();c.___start_em_js=944151,c.___stop_em_js=944312;function h0(){var Yr=ov;Yr=Object.assign({},Yr);var r0=_0=>()=>_0()>>>0,p0=_0=>D0=>_0(D0)>>>0;return Yr.pa=r0(Yr.pa),Yr.qa=p0(Yr.qa),Yr.ua=r0(Yr.ua),Yr.wa=p0(Yr.wa),Yr}c.stackAlloc=i1,c.stackSave=v_,c.stackRestore=Rv,c.UTF8ToString=Gy,c.stringToUTF8=(Yr,r0,p0)=>yv(Yr,f0,r0,p0),c.lengthBytesUTF8=sv;var $0;T0=function Yr(){$0||P0(),$0||(T0=Yr)};function P0(){if(!(0<k0)){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;){var Yr=c.preRun.shift();ty.unshift(Yr)}for(;0<ty.length;)ty.shift()(c);if(!(0<k0||$0||($0=!0,c.calledRun=!0,l0))){for(;0<w0.length;)w0.shift()(c);for(h(c);0<L0.length;)L0.shift()(c)}}}return P0(),d.ready}})();typeof a=="object"&&typeof e=="object"?e.exports=o:typeof define=="function"&&define.amd&&define([],()=>o)}),Ui=tr(()=>{}),Ni=tr(()=>{}),Wi={};rr(Wi,{cpus:()=>vd});var vd,Vi=F(()=>{vd=void 0}),Li=tr((a,e)=>{var o=(()=>{var s=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(s=s||__filename),function(d={}){function c(){return ty.buffer!=T0.buffer&&Uy(),T0}function h(){return ty.buffer!=T0.buffer&&Uy(),q0}function _(){return ty.buffer!=T0.buffer&&Uy(),vy}function bt(){return ty.buffer!=T0.buffer&&Uy(),J0}function g(){return ty.buffer!=T0.buffer&&Uy(),cy}function j(){return ty.buffer!=T0.buffer&&Uy(),Ty}var b=d,Et,It;b.ready=new Promise((om,c0)=>{Et=om,It=c0}),b.mountExternalData=(om,c0)=>{(b.cb||(b.cb=new Map)).set(om,c0)},b.unmountExternalData=()=>{delete b.cb};let zt=()=>{let om=(x0,U0,ry)=>(...by)=>{let Vy=S_,Ev=U0==null?void 0:U0();by=x0(...by);let Hv=U0==null?void 0:U0();return Ev!==Hv&&(x0=Hv,ry(Ev),U0=ry=null),S_!=Vy?Hw():by},c0=x0=>async(...U0)=>{var ry;try{if(b.bb)throw Error("Session already started");let by=b.bb={Gb:U0[0],errors:[]},Vy=await x0(...U0);if(b.bb!==by)throw Error("Session mismatch");(ry=b.kb)==null||ry.flush();let Ev=by.errors;if(0<Ev.length){let Hv=await Promise.all(Ev);if(Hv=Hv.filter(Nv=>Nv),0<Hv.length)throw Error(Hv.join(`
`))}return Vy}finally{b.bb=null}};b._OrtCreateSession=om(b._OrtCreateSession,()=>b._OrtCreateSession,x0=>b._OrtCreateSession=x0),b._OrtRun=c0(om(b._OrtRun,()=>b._OrtRun,x0=>b._OrtRun=x0)),b._OrtRunWithBinding=c0(om(b._OrtRunWithBinding,()=>b._OrtRunWithBinding,x0=>b._OrtRunWithBinding=x0)),b._OrtBindInput=om(b._OrtBindInput,()=>b._OrtBindInput,x0=>b._OrtBindInput=x0),zt=void 0};b.jsepInit=(om,c0)=>{if(zt==null||zt(),om==="webgpu"){[b.kb,b.xb,b.Bb,b.lb,b.Ab,b.Ea,b.Cb,b.Eb,b.yb,b.zb,b.Db]=c0;let x0=b.kb;b.jsepRegisterBuffer=(U0,ry,by,Vy)=>x0.registerBuffer(U0,ry,by,Vy),b.jsepGetBuffer=U0=>x0.getBuffer(U0),b.jsepCreateDownloader=(U0,ry,by)=>x0.createDownloader(U0,ry,by),b.jsepOnReleaseSession=U0=>{x0.onReleaseSession(U0)},b.jsepOnRunStart=U0=>x0.onRunStart(U0)}};var er=Object.assign({},b),Hn="./this.program",Qt=(om,c0)=>{throw c0},cr=typeof window=="object",fr=typeof importScripts=="function",jr=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",e0=b.ENVIRONMENT_IS_PTHREAD||!1,t0="";function o0(om){return b.locateFile?b.locateFile(om,t0):t0+om}var l0,g0,i0;if(jr){var f0=(Xn(),Gt(Zn)),C0=(Jn(),Gt(Qn));t0=fr?C0.dirname(t0)+"/":__dirname+"/",l0=(c0,x0)=>(c0=Jy(c0)?new URL(c0):C0.normalize(c0),f0.readFileSync(c0,x0?void 0:"utf8")),i0=c0=>(c0=l0(c0,!0),c0.buffer||(c0=new Uint8Array(c0)),c0),g0=(c0,x0,U0,ry=!0)=>{c0=Jy(c0)?new URL(c0):C0.normalize(c0),f0.readFile(c0,ry?void 0:"utf8",(by,Vy)=>{by?U0(by):x0(ry?Vy.buffer:Vy)})},!b.thisProgram&&1<process.argv.length&&(Hn=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),Qt=(c0,x0)=>{throw process.exitCode=c0,x0},b.inspect=()=>"[Emscripten Module object]";let om;try{om=Ui()}catch(c0){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),c0}global.Worker=om.Worker}else(cr||fr)&&(fr?t0=self.location.href:typeof document<"u"&&document.currentScript&&(t0=document.currentScript.src),typeof s<"u"&&s&&(t0=s),t0.indexOf("blob:")!==0?t0=t0.substr(0,t0.replace(/[?#].*/,"").lastIndexOf("/")+1):t0="",jr||(l0=om=>{var c0=new XMLHttpRequest;return c0.open("GET",om,!1),c0.send(null),c0.responseText},fr&&(i0=om=>{var c0=new XMLHttpRequest;return c0.open("GET",om,!1),c0.responseType="arraybuffer",c0.send(null),new Uint8Array(c0.response)}),g0=(om,c0,x0)=>{var U0=new XMLHttpRequest;U0.open("GET",om,!0),U0.responseType="arraybuffer",U0.onload=()=>{U0.status==200||U0.status==0&&U0.response?c0(U0.response):x0()},U0.onerror=x0,U0.send(null)}));jr&&typeof performance>"u"&&(global.performance=Ni().performance);var Z0=console.log.bind(console),R0=console.error.bind(console);jr&&(Z0=(...om)=>f0.writeSync(1,om.join(" ")+`
`),R0=(...om)=>f0.writeSync(2,om.join(" ")+`
`));var Y0=Z0,H0=R0;Object.assign(b,er),er=null,typeof WebAssembly!="object"&&Ly("no native wasm support detected");var ty,w0,L0=!1,k0,T0,q0,vy,J0,cy,Ty;function Uy(){var om=ty.buffer;b.HEAP8=T0=new Int8Array(om),b.HEAP16=new Int16Array(om),b.HEAPU8=q0=new Uint8Array(om),b.HEAPU16=new Uint16Array(om),b.HEAP32=vy=new Int32Array(om),b.HEAPU32=J0=new Uint32Array(om),b.HEAPF32=cy=new Float32Array(om),b.HEAPF64=Ty=new Float64Array(om)}var Qy=16777216;if(e0)ty=b.wasmMemory;else if(b.wasmMemory)ty=b.wasmMemory;else if(ty=new WebAssembly.Memory({initial:Qy/65536,maximum:65536,shared:!0}),!(ty.buffer instanceof SharedArrayBuffer))throw H0("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),jr&&H0("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Uy(),Qy=ty.buffer.byteLength;var Zy=[],iv=[],zy=[],B0=0,Ay=null;function hy(){if(B0--,B0==0&&Ay){var om=Ay;Ay=null,om()}}function Ly(om){throw om="Aborted("+om+")",H0(om),L0=!0,k0=1,om=new WebAssembly.RuntimeError(om+". Build with -sASSERTIONS for more info."),It(om),om}var Iy=om=>om.startsWith("data:application/octet-stream;base64,"),Jy=om=>om.startsWith("file://"),Gy;Gy="ort-wasm-simd-threaded.wasm",Iy(Gy)||(Gy=o0(Gy));function sv(om){if(i0)return i0(om);throw"both async and sync fetching of the wasm failed"}function yv(om){if(cr||fr){if(typeof fetch=="function"&&!Jy(om))return fetch(om,{credentials:"same-origin"}).then(c0=>{if(!c0.ok)throw"failed to load wasm binary file at '"+om+"'";return c0.arrayBuffer()}).catch(()=>sv(om));if(g0)return new Promise((c0,x0)=>{g0(om,U0=>c0(new Uint8Array(U0)),x0)})}return Promise.resolve().then(()=>sv(om))}function I0(om,c0,x0){return yv(om).then(U0=>WebAssembly.instantiate(U0,c0)).then(U0=>U0).then(x0,U0=>{H0(`failed to asynchronously prepare wasm: ${U0}`),Ly(U0)})}function b0(om,c0){var x0=Gy;return typeof WebAssembly.instantiateStreaming!="function"||Iy(x0)||Jy(x0)||jr||typeof fetch!="function"?I0(x0,om,c0):fetch(x0,{credentials:"same-origin"}).then(U0=>WebAssembly.instantiateStreaming(U0,om).then(c0,function(ry){return H0(`wasm streaming compile failed: ${ry}`),H0("falling back to ArrayBuffer instantiation"),I0(x0,om,c0)}))}var uy,Ey={933148:(om,c0,x0,U0)=>{if(typeof b>"u"||!b.cb)return 1;if(om=uv(om>>>0),om.startsWith("./")&&(om=om.substring(2)),om=b.cb.get(om),!om)return 2;if(c0>>>=0,x0>>>=0,U0>>>=0,c0+x0>om.byteLength)return 3;try{return h().set(om.subarray(c0,c0+x0),U0>>>0),0}catch{return 4}},933649:()=>{b.yb()},933680:()=>{b.zb()},933709:()=>{b.Db()},933734:om=>b.xb(om),933767:om=>b.Bb(om),933799:(om,c0,x0)=>{b.lb(om,c0,x0,!0)},933838:(om,c0,x0)=>{b.lb(om,c0,x0)},933871:om=>{b.Ea("Abs",om,void 0)},933922:om=>{b.Ea("Neg",om,void 0)},933973:om=>{b.Ea("Floor",om,void 0)},934026:om=>{b.Ea("Ceil",om,void 0)},934078:om=>{b.Ea("Reciprocal",om,void 0)},934136:om=>{b.Ea("Sqrt",om,void 0)},934188:om=>{b.Ea("Exp",om,void 0)},934239:om=>{b.Ea("Erf",om,void 0)},934290:om=>{b.Ea("Sigmoid",om,void 0)},934345:(om,c0,x0)=>{b.Ea("HardSigmoid",om,{alpha:c0,beta:x0})},934424:om=>{b.Ea("Log",om,void 0)},934475:om=>{b.Ea("Sin",om,void 0)},934526:om=>{b.Ea("Cos",om,void 0)},934577:om=>{b.Ea("Tan",om,void 0)},934628:om=>{b.Ea("Asin",om,void 0)},934680:om=>{b.Ea("Acos",om,void 0)},934732:om=>{b.Ea("Atan",om,void 0)},934784:om=>{b.Ea("Sinh",om,void 0)},934836:om=>{b.Ea("Cosh",om,void 0)},934888:om=>{b.Ea("Asinh",om,void 0)},934941:om=>{b.Ea("Acosh",om,void 0)},934994:om=>{b.Ea("Atanh",om,void 0)},935047:om=>{b.Ea("Tanh",om,void 0)},935099:om=>{b.Ea("Not",om,void 0)},935150:(om,c0,x0)=>{b.Ea("Clip",om,{min:c0,max:x0})},935219:om=>{b.Ea("Clip",om,void 0)},935271:(om,c0)=>{b.Ea("Elu",om,{alpha:c0})},935329:om=>{b.Ea("Relu",om,void 0)},935381:(om,c0)=>{b.Ea("LeakyRelu",om,{alpha:c0})},935445:(om,c0)=>{b.Ea("ThresholdedRelu",om,{alpha:c0})},935515:(om,c0)=>{b.Ea("Cast",om,{to:c0})},935573:om=>{b.Ea("Add",om,void 0)},935624:om=>{b.Ea("Sub",om,void 0)},935675:om=>{b.Ea("Mul",om,void 0)},935726:om=>{b.Ea("Div",om,void 0)},935777:om=>{b.Ea("Pow",om,void 0)},935828:om=>{b.Ea("Equal",om,void 0)},935881:om=>{b.Ea("Greater",om,void 0)},935936:om=>{b.Ea("GreaterOrEqual",om,void 0)},935998:om=>{b.Ea("Less",om,void 0)},936050:om=>{b.Ea("LessOrEqual",om,void 0)},936109:(om,c0,x0,U0,ry)=>{b.Ea("ReduceMean",om,{keepDims:!!c0,noopWithEmptyAxes:!!x0,axes:U0?Array.from(_().subarray(U0>>>0,ry>>>0)):[]})},936268:(om,c0,x0,U0,ry)=>{b.Ea("ReduceMax",om,{keepDims:!!c0,noopWithEmptyAxes:!!x0,axes:U0?Array.from(_().subarray(U0>>>0,ry>>>0)):[]})},936426:(om,c0,x0,U0,ry)=>{b.Ea("ReduceMin",om,{keepDims:!!c0,noopWithEmptyAxes:!!x0,axes:U0?Array.from(_().subarray(U0>>>0,ry>>>0)):[]})},936584:(om,c0,x0,U0,ry)=>{b.Ea("ReduceProd",om,{keepDims:!!c0,noopWithEmptyAxes:!!x0,axes:U0?Array.from(_().subarray(U0>>>0,ry>>>0)):[]})},936743:(om,c0,x0,U0,ry)=>{b.Ea("ReduceSum",om,{keepDims:!!c0,noopWithEmptyAxes:!!x0,axes:U0?Array.from(_().subarray(U0>>>0,ry>>>0)):[]})},936901:(om,c0,x0,U0,ry)=>{b.Ea("ReduceL1",om,{keepDims:!!c0,noopWithEmptyAxes:!!x0,axes:U0?Array.from(_().subarray(U0>>>0,ry>>>0)):[]})},937058:(om,c0,x0,U0,ry)=>{b.Ea("ReduceL2",om,{keepDims:!!c0,noopWithEmptyAxes:!!x0,axes:U0?Array.from(_().subarray(U0>>>0,ry>>>0)):[]})},937215:(om,c0,x0,U0,ry)=>{b.Ea("ReduceLogSum",om,{keepDims:!!c0,noopWithEmptyAxes:!!x0,axes:U0?Array.from(_().subarray(U0>>>0,ry>>>0)):[]})},937376:(om,c0,x0,U0,ry)=>{b.Ea("ReduceSumSquare",om,{keepDims:!!c0,noopWithEmptyAxes:!!x0,axes:U0?Array.from(_().subarray(U0>>>0,ry>>>0)):[]})},937540:(om,c0,x0,U0,ry)=>{b.Ea("ReduceLogSumExp",om,{keepDims:!!c0,noopWithEmptyAxes:!!x0,axes:U0?Array.from(_().subarray(U0>>>0,ry>>>0)):[]})},937704:om=>{b.Ea("Where",om,void 0)},937757:(om,c0,x0)=>{b.Ea("Transpose",om,{perm:c0?Array.from(_().subarray(c0>>>0,x0>>>0)):[]})},937865:(om,c0,x0,U0,ry,by,Vy,Ev,Hv,Nv,jv,Lv,p_,dy,qv)=>{b.Ea("ConvTranspose",om,{format:Hv?"NHWC":"NCHW",autoPad:c0,dilations:[x0],group:U0,kernel_shape:[ry],pads:[by,Vy],strides:[Ev],wIsConst:()=>!!c()[Nv>>>0],outputPadding:jv?Array.from(_().subarray(jv>>>0,Lv>>>0)):[],outputShape:p_?Array.from(_().subarray(p_>>>0,dy>>>0)):[],activation:uv(qv)})},938267:(om,c0,x0,U0,ry,by,Vy,Ev,Hv,Nv,jv,Lv,p_,dy)=>{b.Ea("ConvTranspose",om,{format:Ev?"NHWC":"NCHW",autoPad:c0,dilations:Array.from(_().subarray(x0>>>0,(x0>>>0)+2>>>0)),group:U0,kernelShape:Array.from(_().subarray(ry>>>0,(ry>>>0)+2>>>0)),pads:Array.from(_().subarray(by>>>0,(by>>>0)+4>>>0)),strides:Array.from(_().subarray(Vy>>>0,(Vy>>>0)+2>>>0)),wIsConst:()=>!!c()[Hv>>>0],outputPadding:Nv?Array.from(_().subarray(Nv>>>0,jv>>>0)):[],outputShape:Lv?Array.from(_().subarray(Lv>>>0,p_>>>0)):[],activation:uv(dy)})},938832:(om,c0,x0,U0,ry,by,Vy,Ev,Hv,Nv,jv,Lv,p_,dy,qv)=>{b.Ea("ConvTranspose",om,{format:Hv?"NHWC":"NCHW",autoPad:c0,dilations:[x0],group:U0,kernel_shape:[ry],pads:[by,Vy],strides:[Ev],wIsConst:()=>!!c()[Nv>>>0],outputPadding:jv?Array.from(_().subarray(jv>>>0,Lv>>>0)):[],outputShape:p_?Array.from(_().subarray(p_>>>0,dy>>>0)):[],activation:uv(qv)})},939234:(om,c0,x0,U0,ry,by,Vy,Ev,Hv,Nv,jv,Lv,p_,dy)=>{b.Ea("ConvTranspose",om,{format:Ev?"NHWC":"NCHW",autoPad:c0,dilations:Array.from(_().subarray(x0>>>0,(x0>>>0)+2>>>0)),group:U0,kernelShape:Array.from(_().subarray(ry>>>0,(ry>>>0)+2>>>0)),pads:Array.from(_().subarray(by>>>0,(by>>>0)+4>>>0)),strides:Array.from(_().subarray(Vy>>>0,(Vy>>>0)+2>>>0)),wIsConst:()=>!!c()[Hv>>>0],outputPadding:Nv?Array.from(_().subarray(Nv>>>0,jv>>>0)):[],outputShape:Lv?Array.from(_().subarray(Lv>>>0,p_>>>0)):[],activation:uv(dy)})},939799:(om,c0)=>{b.Ea("GlobalAveragePool",om,{format:c0?"NHWC":"NCHW"})},939890:(om,c0,x0,U0,ry,by,Vy,Ev,Hv,Nv,jv,Lv,p_,dy,qv,d_)=>{b.Ea("AveragePool",om,{format:d_?"NHWC":"NCHW",auto_pad:c0,ceil_mode:x0,count_include_pad:U0,storage_order:ry,dilations:[by,Vy],kernel_shape:[Ev,Hv],pads:[Nv,jv,Lv,p_],strides:[dy,qv]})},940174:(om,c0)=>{b.Ea("GlobalAveragePool",om,{format:c0?"NHWC":"NCHW"})},940265:(om,c0,x0,U0,ry,by,Vy,Ev,Hv,Nv,jv,Lv,p_,dy,qv,d_)=>{b.Ea("AveragePool",om,{format:d_?"NHWC":"NCHW",auto_pad:c0,ceil_mode:x0,count_include_pad:U0,storage_order:ry,dilations:[by,Vy],kernel_shape:[Ev,Hv],pads:[Nv,jv,Lv,p_],strides:[dy,qv]})},940549:(om,c0)=>{b.Ea("GlobalMaxPool",om,{format:c0?"NHWC":"NCHW"})},940636:(om,c0,x0,U0,ry,by,Vy,Ev,Hv,Nv,jv,Lv,p_,dy,qv,d_)=>{b.Ea("MaxPool",om,{format:d_?"NHWC":"NCHW",auto_pad:c0,ceil_mode:x0,count_include_pad:U0,storage_order:ry,dilations:[by,Vy],kernel_shape:[Ev,Hv],pads:[Nv,jv,Lv,p_],strides:[dy,qv]})},940916:(om,c0)=>{b.Ea("GlobalMaxPool",om,{format:c0?"NHWC":"NCHW"})},941003:(om,c0,x0,U0,ry,by,Vy,Ev,Hv,Nv,jv,Lv,p_,dy,qv,d_)=>{b.Ea("MaxPool",om,{format:d_?"NHWC":"NCHW",auto_pad:c0,ceil_mode:x0,count_include_pad:U0,storage_order:ry,dilations:[by,Vy],kernel_shape:[Ev,Hv],pads:[Nv,jv,Lv,p_],strides:[dy,qv]})},941283:(om,c0,x0,U0,ry)=>{b.Ea("Gemm",om,{alpha:c0,beta:x0,transA:U0,transB:ry})},941387:om=>{b.Ea("MatMul",om,void 0)},941441:(om,c0,x0,U0)=>{b.Ea("ArgMax",om,{keepDims:!!c0,selectLastIndex:!!x0,axis:U0})},941549:(om,c0,x0,U0)=>{b.Ea("ArgMin",om,{keepDims:!!c0,selectLastIndex:!!x0,axis:U0})},941657:(om,c0)=>{b.Ea("Softmax",om,{axis:c0})},941720:(om,c0)=>{b.Ea("Concat",om,{axis:c0})},941780:(om,c0,x0,U0,ry)=>{b.Ea("Split",om,{axis:c0,numOutputs:x0,splitSizes:U0?Array.from(_().subarray(U0>>>0,ry>>>0)):[]})},941920:om=>{b.Ea("Expand",om,void 0)},941974:(om,c0)=>{b.Ea("Gather",om,{axis:Number(c0)})},942045:(om,c0)=>{b.Ea("GatherElements",om,{axis:Number(c0)})},942124:(om,c0,x0,U0,ry,by,Vy,Ev,Hv,Nv,jv)=>{b.Ea("Resize",om,{antialias:c0,axes:x0?Array.from(_().subarray(x0>>>0,U0>>>0)):[],coordinateTransformMode:uv(ry),cubicCoeffA:by,excludeOutside:Vy,extrapolationValue:Ev,keepAspectRatioPolicy:uv(Hv),mode:uv(Nv),nearestMode:uv(jv)})},942470:(om,c0,x0,U0,ry,by,Vy)=>{b.Ea("Slice",om,{starts:c0?Array.from(_().subarray(c0>>>0,x0>>>0)):[],ends:U0?Array.from(_().subarray(U0>>>0,ry>>>0)):[],axes:by?Array.from(_().subarray(by>>>0,Vy>>>0)):[]})},942686:om=>{b.Ea("Tile",om,void 0)},942738:(om,c0,x0)=>{b.Ea("LayerNormalization",om,{axis:Number(c0),epsilon:Number(x0)})},942845:(om,c0,x0)=>{b.Ea("InstanceNormalization",om,{epsilon:c0,format:x0?"NHWC":"NCHW"})},942959:(om,c0,x0)=>{b.Ea("InstanceNormalization",om,{epsilon:c0,format:x0?"NHWC":"NCHW"})},943073:om=>{b.Ea("Range",om,void 0)},943126:(om,c0)=>{b.Ea("Einsum",om,{equation:uv(c0)})},943207:(om,c0,x0,U0,ry)=>{b.Ea("Pad",om,{mode:c0,value:x0,pads:U0?Array.from(_().subarray(U0>>>0,ry>>>0)):[]})},943334:(om,c0,x0,U0,ry,by)=>{b.Ea("BatchNormalization",om,{epsilon:c0,momentum:x0,spatial:!!ry,trainingMode:!!U0,format:by?"NHWC":"NCHW"})},943503:(om,c0,x0,U0,ry,by)=>{b.Ea("BatchNormalization",om,{epsilon:c0,momentum:x0,spatial:!!ry,trainingMode:!!U0,format:by?"NHWC":"NCHW"})},943672:(om,c0,x0)=>{b.Ea("CumSum",om,{exclusive:Number(c0),reverse:Number(x0)})},943769:(om,c0,x0,U0,ry,by,Vy,Ev,Hv)=>{b.Ea("Attention",om,{numHeads:c0,isUnidirectional:x0,maskFilterValue:U0,scale:ry,doRotary:by,qkvHiddenSizes:Vy?Array.from(_().subarray(Number(Ev)>>>0,Number(Ev)+Vy>>>0)):[],pastPresentShareBuffer:!!Hv})},944041:om=>{b.Ea("BiasAdd",om,void 0)},944096:om=>{b.Ea("BiasSplitGelu",om,void 0)},944157:om=>{b.Ea("FastGelu",om,void 0)},944213:(om,c0,x0,U0,ry,by,Vy,Ev,Hv,Nv,jv,Lv,p_)=>{b.Ea("Conv",om,{format:Hv?"NHWC":"NCHW",auto_pad:c0,dilations:[x0],group:U0,kernel_shape:[ry],pads:by?Array.from(_().subarray(by>>>0,Vy>>>0)):[],strides:[Ev],w_is_const:()=>!!c()[Nv>>>0],activation:uv(jv),activation_params:Lv?Array.from(g().subarray(Lv>>>0,p_>>>0)):[]})},944583:(om,c0,x0,U0,ry,by,Vy,Ev,Hv,Nv,jv,Lv,p_,dy,qv,d_)=>{b.Ea("Conv",om,{format:Lv?"NHWC":"NCHW",auto_pad:c0,dilations:[x0,U0],group:ry,kernel_shape:[by,Vy],pads:Ev?Array.from(_().subarray(Ev>>>0,Hv>>>0)):[],strides:[Nv,jv],w_is_const:()=>!!c()[p_>>>0],activation:uv(dy),activation_params:qv?Array.from(g().subarray(qv>>>0,d_>>>0)):[]})},944974:om=>{b.Ea("Gelu",om,void 0)},945026:(om,c0,x0,U0,ry,by)=>{b.Ea("MatMulNBits",om,{k:c0,n:x0,accuracyLevel:U0,bits:ry,blockSize:by})},945153:(om,c0,x0,U0,ry,by)=>{b.Ea("MultiHeadAttention",om,{numHeads:c0,isUnidirectional:x0,maskFilterValue:U0,scale:ry,doRotary:by})},945312:(om,c0)=>{b.Ea("SkipLayerNormalization",om,{epsilon:c0})},945393:om=>{b.Cb(om)},945427:(om,c0)=>b.Eb(om,c0,b.bb.Gb,b.bb.errors)};function Dy(om){this.name="ExitStatus",this.message=`Program terminated with exit(${om})`,this.status=om}var By=om=>{om.terminate(),om.onmessage=()=>{}},bv=om=>{d0.Ya.length==0&&(Py(),d0.mb(d0.Ya[0]));var c0=d0.Ya.pop();if(!c0)return 6;d0.Za.push(c0),d0.Qa[om.Xa]=c0,c0.Xa=om.Xa;var x0={cmd:"run",start_routine:om.Hb,arg:om.ub,pthread_ptr:om.Xa};return jr&&c0.unref(),c0.postMessage(x0,om.Nb),0},av=0,Wy=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,my=(om,c0,x0)=>{c0>>>=0;var U0=c0+x0;for(x0=c0;om[x0]&&!(x0>=U0);)++x0;if(16<x0-c0&&om.buffer&&Wy)return Wy.decode(om.buffer instanceof SharedArrayBuffer?om.slice(c0,x0):om.subarray(c0,x0));for(U0="";c0<x0;){var ry=om[c0++];if(ry&128){var by=om[c0++]&63;if((ry&224)==192)U0+=String.fromCharCode((ry&31)<<6|by);else{var Vy=om[c0++]&63;ry=(ry&240)==224?(ry&15)<<12|by<<6|Vy:(ry&7)<<18|by<<12|Vy<<6|om[c0++]&63,65536>ry?U0+=String.fromCharCode(ry):(ry-=65536,U0+=String.fromCharCode(55296|ry>>10,56320|ry&1023))}}else U0+=String.fromCharCode(ry)}return U0},uv=(om,c0)=>(om>>>=0)?my(h(),om,c0):"",Hy=om=>{var c0=Pv();return om=om(),l_(c0),om};function wv(om,c0){var x0=arguments.length-2,U0=arguments;return Hy(()=>{for(var ry=t1(8*x0),by=ry>>>3,Vy=0;Vy<x0;Vy++){var Ev=U0[2+Vy];j()[by+Vy>>>0]=Ev}return $_(om,x0,ry,c0)})}function mv(om){var c0;if(e0)return wv(0,1,om);k0=om,0<av||(d0.Ib(),(c0=b.onExit)==null||c0.call(b,om),L0=!0),Qt(om,new Dy(om))}var cv=om=>{if(k0=om,e0)throw N0(om),"unwind";mv(om)},O0=om=>{om instanceof Dy||om=="unwind"||Qt(1,om)};function oy(){for(var om=b.numThreads;om--;)Py();Zy.unshift(()=>{B0++,nv(()=>hy())})}function Py(){var om=o0("ort-wasm-simd-threaded.worker.js");om=new Worker(om),d0.Ya.push(om)}function nv(om){e0?om():Promise.all(d0.Ya.map(d0.mb)).then(om)}var d0={Ya:[],Za:[],qb:[],Qa:{},hb(){e0?(d0.receiveObjectTransfer=d0.Fb,d0.threadInitTLS=d0.pb,d0.setExitStatus=d0.ob):oy()},ob:om=>k0=om,Qb:["$terminateWorker"],Ib:()=>{for(var om of d0.Za)By(om);for(om of d0.Ya)By(om);d0.Ya=[],d0.Za=[],d0.Qa=[]},nb:om=>{var c0=om.Xa;delete d0.Qa[c0],d0.Ya.push(om),d0.Za.splice(d0.Za.indexOf(om),1),om.Xa=0,G_(c0)},Fb(){},pb(){d0.qb.forEach(om=>om())},mb:om=>new Promise(c0=>{om.onmessage=by=>{by=by.data;var Vy=by.cmd;if(by.targetThread&&by.targetThread!=Xy()){var Ev=d0.Qa[by.targetThread];Ev?Ev.postMessage(by,by.transferList):H0(`Internal error! Worker sent a message "${Vy}" to target pthread ${by.targetThread}, but that thread no longer exists!`)}else Vy==="checkMailbox"?P0():Vy==="spawnThread"?bv(by):Vy==="cleanupThread"?d0.nb(d0.Qa[by.thread]):Vy==="killThread"?(by=by.thread,Vy=d0.Qa[by],delete d0.Qa[by],By(Vy),G_(by),d0.Za.splice(d0.Za.indexOf(Vy),1),Vy.Xa=0):Vy==="cancelThread"?d0.Qa[by.thread].postMessage({cmd:"cancel"}):Vy==="loaded"?(om.loaded=!0,jr&&!om.Xa&&om.unref(),c0(om)):Vy==="alert"?alert(`Thread ${by.threadId}: ${by.text}`):by.target==="setimmediate"?om.postMessage(by):Vy==="callHandler"?b[by.handler](...by.args):Vy&&H0(`worker sent an unknown command ${Vy}`)},om.onerror=by=>{throw H0(`worker sent an error! ${by.filename}:${by.lineno}: ${by.message}`),by},jr&&(om.on("message",by=>om.onmessage({data:by})),om.on("error",by=>om.onerror(by)));var x0=[],U0=["onExit"],ry;for(ry of U0)b.hasOwnProperty(ry)&&x0.push(ry);om.postMessage({cmd:"load",handlers:x0,urlOrBlob:b.mainScriptUrlOrBlob||s,wasmMemory:ty,wasmModule:w0})})};b.PThread=d0;var v0=om=>{for(;0<om.length;)om.shift()(b)};b.establishStackSpace=()=>{var om=Xy(),c0=bt()[om+52>>>2>>>0];om=bt()[om+56>>>2>>>0],t_(c0,c0-om),l_(c0)};function N0(om){if(e0)return wv(1,0,om);cv(om)}b.invokeEntryPoint=(om,c0)=>{om=L1.apply(null,[om,c0]),0<av?d0.ob(om):aw(om)};function F0(om){this.gb=om-24,this.tb=function(c0){bt()[this.gb+4>>>2>>>0]=c0},this.sb=function(c0){bt()[this.gb+8>>>2>>>0]=c0},this.hb=function(c0,x0){this.rb(),this.tb(c0),this.sb(x0)},this.rb=function(){bt()[this.gb+16>>>2>>>0]=0}}var sy=0;function xy(om,c0,x0,U0){return e0?wv(2,1,om,c0,x0,U0):ev(om,c0,x0,U0)}function ev(om,c0,x0,U0){if(om>>>=0,c0>>>=0,x0>>>=0,U0>>>=0,typeof SharedArrayBuffer>"u")return H0("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var ry=[];return e0&&ry.length===0?xy(om,c0,x0,U0):(om={Hb:x0,Xa:om,ub:U0,Nb:ry},e0?(om.Pb="spawnThread",postMessage(om,ry),0):bv(om))}function Sv(om,c0,x0){return e0?wv(3,1,om,c0,x0):0}function kv(om,c0){if(e0)return wv(4,1,om,c0)}var Vv=om=>{for(var c0=0,x0=0;x0<om.length;++x0){var U0=om.charCodeAt(x0);127>=U0?c0++:2047>=U0?c0+=2:55296<=U0&&57343>=U0?(c0+=4,++x0):c0+=3}return c0},$v=(om,c0,x0,U0)=>{if(x0>>>=0,!(0<U0))return 0;var ry=x0;U0=x0+U0-1;for(var by=0;by<om.length;++by){var Vy=om.charCodeAt(by);if(55296<=Vy&&57343>=Vy){var Ev=om.charCodeAt(++by);Vy=65536+((Vy&1023)<<10)|Ev&1023}if(127>=Vy){if(x0>=U0)break;c0[x0++>>>0]=Vy}else{if(2047>=Vy){if(x0+1>=U0)break;c0[x0++>>>0]=192|Vy>>6}else{if(65535>=Vy){if(x0+2>=U0)break;c0[x0++>>>0]=224|Vy>>12}else{if(x0+3>=U0)break;c0[x0++>>>0]=240|Vy>>18,c0[x0++>>>0]=128|Vy>>12&63}c0[x0++>>>0]=128|Vy>>6&63}c0[x0++>>>0]=128|Vy&63}}return c0[x0>>>0]=0,x0-ry},ov=(om,c0,x0)=>$v(om,h(),c0,x0);function C_(om,c0){if(e0)return wv(5,1,om,c0)}function wy(om,c0,x0){if(e0)return wv(6,1,om,c0,x0)}function Zv(om,c0,x0){return e0?wv(7,1,om,c0,x0):0}function Xv(om,c0){if(e0)return wv(8,1,om,c0)}function v_(om,c0,x0){if(e0)return wv(9,1,om,c0,x0)}function Rv(om,c0,x0,U0){if(e0)return wv(10,1,om,c0,x0,U0)}function i1(om,c0,x0,U0){if(e0)return wv(11,1,om,c0,x0,U0)}function h1(om,c0,x0,U0){if(e0)return wv(12,1,om,c0,x0,U0)}function m0(om){if(e0)return wv(13,1,om)}function E0(om,c0){if(e0)return wv(14,1,om,c0)}function j0(om,c0,x0){if(e0)return wv(15,1,om,c0,x0)}var h0=()=>{if(!(0<av))try{e0?aw(k0):cv(k0)}catch(om){O0(om)}};function $0(om){om>>>=0,typeof Atomics.Ob=="function"&&(Atomics.Ob(_(),om>>>2,om).value.then(P0),om+=128,Atomics.store(_(),om>>>2,1))}b.__emscripten_thread_mailbox_await=$0;var P0=()=>{var om=Xy();if(om&&($0(om),!L0))try{Ww(),h0()}catch(c0){O0(c0)}};b.checkMailbox=P0;var Yr=[],r0=om=>om%4===0&&(om%100!==0||om%400===0),p0=[0,31,60,91,121,152,182,213,244,274,305,335],_0=[0,31,59,90,120,151,181,212,243,273,304,334];function D0(om,c0,x0,U0,ry,by,Vy,Ev){return e0?wv(16,1,om,c0,x0,U0,ry,by,Vy,Ev):-52}function V0(om,c0,x0,U0,ry,by,Vy){if(e0)return wv(17,1,om,c0,x0,U0,ry,by,Vy)}var yy=om=>{var c0=Vv(om)+1,x0=_v(c0);return x0&&ov(om,x0,c0),x0},ly=[],gy=(om,c0)=>{ly.length=0;for(var x0;x0=h()[om++>>>0];){var U0=x0!=105;U0&=x0!=112,c0+=U0&&c0%8?4:0,ly.push(x0==112?bt()[c0>>>2>>>0]:x0==105?_()[c0>>>2>>>0]:j()[c0>>>3>>>0]),c0+=U0?8:4}return ly},ky={},jy=()=>{if(!rv){var om={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:Hn||"./this.program"},c0;for(c0 in ky)ky[c0]===void 0?delete om[c0]:om[c0]=ky[c0];var x0=[];for(c0 in om)x0.push(`${c0}=${om[c0]}`);rv=x0}return rv},rv;function dv(om,c0){if(e0)return wv(18,1,om,c0);om>>>=0,c0>>>=0;var x0=0;return jy().forEach((U0,ry)=>{var by=c0+x0;for(ry=bt()[om+4*ry>>>2>>>0]=by,by=0;by<U0.length;++by)c()[ry++>>>0>>>0]=U0.charCodeAt(by);c()[ry>>>0>>>0]=0,x0+=U0.length+1}),0}function K0(om,c0){if(e0)return wv(19,1,om,c0);om>>>=0,c0>>>=0;var x0=jy();bt()[om>>>2>>>0]=x0.length;var U0=0;return x0.forEach(ry=>U0+=ry.length+1),bt()[c0>>>2>>>0]=U0,0}function Cy(om){return e0?wv(20,1,om):52}function lv(om,c0,x0,U0){return e0?wv(21,1,om,c0,x0,U0):52}function vv(om,c0,x0,U0,ry){return e0?wv(22,1,om,c0,x0,U0,ry):70}var Mv=[null,[],[]];function f_(om,c0,x0,U0){if(e0)return wv(23,1,om,c0,x0,U0);c0>>>=0,x0>>>=0,U0>>>=0;for(var ry=0,by=0;by<x0;by++){var Vy=bt()[c0>>>2>>>0],Ev=bt()[c0+4>>>2>>>0];c0+=8;for(var Hv=0;Hv<Ev;Hv++){var Nv=h()[Vy+Hv>>>0],jv=Mv[om];Nv===0||Nv===10?((om===1?Y0:H0)(my(jv,0)),jv.length=0):jv.push(Nv)}ry+=Ev}return bt()[U0>>>2>>>0]=ry,0}var b_=[31,29,31,30,31,30,31,31,30,31,30,31],x_=[31,28,31,30,31,30,31,31,30,31,30,31];function o_(om){var c0=Array(Vv(om)+1);return $v(om,c0,0,c0.length),c0}var Yy=(om,c0)=>{c().set(om,c0>>>0)};function w_(om,c0,x0,U0){function ry(dy,qv,d_){for(dy=typeof dy=="number"?dy.toString():dy||"";dy.length<qv;)dy=d_[0]+dy;return dy}function by(dy,qv){return ry(dy,qv,"0")}function Vy(dy,qv){function d_(_1){return 0>_1?-1:0<_1?1:0}var P_;return(P_=d_(dy.getFullYear()-qv.getFullYear()))===0&&(P_=d_(dy.getMonth()-qv.getMonth()))===0&&(P_=d_(dy.getDate()-qv.getDate())),P_}function Ev(dy){switch(dy.getDay()){case 0:return new Date(dy.getFullYear()-1,11,29);case 1:return dy;case 2:return new Date(dy.getFullYear(),0,3);case 3:return new Date(dy.getFullYear(),0,2);case 4:return new Date(dy.getFullYear(),0,1);case 5:return new Date(dy.getFullYear()-1,11,31);case 6:return new Date(dy.getFullYear()-1,11,30)}}function Hv(dy){var qv=dy.$a;for(dy=new Date(new Date(dy.ab+1900,0,1).getTime());0<qv;){var d_=dy.getMonth(),P_=(r0(dy.getFullYear())?b_:x_)[d_];if(qv>P_-dy.getDate())qv-=P_-dy.getDate()+1,dy.setDate(1),11>d_?dy.setMonth(d_+1):(dy.setMonth(0),dy.setFullYear(dy.getFullYear()+1));else{dy.setDate(dy.getDate()+qv);break}}return d_=new Date(dy.getFullYear()+1,0,4),qv=Ev(new Date(dy.getFullYear(),0,4)),d_=Ev(d_),0>=Vy(qv,dy)?0>=Vy(d_,dy)?dy.getFullYear()+1:dy.getFullYear():dy.getFullYear()-1}om>>>=0,c0>>>=0,x0>>>=0,U0>>>=0;var Nv=bt()[U0+40>>>2>>>0];U0={Lb:_()[U0>>>2>>>0],Kb:_()[U0+4>>>2>>>0],eb:_()[U0+8>>>2>>>0],jb:_()[U0+12>>>2>>>0],fb:_()[U0+16>>>2>>>0],ab:_()[U0+20>>>2>>>0],Wa:_()[U0+24>>>2>>>0],$a:_()[U0+28>>>2>>>0],Rb:_()[U0+32>>>2>>>0],Jb:_()[U0+36>>>2>>>0],Mb:Nv?uv(Nv):""},x0=uv(x0),Nv={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var jv in Nv)x0=x0.replace(new RegExp(jv,"g"),Nv[jv]);var Lv="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p_="January February March April May June July August September October November December".split(" ");Nv={"%a":dy=>Lv[dy.Wa].substring(0,3),"%A":dy=>Lv[dy.Wa],"%b":dy=>p_[dy.fb].substring(0,3),"%B":dy=>p_[dy.fb],"%C":dy=>by((dy.ab+1900)/100|0,2),"%d":dy=>by(dy.jb,2),"%e":dy=>ry(dy.jb,2," "),"%g":dy=>Hv(dy).toString().substring(2),"%G":dy=>Hv(dy),"%H":dy=>by(dy.eb,2),"%I":dy=>(dy=dy.eb,dy==0?dy=12:12<dy&&(dy-=12),by(dy,2)),"%j":dy=>{for(var qv=0,d_=0;d_<=dy.fb-1;qv+=(r0(dy.ab+1900)?b_:x_)[d_++]);return by(dy.jb+qv,3)},"%m":dy=>by(dy.fb+1,2),"%M":dy=>by(dy.Kb,2),"%n":()=>`
`,"%p":dy=>0<=dy.eb&&12>dy.eb?"AM":"PM","%S":dy=>by(dy.Lb,2),"%t":()=>"	","%u":dy=>dy.Wa||7,"%U":dy=>by(Math.floor((dy.$a+7-dy.Wa)/7),2),"%V":dy=>{var qv=Math.floor((dy.$a+7-(dy.Wa+6)%7)/7);if(2>=(dy.Wa+371-dy.$a-2)%7&&qv++,qv)qv==53&&(d_=(dy.Wa+371-dy.$a)%7,d_==4||d_==3&&r0(dy.ab)||(qv=1));else{qv=52;var d_=(dy.Wa+7-dy.$a-1)%7;(d_==4||d_==5&&r0(dy.ab%400-1))&&qv++}return by(qv,2)},"%w":dy=>dy.Wa,"%W":dy=>by(Math.floor((dy.$a+7-(dy.Wa+6)%7)/7),2),"%y":dy=>(dy.ab+1900).toString().substring(2),"%Y":dy=>dy.ab+1900,"%z":dy=>{dy=dy.Jb;var qv=0<=dy;return dy=Math.abs(dy)/60,(qv?"+":"-")+("0000"+(dy/60*100+dy%60)).slice(-4)},"%Z":dy=>dy.Mb,"%%":()=>"%"},x0=x0.replace(/%%/g,"\0\0");for(jv in Nv)x0.includes(jv)&&(x0=x0.replace(new RegExp(jv,"g"),Nv[jv](U0)));return x0=x0.replace(/\0\0/g,"%"),jv=o_(x0),jv.length>c0?0:(Yy(jv,om),jv.length-1)}var Ov=om=>{try{om()}catch(c0){Ly(c0)}};function Qv(){var om=X0,c0={};for(let[x0,U0]of Object.entries(om))c0[x0]=typeof U0=="function"?function(){z_.push(x0);try{return U0.apply(null,arguments)}finally{L0||(z_.pop(),S_&&s_===1&&z_.length===0&&(s_=0,av+=1,Ov(lx),typeof Fibers<"u"&&Fibers.Sb()))}}:U0;return c0}var s_=0,S_=null,B_=0,z_=[],D1={},B1={},m1=0,S1=null,vw=[];function Hw(){return new Promise((om,c0)=>{S1={resolve:om,reject:c0}})}function Cw(){var om=_v(65548),c0=om+12;bt()[om>>>2>>>0]=c0,bt()[om+4>>>2>>>0]=c0+65536,c0=z_[0];var x0=D1[c0];return x0===void 0&&(x0=m1++,D1[c0]=x0,B1[x0]=c0),c0=x0,_()[om+8>>>2>>>0]=c0,om}function H1(){var om=_()[S_+8>>>2>>>0];return om=X0[B1[om]],--av,om()}function W1(om){if(!L0){if(s_===0){var c0=!1,x0=!1;om((U0=0)=>{if(!L0&&(B_=U0,c0=!0,x0)){s_=2,Ov(()=>Fx(S_)),typeof Browser<"u"&&Browser.ib.wb&&Browser.ib.resume(),U0=!1;try{var ry=H1()}catch(Ev){ry=Ev,U0=!0}var by=!1;if(!S_){var Vy=S1;Vy&&(S1=null,(U0?Vy.reject:Vy.resolve)(ry),by=!0)}if(U0&&!by)throw ry}}),x0=!0,c0||(s_=1,S_=Cw(),typeof Browser<"u"&&Browser.ib.wb&&Browser.ib.pause(),Ov(()=>jw(S_)))}else s_===2?(s_=0,Ov(y2),A_(S_),S_=null,vw.forEach(U0=>{if(!L0)try{U0(),h0()}catch(ry){O0(ry)}})):Ly(`invalid state: ${s_}`);return B_}}function u0(om){return W1(c0=>{om().then(c0)})}d0.hb();var M0=[mv,N0,xy,Sv,kv,C_,wy,Zv,Xv,v_,Rv,i1,h1,m0,E0,j0,D0,V0,dv,K0,Cy,lv,vv,f_],G0={r:function(om,c0,x0){return u0(async()=>{await b.Ab(om,c0,x0)})},b:function(om,c0,x0){throw om>>>=0,new F0(om).hb(c0>>>0,x0>>>0),sy=om,sy},N:function(om){y_(om>>>0,!fr,1,!cr,131072,!1),d0.pb()},l:function(om){om>>>=0,e0?postMessage({cmd:"cleanupThread",thread:om}):d0.nb(d0.Qa[om])},J:ev,i:Sv,T:kv,F:C_,H:wy,U:Zv,R:Xv,L:v_,Q:Rv,p:i1,G:h1,D:m0,S:E0,E:j0,q:()=>1,B:function(om,c0){om>>>=0,om==c0>>>0?setTimeout(()=>P0()):e0?postMessage({targetThread:om,cmd:"checkMailbox"}):(om=d0.Qa[om])&&om.postMessage({cmd:"checkMailbox"})},K:function(om,c0,x0,U0){c0>>>=0,Yr.length=x0,U0=U0>>>0>>>3;for(var ry=0;ry<x0;ry++)Yr[ry]=j()[U0+ry>>>0];return om=0>om?Ey[-om-1]:M0[om],d0.vb=c0,c0=om.apply(null,Yr),d0.vb=0,c0},M:$0,W:function(om){jr&&d0.Qa[om>>>0].ref()},u:function(om,c0,x0){om=c0+2097152>>>0<4194305-!!om?(om>>>0)+4294967296*c0:NaN,x0>>>=0,om=new Date(1e3*om),_()[x0>>>2>>>0]=om.getUTCSeconds(),_()[x0+4>>>2>>>0]=om.getUTCMinutes(),_()[x0+8>>>2>>>0]=om.getUTCHours(),_()[x0+12>>>2>>>0]=om.getUTCDate(),_()[x0+16>>>2>>>0]=om.getUTCMonth(),_()[x0+20>>>2>>>0]=om.getUTCFullYear()-1900,_()[x0+24>>>2>>>0]=om.getUTCDay(),om=(om.getTime()-Date.UTC(om.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,_()[x0+28>>>2>>>0]=om},v:function(om,c0,x0){om=c0+2097152>>>0<4194305-!!om?(om>>>0)+4294967296*c0:NaN,x0>>>=0,om=new Date(1e3*om),_()[x0>>>2>>>0]=om.getSeconds(),_()[x0+4>>>2>>>0]=om.getMinutes(),_()[x0+8>>>2>>>0]=om.getHours(),_()[x0+12>>>2>>>0]=om.getDate(),_()[x0+16>>>2>>>0]=om.getMonth(),_()[x0+20>>>2>>>0]=om.getFullYear()-1900,_()[x0+24>>>2>>>0]=om.getDay(),c0=(r0(om.getFullYear())?p0:_0)[om.getMonth()]+om.getDate()-1|0,_()[x0+28>>>2>>>0]=c0,_()[x0+36>>>2>>>0]=-(60*om.getTimezoneOffset()),c0=new Date(om.getFullYear(),6,1).getTimezoneOffset();var U0=new Date(om.getFullYear(),0,1).getTimezoneOffset();om=(c0!=U0&&om.getTimezoneOffset()==Math.min(U0,c0))|0,_()[x0+32>>>2>>>0]=om},w:function(om){om>>>=0;var c0=new Date(_()[om+20>>>2>>>0]+1900,_()[om+16>>>2>>>0],_()[om+12>>>2>>>0],_()[om+8>>>2>>>0],_()[om+4>>>2>>>0],_()[om>>>2>>>0],0),x0=_()[om+32>>>2>>>0],U0=c0.getTimezoneOffset(),ry=new Date(c0.getFullYear(),6,1).getTimezoneOffset(),by=new Date(c0.getFullYear(),0,1).getTimezoneOffset(),Vy=Math.min(by,ry);return 0>x0?_()[om+32>>>2>>>0]=+(ry!=by&&Vy==U0):0<x0!=(Vy==U0)&&(ry=Math.max(by,ry),c0.setTime(c0.getTime()+6e4*((0<x0?Vy:ry)-U0))),_()[om+24>>>2>>>0]=c0.getDay(),x0=(r0(c0.getFullYear())?p0:_0)[c0.getMonth()]+c0.getDate()-1|0,_()[om+28>>>2>>>0]=x0,_()[om>>>2>>>0]=c0.getSeconds(),_()[om+4>>>2>>>0]=c0.getMinutes(),_()[om+8>>>2>>>0]=c0.getHours(),_()[om+12>>>2>>>0]=c0.getDate(),_()[om+16>>>2>>>0]=c0.getMonth(),_()[om+20>>>2>>>0]=c0.getYear(),om=c0.getTime(),isNaN(om)?(_()[Ky()>>>2>>>0]=61,om=-1):om/=1e3,Ry((uy=om,1<=+Math.abs(uy)?0<uy?+Math.floor(uy/4294967296)>>>0:~~+Math.ceil((uy-+(~~uy>>>0))/4294967296)>>>0:0)),om>>>0},s:D0,t:V0,A:function(om,c0,x0){function U0(Nv){return(Nv=Nv.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Nv[1]:"GMT"}om>>>=0,c0>>>=0,x0>>>=0;var ry=new Date().getFullYear(),by=new Date(ry,0,1),Vy=new Date(ry,6,1);ry=by.getTimezoneOffset();var Ev=Vy.getTimezoneOffset(),Hv=Math.max(ry,Ev);bt()[om>>>2>>>0]=60*Hv,_()[c0>>>2>>>0]=+(ry!=Ev),om=U0(by),c0=U0(Vy),om=yy(om),c0=yy(c0),Ev<ry?(bt()[x0>>>2>>>0]=om,bt()[x0+4>>>2>>>0]=c0):(bt()[x0>>>2>>>0]=c0,bt()[x0+4>>>2>>>0]=om)},d:()=>{Ly("")},c:function(om,c0,x0){return om>>>=0,c0=gy(c0>>>0,x0>>>0),Ey[om].apply(null,c0)},k:function(om,c0,x0){return om>>>=0,c0=gy(c0>>>0,x0>>>0),Ey[om].apply(null,c0)},m:()=>{},j:()=>Date.now(),V:()=>{throw av+=1,"unwind"},C:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:()=>jr?(Vi(),Gt(Wi)).cpus().length:navigator.hardwareConcurrency,y:function(om){om>>>=0;var c0=h().length;if(om<=c0||4294901760<om)return!1;for(var x0=1;4>=x0;x0*=2){var U0=c0*(1+.2/x0);U0=Math.min(U0,om+100663296);var ry=Math;U0=Math.max(om,U0);e:{ry=(ry.min.call(ry,4294901760,U0+(65536-U0%65536)%65536)-ty.buffer.byteLength+65535)/65536;try{ty.grow(ry),Uy();var by=1;break e}catch{}by=void 0}if(by)return!0}return!1},O:dv,P:K0,I:cv,h:Cy,o:lv,x:vv,n:f_,a:ty||b.wasmMemory,z:w_,e:function(om,c0,x0,U0){return w_(om>>>0,c0>>>0,x0>>>0,U0>>>0)}},X0=function(){function om(x0,U0){return X0=x0.exports,X0=Qv(),X0=E1(),d0.qb.push(X0.Da),iv.unshift(X0.X),w0=U0,hy(),X0}var c0={a:G0};if(B0++,b.instantiateWasm)try{return b.instantiateWasm(c0,om)}catch(x0){H0(`Module.instantiateWasm callback failed with error: ${x0}`),It(x0)}return b0(c0,function(x0){om(x0.instance,x0.module)}).catch(It),{}}();b._OrtInit=(om,c0)=>(b._OrtInit=X0.Y)(om,c0),b._OrtGetLastError=(om,c0)=>(b._OrtGetLastError=X0.Z)(om,c0),b._OrtCreateSessionOptions=(om,c0,x0,U0,ry,by,Vy,Ev,Hv,Nv)=>(b._OrtCreateSessionOptions=X0._)(om,c0,x0,U0,ry,by,Vy,Ev,Hv,Nv),b._OrtAppendExecutionProvider=(om,c0)=>(b._OrtAppendExecutionProvider=X0.$)(om,c0),b._OrtAddFreeDimensionOverride=(om,c0,x0)=>(b._OrtAddFreeDimensionOverride=X0.aa)(om,c0,x0),b._OrtAddSessionConfigEntry=(om,c0,x0)=>(b._OrtAddSessionConfigEntry=X0.ba)(om,c0,x0),b._OrtReleaseSessionOptions=om=>(b._OrtReleaseSessionOptions=X0.ca)(om),b._OrtCreateSession=(om,c0,x0)=>(b._OrtCreateSession=X0.da)(om,c0,x0),b._OrtReleaseSession=om=>(b._OrtReleaseSession=X0.ea)(om),b._OrtGetInputOutputCount=(om,c0,x0)=>(b._OrtGetInputOutputCount=X0.fa)(om,c0,x0),b._OrtGetInputName=(om,c0)=>(b._OrtGetInputName=X0.ga)(om,c0),b._OrtGetOutputName=(om,c0)=>(b._OrtGetOutputName=X0.ha)(om,c0),b._OrtFree=om=>(b._OrtFree=X0.ia)(om),b._OrtCreateTensor=(om,c0,x0,U0,ry,by)=>(b._OrtCreateTensor=X0.ja)(om,c0,x0,U0,ry,by),b._OrtGetTensorData=(om,c0,x0,U0,ry)=>(b._OrtGetTensorData=X0.ka)(om,c0,x0,U0,ry),b._OrtReleaseTensor=om=>(b._OrtReleaseTensor=X0.la)(om),b._OrtCreateRunOptions=(om,c0,x0,U0)=>(b._OrtCreateRunOptions=X0.ma)(om,c0,x0,U0),b._OrtAddRunConfigEntry=(om,c0,x0)=>(b._OrtAddRunConfigEntry=X0.na)(om,c0,x0),b._OrtReleaseRunOptions=om=>(b._OrtReleaseRunOptions=X0.oa)(om),b._OrtCreateBinding=om=>(b._OrtCreateBinding=X0.pa)(om),b._OrtBindInput=(om,c0,x0)=>(b._OrtBindInput=X0.qa)(om,c0,x0),b._OrtBindOutput=(om,c0,x0,U0)=>(b._OrtBindOutput=X0.ra)(om,c0,x0,U0),b._OrtClearBoundOutputs=om=>(b._OrtClearBoundOutputs=X0.sa)(om),b._OrtReleaseBinding=om=>(b._OrtReleaseBinding=X0.ta)(om),b._OrtRunWithBinding=(om,c0,x0,U0,ry)=>(b._OrtRunWithBinding=X0.ua)(om,c0,x0,U0,ry),b._OrtRun=(om,c0,x0,U0,ry,by,Vy,Ev)=>(b._OrtRun=X0.va)(om,c0,x0,U0,ry,by,Vy,Ev),b._OrtEndProfiling=om=>(b._OrtEndProfiling=X0.wa)(om),b._JsepOutput=(om,c0,x0)=>(b._JsepOutput=X0.xa)(om,c0,x0),b._JsepGetNodeName=om=>(b._JsepGetNodeName=X0.ya)(om);var Ky=()=>(Ky=X0.za)(),Xy=b._pthread_self=()=>(Xy=b._pthread_self=X0.Aa)(),_v=b._malloc=om=>(_v=b._malloc=X0.Ba)(om),A_=b._free=om=>(A_=b._free=X0.Ca)(om);b.__emscripten_tls_init=()=>(b.__emscripten_tls_init=X0.Da)();var y_=b.__emscripten_thread_init=(om,c0,x0,U0,ry,by)=>(y_=b.__emscripten_thread_init=X0.Fa)(om,c0,x0,U0,ry,by);b.__emscripten_thread_crashed=()=>(b.__emscripten_thread_crashed=X0.Ga)();var $_=(om,c0,x0,U0)=>($_=X0.Ha)(om,c0,x0,U0),G_=om=>(G_=X0.Ia)(om),aw=b.__emscripten_thread_exit=om=>(aw=b.__emscripten_thread_exit=X0.Ja)(om),Ww=()=>(Ww=X0.Ka)(),Ry=om=>(Ry=X0.La)(om),t_=(om,c0)=>(t_=X0.Ma)(om,c0),Pv=()=>(Pv=X0.Na)(),l_=om=>(l_=X0.Oa)(om),t1=om=>(t1=X0.Pa)(om),L1=b.dynCall_ii=(om,c0)=>(L1=b.dynCall_ii=X0.Ra)(om,c0),jw=om=>(jw=X0.Sa)(om),lx=()=>(lx=X0.Ta)(),Fx=om=>(Fx=X0.Ua)(om),y2=()=>(y2=X0.Va)();b.___start_em_js=945539,b.___stop_em_js=945700;function E1(){var om=X0;om=Object.assign({},om);var c0=U0=>()=>U0()>>>0,x0=U0=>ry=>U0(ry)>>>0;return om.za=c0(om.za),om.Aa=c0(om.Aa),om.Ba=x0(om.Ba),om.emscripten_main_runtime_thread_id=c0(om.emscripten_main_runtime_thread_id),om.Na=c0(om.Na),om.Pa=x0(om.Pa),om}b.wasmMemory=ty,b.stackAlloc=t1,b.stackSave=Pv,b.stackRestore=l_,b.keepRuntimeAlive=()=>0<av,b.UTF8ToString=uv,b.stringToUTF8=ov,b.lengthBytesUTF8=Vv,b.ExitStatus=Dy,b.PThread=d0;var ux;Ay=function om(){ux||O_(),ux||(Ay=om)};function O_(){if(!(0<B0))if(e0)Et(b),e0||v0(iv),startWorker(b);else{if(b.preRun)for(typeof b.preRun=="function"&&(b.preRun=[b.preRun]);b.preRun.length;)Zy.unshift(b.preRun.shift());v0(Zy),0<B0||ux||(ux=!0,b.calledRun=!0,L0||(e0||v0(iv),Et(b),e0||v0(zy)))}}return O_(),d.ready}})();typeof a=="object"&&typeof e=="object"?e.exports=o:typeof define=="function"&&define.amd&&define([],()=>o)}),Fi=tr((a,e)=>{e.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed?.(),a}}self.onmessage=handleMessage;\n'}),ji,_d,ra,na,an,qi,xd,Sd,Cd,Ki,Ge,nr=F(()=>{ji=Mi(),_d=Li(),na=!1,an=!1,qi=!1,xd=a=>{if(a===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+a+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+a+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Sd=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Cd=(a,e)=>a?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":e?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Ki=async a=>{if(na)return Promise.resolve();if(an)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(qi)throw new Error("previous call to 'initializeWebAssembly()' failed.");an=!0;let e=a.initTimeout,o=a.numThreads,s=a.simd,d=xd(o),c=s&&Sd(),h=a.wasmPaths,_=typeof h=="string"?h:void 0,bt=Cd(c,d),g=typeof h=="object"?h[bt]:void 0,j=!1,b=[];if(e>0&&b.push(new Promise(Et=>{setTimeout(()=>{j=!0,Et()},e)})),b.push(new Promise((Et,It)=>{let zt=d?_d:ji,er={locateFile:(Hn,Qt)=>{if(d&&Hn.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Fi()],{type:"text/javascript"}));if(Hn.endsWith(".wasm")){if(g)return g;let cr=_??Qt;return bt==="ort-wasm-simd.wasm"?cr+"ort-wasm-simd.jsep.wasm":bt==="ort-wasm-simd-threaded.wasm"?cr+"ort-wasm-simd-threaded.jsep.wasm":cr+bt}return Qt+Hn}};if(d)if(er.numThreads=o,typeof Blob>"u")er.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let Hn=`var ortWasmThreaded=${zt.toString()};`;er.mainScriptUrlOrBlob=new Blob([Hn],{type:"text/javascript"})}zt(er).then(Hn=>{an=!1,na=!0,ra=Hn,Et()},Hn=>{an=!1,qi=!0,It(Hn)})})),await Promise.race(b),j)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},Ge=()=>{if(na&&ra)return ra;throw new Error("WebAssembly is not initialized yet.")}}),He,Cr,Be,on=F(()=>{nr(),He=(a,e)=>{let o=Ge(),s=o.lengthBytesUTF8(a)+1,d=o._malloc(s);return o.stringToUTF8(a,d,s),e.push(d),d},Cr=(a,e,o,s)=>{if(typeof a=="object"&&a!==null){if(o.has(a))throw new Error("Circular reference in options");o.add(a)}Object.entries(a).forEach(([d,c])=>{let h=e?e+d:d;if(typeof c=="object")Cr(c,h+".",o,s);else if(typeof c=="string"||typeof c=="number")s(h,c.toString());else if(typeof c=="boolean")s(h,c?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof c}`)})},Be=a=>{let e=Ge(),o=e.stackSave();try{let s=e.stackAlloc(8);e._OrtGetLastError(s,s+4);let d=e.HEAP32[s/4],c=e.HEAPU32[s/4+1],h=c?e.UTF8ToString(c):"";throw new Error(`${a} ERROR_CODE: ${d}, ERROR_MESSAGE: ${h}`)}finally{e.stackRestore(o)}}}),Yi,Zi=F(()=>{nr(),on(),Yi=a=>{let e=Ge(),o=0,s=[],d=a||{};try{if((a==null?void 0:a.logSeverityLevel)===void 0)d.logSeverityLevel=2;else if(typeof a.logSeverityLevel!="number"||!Number.isInteger(a.logSeverityLevel)||a.logSeverityLevel<0||a.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${a.logSeverityLevel}`);if((a==null?void 0:a.logVerbosityLevel)===void 0)d.logVerbosityLevel=0;else if(typeof a.logVerbosityLevel!="number"||!Number.isInteger(a.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${a.logVerbosityLevel}`);(a==null?void 0:a.terminate)===void 0&&(d.terminate=!1);let c=0;return(a==null?void 0:a.tag)!==void 0&&(c=He(a.tag,s)),o=e._OrtCreateRunOptions(d.logSeverityLevel,d.logVerbosityLevel,!!d.terminate,c),o===0&&Be("Can't create run options."),(a==null?void 0:a.extra)!==void 0&&Cr(a.extra,"",new WeakSet,(h,_)=>{let bt=He(h,s),g=He(_,s);e._OrtAddRunConfigEntry(o,bt,g)!==0&&Be(`Can't set a run config entry: ${h} - ${_}.`)}),[o,s]}catch(c){throw o!==0&&e._OrtReleaseRunOptions(o),s.forEach(h=>e._free(h)),c}}}),Id,Ed,Ad,Td,Xi,Qi=F(()=>{nr(),on(),Id=a=>{switch(a){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${a}`)}},Ed=a=>{switch(a){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${a}`)}},Ad=a=>{a.extra||(a.extra={}),a.extra.session||(a.extra.session={});let e=a.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),a.executionProviders&&a.executionProviders.some(o=>(typeof o=="string"?o:o.name)==="webgpu")&&(a.enableMemPattern=!1)},Td=(a,e,o)=>{for(let s of e){let d=typeof s=="string"?s:s.name;switch(d){case"webnn":if(d="WEBNN",typeof s!="string"){let h=s;if(h!=null&&h.deviceType){let _=He("deviceType",o),bt=He(h.deviceType,o);Ge()._OrtAddSessionConfigEntry(a,_,bt)!==0&&Be(`Can't set a session config entry: 'deviceType' - ${h.deviceType}.`)}if(h!=null&&h.numThreads){let _=h.numThreads;(typeof _!="number"||!Number.isInteger(_)||_<0)&&(_=0);let bt=He("numThreads",o),g=He(_.toString(),o);Ge()._OrtAddSessionConfigEntry(a,bt,g)!==0&&Be(`Can't set a session config entry: 'numThreads' - ${h.numThreads}.`)}if(h!=null&&h.powerPreference){let _=He("powerPreference",o),bt=He(h.powerPreference,o);Ge()._OrtAddSessionConfigEntry(a,_,bt)!==0&&Be(`Can't set a session config entry: 'powerPreference' - ${h.powerPreference}.`)}}break;case"webgpu":if(d="JS",typeof s!="string"){let h=s;if(h!=null&&h.preferredLayout){if(h.preferredLayout!=="NCHW"&&h.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${h.preferredLayout}`);let _=He("preferredLayout",o),bt=He(h.preferredLayout,o);Ge()._OrtAddSessionConfigEntry(a,_,bt)!==0&&Be(`Can't set a session config entry: 'preferredLayout' - ${h.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${d}`)}let c=He(d,o);Ge()._OrtAppendExecutionProvider(a,c)!==0&&Be(`Can't append execution provider: ${d}.`)}},Xi=a=>{let e=Ge(),o=0,s=[],d=a||{};Ad(d);try{let c=Id(d.graphOptimizationLevel??"all"),h=Ed(d.executionMode??"sequential"),_=typeof d.logId=="string"?He(d.logId,s):0,bt=d.logSeverityLevel??2;if(!Number.isInteger(bt)||bt<0||bt>4)throw new Error(`log serverity level is not valid: ${bt}`);let g=d.logVerbosityLevel??0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);let j=typeof d.optimizedModelFilePath=="string"?He(d.optimizedModelFilePath,s):0;if(o=e._OrtCreateSessionOptions(c,!!d.enableCpuMemArena,!!d.enableMemPattern,h,!!d.enableProfiling,0,_,bt,g,j),o===0&&Be("Can't create session options."),d.executionProviders&&Td(o,d.executionProviders,s),d.enableGraphCapture!==void 0){if(typeof d.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${d.enableGraphCapture}`);let b=He("enableGraphCapture",s),Et=He(d.enableGraphCapture.toString(),s);e._OrtAddSessionConfigEntry(o,b,Et)!==0&&Be(`Can't set a session config entry: 'enableGraphCapture' - ${d.enableGraphCapture}.`)}if(d.freeDimensionOverrides)for(let[b,Et]of Object.entries(d.freeDimensionOverrides)){if(typeof b!="string")throw new Error(`free dimension override name must be a string: ${b}`);if(typeof Et!="number"||!Number.isInteger(Et)||Et<0)throw new Error(`free dimension override value must be a non-negative integer: ${Et}`);let It=He(b,s);e._OrtAddFreeDimensionOverride(o,It,Et)!==0&&Be(`Can't set a free dimension override: ${b} - ${Et}.`)}return d.extra!==void 0&&Cr(d.extra,"",new WeakSet,(b,Et)=>{let It=He(b,s),zt=He(Et,s);e._OrtAddSessionConfigEntry(o,It,zt)!==0&&Be(`Can't set a session config entry: ${b} - ${Et}.`)}),[o,s]}catch(c){throw o!==0&&e._OrtReleaseSessionOptions(o),s.forEach(h=>e._free(h)),c}}}),aa,Bt,Ir,sn,Er,un,ia,ie=F(()=>{aa=a=>{switch(a){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${a}`)}},Bt=a=>{switch(a){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${a}`)}},Ir=a=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][a],sn=a=>{switch(a){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${a}`)}},Er=a=>{switch(a){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${a}`)}},un=a=>a==="float32"||a==="float16"||a==="int32"||a==="int64"||a==="uint32"||a==="uint8"||a==="bool",ia=a=>{switch(a){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${a}`)}}}),Ar,oa=F(()=>{Ar=async a=>{if(typeof a=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(a))}catch(e){if(e.code==="ERR_FS_FILE_TOO_LARGE"){let o=(void 0)(a),s=[];for await(let d of o)s.push(d);return new Uint8Array(Buffer.concat(s))}throw e}else{let e=await fetch(a);if(!e.ok)throw new Error(`failed to load external data file: ${a}`);let o=e.headers.get("Content-Length"),s=o?parseInt(o,10):0;if(s<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${a}, no response body.`);let d=e.body.getReader(),c;try{c=new ArrayBuffer(s)}catch(_){if(_ instanceof RangeError){let bt=Math.ceil(s/65536);c=new WebAssembly.Memory({initial:bt,maximum:bt}).buffer}else throw _}let h=0;for(;;){let{done:_,value:bt}=await d.read();if(_)break;let g=bt.byteLength;new Uint8Array(c,h,g).set(bt),h+=g}return new Uint8Array(c,0,s)}}else return a instanceof Blob?new Uint8Array(await a.arrayBuffer()):a instanceof Uint8Array?a:new Uint8Array(a)}}),Od,kd,Ji,eo,to,Pd,De,Dt=F(()=>{ie(),Od=["V","I","W","E","F"],kd=(a,e)=>{console.log(`[${Od[a]},${new Date().toISOString()}]${e}`)},to=(a,e)=>{Ji=a,eo=e},Pd=(a,e)=>{let o=Er(a),s=Er(Ji);o>=s&&kd(o,typeof e=="function"?e():e)},De=(...a)=>{eo&&Pd(...a)}}),ro,no=F(()=>{ie(),ro=(a,e)=>new(sn(e))(a)}),ln=F(()=>{}),dn,Rd,ao,ua,sa,oo,so=F(()=>{Dt(),ln(),dn=a=>Math.ceil(a/16)*16,Rd=1,ao=()=>Rd++,ua=async(a,e,o,s)=>{let d=dn(o),c=a.device.createBuffer({size:d,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let h=a.getCommandEncoder();a.endComputePass(),h.copyBufferToBuffer(e,0,c,0,d),a.flush(),await c.mapAsync(GPUMapMode.READ);let _=c.getMappedRange();if(s){let bt=s();return bt.set(new Uint8Array(_,0,o)),bt}else return new Uint8Array(_.slice(0,o))}finally{c.destroy()}},sa=class{constructor(a){this.backend=a,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map,this.capturedPendingBuffers=new Map}upload(a,e){let o=e.buffer,s=e.byteOffset,d=e.byteLength,c=dn(d),h=this.storageCache.get(a);if(!h)throw new Error("gpu data for uploading does not exist");if(h.originalSize!==d)throw new Error(`inconsistent data size. gpu data size=${h.originalSize}, data size=${d}`);let _=this.backend.device.createBuffer({mappedAtCreation:!0,size:c,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),bt=_.getMappedRange();new Uint8Array(bt).set(new Uint8Array(o,s,d)),_.unmap();let g=this.backend.getCommandEncoder();this.backend.endComputePass(),g.copyBufferToBuffer(_,0,h.gpuData.buffer,0,c),De("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${a})`),this.buffersForUploadingPending.push(_)}memcpy(a,e){let o=this.storageCache.get(a);if(!o)throw new Error("source gpu data for memcpy does not exist");let s=this.storageCache.get(e);if(!s)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==s.originalSize)throw new Error("inconsistent source and destination gpu data size");let d=dn(o.originalSize),c=this.backend.getCommandEncoder();this.backend.endComputePass(),c.copyBufferToBuffer(o.gpuData.buffer,0,s.gpuData.buffer,0,d)}registerExternalBuffer(a,e,o){let s;if(o){if(s=this.externalBuffers.get(o),s===void 0)throw new Error("previous buffer is not registered");if(a===o)return De("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${s}, buffer is the same, skip.`),s;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);this.externalBuffers.delete(o)}else s=ao();return this.storageCache.set(s,{gpuData:{id:s,type:0,buffer:a},originalSize:e}),this.externalBuffers.set(a,s),De("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${s}, registered.`),s}unregisterExternalBuffer(a){let e=this.externalBuffers.get(a);e!==void 0&&(this.storageCache.delete(e),this.externalBuffers.delete(a),De("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(a,e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=dn(a),s,d=(e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,c=(e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(d||c){let _=d?this.freeBuffers:this.freeUniformBuffers,bt=_.get(o);bt||(bt=[],_.set(o,bt)),bt.length>0?s=bt.pop():s=this.backend.device.createBuffer({size:o,usage:e})}else s=this.backend.device.createBuffer({size:o,usage:e});let h={id:ao(),type:0,buffer:s};return this.storageCache.set(h.id,{gpuData:h,originalSize:a}),De("verbose",()=>`[WebGPU] GpuDataManager.create(size=${a}) => id=${h.id}`),h}get(a){var e;return(e=this.storageCache.get(a))==null?void 0:e.gpuData}release(a){let e=this.storageCache.get(a);if(!e)throw new Error("releasing data does not exist");return De("verbose",()=>`[WebGPU] GpuDataManager.release(id=${a}), gpuDataId=${e.gpuData.id}`),this.storageCache.delete(a),this.buffersPending.push(e.gpuData.buffer),e.originalSize}async download(a,e){let o=this.storageCache.get(a);if(!o)throw new Error("data does not exist");await ua(this.backend,o.gpuData.buffer,o.originalSize,e)}refreshPendingBuffers(){for(let a of this.buffersForUploadingPending)a.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let a of this.buffersPending)(a.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(a.size).push(a):(a.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(a.size).push(a):a.destroy();this.buffersPending=[]}else{let a=this.capturedPendingBuffers.get(this.backend.currentSessionId);a||(a=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,a));for(let e of this.buffersPending)a.push(e);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(a=>{a.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(a=>{a.forEach(e=>{e.destroy()})}),this.storageCache.forEach(a=>{a.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(a=>{a.forEach(e=>{e.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onReleaseSession(a){let e=this.capturedPendingBuffers.get(a);e&&(e.forEach(o=>{o.destroy()}),this.capturedPendingBuffers.delete(a))}},oo=(...a)=>new sa(...a)}),la,$e,Ye=F(()=>{la=class{constructor(a){Object.assign(this,a)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(a=>`${this[a]}`).join(";")),this.key}},$e=a=>new la(a)}),da,vt,M,qt,cn,pn,fn,_e=F(()=>{da=class{static calcMatMulShape(a,e){return a[1]!==e[0]?void 0:[a[0],e[1]]}},vt=class{static calcShape(a,e,o=!1){let s=a.length,d=e.length;if(s===0)return e;if(d===0)return a;let c=Math.max(a.length,e.length),h=new Array(c);if(o){if(s<2||d<2)return;let _=da.calcMatMulShape([a[s-2],a[s-1]],[e[d-2],e[d-1]]);if(_===void 0)return;[h[c-2],h[c-1]]=_}for(let _=o?3:1;_<=c;_++){let bt=s-_<0?1:a[s-_],g=d-_<0?1:e[d-_];if(bt!==g&&bt>1&&g>1)return;let j=Math.max(bt,g);if(bt&&g)h[c-_]=Math.max(bt,g);else{if(j>1)return;h[c-_]=0}}return h}static isValidBroadcast(a,e){let o=a.length,s=e.length;if(o>s)return!1;for(let d=1;d<=o;d++)if(a[o-d]!==1&&a[o-d]!==e[s-d])return!1;return!0}},M=class LE{static size(e){return LE.getSizeFromDimensionRange(e,0,e.length)}static convertShape(e,o=4){let s=e.length;if(s===0)return[];let d=new Array(s),c=s-1;for(;c>=0;){if(e[c]%o===0){d[c]=e[c]/o;break}if(o%e[c]!==0)throw new Error("cannot convert shape");d[c]=1,o/=e[c],c--}for(c--;c>=0;c--)d[c]=e[c];return d}static sizeFromDimension(e,o){if(o<0||o>e.length)throw new Error(`invalid dimension of ${o} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return LE.getSizeFromDimensionRange(e,o,e.length)}static sizeToDimension(e,o){if(o<0||o>e.length)throw new Error(`invalid dimension of ${o} for sizeToDimension as Tensor has ${e.length} dimensions.`);return LE.getSizeFromDimensionRange(e,0,o)}static getSizeFromDimensionRange(e,o,s){let d=1;for(let c=o;c<s;c++){if(e[c]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");d*=e[c]}return d}static computeStrides(e){let o=e.length;if(o===0)return[];if(o===1)return[1];let s=new Array(o);s[o-1]=1,s[o-2]=e[o-1];for(let d=o-3;d>=0;--d)s[d]=s[d+1]*e[d+1];return s}static normalizeAxis(e,o){if(e<-o&&e>=o)throw new Error("unsupported axis for this operation.");return e<0?e+o:e}static normalizeAxes(e,o){return e.map(s=>this.normalizeAxis(s,o??e.length))}static sortBasedOnPerm(e,o){return o?o.map(s=>e[s]):e.slice().reverse()}static padShape(e,o){let s=e.length;return e.map((d,c)=>d+o[c]+o[c+s])}static areEqual(e,o){return e.length!==o.length?!1:e.every((s,d)=>s===o[d])}},qt=class PS{static adjustPoolAttributes(e,o,s,d,c,h){if(!e&&s.length!==o.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let _=0;_<o.length-2;_++)_>=s.length?s.push(o[_+2]):s[_]=o[_+2];for(let _=0;_<s.length;_++)if(_<d.length){if(d[_]<0)throw new Error("strides should be greater than or equal to 1")}else d.push(1);for(let _=0;_<s.length;_++)if(_<c.length){if(c[_]<0)throw new Error("dilations should be greater than or equal to 1")}else c.push(1);for(let _=0;_<s.length*2;_++)if(_<h.length){if(h[_]<0)throw new Error("pad should be greater than or equal to 1")}else h.push(0);for(let _=0;_<s.length;_++){if(s[_]<=0)throw new Error("kernel shapes need to be greater than 0");if(h[_]>=s[_]||h[_+s.length]>=s[_])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,o,s,d,c,h,_){if(_){if(c.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(o.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(d.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let bt=0;bt<e.length-2;bt++)PS.adjustPadAndReturnShape(e[bt+(h?1:2)],o[bt],s[bt],d[bt],c,bt,bt+e.length-2,_)}}static computePoolOutputShape(e,o,s,d,c,h,_){if(o.length<=0)throw new Error("input shape must be of size greater than 0");let bt=[o[0],o[1]];return PS.computeShapeHelper(e,o,bt,s,d,c,h,_),bt}static computeConvOutputShape(e,o,s,d,c,h,_){if(e.length<=0||o.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let bt=[e[0],o[0]];return PS.computeShapeHelper(!1,e,bt,s,d,c,h,_),bt}static computeShapeHelper(e,o,s,d,c,h,_,bt){if(e)for(let g=0;g<o.length-2;g++)s.push(1);else for(let g=0;g<o.length-2;g++)s.push(PS.adjustPadAndReturnShape(o[g+2],d[g],c[g],h[g],_,g,g+o.length-2,bt))}static adjustPadAndReturnShape(e,o,s,d,c,h,_,bt){let g=s*(d-1)+1;if(bt&&bt!=="NOTSET")switch(bt){case"VALID":return c[h]=0,c[_]=0,Math.floor((e-g)/o+1);case"SAME_LOWER":case"SAME_UPPER":if(s!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let j=((e+o-1)/o-1)*o+d-e;return c[h]=Math.floor(bt==="SAME_LOWER"?(j+1)/2:j/2),c[_]=j-c[h],Math.floor((e+j-d)/o+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+c[h]+c[_]-g)/o+1)}},cn=class{static getShapeOfGemmResult(a,e,o,s,d){if(a.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let c,h,_;e?(c=a[1],h=a[0]):(c=a[0],h=a[1]);let bt=-1;if(s?(_=o[0],bt=1):(_=o[1],bt=0),o[bt]!==h)throw new Error("dimension mismatch");if(c<=0||_<=0||h<=0)throw new Error("invalid shape specified");if(d&&!vt.isValidBroadcast(d,[c,_]))throw new Error("gemm: invalid bias shape for broadcast");return[c,_,h]}},pn=-34028234663852886e22,fn=34028234663852886e22}),mn,pa,ke,at,K,Me,Xe,mt,it,re,fa,D,q,hn,ca,uo,ar,be=F(()=>{ie(),_e(),mn=64,pa=(a,e)=>{if(e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(a){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${a}`)}},ke=(a,e=1)=>{let o=pa(a,e);return typeof o=="string"?o:o[0]},at=(a,e=1)=>{let o=pa(a,e);return typeof o=="string"?o:o[1]},K=(...a)=>{let e=[];return a.forEach(o=>{o.length!==0&&e.push({type:12,data:o},{type:12,data:M.computeStrides(o)})}),e},Me=a=>a%4===0?4:a%2===0?2:1,Xe=(a="f32",e,o="0")=>!e||e===1?`${a}(${o})`:`vec${e}<${a}>(${o})`,mt=(a,e,o)=>a==="f32"?o:e===1?`f32(${o})`:`vec${e}f(${o})`,it=(a,e)=>e===4?`(${a}.x + ${a}.y + ${a}.z + ${a}.w)`:e===2?`(${a}.x + ${a}.y)`:e===3?`(${a}.x + ${a}.y + ${a}.z)`:a,re=(a,e,o,s)=>a.startsWith("uniforms.")&&o>4?typeof e=="string"?s==="f16"?`${a}[(${e}) / 8][(${e}) % 8 / 4][(${e}) % 8 % 4]`:`${a}[(${e}) / 4][(${e}) % 4]`:s==="f16"?`${a}[${Math.floor(e/8)}][${Math.floor(e%8/4)}][${e%8%4}]`:`${a}[${Math.floor(e/4)}][${e%4}]`:o>1?`${a}[${e}]`:a,fa=(a,e,o,s,d)=>{let c=typeof o=="number",h=c?o:o.length,_=[...new Array(h).keys()],bt=h<2?"u32":h<=4?`vec${h}<u32>`:`array<u32, ${h}>`,g=pa(e,d),j=typeof g=="string"?g:g[1],b=typeof g=="string"?g:g[0],Et={indices:bt,value:j,storage:b,tensor:e},It=T0=>typeof T0=="string"?T0:`${T0}u`,zt={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},er=c?"uniforms.":"",Hn=`${er}${a}_shape`,Qt=`${er}${a}_strides`,cr="";for(let T0=0;T0<h-1;T0++)cr+=`
    let dim${T0} = current / ${re(Qt,T0,h)};
    let rest${T0} = current % ${re(Qt,T0,h)};
    indices[${T0}] = dim${T0};
    current = rest${T0};
    `;cr+=`indices[${h-1}] = current;`;let fr=h<2?"":`
  fn o2i_${a}(offset: u32) -> ${Et.indices} {
    var indices: ${Et.indices};
    var current = offset;
    ${cr}
    return indices;
  }`,jr=T0=>(zt.offsetToIndices=!0,h<2?T0:`o2i_${a}(${T0})`),e0=[];if(h>=2)for(let T0=h-1;T0>=0;T0--)e0.push(`${re(Qt,T0,h)} * (indices[${T0}])`);let t0=h<2?"":`
  fn i2o_${a}(indices: ${Et.indices}) -> u32 {
    return ${e0.join("+")};
  }`,o0=T0=>(zt.indicesToOffset=!0,h<2?T0:`i2o_${a}(${T0})`),l0=(...T0)=>h===0?"0u":`${Et.indices}(${T0.map(It).join(",")})`,g0=(T0,q0)=>h<2?`${T0}`:`${re(T0,q0,h)}`,i0=(T0,q0,vy)=>h<2?`${T0}=${vy};`:`${re(T0,q0,h)}=${vy};`,f0={},C0=(T0,q0)=>{zt.broadcastedIndicesToOffset=!0;let vy=`${q0.name}broadcastedIndicesTo${a}Offset`;if(vy in f0)return`${vy}(${T0})`;let J0=[];for(let cy=h-1;cy>=0;cy--){let Ty=q0.indicesGet("outputIndices",cy+q0.rank-h);J0.push(`${g0(Qt,cy)} * (${Ty} % ${g0(Hn,cy)})`)}return f0[vy]=`fn ${vy}(outputIndices: ${q0.type.indices}) -> u32 {
             return ${J0.length>0?J0.join("+"):"0u"};
           }`,`${vy}(${T0})`},Z0=(T0,q0)=>(()=>{if(Et.storage===Et.value)return`${a}[${T0}]=${q0};`;if(Et.storage==="vec2<u32>"&&Et.value==="i32")return`${a}[${T0}]=vec2<u32>(u32(${q0}), select(0u, 0xFFFFFFFFu, ${q0} < 0));`;if(Et.storage==="vec2<u32>"&&Et.value==="u32")return`${a}[${T0}]=vec2<u32>(u32(${q0}), 0u);`;if(Et.storage==="u32"&&Et.value==="vec4<bool>")return`${a}[${T0}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${q0}));`;throw new Error(`not supported combination of storage type ${Et.storage} and value type ${Et.value} yet`)})(),R0=T0=>(()=>{if(Et.storage===Et.value)return`${a}[${T0}]`;if(Et.storage==="vec2<u32>"&&Et.value==="i32")return`i32(${a}[${T0}].x)`;if(Et.storage==="vec2<u32>"&&Et.value==="u32")return`u32(${a}[${T0}].x)`;if(Et.storage==="u32"&&Et.value==="vec4<bool>")return`vec4<bool>(bool(${a}[${T0}] & 0xFFu), bool(${a}[${T0}] & 0xFF00u), bool(${a}[${T0}] & 0xFF0000u), bool(${a}[${T0}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${Et.storage} and value type ${Et.value} yet`)})(),Y0=h<2?"":`
  fn get_${a}ByIndices(indices: ${Et.indices}) -> ${j} {
    return ${R0(`i2o_${a}(indices)`)};
  }`,H0=h<2?"":(()=>{let T0=_.map(vy=>`d${vy}: u32`).join(", "),q0=_.map(vy=>`d${vy}`).join(", ");return`
  fn get_${a}(${T0}) -> ${j} {
    return get_${a}ByIndices(${l0(q0)});
  }`})(),ty=(...T0)=>{if(T0.length!==h)throw new Error(`indices length must be ${h}`);let q0=T0.map(It).join(",");return h===0?R0("0u"):h===1?R0(q0[0]):(zt.get=!0,zt.getByIndices=!0,zt.indicesToOffset=!0,`get_${a}(${q0})`)},w0=T0=>h<2?R0(T0):(zt.getByIndices=!0,zt.indicesToOffset=!0,`get_${a}ByIndices(${T0})`),L0=h<2?"":`
  fn set_${a}ByIndices(indices: ${Et.indices}, value: ${j}) {
    ${Z0(`i2o_${a}(indices)`,"value")}
  }`,k0=h<2?"":(()=>{let T0=_.map(vy=>`d${vy}: u32`).join(", "),q0=_.map(vy=>`d${vy}`).join(", ");return`
  fn set_${a}(${T0}, value: ${j}) {
    set_${a}ByIndices(${l0(q0)}, value);
  }`})();return{impl:()=>{let T0=[],q0=!1;return zt.offsetToIndices&&(T0.push(fr),q0=!0),zt.indicesToOffset&&(T0.push(t0),q0=!0),zt.broadcastedIndicesToOffset&&(Object.values(f0).forEach(vy=>T0.push(vy)),q0=!0),zt.set&&(T0.push(k0),q0=!0),zt.setByIndices&&(T0.push(L0),q0=!0),zt.get&&(T0.push(H0),q0=!0),zt.getByIndices&&(T0.push(Y0),q0=!0),!c&&q0&&T0.unshift(`const ${Hn} = ${Et.indices}(${o.join(",")});`,`const ${Qt} = ${Et.indices}(${M.computeStrides(o).join(",")});`),T0.join(`
`)},type:Et,offsetToIndices:jr,indicesToOffset:o0,broadcastedIndicesToOffset:C0,indices:l0,indicesGet:g0,indicesSet:i0,set:(...T0)=>{if(T0.length!==h+1)throw new Error(`indices length must be ${h}`);let q0=T0[h];if(typeof q0!="string")throw new Error("value must be string");let vy=T0.slice(0,h).map(It).join(",");return h===0?Z0("0u",q0):h===1?Z0(vy[0],q0):(zt.set=!0,zt.setByIndices=!0,zt.indicesToOffset=!0,`set_${a}(${vy}, ${q0})`)},setByOffset:Z0,setByIndices:(T0,q0)=>h<2?Z0(T0,q0):(zt.setByIndices=!0,zt.indicesToOffset=!0,`set_${a}ByIndices(${T0}, ${q0});`),get:ty,getByOffset:R0,getByIndices:w0,usage:s,name:a,strides:Qt,shape:Hn,rank:h}},D=(a,e,o,s=1)=>fa(a,e,o,"input",s),q=(a,e,o,s=1)=>fa(a,e,o,"output",s),hn=(a,e,o,s=1)=>fa(a,e,o,"internal",s),ca=class{constructor(a){this.normalizedDispatchGroup=a,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(a){return`if (global_idx >= ${typeof a=="number"?`${a}u`:a}) { return; }`}mainStart(a=mn){let e=typeof a=="number"?a:a[0],o=typeof a=="number"?1:a[1],s=typeof a=="number"?1:a[2],d=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,c=d?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,h=d?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${e*o*s}u + local_idx;`;return`@compute @workgroup_size(${e}, ${o}, ${s})
  fn main(${c}) {
    ${h}
  `}appendVariableUniforms(a){a.rank!==0&&(a.shape.startsWith("uniforms.")&&this.uniforms.push({name:a.shape.replace("uniforms.",""),type:"u32",length:a.rank}),a.strides.startsWith("uniforms.")&&this.uniforms.push({name:a.strides.replace("uniforms.",""),type:"u32",length:a.rank}))}declareVariable(a,e){if(a.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(a),this.appendVariableUniforms(a);let o=a.usage==="input"?"read":"read_write",s=a.type.storage;return`@group(0) @binding(${e}) var<storage, ${o}> ${a.name}: array<${s}>;`}declareVariables(...a){return a.map(e=>this.declareVariable(e,this.variableIndex++)).join(`
`)}registerInternalVariable(a){if(a.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(a),this.appendVariableUniforms(a)}registerInternalVariables(...a){return a.forEach(e=>this.registerInternalVariable(e)),this}registerUniform(a,e,o=1){return this.uniforms.push({name:a,type:e,length:o}),this}registerUniforms(a){return this.uniforms=this.uniforms.concat(a),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let a=[];for(let{name:e,type:o,length:s}of this.uniforms)if(s&&s>4)o==="f16"?a.push(`@align(16) ${e}:array<mat2x4<${o}>, ${Math.ceil(s/8)}>`):a.push(`${e}:array<vec4<${o}>, ${Math.ceil(s/4)}>`);else{let d=s==null||s===1?o:`vec${s}<${o}>`;a.push(`${e}:${d}`)}return`
      struct Uniforms { ${a.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(a=>a.impl()).join(`
`)+this.internalVariables.map(a=>a.impl()).join(`
`)}},uo=a=>new ca(a),ar=(a,e)=>{let o=a.length,s=[];for(let d=0;d<o;d++){let c=o-1-d,h=a[c]||1;(e[e.length-1-d]||1)>1&&h===1&&s.unshift(c)}return s}}),zd,lo,Bd,Dd,dt,co,po,ir=F(()=>{ie(),_e(),Ye(),be(),zd=a=>{if(!a||a.length!==1)throw new Error("Transpose requires 1 input.")},lo=(a,e)=>e&&e.length!==a?[...new Array(a).keys()].reverse():e,Bd=(a,e)=>M.sortBasedOnPerm(a,lo(a.length,e)),Dd=(a,e,o,s)=>{let d=[];d.push(`fn perm(i: ${s.type.indices}) -> ${o.type.indices} {
    var a: ${o.type.indices};`);for(let c=0;c<e;++c)d.push(o.indicesSet("a",a[c],`i[${c}]`));return d.push("return a;}"),d.join(`
`)},dt=(a,e)=>{let o=a.dataType,s=a.dims.length,d=lo(s,e),c=Bd(a.dims,d),h=q("output",o,c.length),_=D("a",o,s),bt=g=>`
  ${g.registerUniform("output_size","u32").declareVariables(_,h)}

  ${Dd(d,s,_,h)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${h.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${h.setByOffset("global_idx",_.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:["rank"]},getRunData:g=>{let j=M.size(c);return{outputs:[{dims:c,dataType:g[0].dataType}],dispatchGroup:{x:Math.ceil(j/64)},programUniforms:[{type:12,data:j},...K(g[0].dims,c)]}},getShaderSource:bt}},co=(a,e)=>{zd(a.inputs),a.compute(dt(a.inputs[0],e.perm))},po=a=>$e({perm:a.perm})}),Md,Ud,Nd,Wd,Vd,Gd,Hd,Ld,Fd,qd,$t,fo,mo,ho,go,yo,bo,wo,vo,$o,_o,xo=F(()=>{ie(),_e(),be(),gn(),ir(),Md={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Ud={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Nd={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Wd={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Vd=(a,e)=>{let o=[];for(let s=e-a;s<e;++s)o.push(s);return o},Gd=(a,e)=>{let o=[],s=a.length;for(let c=0;c<s;c++)e.indexOf(c)===-1&&o.push(a[c]);let d=e.map(c=>a[c]);return[o,d]},Hd=(a,e)=>{let o=a.length+e.length,s=[],d=0;for(let c=0;c<o;c++)e.indexOf(c)===-1?s.push(a[d++]):s.push(1);return s},Ld=(a,e)=>{for(let o=0;o<a.length;++o)if(a[a.length-o-1]!==e-1-o)return!1;return!0},Fd=(a,e)=>{let o=[];if(!Ld(a,e)){for(let s=0;s<e;++s)a.indexOf(s)===-1&&o.push(s);a.forEach(s=>o.push(s))}return o},qd=(a,e,o,s,d,c,h)=>{let _=o[0].dims,bt=M.size(c),g=M.size(h),j=D("_A",o[0].dataType,_),b=q("output",d,c),Et=32,It=`
          var<workgroup> aBestValues : array<f32, ${Et}>;
       `;return{name:a,shaderCache:e,getShaderSource:zt=>`
        ${zt.registerUniform("reduceSize","u32").declareVariables(j,b)}
        ${It}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${zt.mainStart(Et)}

          let outputIndex = global_idx / ${Et};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${Nd[s]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${Et}) {
           let candidate = f32(${j.getByOffset("offset + k")});
           bestValue = ${Md[s]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${Et}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${Ud[s]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${b.setByOffset("outputIndex",`${s==="mean"?`${b.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${b.type.storage}(${Wd[s]})`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:c,dataType:d}],dispatchGroup:{x:bt},programUniforms:[{type:12,data:g}]})}},$t=(a,e,o,s)=>{let d=a.inputs.length===1?o:ma(a.inputs,o),c=d.axes;c.length===0&&!d.noopWithEmptyAxes&&(c=a.inputs[0].dims.map((It,zt)=>zt));let h=M.normalizeAxes(c,a.inputs[0].dims.length),_=h,bt=a.inputs[0],g=Fd(_,a.inputs[0].dims.length);g.length>0&&(bt=a.compute(dt(a.inputs[0],g),{inputs:[0],outputs:[-1]})[0],_=Vd(_.length,bt.dims.length));let[j,b]=Gd(bt.dims,_),Et=j;d.keepDims&&(Et=Hd(j,h)),a.compute(qd(e,{hint:d.cacheKey,inputDependencies:["type"]},[bt],s,a.inputs[0].dataType,Et,b),{inputs:[bt]})},fo=(a,e)=>{$t(a,"ReduceMeanShared",e,"mean")},mo=(a,e)=>{$t(a,"ReduceL1Shared",e,"l1")},ho=(a,e)=>{$t(a,"ReduceL2Shared",e,"l2")},go=(a,e)=>{$t(a,"ReduceLogSumExpShared",e,"logSumExp")},yo=(a,e)=>{$t(a,"ReduceMaxShared",e,"max")},bo=(a,e)=>{$t(a,"ReduceMinShared",e,"min")},wo=(a,e)=>{$t(a,"ReduceProdShared",e,"prod")},vo=(a,e)=>{$t(a,"ReduceSumShared",e,"sum")},$o=(a,e)=>{$t(a,"ReduceSumSquareShared",e,"sumSquare")},_o=(a,e)=>{$t(a,"ReduceLogSumShared",e,"logSum")}}),_t,jd,yn,ma,xt,Kd,Yd,Zd,Xd,Qd,Jd,ec,tc,rc,nc,St,So,Co,Io,Eo,Ao,To,Oo,ko,Po,Ro,gn=F(()=>{ie(),_e(),Ye(),be(),xo(),_t=a=>{if(!a||a.length===0||a.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(a.length===2&&a[1].dims.length!==1)throw new Error("Invalid axes input dims.")},jd=a=>["","",`var value = ${a.getByIndices("input_indices")};`,""],yn=(a,e,o,s,d,c,h=!1,_=!1)=>{let bt=[],g=o[0].dims,j=g.length,b=M.normalizeAxes(d,j),Et=!_&&b.length===0;g.forEach((er,Hn)=>{Et||b.indexOf(Hn)>=0?h&&bt.push(1):bt.push(er)});let It=bt.length,zt=M.size(bt);return{name:a,shaderCache:e,getShaderSource:er=>{let Hn=[],Qt=D("_A",o[0].dataType,j),cr=q("output",c,It),fr=s(Qt,cr,b),jr=fr[2];for(let e0=0,t0=0;e0<j;e0++)Et||b.indexOf(e0)>=0?(h&&t0++,jr=`for(var j${e0}: u32 = 0; j${e0} < ${g[e0]}; j${e0}++) {
                  ${fr[2].includes("last_index")?`let last_index = j${e0};`:""}
                  ${Qt.indicesSet("input_indices",e0,`j${e0}`)}
                  ${jr}
                }`):(Hn.push(`${Qt.indicesSet("input_indices",e0,cr.indicesGet("output_indices",t0))};`),t0++);return`

        ${er.registerUniform("output_size","u32").declareVariables(Qt,cr)}

        ${er.mainStart()}
          ${er.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${Qt.type.indices};
          let output_indices = ${cr.offsetToIndices("global_idx")};

          ${Hn.join(`
`)}
          ${fr[0]}       // init ops for reduce max/min
          ${fr[1]}
          ${jr}
          ${fr[3]}
          ${fr.length===4?cr.setByOffset("global_idx","value"):fr.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:bt,dataType:c}],dispatchGroup:{x:Math.ceil(zt/64)},programUniforms:[{type:12,data:zt},...K(g,bt)]})}},ma=(a,e)=>{let o=[];return a[1].dims[0]>0&&a[1].getBigInt64Array().forEach(s=>o.push(Number(s))),$e({axes:o,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},xt=(a,e,o,s)=>{let d=a.inputs,c=d.length===1?o:ma(d,o);a.compute(yn(e,{hint:c.cacheKey,inputDependencies:["rank"]},[d[0]],c.noopWithEmptyAxes&&c.axes.length===0?jd:s,c.axes,d[0].dataType,c.keepDims,c.noopWithEmptyAxes),{inputs:[0]})},Kd=(a,e)=>{_t(a.inputs),xt(a,"ReduceLogSum",e,(o,s)=>[`var value = ${s.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,"value = log(value);"])},Yd=(a,e)=>{_t(a.inputs),xt(a,"ReduceL1",e,(o,s)=>[`var value = ${s.type.storage}(0);`,"",`value += abs(${o.getByIndices("input_indices")});`,""])},Zd=(a,e)=>{_t(a.inputs),xt(a,"ReduceL2",e,(o,s)=>[`var t = ${s.type.value}(0); var value = ${s.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Xd=(a,e)=>{_t(a.inputs),xt(a,"ReduceLogSumExp",e,(o,s)=>[`var value = ${s.type.storage}(0);`,"",`value += exp(${o.getByIndices("input_indices")});`,"value = log(value);"])},Qd=(a,e)=>{_t(a.inputs),xt(a,"ReduceMax",e,(o,s,d)=>{let c=[];for(let h=0;h<o.rank;h++)(d.indexOf(h)>=0||d.length===0)&&c.push(o.indicesSet("input_indices",h,0));return[`${c.join(`
`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = max(value, ${o.getByIndices("input_indices")});`,""]})},Jd=(a,e)=>{_t(a.inputs),xt(a,"ReduceMean",e,(o,s,d)=>{let c=1;for(let h=0;h<o.rank;h++)(d.indexOf(h)>=0||d.length===0)&&(c*=a.inputs[0].dims[h]);return["var sum = f32(0);","",`sum += f32(${o.getByIndices("input_indices")});`,`let value = ${s.type.value}(sum / ${c});`]})},ec=(a,e)=>{_t(a.inputs),xt(a,"ReduceMin",e,(o,s,d)=>{let c=[];for(let h=0;h<o.rank;h++)(d.indexOf(h)>=0||d.length===0)&&c.push(`input_indices[${h}] = 0;`);return[`${c.join(`
`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = min(value, ${o.getByIndices("input_indices")});`,""]})},tc=(a,e)=>{_t(a.inputs),xt(a,"ReduceProd",e,(o,s)=>[`var value = ${s.type.storage}(1);`,"",`value *= ${o.getByIndices("input_indices")};`,""])},rc=(a,e)=>{_t(a.inputs),xt(a,"ReduceSum",e,(o,s)=>[`var value = ${s.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,""])},nc=(a,e)=>{_t(a.inputs),xt(a,"ReduceSumSquare",e,(o,s)=>[`var t = ${s.type.value}(0); var value = ${s.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += t * t;`,""])},St=(a,e,o)=>{if(e.length===0)return o;let s=1,d=1;for(let c=0;c<e.length;c++)e.indexOf(c)===-1?s*=a[c]:d*=a[c];return d<32&&s>1024},So=(a,e)=>{St(a.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Jd(a,e):fo(a,e)},Co=(a,e)=>{St(a.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Yd(a,e):mo(a,e)},Io=(a,e)=>{St(a.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Zd(a,e):ho(a,e)},Eo=(a,e)=>{St(a.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Xd(a,e):go(a,e)},Ao=(a,e)=>{St(a.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Qd(a,e):yo(a,e)},To=(a,e)=>{St(a.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?ec(a,e):bo(a,e)},Oo=(a,e)=>{St(a.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?tc(a,e):wo(a,e)},ko=(a,e)=>{St(a.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?rc(a,e):vo(a,e)},Po=(a,e)=>{St(a.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?nc(a,e):$o(a,e)},Ro=(a,e)=>{St(a.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Kd(a,e):_o(a,e)}}),zo,Bo,Do,ha,Mo=F(()=>{ie(),Ye(),gn(),zo=a=>{if(!a||a.length===0||a.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(a[0].dataType!==1)throw new Error("Invalid input type.")},Bo=(a,e)=>{zo(a.inputs);let o=(s,d,c)=>{let h=[];for(let _=0;_<s.rank;_++)(c.indexOf(_)>=0||c.length===0)&&h.push(`input_indices[${_}] = 0;`);return[`${h.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${s.getByIndices("input_indices")} ${e.selectLastIndex>0?"<=":"<"} value) {
         value = ${s.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",d.setByOffset("global_idx","best_index")]};a.compute(yn("ArgMin",{hint:e.cacheKey,inputDependencies:["rank"]},[a.inputs[0]],o,[e.axis],7,e.keepDims),{inputs:[0]})},Do=(a,e)=>{zo(a.inputs);let o=(s,d,c)=>{let h=[];for(let _=0;_<s.rank;_++)(c.indexOf(_)>=0||c.length===0)&&h.push(`input_indices[${_}] = 0;`);return[`${h.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${s.getByIndices("input_indices")} ${e.selectLastIndex>0?">=":">"} value) {
         value = ${s.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",d.setByOffset("global_idx","best_index")]};a.compute(yn("argMax",{hint:e.cacheKey,inputDependencies:["rank"]},[a.inputs[0]],o,[e.axis],7,e.keepDims),{inputs:[0]})},ha=a=>$e(a)}),ac,ic,oc,sc,bn,uc,Uo,ga=F(()=>{ie(),ln(),be(),ac=(a,e)=>{let o=a[0],s=a[1],d=a[2],c=a[3],h=a[4],_=a[5];if(h&&_)throw new Error("Attention cannot have both past and relative_position_bias");if(o.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let bt=o.dims[0],g=o.dims[1],j=o.dims[2];if(d.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(s.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(s.dims[0]!==j)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(d.dims[0]!==s.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let b=d.dims[0]/3,Et=b,It=Et;if(e.qkvHiddenSizes.length>0){if(e.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let fr of e.qkvHiddenSizes)if(fr%e.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");b=e.qkvHiddenSizes[0],Et=e.qkvHiddenSizes[1],It=e.qkvHiddenSizes[2]}let zt=g;if(b!==Et)throw new Error("qkv_hidden_sizes first element should be same as the second");if(d.dims[0]!==b+Et+It)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let er=0;if(h){if(Et!==It)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(h.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(h.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(h.dims[1]!==bt)throw new Error('Input "past" second dimension must be batch_size');if(h.dims[2]!==e.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(h.dims[4]!==Et/e.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');e.pastPresentShareBuffer||(er=h.dims[3])}let Hn=zt+er,Qt=-1,cr=0;if(c)throw new Error("Mask not supported");if(h)throw new Error("past is not supported");if(_)throw new Error("relativePositionBias is not supported");return{batchSize:bt,sequenceLength:g,pastSequenceLength:er,kvSequenceLength:zt,totalSequenceLength:Hn,maxSequenceLength:Qt,inputHiddenSize:j,hiddenSize:b,vHiddenSize:It,headSize:Math.floor(b/e.numHeads),vHeadSize:Math.floor(It/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:cr,scale:e.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},ic=(a,e,o,s)=>{let d=Me(s),c=64,h=s/d;h<c?c=1:h/8<64&&(c=Math.ceil(h/8));let _=Math.ceil(s/d/c),bt=[{type:e.dataType,data:1/s},{type:12,data:h},{type:12,data:_}],g=ke(e.dataType,d),j=b=>{let Et=q("x",e.dataType,e.dims,d),It="thread_max_vector";d===2?It="max(thread_max_vector.x, thread_max_vector.y)":d===4&&(It="max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))");let zt=at(e.dataType),er=[{name:"d_inv",type:zt},{name:"d_comp",type:"u32"},{name:"elements_per_wg",type:"u32"}];return`
  var<workgroup> wgMax: array<f32, ${c}>;
  var<workgroup> wgSum: array<f32, ${c}>;
  ${b.registerUniforms(er).declareVariables(Et)}
  ${b.mainStart([c,1,1])}
    let localOffset = local_idx * uniforms.elements_per_wg;
    let offset: u32 = workgroup_id.x * uniforms.d_comp + localOffset;

    var thread_max_vector = ${Xe("f32",d,"-3.402823e+38f")};
    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {
      thread_max_vector = max(${mt(zt,d,"x[offset + i]")}, thread_max_vector);
    }
    wgMax[local_idx] = ${It};
    workgroupBarrier();

    var maxValue = -3.402823e+38f;
    for (var i = 0u; i < ${c}; i++) {
      maxValue = max(wgMax[i], maxValue);
    }

    var sumVector = ${Xe("f32",d,"0")};
    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {
      sumVector += exp(${mt(zt,d,"x[offset + i]")} - maxValue);
    }
    wgSum[local_idx] = ${it("sumVector",d)};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${c}; i++) {
      sum += wgSum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {
        x[offset + i] = ${Xe(zt,d,"uniforms.d_inv")};
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {
        let f32input = ${mt(zt,d,"x[offset + i]")};
        x[offset + i] = ${Et.type.value}(exp(f32input - maxValue) / sum);
      }
    }
  }`};a.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${c};${g};${d}`},getShaderSource:j,getRunData:()=>({outputs:[],dispatchGroup:{x:o},programUniforms:bt})},{inputs:[e],outputs:[]})},oc=(a,e,o,s,d,c)=>{let h=[d.batchSize,d.numHeads,d.sequenceLength,d.kvSequenceLength+d.pastSequenceLength],_=c.scale===0?1/Math.sqrt(d.headSize):c.scale,bt=Me(d.headSize),g=d.headSize/bt,j=12,b={x:Math.ceil(d.totalSequenceLength/j),y:Math.ceil(d.sequenceLength/j),z:d.batchSize*d.numHeads},Et=[{type:12,data:d.sequenceLength},{type:12,data:g},{type:12,data:d.totalSequenceLength},{type:12,data:d.kvSequenceLength},{type:e.dataType,data:_}],It=[e,o],zt=Hn=>{let Qt=D("q",e.dataType,e.dims,bt),cr=D("key",o.dataType,o.dims,bt),fr=q("output",e.dataType,h),jr=ke(e.dataType),e0=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"alpha",type:jr}];return`
  const beta: ${jr} = 1.0;
  const TILE_SIZE = ${j}u;

  var<workgroup> tileQ: array<${Qt.type.storage}, ${j*j}>;
  var<workgroup> tileK: array<${Qt.type.storage}, ${j*j}>;
  ${Hn.registerUniforms(e0).declareVariables(Qt,cr,fr)}
  ${Hn.mainStart([j,j,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let lm = m + local_id.y;
    let ln = n + local_id.x;

    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;
    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx + n * uniforms.K;

    var value = ${Xe(jr,bt)};
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m + local_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * uniforms.M * uniforms.N;
    if (lm < uniforms.M && ln < uniforms.N) {
      let outputIdx = headOffset + lm * uniforms.N + ln;
      output[outputIdx] = ${it("value",bt)} * uniforms.alpha;
    }
  }`},er=a.compute({name:"AttentionProbs",shaderCache:{hint:`${bt}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:h,dataType:e.dataType,gpuDataType:0}],dispatchGroup:b,programUniforms:Et}),getShaderSource:zt},{inputs:It,outputs:[-1]})[0];return ic(a,er,d.batchSize*d.numHeads*d.sequenceLength,d.totalSequenceLength),er},sc=(a,e,o,s)=>{let d=[s.batchSize,s.sequenceLength,s.vHiddenSize],c=12,h={x:Math.ceil(s.vHeadSize/c),y:Math.ceil(s.sequenceLength/c),z:s.batchSize*s.numHeads},_=[{type:12,data:s.sequenceLength},{type:12,data:s.totalSequenceLength},{type:12,data:s.vHeadSize},{type:12,data:s.numHeads},{type:12,data:s.vHiddenSize}],bt=g=>{let j=D("probs",e.dataType,e.dims),b=D("v",o.dataType,o.dims),Et=q("output",e.dataType,d),It=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"}];return`
  const TILE_SIZE = ${c}u;
  var<workgroup> tileQ: array<${j.type.value}, ${c*c}>;
  var<workgroup> tileK: array<${j.type.value}, ${c*c}>;
  ${g.registerUniforms(It).declareVariables(j,b,Et)}
  ${g.mainStart([c,c,1])}
   let headIdx = workgroup_id.z;
   let m = workgroup_id.y * TILE_SIZE + local_id.y;
   let n = workgroup_id.x * TILE_SIZE + local_id.x;

   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;
   let offsetB = headIdx * (uniforms.N * uniforms.K) + n;

   var value = ${j.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
     if (m < uniforms.M && w + local_id.x < uniforms.K) {
       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
     }
     if (n < uniforms.N && w + local_id.y < uniforms.K) {
       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * uniforms.N];
     }
     workgroupBarrier();
     for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;
   let headOffset = (batchIdx * uniforms.M * uniforms.num_heads + currentBatchHeadNumber) * uniforms.N;
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M *uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + currentBatchHeadNumber * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return a.compute({name:"AttentionScore",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:d,dataType:e.dataType,gpuDataType:0}],dispatchGroup:h,programUniforms:_}),getShaderSource:bt},{inputs:[e,o],outputs:[0]})[0]},bn=(a,e,o,s,d,c,h,_,bt,g,j)=>{let b=oc(a,e,o,bt,g,j);sc(a,b,s,g)},uc=(a,e)=>{let o=[e.batchSize,e.numHeads,e.sequenceLength,e.headSize],s=e.sequenceLength,d=e.inputHiddenSize,c=e.headSize,h=12,_={x:Math.ceil(e.headSize/h),y:Math.ceil(e.sequenceLength/h),z:e.batchSize*e.numHeads},bt=[a.inputs[0],a.inputs[1],a.inputs[2]],g=[{type:12,data:s},{type:12,data:d},{type:12,data:c},{type:12,data:e.numHeads},{type:12,data:e.headSize},{type:12,data:e.hiddenSize},{type:12,data:e.hiddenSize+e.hiddenSize+e.vHiddenSize}],j=b=>{let Et=q("output_q",bt[0].dataType,o),It=q("output_k",bt[0].dataType,o),zt=q("output_v",bt[0].dataType,o),er=D("input",bt[0].dataType,bt[0].dims),Hn=D("weight",bt[1].dataType,bt[1].dims),Qt=D("bias",bt[2].dataType,bt[2].dims),cr=er.type.storage,fr=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${h}u;
  var<workgroup> tileInput: array<${cr}, ${h*h}>;
  var<workgroup> tileWeightQ: array<${cr}, ${h*h}>;
  var<workgroup> tileWeightK: array<${cr}, ${h*h}>;
  var<workgroup> tileWeightV: array<${cr}, ${h*h}>;
  ${b.registerUniforms(fr).declareVariables(er,Hn,Qt,Et,It,zt)}
  ${b.mainStart([h,h,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE + local_id.y;
    let n = workgroup_id.x * TILE_SIZE + local_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${cr}(0);
    var valueK = ${cr}(0);
    var valueV = ${cr}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return a.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:o,dataType:a.inputs[0].dataType,gpuDataType:0},{dims:o,dataType:a.inputs[0].dataType,gpuDataType:0},{dims:o,dataType:a.inputs[0].dataType,gpuDataType:0}],dispatchGroup:_,programUniforms:g}),getShaderSource:j},{inputs:bt,outputs:[-1,-1,-1]})},Uo=(a,e)=>{let o=ac(a.inputs,e),[s,d,c]=uc(a,o);return bn(a,s,d,c,a.inputs[4],void 0,void 0,void 0,a.inputs[5],o,e)}}),lc,dc,cc,No,Wo=F(()=>{lt(),ie(),_e(),Ye(),be(),lc=(a,e)=>{if(!a||a.length!==5)throw new Error("BatchNormalization requires 5 inputs");let o=(s,d,c)=>{let h=d.length;if(h!==s.length)throw new Error(`${c}: num dimensions != ${h}`);d.forEach((_,bt)=>{if(_!==s[bt])throw new Error(`${c}: dim[${bt}] do not match`)})};if(a[0].dims.length>1){let s=e.format==="NHWC"?e.spatial?a[0].dims.slice(-1):a[0].dims.slice(-1).concat(a[0].dims.slice(1,a[0].dims.length-1)):a[0].dims.slice(1,e.spatial?2:void 0);o(a[1].dims,s,"Invalid input scale"),o(a[2].dims,s,"Invalid input B"),o(a[3].dims,s,"Invalid input mean"),o(a[4].dims,s,"Invalid input var")}else o(a[1].dims,[1],"Invalid input scale"),o(a[2].dims,[1],"Invalid input B"),o(a[3].dims,[1],"Invalid input mean"),o(a[4].dims,[1],"Invalid input var")},dc=(a,e)=>{let{epsilon:o,spatial:s,format:d}=e,c=a[0].dims,h=s?Me(c[c.length-1]):1,_=d==="NHWC"&&c.length>1?h:1,bt=M.size(c)/h,g=s,j=g?c.length:c,b=D("x",a[0].dataType,a[0].dims,h),Et=D("scale",a[1].dataType,a[1].dims,_),It=D("bias",a[2].dataType,a[2].dims,_),zt=D("inputMean",a[3].dataType,a[3].dims,_),er=D("inputVar",a[4].dataType,a[4].dims,_),Hn=q("y",a[0].dataType,j,h),Qt=()=>{let fr="";if(s)fr=`let cOffset = ${c.length===1?"0u":d==="NHWC"?`outputIndices[${c.length-1}] / ${h}`:"outputIndices[1]"};`;else if(d==="NCHW")fr=`
            ${Hn.indicesSet("outputIndices","0","0")}
            let cOffset = ${Hn.indicesToOffset("outputIndices")};`;else{fr=`var cIndices = ${Et.type.indices}(0);
                       cIndices[0] = outputIndices[${c.length-1}];`;for(let jr=1;jr<Et.rank;jr++)fr+=`cIndices[${jr}] = outputIndices[${jr}];`;fr+=`let cOffset = ${Et.indicesToOffset("cIndices")};`}return fr},cr=fr=>`
  const epsilon = ${o};
  ${fr.registerUniform("outputSize","u32").declareVariables(b,Et,It,zt,er,Hn)}
  ${fr.mainStart()}
  ${fr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${Hn.offsetToIndices(`global_idx * ${h}`)};
    ${Qt()}
    let scale = ${Et.getByOffset("cOffset")};
    let bias = ${It.getByOffset("cOffset")};
    let inputMean = ${zt.getByOffset("cOffset")};
    let inputVar = ${er.getByOffset("cOffset")};
    let x = ${b.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${Hn.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${e.epsilon}_${e.format}_${s}_${h}`,inputDependencies:g?["rank","type","type","type","type"]:void 0},getShaderSource:cr,getRunData:()=>({outputs:[{dims:a[0].dims,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(bt/64)},programUniforms:g?[{type:12,data:bt},...K(c)]:[{type:12,data:bt}]})}},cc=a=>$e(a),No=(a,e)=>{let{inputs:o,outputCount:s}=a,d=cc({...e,outputCount:s});if(Ae.webgpu.validateInputContent&&lc(o,d),e.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");a.compute(dc(o,d))}}),pc,fc,Vo,Go=F(()=>{_e(),be(),pc=a=>{if(a[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(a[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(a[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(a[0].dims[2]!==a[1].dims[0])throw new Error("last dimension of input and bias are not the same")},fc=a=>{let e=a[0].dims,o=a[0].dims[2],s=M.size(e)/4,d=a[0].dataType,c=D("input",d,e,4),h=D("bias",d,[o],4),_=D("residual",d,e,4),bt=q("output",d,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:g=>`
  const channels = ${o}u / 4;
  ${g.declareVariables(c,h,_,bt)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let value = ${c.getByOffset("global_idx")}
      + ${h.getByOffset("global_idx % channels")} + ${_.getByOffset("global_idx")};
    ${bt.setByOffset("global_idx","value")}
  }`}},Vo=a=>{pc(a.inputs),a.compute(fc(a.inputs))}}),mc,Oe,Ho,Lo,Fo,qo,jo,Ko,Yo,Zo,Xo,hc,Qo,Jo,es,ts,wn,rs,vn,ns,as,is,os,ss,us,ls,ds,cs,ps,fs,ms,hs,gs,ys,bs,ws,vs,ya,ba,$s,_s,xs,$n=F(()=>{ie(),_e(),Ye(),be(),mc=(a,e,o,s,d,c)=>{let h=Math.ceil(e/4),_="";typeof d=="string"?_=`${d}(a)`:_=d("a");let bt=D("inputData",o,[h],4),g=q("outputData",s,[h],4);return`
      ${a.registerUniform("vec_size","u32").declareVariables(bt,g)}

  ${c??""}

  ${a.mainStart()}
    ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${bt.getByOffset("global_idx")};
    ${g.setByOffset("global_idx",_)}
  }`},Oe=(a,e,o,s,d,c=a.dataType)=>({name:e,shaderCache:{hint:d,inputDependencies:["type"]},getShaderSource:h=>mc(h,M.size(a.dims),a.dataType,c,o,s),getRunData:h=>({outputs:[{dims:a.dims,dataType:c}],dispatchGroup:{x:Math.ceil(M.size(h[0].dims)/64/4)},programUniforms:[{type:12,data:Math.ceil(M.size(a.dims)/4)}]})}),Ho=a=>{a.compute(Oe(a.inputs[0],"Abs","abs"))},Lo=a=>{a.compute(Oe(a.inputs[0],"Acos","acos"))},Fo=a=>{a.compute(Oe(a.inputs[0],"Acosh","acosh"))},qo=a=>{a.compute(Oe(a.inputs[0],"Asin","asin"))},jo=a=>{a.compute(Oe(a.inputs[0],"Asinh","asinh"))},Ko=a=>{a.compute(Oe(a.inputs[0],"Atan","atan"))},Yo=a=>{a.compute(Oe(a.inputs[0],"Atanh","atanh"))},Zo=a=>$e(a),Xo=(a,e)=>{let o;switch(e.to){case 10:o="vec4<f16>";break;case 1:o="vec4<f32>";break;case 12:o="vec4<u32>";break;case 6:o="vec4<i32>";break;case 9:o="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}a.compute(Oe(a.inputs[0],"Cast",o,void 0,e.cacheKey,e.to))},hc=a=>{let e=a.length>=2&&a[1].data!==0?a[1].getFloat32Array()[0]:pn,o=a.length>=3&&a[2].data!==0?a[2].getFloat32Array()[0]:fn;return $e({min:e,max:o})},Qo=(a,e)=>{let o=a.inputs.length===1?e:hc(a.inputs),s=at(a.inputs[0].dataType);a.compute(Oe(a.inputs[0],"Clip",d=>`clamp(${d}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${s}> = vec4(${s}(${o.min}));
    const clip_max_: vec4<${s}> = vec4(${s}(${o.max}));
`,o.cacheKey),{inputs:[0]})},Jo=a=>{a.compute(Oe(a.inputs[0],"Ceil","ceil"))},es=a=>{a.compute(Oe(a.inputs[0],"Cos","cos"))},ts=a=>{a.compute(Oe(a.inputs[0],"Cosh","cosh"))},wn=a=>$e(a),rs=(a,e)=>{let o=at(a.inputs[0].dataType);a.compute(Oe(a.inputs[0],"Elu",s=>`elu_vf32(${s})`,`
  const elu_alpha_ = ${o}(${e.alpha});

  fn elu_f32(a: ${o}) -> ${o} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${o}>) -> vec4<${o}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,e.cacheKey))},vn=(a="f32")=>`
const r0: ${a} = 0.3275911;
const r1: ${a} = 0.254829592;
const r2: ${a} = -0.284496736;
const r3: ${a} = 1.421413741;
const r4: ${a} = -1.453152027;
const r5: ${a} = 1.061405429;

fn erf_vf32(v: vec4<${a}>) -> vec4<${a}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,ns=a=>{let e=at(a.inputs[0].dataType);a.compute(Oe(a.inputs[0],"Erf",o=>`erf_vf32(${o})`,vn(e)))},as=a=>{a.compute(Oe(a.inputs[0],"Exp","exp"))},is=a=>{a.compute(Oe(a.inputs[0],"Floor","floor"))},os=a=>{let e=at(a.inputs[0].dataType);a.compute(Oe(a.inputs[0],"Gelu",o=>`0.5 * ${o} * (1.0 + erf_vf32(${o} * 0.7071067811865475))`,vn(e)))},ss=(a,e)=>{let o=at(a.inputs[0].dataType);a.compute(Oe(a.inputs[0],"LeakyRelu",s=>`select(leaky_relu_alpha_ * ${s}, ${s}, ${s} >= vec4<${o}>(0.0))`,`const leaky_relu_alpha_ = ${o}(${e.alpha});`,e.cacheKey))},us=a=>{a.compute(Oe(a.inputs[0],"Not",e=>`!${e}`))},ls=a=>{a.compute(Oe(a.inputs[0],"Neg",e=>`-${e}`))},ds=a=>{a.compute(Oe(a.inputs[0],"Reciprocal",e=>`1.0/${e}`))},cs=a=>{let e=at(a.inputs[0].dataType);a.compute(Oe(a.inputs[0],"Relu",o=>`select(vec4<${e}>(0.0), ${o}, ${o} > vec4<${e}>(0.0))`))},ps=a=>{a.compute(Oe(a.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},fs=a=>$e(a),ms=(a,e)=>{let o=at(a.inputs[0].dataType);a.compute(Oe(a.inputs[0],"HardSigmoid",s=>`max(vec4<${o}>(0.0), min(vec4<${o}>(1.0), ${e.alpha} * ${s} + vec4<${o}>(${e.beta})))`,void 0,e.cacheKey))},hs=a=>{a.compute(Oe(a.inputs[0],"Sin","sin"))},gs=a=>{a.compute(Oe(a.inputs[0],"Sinh","sinh"))},ys=a=>{a.compute(Oe(a.inputs[0],"Sqrt","sqrt"))},bs=a=>{a.compute(Oe(a.inputs[0],"Tan","tan"))},ws=a=>`sign(${a}) * (1 - exp(-2 * abs(${a}))) / (1 + exp(-2 * abs(${a})))`,vs=a=>{a.compute(Oe(a.inputs[0],"Tanh",ws))},ya=(a="f32")=>`
const fast_gelu_a: ${a} = 0.5;
const fast_gelu_b: ${a} = 0.7978845608028654;
const fast_gelu_c: ${a} = 0.035677408136300125;

fn tanh_v(v: vec4<${a}>) -> vec4<${a}> {
  return ${ws("v")};
}
`,ba=a=>`(fast_gelu_a + fast_gelu_a * tanh_v(${a} * (fast_gelu_c * ${a} * ${a} + fast_gelu_b))) * ${a}`,$s=a=>{let e=at(a.inputs[0].dataType);a.compute(Oe(a.inputs[0],"FastGelu",ba,ya(e),void 0,a.inputs[0].dataType))},_s=(a,e)=>{let o=at(a.inputs[0].dataType);return a.compute(Oe(a.inputs[0],"ThresholdedRelu",s=>`select(vec4<${o}>(0.0), ${s}, ${s} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${o}>(${e.alpha});`,e.cacheKey)),0},xs=a=>{a.compute(Oe(a.inputs[0],"Log","log"))}}),gc,yc,Cs,Is=F(()=>{_e(),be(),$n(),gc=a=>{if(a[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(a[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(a[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(a[0].dims[2]!==a[1].dims[0])throw new Error("last dimension of input and bias are not the same")},yc=a=>{let e=a[0].dims.slice();e[2]=e[2]/2;let o=D("input",a[0].dataType,a[0].dims,4),s=D("bias",a[0].dataType,[a[0].dims[2]],4),d=q("output",a[0].dataType,e,4),c=M.size(e)/4,h=ke(a[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)}}),getShaderSource:_=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${a[0].dims[2]/4/2}u;

  ${_.declareVariables(o,s,d)}

  ${vn(h)}

  ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes(c)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${d.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},Cs=a=>{gc(a.inputs),a.compute(yc(a.inputs))}}),bc,wc,Ct,Es,As,Ts,Os,ks,Ps,Rs,zs,Bs,Ds,Ms=F(()=>{ie(),_e(),be(),bc=(a,e,o,s,d,c,h,_,bt,g,j,b)=>{let Et,It;typeof _=="string"?Et=It=(cr,fr)=>`${_}((${cr}),(${fr}))`:typeof _=="function"?Et=It=_:(Et=_.scalar,It=_.vector);let zt=q("outputData",j,s.length,4),er=D("aData",bt,e.length,4),Hn=D("bData",g,o.length,4),Qt;if(d)if(c){let cr=M.size(e)===1,fr=M.size(o)===1,jr=e.length>0&&e[e.length-1]%4===0,e0=o.length>0&&o[o.length-1]%4===0;cr||fr?Qt=zt.setByOffset("global_idx",It(cr?`${er.type.value}(${er.getByOffset("0")}.x)`:er.getByOffset("global_idx"),fr?`${Hn.type.value}(${Hn.getByOffset("0")}.x)`:Hn.getByOffset("global_idx"))):Qt=`
            let outputIndices = ${zt.offsetToIndices("global_idx * 4u")};
            let offsetA = ${er.broadcastedIndicesToOffset("outputIndices",zt)};
            let offsetB = ${Hn.broadcastedIndicesToOffset("outputIndices",zt)};
            ${zt.setByOffset("global_idx",It(h||jr?er.getByOffset("offsetA / 4u"):`${er.type.value}(${er.getByOffset("offsetA / 4u")}[offsetA % 4u])`,h||e0?Hn.getByOffset("offsetB / 4u"):`${Hn.type.value}(${Hn.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else Qt=zt.setByOffset("global_idx",It(er.getByOffset("global_idx"),Hn.getByOffset("global_idx")));else{if(!c)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let cr=(fr,jr,e0="")=>{let t0=`aData[indexA${jr}][componentA${jr}]`,o0=`bData[indexB${jr}][componentB${jr}]`;return`
            let outputIndices${jr} = ${zt.offsetToIndices(`global_idx * 4u + ${jr}u`)};
            let offsetA${jr} = ${er.broadcastedIndicesToOffset(`outputIndices${jr}`,zt)};
            let offsetB${jr} = ${Hn.broadcastedIndicesToOffset(`outputIndices${jr}`,zt)};
            let indexA${jr} = offsetA${jr} / 4u;
            let indexB${jr} = offsetB${jr} / 4u;
            let componentA${jr} = offsetA${jr} % 4u;
            let componentB${jr} = offsetB${jr} % 4u;
            ${fr}[${jr}] = ${e0}(${Et(t0,o0)});
          `};j===9?Qt=`
            var data = vec4<u32>(0);
            ${cr("data",0,"u32")}
            ${cr("data",1,"u32")}
            ${cr("data",2,"u32")}
            ${cr("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:Qt=`
            ${cr("outputData[global_idx]",0)}
            ${cr("outputData[global_idx]",1)}
            ${cr("outputData[global_idx]",2)}
            ${cr("outputData[global_idx]",3)}
          `}return`
        ${a.registerUniform("vec_size","u32").declareVariables(er,Hn,zt)}

        ${b??""}

        ${a.mainStart()}
        ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${Qt}
      }`},wc=(a,e,o,s,d,c,h=o.dataType)=>{let _=!M.areEqual(o.dims,s.dims),bt=o.dims,g=M.size(o.dims),j=!1,b=!1,Et=[_];if(_){let It=vt.calcShape(o.dims,s.dims,!1);if(!It)throw new Error("Can't perform binary op on the given tensors");bt=It,g=M.size(bt);let zt=M.size(o.dims)===1,er=M.size(s.dims)===1,Hn=o.dims.length>0&&o.dims[o.dims.length-1]%4===0,Qt=s.dims.length>0&&s.dims[s.dims.length-1]%4===0;Et.push(zt),Et.push(er),Et.push(Hn),Et.push(Qt);let cr=1;for(let fr=1;fr<bt.length;fr++){let jr=o.dims[o.dims.length-fr]??1,e0=s.dims[s.dims.length-fr]??1;if(jr===e0)cr*=jr;else break}cr%4===0?(b=!0,j=!0):(zt||er||Hn||Qt)&&(j=!0)}else j=!0;return Et.push(j),{name:a,shaderCache:{hint:e+Et.map(It=>It.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:It=>bc(It,o.dims,s.dims,bt,j,_,b,d,o.dataType,s.dataType,h,c),getRunData:()=>({outputs:[{dims:bt,dataType:h}],dispatchGroup:{x:Math.ceil(g/64/4)},programUniforms:[{type:12,data:Math.ceil(M.size(bt)/4)},...K(o.dims,s.dims,bt)]})}},Ct=(a,e,o,s,d,c)=>{a.compute(wc(e,d??"",a.inputs[0],a.inputs[1],o,s,c))},Es=a=>{Ct(a,"Add",(e,o)=>`${e}+${o}`)},As=a=>{Ct(a,"Div",(e,o)=>`${e}/${o}`)},Ts=a=>{Ct(a,"Equal",{scalar:(e,o)=>`u32(${e}==${o})`,vector:(e,o)=>`vec4<u32>(${e}==${o})`},void 0,void 0,9)},Os=a=>{Ct(a,"Mul",(e,o)=>`${e}*${o}`)},ks=a=>{let e=D("input",a.inputs[0].dataType,a.inputs[0].dims).type.value;Ct(a,"Pow",{scalar:(o,s)=>`pow_custom(${o},${s})`,vector:(o,s)=>`pow_vector_custom(${o},${s})`},`
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Ps=a=>{Ct(a,"Sub",(e,o)=>`${e}-${o}`)},Rs=a=>{Ct(a,"Greater",{scalar:(e,o)=>`u32(${e}>${o})`,vector:(e,o)=>`vec4<u32>(${e}>${o})`},void 0,void 0,9)},zs=a=>{Ct(a,"Less",{scalar:(e,o)=>`u32(${e}<${o})`,vector:(e,o)=>`vec4<u32>(${e}<${o})`},void 0,void 0,9)},Bs=a=>{Ct(a,"GreaterOrEqual",{scalar:(e,o)=>`u32(${e}>=${o})`,vector:(e,o)=>`vec4<u32>(${e}>=${o})`},void 0,void 0,9)},Ds=a=>{Ct(a,"LessOrEqual",{scalar:(e,o)=>`u32(${e}<=${o})`,vector:(e,o)=>`vec4<u32>(${e}<=${o})`},void 0,void 0,9)}}),$c,_c,xc,Sc,Us,Ns,Ws=F(()=>{ie(),_e(),Ye(),be(),$c=(a,e)=>{if(!a||a.length<1)throw new Error("too few inputs");let o=0,s=a[o],d=s.dataType,c=s.dims.length;a.forEach((h,_)=>{if(_!==o){if(h.dataType!==d)throw new Error("input tensors should be one type");if(h.dims.length!==c)throw new Error("input tensors should have the same shape");h.dims.forEach((bt,g)=>{if(g!==e&&bt!==s.dims[g])throw new Error("non concat dimensions must match")})}})},_c=(a,e)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${a}u>(${e});
    for (var i: u32 = 0u; i < ${a}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${a}u;
  }`,xc=(a,e)=>{let o=a.length,s=[];for(let d=0;d<o;++d){let c=e.setByOffset("global_idx",a[d].getByIndices("indices"));o===1?s.push(c):d===0?s.push(`if (inputIndex == ${d}u) { ${c} }`):d===o-1?s.push(`else { ${c} }`):s.push(`else if (inputIndex == ${d}) { ${c} }`)}return s.join(`
`)},Sc=(a,e,o,s)=>{let d=M.size(o),c=new Array(a.length),h=new Array(a.length),_=0,bt=[],g=[],j=[{type:12,data:d}];for(let er=0;er<a.length;++er)_+=a[er].dims[e],c[er]=_,g.push(a[er].dims.length),h[er]=D(`input${er}`,s,g[er]),bt.push("rank"),j.push({type:12,data:c[er]});for(let er=0;er<a.length;++er)j.push(...K(a[er].dims));j.push(...K(o));let b=q("output",s,o.length),Et=b.indicesGet("indices",e),It=Array.from(Array(c.length).keys()).map(er=>`uniforms.sizeInConcatAxis${er}`).join(","),zt=er=>`

  ${(()=>{er.registerUniform("outputSize","u32");for(let Hn=0;Hn<a.length;Hn++)er.registerUniform(`sizeInConcatAxis${Hn}`,"u32");return er.declareVariables(...h,b)})()}

  ${_c(c.length,It)}

  ${er.mainStart()}
    ${er.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${b.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${Et});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${c.length}u>(${It});
      ${Et} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${xc(h,b)}
  }`;return{name:"Concat",shaderCache:{hint:`${e}`,inputDependencies:bt},getRunData:()=>({outputs:[{dims:o,dataType:s}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:j}),getShaderSource:zt}},Us=(a,e)=>{let o=a.inputs,s=o[0].dims,d=M.normalizeAxis(e.axis,s.length);$c(o,d);let c=s.slice();c[d]=o.reduce((_,bt)=>_+(bt.dims.length>d?bt.dims[d]:0),0);let h=o.filter(_=>M.size(_.dims)>0);a.compute(Sc(h,d,c,o[0].dataType),{inputs:h})},Ns=a=>$e({axis:a.axis})}),ht,gt,yt,_n,Mt=F(()=>{ie(),_e(),ht=(a,e,o="f32")=>{switch(a.activation){case"Relu":return`value = max(value, ${e}(0.0));`;case"Sigmoid":return`value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${e}(${o}(uniforms.clip_min)), ${e}(${o}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${e}(0.0), min(${e}(1.0), ${o}(uniforms.alpha) * value + ${o}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${o}(uniforms.alpha) * value, value, value >= ${e}(0.0));`;case"":return"";default:throw new Error(`Unsupported activation ${a.activation}`)}},gt=(a,e)=>{a.activation==="Clip"?e.push({type:1,data:a.clipMax},{type:1,data:a.clipMin}):a.activation==="HardSigmoid"?e.push({type:1,data:a.alpha},{type:1,data:a.beta}):a.activation==="LeakyRelu"&&e.push({type:1,data:a.alpha})},yt=(a,e)=>{a.activation==="Clip"?e.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):a.activation==="HardSigmoid"?e.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):a.activation==="LeakyRelu"&&e.push({name:"alpha",type:"f32"})},_n=a=>{let e=(a==null?void 0:a.activation)||"";if(e==="HardSigmoid"){let[o,s]=(a==null?void 0:a.activation_params)||[.2,.5];return{activation:e,alpha:o,beta:s}}else if(e==="Clip"){let[o,s]=(a==null?void 0:a.activation_params)||[pn,fn];return{activation:e,clipMax:s,clipMin:o}}else if(e==="LeakyRelu"){let[o]=(a==null?void 0:a.activation_params)||[.01];return{activation:e,alpha:o}}return{activation:e}}}),Qe,xn,Sn=F(()=>{Qe=(a,e)=>{switch(a){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${a}-component is not supported.`)}},xn=a=>`
      ${a?"value = value + getBiasByOutputCoords(coords);":""}
      `}),Cn,wa=F(()=>{Cn=a=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${a}.x), i32(${a}.y), i32(${a}.z), 1));
}
`}),Cc,Ic,Tr,Vs,Ec,Or,Ac,In,kr=F(()=>{ie(),_e(),be(),Mt(),Sn(),Cc=(a,e)=>a?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e?", batchIndices":""});
        `,Ic=(a,e)=>a?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,Tr=(a,e,o="f32",s,d=!1,c=32,h=!1,_=32)=>{let bt=e[1]*a[1],g=e[0]*a[0],j=d?bt:c,b=d?c:bt,Et=j/e[0],It=c/e[1];if(!((d&&Et===4&&a[1]===4||!d&&(Et===3||Et===4))&&j%e[0]===0&&c%e[1]===0&&a[0]===4))throw new Error(`If transposeA ${d} is true, innerElementSize ${Et} and workPerThread[1] ${a[1]} must be 4.
      Otherwise, innerElementSize ${Et} must be 3 or 4.
  tileAWidth ${j} must be divisible by workgroupSize[0]${e[0]}. tileInner ${c} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${a[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${Et}<${o}>, ${j/Et}>, ${b}>;
var<workgroup> mm_Bsub: array<array<vec4<${o}>, ${g/a[0]}>, ${c}>;

const rowPerThread = ${a[1]};
const colPerThread = ${a[0]};
const innerElementSize = ${Et};
const tileInner = ${c};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${h?"0":"i32(globalId.z)"};
  ${s?`let batchIndices = ${s.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${bt};

  let num_tiles = ${h?`${Math.ceil(_/c)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${h?`i32(globalId.z) * ${_}`:"0"};

  var acc: array<vec4<${o}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${It};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${Cc(d,s)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${It}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${s?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${Et===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${Ic(d,Et)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Vs=(a,e)=>a?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e?", batchIndices":""});
            `,Ec=a=>a?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Or=(a,e,o="f32",s,d=!1,c=32,h=!1,_=32,bt=!1)=>{let g=a[1]*e[1],j=a[0]*e[0],b=d?g:c,Et=d?c:g;if(!(Et%e[1]===0&&b%e[0]===0&&c%e[1]===0))throw new Error(`tileAHight ${Et} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${b} must be divisible by workgroupSize[0]${e[0]}, tileInner ${c} must be divisible by workgroupSize[1]${e[1]}`);let It=Et/e[1],zt=b/e[0],er=c/e[1],Hn=bt?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${g};
    let globalColStart = i32(workgroupId.x) * ${j};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${Et}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${b}; inputCol = inputCol + ${e[0]}) {
          ${Vs(d,s)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${c}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${j}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${s?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${o}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${d?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${g};

let tileRowA = i32(localId.y) * ${It};
let tileColA = i32(localId.x) * ${zt};
let tileRowB = i32(localId.y) * ${er};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${It}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${zt}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Vs(d,s)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${er}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${s?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${o}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${Ec(d)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${o}, ${b}>, ${Et}>;
  var<workgroup> mm_Bsub : array<array<${o}, ${j}>, ${c}>;
  const rowPerThread = ${a[1]};
  const colPerThread = ${a[0]};
  const tileInner = ${c};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${h?"0":"i32(globalId.z)"};
    ${s?`let batchIndices = ${s.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${h?`${Math.ceil(_/c)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${h?`i32(globalId.z) * ${_}`:"0"};

    var acc : array<array<${o}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${Hn}
  }
`},Ac=(a,e,o,s,d,c=!1)=>{let[h,_,bt]=d,[g,j,b,Et]=s,It=ar(h,bt),zt=ar(_,bt),er=ke(s[0].type.tensor),Hn=()=>{let cr=j.rank,fr=g.rank,jr=`var aIndices: ${j.type.indices};`;for(let e0=cr-2-1,t0=fr-1;e0>=0;e0--,t0--)jr+=`
aIndices[${e0}] = ${fr>1?`batchIndices[${t0}]`:"batchIndices"};`;return It.forEach(e0=>{jr+=`
aIndices[${e0}] = 0;`}),jr+=`
aIndices[${cr-2}] = u32(row);
                   aIndices[${cr-1}] = u32(colIn);`,jr},Qt=()=>{let cr=b.rank,fr=g.rank,jr=`var bIndices: ${b.type.indices};`;for(let e0=cr-2-1,t0=fr-1;e0>=0;e0--,t0--)jr+=`
bIndices[${e0}] = ${fr>1?`batchIndices[${t0}]`:"batchIndices"};`;return zt.forEach(e0=>{jr+=`
bIndices[${e0}] = 0;`}),jr+=`
bIndices[${cr-2}] = u32(row);
                   bIndices[${cr-1}] = u32(colIn);`,jr};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${g.type.indices}) -> ${Qe(a,er)} {
      var value = ${Qe(a,er)}(0.0);
      let col = colIn * ${a};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${Hn()}
        value = ${j.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${g.type.indices}) -> ${Qe(a,er)} {
      var value = ${Qe(a,er)}(0.0);
      let col = colIn * ${a};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${Qt()}
        value = ${b.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Qe(a,er)}) {
      let col = colIn * ${a};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e?`value = value + ${c?"bias[colIn]":`${Qe(a,er)}(bias[row])`};`:""}
        ${o}
        ${Et.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},In=(a,e,o,s,d=!1)=>{let c=a[0].dims,h=a[1].dims,_=c.slice(0,-2),bt=h.slice(0,-2),g=s?s.slice(0,-2):o.slice(0,-2),j=M.size(g),b=c[c.length-2],Et=c[c.length-1],It=h[h.length-1],zt=Et%4===0&&It%4===0,er=b<=8?[4,1,1]:[4,4,1],Hn=[8,8,1],Qt=[Math.ceil(It/Hn[0]/er[0]),Math.ceil(b/Hn[1]/er[1]),Math.ceil(j/Hn[2]/er[2])],cr=zt?4:1,fr=[..._,b,Et/cr],jr=fr.length,e0=[...bt,Et,It/cr],t0=e0.length,o0=[j,b,It/cr],l0=[{type:6,data:b},{type:6,data:It},{type:6,data:Et}];gt(e,l0),l0.push(...K(g,fr,e0));let g0=["rank","rank"],i0=a.length>2;i0&&(l0.push(...K(a[2].dims)),g0.push("rank")),l0.push(...K(o0));let f0=C0=>{let Z0=g.length,R0=hn("batchDims",a[0].dataType,Z0,1),Y0=ke(a[0].dataType),H0=D("a",a[0].dataType,jr,cr),ty=D("b",a[1].dataType,t0,cr),w0=q("result",a[0].dataType,o0.length,cr),L0=[H0,ty];if(i0){let J0=d?cr:1;L0.push(D("bias",a[2].dataType,a[2].dims.length,J0))}let k0=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];yt(e,k0);let T0=ke(w0.type.tensor),q0=ht(e,w0.type.value,T0),vy=Ac(cr,i0,q0,[R0,H0,ty,w0],[_,bt,g],d);return`
  ${C0.registerUniforms(k0).registerInternalVariables(R0).declareVariables(...L0,w0)}
  ${vy}
  ${zt?Tr(er,Hn,Y0,R0):Or(er,Hn,Y0,R0)}
                   `};return{name:"MatMul",shaderCache:{hint:`${er};${e.activation};${zt};${d}`,inputDependencies:g0},getRunData:()=>({outputs:[{dims:o,dataType:a[0].dataType}],dispatchGroup:{x:Qt[0],y:Qt[1],z:Qt[2]},programUniforms:l0}),getShaderSource:f0}}}),Tc,Gs,Hs=F(()=>{ie(),Dt(),be(),Mt(),Sn(),wa(),kr(),Tc=(a,e,o,s,d=!1,c,h=4,_=4,bt=4,g="f32")=>{let j=g0=>{switch(g0){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${g}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${g0} is not supported.`)}},b=g0=>{switch(g0){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${g0} is not supported.`)}},Et=a?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,It=a?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,zt=a?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",er=a?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",Hn=a?"row":"col",Qt=a?"col":"row",cr=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${a?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${Hn} / outWidth;
    let outCol = ${Hn} % outWidth;

    let WRow = ${Qt} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${Qt} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${Qt} % inChannels;
    var resData = ${Qe(h,g)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${zt} && xCol >= 0 && xCol < ${er}) {
      ${Et}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${j(h)}
    }
    return resData;`,fr=a?e&&s?`
    let col = colIn * ${h};
    ${cr}`:`
    let col = colIn * ${h};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${cr}
    }
    return ${Qe(h,g)}(0.0);`:s&&o?`
    let col = colIn * ${h};
    ${cr}`:`
    let col = colIn * ${h};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${cr}
    }
    return ${Qe(h,g)}(0.0);`,jr=`${b(_)}`,e0=Qe(bt,g),t0=Qe(a?h:_,g),o0=Qe(a?_:h,g),l0=ht(c,e0,g);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${t0} {
      ${a?fr:jr}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${o0} {
      ${a?jr:fr}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${e0}) {
      let col = colIn * ${bt};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${a?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${It}
      ${xn(d)}
      ${l0}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},Gs=(a,e,o,s,d,c,h,_)=>{let bt=e.format==="NHWC",g=bt?a[0].dims[3]:a[0].dims[1],j=o[0],b=bt?o[2]:o[3],Et=bt?o[1]:o[2],It=bt?o[3]:o[1],zt=bt&&(g%4===0||g%3===0)&&It%4===0,er=bt?It:b*Et,Hn=bt?b*Et:It,Qt=[8,8,1],cr=s<=8?[4,1,1]:[4,4,1],fr=[Math.ceil(er/Qt[0]/cr[0]),Math.ceil(Hn/Qt[1]/cr[1]),Math.ceil(j/Qt[2]/cr[2])];De("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${fr}`);let jr=zt?bt&&g%4!==0?3:4:1,e0=Qt[1]*cr[1],t0=Qt[0]*cr[0],o0=Math.max(Qt[0]*jr,Qt[1]),l0=s%e0===0,g0=d%t0===0,i0=c%o0===0,f0=zt?[jr,4,4]:[1,1,1],C0=[{type:6,data:s},{type:6,data:d},{type:6,data:c},{type:6,data:[e.pads[0],e.pads[1]]},{type:6,data:e.strides},{type:6,data:e.dilations}];gt(e,C0),C0.push(...K(a[0].dims,a[1].dims));let Z0=["rank","rank"];h&&(C0.push(...K(a[2].dims)),Z0.push("rank")),C0.push(...K(o));let R0=Y0=>{let H0=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];yt(e,H0);let ty=zt?4:1,w0=ke(a[0].dataType),L0=`
      fn setOutputAtIndex(flatIndex : i32, value : ${zt?`vec4<${w0}>`:w0}) {
        result[flatIndex] = ${zt?`vec4<${w0}>`:w0}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${zt?`vec4<${w0}>`:w0}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${zt?"/ 4":""}, value);
      }`,k0=D("x",a[0].dataType,a[0].dims.length,jr===3?1:jr),T0=D("w",a[1].dataType,a[1].dims.length,ty),q0=[k0,T0],vy=q("result",a[0].dataType,o.length,ty);if(h){let J0=D("bias",a[2].dataType,a[2].dims.length,ty);q0.push(J0),L0+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${zt?`vec4<${w0}>`:w0} {
          return bias[coords.${bt?"w":"y"}${zt?"/ 4":""}];
        }`}return`
        ${Cn("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Y0.registerUniforms(H0).declareVariables(...q0,vy)}
        ${L0}
        ${Tc(bt,l0,g0,i0,h,e,f0[0],f0[1],f0[2],w0)}
        ${zt?Tr(cr,Qt,w0,void 0,!bt,o0):Or(cr,Qt,w0,void 0,!bt,o0,!1,void 0,_)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${e.cacheKey};${jr};${zt};${l0};${g0};${i0};${e0};${t0};${o0}`,inputDependencies:Z0},getRunData:()=>({outputs:[{dims:o,dataType:a[0].dataType}],dispatchGroup:{x:fr[0],y:fr[1],z:fr[2]},programUniforms:C0}),getShaderSource:R0}}}),va,Ls,Fs=F(()=>{ie(),_e(),be(),$a(),Mt(),va=(a,e,o)=>{let s=a.length>2,d=s?"value += b[output_channel];":"",c=a[0].dims,h=a[1].dims,_=h[0]/e.group,bt=e.format==="NHWC",g=En(c,h,e.dilations,e.pads,e.strides,bt),j=M.size(g),b=[{type:12,data:j},{type:12,data:e.dilations},{type:12,data:[e.strides[0],e.strides[1]]},{type:12,data:[e.pads[0],e.pads[1]]},{type:12,data:_}];gt(e,b),b.push(...K(c,h,g));let Et=["rank","rank"];s&&(b.push(...K(a[2].dims)),Et.push("rank")),b.push(...K(g));let It=zt=>{let er=q("output",a[0].dataType,g.length),Hn=ke(er.type.tensor),Qt=ht(e,er.type.value,Hn),cr=D("x",a[0].dataType,c.length),fr=D("w",a[1].dataType,h.length),jr=[cr,fr];s&&jr.push(D("b",a[2].dataType,a[2].dims));let e0=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:e.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];return yt(e,e0),`
  ${zt.registerUniforms(e0).declareVariables(...jr,er)}

  ${zt.mainStart()}
    ${zt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${er.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${bt?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${bt?1:2}], outputIndices[${bt?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel / uniforms.output_channels_per_group;

    var value: ${er.type.value} = ${er.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[${bt?1:2}]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[${bt?2:3}]) {
            continue;
          }

          let xVal = ${bt?cr.get("batch","xHeight","xWidth","input_channel"):cr.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${fr.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${d}
    ${Qt}
    ${er.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:e.cacheKey,inputDependencies:Et},getRunData:()=>({outputs:[{dims:o?o(g):g,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(j/64)},programUniforms:b}),getShaderSource:It}},Ls=(a,e,o)=>{let s=a.length>2,d=Me(o[3]),c=Me(o[2]),h=M.size(o)/d/c,_=[a[0].dims[0],a[0].dims[1],a[0].dims[2],a[0].dims[3]/d],bt=[a[1].dims[0],a[1].dims[1],a[1].dims[2],a[1].dims[3]/d],g=[o[0],o[1],o[2],o[3]/d],j=[{type:12,data:h},{type:6,data:[e.strides[0],e.strides[1]]},{type:6,data:[e.pads[0],e.pads[1]]}];gt(e,j),j.push(...K(_,bt,g));let b=(c-1)*e.strides[1]+bt[1],Et=It=>{let zt=q("output",a[0].dataType,g.length,d),er=ke(zt.type.tensor),Hn=ht(e,zt.type.value,er),Qt=D("x",a[0].dataType,_.length,d),cr=D("w",a[1].dataType,bt.length,d),fr=[Qt,cr];s&&fr.push(D("b",a[2].dataType,a[2].dims,d));let jr=s?"value += b[output_channel];":"",e0=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return yt(e,e0),`
  ${It.registerUniforms(e0).declareVariables(...fr,zt)}
  ${It.mainStart()}
    ${It.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${c}u;
    let col = (index1 % width1) * ${c}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${Qt.type.value}, ${b}>;
    var values: array<${zt.type.value}, ${c}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${bt[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${b}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${Qt.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${Qt.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${bt[1]}; w_width++) {
          let w_val = ${cr.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${c}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${c}u; i++) {
      var value = values[i];
      ${jr}
      ${Hn}
      ${zt.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${e.cacheKey};${d};${c};${b};${bt[0]};${bt[1]}`,inputDependencies:s?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:o,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:j}),getShaderSource:Et}}}),_a,Oc,qs,xa=F(()=>{ie(),_e(),kr(),be(),Mt(),_a=(a,e,o,s,d=!1)=>{let c=a[0].dims,h=a[1].dims,_=c[c.length-2],bt=h[h.length-1],g=c[c.length-1],j=Me(bt),b=Me(g),Et=Me(_),It=M.size(o)/j/Et,zt=a.length>2,er=s?s.slice(0,-2):o.slice(0,-2),Hn=[M.size(er),_,bt],Qt=[{type:12,data:It},{type:12,data:_},{type:12,data:bt},{type:12,data:g}];gt(e,Qt),Qt.push(...K(er,c,h)),zt&&Qt.push(...K(a[2].dims)),Qt.push(...K(Hn));let cr=fr=>{let jr=hn("batch_dims",a[0].dataType,er.length),e0=D("a",a[0].dataType,c.length,b),t0=D("b",a[1].dataType,h.length,j),o0=q("output",a[0].dataType,Hn.length,j),l0=ke(o0.type.tensor),g0=ht(e,o0.type.value,l0),i0=[e0,t0],f0="";if(zt){let L0=d?j:1;i0.push(D("bias",a[2].dataType,a[2].dims.length,L0)),f0=`${d?`value += bias[col / ${L0}];`:`value += ${o0.type.value}(bias[row + i]);`}`}let C0=c.slice(0,-2),Z0=h.slice(0,-2),R0=ar(C0,er),Y0=ar(Z0,er),H0=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];yt(e,H0);let ty=(L0,k0)=>{let T0=L0.rank,q0=L0.name;if(T0===2)return`var ${q0}_indices = ${L0.type.indices}(0u, 0u);`;let vy=jr.rank,J0=`var ${q0}_indices: ${L0.type.indices};`;for(let cy=T0-2-1,Ty=vy-1;cy>=0;cy--,Ty--)J0+=`
${q0}_indices[${cy}] = ${vy>1?`batch_indices[${Ty}]`:"batch_indices"};`;return k0.forEach(cy=>{J0+=`
${q0}_indices[${cy}] = 0;`}),J0+=`${q0}_indices[${T0-2}] = 0u;
                     ${q0}_indices[${T0-1}] = 0u;`,J0},w0=()=>{let L0=`var a_data: ${e0.type.value};`;for(let k0=0;k0<b;k0++)L0+=`
              let b_data${k0} = b[(b_offset + (k + ${k0}) * uniforms.N + col) / ${j}];`;for(let k0=0;k0<Et;k0++){L0+=`a_data = a[(a_offset + (row + ${k0}) * uniforms.K + k) / ${b}];`;for(let T0=0;T0<b;T0++)L0+=`
            values[${k0}] = fma(${t0.type.value}(a_data${b===1?"":`[${T0}]`}), b_data${T0}, values[${k0}]);
`}return L0};return`
  ${fr.registerUniforms(H0).registerInternalVariables(jr).declareVariables(...i0,o0)}
  ${fr.mainStart()}
    ${fr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${j})) * ${j};
    var index1 = global_idx / (uniforms.N / ${j});
    let stride1 = uniforms.M / ${Et};
    let row = (index1 % stride1) * ${Et};
    let batch = index1 / stride1;

    ${o.length===2?"":`let batch_indices = ${jr.offsetToIndices("batch")};`}
    ${ty(e0,R0)}
    let a_offset = ${e0.indicesToOffset("a_indices")};
    ${ty(t0,Y0)}
    let b_offset = ${t0.indicesToOffset("b_indices")};
    var values: array<${o0.type.value}, ${Et}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${b}) {
      ${w0()}
    }
    for (var i = 0u; i < ${Et}u; i++) {
      var value = values[i];
      ${f0}
      ${g0}
      let cur_indices = ${o0.type.indices}(batch, row + i, col);
      let offset = ${o0.indicesToOffset("cur_indices")};
      ${o0.setByOffset(`offset / ${j}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${e.activation};${j};${b};${Et};${d}`,inputDependencies:zt?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:o,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(It/64)},programUniforms:Qt}),getShaderSource:cr}},Oc=a=>{if(!a||a.length!==2)throw new Error("MatMul requires 2 inputs.");if(a[0].dims[a[0].dims.length-1]!==a[1].dims[a[1].dims.length-2])throw new Error("shared dimension does not match.")},qs=a=>{Oc(a.inputs);let e=vt.calcShape(a.inputs[0].dims,a.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");let o=e[e.length-1],s=a.inputs[0].dims[a.inputs[0].dims.length-1];o<8&&s<8?a.compute(_a(a.inputs,{activation:""},e)):a.compute(In(a.inputs,{activation:""},e))}}),En,Sa,kc,js,Ca,Pc,Rc,Ia,$a=F(()=>{_e(),Hs(),kr(),Fs(),Mt(),xa(),ir(),En=(a,e,o,s,d,c)=>{let h=a[0],_=a.slice(c?1:2,c?3:4),bt=_.length,g=e[0],j=e.slice(2).map((Et,It)=>Et+(Et-1)*(o[It]-1)),b=_.map((Et,It)=>Et+s[It]+s[It+bt]).map((Et,It)=>Math.floor((Et-j[It]+d[It])/d[It]));return b.splice(0,0,h),b.splice(c?3:1,0,g),b},Sa=[2,3,1,0],kc=(a,e)=>{if(!a||a.length!==2&&a.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(a[0].dims.length!==4&&a[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(a[0].dims.length!==a[1].dims.length)throw new Error("filter does not have same dimension as input");let o=a[0].dims[e.format==="NHWC"?a[0].dims.length-1:1],s=a[1].dims[1]*e.group;if(o!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(a.length===3&&(a[2].dims.length!==1||a[1].dims[0]!==a[2].dims[0]))throw new Error("invalid bias");let d=a[0].dims.length-2;if(e.dilations.length!==d)throw new Error(`dilations should be ${d}D`);if(e.strides.length!==d)throw new Error(`strides should be ${d}D`);if(e.pads.length!==d*2)throw new Error(`pads should be ${d*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==a[1].dims.length-2)throw new Error("invalid kernel shape")},js=(a,e)=>{let o=a.kernelShape.slice();for(let c=2;c<e[1].dims.length;++c)o[c-2]===0&&(o[c-2]=e[1].dims[c]);let s=a.pads.slice();qt.adjustPadsBasedOnAutoPad(e[0].dims,a.strides,a.dilations,o,s,a.format==="NHWC",a.autoPad);let d=Object.assign({},a);return Object.assign(d,{kernelShape:o,pads:s}),d},Ca=a=>{let e=_n(a),o=a.format,s=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][a.auto_pad],d=a.dilations,c=a.group,h=a.kernel_shape,_=a.pads,bt=a.strides,g=a.w_is_const();return{autoPad:s,format:o,dilations:d,group:c,kernelShape:h,pads:_,strides:bt,wIsConst:g,...e,cacheKey:`${a.format};${e.activation};`}},Pc=(a,e,o)=>{let s=js(o,e),d=o.format==="NHWC";if(o.group!==1){if(!a.adapterInfo.isArchitecture("ampere")&&d&&e[1].dims[0]===o.group&&e[1].dims[1]===1&&o.dilations[0]===1&&o.dilations[1]===1){let t0=En(e[0].dims,e[1].dims,o.dilations,s.pads,o.strides,d),o0=a.kernelCustomData.wT??a.compute(dt(e[1],Sa),{inputs:[1],outputs:[o.wIsConst?-2:-1]})[0];o.wIsConst&&!a.kernelCustomData.wT&&(a.kernelCustomData.wT=o0);let l0=[e[0],o0];e.length===3&&l0.push(e[2]),a.compute(Ls(l0,s,t0),{inputs:l0})}else a.compute(va(e,s));return}let c=e.length===3,h=e[0].dims[d?1:2],_=e[0].dims[d?2:3],bt=e[0].dims[d?3:1],g=e[1].dims[2],j=e[1].dims[3],b=En(e[0].dims,e[1].dims,o.dilations,s.pads,o.strides,d),Et=b[d?1:2],It=b[d?2:3],zt=b[d?3:1],er=d&&g===h&&j===_&&o.pads[0]===0&&o.pads[1]===0;if(er||g===1&&j===1&&o.dilations[0]===1&&o.dilations[1]===1&&o.strides[0]===1&&o.strides[1]===1&&o.pads[0]===0&&o.pads[1]===0){let t0=b[0],o0,l0,g0,i0=[];if(d){let Z0=a.kernelCustomData.wT??a.compute(dt(e[1],Sa),{inputs:[1],outputs:[o.wIsConst?-2:-1]})[0];if(o.wIsConst&&!a.kernelCustomData.wT&&(a.kernelCustomData.wT=Z0),er){let R0=h*_*bt;o0=e[0].reshape([1,t0,R0]),l0=Z0.reshape([1,R0,zt]),g0=[1,t0,zt]}else o0=e[0].reshape([t0,h*_,bt]),l0=Z0.reshape([1,bt,zt]),g0=[t0,Et*It,zt];i0.push(o0),i0.push(l0)}else o0=e[0].reshape([t0,bt,h*_]),l0=e[1].reshape([1,zt,bt]),g0=[t0,zt,Et*It],i0.push(l0),i0.push(o0);c&&i0.push(e[2]);let f0=g0[2],C0=i0[0].dims[i0[0].dims.length-1];f0<8&&C0<8?a.compute(_a(i0,s,b,g0,d),{inputs:i0}):a.compute(In(i0,s,b,g0,d),{inputs:i0});return}let Hn=!0,Qt=a.kernelCustomData.wT??a.compute(dt(e[1],Sa),{inputs:[1],outputs:[o.wIsConst?-2:-1]})[0];o.wIsConst&&!a.kernelCustomData.wT&&(a.kernelCustomData.wT=Qt);let cr=[e[0],Qt];c&&cr.push(e[2]);let fr=d?Et*It:zt,jr=d?zt:Et*It,e0=g*j*bt;a.compute(Gs(cr,s,b,fr,jr,e0,c,Hn),{inputs:cr})},Rc=(a,e)=>{let o=e.format==="NHWC",s=[a.inputs[0].reshape(o?[a.inputs[0].dims[0],1,a.inputs[0].dims[1],a.inputs[0].dims[2]]:[a.inputs[0].dims[0],a.inputs[0].dims[1],1,a.inputs[0].dims[2]]),a.inputs[1].reshape([a.inputs[1].dims[0],a.inputs[1].dims[1],1,a.inputs[1].dims[2]])];a.inputs.length===3&&s.push(a.inputs[2]);let d=[0,e.pads[0],0,e.pads[1]],c=[1].concat(e.strides),h=[1].concat(e.dilations),_=[1].concat(e.kernelShape),bt=js({...e,pads:d,strides:c,dilations:h,kernelShape:_},s);a.compute(va(s,bt,g=>o?[g[0],g[2],g[3]]:[]))},Ia=(a,e)=>{kc(a.inputs,e),a.inputs[0].dims.length===3?Rc(a,e):Pc(a,a.inputs,e)}}),zc,Ks,Ys=F(()=>{ie(),Dt(),be(),Mt(),Sn(),wa(),kr(),zc=(a,e=!1,o,s,d=4)=>{let c=Hn=>{switch(Hn){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${s}(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${Hn} is not supported.`)}},h=a?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,_=a?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,bt=a?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",g=a?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",j=a?"row":"col",b=a?"col":"row",Et=`
      let inChannels = ${a?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let outWidth = ${a?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      let outRow = ${j} / outWidth;
      let outCol = ${j} % outWidth;

      let WRow = ${b} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${b} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${bt}) || fract(xR) > 0.0) {
        return ${s}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${g}) || fract(xC) > 0.0) {
        return ${s}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${b} % inChannels;
      ${h}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${d}];`,It=a?`
      let col = colIn * ${d};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${Et}
      }
      return ${s}(0.0);`:`
      let col = colIn * ${d};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${Et}
      }
      return ${s}(0.0);`,zt=`
      let col = colIn * ${d};
      let inChannels = ${a?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${a?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${c(d)}
      }
      return ${s}(0.0);
      `,er=ht(o,s);return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${s} {
    ${a?It:zt}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${s} {
    ${a?zt:It}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${s}) {
    let col = colIn * ${d};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${a?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${_}
      ${xn(e)}
      ${er}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${d}] = value;
    }
  }`},Ks=(a,e,o,s,d,c,h,_)=>{let bt=e.format==="NHWC",g=bt?a[0].dims[3]:a[0].dims[1],j=o[0],b=bt?o[2]:o[3],Et=bt?o[1]:o[2],It=bt?o[3]:o[1],zt=bt?g%4===0&&It%4===0:b%4===0&&It%4===0,er=bt?It:b*Et,Hn=bt?b*Et:It,Qt=zt?[8,8,1]:[er<=4||Hn<=4?4:16,er>4&&Hn<=4?4:16,1],cr=zt?[4,4,1]:[er<=4?1:4,er>4&&Hn<=4?1:4,1],fr=[Math.ceil(er/Qt[0]/cr[0]),Math.ceil(Hn/Qt[1]/cr[1]),Math.ceil(j/Qt[2]/cr[2])];De("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${fr}`);let jr=zt?4:1,e0=Math.max(Qt[0]*jr,Qt[1]),t0=zt?4:1,o0=[e.kernelShape[bt?1:2],e.kernelShape[bt?2:3]],l0=[o0[0]+(e.dilations[0]<=1?0:(o0[0]-1)*(e.dilations[0]-1)),o0[1]+(e.dilations[1]<=1?0:(o0[1]-1)*(e.dilations[1]-1))],g0=[l0[0]-1-Math.floor((e.pads[0]+e.pads[2])/2),l0[1]-1-Math.floor((e.pads[1]+e.pads[3])/2)],i0=[{type:6,data:s},{type:6,data:d},{type:6,data:c},{type:6,data:e.strides},{type:6,data:e.dilations},{type:6,data:o0},{type:6,data:g0}];gt(e,i0),i0.push(...K(a[0].dims,a[1].dims));let f0=["rank","rank"];h&&(i0.push(...K(a[2].dims)),f0.push("rank")),i0.push(...K(o));let C0=Z0=>{let R0=D("x",a[0].dataType,a[0].dims.length,t0),Y0=D("w",a[1].dataType,a[1].dims.length,1),H0=q("result",a[0].dataType,o.length,t0),ty=[R0,Y0],w0="";if(h){let T0=D("bias",a[2].dataType,a[2].dims.length,t0);ty.push(T0),w0+=`
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${T0.type.value} {
            return bias[coords.${bt?"w":"y"}${zt?"/ 4":""}];
          }`}let L0=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:o0.length},{name:"pads",type:"i32",length:g0.length}];yt(e,L0);let k0=ke(a[0].dataType,1);if(k0!=="f16"&&k0!=="f32")throw new Error(`elemType ${k0} is not supported.`);return`
        ${Cn("uniforms.result_strides")}
        ${Z0.registerUniforms(L0).declareVariables(...ty,H0)};
        ${w0}
        ${zc(bt,h,e,R0.type.value,jr)}
        ${zt?Tr(cr,Qt,k0,void 0,!bt,e0):Or(cr,Qt,k0,void 0,!bt,e0,!1,void 0,_)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${e.cacheKey};${cr};${Qt};${zt}`,inputDependencies:f0},getRunData:()=>({outputs:[{dims:o,dataType:a[0].dataType}],dispatchGroup:{x:fr[0],y:fr[1],z:fr[2]},programUniforms:i0}),getShaderSource:C0}}}),Bc,Ea,Zs=F(()=>{ie(),Dt(),_e(),be(),Bc=(a,e,o,s,d,c=!1,h,_,bt=!1)=>{let g=bt?1:2,j=bt?2:3,b=bt?3:1,Et=c?2:1,It=`
  fn setOutputAtIndex(flatIndex : u32, value : ${c?`vec4<${h}>`:h}) {
    result[flatIndex] = ${c?`vec4<${h}>`:h}(value);
  }`;s&&(It+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${c?`vec4<${h}>`:h} {
      return bias[coords.${bt?"w":"y"}${c?"/ 4":""}];
    }`);let zt=c?4:1,er=D("W",e[1].dataType,e[1].dims.length,zt),Hn=D("Dy",e[0].dataType,e[0].dims.length,zt),Qt=[Hn,er];s&&Qt.push(D("bias",e[2].dataType,[o[b]].length,zt));let cr=q("result",e[0].dataType,o.length,zt),fr=`{
        let batch: u32 = ${d?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];
        let r = ${d?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];
        let c = ${d?"global_id.y":"workgroup_id.y"} * ${Et};
        let d1: u32 = ${d?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${h}>, ${Et}>;
        for (var i = 0; i < ${Et}; i++) {
          dotProd[i] = vec4<${h}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${h}(dyCorner.x) + ${h}(wR)) / ${h}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${h}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${h}(dyCorner.y) + ${h}(wC)) / ${h}(uniforms.strides.y);
            let dyC2 = (${h}(dyCorner.y) + 1.0 + ${h}(wC)) / ${h}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${h}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${h}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${er.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${er.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${er.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${er.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Hn.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${h}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${Hn.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${h}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${b}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${er.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${er.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${er.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${er.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Hn.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${h}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${er.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${er.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${er.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${er.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Hn.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${h}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${Et}; i = i + 1) {
          let value = dotProd[i] + ${s?"bias[c+i]":`vec4<${h}>(0.0)`};
          ${cr.set("batch","r","c + i","d1","value")};
        }
      }`,jr=`
          let outputIndices = ${cr.offsetToIndices("global_idx")};
          let batch = ${cr.indicesGet("outputIndices",0)};
          let d1 = ${cr.indicesGet("outputIndices",b)};
          let r = ${cr.indicesGet("outputIndices",g)};
          let c = ${cr.indicesGet("outputIndices",j)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${h}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${h}(dyRCorner) + ${h}(wR)) / ${h}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${h}(uniforms.Dy_shape[${g}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${h}(dyCCorner) + ${h}(wC)) / ${h}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${h}(uniforms.Dy_shape[${j}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${bt?Hn.get("batch","idyR","idyC","inputChannel"):Hn.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${er.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${s?"bias[d1]":`${h}(0.0)`};
          ${cr.setByOffset("global_idx","value")};
        `;return`
  ${a.registerUniforms(_).declareVariables(...Qt,cr)}
  ${It}

    ${a.mainStart()}
    ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${c?fr:jr}}`},Ea=(a,e,o)=>{let s=a.length>2,d=e.outputShape,c=M.size(d),h=[Math.ceil(c/64),1,1];De("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${h}`);let _=e.format==="NHWC",bt=["rank","rank"],g=[e.strides[0],e.strides[1]],j=[e.kernelShape[_?1:2],e.kernelShape[_?2:3]],b=[e.dilations[0],e.dilations[1]],Et=[j[0]+(e.dilations[0]<=1?0:(e.kernelShape[_?1:2]-1)*(e.dilations[0]-1)),j[1]+(e.dilations[1]<=1?0:(e.kernelShape[_?2:3]-1)*(e.dilations[1]-1))],It=[Et[0]-1-Math.floor((e.pads[0]+e.pads[2])/2),Et[1]-1-Math.floor(e.pads[1]+e.pads[3])/2],zt=!1,er=e.group,Hn=a[1].dims,Qt=Hn[0]/er,cr=Hn[1],fr=[{type:6,data:c},{type:12,data:g},{type:12,data:j},{type:12,data:b},{type:12,data:Et},{type:6,data:It},{type:12,data:Qt},{type:12,data:cr},...K(a[0].dims,a[1].dims)];s&&(fr.push(...K(a[2].dims)),bt.push("rank")),fr.push(...K(d));let jr=h[1]===1&&h[2]===1,e0=t0=>{let o0=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:g.length},{name:"filter_dims",type:"u32",length:j.length},{name:"dilations",type:"u32",length:j.length},{name:"effective_filter_dims",type:"u32",length:Et.length},{name:"pads",type:"i32",length:It.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],l0=ke(a[0].dataType);return`${Bc(t0,a,d,s,jr,zt,l0,o0,_)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${e.cacheKey};`,inputDependencies:bt},getRunData:()=>({dispatchGroup:{x:h[0],y:h[1],z:h[2]},outputs:[{dims:o?o(d):d,dataType:a[0].dataType}],programUniforms:fr}),getShaderSource:e0}}}),Dc,Mc,Uc,Xs,Qs,Nc,Wc,Vc,Gc,Js,eu=F(()=>{Ys(),Zs(),Mt(),ir(),Dc=(a,e,o,s,d,c)=>(a-1)*e+o+(s-1)*d+1-c,Mc=(a,e,o,s,d)=>{let c=Math.floor(a/2);e==="SAME_UPPER"?(o[s]=c,o[d]=a-c):e==="SAME_LOWER"&&(o[s]=a-c,o[d]=c)},Uc=(a,e,o,s,d,c,h,_,bt,g)=>{let j=a.length-2,b=g.length===0;if(bt.length===0)for(let zt=0;zt<j;++zt)bt.push(0);let Et=a[0],It=e[_?3:1]*d;for(let zt=0,er=a.length-j-(_?1:0);zt<j;++zt,++er){let Hn=a[er],Qt=b?Hn*h[zt]:g[zt],cr=Dc(Hn,h[zt],c[zt],e[er],o[zt],Qt);Mc(cr,s,c,zt,zt+j),b&&g.push(h[zt]*(Hn-1)+bt[zt]+(e[er]-1)*o[zt]+1-c[zt]-c[zt+j])}g.splice(0,0,Et),g.splice(_?3:1,0,It)},Xs=(a,e)=>{let o=a.kernelShape.slice();if(a.kernelShape.length===0||a.kernelShape.reduce((b,Et)=>b*Et,1)===0){o.length=0;for(let b=2;b<e[1].dims.length;++b)o.push(e[1].dims[b])}let s=a.format==="NHWC";o.splice(0,0,e[1].dims[0]),o.splice(s?3:1,0,e[1].dims[1]);let d=a.pads.slice(),c=a.outputShape.slice(),h=a.outputPadding.slice(),_=e[0].dims,bt=a.dilations.slice();if(bt.reduce((b,Et)=>b+Et,0)===0){let b=e[0].dims.length-2;bt=new Array(b).fill(1)}let g=a.strides.slice();if(g.reduce((b,Et)=>b+Et,0)===0){let b=e[0].dims.length-2;g=new Array(b).fill(1)}Uc(_,o,bt,a.autoPad,a.group,d,g,s,h,c);let j=Object.assign({},a);return Object.assign(j,{kernelShape:o,pads:d,outputPadding:h,outputShape:c,dilations:bt,strides:g}),j},Qs=a=>{let e=_n(a),o=a.format,s=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof a.autoPad>"u"?0:a.autoPad],d=a.dilations,c=a.group,h=a.kernelShape,_=a.pads,bt=a.strides,g=a.wIsConst(),j=a.outputPadding,b=a.outputShape;return{autoPad:s,format:o,dilations:d,group:c,kernelShape:h,outputPadding:j,outputShape:b,pads:_,strides:bt,wIsConst:g,...e,cacheKey:`${a.format};${e.activation};`}},Nc=(a,e)=>{if(!a||a.length!==2&&a.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(a[0].dims.length!==4&&a[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(a[0].dims.length!==a[1].dims.length)throw new Error("filter does not have same dimension as input");let o=a[0].dims[e.format==="NHWC"?a[0].dims.length-1:1],s=a[1].dims[0];if(o!==s)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let d=a[1].dims[1]*e.group;if(a.length===3&&(a[2].dims.length!==1||a[2].dims[0]!==d))throw new Error("invalid bias");let c=a[0].dims.length-2;if(e.dilations.reduce((h,_)=>h+_,0)>0&&e.dilations.length!==c)throw new Error(`dilations should be ${c}D`);if(e.strides.reduce((h,_)=>h+_,0)>0&&e.strides.length!==c)throw new Error(`strides should be ${c}D`);if(e.pads.reduce((h,_)=>h+_,0)>0&&e.pads.length!==c*2)throw new Error(`pads should be ${c*2}D`);if(e.outputPadding.length!==c&&e.outputPadding.length!==0)throw new Error(`output_padding should be ${c}D`);if(e.kernelShape.reduce((h,_)=>h+_,0)>0&&e.kernelShape.length!==0&&e.kernelShape.length!==a[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==a[0].dims.length-2)throw new Error("invalid output shape")},Wc=[2,3,1,0],Vc=(a,e,o)=>{let s=Xs(o,e),d=o.format==="NHWC",c=s.outputShape,h=c[d?3:1],_=e[0].dims[d?3:1];if(s.group!==1||h===1&&_===1){a.compute(Ea(e,s));return}let bt=c[d?1:2],g=c[d?2:3],j=e[1].dims[2],b=e[1].dims[3],Et=d?bt*g:h,It=d?h:bt*g,zt=j*b*_,er=!0,Hn=a.kernelCustomData.wT??a.compute(dt(e[1],Wc),{inputs:[1],outputs:[o.wIsConst?-2:-1]})[0];o.wIsConst&&!a.kernelCustomData.wT&&(a.kernelCustomData.wT=Hn);let Qt=[e[0],Hn],cr=e.length===3;cr&&(!d&&e[2].dims.length===1?Qt.push(e[2].reshape([e[2].dims[0],1,1])):Qt.push(e[2])),a.compute(Ks(Qt,s,c,Et,It,zt,cr,er),{inputs:Qt})},Gc=(a,e)=>{let o=e.format==="NHWC",s=[a.inputs[0].reshape(o?[a.inputs[0].dims[0],1,a.inputs[0].dims[1],a.inputs[0].dims[2]]:[a.inputs[0].dims[0],a.inputs[0].dims[1],1,a.inputs[0].dims[2]]),a.inputs[1].reshape([a.inputs[1].dims[0],a.inputs[1].dims[1],1,a.inputs[1].dims[2]])];s.length===3&&s.push(a.inputs[2]);let d=e.kernelShape;(d.length===0||d[0]===0)&&(d=[a.inputs[1].dims[2]]);let c=e.dilations;(c.length===0||c[0]===0)&&(c=[1]);let h=e.strides;(h.length===0||h[0]===0)&&(h=[1]);let _=e.pads;_.length===0&&(_=[0,0]),_=[0,_[0],0,_[1]],h=[1].concat(h),c=[1].concat(c),d=[1].concat(d);let bt=Xs({...e,pads:_,strides:h,dilations:c,kernelShape:d},s);a.compute(Ea(s,bt,g=>o?[g[0],g[2],g[3]]:[g[0],g[1],g[3]]))},Js=(a,e)=>{Nc(a.inputs,e),a.inputs[0].dims.length===3?Gc(a,e):Vc(a,a.inputs,e)}}),Hc,tu,ru,nu=F(()=>{ie(),_e(),Ye(),be(),Hc=(a,e,o,s)=>{let d=M.size(e),c=e.length,h=D("input",a,c),_=q("output",a,c),bt=o.dataType===6?o.getInt32Array()[0]:Number(o.getBigInt64Array()[0]),g=M.normalizeAxis(bt,c),j=b=>{let Et=` i32(${h.indicesGet("inputIndices","uniforms.axis")}) `,It=re("uniforms.input_shape","uniforms.axis",c),zt=s.reverse?Et+(s.exclusive?" + 1":""):"0",er=s.reverse?It:Et+(s.exclusive?"":" + 1");return`
                ${b.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(h,_)}
                ${b.mainStart()}
                  ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${_.offsetToIndices("global_idx")};
                  var sum = ${_.type.value}(0);
                  let first : i32 = ${zt};
                  let last : i32 = ${er};
                  for (var i : i32 = first; i < last; i++) {
                    ${h.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${h.getByIndices("inputIndices")};
                  }
                  ${_.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:s.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:e,dataType:a}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},{type:6,data:g},...K(e,e)]}),getShaderSource:j}},tu=(a,e)=>{let o=a.inputs[0].dims,s=a.inputs[0].dataType,d=a.inputs[1];a.compute(Hc(s,o,d,e),{inputs:[0]})},ru=a=>{let e=a.exclusive===1,o=a.reverse===1;return $e({exclusive:e,reverse:o})}}),Aa,An,au,Lc,Fc,Ta,Oa,iu,qc,ou,su,uu=F(()=>{ie(),_e(),Ye(),be(),Aa="[a-zA-Z]|\\.\\.\\.",An="("+Aa+")+",au="^"+An+"$",Lc="("+An+",)*"+An,Fc="^"+Lc+"$",Ta=class{constructor(a=-1){this.symbolToIndices=new Map,this.inputIndex=a}addSymbol(a,e){let o=this.symbolToIndices.get(a);o===void 0?o=[e]:o.push(e),this.symbolToIndices.set(a,o)}},Oa=class{constructor(a,e){var d;this.equation=e,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,s]=e.includes("->")?e.split("->",2):[e,""];if(!o.match(RegExp(Fc)))throw new Error("Invalid LHS term");if(o.split(",").forEach((c,h)=>{let _=a[h].dims.slice();if(!c.match(RegExp(au)))throw new Error("Invalid LHS term");let bt=this.processTerm(c,!0,_,h);this.lhs.push(bt)}),s==="")s+=[...this.symbolToInfo.entries()].filter(([c,h])=>h.count===1||c==="...").map(([c])=>c).join("");else if(!s.match(RegExp(An)))throw new Error("Invalid RHS");(d=s.match(RegExp(Aa,"g")))==null||d.forEach(c=>{if(c==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let h=this.symbolToInfo.get(c);if(h===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(h.dimValue)}}),this.rhs=this.processTerm(s,!1,this.outputDims)}addSymbol(a,e,o){let s=this.symbolToInfo.get(a);if(s!==void 0){if(s.dimValue!==e&&s.count!==1)throw new Error("Dimension mismatch");s.count++,s.inputIndices.push(o)}else s={count:1,dimValue:e,inputIndices:[o]};this.symbolToInfo.set(a,s)}processTerm(a,e,o,s=-1){let d=o.length,c=!1,h=[],_=0;if(!a.match(RegExp(au))&&!e&&a!=="")throw new Error("Invalid LHS term");let bt=a.match(RegExp(Aa,"g")),g=new Ta(s);return bt==null||bt.forEach((j,b)=>{if(j==="..."){if(c)throw new Error("Only one ellipsis is allowed per input term");c=!0;let Et=d-bt.length+1;if(Et<0)throw new Error("Ellipsis out of bounds");if(h=o.slice(_,_+Et),this.hasEllipsis){if(this.ellipsisDims.length!==h.length||this.ellipsisDims.toString()!==h.toString())throw new Error("Ellipsis dimensions mismatch")}else if(e)this.hasEllipsis=!0,this.ellipsisDims=h;else throw new Error("Ellipsis must be specified in the LHS");for(let It=0;It<h.length;It++){let zt=String.fromCharCode(48+It);g.addSymbol(zt,b+It),this.addSymbol(zt,o[_++],s)}}else g.addSymbol(j,b+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(j,o[_++],s)}),g}},iu=a=>a+"_max",qc=(a,e,o,s)=>{let d=a.map(g=>g.length).map((g,j)=>D(`input${j}`,e,g)),c=M.size(s),h=q("output",e,s.length),_=[...o.symbolToInfo.keys()].filter(g=>!o.rhs.symbolToIndices.has(g)),bt=g=>{let j=[],b="var prod = 1.0;",Et="var sum = 0.0;",It="sum += prod;",zt=[],er=[],Hn=[],Qt=[],cr=o.symbolToInfo.size===o.rhs.symbolToIndices.size;o.symbolToInfo.forEach((jr,e0)=>{var t0;if(o.rhs.symbolToIndices.has(e0)){let o0=(t0=o.rhs.symbolToIndices.get(e0))==null?void 0:t0[0];o0!==void 0&&o.lhs.forEach((l0,g0)=>{if(jr.inputIndices.includes(g0)){let i0=l0.symbolToIndices.get(e0);if(i0===void 0)throw new Error("Invalid symbol error");i0.forEach(f0=>{j.push(`${d[g0].indicesSet(`input${g0}Indices`,f0,h.indicesGet("outputIndices",o0))}`)})}})}else o.lhs.forEach((o0,l0)=>{if(jr.inputIndices.includes(l0)){let g0=o0.symbolToIndices.get(e0);if(g0===void 0)throw new Error("Invalid symbol error");g0.forEach(i0=>{zt.push(`${d[l0].indicesSet(`input${l0}Indices`,i0,`${e0}`)}`)}),Qt.push(`prod *= ${d[l0].getByIndices(`input${l0}Indices`)};`)}}),er.push(`for(var ${e0}: u32 = 0; ${e0} < uniforms.${iu(e0)}; ${e0}++) {`),Hn.push("}")});let fr=cr?[...j,`let sum = ${d.map((jr,e0)=>jr.getByIndices(`input${e0}Indices`)).join(" * ")};`]:[...j,Et,...er,...zt,b,...Qt,It,...Hn];return`
            ${g.registerUniforms(_.map(jr=>({name:`${iu(jr)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...d,h)}

            ${g.mainStart()}
            ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${h.offsetToIndices("global_idx")};
            ${d.map((jr,e0)=>`var input${e0}Indices: ${d[e0].type.indices};`).join(`
`)}
            ${fr.join(`
`)};
            ${h.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:o.equation,inputDependencies:a.map(()=>"rank")},getRunData:()=>{let g=_.filter(b=>o.symbolToInfo.has(b)).map(b=>{var Et;return{type:12,data:((Et=o.symbolToInfo.get(b))==null?void 0:Et.dimValue)||0}});g.push({type:12,data:c});let j=a.map((b,Et)=>[...K(b)]).reduce((b,Et)=>b.concat(Et),g);return j.push(...K(s)),{outputs:[{dims:s,dataType:e}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:j}},getShaderSource:bt}},ou=(a,e)=>{let o=new Oa(a.inputs,e.equation),s=o.outputDims,d=a.inputs.map((c,h)=>c.dims);a.compute(qc(d,a.inputs[0].dataType,o,s))},su=a=>{let e=a.equation.replace(/\s+/g,"");return $e({equation:e})}}),jc,lu,Kc,Yc,du,cu=F(()=>{ie(),_e(),be(),jc=a=>{if(!a||a.length!==2)throw new Error("Expand requires 2 input.");let e=a[0].dims,o=Array.from(a[1].getBigInt64Array(),Number),s=o.length<e.length?0:o.length-e.length,d=e.length<o.length?0:e.length-o.length;for(;s<o.length&&d<e.length;++s,++d)if(o[s]!==e[d]&&o[s]!==1&&e[d]!==1)throw new Error("Expand requires shape to be broadcastable to input")},lu=(a,e)=>{let o=a.length-e.length,s=[];for(let d=0;d<o;++d)s.push(a[d]);for(let d=0;d<e.length;++d)s.push(e[d]===1?a[d+o]:e[d]);return s},Kc=(a,e)=>a.length>e.length?lu(a,e):lu(e,a),Yc=a=>{let e=a[0].dims,o=Array.from(a[1].getBigInt64Array(),Number),s=Kc(e,o),d=a[0].dataType,c=d===9?4:1,h=Math.ceil(M.size(s)/c),_=g=>{let j=D("input",d,e.length,c),b=q("output",d,s.length,c),Et;if(d===9){let It=(zt,er,Hn="")=>`
          let outputIndices${er} = ${b.offsetToIndices(`outputOffset + ${er}u`)};
          let offset${er} = ${j.broadcastedIndicesToOffset(`outputIndices${er}`,b)};
          let index${er} = offset${er} / 4u;
          let component${er} = offset${er} % 4u;
          ${zt}[${er}] = ${Hn}(${j.getByOffset(`index${er}`)}[component${er}]);
        `;Et=`
        let outputOffset = global_idx * ${c};
        var data = vec4<u32>(0);
        ${It("data",0,"u32")}
        ${It("data",1,"u32")}
        ${It("data",2,"u32")}
        ${It("data",3,"u32")}
        ${b.setByOffset("global_idx","data")}
      }`}else Et=`
        let outputIndices = ${b.offsetToIndices("global_idx")};
        let inputOffset = ${j.broadcastedIndicesToOffset("outputIndices",b)};
        ${b.setByOffset("global_idx",j.getByOffset("inputOffset"))}
      }`;return`
    ${g.registerUniform("vec_size","u32").declareVariables(j,b)}
    ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${Et}`},bt=[{type:12,data:h},...K(e,s)];return{name:"Expand",shaderCache:{hint:`${s.length}`,inputDependencies:["rank"]},getShaderSource:_,getRunData:()=>({outputs:[{dims:s,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:bt})}},du=a=>{jc(a.inputs),a.compute(Yc(a.inputs),{inputs:[0]})}}),Zc,pu,fu=F(()=>{ie(),_e(),be(),$n(),Zc=a=>{let e=a[0].dataType,o=M.size(a[0].dims),s=M.size(a[1].dims),d=s%4===0,c=h=>{let _=D("x",e,[1],4),bt=D("bias",e,[1],4),g=q("y",e,[1],4),j=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],b=It=>`
      let bias${It}_offset: u32 = (global_idx * 4 + ${It}) % uniforms.bias_size;
      let bias${It} = ${bt.getByOffset(`bias${It}_offset / 4`)}[bias${It}_offset % 4];`,Et=d?`
      let bias = ${bt.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${b(0)}${b(1)}${b(2)}${b(3)}
      let bias = ${_.type.value}(bias0, bias1, bias2, bias3);`;return`${h.registerUniforms(j).declareVariables(_,bt,g)}

    ${ya(at(e))}

    ${h.mainStart(mn)}
      ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${_.getByOffset("global_idx")};
      ${Et}
      let x_in = x + bias;
      ${g.setByOffset("global_idx",ba("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${d}`,inputDependencies:["type","type"]},getShaderSource:c,getRunData:h=>({outputs:[{dims:h[0].dims,dataType:h[0].dataType}],programUniforms:[{type:12,data:Math.ceil(o/4)},{type:12,data:s}],dispatchGroup:{x:Math.ceil(o/mn/4)}})}},pu=a=>{a.inputs.length<2||M.size(a.inputs[1].dims)===0?$s(a):a.compute(Zc(a.inputs))}}),Xc,Qc,mu,hu,gu=F(()=>{ie(),_e(),Ye(),be(),Xc=a=>{if(!a||a.length!==2)throw new Error("Gather requires 2 inputs.")},Qc=(a,e)=>{let o=a[0].dims,s=a[1].dims,d=o.length,c=M.normalizeAxis(e.axis,d),h=o.slice(0);h.splice(c,1,...s);let _=o[c],bt=a[0].dataType===9?4:1,g=Math.ceil(M.size(h)/bt),j=[{type:12,data:g},{type:6,data:_},{type:12,data:c},...K(a[0].dims,a[1].dims,h)],b=Et=>{let It=D("data",a[0].dataType,a[0].dims.length,bt),zt=D("inputIndices",a[1].dataType,a[1].dims.length),er=q("output",a[0].dataType,h.length,bt),Hn=cr=>{let fr=s.length,jr=`var indicesIndices${cr}  = ${zt.type.indices}(0);`;for(let e0=0;e0<fr;e0++)jr+=`${fr>1?`indicesIndices${cr}[${e0}]`:`indicesIndices${cr}`} = ${h.length>1?`outputIndices${cr}[uniforms.axis + ${e0}]`:`outputIndices${cr}`};`;jr+=`
          var idx${cr} = ${zt.getByIndices(`indicesIndices${cr}`)};
          if (idx${cr} < 0) {
            idx${cr} = idx${cr} + uniforms.axisDimLimit;
          }
          var dataIndices${cr} : ${It.type.indices};
        `;for(let e0=0,t0=0;e0<d;e0++)e0===c?(jr+=`${d>1?`dataIndices${cr}[${e0}]`:`dataIndices${cr}`} = u32(idx${cr});`,t0+=fr):(jr+=`${d>1?`dataIndices${cr}[${e0}]`:`dataIndices${cr}`} = ${h.length>1?`outputIndices${cr}[${t0}]`:`outputIndices${cr}`};`,t0++);return jr},Qt;if(a[0].dataType===9){let cr=(fr,jr,e0="")=>`
          let outputIndices${jr} = ${er.offsetToIndices(`outputOffset + ${jr}u`)};
          ${Hn(jr)};
          let offset${jr} = ${It.indicesToOffset(`dataIndices${jr}`)};
          let index${jr} = offset${jr} / 4u;
          let component${jr} = offset${jr} % 4u;
          ${fr}[${jr}] = ${e0}(${It.getByOffset(`index${jr}`)}[component${jr}]);
        `;Qt=`
        let outputOffset = global_idx * ${bt};
        var value = vec4<u32>(0);
        ${cr("value",0,"u32")}
        ${cr("value",1,"u32")}
        ${cr("value",2,"u32")}
        ${cr("value",3,"u32")}
        ${er.setByOffset("global_idx","value")}
      `}else Qt=`
      let outputIndices = ${er.offsetToIndices("global_idx")};
      ${Hn("")};
      let value = ${It.getByIndices("dataIndices")};
      ${er.setByOffset("global_idx","value")};
      `;return`
      ${Et.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(It,zt,er)}
      ${Et.mainStart()}
        ${Et.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${Qt}
      }`};return{name:"Gather",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:h,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:j}),getShaderSource:b}},mu=a=>$e({axis:a.axis}),hu=(a,e)=>{let o=a.inputs;Xc(o),a.compute(Qc(a.inputs,e))}}),Jc,ep,yu,bu,wu=F(()=>{ie(),_e(),Ye(),be(),Jc=a=>{if(!a||a.length!==2)throw new Error("GatherElements requires 2 inputs.");if(a[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(a[0].dims.length!==a[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},ep=(a,e)=>{let o=a[0].dims,s=a[0].dataType,d=o.length,c=a[1].dims,h=a[1].dataType,_=M.normalizeAxis(e.axis,d),bt=o[_],g=c.slice(0),j=M.size(g),b=D("input",s,d),Et=D("indicesInput",h,c.length),It=q("output",s,g.length),zt=[{type:12,data:j},{type:6,data:bt},{type:12,data:_}];return zt.push(...K(o,c,g)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:g,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(j/64)},programUniforms:zt}),getShaderSource:er=>`
      ${er.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(b,Et,It)}
      ${er.mainStart()}
      ${er.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${It.offsetToIndices("global_idx")};

      var idx = ${Et.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${b.type.indices}(outputIndices);
      ${b.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${b.getByIndices("inputIndices")};

      ${It.setByOffset("global_idx","value")};
  }`}},yu=a=>$e({axis:a.axis}),bu=(a,e)=>{let o=a.inputs;Jc(o),a.compute(ep(a.inputs,e))}}),tp,rp,vu,$u,_u=F(()=>{ie(),_e(),be(),tp=a=>{if(!a)throw new Error("Input is missing");if(a.length<2||a.length>3)throw new Error("Invaid input number.");if(a.length===3&&a[2].dims.length>2)throw new Error("Invalid input shape of C");if(a[0].dataType!==a[1].dataType||a.length===3&&a[0].dataType!==a[2].dataType)throw new Error("Input types are mismatched")},rp=(a,e)=>{let o=a[0].dims.slice(),s=a[1].dims.slice(),[d,c,h]=cn.getShapeOfGemmResult(o,e.transA,s,e.transB,a.length===3?a[2].dims:void 0),_=[d,c];if(!_)throw new Error("Can't use gemm on the given tensors");let bt=M.size(_),g=[{type:12,data:bt},{type:12,data:d},{type:12,data:c},{type:12,data:h},{type:1,data:e.alpha},{type:1,data:e.beta}],j=["type","type"];a.length===3&&(g.push(...K(a[2].dims)),j.push("rank")),g.push(...K(_));let b=Et=>{let It="";e.transA&&e.transB?It="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":e.transA&&!e.transB?It="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!e.transA&&e.transB?It="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!e.transA&&!e.transB&&(It="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let zt=e.alpha===1?"":"value *= uniforms.alpha;",er=D("a",a[0].dataType,a[0].dims),Hn=D("b",a[1].dataType,a[1].dims),Qt=er.type.value,cr=null,fr=[er,Hn];a.length===3&&(cr=D("c",a[2].dataType,a[2].dims.length),fr.push(cr));let jr=q("output",a[0].dataType,_.length);fr.push(jr);let e0=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${Et.registerUniforms(e0).declareVariables(...fr)}

  ${Et.mainStart()}
    ${Et.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${Qt}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${It}
    }

    ${zt}
    ${cr!=null?`let cOffset = ${cr.broadcastedIndicesToOffset("vec2(m, n)",jr)}; value += ${Qt}(uniforms.beta) * ${cr.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`};return{name:"Gemm",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:j},getRunData:()=>({outputs:[{dims:_,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(bt/64)},programUniforms:g}),getShaderSource:b}},vu=a=>{let e=a.transA,o=a.transB,s=a.alpha,d=a.beta;return{transA:e,transB:o,alpha:s,beta:d,cacheKey:`${a.transA};${a.transB};${a.alpha===1}`}},$u=(a,e)=>{tp(a.inputs),a.compute(rp(a.inputs,e))}}),np,ap,ip,xu,Su=F(()=>{ie(),_e(),be(),np=(a,e)=>{let o=a[0].dims,s=o,d=2,c=M.sizeToDimension(o,d),h=M.sizeFromDimension(o,d),_=Me(h),bt=h/_,g=[o[0],o[1],bt],j=["rank","type","type"],b=[{type:12,data:h},{type:12,data:bt}];b.push(...K(g,g));let Et=It=>{let zt=D("x",a[0].dataType,g.length,_),er=D("scale",a[1].dataType,a[1].dims),Hn=D("bias",a[2].dataType,a[2].dims),Qt=q("output",a[0].dataType,g.length,_),cr=[zt,er,Hn,Qt],fr=zt.type.value,jr=_===1?"f32":`vec${_}<f32>`,e0=64,t0=[{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}];return`
  var<workgroup> meanShared : f32;
  var<workgroup> squaredNormShared : f32;
  var<workgroup> workgroupShared : array<${jr}, ${e0}>;
  const workgroupSize = ${e0}u;
  ${It.registerUniforms(t0).declareVariables(...cr)}
  ${It.mainStart(e0)}
    let norm = global_idx / workgroupSize;
    let batch = norm / uniforms.x_shape[1];
    let channel = norm % uniforms.x_shape[1];
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial = ${jr}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      initial = initial + ${jr}(${zt.get("batch","channel","h")});
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = ${it("workgroupShared[0]",_)} / f32(uniforms.normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = ${jr}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let deviation =  ${jr}(${zt.get("batch","channel","h")}) - ${jr}(meanShared);
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = ${it("workgroupShared[0]",_)};
    }
    workgroupBarrier();

    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${e.epsilon}));
    let channelScale = invStdDev * f32(${er.getByOffset("channel")});
    let channelShift = f32(${Hn.getByOffset("channel")}) - meanShared * channelScale;
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let value = ${zt.get("batch","channel","h")} * ${fr}(${jr}(channelScale)) + ${fr}(${jr}(channelShift));
      ${Qt.set("batch","channel","h","value")};
    }
  }`};return{name:"InstanceNormalization",shaderCache:{hint:`${e.epsilon};${_}`,inputDependencies:j},getRunData:()=>({outputs:[{dims:s,dataType:a[0].dataType}],dispatchGroup:{x:c},programUniforms:b}),getShaderSource:Et}},ap=(a,e,o,s,d,c,h,_)=>{let bt=Me(h),g=64,j=bt===1?"vec2f":`mat2x${bt}f`,b=bt===1?"f32":`vec${bt}f`,Et=(t0,o0)=>`${j}(${t0}, ${o0})`,It=d*h/bt,zt=Math.ceil(c/g),er=["type"],Hn=[{type:12,data:zt},{type:12,data:c},{type:12,data:Math.floor(h/bt)},{type:12,data:Math.floor(c*h/bt)}],Qt=t0=>{let o0=D("input",e.dataType,e.dims,bt);return`
  ${t0.declareVariables(o0)}
  @group(0) @binding(1) var<storage, read_write> output : array<${j}>;
  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};
  @group(0) @binding(2) var<uniform> uniforms: Uniforms;

  ${t0.mainStart(g)}
    let currentImageNumber = global_idx / ${g} / uniforms.C;
    let currentChannelNumber = (global_idx / ${g}) % uniforms.C;
    let wgId = global_idx % ${g};
    let wgOffset = wgId * uniforms.wg_size;
    if (wgOffset >= uniforms.H) {
        return;
    }
    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);

    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;
    var sum = ${Xe("f32",bt)};
    var squaredSum = ${Xe("f32",bt)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${b}(input[offset + i * uniforms.C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${Et("sum","squaredSum")};
  }`},cr=a.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${bt}`,inputDependencies:er},getRunData:()=>({outputs:[{dims:[d,h,g,2],dataType:1}],dispatchGroup:{x:d*h/bt},programUniforms:Hn}),getShaderSource:Qt},{inputs:[e],outputs:[-1]})[0],fr=[{type:12,data:It},{type:12,data:c},{type:12,data:Math.floor(h/bt)},{type:12,data:Math.floor(g*h/bt)}],jr=["type","type","type"],e0=t0=>{let o0=D("scale",o.dataType,o.dims,bt),l0=D("bias",s.dataType,s.dims,bt);return`
  @group(0) @binding(0) var<storage, read> input : array<${j}>;
  @group(0) @binding(1) var<storage, read> scale : array<${o0.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${l0.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${j}>;
  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};
  @group(0) @binding(4) var<uniform> uniforms: Uniforms;

  ${t0.mainStart()}
    ${t0.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}
    let currentImageNumber = global_idx / uniforms.C;
    let currentChannelNumber = global_idx % uniforms.C;

    let offset = currentImageNumber * uniforms.image_size;
    var sum = ${Xe("f32",bt)};
    var squaredSum = ${Xe("f32",bt)};
    for (var i: u32 = 0; i < min(${g}, uniforms.H); i++) {
        let value = input[offset + i + currentChannelNumber * ${g}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(uniforms.H);
    squaredSum = squaredSum / f32(uniforms.H);
    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${_}));
    let channelScale = invStdDev * ${b}(scale[currentChannelNumber]);
    let channelShift = ${b}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${Et("channelScale","channelShift")};
  }`};return a.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${bt};${_}`,inputDependencies:jr},getRunData:()=>({outputs:[{dims:[d,h,2],dataType:1}],dispatchGroup:{x:Math.ceil(It/64)},programUniforms:fr}),getShaderSource:e0},{inputs:[cr,o,s],outputs:[-1]})[0]},ip=(a,e,o)=>{let s=e[0].dims,d=s,c=s[0],h=s[s.length-1],_=M.sizeFromDimension(s,1)/h,bt=Me(h),g=M.size(d)/bt,j=[{type:12,data:_},{type:12,data:Math.floor(h/bt)}],b=["type","type"],Et=ap(a,e[0],e[1],e[2],c,_,h,o.epsilon),It=zt=>{let er=ke(e[0].dataType),Hn=bt===1?"vec2f":`mat2x${bt}f`,Qt=bt===1?er:`vec${bt}<${er}>`,cr=D("input",e[0].dataType,e[0].dims,bt),fr=q("output",e[0].dataType,d,bt);return`
  @group(0) @binding(0) var<storage, read> input : array<${cr.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${Hn}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${fr.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${zt.mainStart()}
    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);
    let currentChannelNumber = global_idx % uniforms.C;

    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${Qt}(scale[0]), ${Qt}(scale[1]));
  }`};a.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${bt}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:j}),getShaderSource:It},{inputs:[e[0],Et]})},xu=(a,e)=>{e.format==="NHWC"?ip(a,a.inputs,e):a.compute(np(a.inputs,e))}}),op,sp,Cu,Iu=F(()=>{ie(),_e(),be(),op=a=>{if(!a||a.length<2)throw new Error("layerNorm requires at least 2 inputs.")},sp=(a,e,o)=>{let s=a[0].dims,d=a[1],c=a[2],h=s,_=M.normalizeAxis(e.axis,s.length),bt=M.sizeToDimension(s,_),g=M.sizeFromDimension(s,_),j=M.size(d.dims),b=c?M.size(c.dims):0;if(j!==g||c&&b!==g)throw new Error(`Size of X.shape()[axis:] == ${g}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${j} and bias size of ${b}`);let Et=[];for(let jr=0;jr<s.length;++jr)jr<_?Et.push(s[jr]):Et.push(1);let It=Me(g),zt=["type","type"],er=[{type:12,data:bt},{type:1,data:g},{type:12,data:Math.floor(g/It)},{type:1,data:e.epsilon}];c&&zt.push("type");let Hn=o>1,Qt=o>2,cr=jr=>{let e0=ke(a[0].dataType),t0=[D("x",a[0].dataType,a[0].dims,It),D("scale",d.dataType,d.dims,It)];c&&t0.push(D("bias",c.dataType,c.dims,It)),t0.push(q("output",a[0].dataType,h,It)),Hn&&t0.push(q("mean_data_output",1,Et)),Qt&&t0.push(q("inv_std_output",1,Et));let o0=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${jr.registerUniforms(o0).declareVariables(...t0)}
  ${jr.mainStart()}
    ${jr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${Xe("f32",It)};
    var mean_square_vector = ${Xe("f32",It)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${mt(e0,It,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${it("mean_vector",It)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${it("mean_square_vector",It)} / uniforms.norm_size - mean * mean + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${mt(e0,It,"x[j + offset]")};
      let f32scale = ${mt(e0,It,"scale[j]")};
      output[j + offset] = ${t0[0].type.value}((f32input - mean) * inv_std_dev * f32scale
        ${c?`+ ${mt(e0,It,"bias[j]")}`:""}
      );
    }

    ${Hn?"mean_data_output[global_idx] = mean":""};
    ${Qt?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},fr=[{dims:h,dataType:a[0].dataType}];return Hn&&fr.push({dims:Et,dataType:1}),Qt&&fr.push({dims:Et,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${It};${o}`,inputDependencies:zt},getRunData:()=>({outputs:fr,dispatchGroup:{x:Math.ceil(bt/64)},programUniforms:er}),getShaderSource:cr}},Cu=(a,e)=>{op(a.inputs),a.compute(sp(a.inputs,e,a.outputCount))}}),up,lp,Eu,Au,Tu=F(()=>{ie(),_e(),Ye(),be(),up=(a,e)=>{if(a.length<3||a.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let o=a[0],s=o.dims.length;if(o.dims[s-1]!==e.k)throw new Error("The last dim of input shape does not match the k value");let d=Math.floor((e.k+e.blockSize-1)/e.blockSize),c=e.blockSize/8*e.bits,h=a[1];if(!M.areEqual(h.dims,[e.n,d,c]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let _=a[2].dims;if(M.size(_)!==e.n*d)throw new Error("scales input size error.");if(a.length===4){let bt=a[3].dims,g=e.bits>4?e.n*d:e.n*Math.floor((d+1)/2);if(M.size(bt)!==g)throw new Error("zeroPoints input size error.")}},lp=(a,e)=>{let o=a[0].dims,s=o.length,d=o.slice(0,s-1).concat(e.n),c=o[s-2],h=e.blockSize/8*e.bits/4,_=Me(c),bt=Me(e.n),g=Me(e.k),j=Me(h),b=M.size(d)/bt/_,Et=[{type:12,data:b},{type:12,data:e.k},{type:12,data:e.n},{type:12,data:e.accuracyLevel},{type:12,data:e.bits},{type:12,data:e.blockSize}],It=o.slice();It.splice(-1,1,e.k/g);let zt=M.convertShape(a[1].dims).slice();zt.splice(-1,1,h/j),Et.push(...K(It)),Et.push(...K(zt)),Et.push(...K(a[2].dims)),a.length===4&&Et.push(...K(M.convertShape(a[3].dims)));let er=d.slice();er.splice(-1,1,e.n/bt),Et.push(...K(er));let Hn=Qt=>{let cr=D("a",a[0].dataType,It.length,g),fr=D("b",12,zt.length,j),jr=D("scales",a[2].dataType,a[2].dims.length),e0=[cr,fr,jr],t0=a.length===4?D("zero_points",12,a[3].dims.length):void 0;t0&&e0.push(t0);let o0=q("output",a[0].dataType,d.length,bt),l0=[{name:"output_size",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"accuracy_level",type:"u32"},{name:"bits",type:"u32"},{name:"block_size",type:"u32"}],g0=Math.floor((e.k+e.blockSize-1)/e.blockSize),i0=ke(a[0].dataType),f0=(()=>{switch(g){case 1:return`array<${i0}, 8>`;case 2:return`mat4x2<${i0}>`;case 4:return`mat2x4<${i0}>`;default:throw new Error(`${g}-component is not supported.`)}})(),C0=`
        fn dequantize(quantized: ${f0}, zero_point: ${i0}, scale: ${i0}) -> ${f0} {
          ${g===1?`var dequantized = ${f0}(${Array.from({length:8},(Y0,H0)=>`(quantized[${H0}] - zero_point) * scale`).join(", ")});
              return dequantized;`:`var zero_points: ${f0} = ${f0}(${Array(8).fill("zero_point").join(",")});
              return (quantized - zero_points) * scale;`}
        }`,Z0=`
        fn ortUnpack8x4snorm(value: u32) -> ${f0} {
          var quantized: ${f0};
          var offset: u32 = 0;
          let count: u32 = 4;
          for (var i: u32 = 0; i < 8u; i++) {
            var result = ${i0}(extractBits(value, offset, count));
            ${(()=>{switch(g){case 1:return"quantized[i] = result;";case 2:return"quantized[i / 2][i % 2] = result;";case 4:return"quantized[i / 4][i % 4] = result;";default:throw new Error(`${g}-component is not supported.`)}})()}
            offset += count;
          }
          return quantized;
        }`,R0=t0?`
          zero_point_offset += 4;
          if (zero_point_offset == 32) {
            zero_point_offset = 0;
            zero_point_index++;
            zero_point_word = ${t0.getByOffset("zero_point_index")};
          }`:"";return`
        ${C0};
        ${Z0};
        ${Qt.registerUniforms(l0).declareVariables(...e0,o0)}
        ${Qt.mainStart()}
          ${Qt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var output_values: array<${o0.type.value}, ${_}>;
          var output_indices = ${o0.offsetToIndices("global_idx")};
          var n = ${o0.indicesGet("output_indices",s-1)};
          var m = ${o0.indicesGet("output_indices",s-2)};
          var a_indices: ${cr.type.indices} = output_indices;
          // Two zero points are packed into one byte because uniforms.bits <= 4.
          // zero_point_offset is either 0 or 4. It is bit offset within one byte.
          // TODO support zero_point_offset for bits > 4
          ${t0?`
          var zero_point_index: u32 = n * ${bt} * ((${g0} + 1) / 2) / 4;
          var zero_point_word: u32 = ${t0.getByOffset("zero_point_index")};
          var zero_point_offset: u32 = 0;`:""}
          var scale_index = n * ${g0*bt};
          var b_indices: ${fr.type.indices};
          for (var c: u32 = 0; c < ${bt}; c++) {
            ${fr.indicesSet("b_indices","0",`n * ${bt} + c`)};
            var block_offset: u32 = 0;
            for (var block: u32 = 0; block < ${g0}; block++) {
              // The scale and zero points are computed per block.
              let scale = ${jr.getByOffset("scale_index")};
              // The default zero point is 8 for unsigned 4-bit quantization.
              let zero_point = ${i0}(${t0?"extractBits(zero_point_word, zero_point_offset, 4)":8});
              ${fr.indicesSet("b_indices","1","block")};
              var word_offset: u32 = block_offset;
              for (var word: u32 = 0; word < ${h}; word += ${j}) {
                ${fr.indicesSet("b_indices","2","word")};
                let b_data = ${fr.getByIndices("b_indices")};
                for (var i: u32 = 0; i < ${j}; i++) {
                  let b_value = ${j===1?"b_data":"b_data[word + i]"};
                  let b_quantized_values: ${f0} = ortUnpack8x4snorm(b_value);
                  let b_dequantized_values = dequantize(b_quantized_values, zero_point, scale);
                  // Number of B elements per 32-bit word is 32/bits = 32/4 = 8
                  var offset: u32 = word_offset;
                  for (var j: u32 = 0; j < 8/${g}; j++) {
                    ${cr.indicesSet("a_indices",s-1,`offset/${g}`)};
                    for (var k: u32 = 0; k < ${_}u; k++) {
                      ${cr.indicesSet("a_indices",s-2,`m * ${_} + k`)};
                      let a_data = ${cr.getByIndices("a_indices")};
                      output_values[k]${bt>1?"[c]":""} += ${g===1?"a_data * b_dequantized_values[j]":"dot(a_data, b_dequantized_values[j])"};
                    }
                    offset += ${g};
                  }
                  word_offset += 8;
                }
              }
              scale_index++;
              ${R0}
              block_offset += uniforms.block_size;
            }
            // Drop the trailing 4 bits if the zero_poit_offset is not a byte boundary to align with the next byte.
            ${t0?`if (zero_point_offset % 8 > 0) {
                ${R0}
              }`:""}
            }
            for (var k: u32 = 0u; k < ${_}u; k++) {
              ${o0.indicesSet("output_indices",s-2,`${_+" * m + k"}`)};
              ${o0.setByIndices("output_indices","output_values[k]")}
            }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${e.cacheKey};${a.length}`,inputDependencies:Array(a.length).fill("rank")},getRunData:()=>({outputs:[{dims:d,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:Et}),getShaderSource:Hn}},Eu=(a,e)=>{up(a.inputs,e),a.compute(lp(a.inputs,e))},Au=a=>$e(a)}),dp,ku,Ou,cp,ka,Pu,Ru=F(()=>{ie(),_e(),Ye(),ln(),ga(),be(),ir(),dp=(a,e)=>{let o=a[0],s=a[1],d=a[2],c=a[3],h=a[4],_=a[5],bt=a[6],g=a[7];if(o.dims.length!==3&&o.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let j=!1,b=o.dims[0],Et=o.dims[1],It=o.dims.length===3?j?o.dims[2]/3:o.dims[2]:e.numHeads*o.dims[4],zt=Et,er=0,Hn=0,Qt=Math.floor(It/e.numHeads);if(bt&&g){if(bt.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(g.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');er=bt.dims[2],Hn=bt.dims[2]}else if(bt||g)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let cr;if(s){if(o.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(s.dims.length<3||s.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(o.dims[0]!==s.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(s.dims.length===3){if(s.dims[2]!==o.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');cr=2,zt=s.dims[1]}else if(s.dims.length===5){if(s.dims[2]!==e.numHeads||s.dims[3]!==2||s.dims[4]!==Qt)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(d)throw new Error('Expect "value" be none when "key" has packed kv format.');cr=5,zt=s.dims[1]}else{if(s.dims[1]!==e.numHeads||s.dims[3]!==Qt)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');cr=0,zt=s.dims[2]}}else{if(o.dims.length!==3&&o.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(o.dims.length===5&&(o.dims[2]!==e.numHeads||o.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');cr=3}if(c){if(c.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(d&&o.dims.length===5&&o.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let fr=0;if(h){fr=8;let l0=h.dims;throw l0.length===1?l0[0]===b?fr=1:l0[0]===3*b+2&&(fr=3):l0.length===2&&l0[0]===b&&l0[1]===zt&&(fr=5),fr===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)'):new Error("Mask not supported")}let jr=!1,e0=It;if(d){if(d.dims.length!==3&&d.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(o.dims[0]!==d.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(d.dims.length===3){if(zt!==d.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');e0=d.dims[2]}else{if(zt!==d.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');e0=d.dims[1]*d.dims[3],jr=!0}}let t0=er+zt,o0=!1;if(h)throw new Error("Key padding mask is not supported");if(_)throw new Error("extraAddQk is not supported");if(bt)throw new Error("pastKey is not supported");if(g)throw new Error("pastValue is not supported");return{batchSize:b,sequenceLength:Et,pastSequenceLength:er,kvSequenceLength:zt,totalSequenceLength:t0,maxSequenceLength:Hn,inputHiddenSize:0,hiddenSize:It,vHiddenSize:e0,headSize:Qt,vHeadSize:Math.floor(e0/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:fr,scale:e.scale,broadcastResPosBias:o0,passPastInKv:jr,qkvFormat:cr}},ku=a=>$e({...a}),Ou=$e({perm:[0,2,1,3]}),cp=(a,e,o,s,d,c,h)=>{let _=[s,d,c],bt=M.size(_),g=[{type:12,data:bt},{type:12,data:h},{type:12,data:c}],j=b=>{let Et=q("qkv_with_bias",e.dataType,_),It=D("qkv",e.dataType,_),zt=D("bias",o.dataType,_),er=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${b.registerUniforms(er).declareVariables(It,zt,Et)}
  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return a.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:_,dataType:e.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(bt/64)},programUniforms:g}),getShaderSource:j},{inputs:[e,o],outputs:[-1]})[0]},ka=(a,e,o,s,d,c,h,_)=>{let bt=c;if(h){if(s===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return bt=cp(a,c,h,e,s,o*d,_),bt=bt.reshape([e,s,o,d]),a.compute(dt(bt,Ou.perm),{inputs:[bt],outputs:[-1]})[0]}else return c.dims.length===3&&(bt=c.reshape([e,s,o,d])),a.compute(dt(bt,Ou.perm),{inputs:[bt],outputs:[-1]})[0]},Pu=(a,e)=>{var _;let o=dp(a.inputs,e);if(a.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(((_=a.inputs[1])==null?void 0:_.dims.length)===5)throw new Error("Packed KV is not implemented");let s=a.inputs[1]&&a.inputs[2]&&a.inputs[1].dims.length===4&&a.inputs[2].dims.length===4,d=ka(a,o.batchSize,o.numHeads,o.sequenceLength,o.headSize,a.inputs[0],a.inputs[3],0);if(s)return bn(a,d,a.inputs[1],a.inputs[2],a.inputs[4],void 0,void 0,void 0,a.inputs[5],o,e);let c=ka(a,o.batchSize,o.numHeads,o.kvSequenceLength,o.headSize,a.inputs[1],a.inputs[3],o.hiddenSize),h=ka(a,o.batchSize,o.numHeads,o.kvSequenceLength,o.vHeadSize,a.inputs[2],a.inputs[3],2*o.hiddenSize);bn(a,d,c,h,a.inputs[4],void 0,a.inputs[6],a.inputs[7],a.inputs[5],o,e)}}),pp,fp,mp,hp,gp,yp,bp,wp,zu,Bu=F(()=>{ie(),_e(),be(),pp=a=>{if(!a||a.length<1)throw new Error("Too few inputs");if(a[0].dataType!==1&&a[0].dataType!==10)throw new Error("Input type must be float or float16.");if(a.length>=2){let e=a[0].dims.length*2===a[1].dims[0];if(a.length===4&&(e=a[3].dims[0]*2===a[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},fp=(a,e,o)=>{let s="";for(let d=e-1;d>=0;--d)s+=`
            k = i32(${a.indicesGet("indices",d)}) - ${re("uniforms.pads",d,o)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${re("uniforms.x_shape",d,e)})) {
              break;
            }
            offset += k * i32(${re("uniforms.x_strides",d,e)});
        `;return`
          value = ${a.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${s}
            value = x[offset];
          }
      `},mp=(a,e,o)=>{let s="";for(let d=e-1;d>=0;--d)s+=`
                k = i32(${a.indicesGet("indices",d)}) - ${re("uniforms.pads",d,o)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${re("uniforms.x_shape",d,e)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${re("uniforms.x_shape",d,e)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${re("uniforms.x_strides",d,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},hp=(a,e,o)=>{let s="";for(let d=e-1;d>=0;--d)s+=`
                k = i32(${a.indicesGet("indices",d)}) - ${re("uniforms.pads",d,o)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${re("uniforms.x_shape",d,e)})) {
                  k = i32(${re("uniforms.x_shape",d,e)}) - 1;
                }
                offset += k * i32(${re("uniforms.x_strides",d,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},gp=(a,e,o)=>{let s="";for(let d=e-1;d>=0;--d)s+=`
                k = i32(${a.indicesGet("indices",d)}) - ${re("uniforms.pads",d,o)};
                if (k < 0)  {
                  k += i32(${re("uniforms.x_shape",d,e)}]);
                }
                if (k >= i32(${re("uniforms.x_shape",d,e)})) {
                  k -= i32(${re("uniforms.x_shape",d,e)});
                }
                offset += k * i32(${re("uniforms.x_strides",d,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},yp=(a,e,o)=>{switch(o.mode){case 0:return fp(a,e,o.pads.length);case 1:return mp(a,e,o.pads.length);case 2:return hp(a,e,o.pads.length);case 3:return gp(a,e,o.pads.length);default:throw new Error("Invalid mode")}},bp=(a,e)=>{let o=M.padShape(a[0].dims.slice(),e.pads),s=a[0].dims,d=M.size(o),c=[{type:12,data:d},{type:12,data:e.pads}];e.mode===0&&c.push({type:a[0].dataType,data:e.value}),c.push(...K(a[0].dims,o));let h=["rank"],_=bt=>{let g=q("output",a[0].dataType,o.length),j=D("x",a[0].dataType,s.length),b=j.type.value,Et=yp(g,s.length,e),It=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:e.pads.length}];return e.mode===0&&It.push({name:"constant_value",type:b}),`
            ${bt.registerUniforms(It).declareVariables(j,g)}
            ${bt.mainStart()}
            ${bt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${g.offsetToIndices("global_idx")};

            var value = ${b}(0);
            ${Et}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${e.mode}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:o,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(o)/64)},programUniforms:c}),getShaderSource:_}},wp=(a,e)=>{if(a.length>1){let o=a[1].getBigInt64Array(),s=a.length>=3&&a[2].data?a[2].getFloat32Array()[0]:0,d=a[0].dims.length,c=new Int32Array(2*d).fill(0);if(a.length>=4){let _=a[3].getBigInt64Array();for(let bt=0;bt<_.length;bt++)c[Number(_[bt])]=Number(o[bt]),c[Number(_[bt])+d]=Number(o[bt+_.length])}else o.forEach((_,bt)=>c[Number(bt)]=Number(_));let h=[];return c.forEach(_=>h.push(_)),{mode:e.mode,value:s,pads:h}}else return e},zu=(a,e)=>{pp(a.inputs);let o=wp(a.inputs,e);a.compute(bp(a.inputs,o),{inputs:[0]})}}),Tn,Du,Mu,Uu,Nu,vp,$p,Wu,Vu,Gu,Hu,Lu,Fu,qu,ju,Ku,Yu,Zu,Xu,Qu=F(()=>{lt(),ie(),_e(),be(),Tn=a=>{if(Ae.webgpu.validateInputContent&&(!a||a.length!==1))throw new Error("Pool ops requires 1 input.")},Du=(a,e,o)=>{let s=e.format==="NHWC",d=a.dims.slice();s&&d.splice(1,0,d.pop());let c=Object.hasOwnProperty.call(e,"dilations"),h=e.kernelShape.slice(),_=e.strides.slice(),bt=c?e.dilations.slice():[],g=e.pads.slice();qt.adjustPoolAttributes(o,d,h,_,bt,g);let j=qt.computePoolOutputShape(o,d,_,bt,h,g,e.autoPad),b=Object.assign({},e);c?Object.assign(b,{kernelShape:h,strides:_,pads:g,dilations:bt,cacheKey:e.cacheKey}):Object.assign(b,{kernelShape:h,strides:_,pads:g,cacheKey:e.cacheKey});let Et=j.slice();return Et.push(Et.splice(1,1)[0]),[b,s?Et:j]},Mu=(a,e)=>{let o=e.format==="NHWC",s=M.size(a),d=M.size(e.kernelShape),c=[{type:12,data:s},{type:12,data:d}],h=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(e.kernelShape.length<=2){let _=e.kernelShape[e.kernelShape.length-1],bt=e.strides[e.strides.length-1],g=e.pads[e.pads.length/2-1],j=e.pads[e.pads.length-1],b=!!(g+j);c.push({type:12,data:_},{type:12,data:bt},{type:12,data:g},{type:12,data:j}),h.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let Et=!1;if(e.kernelShape.length===2){let It=e.kernelShape[e.kernelShape.length-2],zt=e.strides[e.strides.length-2],er=e.pads[e.pads.length/2-2],Hn=e.pads[e.pads.length-2];Et=!!(er+Hn),c.push({type:12,data:It},{type:12,data:zt},{type:12,data:er},{type:12,data:Hn}),h.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[c,h,!0,b,Et]}else{if(o)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let _=M.computeStrides(e.kernelShape);c.push({type:12,data:_},{type:12,data:e.pads},{type:12,data:e.strides}),h.push({name:"kernelStrides",type:"u32",length:_.length},{name:"pads",type:"u32",length:e.pads.length},{name:"strides",type:"u32",length:e.strides.length});let bt=e.pads.reduce((g,j)=>g+j);return[c,h,!!bt,!1,!1]}},Uu=(a,e,o,s,d,c,h,_,bt,g,j,b)=>{let Et=d.format==="NHWC",It=e.type.value,zt=q("output",e.type.tensor,s);if(d.kernelShape.length<=2){let er="",Hn="",Qt="",cr=o-(Et?2:1);if(j?er=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${cr}] = indices[${cr}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${cr}] < 0 || xIndices[${cr}]
                      >= uniforms.x_shape[${cr}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${c}
                }`:er=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${cr}] = indices[${cr}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${c}
                }`,d.kernelShape.length===2){let fr=o-(Et?3:2);b?Hn=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${fr}] = indices[${fr}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${fr}] < 0 || xIndices[${fr}] >= uniforms.x_shape[${fr}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:Hn=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${fr}] = indices[${fr}] * uniforms.sh - uniforms.phStart + j;
                `,Qt=`
              }
            `}return`
            ${a.registerUniforms(bt).declareVariables(e,zt)}

            ${a.mainStart()}
              ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${zt.offsetToIndices("global_idx")};
              var xIndices = ${zt.offsetToIndices("global_idx")};

              var value = ${It}(${_});
              var pad = 0;
              ${Hn}
              ${er}
              ${Qt}
              ${h}

              output[global_idx] = value;
            }`}else{if(Et)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let er=d.kernelShape.length,Hn=d.pads.length,Qt="";return g?Qt=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${c}
              }`:Qt=`
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${c}
            `,`
            ${a.registerUniforms(bt).declareVariables(e,zt)}

            ${a.mainStart()}
              ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${zt.offsetToIndices("global_idx")};
              var xIndices = ${zt.offsetToIndices("global_idx")};

              var offsets: array<u32, ${er}>;

              var value = ${It}(${_});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${er-1}u; j++) {
                  offsets[j] = offset / ${re("uniforms.kernelStrides","j",er)};
                  offset -= offsets[j] * ${re("uniforms.kernelStrides","j",er)};
                }
                offsets[${er-1}] = offset;

                isPad = false;
                for (var j = ${o-er}u; j < ${o}u; j++) {
                  xIndices[j] = indices[j] * ${re("uniforms.strides",`j - ${o-er}u`,er)}
                    + offsets[j - ${o-er}u] - ${re("uniforms.pads","j - 2u",Hn)};
                  ${Qt}
              }
              ${h}

              output[global_idx] = value;
            }`}},Nu=a=>`${a.format};${a.ceilMode};${a.autoPad};${a.kernelShape.length}`,vp=a=>`${Nu(a)};${a.countIncludePad}`,$p=a=>`${Nu(a)};${a.storageOrder};${a.dilations}`,Wu=a=>({format:a.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][a.auto_pad],ceilMode:a.ceil_mode,kernelShape:a.kernel_shape,strides:a.strides,pads:a.pads}),Vu=(a,e,o,s)=>{let[d,c]=Du(e,s,o),h=D("x",e.dataType,e.dims.length),_=h.type.value,bt="value += x_val;",g="";d.countIncludePad?g+=`value /= ${_}(uniforms.kernelSize);`:g+=`value /= ${_}(i32(uniforms.kernelSize) - pad);`;let[j,b,Et,It,zt]=Mu(c,d);j.push(...K(e.dims,c));let er=["rank"];return{name:a,shaderCache:{hint:`${s.cacheKey};${Et};${It};${zt}`,inputDependencies:er},getRunData:()=>({outputs:[{dims:c,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(M.size(c)/64)},programUniforms:j}),getShaderSource:Hn=>Uu(Hn,h,e.dims.length,c.length,d,bt,g,0,b,Et,It,zt)}},Gu=a=>{let e=a.count_include_pad!==0,o=Wu(a);if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let s={countIncludePad:e,...o,cacheKey:""};return{...s,cacheKey:vp(s)}},Hu=(a,e)=>{Tn(a.inputs),a.compute(Vu("AveragePool",a.inputs[0],!1,e))},Lu={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Fu=a=>{let e=a.format;return{format:e,...Lu,cacheKey:e}},qu=(a,e)=>{Tn(a.inputs),a.compute(Vu("GlobalAveragePool",a.inputs[0],!0,e))},ju=(a,e,o,s)=>{let[d,c]=Du(e,s,o),h=`
      value = max(x_val, value);
    `,_="",bt=D("x",e.dataType,e.dims.length),g=["rank"],[j,b,Et,It,zt]=Mu(c,d);return j.push(...K(e.dims,c)),{name:a,shaderCache:{hint:`${s.cacheKey};${Et};${It};${zt}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:c,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(M.size(c)/64)},programUniforms:j}),getShaderSource:er=>Uu(er,bt,e.dims.length,c.length,d,h,_,e.dataType===10?-65504:-1e5,b,Et,It,zt)}},Ku=(a,e)=>{Tn(a.inputs),a.compute(ju("MaxPool",a.inputs[0],!1,e))},Yu=a=>{let e=a.storage_order,o=a.dilations,s=Wu(a);if(e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(s.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let d={storageOrder:e,dilations:o,...s,cacheKey:""};return{...d,cacheKey:$p(d)}},Zu=a=>{let e=a.format;return{format:e,...Lu,cacheKey:e}},Xu=(a,e)=>{Tn(a.inputs),a.compute(ju("GlobalMaxPool",a.inputs[0],!0,e))}}),xp,Sp,Ju,el=F(()=>{lt(),ie(),be(),xp=(a,e,o)=>{let s=a===e,d=a<e&&o<0,c=a>e&&o>0;if(s||d||c)throw new Error("Range these inputs' contents are invalid.")},Sp=(a,e,o,s)=>{let d=Math.abs(Math.ceil((e-a)/o)),c=[d],h=d,_=[{type:12,data:h},{type:s,data:a},{type:s,data:o},...K(c)],bt=g=>{let j=q("output",s,c.length),b=j.type.value,Et=[{name:"outputSize",type:"u32"},{name:"start",type:b},{name:"delta",type:b}];return`
        ${g.registerUniforms(Et).declareVariables(j)}
        ${g.mainStart()}
        ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${b}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${s}`},getShaderSource:bt,getRunData:()=>({outputs:[{dims:c,dataType:s}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:_})}},Ju=a=>{let e=0,o=0,s=0;a.inputs[0].dataType===6?(e=a.inputs[0].getInt32Array()[0],o=a.inputs[1].getInt32Array()[0],s=a.inputs[2].getInt32Array()[0]):a.inputs[0].dataType===1&&(e=a.inputs[0].getFloat32Array()[0],o=a.inputs[1].getFloat32Array()[0],s=a.inputs[2].getFloat32Array()[0]),Ae.webgpu.validateInputContent&&xp(e,o,s),a.compute(Sp(e,o,s,a.inputs[0].dataType),{inputs:[]})}}),Cp,Ip,Ep,Ap,Tp,Op,kp,Pp,Rp,zp,Bp,tl,Dp,Mp,Up,Np,Wp,rl,nl,al=F(()=>{ie(),_e(),Ye(),be(),Cp=(a,e)=>{if(a.every(o=>o>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),a.length>0){if(e.mode==="linear"){if(!(a.length===2||a.length===3||a.length===4&&a[0]===1&&a[1]===1||a.length===4&&a[0]===1&&a[3]===1||a.length===5&&a[0]===1&&a[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(e.mode==="cubic"&&!(a.length===2||a.length===4&&a[0]===1&&a[1]===1||a.length===4&&a[0]===1&&a[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Ip=(a,e,o)=>{e.every(d=>d>=0&&d<o||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let s=new Array(o).fill(1);return e.forEach((d,c)=>s[d]=a[c]),s},Ep=(a,e,o,s,d,c)=>{let[h,_,bt]=o>10?[1,2,3]:[-1,a.length>1?1:-1,-1],g=a[0].dims.length;if(h>0&&a.length>h&&a[h].dims.length>0)a[h].getFloat32Array().forEach(j=>c.push(j));else if(e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(_>0&&a.length>_&&a[_].dims.length>0){if(a[_].getFloat32Array().forEach(j=>s.push(j)),s.length!==0&&s.length!==g&&o>=18&&s.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Cp(s,e),e.axes.length>0&&Ip(s,e.axes,g).forEach((j,b)=>s[b]=j)}if(bt>0&&a.length>bt&&(a[bt].getBigInt64Array().forEach(j=>d.push(Number(j))),d.length!==g||o>=18&&d.length===e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(s.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(d.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof s<"u"&&typeof d<"u"&&s.length>0&&d.length>g)throw new Error("Resize requires only of scales or sizes to be specified")},Ap=(a,e)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${e} { `+(()=>{switch(a){case"asymmetric":return`return ${e}(xResized) / ${e}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${e}(xResized) + 0.5) / ${e}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${e}(xResized) + 0.5) / ${e}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${e}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${e}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${e}(lengthResized - 1);
                    return whole + fract;
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${e}(roiStart) * ${e}(lengthOriginal - 1) +
                        (${e}(xResized) * ${e}(roiEnd - roiStart) * ${e}(lengthOriginal - 1)) /
                        ${e}(lengthResized - 1);
                  } else {
                    return 0.5 * ${e}(roiStart + roiEnd) * ${e}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${e}xScale * ${e}(lengthResized);
                  const adjustment = ${e}(lengthResized) / outputWidth;
                  const center = ${e}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;case"half_pixel":return`return ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${a} is not supported`)}})()+"}",Tp=(a,e,o)=>`fn getNearestPixelFromOriginal(xOriginal: ${o}, isDownSample: bool) -> ${o} {`+(()=>{switch(a){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${a} is not supported`)}})()+"}",Op=(a,e,o)=>{let s=new Array(o).fill(0).concat(new Array(o).fill(1)),d=a.length===0?s:a.slice();return e.length>0?(e.forEach((c,h)=>{s[c]=d[h],s[h+o]=d[e.length+h]}),s):d},kp=(a,e,o,s)=>{let d=[];if(o.length>0)if(s.length>0){if(a.forEach(c=>d.push(c)),Math.max(...s)>a.length)throw new Error("axes is out of bound");s.forEach((c,h)=>d[c]=o[h])}else o.forEach(c=>d.push(c));else{if(e.length===0)throw new Error("Resize requires either scales or sizes.");d=a.map((c,h)=>Math.round(c*e[h]))}return d},Pp=(a,e,o)=>{let s=(()=>{switch(o.keepAspectRatioPolicy){case"not_larger":return o.axes.length>0?Math.min(...o.axes.map(c=>e[c]),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return o.axes.length>0?Math.max(...o.axes.map(c=>e[c]),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${o.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);let d=a.slice();return o.axes.length>0?(o.axes.forEach(c=>e[c]=s),o.axes.forEach(c=>d[c]=Math.round(a[c]*e[c]))):(e.fill(s,0,e.length),d.forEach((c,h)=>d[h]=Math.round(c*e[h]))),d},Rp=(a,e,o,s,d)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${a.type.indices}) -> array<${a.type.value}, ${o.length}> {
      var original_indices: array<${a.type.value}, ${o.length}>;
      for (var i:u32 = 0; i < ${o.length}; i++) {
        var output_index = ${a.indicesGet("output_indices","i")};
        var scale = ${re("uniforms.scales","i",s)};
        var roi_low = ${re("uniforms.roi","i",d)};
        var roi_hi = ${re("uniforms.roi",`i + ${e.length}`,d)};
        if (scale == 1.0) {
          original_indices[i] = ${a.type.value}(output_index);
        } else {
          var input_shape_i = ${re("uniforms.input_shape","i",e.length)};
          var output_shape_i = ${re("uniforms.output_shape","i",o.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,zp=(a,e,o,s,d,c,h)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> ${a.type.indices} {
      var input_indices: ${a.type.indices};
      for (var i:u32 = 0; i < ${s.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${re("uniforms.scales","i",d)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${re("uniforms.roi","i",c)};
          var roi_hi = ${re("uniforms.roi",`i + ${o.length}`,c)};
          var input_shape_i = ${re("uniforms.input_shape","i",o.length)};
          var output_shape_i = ${re("uniforms.output_shape","i",s.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${h} || (original_idx >= 0 && original_idx < ${e.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${e.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${a.indicesSet("input_indices","i"," input_index")}
      }
      return input_indices;
    }`,Bp=(a,e)=>`
    fn checkInputIndices(input_indices: ${a.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var input_index = ${a.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${re("uniforms.input_shape","i",e.length)}) {
          return false;
        }
      }
      return true;
    }`,tl=(a,e,o,s)=>a.rank>s?`
    ${a.indicesSet("input_indices",e,"channel")};
    ${a.indicesSet("input_indices",o,"batch")};
`:"",Dp=(a,e,o,s,d)=>{let[c,h,_,bt]=o.length===2?[-1,0,1,-1]:[0,2,3,1],g=a.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${g} {
      var input_indices: ${a.type.indices};
      ${a.indicesSet("input_indices",h,`max(0, min(row, ${o[h]} - 1))`)};
      ${a.indicesSet("input_indices",_,`max(0, min(col, ${o[_]} - 1))`)};
      ${tl(a,bt,c,2)}
      return ${a.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${e.type.indices}) -> ${g} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${g} = originalIndices[${h}];
      var col:${g} = originalIndices[${_}];
      ${s?`if (row < 0 || row > (${o[h]} - 1) || col < 0 || col > (${o[_]} - 1)) {
        return ${d};
      }`:""};
      row = max(0, min(row, ${o[h]} - 1));
      col = max(0, min(col, ${o[_]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${o.length>2?`u32(originalIndices[${bt}])`:"0"};
      var batch: u32 =  ${o.length>2?`u32(originalIndices[${c}])`:"0"};
      var x11: ${g} = getInputValue(batch, channel, row1, col1);
      var x12: ${g} = getInputValue(batch, channel, row1, col2);
      var x21: ${g} = getInputValue(batch, channel, row2, col1);
      var x22: ${g} = getInputValue(batch, channel, row2, col2);
      var dx1: ${g} = abs(row - ${g}(row1));
      var dx2: ${g} = abs(${g}(row2) - row);
      var dy1: ${g} = abs(col - ${g}(col1));
      var dy2: ${g} = abs(${g}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},Mp=(a,e,o,s,d,c,h,_,bt,g)=>{let j=o.length===2,[b,Et]=j?[0,1]:[2,3],It=a.type.value,zt=er=>{let Hn=er===b?"row":"col";return`
      fn ${Hn}CubicInterpolation(input_indices: ${a.type.indices}, output_indices: ${e.type.indices}) -> ${It} {
        var output_index = ${e.indicesGet("output_indices",er)};
        var originalIdx: ${It} = getOriginalCoordinateFromResizedCoordinate(output_index, ${d[er]},
        ${s[er]}, ${o[er]}, ${c[er]}, ${c[er]} + ${o.length});
        var fractOriginalIdx: ${It} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${_} && (originalIdx < 0 || originalIdx > (${o[er]} - 1))) {
          return ${bt};
        }
        var data: array<${It}, 4> = array<${It}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${Hn}: ${It} = originalIdx + ${It}(i);
          if (${Hn} < 0 || ${Hn} >= ${o[er]}) {
            ${g?`coefs[i + 1] = 0.0;
                        continue;`:_?`return ${bt};`:`${Hn} = max(0, min(${Hn}, ${o[er]} - 1));`};
          }
        var input_indices_copy: ${a.type.indices} = input_indices;
          ${a.indicesSet("input_indices_copy",er,`u32(${Hn})`)};
          data[i + 1] = ${er===b?a.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${zt(b)};
    ${zt(Et)};
  fn getCubicInterpolationCoefs(s: ${It}) -> array<${It}, 4> {
    var absS = abs(s);
    var coeffs: array<${It}, 4> = array<${It}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${It} = 1.0 - absS;
    var twoMinusAbsS: ${It} = 2.0 - absS;
    var onePlusAbsS: ${It} = 1.0 + absS;
    coeffs[0] = ((${h} * onePlusAbsS - 5 * ${h}) * onePlusAbsS + 8 * ${h}) * onePlusAbsS - 4 * ${h};
    coeffs[1] = ((${h} + 2) * absS - (${h} + 3)) * absS * absS + 1;
    coeffs[2] = ((${h} + 2) * oneMinusAbsS - (${h} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${h} * twoMinusAbsS - 5 * ${h}) * twoMinusAbsS + 8 * ${h}) * twoMinusAbsS - 4 * ${h};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${It}, 4>, coefs: array<${It}, 4>) -> ${It} {
    var coefsSum: ${It} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${e.type.indices}) -> ${It} {
    var input_indices: ${a.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},Up=(a,e,o,s,d)=>{let[c,h,_,bt,g]=o.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],j=a.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${j} {
      var input_indices: ${a.type.indices};
      ${a.indicesSet("input_indices",h,`max(0, min(depth, ${o[h]} - 1))`)};
      ${a.indicesSet("input_indices",_,`max(0, min(height, ${o[_]} - 1))`)};
      ${a.indicesSet("input_indices",bt,`max(0, min(width, ${o[bt]} - 1))`)};
      ${tl(a,g,c,3)}
      return ${a.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${e.type.indices}) -> ${j} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${j} = originalIndices[${h}];
      var height:${j} = originalIndices[${_}];
      var width:${j} = originalIndices[${bt}];
      ${s?`if (depth < 0 || depth > (${o[h]} - 1) || height < 0 || height > (${o[_]} - 1) || width < 0 || (width > ${o[bt]} - 1)) {
      return ${d};
        }`:""};

    depth = max(0, min(depth, ${o[h]} - 1));
      height = max(0, min(height, ${o[_]} - 1));
      width = max(0, min(width, ${o[bt]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${o.length>3?`u32(originalIndices[${g}])`:"0"};
      var batch: u32 =  ${o.length>3?`u32(originalIndices[${c}])`:"0"};

      var x111: ${j} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${j} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${j} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${j} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${j} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${j} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${j} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${j} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${j} = abs(depth - ${j}(depth1));
      var dx2: ${j} = abs(${j}(depth2) - depth);
      var dy1: ${j} = abs(height - ${j}(height1));
      var dy2: ${j} = abs(${j}(height2) - height);
      var dz1: ${j} = abs(width - ${j}(width1));
      var dz2: ${j} = abs(${j}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},Np=(a,e,o,s,d,c)=>{let h=a.dims,_=Op(c,e.axes,h.length),bt=kp(h,s,d,e.axes),g=s.slice();s.length===0&&(g=h.map((cr,fr)=>cr===0?1:bt[fr]/cr),e.keepAspectRatioPolicy!=="stretch"&&(bt=Pp(h,g,e)));let j=q("output",a.dataType,bt.length),b=D("input",a.dataType,h.length),Et=M.size(bt),It=h.length===bt.length&&h.every((cr,fr)=>cr===bt[fr]),zt=e.coordinateTransformMode==="tf_crop_and_resize",er=e.extrapolationValue,Hn=b.type.value,Qt=cr=>`
      ${It?"":`
      ${Ap(e.coordinateTransformMode,Hn)};
      ${(()=>{switch(e.mode){case"nearest":return`
              ${Bp(b,h)};
              ${Tp(e.nearestMode,o,Hn)};
              ${zp(b,j,h,bt,g.length,_.length,zt)};
              `;case"linear":return`
              ${Rp(j,h,bt,g.length,_.length)};
              ${(()=>{if(h.length===2||h.length===4)return`${Dp(b,j,h,zt,er)}`;if(h.length===3||h.length===5)return`${Up(b,j,h,zt,er)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(h.length===2||h.length===4)return`${Mp(b,j,h,bt,g,_,e.cubicCoeffA,zt,e.extrapolationValue,e.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${cr.registerUniform("output_size","u32").registerUniform("scales","f32",g.length).registerUniform("roi","f32",_.length).declareVariables(b,j)}
      ${cr.mainStart()}
        ${cr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${It?"output[global_idx] = input[global_idx];":`
        let output_indices = ${j.offsetToIndices("global_idx")};
        var input_indices: ${b.type.indices};
        ${(()=>{switch(e.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${b.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${e.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${h.length===2||h.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${o}|${g.length>0?g:""}|${d.length>0?d:""}|${_.length>0?_:""}|${It}|${h}`,inputDependencies:["rank"]},getShaderSource:Qt,getRunData:()=>({outputs:[{dims:bt,dataType:a.dataType}],dispatchGroup:{x:Math.ceil(Et/64)},programUniforms:[{type:12,data:Et},{type:1,data:g},{type:1,data:_},...K(h,bt)]})}},Wp=a=>{let e=a.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},rl=(a,e)=>{let o=[],s=[],d=[],c=Wp(a);if(e.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");Ep(a.inputs,e,c,o,s,d),a.compute(Np(a.inputs[0],e,c,o,s,d),{inputs:[0]})},nl=a=>{let e=a.antialias,o=a.axes,s=a.coordinateTransformMode,d=a.cubicCoeffA,c=a.excludeOutside!==0,h=a.extrapolationValue,_=a.keepAspectRatioPolicy,bt=a.mode,g=a.nearestMode===""?"simple":a.nearestMode;return $e({antialias:e,axes:o,coordinateTransformMode:s,cubicCoeffA:d,excludeOutside:c,extrapolationValue:h,keepAspectRatioPolicy:_,mode:bt,nearestMode:g})}}),Vp,Gp,il,ol=F(()=>{ie(),_e(),be(),Vp=a=>{if(!a||a.length<3)throw new Error("layerNorm requires at least 3 inputs.");let e=a[0],o=a[1],s=a[2];if(e.dataType!==o.dataType||e.dataType!==s.dataType)throw new Error("All inputs must have the same data type");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(o.dims.length!==3&&o.dims.length!==2)throw new Error("Skip must be 2D or 3D");let d=e.dims[e.dims.length-1],c=e.dims[e.dims.length-2];if(o.dims[o.dims.length-1]!==d)throw new Error("Skip must have the same hidden size as input");if(o.dims[o.dims.length-2]!==c)throw new Error("Skip must have the same sequence length as input");if(s.dims.length!==1)throw new Error("Gamma must be 1D");if(s.dims[s.dims.length-1]!==d)throw new Error("Gamma must have the same hidden size as input");if(a.length>3){let h=a[3];if(h.dims.length!==1)throw new Error("Beta must be 1D");if(h.dims[h.dims.length-1]!==d)throw new Error("Beta must have the same hidden size as input")}if(a.length>4){let h=a[4];if(h.dims.length!==1)throw new Error("Bias must be 1D");if(h.dims[h.dims.length-1]!==d)throw new Error("Bias must have the same hidden size as input")}},Gp=(a,e,o,s)=>{let d=a[0].dims,c=M.size(d),h=d,_=c,bt=d.slice(-1)[0],g=s?d.slice(0,-1).concat(1):[],j=a.length>3,b=a.length>4,Et=s&&o>1,It=s&&o>2,zt=o>3,er=Me(bt),Hn=[{type:12,data:_},{type:12,data:er},{type:12,data:bt},{type:1,data:e.epsilon}],Qt=fr=>{let jr=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],e0=[D("x",a[0].dataType,a[0].dims,er),D("skip",a[1].dataType,a[1].dims,er),D("gamma",a[2].dataType,a[2].dims,er)];j&&e0.push(D("beta",a[3].dataType,a[3].dims,er)),b&&e0.push(D("bias",a[4].dataType,a[4].dims,er)),e0.push(q("output",a[0].dataType,h,er)),Et&&e0.push(q("mean_output",1,g)),It&&e0.push(q("inv_std_output",1,g)),zt&&e0.push(q("input_skip_bias_sum",a[0].dataType,h,er));let t0=ke(a[0].dataType);return`

      ${fr.registerUniforms(jr).declareVariables(...e0)}

      ${fr.mainStart()}
        ${fr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size / uniforms.hidden_size")}
        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        let offset = global_idx * hidden_size_vectorized;
        var sum = ${Xe("f32",er)};
        var squareSum = ${Xe("f32",er)};
        for (var i: u32 = 0; i < hidden_size_vectorized; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${b?"bias[i]":"0.0"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${zt?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${mt(t0,er,"value")};
          sum += f32_value;
          squareSum += f32_value * f32_value;
        }
        let mean = ${it("sum",er)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${it("squareSum",er)} / f32(uniforms.hidden_size) - mean * mean + uniforms.epsilon);
        ${Et?"mean_output[global_idx] = mean;":""}
        ${It?"inv_std_output[global_idx] = inv_std_dev;":""}
        for (var i: u32 = 0; i < hidden_size_vectorized; i++) {
          output[offset + i] = (output[offset + i] - ${t0}(mean)) * ${t0}(inv_std_dev) * gamma[i] + ${j?"beta[i]":"0.0"};
        }
      }`},cr=[{dims:h,dataType:a[0].dataType}];return o>1&&cr.push({dims:g,dataType:1}),o>2&&cr.push({dims:g,dataType:1}),o>3&&cr.push({dims:d,dataType:a[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${er};${Et};${It};${zt}`,inputDependencies:a.map((fr,jr)=>"type")},getShaderSource:Qt,getRunData:()=>({outputs:cr,dispatchGroup:{x:Math.ceil(_/bt/64)},programUniforms:Hn})}},il=(a,e)=>{Vp(a.inputs);let o=[0];a.outputCount>1&&o.push(-3),a.outputCount>2&&o.push(-3),a.outputCount>3&&o.push(3),a.compute(Gp(a.inputs,e,a.outputCount,!1),{outputs:o})}}),Hp,On,Lp,sl,Fp,qp,ul,ll,dl=F(()=>{ie(),_e(),Ye(),be(),Hp=(a,e)=>{if(!a||a.length<1)throw new Error("too few inputs");if(e.axes.length!==0){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");a.slice(1).forEach((o,s)=>{if(a[s+1].dataType!==6&&a[s+1].dataType!==7)throw new Error(`Input ${s} must be an array of int32 or int64`)})},On=(a,e)=>{let o=[];if(a.length>e)if(a[e].dataType===7)a[e].getBigInt64Array().forEach(s=>o.push(Number(s)));else if(a[e].dataType===6)a[e].getInt32Array().forEach(s=>o.push(Number(s)));else throw new Error(`Input ${e} must be an array of int32 or int64`);return o},Lp=(a,e)=>{if(a.length>1){let o=On(a,1),s=On(a,2),d=On(a,3);return d.length===0&&(d=[...Array(a[0].dims.length).keys()]),$e({starts:o,ends:s,axes:d})}else return e},sl=(a,e,o,s,d)=>{let c=a;return a<0&&(c+=o[s[e]]),d[e]<0?Math.max(0,Math.min(c,o[s[e]]-1)):Math.max(0,Math.min(c,o[s[e]]))},Fp=(a,e,o)=>`fn calculateInputIndices(output_indices: ${e.type.indices}) -> ${a.type.indices} {
          var input_indices: ${a.type.indices};
          var carry = 0u;
          for (var i = ${o.length}; i >= 0; i--) {
            let input_shape_i = ${re("uniforms.input_shape","i",o.length)};
            let steps_i = ${re("uniforms.steps","i",o.length)};
            let signs_i = ${re("uniforms.signs","i",o.length)};
            let starts_i = ${re("uniforms.starts","i",o.length)};
            var output_index = ${e.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${a.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,qp=(a,e)=>{let o=a[0].dims,s=M.size(o),d=e.axes.length>0?M.normalizeAxes(e.axes,o.length):[...Array(o.length).keys()],c=On(a,4);c.forEach(Qt=>Qt!==0||(()=>{throw new Error("step cannot be 0")})),c.length===0&&(c=Array(d.length).fill(1));let h=e.starts.map((Qt,cr)=>sl(Qt,cr,o,d,c)),_=e.ends.map((Qt,cr)=>sl(Qt,cr,o,d,c));if(d.length!==h.length||d.length!==_.length)throw new Error("start, ends and axes should have the same number of elements");if(d.length!==o.length)for(let Qt=0;Qt<o.length;++Qt)d.includes(Qt)||(h.splice(Qt,0,0),_.splice(Qt,0,o[Qt]),c.splice(Qt,0,1));let bt=c.map(Qt=>Math.sign(Qt));c.forEach((Qt,cr,fr)=>{if(Qt<0){let jr=(_[cr]-h[cr])/Qt,e0=h[cr],t0=e0+jr*c[cr];h[cr]=t0,_[cr]=e0,fr[cr]=-Qt}});let g=o.slice(0);d.forEach((Qt,cr)=>{g[Qt]=Math.ceil((_[Qt]-h[Qt])/c[Qt])});let j={dims:g,dataType:a[0].dataType},b=q("output",a[0].dataType,g.length),Et=D("input",a[0].dataType,a[0].dims.length),It=M.size(g),zt=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:h.length},{name:"signs",type:"i32",length:bt.length},{name:"steps",type:"u32",length:c.length}],er=[{type:12,data:It},{type:12,data:h},{type:6,data:bt},{type:12,data:c},...K(a[0].dims,g)],Hn=Qt=>`
      ${Qt.registerUniforms(zt).declareVariables(Et,b)}
        ${Fp(Et,b,o)}
        ${Qt.mainStart()}
          ${Qt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${b.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${b.setByOffset("global_idx",Et.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${bt.length}_${h.length}_${c.length}`,inputDependencies:["rank"]},getShaderSource:Hn,getRunData:()=>({outputs:[j],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:er})}},ul=(a,e)=>{Hp(a.inputs,e);let o=Lp(a.inputs,e);a.compute(qp(a.inputs,o),{inputs:[0]})},ll=a=>{let e=a.starts,o=a.ends,s=a.axes;return $e({starts:e,ends:o,axes:s})}}),jp,Kp,cl,pl,fl=F(()=>{ie(),_e(),Ye(),be(),jp=a=>{if(!a||a.length!==1)throw new Error("Softmax op requires 1 input.")},Kp=(a,e)=>{let o=a.dims,s=M.size(o),d=64,c=e.axis;if(c<0&&(c=o.length+c),c<o.length-1)throw new Error("softmax only supports last axis for now.");let h=o[c],_=s/h,bt=Me(h),g=h/bt,j=(Hn,Qt)=>Qt===4?`max(max(${Hn}.x, ${Hn}.y), max(${Hn}.z, ${Hn}.w))`:Qt===2?`max(${Hn}.x, ${Hn}.y)`:Qt===3?`max(max(${Hn}.x, ${Hn}.y), ${Hn}.z)`:Hn,b=D("x",a.dataType,a.dims,bt),Et=q("result",a.dataType,a.dims,bt),It=b.type.value,zt=ke(a.dataType)==="f32"?`var threadMax = ${It}(-3.402823e+38f);`:`var threadMax = ${It}(-65504.0h);`,er=Hn=>`
      var<workgroup> rowMaxShared : ${It};
      var<workgroup> rowSumShared : ${It};
      var<workgroup> threadShared : array<${It}, ${d}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${It} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${It}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${Hn.registerUniform("packedCols","i32").declareVariables(b,Et)}
      ${Hn.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${d};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${zt}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${It}(${j("threadShared[0]",bt)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${It}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${It}(${it("threadShared[0]",bt)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;return{name:"Softmax",shaderCache:{hint:`${bt}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:o,dataType:a.dataType}],dispatchGroup:{x:_},programUniforms:[{type:12,data:g}]}),getShaderSource:er}},cl=(a,e)=>{jp(a.inputs),a.compute(Kp(a.inputs[0],e))},pl=a=>$e({axis:a.axis})}),Yp,Zp,Xp,Qp,Jp,ml,hl,gl=F(()=>{ie(),_e(),Ye(),be(),Yp=a=>{if(!a||a.length<1)throw new Error("too few inputs")},Zp=(a,e)=>{let o=[],s=e.numOutputs;return a[1].dims[0]>0&&(a[1].getBigInt64Array().forEach(d=>o.push(Number(d))),s=o.length),$e({numOutputs:s,axis:e.axis,splitSizes:o})},Xp=a=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${a}u; i += 1u ) {
    if (index < ${re("uniforms.size_in_split_axis","i",a)}) {
        return i;
    }
    }
    return ${a}u;
}`,Qp=a=>{let e=a.length,o=[];for(let s=0;s<e;++s){let d=a[s].setByIndices("indices","input[global_idx]");e===1?o.push(d):s===0?o.push(`if (output_number == ${s}u) { ${d} }`):s===e-1?o.push(`else { ${d} }`):o.push(`else if (output_number == ${s}) { ${d} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${a[0].type.indices}, global_idx: u32) {
        ${o.join(`
`)}
      }`},Jp=(a,e)=>{let o=a[0].dims,s=M.size(o),d=a[0].dataType,c=M.normalizeAxis(e.axis,o.length),h=new Array(e.numOutputs),_=D("input",d,o.length),bt=new Array(e.numOutputs),g=[],j=[],b=0,Et=[{type:12,data:s}];for(let zt=0;zt<e.numOutputs;zt++){b+=e.splitSizes[zt],bt[zt]=b;let er=o.slice();er[e.axis]=e.splitSizes[zt],j.push(er),h[zt]=q(`output${zt}`,d,er.length),g.push({dims:j[zt],dataType:a[0].dataType})}Et.push({type:12,data:bt},...K(o,...j));let It=zt=>`
  ${zt.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",bt.length).declareVariables(_,...h)}
  ${Xp(bt.length)}
  ${Qp(h)}

  ${zt.mainStart()}
    ${zt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${_.offsetToIndices("global_idx")};
    var index = ${_.indicesGet("indices",c)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${re("uniforms.size_in_split_axis","output_number - 1u",bt.length)};
      ${_.indicesSet("indices",c,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:e.cacheKey,inputDependencies:["rank"]},getShaderSource:It,getRunData:()=>({outputs:g,dispatchGroup:{x:Math.ceil(s/64)},programUniforms:Et})}},ml=(a,e)=>{Yp(a.inputs);let o=a.inputs.length===1?e:Zp(a.inputs,e);a.compute(Jp(a.inputs,o),{inputs:[0]})},hl=a=>{let e=a.axis,o=a.splitSizes,s=a.numOutputs<0?o.length:a.numOutputs;if(s!==o.length)throw new Error("numOutputs and splitSizes lengh must be equal");return $e({axis:e,numOutputs:s,splitSizes:o})}}),yl,ef,tf,rf,bl,wl=F(()=>{ie(),_e(),be(),yl=a=>Array.from(a.getBigInt64Array(),Number),ef=a=>{if(!a||a.length!==2)throw new Error("Tile requires 2 inputs.");if(a[0].dataType!==1&&a[0].dataType!==6&&a[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(a[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(a[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(yl(a[1]).length!==a[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},tf=(a,e)=>{let o=[];for(let s=0;s<a.length;++s)o.push(a[s]*e[s]);return o},rf=a=>{let e=a[0].dims,o=yl(a[1]),s=tf(e,o),d=M.size(s),c=a[0].dataType,h=D("input",c,e.length),_=q("output",c,s.length),bt=g=>`
      const inputShape = ${h.indices(...e)};
      ${g.registerUniform("output_size","u32").declareVariables(h,_)}
      ${g.mainStart()}
      ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${_.offsetToIndices("global_idx")};
      var input_indices: ${h.type.indices};
      for (var i = 0; i < ${e.length}; i++) {
        let input_dim_i = ${h.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${_.indicesGet("output_indices","i")}  % input_dim_i;

        ${h.indicesSet("input_indices","i","input_dim_value")}
      }
      ${_.setByOffset("global_idx",h.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${o}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:s,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},...K(a[0].dims,s)]}),getShaderSource:bt}},bl=a=>{ef(a.inputs),a.compute(rf(a.inputs),{inputs:[0]})}}),nf,af,vl,$l=F(()=>{ie(),_e(),be(),nf=(a,e,o,s,d)=>{let c=q("output_data",d,o.length,4),h=D("a_data",e[1].dataType,e[1].dims.length,4),_=D("b_data",e[2].dataType,e[2].dims.length,4),bt=D("c_data",e[0].dataType,e[0].dims.length,4),g,j=(b,Et,It)=>`select(${Et}, ${b}, ${It})`;if(!s)g=c.setByOffset("global_idx",j(h.getByOffset("global_idx"),_.getByOffset("global_idx"),bt.getByOffset("global_idx")));else{let b=(Et,It,zt="")=>{let er=`a_data[index_a${It}][component_a${It}]`,Hn=`b_data[index_b${It}][component_b${It}]`,Qt=`bool(c_data[index_c${It}] & (0xffu << (component_c${It} * 8)))`;return`
            let output_indices${It} = ${c.offsetToIndices(`global_idx * 4u + ${It}u`)};
            let offset_a${It} = ${h.broadcastedIndicesToOffset(`output_indices${It}`,c)};
            let offset_b${It} = ${_.broadcastedIndicesToOffset(`output_indices${It}`,c)};
            let offset_c${It} = ${bt.broadcastedIndicesToOffset(`output_indices${It}`,c)};
            let index_a${It} = offset_a${It} / 4u;
            let index_b${It} = offset_b${It} / 4u;
            let index_c${It} = offset_c${It} / 4u;
            let component_a${It} = offset_a${It} % 4u;
            let component_b${It} = offset_b${It} % 4u;
            let component_c${It} = offset_c${It} % 4u;
            ${Et}[${It}] = ${zt}(${j(er,Hn,Qt)});
          `};d===9?g=`
            var data = vec4<u32>(0);
            ${b("data",0,"u32")}
            ${b("data",1,"u32")}
            ${b("data",2,"u32")}
            ${b("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:g=`
            ${b("output_data[global_idx]",0)}
            ${b("output_data[global_idx]",1)}
            ${b("output_data[global_idx]",2)}
            ${b("output_data[global_idx]",3)}
          `}return`
        ${a.registerUniform("vec_size","u32").declareVariables(bt,h,_,c)}
        ${a.mainStart()}
        ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${g}
      }`},af=a=>{let e=a[1].dims,o=a[2].dims,s=a[0].dims,d=a[1].dataType,c=!(M.areEqual(e,o)&&M.areEqual(o,s)),h=e,_=M.size(e);if(c){let g=vt.calcShape(vt.calcShape(e,o,!1),s,!1);if(!g)throw new Error("Can't perform where op on the given tensors");h=g,_=M.size(h)}let bt=Math.ceil(_/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:g=>nf(g,a,h,c,d),getRunData:()=>({outputs:[{dims:h,dataType:d}],dispatchGroup:{x:Math.ceil(_/64/4)},programUniforms:[{type:12,data:bt},...K(s,e,o,h)]})}},vl=a=>{a.compute(af(a.inputs))}}),_l,xl=F(()=>{Mo(),ga(),Wo(),Go(),Is(),Ms(),Ws(),$a(),eu(),nu(),uu(),cu(),fu(),gu(),wu(),_u(),Su(),Iu(),xa(),Tu(),Ru(),Bu(),Qu(),el(),gn(),al(),ol(),dl(),fl(),gl(),wl(),ir(),$n(),$l(),_l=new Map([["Abs",[Ho]],["Acos",[Lo]],["Acosh",[Fo]],["Add",[Es]],["ArgMax",[Do,ha]],["ArgMin",[Bo,ha]],["Asin",[qo]],["Asinh",[jo]],["Atan",[Ko]],["Atanh",[Yo]],["Attention",[Uo]],["AveragePool",[Hu,Gu]],["BatchNormalization",[No]],["BiasAdd",[Vo]],["BiasSplitGelu",[Cs]],["Cast",[Xo,Zo]],["Ceil",[Jo]],["Clip",[Qo]],["Concat",[Us,Ns]],["Conv",[Ia,Ca]],["ConvTranspose",[Js,Qs]],["Cos",[es]],["Cosh",[ts]],["CumSum",[tu,ru]],["Div",[As]],["Einsum",[ou,su]],["Elu",[rs,wn]],["Equal",[Ts]],["Erf",[ns]],["Exp",[as]],["Expand",[du]],["FastGelu",[pu]],["Floor",[is]],["FusedConv",[Ia,Ca]],["Gather",[hu,mu]],["GatherElements",[bu,yu]],["Gelu",[os]],["Gemm",[$u,vu]],["GlobalAveragePool",[qu,Fu]],["GlobalMaxPool",[Xu,Zu]],["Greater",[Rs]],["GreaterOrEqual",[Bs]],["HardSigmoid",[ms,fs]],["InstanceNormalization",[xu]],["LayerNormalization",[Cu]],["LeakyRelu",[ss,wn]],["Less",[zs]],["LessOrEqual",[Ds]],["Log",[xs]],["MatMul",[qs]],["MatMulNBits",[Eu,Au]],["MaxPool",[Ku,Yu]],["Mul",[Os]],["MultiHeadAttention",[Pu,ku]],["Neg",[ls]],["Not",[us]],["Pad",[zu]],["Pow",[ks]],["Range",[Ju]],["Reciprocal",[ds]],["ReduceMin",[To]],["ReduceMean",[So]],["ReduceMax",[Ao]],["ReduceSum",[ko]],["ReduceProd",[Oo]],["ReduceL1",[Co]],["ReduceL2",[Io]],["ReduceLogSum",[Ro]],["ReduceLogSumExp",[Eo]],["ReduceSumSquare",[Po]],["Relu",[cs]],["Resize",[rl,nl]],["Sigmoid",[ps]],["Sin",[hs]],["Sinh",[gs]],["Slice",[ul,ll]],["SkipLayerNormalization",[il]],["Split",[ml,hl]],["Sqrt",[ys]],["Softmax",[cl,pl]],["Sub",[Ps]],["Tan",[bs]],["Tanh",[vs]],["ThresholdedRelu",[_s,wn]],["Tile",[bl]],["Transpose",[co,po]],["Where",[vl]]])}),kn,Sl=F(()=>{lt(),Dt(),be(),kn=class{constructor(a){this.backend=a,this.repo=new Map,this.attributesBound=!1}getArtifact(a){return this.repo.get(a)}setArtifact(a,e){this.repo.set(a,e)}run(a,e,o,s,d){st(a.programInfo.name);let c=this.backend.device,h=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let _=[];for(let g of e)_.push({binding:_.length,resource:{buffer:g.buffer}});for(let g of o)_.push({binding:_.length,resource:{buffer:g.buffer}});d&&_.push({binding:_.length,resource:d});let bt=c.createBindGroup({layout:a.computePipeline.getBindGroupLayout(0),entries:_,label:a.programInfo.name});if(this.backend.sessionStatus==="capturing"){let g={kernelId:this.backend.currentKernelId,computePipeline:a.computePipeline,bindGroup:bt,dispatchGroup:s};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(g)}h.setPipeline(a.computePipeline),h.setBindGroup(0,bt),h.dispatchWorkgroups(...s),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),nt(a.programInfo.name)}dispose(){}build(a,e){st(a.name);let o=this.backend.device,s=[];o.features.has("shader-f16")&&s.push("enable f16;");let d=uo(e),c=a.getShaderSource(d),h=`${s.join(`
`)}
${d.additionalImplementations}
${c}`,_=o.createShaderModule({code:h,label:a.name});De("verbose",()=>`[WebGPU] ${a.name} shader code: ${h}`);let bt=o.createComputePipeline({compute:{module:_,entryPoint:"main"},layout:"auto",label:a.name});return nt(a.name),{programInfo:a,computePipeline:bt}}normalizeDispatchGroupSize(a){let e=typeof a=="number"?a:a.x,o=typeof a=="number"?1:a.y||1,s=typeof a=="number"?1:a.z||1,d=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(e<=d&&o<=d&&s<=d)return[e,o,s];let c=e*o*s,h=Math.ceil(Math.sqrt(c));if(h>d){if(h=Math.ceil(Math.cbrt(c)),h>d)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[h,h,h]}else return[h,h,1]}}}),of,sf,Pa,Pn,Cl=F(()=>{lt(),ie(),Dt(),no(),so(),xl(),Sl(),of=(a,e)=>{if(e.length!==a.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${a.length}.`);let o=[];for(let s=0;s<a.length;++s){let d=a[s].dataType;switch(e[s]){case"none":{o.push("");break}case"type":{o.push(`${d}`);break}case"rank":{let c=a[s].dims.length;o.push(`${d};${c}`);break}case"dims":{let c=a[s].dims.join(",");o.push(`${d};${c}`);break}default:throw new Error(`unsupported input dependency: ${e[s]}`)}}return o.join("|")},sf=(a,e,o)=>{var d,c;let s=a.name;return(d=a.shaderCache)!=null&&d.hint&&(s+="["+a.shaderCache.hint+"]"),s+=":"+o+`:${of(e,((c=a.shaderCache)==null?void 0:c.inputDependencies)??new Array(e.length).fill("dims"))}`,s},Pa=class{constructor(a){a&&(this.architecture=a.architecture,this.vendor=a.vendor)}isArchitecture(a){return this.architecture===a}isVendor(a){return this.vendor===a}},Pn=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let a=this.kernelCustomData.get(this.currentKernelId);return a||(a={},this.kernelCustomData.set(this.currentKernelId,a)),a}async initialize(a,e){this.env=a;let o=[],s={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize,maxBufferSize:e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};e.features.has("chromium-experimental-timestamp-query-inside-passes")?o.push("chromium-experimental-timestamp-query-inside-passes"):e.features.has("timestamp-query")&&o.push("timestamp-query"),e.features.has("shader-f16")&&o.push("shader-f16"),this.device=await e.requestDevice(s),this.adapterInfo=new Pa(await e.requestAdapterInfo()),this.gpuDataManager=oo(this),this.programManager=new kn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,to(a.logLevel,!!a.debug),this.device.onuncapturederror=d=>{d.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${d.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:e,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let a=this.getCommandEncoder(),e={};this.queryType==="at-passes"&&(e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=a.beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;st(),this.endComputePass();let a;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),a=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(a,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,a,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&a.mapAsync(GPUMapMode.READ).then(()=>{var s;let e=new BigUint64Array(a.getMappedRange()),o=this.pendingQueries.get(a);for(let d=0;d<e.length/2;d++){let c=o[d],h=c.kernelId,_=this.kernels.get(h),bt=_.kernelType,g=_.kernelName,j=c.programName,b=c.inputTensorViews,Et=c.outputTensorViews,It=e[d*2],zt=e[d*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=It);let er=Number(It-this.queryTimeBase),Hn=Number(zt-this.queryTimeBase);if(!Number.isSafeInteger(er)||!Number.isSafeInteger(Hn))throw new RangeError("incorrect timestamp range");if((s=this.env.webgpu.profiling)!=null&&s.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:b.map(Qt=>({dims:Qt.dims,dataType:Bt(Qt.dataType)})),outputsMetadata:Et.map(Qt=>({dims:Qt.dims,dataType:Bt(Qt.dataType)})),kernelId:h,kernelType:bt,kernelName:g,programName:j,startTime:er,endTime:Hn});else{let Qt="";b.forEach((fr,jr)=>{Qt+=`input[${jr}]: [${fr.dims}] | ${Bt(fr.dataType)}, `});let cr="";Et.forEach((fr,jr)=>{cr+=`output[${jr}]: [${fr.dims}] | ${Bt(fr.dataType)}, `}),console.log(`[profiling] kernel "${h}|${bt}|${g}|${j}" ${Qt}${cr}execution time: ${Hn-er} ns`)}tn("GPU",`${j}::${It}::${zt}`)}a.unmap(),this.pendingQueries.delete(a)}),nt()}run(a,e,o,s,d){st(a.name);let c=[];for(let Qt=0;Qt<e.length;++Qt){let cr=e[Qt].data;if(cr===0)continue;let fr=this.gpuDataManager.get(cr);if(!fr)throw new Error(`no GPU data for input: ${cr}`);c.push(fr)}let{outputs:h,dispatchGroup:_,programUniforms:bt}=a.getRunData(e),g=o.length===0?h.map((Qt,cr)=>cr):o;if(g.length!==h.length)throw new Error(`Output size ${g.length} must be equal to ${h.length}.`);let j=[],b=[];for(let Qt=0;Qt<h.length;++Qt){if(!Number.isInteger(g[Qt])||g[Qt]<-3||g[Qt]>=h.length)throw new Error(`Invalid output index: ${g[Qt]}`);if(g[Qt]===-3)continue;let cr=g[Qt]===-1,fr=g[Qt]===-2,jr=cr||fr?d(h[Qt].dataType,h[Qt].dims):s(g[Qt],h[Qt].dataType,h[Qt].dims);if(j.push(jr),jr.data===0)continue;let e0=this.gpuDataManager.get(jr.data);if(!e0)throw new Error(`no GPU data for output: ${jr.data}`);if(cr&&this.temporaryData.push(e0),fr){let t0=this.kernelPersistentData.get(this.currentKernelId);t0||(t0=[],this.kernelPersistentData.set(this.currentKernelId,t0)),t0.push(e0)}b.push(e0)}if(c.length!==e.length||b.length!==j.length){if(b.length===0)return nt(a.name),j;throw new Error(`Program ${a.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let Et;if(bt){let Qt=0,cr=[];bt.forEach(t0=>{let o0=typeof t0.data=="number"?[t0.data]:t0.data;if(o0.length===0)return;let l0=t0.type===10?2:4,g0,i0;t0.type===10?(i0=o0.length>4?16:o0.length>2?8:o0.length*l0,g0=o0.length>4?16:l0*o0.length):(i0=o0.length<=2?o0.length*l0:16,g0=16),Qt=Math.ceil(Qt/i0)*i0,cr.push(Qt);let f0=t0.type===10?8:4;Qt+=o0.length>4?Math.ceil(o0.length/f0)*g0:o0.length*l0});let fr=16;Qt=Math.ceil(Qt/fr)*fr;let jr=new ArrayBuffer(Qt);bt.forEach((t0,o0)=>{let l0=cr[o0],g0=typeof t0.data=="number"?[t0.data]:t0.data;if(t0.type===6)new Int32Array(jr,l0,g0.length).set(g0);else if(t0.type===12)new Uint32Array(jr,l0,g0.length).set(g0);else if(t0.type===10)new Uint16Array(jr,l0,g0.length).set(g0);else if(t0.type===1)new Float32Array(jr,l0,g0.length).set(g0);else throw new Error(`Unsupported uniform type: ${Bt(t0.type)}`)});let e0=this.gpuDataManager.create(Qt,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(e0.buffer,0,jr,0,Qt),this.gpuDataManager.release(e0.id),Et={offset:0,size:Qt,buffer:e0.buffer}}let It=this.programManager.normalizeDispatchGroupSize(_),zt=It[1]===1&&It[2]===1,er=sf(a,e,zt),Hn=this.programManager.getArtifact(er);if(Hn||(Hn=this.programManager.build(a,It),this.programManager.setArtifact(er,Hn),De("info",()=>`[artifact] key: ${er}, programName: ${a.name}`)),De("info",()=>`[ProgramManager] run "${a.name}" (key=${er}) with ${It[0]}x${It[1]}x${It[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let Qt={kernelId:this.currentKernelId,programName:Hn.programInfo.name,inputTensorViews:e,outputTensorViews:j};this.pendingKernels.push(Qt),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(Qt)}return this.programManager.run(Hn,c,b,It,Et),nt(a.name),j}upload(a,e){this.gpuDataManager.upload(a,e)}memcpy(a,e){this.gpuDataManager.memcpy(a,e)}async download(a,e){await this.gpuDataManager.download(a,e)}alloc(a){return this.gpuDataManager.create(a).id}free(a){return this.gpuDataManager.release(a)}createKernel(a,e,o,s){let d=_l.get(a);if(!d)throw new Error(`kernel not implemented: ${a}`);let c={kernelType:a,kernelName:s,kernelEntry:d[0],attributes:[d[1],o]};this.kernels.set(e,c)}releaseKernel(a){let e=this.kernelPersistentData.get(a);if(e){for(let o of e)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(a)}this.kernelCustomData.delete(a),this.kernels.delete(a)}computeKernel(a,e,o){let s=this.kernels.get(a);if(!s)throw new Error(`kernel not created: ${a}`);let d=s.kernelType,c=s.kernelName,h=s.kernelEntry,_=s.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${d}] ${c}" is not allowed to be called recursively`);this.currentKernelId=a,_[0]&&(_[1]=_[0](_[1]),_[0]=void 0),De("info",()=>`[WebGPU] Start to run kernel "[${d}] ${c}"...`);let bt=this.env.debug;this.temporaryData=[];try{return bt&&this.device.pushErrorScope("validation"),h(e,_[1]),0}catch(g){return o.push(Promise.resolve(`[WebGPU] Kernel "[${d}] ${c}" failed. ${g}`)),1}finally{bt&&o.push(this.device.popErrorScope().then(g=>g?`GPU validation error for kernel "[${d}] ${c}": ${g.message}`:null));for(let g of this.temporaryData)this.gpuDataManager.release(g.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(a,e,o,s){let d=this.sessionExternalDataMapping.get(a);d||(d=new Map,this.sessionExternalDataMapping.set(a,d));let c=d.get(e),h=this.gpuDataManager.registerExternalBuffer(o,s,c==null?void 0:c[1]);return d.set(e,[h,o]),h}unregisterBuffers(a){let e=this.sessionExternalDataMapping.get(a);e&&(e.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(a))}getBuffer(a){let e=this.gpuDataManager.get(a);if(!e)throw new Error(`no GPU data for buffer: ${a}`);return e.buffer}createDownloader(a,e,o){return async()=>{let s=await ua(this,a,e);return ro(s.buffer,o)}}writeTimestamp(a){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,a)}setQueryType(){var a;this.queryType="none",(((a=this.env.webgpu.profiling)==null?void 0:a.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){De("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){De("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){De("info","replay"),this.sessionStatus="replaying";let a=this.capturedCommandList.get(this.currentSessionId),e=this.capturedPendingKernels.get(this.currentSessionId),o=a.length;this.pendingKernels=[];for(let s=0;s<o;s++){let d=this.getComputePassEncoder(),c=a[s];this.writeTimestamp(this.pendingDispatchNumber*2),d.setPipeline(c.computePipeline),d.setBindGroup(0,c.bindGroup),d.dispatchWorkgroups(...c.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(e[s]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onReleaseSession(a){this.unregisterBuffers(a),this.capturedCommandList.has(a)&&this.capturedCommandList.delete(a),this.capturedPendingKernels.has(a)&&this.capturedPendingKernels.delete(a),this.gpuDataManager.onReleaseSession(a)}onRunStart(a){this.currentSessionId=a,this.setQueryType()}}}),Il={};rr(Il,{init:()=>uf});var Pr,Ra,uf,El=F(()=>{ie(),Cl(),Dt(),_e(),Pr=class mA{constructor(e,o,s,d){this.module=e,this.dataType=o,this.data=s,this.dims=d}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let e=M.size(this.dims);return e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let e=M.size(this.dims);return e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let e=M.size(this.dims);return e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(M.size(e)!==M.size(this.dims))throw new Error("Invalid new shape");return new mA(this.module,this.dataType,this.data,e)}},Ra=class{constructor(a,e,o){this.module=a,this.backend=e,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=e.adapterInfo;let s=a.HEAPU32,d=o>>>2;this.opKernelContext=s[d++];let c=s[d++];this.outputCount=s[d++],this.customDataOffset=s[d++],this.customDataSize=s[d++];let h=[];for(let _=0;_<c;_++){let bt=s[d++],g=s[d++],j=s[d++],b=[];for(let Et=0;Et<j;Et++)b.push(s[d++]);h.push(new Pr(a,bt,g,b))}this.inputs=h}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(a,e){var h;let o=((h=e==null?void 0:e.inputs)==null?void 0:h.map(_=>typeof _=="number"?this.inputs[_]:_))??this.inputs,s=(e==null?void 0:e.outputs)??[],d=(_,bt,g)=>new Pr(this.module,bt,this.output(_,g),g),c=(_,bt)=>{let g=Ir(_);if(!g)throw new Error(`Unsupported data type: ${_}`);let j=g*M.size(bt),b=j>0?this.backend.gpuDataManager.create(j).id:0;return new Pr(this.module,_,b,bt)};return this.backend.run(a,o,s,d,c)}output(a,e){let o=this.module.stackSave();try{let s=this.module.stackAlloc((1+e.length)*4),d=s>>2;this.module.HEAPU32[d++]=e.length;for(let c=0;c<e.length;c++)this.module.HEAPU32[d++]=e[c];return this.module._JsepOutput(this.opKernelContext,a,s)}catch(s){throw new Error(`Failed to generate kernel's output[${a}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${s}`)}finally{this.module.stackRestore(o)}}},uf=async(a,e,o,s)=>{let d=e.jsepInit;if(!d)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(a==="webgpu"){let c=new Pn;await c.initialize(o,s),d("webgpu",[c,h=>c.alloc(h),h=>c.free(h),(h,_,bt,g=!1)=>{if(g)De("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${h}, dst=${_}, size=${bt}`),c.memcpy(h,_);else{De("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${h}, gpuDataId=${_}, size=${bt}`);let j=e.HEAPU8.subarray(h>>>0,(h>>>0)+bt);c.upload(_,j)}},async(h,_,bt)=>{De("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${h}, dataOffset=${_}, size=${bt}`),await c.download(h,()=>e.HEAPU8.subarray(_>>>0,(_>>>0)+bt))},(h,_,bt)=>c.createKernel(h,_,bt,e.UTF8ToString(e._JsepGetNodeName(_))),h=>c.releaseKernel(h),(h,_,bt,g)=>{De("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${bt}, kernel=${h}, contextDataOffset=${_}`);let j=new Ra(e,c,_);return c.computeKernel(h,j,g)},()=>c.captureBegin(),()=>c.captureEnd(),()=>c.replay()])}else d("webnn")}}),lf,Tl,Ol,jt,df,za,kl,Pl,Al,Rl,zl,Bl,Dl=F(()=>{Zi(),Qi(),ie(),nr(),on(),oa(),lf=(a,e)=>{Ge()._OrtInit(a,e)!==0&&Be("Can't initialize onnxruntime.")},Tl=async a=>{lf(a.wasm.numThreads,Er(a.logLevel))},Ol=async(a,e)=>{{let o=(El(),Gt(Il)).init;if(e==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let s=a.webgpu.adapter;if(s){if(typeof s.limits!="object"||typeof s.features!="object"||typeof s.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let d=a.webgpu.powerPreference;if(d!==void 0&&d!=="low-power"&&d!=="high-performance")throw new Error(`Invalid powerPreference setting: "${d}"`);let c=a.webgpu.forceFallbackAdapter;if(c!==void 0&&typeof c!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${c}"`);if(s=await navigator.gpu.requestAdapter({powerPreference:d,forceFallbackAdapter:c}),!s)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}if(!a.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");await o("webgpu",Ge(),a,s)}if(e==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await o("webnn",Ge(),a)}}},jt=new Map,df=a=>{let e=Ge(),o=e.stackSave();try{let s=e.stackAlloc(8);return e._OrtGetInputOutputCount(a,s,s+4)!==0&&Be("Can't get session input/output count."),[e.HEAP32[s/4],e.HEAP32[s/4+1]]}finally{e.stackRestore(o)}},za=a=>{let e=Ge(),o=e._malloc(a.byteLength);if(o===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${a.byteLength}.`);return e.HEAPU8.set(a,o),[o,a.byteLength]},kl=async(a,e)=>{var b,Et;let o,s,d=Ge();Array.isArray(a)?[o,s]=a:a.buffer===d.HEAPU8.buffer?[o,s]=[a.byteOffset,a.byteLength]:[o,s]=za(a);let c=0,h=0,_=0,bt=[],g=[],j=[];try{if([h,bt]=Xi(e),(e==null?void 0:e.externalData)&&d.mountExternalData){let jr=[];for(let e0 of e.externalData){let t0=typeof e0=="string"?e0:e0.path;jr.push(Ar(typeof e0=="string"?e0:e0.data).then(o0=>{d.mountExternalData(t0,o0)}))}await Promise.all(jr)}c=await d._OrtCreateSession(o,s,h),c===0&&Be("Can't create a session.");let[It,zt]=df(c),er=!!(e!=null&&e.enableGraphCapture),Hn=[],Qt=[],cr=[];for(let jr=0;jr<It;jr++){let e0=d._OrtGetInputName(c,jr);e0===0&&Be("Can't get an input name."),g.push(e0),Hn.push(d.UTF8ToString(e0))}for(let jr=0;jr<zt;jr++){let e0=d._OrtGetOutputName(c,jr);e0===0&&Be("Can't get an output name."),j.push(e0);let t0=d.UTF8ToString(e0);Qt.push(t0);{if(er&&(e==null?void 0:e.preferredOutputLocation)===void 0){cr.push("gpu-buffer");continue}let o0=typeof(e==null?void 0:e.preferredOutputLocation)=="string"?e.preferredOutputLocation:((b=e==null?void 0:e.preferredOutputLocation)==null?void 0:b[t0])??"cpu";if(o0!=="cpu"&&o0!=="cpu-pinned"&&o0!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${o0}.`);if(er&&o0!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${o0}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);cr.push(o0)}}let fr=null;return cr.some(jr=>jr==="gpu-buffer")&&(_=d._OrtCreateBinding(c),_===0&&Be("Can't create IO binding."),fr={handle:_,outputPreferredLocations:cr,outputPreferredLocationsEncoded:cr.map(jr=>ia(jr))}),jt.set(c,[c,g,j,fr,er,!1]),[c,Hn,Qt]}catch(It){throw g.forEach(zt=>d._OrtFree(zt)),j.forEach(zt=>d._OrtFree(zt)),_!==0&&d._OrtReleaseBinding(_),c!==0&&d._OrtReleaseSession(c),It}finally{d._free(o),h!==0&&d._OrtReleaseSessionOptions(h),bt.forEach(It=>d._free(It)),(Et=d.unmountExternalData)==null||Et.call(d)}},Pl=a=>{var bt;let e=Ge(),o=jt.get(a);if(!o)throw new Error(`cannot release session. invalid session id: ${a}`);let[s,d,c,h,_]=o;h&&(_&&e._OrtClearBoundOutputs(h.handle),e._OrtReleaseBinding(h.handle)),(bt=e.jsepOnReleaseSession)==null||bt.call(e,a),d.forEach(g=>e._OrtFree(g)),c.forEach(g=>e._OrtFree(g)),e._OrtReleaseSession(s),jt.delete(a)},Al=(a,e,o,s,d,c=!1)=>{if(!a){e.push(0);return}let h=Ge(),_=a[0],bt=a[1],g=a[3],j,b;if(_==="string"&&g==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(c&&g!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${d} when enableGraphCapture is true.`);if(g==="gpu-buffer"){let zt=a[2].gpuBuffer,er=Ir(aa(_));b=bt.reduce((Qt,cr)=>Qt*cr,1)*er;let Hn=h.jsepRegisterBuffer;if(!Hn)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');j=Hn(s,d,zt,b)}else{let zt=a[2];if(Array.isArray(zt)){b=4*zt.length,j=h._malloc(b),o.push(j);let er=j/4;for(let Hn=0;Hn<zt.length;Hn++){if(typeof zt[Hn]!="string")throw new TypeError(`tensor data at index ${Hn} is not a string`);h.HEAPU32[er++]=He(zt[Hn],o)}}else b=zt.byteLength,j=h._malloc(b),o.push(j),h.HEAPU8.set(new Uint8Array(zt.buffer,zt.byteOffset,b),j)}let Et=h.stackSave(),It=h.stackAlloc(4*bt.length);try{let zt=It/4;bt.forEach(Hn=>h.HEAP32[zt++]=Hn);let er=h._OrtCreateTensor(aa(_),j,b,It,bt.length,ia(g));er===0&&Be(`Can't create tensor for input/output. session=${s}, index=${d}.`),e.push(er)}finally{h.stackRestore(Et)}},Rl=async(a,e,o,s,d,c)=>{var i0,f0;let h=Ge(),_=jt.get(a);if(!_)throw new Error(`cannot run inference. invalid session id: ${a}`);let bt=_[0],g=_[1],j=_[2],b=_[3],Et=_[4],It=_[5],zt=e.length,er=s.length,Hn=0,Qt=[],cr=[],fr=[],jr=[],e0=h.stackSave(),t0=h.stackAlloc(zt*4),o0=h.stackAlloc(zt*4),l0=h.stackAlloc(er*4),g0=h.stackAlloc(er*4);try{[Hn,Qt]=Yi(c);for(let w0=0;w0<zt;w0++)Al(o[w0],cr,jr,a,e[w0],Et);for(let w0=0;w0<er;w0++)Al(d[w0],fr,jr,a,zt+s[w0],Et);let C0=t0/4,Z0=o0/4,R0=l0/4,Y0=g0/4;for(let w0=0;w0<zt;w0++)h.HEAPU32[C0++]=cr[w0],h.HEAPU32[Z0++]=g[e[w0]];for(let w0=0;w0<er;w0++)h.HEAPU32[R0++]=fr[w0],h.HEAPU32[Y0++]=j[s[w0]];if(b&&!It){let{handle:w0,outputPreferredLocations:L0,outputPreferredLocationsEncoded:k0}=b;if(g.length!==zt)throw new Error(`input count from feeds (${zt}) is expected to be always equal to model's input count (${g.length}).`);for(let T0=0;T0<zt;T0++){let q0=e[T0];await h._OrtBindInput(w0,g[q0],cr[T0])!==0&&Be(`Can't bind input[${T0}] for session=${a}.`)}for(let T0=0;T0<er;T0++){let q0=s[T0];(i0=d[T0])!=null&&i0[3]?h._OrtBindOutput(w0,j[q0],fr[T0],0)!==0&&Be(`Can't bind pre-allocated output[${T0}] for session=${a}.`):h._OrtBindOutput(w0,j[q0],0,k0[q0])!==0&&Be(`Can't bind output[${T0}] to ${L0[T0]} for session=${a}.`)}jt.set(a,[bt,g,j,b,Et,!0])}(f0=h.jsepOnRunStart)==null||f0.call(h,bt);let H0;b?H0=await h._OrtRunWithBinding(bt,b.handle,er,l0,Hn):H0=await h._OrtRun(bt,o0,t0,zt,g0,er,l0,Hn),H0!==0&&Be("failed to call OrtRun().");let ty=[];for(let w0=0;w0<er;w0++){let L0=h.HEAPU32[l0/4+w0];if(L0===fr[w0]){ty.push(d[w0]);continue}let k0=h.stackSave(),T0=h.stackAlloc(4*4),q0=!1,vy,J0=0;try{h._OrtGetTensorData(L0,T0,T0+4,T0+8,T0+12)!==0&&Be(`Can't access output tensor data on index ${w0}.`);let cy=T0/4,Ty=h.HEAPU32[cy++];J0=h.HEAPU32[cy++];let Uy=h.HEAPU32[cy++],Qy=h.HEAPU32[cy++],Zy=[];for(let B0=0;B0<Qy;B0++)Zy.push(h.HEAPU32[Uy/4+B0]);h._OrtFree(Uy);let iv=Zy.reduce((B0,Ay)=>B0*Ay,1);vy=Bt(Ty);let zy=b==null?void 0:b.outputPreferredLocations[s[w0]];if(vy==="string"){if(zy==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let B0=[],Ay=J0/4;for(let hy=0;hy<iv;hy++){let Ly=h.HEAPU32[Ay++],Iy=hy===iv-1?void 0:h.HEAPU32[Ay]-Ly;B0.push(h.UTF8ToString(Ly,Iy))}ty.push([vy,Zy,B0,"cpu"])}else if(zy==="gpu-buffer"&&iv>0){let B0=h.jsepGetBuffer;if(!B0)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let Ay=B0(J0),hy=Ir(Ty);if(hy===void 0||!un(vy))throw new Error(`Unsupported data type: ${vy}`);q0=!0,ty.push([vy,Zy,{gpuBuffer:Ay,download:h.jsepCreateDownloader(Ay,iv*hy,vy),dispose:()=>{h._OrtReleaseTensor(L0)}},"gpu-buffer"])}else{let B0=sn(vy),Ay=new B0(iv);new Uint8Array(Ay.buffer,Ay.byteOffset,Ay.byteLength).set(h.HEAPU8.subarray(J0,J0+Ay.byteLength)),ty.push([vy,Zy,Ay,"cpu"])}}finally{h.stackRestore(k0),vy==="string"&&J0&&h._free(J0),q0||h._OrtReleaseTensor(L0)}}return b&&!Et&&(h._OrtClearBoundOutputs(b.handle),jt.set(a,[bt,g,j,b,Et,!1])),ty}finally{h.stackRestore(e0),cr.forEach(C0=>h._OrtReleaseTensor(C0)),fr.forEach(C0=>h._OrtReleaseTensor(C0)),jr.forEach(C0=>h._free(C0)),Hn!==0&&h._OrtReleaseRunOptions(Hn),Qt.forEach(C0=>h._free(C0))}},zl=a=>{let e=Ge(),o=jt.get(a);if(!o)throw new Error("invalid session id");let s=o[0],d=e._OrtEndProfiling(s);d===0&&Be("Can't get an profile file name."),e._OrtFree(d)},Bl=a=>{let e=[];for(let o of a){let s=o[2];!Array.isArray(s)&&"buffer"in s&&e.push(s.buffer)}return e}}),Ml=tr((a,e)=>{e.exports='/*!\n * ONNX Runtime Web v1.17.3\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var vn=Object.defineProperty;var dd=Object.getOwnPropertyDescriptor;var ld=Object.getOwnPropertyNames;var cd=Object.prototype.hasOwnProperty;var q=(e,t)=>()=>(e&&(t=e(e=0)),t);var pr=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Mr=(e,t)=>{for(var r in t)vn(e,r,{get:t[r],enumerable:!0})},pd=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of ld(t))!cd.call(e,n)&&n!==r&&vn(e,n,{get:()=>t[n],enumerable:!(o=dd(t,n))||o.enumerable});return e};var Ft=e=>pd(vn({},"__esModule",{value:!0}),e);var $n={};Mr($n,{createReadStream:()=>Po,readFile:()=>md,readFileSync:()=>fd});var md,fd,Po,_n=q(()=>{md=void 0,fd=void 0,Po=void 0});var xn={};Mr(xn,{join:()=>hd});var hd,Sn=q(()=>{hd=void 0});var Ro=pr((ko,Cn)=>{"use strict";var Oo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,o,n;r.ready=new Promise((d,h)=>{o=d,n=h}),r.mountExternalData=(d,h)=>{(r.Fa||(r.Fa=new Map)).set(d,h)},r.unmountExternalData=()=>{delete r.Fa};let s=()=>{let d=(w,S,P)=>(...N)=>{let K=nt,X=S?.();N=w(...N);let ae=S?.();return X!==ae&&(w=ae,P(X),S=P=null),nt!=K?Cr():N},h=w=>async(...S)=>{try{if(r.Ea)throw Error("Session already started");let P=r.Ea={Za:S[0],errors:[]},N=await w(...S);if(r.Ea!==P)throw Error("Session mismatch");r.La?.flush();let K=P.errors;if(0<K.length){let X=await Promise.all(K);if(X=X.filter(ae=>ae),0<X.length)throw Error(X.join(`\n`))}return N}finally{r.Ea=null}};r._OrtCreateSession=d(r._OrtCreateSession,()=>r._OrtCreateSession,w=>r._OrtCreateSession=w),r._OrtRun=h(d(r._OrtRun,()=>r._OrtRun,w=>r._OrtRun=w)),r._OrtRunWithBinding=h(d(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,w=>r._OrtRunWithBinding=w)),r._OrtBindInput=d(r._OrtBindInput,()=>r._OrtBindInput,w=>r._OrtBindInput=w),s=void 0};r.jsepInit=(d,h)=>{if(s?.(),d==="webgpu"){[r.La,r.Ra,r.Va,r.Ma,r.Ua,r.sa,r.Wa,r.Ya,r.Sa,r.Ta,r.Xa]=h;let w=r.La;r.jsepRegisterBuffer=(S,P,N,K)=>w.registerBuffer(S,P,N,K),r.jsepGetBuffer=S=>w.getBuffer(S),r.jsepCreateDownloader=(S,P,N)=>w.createDownloader(S,P,N),r.jsepOnReleaseSession=S=>{w.onReleaseSession(S)},r.jsepOnRunStart=S=>w.onRunStart(S)}};var u=Object.assign({},r),l="./this.program",a=(d,h)=>{throw h},p=typeof window=="object",m=typeof importScripts=="function",f=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",b="",_,y,$;if(f){var I=(_n(),Ft($n)),C=(Sn(),Ft(xn));b=m?C.dirname(b)+"/":__dirname+"/",_=(d,h)=>(d=Ae(d)?new URL(d):C.normalize(d),I.readFileSync(d,h?void 0:"utf8")),$=d=>(d=_(d,!0),d.buffer||(d=new Uint8Array(d)),d),y=(d,h,w,S=!0)=>{d=Ae(d)?new URL(d):C.normalize(d),I.readFile(d,S?void 0:"utf8",(P,N)=>{P?w(P):h(S?N.buffer:N)})},!r.thisProgram&&1<process.argv.length&&(l=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),a=(d,h)=>{throw process.exitCode=d,h},r.inspect=()=>"[Emscripten Module object]"}else(p||m)&&(m?b=self.location.href:typeof document<"u"&&document.currentScript&&(b=document.currentScript.src),e&&(b=e),b.indexOf("blob:")!==0?b=b.substr(0,b.replace(/[?#].*/,"").lastIndexOf("/")+1):b="",_=d=>{var h=new XMLHttpRequest;return h.open("GET",d,!1),h.send(null),h.responseText},m&&($=d=>{var h=new XMLHttpRequest;return h.open("GET",d,!1),h.responseType="arraybuffer",h.send(null),new Uint8Array(h.response)}),y=(d,h,w)=>{var S=new XMLHttpRequest;S.open("GET",d,!0),S.responseType="arraybuffer",S.onload=()=>{S.status==200||S.status==0&&S.response?h(S.response):w()},S.onerror=w,S.send(null)});var v=console.log.bind(console),A=console.error.bind(console);Object.assign(r,u),u=null,typeof WebAssembly!="object"&&se("no native wasm support detected");var T,D=!1,U,V,H,R,L,pe,Ie;function we(){var d=T.buffer;r.HEAP8=V=new Int8Array(d),r.HEAP16=new Int16Array(d),r.HEAPU8=H=new Uint8Array(d),r.HEAPU16=new Uint16Array(d),r.HEAP32=R=new Int32Array(d),r.HEAPU32=L=new Uint32Array(d),r.HEAPF32=pe=new Float32Array(d),r.HEAPF64=Ie=new Float64Array(d)}var ne=[],ze=[],Q=[],xe=0,me=null,ue=null;function se(d){throw d="Aborted("+d+")",A(d),D=!0,U=1,d=new WebAssembly.RuntimeError(d+". Build with -sASSERTIONS for more info."),n(d),d}var he=d=>d.startsWith("data:application/octet-stream;base64,"),Ae=d=>d.startsWith("file://"),He;if(He="ort-wasm-simd.wasm",!he(He)){var G=He;He=r.locateFile?r.locateFile(G,b):b+G}function J(d){if($)return $(d);throw"both async and sync fetching of the wasm failed"}function Se(d){if(p||m){if(typeof fetch=="function"&&!Ae(d))return fetch(d,{credentials:"same-origin"}).then(h=>{if(!h.ok)throw"failed to load wasm binary file at \'"+d+"\'";return h.arrayBuffer()}).catch(()=>J(d));if(y)return new Promise((h,w)=>{y(d,S=>h(new Uint8Array(S)),w)})}return Promise.resolve().then(()=>J(d))}function Qe(d,h,w){return Se(d).then(S=>WebAssembly.instantiate(S,h)).then(S=>S).then(w,S=>{A(`failed to asynchronously prepare wasm: ${S}`),se(S)})}function Xe(d,h){var w=He;return typeof WebAssembly.instantiateStreaming!="function"||he(w)||Ae(w)||f||typeof fetch!="function"?Qe(w,d,h):fetch(w,{credentials:"same-origin"}).then(S=>WebAssembly.instantiateStreaming(S,d).then(h,function(P){return A(`wasm streaming compile failed: ${P}`),A("falling back to ArrayBuffer instantiation"),Qe(w,d,h)}))}var Le,wt={931760:(d,h,w,S)=>{if(typeof r>"u"||!r.Fa)return 1;if(d=qe(d>>>0),d.startsWith("./")&&(d=d.substring(2)),d=r.Fa.get(d),!d)return 2;if(h>>>=0,w>>>=0,h+w>d.byteLength)return 3;try{return H.set(d.subarray(h,h+w),S>>>0>>>0),0}catch{return 4}},932261:()=>{r.Sa()},932292:()=>{r.Ta()},932321:()=>{r.Xa()},932346:d=>r.Ra(d),932379:d=>r.Va(d),932411:(d,h,w)=>{r.Ma(d,h,w,!0)},932450:(d,h,w)=>{r.Ma(d,h,w)},932483:d=>{r.sa("Abs",d,void 0)},932534:d=>{r.sa("Neg",d,void 0)},932585:d=>{r.sa("Floor",d,void 0)},932638:d=>{r.sa("Ceil",d,void 0)},932690:d=>{r.sa("Reciprocal",d,void 0)},932748:d=>{r.sa("Sqrt",d,void 0)},932800:d=>{r.sa("Exp",d,void 0)},932851:d=>{r.sa("Erf",d,void 0)},932902:d=>{r.sa("Sigmoid",d,void 0)},932957:(d,h,w)=>{r.sa("HardSigmoid",d,{alpha:h,beta:w})},933036:d=>{r.sa("Log",d,void 0)},933087:d=>{r.sa("Sin",d,void 0)},933138:d=>{r.sa("Cos",d,void 0)},933189:d=>{r.sa("Tan",d,void 0)},933240:d=>{r.sa("Asin",d,void 0)},933292:d=>{r.sa("Acos",d,void 0)},933344:d=>{r.sa("Atan",d,void 0)},933396:d=>{r.sa("Sinh",d,void 0)},933448:d=>{r.sa("Cosh",d,void 0)},933500:d=>{r.sa("Asinh",d,void 0)},933553:d=>{r.sa("Acosh",d,void 0)},933606:d=>{r.sa("Atanh",d,void 0)},933659:d=>{r.sa("Tanh",d,void 0)},933711:d=>{r.sa("Not",d,void 0)},933762:(d,h,w)=>{r.sa("Clip",d,{min:h,max:w})},933831:d=>{r.sa("Clip",d,void 0)},933883:(d,h)=>{r.sa("Elu",d,{alpha:h})},933941:d=>{r.sa("Relu",d,void 0)},933993:(d,h)=>{r.sa("LeakyRelu",d,{alpha:h})},934057:(d,h)=>{r.sa("ThresholdedRelu",d,{alpha:h})},934127:(d,h)=>{r.sa("Cast",d,{to:h})},934185:d=>{r.sa("Add",d,void 0)},934236:d=>{r.sa("Sub",d,void 0)},934287:d=>{r.sa("Mul",d,void 0)},934338:d=>{r.sa("Div",d,void 0)},934389:d=>{r.sa("Pow",d,void 0)},934440:d=>{r.sa("Equal",d,void 0)},934493:d=>{r.sa("Greater",d,void 0)},934548:d=>{r.sa("GreaterOrEqual",d,void 0)},934610:d=>{r.sa("Less",d,void 0)},934662:d=>{r.sa("LessOrEqual",d,void 0)},934721:(d,h,w,S,P)=>{r.sa("ReduceMean",d,{keepDims:!!h,noopWithEmptyAxes:!!w,axes:S?Array.from(R.subarray(S>>>0,P>>>0)):[]})},934880:(d,h,w,S,P)=>{r.sa("ReduceMax",d,{keepDims:!!h,noopWithEmptyAxes:!!w,axes:S?Array.from(R.subarray(S>>>0,P>>>0)):[]})},935038:(d,h,w,S,P)=>{r.sa("ReduceMin",d,{keepDims:!!h,noopWithEmptyAxes:!!w,axes:S?Array.from(R.subarray(S>>>0,P>>>0)):[]})},935196:(d,h,w,S,P)=>{r.sa("ReduceProd",d,{keepDims:!!h,noopWithEmptyAxes:!!w,axes:S?Array.from(R.subarray(S>>>0,P>>>0)):[]})},935355:(d,h,w,S,P)=>{r.sa("ReduceSum",d,{keepDims:!!h,noopWithEmptyAxes:!!w,axes:S?Array.from(R.subarray(S>>>0,P>>>0)):[]})},935513:(d,h,w,S,P)=>{r.sa("ReduceL1",d,{keepDims:!!h,noopWithEmptyAxes:!!w,axes:S?Array.from(R.subarray(S>>>0,P>>>0)):[]})},935670:(d,h,w,S,P)=>{r.sa("ReduceL2",d,{keepDims:!!h,noopWithEmptyAxes:!!w,axes:S?Array.from(R.subarray(S>>>0,P>>>0)):[]})},935827:(d,h,w,S,P)=>{r.sa("ReduceLogSum",d,{keepDims:!!h,noopWithEmptyAxes:!!w,axes:S?Array.from(R.subarray(S>>>0,P>>>0)):[]})},935988:(d,h,w,S,P)=>{r.sa("ReduceSumSquare",d,{keepDims:!!h,noopWithEmptyAxes:!!w,axes:S?Array.from(R.subarray(S>>>0,P>>>0)):[]})},936152:(d,h,w,S,P)=>{r.sa("ReduceLogSumExp",d,{keepDims:!!h,noopWithEmptyAxes:!!w,axes:S?Array.from(R.subarray(S>>>0,P>>>0)):[]})},936316:d=>{r.sa("Where",d,void 0)},936369:(d,h,w)=>{r.sa("Transpose",d,{perm:h?Array.from(R.subarray(h>>>0,w>>>0)):[]})},936477:(d,h,w,S,P,N,K,X,ae,de,fe,Oe,Re,O,oe)=>{r.sa("ConvTranspose",d,{format:ae?"NHWC":"NCHW",autoPad:h,dilations:[w],group:S,kernel_shape:[P],pads:[N,K],strides:[X],wIsConst:()=>!!V[de>>>0],outputPadding:fe?Array.from(R.subarray(fe>>>0,Oe>>>0)):[],outputShape:Re?Array.from(R.subarray(Re>>>0,O>>>0)):[],activation:qe(oe)})},936879:(d,h,w,S,P,N,K,X,ae,de,fe,Oe,Re,O)=>{r.sa("ConvTranspose",d,{format:X?"NHWC":"NCHW",autoPad:h,dilations:Array.from(R.subarray(w>>>0,(w>>>0)+2>>>0)),group:S,kernelShape:Array.from(R.subarray(P>>>0,(P>>>0)+2>>>0)),pads:Array.from(R.subarray(N>>>0,(N>>>0)+4>>>0)),strides:Array.from(R.subarray(K>>>0,(K>>>0)+2>>>0)),wIsConst:()=>!!V[ae>>>0],outputPadding:de?Array.from(R.subarray(de>>>0,fe>>>0)):[],outputShape:Oe?Array.from(R.subarray(Oe>>>0,Re>>>0)):[],activation:qe(O)})},937444:(d,h,w,S,P,N,K,X,ae,de,fe,Oe,Re,O,oe)=>{r.sa("ConvTranspose",d,{format:ae?"NHWC":"NCHW",autoPad:h,dilations:[w],group:S,kernel_shape:[P],pads:[N,K],strides:[X],wIsConst:()=>!!V[de>>>0],outputPadding:fe?Array.from(R.subarray(fe>>>0,Oe>>>0)):[],outputShape:Re?Array.from(R.subarray(Re>>>0,O>>>0)):[],activation:qe(oe)})},937846:(d,h,w,S,P,N,K,X,ae,de,fe,Oe,Re,O)=>{r.sa("ConvTranspose",d,{format:X?"NHWC":"NCHW",autoPad:h,dilations:Array.from(R.subarray(w>>>0,(w>>>0)+2>>>0)),group:S,kernelShape:Array.from(R.subarray(P>>>0,(P>>>0)+2>>>0)),pads:Array.from(R.subarray(N>>>0,(N>>>0)+4>>>0)),strides:Array.from(R.subarray(K>>>0,(K>>>0)+2>>>0)),wIsConst:()=>!!V[ae>>>0],outputPadding:de?Array.from(R.subarray(de>>>0,fe>>>0)):[],outputShape:Oe?Array.from(R.subarray(Oe>>>0,Re>>>0)):[],activation:qe(O)})},938411:(d,h)=>{r.sa("GlobalAveragePool",d,{format:h?"NHWC":"NCHW"})},938502:(d,h,w,S,P,N,K,X,ae,de,fe,Oe,Re,O,oe,Ce)=>{r.sa("AveragePool",d,{format:Ce?"NHWC":"NCHW",auto_pad:h,ceil_mode:w,count_include_pad:S,storage_order:P,dilations:[N,K],kernel_shape:[X,ae],pads:[de,fe,Oe,Re],strides:[O,oe]})},938786:(d,h)=>{r.sa("GlobalAveragePool",d,{format:h?"NHWC":"NCHW"})},938877:(d,h,w,S,P,N,K,X,ae,de,fe,Oe,Re,O,oe,Ce)=>{r.sa("AveragePool",d,{format:Ce?"NHWC":"NCHW",auto_pad:h,ceil_mode:w,count_include_pad:S,storage_order:P,dilations:[N,K],kernel_shape:[X,ae],pads:[de,fe,Oe,Re],strides:[O,oe]})},939161:(d,h)=>{r.sa("GlobalMaxPool",d,{format:h?"NHWC":"NCHW"})},939248:(d,h,w,S,P,N,K,X,ae,de,fe,Oe,Re,O,oe,Ce)=>{r.sa("MaxPool",d,{format:Ce?"NHWC":"NCHW",auto_pad:h,ceil_mode:w,count_include_pad:S,storage_order:P,dilations:[N,K],kernel_shape:[X,ae],pads:[de,fe,Oe,Re],strides:[O,oe]})},939528:(d,h)=>{r.sa("GlobalMaxPool",d,{format:h?"NHWC":"NCHW"})},939615:(d,h,w,S,P,N,K,X,ae,de,fe,Oe,Re,O,oe,Ce)=>{r.sa("MaxPool",d,{format:Ce?"NHWC":"NCHW",auto_pad:h,ceil_mode:w,count_include_pad:S,storage_order:P,dilations:[N,K],kernel_shape:[X,ae],pads:[de,fe,Oe,Re],strides:[O,oe]})},939895:(d,h,w,S,P)=>{r.sa("Gemm",d,{alpha:h,beta:w,transA:S,transB:P})},939999:d=>{r.sa("MatMul",d,void 0)},940053:(d,h,w,S)=>{r.sa("ArgMax",d,{keepDims:!!h,selectLastIndex:!!w,axis:S})},940161:(d,h,w,S)=>{r.sa("ArgMin",d,{keepDims:!!h,selectLastIndex:!!w,axis:S})},940269:(d,h)=>{r.sa("Softmax",d,{axis:h})},940332:(d,h)=>{r.sa("Concat",d,{axis:h})},940392:(d,h,w,S,P)=>{r.sa("Split",d,{axis:h,numOutputs:w,splitSizes:S?Array.from(R.subarray(S>>>0,P>>>0)):[]})},940532:d=>{r.sa("Expand",d,void 0)},940586:(d,h)=>{r.sa("Gather",d,{axis:Number(h)})},940657:(d,h)=>{r.sa("GatherElements",d,{axis:Number(h)})},940736:(d,h,w,S,P,N,K,X,ae,de,fe)=>{r.sa("Resize",d,{antialias:h,axes:w?Array.from(R.subarray(w>>>0,S>>>0)):[],coordinateTransformMode:qe(P),cubicCoeffA:N,excludeOutside:K,extrapolationValue:X,keepAspectRatioPolicy:qe(ae),mode:qe(de),nearestMode:qe(fe)})},941082:(d,h,w,S,P,N,K)=>{r.sa("Slice",d,{starts:h?Array.from(R.subarray(h>>>0,w>>>0)):[],ends:S?Array.from(R.subarray(S>>>0,P>>>0)):[],axes:N?Array.from(R.subarray(N>>>0,K>>>0)):[]})},941298:d=>{r.sa("Tile",d,void 0)},941350:(d,h,w)=>{r.sa("LayerNormalization",d,{axis:Number(h),epsilon:Number(w)})},941457:(d,h,w)=>{r.sa("InstanceNormalization",d,{epsilon:h,format:w?"NHWC":"NCHW"})},941571:(d,h,w)=>{r.sa("InstanceNormalization",d,{epsilon:h,format:w?"NHWC":"NCHW"})},941685:d=>{r.sa("Range",d,void 0)},941738:(d,h)=>{r.sa("Einsum",d,{equation:qe(h)})},941819:(d,h,w,S,P)=>{r.sa("Pad",d,{mode:h,value:w,pads:S?Array.from(R.subarray(S>>>0,P>>>0)):[]})},941946:(d,h,w,S,P,N)=>{r.sa("BatchNormalization",d,{epsilon:h,momentum:w,spatial:!!P,trainingMode:!!S,format:N?"NHWC":"NCHW"})},942115:(d,h,w,S,P,N)=>{r.sa("BatchNormalization",d,{epsilon:h,momentum:w,spatial:!!P,trainingMode:!!S,format:N?"NHWC":"NCHW"})},942284:(d,h,w)=>{r.sa("CumSum",d,{exclusive:Number(h),reverse:Number(w)})},942381:(d,h,w,S,P,N,K,X,ae)=>{r.sa("Attention",d,{numHeads:h,isUnidirectional:w,maskFilterValue:S,scale:P,doRotary:N,qkvHiddenSizes:K?Array.from(R.subarray(Number(X)>>>0,Number(X)+K>>>0)):[],pastPresentShareBuffer:!!ae})},942653:d=>{r.sa("BiasAdd",d,void 0)},942708:d=>{r.sa("BiasSplitGelu",d,void 0)},942769:d=>{r.sa("FastGelu",d,void 0)},942825:(d,h,w,S,P,N,K,X,ae,de,fe,Oe,Re)=>{r.sa("Conv",d,{format:ae?"NHWC":"NCHW",auto_pad:h,dilations:[w],group:S,kernel_shape:[P],pads:N?Array.from(R.subarray(N>>>0,K>>>0)):[],strides:[X],w_is_const:()=>!!V[de>>>0],activation:qe(fe),activation_params:Oe?Array.from(pe.subarray(Oe>>>0,Re>>>0)):[]})},943195:(d,h,w,S,P,N,K,X,ae,de,fe,Oe,Re,O,oe,Ce)=>{r.sa("Conv",d,{format:Oe?"NHWC":"NCHW",auto_pad:h,dilations:[w,S],group:P,kernel_shape:[N,K],pads:X?Array.from(R.subarray(X>>>0,ae>>>0)):[],strides:[de,fe],w_is_const:()=>!!V[Re>>>0],activation:qe(O),activation_params:oe?Array.from(pe.subarray(oe>>>0,Ce>>>0)):[]})},943586:d=>{r.sa("Gelu",d,void 0)},943638:(d,h,w,S,P,N)=>{r.sa("MatMulNBits",d,{k:h,n:w,accuracyLevel:S,bits:P,blockSize:N})},943765:(d,h,w,S,P,N)=>{r.sa("MultiHeadAttention",d,{numHeads:h,isUnidirectional:w,maskFilterValue:S,scale:P,doRotary:N})},943924:(d,h)=>{r.sa("SkipLayerNormalization",d,{epsilon:h})},944005:d=>{r.Wa(d)},944039:(d,h)=>r.Ya(d,h,r.Ea.Za,r.Ea.errors)};function Ne(d){this.name="ExitStatus",this.message=`Program terminated with exit(${d})`,this.status=d}function Fe(d){this.Ja=d-24,this.Pa=function(h){L[this.Ja+4>>>2>>>0]=h},this.Oa=function(h){L[this.Ja+8>>>2>>>0]=h},this.eb=function(h,w){this.Na(),this.Pa(h),this.Oa(w)},this.Na=function(){L[this.Ja+16>>>2>>>0]=0}}var Je=0,kt=0,vt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,xt=(d,h,w)=>{h>>>=0;var S=h+w;for(w=h;d[w]&&!(w>=S);)++w;if(16<w-h&&d.buffer&&vt)return vt.decode(d.subarray(h,w));for(S="";h<w;){var P=d[h++];if(P&128){var N=d[h++]&63;if((P&224)==192)S+=String.fromCharCode((P&31)<<6|N);else{var K=d[h++]&63;P=(P&240)==224?(P&15)<<12|N<<6|K:(P&7)<<18|N<<12|K<<6|d[h++]&63,65536>P?S+=String.fromCharCode(P):(P-=65536,S+=String.fromCharCode(55296|P>>10,56320|P&1023))}}else S+=String.fromCharCode(P)}return S},qe=(d,h)=>(d>>>=0)?xt(H,d,h):"",Zt=d=>{for(var h=0,w=0;w<d.length;++w){var S=d.charCodeAt(w);127>=S?h++:2047>=S?h+=2:55296<=S&&57343>=S?(h+=4,++w):h+=3}return h},Vt=(d,h,w,S)=>{if(w>>>=0,!(0<S))return 0;var P=w;S=w+S-1;for(var N=0;N<d.length;++N){var K=d.charCodeAt(N);if(55296<=K&&57343>=K){var X=d.charCodeAt(++N);K=65536+((K&1023)<<10)|X&1023}if(127>=K){if(w>=S)break;h[w++>>>0]=K}else{if(2047>=K){if(w+1>=S)break;h[w++>>>0]=192|K>>6}else{if(65535>=K){if(w+2>=S)break;h[w++>>>0]=224|K>>12}else{if(w+3>=S)break;h[w++>>>0]=240|K>>18,h[w++>>>0]=128|K>>12&63}h[w++>>>0]=128|K>>6&63}h[w++>>>0]=128|K&63}}return h[w>>>0]=0,w-P},St=d=>d%4===0&&(d%100!==0||d%400===0),$t=[0,31,60,91,121,152,182,213,244,274,305,335],Nt=[0,31,59,90,120,151,181,212,243,273,304,334],Wt=d=>{var h=Zt(d)+1,w=Lt(h);return w&&Vt(d,H,w,h),w},Rt=[],Qt=(d,h)=>{Rt.length=0;for(var w;w=H[d++>>>0];){var S=w!=105;S&=w!=112,h+=S&&h%8?4:0,Rt.push(w==112?L[h>>>2>>>0]:w==105?R[h>>>2>>>0]:Ie[h>>>3>>>0]),h+=S?8:4}return Rt},at={},Xt=()=>{if(!Gt){var d={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:l||"./this.program"},h;for(h in at)at[h]===void 0?delete d[h]:d[h]=at[h];var w=[];for(h in d)w.push(`${h}=${d[h]}`);Gt=w}return Gt},Gt,Ke=[null,[],[]],vr=[31,29,31,30,31,30,31,31,30,31,30,31],ke=[31,28,31,30,31,30,31,31,30,31,30,31];function $r(d){var h=Array(Zt(d)+1);return Vt(d,h,0,h.length),h}function Ht(d,h,w,S){function P(O,oe,Ce){for(O=typeof O=="number"?O.toString():O||"";O.length<oe;)O=Ce[0]+O;return O}function N(O,oe){return P(O,oe,"0")}function K(O,oe){function Ce(Pr){return 0>Pr?-1:0<Pr?1:0}var ct;return(ct=Ce(O.getFullYear()-oe.getFullYear()))===0&&(ct=Ce(O.getMonth()-oe.getMonth()))===0&&(ct=Ce(O.getDate()-oe.getDate())),ct}function X(O){switch(O.getDay()){case 0:return new Date(O.getFullYear()-1,11,29);case 1:return O;case 2:return new Date(O.getFullYear(),0,3);case 3:return new Date(O.getFullYear(),0,2);case 4:return new Date(O.getFullYear(),0,1);case 5:return new Date(O.getFullYear()-1,11,31);case 6:return new Date(O.getFullYear()-1,11,30)}}function ae(O){var oe=O.Ca;for(O=new Date(new Date(O.Da+1900,0,1).getTime());0<oe;){var Ce=O.getMonth(),ct=(St(O.getFullYear())?vr:ke)[Ce];if(oe>ct-O.getDate())oe-=ct-O.getDate()+1,O.setDate(1),11>Ce?O.setMonth(Ce+1):(O.setMonth(0),O.setFullYear(O.getFullYear()+1));else{O.setDate(O.getDate()+oe);break}}return Ce=new Date(O.getFullYear()+1,0,4),oe=X(new Date(O.getFullYear(),0,4)),Ce=X(Ce),0>=K(oe,O)?0>=K(Ce,O)?O.getFullYear()+1:O.getFullYear():O.getFullYear()-1}d>>>=0,h>>>=0,w>>>=0,S>>>=0;var de=L[S+40>>>2>>>0];S={bb:R[S>>>2>>>0],ab:R[S+4>>>2>>>0],Ga:R[S+8>>>2>>>0],Ka:R[S+12>>>2>>>0],Ha:R[S+16>>>2>>>0],Da:R[S+20>>>2>>>0],xa:R[S+24>>>2>>>0],Ca:R[S+28>>>2>>>0],fb:R[S+32>>>2>>>0],$a:R[S+36>>>2>>>0],cb:de?qe(de):""},w=qe(w),de={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var fe in de)w=w.replace(new RegExp(fe,"g"),de[fe]);var Oe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Re="January February March April May June July August September October November December".split(" ");de={"%a":O=>Oe[O.xa].substring(0,3),"%A":O=>Oe[O.xa],"%b":O=>Re[O.Ha].substring(0,3),"%B":O=>Re[O.Ha],"%C":O=>N((O.Da+1900)/100|0,2),"%d":O=>N(O.Ka,2),"%e":O=>P(O.Ka,2," "),"%g":O=>ae(O).toString().substring(2),"%G":O=>ae(O),"%H":O=>N(O.Ga,2),"%I":O=>(O=O.Ga,O==0?O=12:12<O&&(O-=12),N(O,2)),"%j":O=>{for(var oe=0,Ce=0;Ce<=O.Ha-1;oe+=(St(O.Da+1900)?vr:ke)[Ce++]);return N(O.Ka+oe,3)},"%m":O=>N(O.Ha+1,2),"%M":O=>N(O.ab,2),"%n":()=>`\n`,"%p":O=>0<=O.Ga&&12>O.Ga?"AM":"PM","%S":O=>N(O.bb,2),"%t":()=>"	","%u":O=>O.xa||7,"%U":O=>N(Math.floor((O.Ca+7-O.xa)/7),2),"%V":O=>{var oe=Math.floor((O.Ca+7-(O.xa+6)%7)/7);if(2>=(O.xa+371-O.Ca-2)%7&&oe++,oe)oe==53&&(Ce=(O.xa+371-O.Ca)%7,Ce==4||Ce==3&&St(O.Da)||(oe=1));else{oe=52;var Ce=(O.xa+7-O.Ca-1)%7;(Ce==4||Ce==5&&St(O.Da%400-1))&&oe++}return N(oe,2)},"%w":O=>O.xa,"%W":O=>N(Math.floor((O.Ca+7-(O.xa+6)%7)/7),2),"%y":O=>(O.Da+1900).toString().substring(2),"%Y":O=>O.Da+1900,"%z":O=>{O=O.$a;var oe=0<=O;return O=Math.abs(O)/60,(oe?"+":"-")+("0000"+(O/60*100+O%60)).slice(-4)},"%Z":O=>O.cb,"%%":()=>"%"},w=w.replace(/%%/g,"\\0\\0");for(fe in de)w.includes(fe)&&(w=w.replace(new RegExp(fe,"g"),de[fe](S)));return w=w.replace(/\\0\\0/g,"%"),fe=$r(w),fe.length>h?0:(V.set(fe,d>>>0),fe.length-1)}var Ct=d=>{try{d()}catch(h){se(h)}};function mn(){var d=ee,h={};for(let[w,S]of Object.entries(d))h[w]=typeof S=="function"?function(){_t.push(w);try{return S.apply(null,arguments)}finally{D||(_t.pop(),nt&&it===1&&_t.length===0&&(it=0,Ct(dr),typeof Fibers<"u"&&Fibers.gb()))}}:S;return h}var it=0,nt=null,te=0,_t=[],Jt={},_r={},xr=0,er=null,Sr=[];function Cr(){return new Promise((d,h)=>{er={resolve:d,reject:h}})}function Ir(){var d=Lt(65548),h=d+12;L[d>>>2>>>0]=h,L[d+4>>>2>>>0]=h+65536,h=_t[0];var w=Jt[h];return w===void 0&&(w=xr++,Jt[h]=w,_r[w]=h),R[d+8>>>2>>>0]=w,d}function Ar(d){if(!D){if(it===0){var h=!1,w=!1;d((S=0)=>{if(!D&&(te=S,h=!0,w)){it=2,Ct(()=>lr(nt)),typeof Browser<"u"&&Browser.Ia.Qa&&Browser.Ia.resume(),S=!1;try{var P=(0,ee[_r[R[nt+8>>>2>>>0]]])()}catch(X){P=X,S=!0}var N=!1;if(!nt){var K=er;K&&(er=null,(S?K.reject:K.resolve)(P),N=!0)}if(S&&!N)throw P}}),w=!0,h||(it=1,nt=Ir(),typeof Browser<"u"&&Browser.Ia.Qa&&Browser.Ia.pause(),Ct(()=>ur(nt)))}else it===2?(it=0,Ct(cr),nr(nt),nt=null,Sr.forEach(S=>{if(!D)try{S();try{U=U=S=U,r.onExit?.(S),D=!0,a(S,new Ne(S))}catch(P){P instanceof Ne||P=="unwind"||a(1,P)}}catch(P){P instanceof Ne||P=="unwind"||a(1,P)}})):se(`invalid state: ${it}`);return te}}function tr(d){return Ar(h=>{d().then(h)})}var Tr={n:function(d,h,w){return tr(async()=>{await r.Ua(d,h,w)})},a:function(d,h,w){throw d>>>=0,new Fe(d).eb(h>>>0,w>>>0),Je=d,kt++,Je},g:function(){return 0},J:function(){},A:function(){},C:function(){},L:function(){return 0},H:function(){},D:function(){},G:function(){},l:function(){},B:function(){},y:function(){},I:function(){},z:function(){},m:()=>1,q:function(d,h,w){d=h+2097152>>>0<4194305-!!d?(d>>>0)+4294967296*h:NaN,w>>>=0,d=new Date(1e3*d),R[w>>>2>>>0]=d.getUTCSeconds(),R[w+4>>>2>>>0]=d.getUTCMinutes(),R[w+8>>>2>>>0]=d.getUTCHours(),R[w+12>>>2>>>0]=d.getUTCDate(),R[w+16>>>2>>>0]=d.getUTCMonth(),R[w+20>>>2>>>0]=d.getUTCFullYear()-1900,R[w+24>>>2>>>0]=d.getUTCDay(),R[w+28>>>2>>>0]=(d.getTime()-Date.UTC(d.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(d,h,w){d=h+2097152>>>0<4194305-!!d?(d>>>0)+4294967296*h:NaN,w>>>=0,d=new Date(1e3*d),R[w>>>2>>>0]=d.getSeconds(),R[w+4>>>2>>>0]=d.getMinutes(),R[w+8>>>2>>>0]=d.getHours(),R[w+12>>>2>>>0]=d.getDate(),R[w+16>>>2>>>0]=d.getMonth(),R[w+20>>>2>>>0]=d.getFullYear()-1900,R[w+24>>>2>>>0]=d.getDay(),R[w+28>>>2>>>0]=(St(d.getFullYear())?$t:Nt)[d.getMonth()]+d.getDate()-1|0,R[w+36>>>2>>>0]=-(60*d.getTimezoneOffset()),h=new Date(d.getFullYear(),6,1).getTimezoneOffset();var S=new Date(d.getFullYear(),0,1).getTimezoneOffset();R[w+32>>>2>>>0]=(h!=S&&d.getTimezoneOffset()==Math.min(S,h))|0},s:function(d){d>>>=0;var h=new Date(R[d+20>>>2>>>0]+1900,R[d+16>>>2>>>0],R[d+12>>>2>>>0],R[d+8>>>2>>>0],R[d+4>>>2>>>0],R[d>>>2>>>0],0),w=R[d+32>>>2>>>0],S=h.getTimezoneOffset(),P=new Date(h.getFullYear(),6,1).getTimezoneOffset(),N=new Date(h.getFullYear(),0,1).getTimezoneOffset(),K=Math.min(N,P);return 0>w?R[d+32>>>2>>>0]=+(P!=N&&K==S):0<w!=(K==S)&&(P=Math.max(N,P),h.setTime(h.getTime()+6e4*((0<w?K:P)-S))),R[d+24>>>2>>>0]=h.getDay(),R[d+28>>>2>>>0]=(St(h.getFullYear())?$t:Nt)[h.getMonth()]+h.getDate()-1|0,R[d>>>2>>>0]=h.getSeconds(),R[d+4>>>2>>>0]=h.getMinutes(),R[d+8>>>2>>>0]=h.getHours(),R[d+12>>>2>>>0]=h.getDate(),R[d+16>>>2>>>0]=h.getMonth(),R[d+20>>>2>>>0]=h.getYear(),d=h.getTime(),isNaN(d)?(R[rr()>>>2>>>0]=61,d=-1):d/=1e3,or((Le=d,1<=+Math.abs(Le)?0<Le?+Math.floor(Le/4294967296)>>>0:~~+Math.ceil((Le-+(~~Le>>>0))/4294967296)>>>0:0)),d>>>0},o:function(){return-52},p:function(){},w:function(d,h,w){function S(ae){return(ae=ae.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?ae[1]:"GMT"}w>>>=0;var P=new Date().getFullYear(),N=new Date(P,0,1),K=new Date(P,6,1);P=N.getTimezoneOffset();var X=K.getTimezoneOffset();L[d>>>0>>>2>>>0]=60*Math.max(P,X),R[h>>>0>>>2>>>0]=+(P!=X),d=S(N),h=S(K),d=Wt(d),h=Wt(h),X<P?(L[w>>>2>>>0]=d,L[w+4>>>2>>>0]=h):(L[w>>>2>>>0]=h,L[w+4>>>2>>>0]=d)},e:()=>{se("")},b:function(d,h,w){return d>>>=0,h=Qt(h>>>0,w>>>0),wt[d].apply(null,h)},i:function(d,h,w){return d>>>=0,h=Qt(h>>>0,w>>>0),wt[d].apply(null,h)},h:()=>Date.now(),x:function(){return 4294901760},c:()=>performance.now(),K:function(d,h,w){return h>>>=0,H.copyWithin(d>>>0>>>0,h>>>0,h+(w>>>0)>>>0)},u:function(d){d>>>=0;var h=H.length;if(4294901760<d)return!1;for(var w=1;4>=w;w*=2){var S=h*(1+.2/w);S=Math.min(S,d+100663296);var P=Math;S=Math.max(d,S);e:{P=(P.min.call(P,4294901760,S+(65536-S%65536)%65536)-T.buffer.byteLength+65535)/65536;try{T.grow(P),we();var N=1;break e}catch{}N=void 0}if(N)return!0}return!1},E:function(d,h){d>>>=0,h>>>=0;var w=0;return Xt().forEach((S,P)=>{var N=h+w;for(P=L[d+4*P>>>2>>>0]=N,N=0;N<S.length;++N)V[P++>>>0>>>0]=S.charCodeAt(N);V[P>>>0>>>0]=0,w+=S.length+1}),0},F:function(d,h){d>>>=0,h>>>=0;var w=Xt();L[d>>>2>>>0]=w.length;var S=0;return w.forEach(P=>S+=P.length+1),L[h>>>2>>>0]=S,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(d,h,w,S){h>>>=0,w>>>=0,S>>>=0;for(var P=0,N=0;N<w;N++){var K=L[h>>>2>>>0],X=L[h+4>>>2>>>0];h+=8;for(var ae=0;ae<X;ae++){var de=H[K+ae>>>0],fe=Ke[d];de===0||de===10?((d===1?v:A)(xt(fe,0)),fe.length=0):fe.push(de)}P+=X}return L[S>>>2>>>0]=P,0},v:Ht,d:function(d,h,w,S){return Ht(d>>>0,h>>>0,w>>>0,S>>>0)}},ee=function(){function d(w){return ee=w.exports,ee=mn(),ee=Er(),T=ee.M,we(),ze.unshift(ee.N),xe--,xe==0&&(me!==null&&(clearInterval(me),me=null),ue&&(w=ue,ue=null,w())),ee}var h={a:Tr};if(xe++,r.instantiateWasm)try{return r.instantiateWasm(h,d)}catch(w){A(`Module.instantiateWasm callback failed with error: ${w}`),n(w)}return Xe(h,function(w){d(w.instance)}).catch(n),{}}();r._OrtInit=(d,h)=>(r._OrtInit=ee.O)(d,h),r._OrtGetLastError=(d,h)=>(r._OrtGetLastError=ee.P)(d,h),r._OrtCreateSessionOptions=(d,h,w,S,P,N,K,X,ae,de)=>(r._OrtCreateSessionOptions=ee.Q)(d,h,w,S,P,N,K,X,ae,de),r._OrtAppendExecutionProvider=(d,h)=>(r._OrtAppendExecutionProvider=ee.R)(d,h),r._OrtAddFreeDimensionOverride=(d,h,w)=>(r._OrtAddFreeDimensionOverride=ee.S)(d,h,w),r._OrtAddSessionConfigEntry=(d,h,w)=>(r._OrtAddSessionConfigEntry=ee.T)(d,h,w),r._OrtReleaseSessionOptions=d=>(r._OrtReleaseSessionOptions=ee.U)(d),r._OrtCreateSession=(d,h,w)=>(r._OrtCreateSession=ee.V)(d,h,w),r._OrtReleaseSession=d=>(r._OrtReleaseSession=ee.W)(d),r._OrtGetInputOutputCount=(d,h,w)=>(r._OrtGetInputOutputCount=ee.X)(d,h,w),r._OrtGetInputName=(d,h)=>(r._OrtGetInputName=ee.Y)(d,h),r._OrtGetOutputName=(d,h)=>(r._OrtGetOutputName=ee.Z)(d,h),r._OrtFree=d=>(r._OrtFree=ee._)(d),r._OrtCreateTensor=(d,h,w,S,P,N)=>(r._OrtCreateTensor=ee.$)(d,h,w,S,P,N),r._OrtGetTensorData=(d,h,w,S,P)=>(r._OrtGetTensorData=ee.aa)(d,h,w,S,P),r._OrtReleaseTensor=d=>(r._OrtReleaseTensor=ee.ba)(d),r._OrtCreateRunOptions=(d,h,w,S)=>(r._OrtCreateRunOptions=ee.ca)(d,h,w,S),r._OrtAddRunConfigEntry=(d,h,w)=>(r._OrtAddRunConfigEntry=ee.da)(d,h,w),r._OrtReleaseRunOptions=d=>(r._OrtReleaseRunOptions=ee.ea)(d),r._OrtCreateBinding=d=>(r._OrtCreateBinding=ee.fa)(d),r._OrtBindInput=(d,h,w)=>(r._OrtBindInput=ee.ga)(d,h,w),r._OrtBindOutput=(d,h,w,S)=>(r._OrtBindOutput=ee.ha)(d,h,w,S),r._OrtClearBoundOutputs=d=>(r._OrtClearBoundOutputs=ee.ia)(d),r._OrtReleaseBinding=d=>(r._OrtReleaseBinding=ee.ja)(d),r._OrtRunWithBinding=(d,h,w,S,P)=>(r._OrtRunWithBinding=ee.ka)(d,h,w,S,P),r._OrtRun=(d,h,w,S,P,N,K,X)=>(r._OrtRun=ee.la)(d,h,w,S,P,N,K,X),r._OrtEndProfiling=d=>(r._OrtEndProfiling=ee.ma)(d),r._JsepOutput=(d,h,w)=>(r._JsepOutput=ee.na)(d,h,w),r._JsepGetNodeName=d=>(r._JsepGetNodeName=ee.oa)(d);var rr=()=>(rr=ee.pa)(),Lt=r._malloc=d=>(Lt=r._malloc=ee.qa)(d),nr=r._free=d=>(nr=r._free=ee.ra)(d),or=d=>(or=ee.ta)(d),ar=()=>(ar=ee.ua)(),ir=d=>(ir=ee.va)(d),sr=d=>(sr=ee.wa)(d),ur=d=>(ur=ee.ya)(d),dr=()=>(dr=ee.za)(),lr=d=>(lr=ee.Aa)(d),cr=()=>(cr=ee.Ba)();r.___start_em_js=944151,r.___stop_em_js=944312;function Er(){var d=ee;d=Object.assign({},d);var h=S=>()=>S()>>>0,w=S=>P=>S(P)>>>0;return d.pa=h(d.pa),d.qa=w(d.qa),d.ua=h(d.ua),d.wa=w(d.wa),d}r.stackAlloc=sr,r.stackSave=ar,r.stackRestore=ir,r.UTF8ToString=qe,r.stringToUTF8=(d,h,w)=>Vt(d,H,h,w),r.lengthBytesUTF8=Zt;var It;ue=function d(){It||Bt(),It||(ue=d)};function Bt(){if(!(0<xe)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;){var d=r.preRun.shift();ne.unshift(d)}for(;0<ne.length;)ne.shift()(r);if(!(0<xe||It||(It=!0,r.calledRun=!0,D))){for(;0<ze.length;)ze.shift()(r);for(o(r);0<Q.length;)Q.shift()(r)}}}return Bt(),t.ready}})();typeof ko=="object"&&typeof Cn=="object"?Cn.exports=Oo:typeof define=="function"&&define.amd&&define([],()=>Oo)});var Bo=pr(()=>{});var Do=pr(()=>{});var Mo={};Mr(Mo,{cpus:()=>gd});var gd,zo=q(()=>{gd=void 0});var No=pr((Vo,In)=>{"use strict";var Uo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return ne.buffer!=me.buffer&&G(),me}function o(){return ne.buffer!=me.buffer&&G(),ue}function n(){return ne.buffer!=me.buffer&&G(),se}function s(){return ne.buffer!=me.buffer&&G(),he}function u(){return ne.buffer!=me.buffer&&G(),Ae}function l(){return ne.buffer!=me.buffer&&G(),He}var a=t,p,m;a.ready=new Promise((i,c)=>{p=i,m=c}),a.mountExternalData=(i,c)=>{(a.cb||(a.cb=new Map)).set(i,c)},a.unmountExternalData=()=>{delete a.cb};let f=()=>{let i=(g,x,E)=>(...k)=>{let W=pt,Z=x?.();k=g(...k);let ge=x?.();return Z!==ge&&(g=ge,E(Z),x=E=null),pt!=W?td():k},c=g=>async(...x)=>{try{if(a.bb)throw Error("Session already started");let E=a.bb={Gb:x[0],errors:[]},k=await g(...x);if(a.bb!==E)throw Error("Session mismatch");a.kb?.flush();let W=E.errors;if(0<W.length){let Z=await Promise.all(W);if(Z=Z.filter(ge=>ge),0<Z.length)throw Error(Z.join(`\n`))}return k}finally{a.bb=null}};a._OrtCreateSession=i(a._OrtCreateSession,()=>a._OrtCreateSession,g=>a._OrtCreateSession=g),a._OrtRun=c(i(a._OrtRun,()=>a._OrtRun,g=>a._OrtRun=g)),a._OrtRunWithBinding=c(i(a._OrtRunWithBinding,()=>a._OrtRunWithBinding,g=>a._OrtRunWithBinding=g)),a._OrtBindInput=i(a._OrtBindInput,()=>a._OrtBindInput,g=>a._OrtBindInput=g),f=void 0};a.jsepInit=(i,c)=>{if(f?.(),i==="webgpu"){[a.kb,a.xb,a.Bb,a.lb,a.Ab,a.Ea,a.Cb,a.Eb,a.yb,a.zb,a.Db]=c;let g=a.kb;a.jsepRegisterBuffer=(x,E,k,W)=>g.registerBuffer(x,E,k,W),a.jsepGetBuffer=x=>g.getBuffer(x),a.jsepCreateDownloader=(x,E,k)=>g.createDownloader(x,E,k),a.jsepOnReleaseSession=x=>{g.onReleaseSession(x)},a.jsepOnRunStart=x=>g.onRunStart(x)}};var b=Object.assign({},a),_="./this.program",y=(i,c)=>{throw c},$=typeof window=="object",I=typeof importScripts=="function",C=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v=a.ENVIRONMENT_IS_PTHREAD||!1,A="";function T(i){return a.locateFile?a.locateFile(i,A):A+i}var D,U,V;if(C){var H=(_n(),Ft($n)),R=(Sn(),Ft(xn));A=I?R.dirname(A)+"/":__dirname+"/",D=(c,g)=>(c=vt(c)?new URL(c):R.normalize(c),H.readFileSync(c,g?void 0:"utf8")),V=c=>(c=D(c,!0),c.buffer||(c=new Uint8Array(c)),c),U=(c,g,x,E=!0)=>{c=vt(c)?new URL(c):R.normalize(c),H.readFile(c,E?void 0:"utf8",(k,W)=>{k?x(k):g(E?W.buffer:W)})},!a.thisProgram&&1<process.argv.length&&(_=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),y=(c,g)=>{throw process.exitCode=c,g},a.inspect=()=>"[Emscripten Module object]";let i;try{i=Bo()}catch(c){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),c}global.Worker=i.Worker}else($||I)&&(I?A=self.location.href:typeof document<"u"&&document.currentScript&&(A=document.currentScript.src),typeof e<"u"&&e&&(A=e),A.indexOf("blob:")!==0?A=A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):A="",C||(D=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.send(null),c.responseText},I&&(V=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)}),U=(i,c,g)=>{var x=new XMLHttpRequest;x.open("GET",i,!0),x.responseType="arraybuffer",x.onload=()=>{x.status==200||x.status==0&&x.response?c(x.response):g()},x.onerror=g,x.send(null)}));C&&typeof performance>"u"&&(global.performance=Do().performance);var L=console.log.bind(console),pe=console.error.bind(console);C&&(L=(...i)=>H.writeSync(1,i.join(" ")+`\n`),pe=(...i)=>H.writeSync(2,i.join(" ")+`\n`));var Ie=L,we=pe;Object.assign(a,b),b=null,typeof WebAssembly!="object"&&Je("no native wasm support detected");var ne,ze,Q=!1,xe,me,ue,se,he,Ae,He;function G(){var i=ne.buffer;a.HEAP8=me=new Int8Array(i),a.HEAP16=new Int16Array(i),a.HEAPU8=ue=new Uint8Array(i),a.HEAPU16=new Uint16Array(i),a.HEAP32=se=new Int32Array(i),a.HEAPU32=he=new Uint32Array(i),a.HEAPF32=Ae=new Float32Array(i),a.HEAPF64=He=new Float64Array(i)}var J=16777216;if(v)ne=a.wasmMemory;else if(a.wasmMemory)ne=a.wasmMemory;else if(ne=new WebAssembly.Memory({initial:J/65536,maximum:65536,shared:!0}),!(ne.buffer instanceof SharedArrayBuffer))throw we("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),C&&we("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");G(),J=ne.buffer.byteLength;var Se=[],Qe=[],Xe=[],Le=0,wt=null,Ne=null;function Fe(){if(Le--,Le==0&&(wt!==null&&(clearInterval(wt),wt=null),Ne)){var i=Ne;Ne=null,i()}}function Je(i){throw i="Aborted("+i+")",we(i),Q=!0,xe=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),m(i),i}var kt=i=>i.startsWith("data:application/octet-stream;base64,"),vt=i=>i.startsWith("file://"),xt;xt="ort-wasm-simd-threaded.wasm",kt(xt)||(xt=T(xt));function qe(i){if(V)return V(i);throw"both async and sync fetching of the wasm failed"}function Zt(i){if($||I){if(typeof fetch=="function"&&!vt(i))return fetch(i,{credentials:"same-origin"}).then(c=>{if(!c.ok)throw"failed to load wasm binary file at \'"+i+"\'";return c.arrayBuffer()}).catch(()=>qe(i));if(U)return new Promise((c,g)=>{U(i,x=>c(new Uint8Array(x)),g)})}return Promise.resolve().then(()=>qe(i))}function Vt(i,c,g){return Zt(i).then(x=>WebAssembly.instantiate(x,c)).then(x=>x).then(g,x=>{we(`failed to asynchronously prepare wasm: ${x}`),Je(x)})}function St(i,c){var g=xt;return typeof WebAssembly.instantiateStreaming!="function"||kt(g)||vt(g)||C||typeof fetch!="function"?Vt(g,i,c):fetch(g,{credentials:"same-origin"}).then(x=>WebAssembly.instantiateStreaming(x,i).then(c,function(E){return we(`wasm streaming compile failed: ${E}`),we("falling back to ArrayBuffer instantiation"),Vt(g,i,c)}))}var $t,Nt={933148:(i,c,g,x)=>{if(typeof a>"u"||!a.cb)return 1;if(i=Ke(i>>>0),i.startsWith("./")&&(i=i.substring(2)),i=a.cb.get(i),!i)return 2;if(c>>>=0,g>>>=0,x>>>=0,c+g>i.byteLength)return 3;try{return o().set(i.subarray(c,c+g),x>>>0),0}catch{return 4}},933649:()=>{a.yb()},933680:()=>{a.zb()},933709:()=>{a.Db()},933734:i=>a.xb(i),933767:i=>a.Bb(i),933799:(i,c,g)=>{a.lb(i,c,g,!0)},933838:(i,c,g)=>{a.lb(i,c,g)},933871:i=>{a.Ea("Abs",i,void 0)},933922:i=>{a.Ea("Neg",i,void 0)},933973:i=>{a.Ea("Floor",i,void 0)},934026:i=>{a.Ea("Ceil",i,void 0)},934078:i=>{a.Ea("Reciprocal",i,void 0)},934136:i=>{a.Ea("Sqrt",i,void 0)},934188:i=>{a.Ea("Exp",i,void 0)},934239:i=>{a.Ea("Erf",i,void 0)},934290:i=>{a.Ea("Sigmoid",i,void 0)},934345:(i,c,g)=>{a.Ea("HardSigmoid",i,{alpha:c,beta:g})},934424:i=>{a.Ea("Log",i,void 0)},934475:i=>{a.Ea("Sin",i,void 0)},934526:i=>{a.Ea("Cos",i,void 0)},934577:i=>{a.Ea("Tan",i,void 0)},934628:i=>{a.Ea("Asin",i,void 0)},934680:i=>{a.Ea("Acos",i,void 0)},934732:i=>{a.Ea("Atan",i,void 0)},934784:i=>{a.Ea("Sinh",i,void 0)},934836:i=>{a.Ea("Cosh",i,void 0)},934888:i=>{a.Ea("Asinh",i,void 0)},934941:i=>{a.Ea("Acosh",i,void 0)},934994:i=>{a.Ea("Atanh",i,void 0)},935047:i=>{a.Ea("Tanh",i,void 0)},935099:i=>{a.Ea("Not",i,void 0)},935150:(i,c,g)=>{a.Ea("Clip",i,{min:c,max:g})},935219:i=>{a.Ea("Clip",i,void 0)},935271:(i,c)=>{a.Ea("Elu",i,{alpha:c})},935329:i=>{a.Ea("Relu",i,void 0)},935381:(i,c)=>{a.Ea("LeakyRelu",i,{alpha:c})},935445:(i,c)=>{a.Ea("ThresholdedRelu",i,{alpha:c})},935515:(i,c)=>{a.Ea("Cast",i,{to:c})},935573:i=>{a.Ea("Add",i,void 0)},935624:i=>{a.Ea("Sub",i,void 0)},935675:i=>{a.Ea("Mul",i,void 0)},935726:i=>{a.Ea("Div",i,void 0)},935777:i=>{a.Ea("Pow",i,void 0)},935828:i=>{a.Ea("Equal",i,void 0)},935881:i=>{a.Ea("Greater",i,void 0)},935936:i=>{a.Ea("GreaterOrEqual",i,void 0)},935998:i=>{a.Ea("Less",i,void 0)},936050:i=>{a.Ea("LessOrEqual",i,void 0)},936109:(i,c,g,x,E)=>{a.Ea("ReduceMean",i,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:x?Array.from(n().subarray(x>>>0,E>>>0)):[]})},936268:(i,c,g,x,E)=>{a.Ea("ReduceMax",i,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:x?Array.from(n().subarray(x>>>0,E>>>0)):[]})},936426:(i,c,g,x,E)=>{a.Ea("ReduceMin",i,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:x?Array.from(n().subarray(x>>>0,E>>>0)):[]})},936584:(i,c,g,x,E)=>{a.Ea("ReduceProd",i,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:x?Array.from(n().subarray(x>>>0,E>>>0)):[]})},936743:(i,c,g,x,E)=>{a.Ea("ReduceSum",i,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:x?Array.from(n().subarray(x>>>0,E>>>0)):[]})},936901:(i,c,g,x,E)=>{a.Ea("ReduceL1",i,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:x?Array.from(n().subarray(x>>>0,E>>>0)):[]})},937058:(i,c,g,x,E)=>{a.Ea("ReduceL2",i,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:x?Array.from(n().subarray(x>>>0,E>>>0)):[]})},937215:(i,c,g,x,E)=>{a.Ea("ReduceLogSum",i,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:x?Array.from(n().subarray(x>>>0,E>>>0)):[]})},937376:(i,c,g,x,E)=>{a.Ea("ReduceSumSquare",i,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:x?Array.from(n().subarray(x>>>0,E>>>0)):[]})},937540:(i,c,g,x,E)=>{a.Ea("ReduceLogSumExp",i,{keepDims:!!c,noopWithEmptyAxes:!!g,axes:x?Array.from(n().subarray(x>>>0,E>>>0)):[]})},937704:i=>{a.Ea("Where",i,void 0)},937757:(i,c,g)=>{a.Ea("Transpose",i,{perm:c?Array.from(n().subarray(c>>>0,g>>>0)):[]})},937865:(i,c,g,x,E,k,W,Z,ge,le,ve,Ue,Ve,B,ce)=>{a.Ea("ConvTranspose",i,{format:ge?"NHWC":"NCHW",autoPad:c,dilations:[g],group:x,kernel_shape:[E],pads:[k,W],strides:[Z],wIsConst:()=>!!r()[le>>>0],outputPadding:ve?Array.from(n().subarray(ve>>>0,Ue>>>0)):[],outputShape:Ve?Array.from(n().subarray(Ve>>>0,B>>>0)):[],activation:Ke(ce)})},938267:(i,c,g,x,E,k,W,Z,ge,le,ve,Ue,Ve,B)=>{a.Ea("ConvTranspose",i,{format:Z?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(g>>>0,(g>>>0)+2>>>0)),group:x,kernelShape:Array.from(n().subarray(E>>>0,(E>>>0)+2>>>0)),pads:Array.from(n().subarray(k>>>0,(k>>>0)+4>>>0)),strides:Array.from(n().subarray(W>>>0,(W>>>0)+2>>>0)),wIsConst:()=>!!r()[ge>>>0],outputPadding:le?Array.from(n().subarray(le>>>0,ve>>>0)):[],outputShape:Ue?Array.from(n().subarray(Ue>>>0,Ve>>>0)):[],activation:Ke(B)})},938832:(i,c,g,x,E,k,W,Z,ge,le,ve,Ue,Ve,B,ce)=>{a.Ea("ConvTranspose",i,{format:ge?"NHWC":"NCHW",autoPad:c,dilations:[g],group:x,kernel_shape:[E],pads:[k,W],strides:[Z],wIsConst:()=>!!r()[le>>>0],outputPadding:ve?Array.from(n().subarray(ve>>>0,Ue>>>0)):[],outputShape:Ve?Array.from(n().subarray(Ve>>>0,B>>>0)):[],activation:Ke(ce)})},939234:(i,c,g,x,E,k,W,Z,ge,le,ve,Ue,Ve,B)=>{a.Ea("ConvTranspose",i,{format:Z?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(g>>>0,(g>>>0)+2>>>0)),group:x,kernelShape:Array.from(n().subarray(E>>>0,(E>>>0)+2>>>0)),pads:Array.from(n().subarray(k>>>0,(k>>>0)+4>>>0)),strides:Array.from(n().subarray(W>>>0,(W>>>0)+2>>>0)),wIsConst:()=>!!r()[ge>>>0],outputPadding:le?Array.from(n().subarray(le>>>0,ve>>>0)):[],outputShape:Ue?Array.from(n().subarray(Ue>>>0,Ve>>>0)):[],activation:Ke(B)})},939799:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},939890:(i,c,g,x,E,k,W,Z,ge,le,ve,Ue,Ve,B,ce,Te)=>{a.Ea("AveragePool",i,{format:Te?"NHWC":"NCHW",auto_pad:c,ceil_mode:g,count_include_pad:x,storage_order:E,dilations:[k,W],kernel_shape:[Z,ge],pads:[le,ve,Ue,Ve],strides:[B,ce]})},940174:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},940265:(i,c,g,x,E,k,W,Z,ge,le,ve,Ue,Ve,B,ce,Te)=>{a.Ea("AveragePool",i,{format:Te?"NHWC":"NCHW",auto_pad:c,ceil_mode:g,count_include_pad:x,storage_order:E,dilations:[k,W],kernel_shape:[Z,ge],pads:[le,ve,Ue,Ve],strides:[B,ce]})},940549:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},940636:(i,c,g,x,E,k,W,Z,ge,le,ve,Ue,Ve,B,ce,Te)=>{a.Ea("MaxPool",i,{format:Te?"NHWC":"NCHW",auto_pad:c,ceil_mode:g,count_include_pad:x,storage_order:E,dilations:[k,W],kernel_shape:[Z,ge],pads:[le,ve,Ue,Ve],strides:[B,ce]})},940916:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},941003:(i,c,g,x,E,k,W,Z,ge,le,ve,Ue,Ve,B,ce,Te)=>{a.Ea("MaxPool",i,{format:Te?"NHWC":"NCHW",auto_pad:c,ceil_mode:g,count_include_pad:x,storage_order:E,dilations:[k,W],kernel_shape:[Z,ge],pads:[le,ve,Ue,Ve],strides:[B,ce]})},941283:(i,c,g,x,E)=>{a.Ea("Gemm",i,{alpha:c,beta:g,transA:x,transB:E})},941387:i=>{a.Ea("MatMul",i,void 0)},941441:(i,c,g,x)=>{a.Ea("ArgMax",i,{keepDims:!!c,selectLastIndex:!!g,axis:x})},941549:(i,c,g,x)=>{a.Ea("ArgMin",i,{keepDims:!!c,selectLastIndex:!!g,axis:x})},941657:(i,c)=>{a.Ea("Softmax",i,{axis:c})},941720:(i,c)=>{a.Ea("Concat",i,{axis:c})},941780:(i,c,g,x,E)=>{a.Ea("Split",i,{axis:c,numOutputs:g,splitSizes:x?Array.from(n().subarray(x>>>0,E>>>0)):[]})},941920:i=>{a.Ea("Expand",i,void 0)},941974:(i,c)=>{a.Ea("Gather",i,{axis:Number(c)})},942045:(i,c)=>{a.Ea("GatherElements",i,{axis:Number(c)})},942124:(i,c,g,x,E,k,W,Z,ge,le,ve)=>{a.Ea("Resize",i,{antialias:c,axes:g?Array.from(n().subarray(g>>>0,x>>>0)):[],coordinateTransformMode:Ke(E),cubicCoeffA:k,excludeOutside:W,extrapolationValue:Z,keepAspectRatioPolicy:Ke(ge),mode:Ke(le),nearestMode:Ke(ve)})},942470:(i,c,g,x,E,k,W)=>{a.Ea("Slice",i,{starts:c?Array.from(n().subarray(c>>>0,g>>>0)):[],ends:x?Array.from(n().subarray(x>>>0,E>>>0)):[],axes:k?Array.from(n().subarray(k>>>0,W>>>0)):[]})},942686:i=>{a.Ea("Tile",i,void 0)},942738:(i,c,g)=>{a.Ea("LayerNormalization",i,{axis:Number(c),epsilon:Number(g)})},942845:(i,c,g)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:g?"NHWC":"NCHW"})},942959:(i,c,g)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:g?"NHWC":"NCHW"})},943073:i=>{a.Ea("Range",i,void 0)},943126:(i,c)=>{a.Ea("Einsum",i,{equation:Ke(c)})},943207:(i,c,g,x,E)=>{a.Ea("Pad",i,{mode:c,value:g,pads:x?Array.from(n().subarray(x>>>0,E>>>0)):[]})},943334:(i,c,g,x,E,k)=>{a.Ea("BatchNormalization",i,{epsilon:c,momentum:g,spatial:!!E,trainingMode:!!x,format:k?"NHWC":"NCHW"})},943503:(i,c,g,x,E,k)=>{a.Ea("BatchNormalization",i,{epsilon:c,momentum:g,spatial:!!E,trainingMode:!!x,format:k?"NHWC":"NCHW"})},943672:(i,c,g)=>{a.Ea("CumSum",i,{exclusive:Number(c),reverse:Number(g)})},943769:(i,c,g,x,E,k,W,Z,ge)=>{a.Ea("Attention",i,{numHeads:c,isUnidirectional:g,maskFilterValue:x,scale:E,doRotary:k,qkvHiddenSizes:W?Array.from(n().subarray(Number(Z)>>>0,Number(Z)+W>>>0)):[],pastPresentShareBuffer:!!ge})},944041:i=>{a.Ea("BiasAdd",i,void 0)},944096:i=>{a.Ea("BiasSplitGelu",i,void 0)},944157:i=>{a.Ea("FastGelu",i,void 0)},944213:(i,c,g,x,E,k,W,Z,ge,le,ve,Ue,Ve)=>{a.Ea("Conv",i,{format:ge?"NHWC":"NCHW",auto_pad:c,dilations:[g],group:x,kernel_shape:[E],pads:k?Array.from(n().subarray(k>>>0,W>>>0)):[],strides:[Z],w_is_const:()=>!!r()[le>>>0],activation:Ke(ve),activation_params:Ue?Array.from(u().subarray(Ue>>>0,Ve>>>0)):[]})},944583:(i,c,g,x,E,k,W,Z,ge,le,ve,Ue,Ve,B,ce,Te)=>{a.Ea("Conv",i,{format:Ue?"NHWC":"NCHW",auto_pad:c,dilations:[g,x],group:E,kernel_shape:[k,W],pads:Z?Array.from(n().subarray(Z>>>0,ge>>>0)):[],strides:[le,ve],w_is_const:()=>!!r()[Ve>>>0],activation:Ke(B),activation_params:ce?Array.from(u().subarray(ce>>>0,Te>>>0)):[]})},944974:i=>{a.Ea("Gelu",i,void 0)},945026:(i,c,g,x,E,k)=>{a.Ea("MatMulNBits",i,{k:c,n:g,accuracyLevel:x,bits:E,blockSize:k})},945153:(i,c,g,x,E,k)=>{a.Ea("MultiHeadAttention",i,{numHeads:c,isUnidirectional:g,maskFilterValue:x,scale:E,doRotary:k})},945312:(i,c)=>{a.Ea("SkipLayerNormalization",i,{epsilon:c})},945393:i=>{a.Cb(i)},945427:(i,c)=>a.Eb(i,c,a.bb.Gb,a.bb.errors)};function Wt(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}var Rt=i=>{i.terminate(),i.onmessage=()=>{}},Qt=i=>{te.Ya.length==0&&(it(),te.mb(te.Ya[0]));var c=te.Ya.pop();if(!c)return 6;te.Za.push(c),te.Qa[i.Xa]=c,c.Xa=i.Xa;var g={cmd:"run",start_routine:i.Hb,arg:i.ub,pthread_ptr:i.Xa};return C&&c.unref(),c.postMessage(g,i.Nb),0},at=0,Xt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Gt=(i,c,g)=>{c>>>=0;var x=c+g;for(g=c;i[g]&&!(g>=x);)++g;if(16<g-c&&i.buffer&&Xt)return Xt.decode(i.buffer instanceof SharedArrayBuffer?i.slice(c,g):i.subarray(c,g));for(x="";c<g;){var E=i[c++];if(E&128){var k=i[c++]&63;if((E&224)==192)x+=String.fromCharCode((E&31)<<6|k);else{var W=i[c++]&63;E=(E&240)==224?(E&15)<<12|k<<6|W:(E&7)<<18|k<<12|W<<6|i[c++]&63,65536>E?x+=String.fromCharCode(E):(E-=65536,x+=String.fromCharCode(55296|E>>10,56320|E&1023))}}else x+=String.fromCharCode(E)}return x},Ke=(i,c)=>(i>>>=0)?Gt(o(),i,c):"",vr=i=>{var c=bn();return i=i(),Br(c),i};function ke(i,c){var g=arguments.length-2,x=arguments;return vr(()=>{for(var E=wn(8*g),k=E>>>3,W=0;W<g;W++){var Z=x[2+W];l()[k+W>>>0]=Z}return wo(i,g,E,c)})}function $r(i){if(v)return ke(0,1,i);xe=i,0<at||(te.Ib(),a.onExit?.(i),Q=!0),y(i,new Wt(i))}var Ht=i=>{if(xe=i,v)throw Jt(i),"unwind";$r(i)},Ct=i=>{i instanceof Wt||i=="unwind"||y(1,i)};function mn(){for(var i=a.numThreads;i--;)it();Se.unshift(()=>{Le++,nt(()=>Fe())})}function it(){var i=T("ort-wasm-simd-threaded.worker.js");i=new Worker(i),te.Ya.push(i)}function nt(i){v?i():Promise.all(te.Ya.map(te.mb)).then(i)}var te={Ya:[],Za:[],qb:[],Qa:{},hb(){v?(te.receiveObjectTransfer=te.Fb,te.threadInitTLS=te.pb,te.setExitStatus=te.ob):mn()},ob:i=>xe=i,Qb:["$terminateWorker"],Ib:()=>{for(var i of te.Za)Rt(i);for(i of te.Ya)Rt(i);te.Ya=[],te.Za=[],te.Qa=[]},nb:i=>{var c=i.Xa;delete te.Qa[c],te.Ya.push(i),te.Za.splice(te.Za.indexOf(i),1),i.Xa=0,gn(c)},Fb(){},pb(){te.qb.forEach(i=>i())},mb:i=>new Promise(c=>{i.onmessage=k=>{k=k.data;var W=k.cmd;if(k.targetThread&&k.targetThread!=Rr()){var Z=te.Qa[k.targetThread];Z?Z.postMessage(k,k.transferList):we(`Internal error! Worker sent a message "${W}" to target pthread ${k.targetThread}, but that thread no longer exists!`)}else W==="checkMailbox"?Bt():W==="spawnThread"?Qt(k):W==="cleanupThread"?te.nb(te.Qa[k.thread]):W==="killThread"?(k=k.thread,W=te.Qa[k],delete te.Qa[k],Rt(W),gn(k),te.Za.splice(te.Za.indexOf(W),1),W.Xa=0):W==="cancelThread"?te.Qa[k.thread].postMessage({cmd:"cancel"}):W==="loaded"?(i.loaded=!0,C&&!i.Xa&&i.unref(),c(i)):W==="alert"?alert(`Thread ${k.threadId}: ${k.text}`):k.target==="setimmediate"?i.postMessage(k):W==="callHandler"?a[k.handler](...k.args):W&&we(`worker sent an unknown command ${W}`)},i.onerror=k=>{throw we(`worker sent an error! ${k.filename}:${k.lineno}: ${k.message}`),k},C&&(i.on("message",k=>i.onmessage({data:k})),i.on("error",k=>i.onerror(k)));var g=[],x=["onExit"],E;for(E of x)a.hasOwnProperty(E)&&g.push(E);i.postMessage({cmd:"load",handlers:g,urlOrBlob:a.mainScriptUrlOrBlob||e,wasmMemory:ne,wasmModule:ze})})};a.PThread=te;var _t=i=>{for(;0<i.length;)i.shift()(a)};a.establishStackSpace=()=>{var i=Rr(),c=s()[i+52>>>2>>>0];i=s()[i+56>>>2>>>0],_o(c,c-i),Br(c)};function Jt(i){if(v)return ke(1,0,i);Ht(i)}a.invokeEntryPoint=(i,c)=>{i=xo.apply(null,[i,c]),0<at?te.ob(i):yn(i)};function _r(i){this.gb=i-24,this.tb=function(c){s()[this.gb+4>>>2>>>0]=c},this.sb=function(c){s()[this.gb+8>>>2>>>0]=c},this.hb=function(c,g){this.rb(),this.tb(c),this.sb(g)},this.rb=function(){s()[this.gb+16>>>2>>>0]=0}}var xr=0,er=0;function Sr(i,c,g,x){return v?ke(2,1,i,c,g,x):Cr(i,c,g,x)}function Cr(i,c,g,x){if(i>>>=0,c>>>=0,g>>>=0,x>>>=0,typeof SharedArrayBuffer>"u")return we("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var E=[];return v&&E.length===0?Sr(i,c,g,x):(i={Hb:g,Xa:i,ub:x,Nb:E},v?(i.Pb="spawnThread",postMessage(i,E),0):Qt(i))}function Ir(i,c,g){return v?ke(3,1,i,c,g):0}function Ar(i,c){if(v)return ke(4,1,i,c)}var tr=i=>{for(var c=0,g=0;g<i.length;++g){var x=i.charCodeAt(g);127>=x?c++:2047>=x?c+=2:55296<=x&&57343>=x?(c+=4,++g):c+=3}return c},Tr=(i,c,g,x)=>{if(g>>>=0,!(0<x))return 0;var E=g;x=g+x-1;for(var k=0;k<i.length;++k){var W=i.charCodeAt(k);if(55296<=W&&57343>=W){var Z=i.charCodeAt(++k);W=65536+((W&1023)<<10)|Z&1023}if(127>=W){if(g>=x)break;c[g++>>>0]=W}else{if(2047>=W){if(g+1>=x)break;c[g++>>>0]=192|W>>6}else{if(65535>=W){if(g+2>=x)break;c[g++>>>0]=224|W>>12}else{if(g+3>=x)break;c[g++>>>0]=240|W>>18,c[g++>>>0]=128|W>>12&63}c[g++>>>0]=128|W>>6&63}c[g++>>>0]=128|W&63}}return c[g>>>0]=0,g-E},ee=(i,c,g)=>Tr(i,o(),c,g);function rr(i,c){if(v)return ke(5,1,i,c)}function Lt(i,c,g){if(v)return ke(6,1,i,c,g)}function nr(i,c,g){return v?ke(7,1,i,c,g):0}function or(i,c){if(v)return ke(8,1,i,c)}function ar(i,c,g){if(v)return ke(9,1,i,c,g)}function ir(i,c,g,x){if(v)return ke(10,1,i,c,g,x)}function sr(i,c,g,x){if(v)return ke(11,1,i,c,g,x)}function ur(i,c,g,x){if(v)return ke(12,1,i,c,g,x)}function dr(i){if(v)return ke(13,1,i)}function lr(i,c){if(v)return ke(14,1,i,c)}function cr(i,c,g){if(v)return ke(15,1,i,c,g)}var Er=()=>{if(!(0<at))try{v?yn(xe):Ht(xe)}catch(i){Ct(i)}};function It(i){i>>>=0,typeof Atomics.Ob=="function"&&(Atomics.Ob(n(),i>>>2,i).value.then(Bt),i+=128,Atomics.store(n(),i>>>2,1))}a.__emscripten_thread_mailbox_await=It;var Bt=()=>{var i=Rr();if(i&&(It(i),!Q))try{vo(),Er()}catch(c){Ct(c)}};a.checkMailbox=Bt;var d=[],h=i=>i%4===0&&(i%100!==0||i%400===0),w=[0,31,60,91,121,152,182,213,244,274,305,335],S=[0,31,59,90,120,151,181,212,243,273,304,334];function P(i,c,g,x,E,k,W,Z){return v?ke(16,1,i,c,g,x,E,k,W,Z):-52}function N(i,c,g,x,E,k,W){if(v)return ke(17,1,i,c,g,x,E,k,W)}var K=i=>{var c=tr(i)+1,g=hn(c);return g&&ee(i,g,c),g},X=[],ae=(i,c)=>{X.length=0;for(var g;g=o()[i++>>>0];){var x=g!=105;x&=g!=112,c+=x&&c%8?4:0,X.push(g==112?s()[c>>>2>>>0]:g==105?n()[c>>>2>>>0]:l()[c>>>3>>>0]),c+=x?8:4}return X},de={},fe=()=>{if(!Oe){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:_||"./this.program"},c;for(c in de)de[c]===void 0?delete i[c]:i[c]=de[c];var g=[];for(c in i)g.push(`${c}=${i[c]}`);Oe=g}return Oe},Oe;function Re(i,c){if(v)return ke(18,1,i,c);i>>>=0,c>>>=0;var g=0;return fe().forEach((x,E)=>{var k=c+g;for(E=s()[i+4*E>>>2>>>0]=k,k=0;k<x.length;++k)r()[E++>>>0>>>0]=x.charCodeAt(k);r()[E>>>0>>>0]=0,g+=x.length+1}),0}function O(i,c){if(v)return ke(19,1,i,c);i>>>=0,c>>>=0;var g=fe();s()[i>>>2>>>0]=g.length;var x=0;return g.forEach(E=>x+=E.length+1),s()[c>>>2>>>0]=x,0}function oe(i){return v?ke(20,1,i):52}function Ce(i,c,g,x){return v?ke(21,1,i,c,g,x):52}function ct(i,c,g,x,E){return v?ke(22,1,i,c,g,x,E):70}var Pr=[null,[],[]];function uo(i,c,g,x){if(v)return ke(23,1,i,c,g,x);c>>>=0,g>>>=0,x>>>=0;for(var E=0,k=0;k<g;k++){var W=s()[c>>>2>>>0],Z=s()[c+4>>>2>>>0];c+=8;for(var ge=0;ge<Z;ge++){var le=o()[W+ge>>>0],ve=Pr[i];le===0||le===10?((i===1?Ie:we)(Gt(ve,0)),ve.length=0):ve.push(le)}E+=Z}return s()[x>>>2>>>0]=E,0}var lo=[31,29,31,30,31,30,31,31,30,31,30,31],co=[31,28,31,30,31,30,31,31,30,31,30,31];function Zu(i){var c=Array(tr(i)+1);return Tr(i,c,0,c.length),c}var Qu=(i,c)=>{r().set(i,c>>>0)};function po(i,c,g,x){function E(B,ce,Te){for(B=typeof B=="number"?B.toString():B||"";B.length<ce;)B=Te[0]+B;return B}function k(B,ce){return E(B,ce,"0")}function W(B,ce){function Te(Eo){return 0>Eo?-1:0<Eo?1:0}var Dt;return(Dt=Te(B.getFullYear()-ce.getFullYear()))===0&&(Dt=Te(B.getMonth()-ce.getMonth()))===0&&(Dt=Te(B.getDate()-ce.getDate())),Dt}function Z(B){switch(B.getDay()){case 0:return new Date(B.getFullYear()-1,11,29);case 1:return B;case 2:return new Date(B.getFullYear(),0,3);case 3:return new Date(B.getFullYear(),0,2);case 4:return new Date(B.getFullYear(),0,1);case 5:return new Date(B.getFullYear()-1,11,31);case 6:return new Date(B.getFullYear()-1,11,30)}}function ge(B){var ce=B.$a;for(B=new Date(new Date(B.ab+1900,0,1).getTime());0<ce;){var Te=B.getMonth(),Dt=(h(B.getFullYear())?lo:co)[Te];if(ce>Dt-B.getDate())ce-=Dt-B.getDate()+1,B.setDate(1),11>Te?B.setMonth(Te+1):(B.setMonth(0),B.setFullYear(B.getFullYear()+1));else{B.setDate(B.getDate()+ce);break}}return Te=new Date(B.getFullYear()+1,0,4),ce=Z(new Date(B.getFullYear(),0,4)),Te=Z(Te),0>=W(ce,B)?0>=W(Te,B)?B.getFullYear()+1:B.getFullYear():B.getFullYear()-1}i>>>=0,c>>>=0,g>>>=0,x>>>=0;var le=s()[x+40>>>2>>>0];x={Lb:n()[x>>>2>>>0],Kb:n()[x+4>>>2>>>0],eb:n()[x+8>>>2>>>0],jb:n()[x+12>>>2>>>0],fb:n()[x+16>>>2>>>0],ab:n()[x+20>>>2>>>0],Wa:n()[x+24>>>2>>>0],$a:n()[x+28>>>2>>>0],Rb:n()[x+32>>>2>>>0],Jb:n()[x+36>>>2>>>0],Mb:le?Ke(le):""},g=Ke(g),le={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ve in le)g=g.replace(new RegExp(ve,"g"),le[ve]);var Ue="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ve="January February March April May June July August September October November December".split(" ");le={"%a":B=>Ue[B.Wa].substring(0,3),"%A":B=>Ue[B.Wa],"%b":B=>Ve[B.fb].substring(0,3),"%B":B=>Ve[B.fb],"%C":B=>k((B.ab+1900)/100|0,2),"%d":B=>k(B.jb,2),"%e":B=>E(B.jb,2," "),"%g":B=>ge(B).toString().substring(2),"%G":B=>ge(B),"%H":B=>k(B.eb,2),"%I":B=>(B=B.eb,B==0?B=12:12<B&&(B-=12),k(B,2)),"%j":B=>{for(var ce=0,Te=0;Te<=B.fb-1;ce+=(h(B.ab+1900)?lo:co)[Te++]);return k(B.jb+ce,3)},"%m":B=>k(B.fb+1,2),"%M":B=>k(B.Kb,2),"%n":()=>`\n`,"%p":B=>0<=B.eb&&12>B.eb?"AM":"PM","%S":B=>k(B.Lb,2),"%t":()=>"	","%u":B=>B.Wa||7,"%U":B=>k(Math.floor((B.$a+7-B.Wa)/7),2),"%V":B=>{var ce=Math.floor((B.$a+7-(B.Wa+6)%7)/7);if(2>=(B.Wa+371-B.$a-2)%7&&ce++,ce)ce==53&&(Te=(B.Wa+371-B.$a)%7,Te==4||Te==3&&h(B.ab)||(ce=1));else{ce=52;var Te=(B.Wa+7-B.$a-1)%7;(Te==4||Te==5&&h(B.ab%400-1))&&ce++}return k(ce,2)},"%w":B=>B.Wa,"%W":B=>k(Math.floor((B.$a+7-(B.Wa+6)%7)/7),2),"%y":B=>(B.ab+1900).toString().substring(2),"%Y":B=>B.ab+1900,"%z":B=>{B=B.Jb;var ce=0<=B;return B=Math.abs(B)/60,(ce?"+":"-")+("0000"+(B/60*100+B%60)).slice(-4)},"%Z":B=>B.Mb,"%%":()=>"%"},g=g.replace(/%%/g,"\\0\\0");for(ve in le)g.includes(ve)&&(g=g.replace(new RegExp(ve,"g"),le[ve](x)));return g=g.replace(/\\0\\0/g,"%"),ve=Zu(g),ve.length>c?0:(Qu(ve,i),ve.length-1)}var Or=i=>{try{i()}catch(c){Je(c)}};function Xu(){var i=Y,c={};for(let[g,x]of Object.entries(i))c[g]=typeof x=="function"?function(){kr.push(g);try{return x.apply(null,arguments)}finally{Q||(kr.pop(),pt&&At===1&&kr.length===0&&(At=0,at+=1,Or(Co),typeof Fibers<"u"&&Fibers.Sb()))}}:x;return c}var At=0,pt=null,mo=0,kr=[],fo={},ho={},Ju=0,fn=null,ed=[];function td(){return new Promise((i,c)=>{fn={resolve:i,reject:c}})}function rd(){var i=hn(65548),c=i+12;s()[i>>>2>>>0]=c,s()[i+4>>>2>>>0]=c+65536,c=kr[0];var g=fo[c];return g===void 0&&(g=Ju++,fo[c]=g,ho[g]=c),c=g,n()[i+8>>>2>>>0]=c,i}function nd(){var i=n()[pt+8>>>2>>>0];return i=Y[ho[i]],--at,i()}function od(i){if(!Q){if(At===0){var c=!1,g=!1;i((x=0)=>{if(!Q&&(mo=x,c=!0,g)){At=2,Or(()=>Io(pt)),typeof Browser<"u"&&Browser.ib.wb&&Browser.ib.resume(),x=!1;try{var E=nd()}catch(Z){E=Z,x=!0}var k=!1;if(!pt){var W=fn;W&&(fn=null,(x?W.reject:W.resolve)(E),k=!0)}if(x&&!k)throw E}}),g=!0,c||(At=1,pt=rd(),typeof Browser<"u"&&Browser.ib.wb&&Browser.ib.pause(),Or(()=>So(pt)))}else At===2?(At=0,Or(Ao),yo(pt),pt=null,ed.forEach(x=>{if(!Q)try{x(),Er()}catch(E){Ct(E)}})):Je(`invalid state: ${At}`);return mo}}function ad(i){return od(c=>{i().then(c)})}te.hb();var id=[$r,Jt,Sr,Ir,Ar,rr,Lt,nr,or,ar,ir,sr,ur,dr,lr,cr,P,N,Re,O,oe,Ce,ct,uo],sd={r:function(i,c,g){return ad(async()=>{await a.Ab(i,c,g)})},b:function(i,c,g){throw i>>>=0,new _r(i).hb(c>>>0,g>>>0),xr=i,er++,xr},N:function(i){bo(i>>>0,!I,1,!$,131072,!1),te.pb()},l:function(i){i>>>=0,v?postMessage({cmd:"cleanupThread",thread:i}):te.nb(te.Qa[i])},J:Cr,i:Ir,T:Ar,F:rr,H:Lt,U:nr,R:or,L:ar,Q:ir,p:sr,G:ur,D:dr,S:lr,E:cr,q:()=>1,B:function(i,c){i>>>=0,i==c>>>0?setTimeout(()=>Bt()):v?postMessage({targetThread:i,cmd:"checkMailbox"}):(i=te.Qa[i])&&i.postMessage({cmd:"checkMailbox"})},K:function(i,c,g,x){c>>>=0,d.length=g,x=x>>>0>>>3;for(var E=0;E<g;E++)d[E]=l()[x+E>>>0];return i=0>i?Nt[-i-1]:id[i],te.vb=c,c=i.apply(null,d),te.vb=0,c},M:It,W:function(i){C&&te.Qa[i>>>0].ref()},u:function(i,c,g){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,g>>>=0,i=new Date(1e3*i),n()[g>>>2>>>0]=i.getUTCSeconds(),n()[g+4>>>2>>>0]=i.getUTCMinutes(),n()[g+8>>>2>>>0]=i.getUTCHours(),n()[g+12>>>2>>>0]=i.getUTCDate(),n()[g+16>>>2>>>0]=i.getUTCMonth(),n()[g+20>>>2>>>0]=i.getUTCFullYear()-1900,n()[g+24>>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[g+28>>>2>>>0]=i},v:function(i,c,g){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,g>>>=0,i=new Date(1e3*i),n()[g>>>2>>>0]=i.getSeconds(),n()[g+4>>>2>>>0]=i.getMinutes(),n()[g+8>>>2>>>0]=i.getHours(),n()[g+12>>>2>>>0]=i.getDate(),n()[g+16>>>2>>>0]=i.getMonth(),n()[g+20>>>2>>>0]=i.getFullYear()-1900,n()[g+24>>>2>>>0]=i.getDay(),c=(h(i.getFullYear())?w:S)[i.getMonth()]+i.getDate()-1|0,n()[g+28>>>2>>>0]=c,n()[g+36>>>2>>>0]=-(60*i.getTimezoneOffset()),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var x=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=(c!=x&&i.getTimezoneOffset()==Math.min(x,c))|0,n()[g+32>>>2>>>0]=i},w:function(i){i>>>=0;var c=new Date(n()[i+20>>>2>>>0]+1900,n()[i+16>>>2>>>0],n()[i+12>>>2>>>0],n()[i+8>>>2>>>0],n()[i+4>>>2>>>0],n()[i>>>2>>>0],0),g=n()[i+32>>>2>>>0],x=c.getTimezoneOffset(),E=new Date(c.getFullYear(),6,1).getTimezoneOffset(),k=new Date(c.getFullYear(),0,1).getTimezoneOffset(),W=Math.min(k,E);return 0>g?n()[i+32>>>2>>>0]=+(E!=k&&W==x):0<g!=(W==x)&&(E=Math.max(k,E),c.setTime(c.getTime()+6e4*((0<g?W:E)-x))),n()[i+24>>>2>>>0]=c.getDay(),g=(h(c.getFullYear())?w:S)[c.getMonth()]+c.getDate()-1|0,n()[i+28>>>2>>>0]=g,n()[i>>>2>>>0]=c.getSeconds(),n()[i+4>>>2>>>0]=c.getMinutes(),n()[i+8>>>2>>>0]=c.getHours(),n()[i+12>>>2>>>0]=c.getDate(),n()[i+16>>>2>>>0]=c.getMonth(),n()[i+20>>>2>>>0]=c.getYear(),i=c.getTime(),isNaN(i)?(n()[go()>>>2>>>0]=61,i=-1):i/=1e3,$o(($t=i,1<=+Math.abs($t)?0<$t?+Math.floor($t/4294967296)>>>0:~~+Math.ceil(($t-+(~~$t>>>0))/4294967296)>>>0:0)),i>>>0},s:P,t:N,A:function(i,c,g){function x(le){return(le=le.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?le[1]:"GMT"}i>>>=0,c>>>=0,g>>>=0;var E=new Date().getFullYear(),k=new Date(E,0,1),W=new Date(E,6,1);E=k.getTimezoneOffset();var Z=W.getTimezoneOffset(),ge=Math.max(E,Z);s()[i>>>2>>>0]=60*ge,n()[c>>>2>>>0]=+(E!=Z),i=x(k),c=x(W),i=K(i),c=K(c),Z<E?(s()[g>>>2>>>0]=i,s()[g+4>>>2>>>0]=c):(s()[g>>>2>>>0]=c,s()[g+4>>>2>>>0]=i)},d:()=>{Je("")},c:function(i,c,g){return i>>>=0,c=ae(c>>>0,g>>>0),Nt[i].apply(null,c)},k:function(i,c,g){return i>>>=0,c=ae(c>>>0,g>>>0),Nt[i].apply(null,c)},m:()=>{},j:()=>Date.now(),V:()=>{throw at+=1,"unwind"},C:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:()=>C?(zo(),Ft(Mo)).cpus().length:navigator.hardwareConcurrency,y:function(i){i>>>=0;var c=o().length;if(i<=c||4294901760<i)return!1;for(var g=1;4>=g;g*=2){var x=c*(1+.2/g);x=Math.min(x,i+100663296);var E=Math;x=Math.max(i,x);e:{E=(E.min.call(E,4294901760,x+(65536-x%65536)%65536)-ne.buffer.byteLength+65535)/65536;try{ne.grow(E),G();var k=1;break e}catch{}k=void 0}if(k)return!0}return!1},O:Re,P:O,I:Ht,h:oe,o:Ce,x:ct,n:uo,a:ne||a.wasmMemory,z:po,e:function(i,c,g,x){return po(i>>>0,c>>>0,g>>>0,x>>>0)}},Y=function(){function i(g,x){return Y=g.exports,Y=Xu(),Y=ud(),te.qb.push(Y.Da),Qe.unshift(Y.X),ze=x,Fe(),Y}var c={a:sd};if(Le++,a.instantiateWasm)try{return a.instantiateWasm(c,i)}catch(g){we(`Module.instantiateWasm callback failed with error: ${g}`),m(g)}return St(c,function(g){i(g.instance,g.module)}).catch(m),{}}();a._OrtInit=(i,c)=>(a._OrtInit=Y.Y)(i,c),a._OrtGetLastError=(i,c)=>(a._OrtGetLastError=Y.Z)(i,c),a._OrtCreateSessionOptions=(i,c,g,x,E,k,W,Z,ge,le)=>(a._OrtCreateSessionOptions=Y._)(i,c,g,x,E,k,W,Z,ge,le),a._OrtAppendExecutionProvider=(i,c)=>(a._OrtAppendExecutionProvider=Y.$)(i,c),a._OrtAddFreeDimensionOverride=(i,c,g)=>(a._OrtAddFreeDimensionOverride=Y.aa)(i,c,g),a._OrtAddSessionConfigEntry=(i,c,g)=>(a._OrtAddSessionConfigEntry=Y.ba)(i,c,g),a._OrtReleaseSessionOptions=i=>(a._OrtReleaseSessionOptions=Y.ca)(i),a._OrtCreateSession=(i,c,g)=>(a._OrtCreateSession=Y.da)(i,c,g),a._OrtReleaseSession=i=>(a._OrtReleaseSession=Y.ea)(i),a._OrtGetInputOutputCount=(i,c,g)=>(a._OrtGetInputOutputCount=Y.fa)(i,c,g),a._OrtGetInputName=(i,c)=>(a._OrtGetInputName=Y.ga)(i,c),a._OrtGetOutputName=(i,c)=>(a._OrtGetOutputName=Y.ha)(i,c),a._OrtFree=i=>(a._OrtFree=Y.ia)(i),a._OrtCreateTensor=(i,c,g,x,E,k)=>(a._OrtCreateTensor=Y.ja)(i,c,g,x,E,k),a._OrtGetTensorData=(i,c,g,x,E)=>(a._OrtGetTensorData=Y.ka)(i,c,g,x,E),a._OrtReleaseTensor=i=>(a._OrtReleaseTensor=Y.la)(i),a._OrtCreateRunOptions=(i,c,g,x)=>(a._OrtCreateRunOptions=Y.ma)(i,c,g,x),a._OrtAddRunConfigEntry=(i,c,g)=>(a._OrtAddRunConfigEntry=Y.na)(i,c,g),a._OrtReleaseRunOptions=i=>(a._OrtReleaseRunOptions=Y.oa)(i),a._OrtCreateBinding=i=>(a._OrtCreateBinding=Y.pa)(i),a._OrtBindInput=(i,c,g)=>(a._OrtBindInput=Y.qa)(i,c,g),a._OrtBindOutput=(i,c,g,x)=>(a._OrtBindOutput=Y.ra)(i,c,g,x),a._OrtClearBoundOutputs=i=>(a._OrtClearBoundOutputs=Y.sa)(i),a._OrtReleaseBinding=i=>(a._OrtReleaseBinding=Y.ta)(i),a._OrtRunWithBinding=(i,c,g,x,E)=>(a._OrtRunWithBinding=Y.ua)(i,c,g,x,E),a._OrtRun=(i,c,g,x,E,k,W,Z)=>(a._OrtRun=Y.va)(i,c,g,x,E,k,W,Z),a._OrtEndProfiling=i=>(a._OrtEndProfiling=Y.wa)(i),a._JsepOutput=(i,c,g)=>(a._JsepOutput=Y.xa)(i,c,g),a._JsepGetNodeName=i=>(a._JsepGetNodeName=Y.ya)(i);var go=()=>(go=Y.za)(),Rr=a._pthread_self=()=>(Rr=a._pthread_self=Y.Aa)(),hn=a._malloc=i=>(hn=a._malloc=Y.Ba)(i),yo=a._free=i=>(yo=a._free=Y.Ca)(i);a.__emscripten_tls_init=()=>(a.__emscripten_tls_init=Y.Da)();var bo=a.__emscripten_thread_init=(i,c,g,x,E,k)=>(bo=a.__emscripten_thread_init=Y.Fa)(i,c,g,x,E,k);a.__emscripten_thread_crashed=()=>(a.__emscripten_thread_crashed=Y.Ga)();var wo=(i,c,g,x)=>(wo=Y.Ha)(i,c,g,x),gn=i=>(gn=Y.Ia)(i),yn=a.__emscripten_thread_exit=i=>(yn=a.__emscripten_thread_exit=Y.Ja)(i),vo=()=>(vo=Y.Ka)(),$o=i=>($o=Y.La)(i),_o=(i,c)=>(_o=Y.Ma)(i,c),bn=()=>(bn=Y.Na)(),Br=i=>(Br=Y.Oa)(i),wn=i=>(wn=Y.Pa)(i),xo=a.dynCall_ii=(i,c)=>(xo=a.dynCall_ii=Y.Ra)(i,c),So=i=>(So=Y.Sa)(i),Co=()=>(Co=Y.Ta)(),Io=i=>(Io=Y.Ua)(i),Ao=()=>(Ao=Y.Va)();a.___start_em_js=945539,a.___stop_em_js=945700;function ud(){var i=Y;i=Object.assign({},i);var c=x=>()=>x()>>>0,g=x=>E=>x(E)>>>0;return i.za=c(i.za),i.Aa=c(i.Aa),i.Ba=g(i.Ba),i.emscripten_main_runtime_thread_id=c(i.emscripten_main_runtime_thread_id),i.Na=c(i.Na),i.Pa=g(i.Pa),i}a.wasmMemory=ne,a.stackAlloc=wn,a.stackSave=bn,a.stackRestore=Br,a.keepRuntimeAlive=()=>0<at,a.UTF8ToString=Ke,a.stringToUTF8=ee,a.lengthBytesUTF8=tr,a.ExitStatus=Wt,a.PThread=te;var Dr;Ne=function i(){Dr||To(),Dr||(Ne=i)};function To(){if(!(0<Le))if(v)p(a),v||_t(Qe),startWorker(a);else{if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)Se.unshift(a.preRun.shift());_t(Se),0<Le||Dr||(Dr=!0,a.calledRun=!0,Q||(v||_t(Qe),p(a),v||_t(Xe)))}}return To(),t.ready}})();typeof Vo=="object"&&typeof In=="object"?In.exports=Uo:typeof define=="function"&&define.amd&&define([],()=>Uo)});var Wo=pr((mp,yd)=>{yd.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed?.(),a}}self.onmessage=handleMessage;\\n\'});var En,Tt,fr,Ur,hr,Ko,Pn,ie=q(()=>{"use strict";En=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Tt=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},fr=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Ur=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},hr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Ko=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool",Pn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var Vr=q(()=>{"use strict"});var Yo=q(()=>{"use strict";Vr()});var Zo,Qo=q(()=>{"use strict";Zo="1.17.3"});var Xo,rt,On=q(()=>{"use strict";Qo();Xo="warning",rt={wasm:{},webgl:{},webgpu:{},versions:{common:Zo},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Xo=e}},get logLevel(){return Xo}};Object.defineProperty(rt,"logLevel",{enumerable:!0})});var qt,Jo=q(()=>{"use strict";On();qt=rt});var ea=q(()=>{"use strict"});var ta=q(()=>{"use strict";Nr()});var na=q(()=>{"use strict"});var oa=q(()=>{"use strict";Nr()});var Nr=q(()=>{"use strict";ea();ta();na();oa()});var Wr=q(()=>{"use strict";Nr()});var kn,aa,Mt,Et,Rn=q(()=>{"use strict";On();kn=(e,t)=>{(typeof rt.trace>"u"?!rt.wasm.trace:!rt.trace)||console.timeStamp(`${e}::ORT::${t}`)},aa=(e,t)=>{let r=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],o=!1;for(let n=0;n<r.length;n++){if(o&&!r[n].includes("TRACE_FUNC")){let s=`FUNC_${e}::${r[n].trim().split(" ")[1]}`;t&&(s+=`::${t}`),kn("CPU",s);return}r[n].includes("TRACE_FUNC")&&(o=!0)}},Mt=e=>{(typeof rt.trace>"u"?!rt.wasm.trace:!rt.trace)||aa("BEGIN",e)},Et=e=>{(typeof rt.trace>"u"?!rt.wasm.trace:!rt.trace)||aa("END",e)}});var ia=q(()=>{"use strict";Vr();Wr();Rn()});var sa=q(()=>{"use strict";ia()});var ua=q(()=>{"use strict"});var da=q(()=>{"use strict"});var la=q(()=>{"use strict"});var ca=q(()=>{"use strict"});var pa=q(()=>{"use strict";Vr();Wr()});var ma=q(()=>{"use strict";pa()});var Kt=q(()=>{"use strict";Yo();Jo();sa();Wr();ua();da();Rn();la();ca();ma()});var Td,Ed,fa,ha,ga,Pd,De,Pt=q(()=>{"use strict";ie();Td=["V","I","W","E","F"],Ed=(e,t)=>{console.log(`[${Td[e]},${new Date().toISOString()}]${t}`)},ga=(e,t)=>{fa=e,ha=t},Pd=(e,t)=>{let r=hr(e),o=hr(fa);r>=o&&Ed(r,typeof t=="function"?t():t)},De=(...e)=>{ha&&Pd(...e)}});var ya,ba=q(()=>{"use strict";ie();ya=(e,t)=>new(Ur(t))(e)});var Gr=q(()=>{"use strict"});var Hr,Od,wa,Dn,Bn,$a,_a=q(()=>{"use strict";Pt();Gr();Hr=e=>Math.ceil(e/16)*16,Od=1,wa=()=>Od++,Dn=async(e,t,r,o)=>{let n=Hr(r),s=e.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,s,0,n),e.flush(),await s.mapAsync(GPUMapMode.READ);let l=s.getMappedRange();if(o){let a=o();return a.set(new Uint8Array(l,0,r)),a}else return new Uint8Array(l.slice(0,r))}finally{s.destroy()}},Bn=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map,this.capturedPendingBuffers=new Map}upload(t,r){let o=r.buffer,n=r.byteOffset,s=r.byteLength,u=Hr(s),l=this.storageCache.get(t);if(!l)throw new Error("gpu data for uploading does not exist");if(l.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${l.originalSize}, data size=${s}`);let a=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=a.getMappedRange();new Uint8Array(p).set(new Uint8Array(o,n,s)),a.unmap();let m=this.backend.getCommandEncoder();this.backend.endComputePass(),m.copyBufferToBuffer(a,0,l.gpuData.buffer,0,u),De("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(a)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(r);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=Hr(o.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(o.gpuData.buffer,0,n.gpuData.buffer,0,s)}registerExternalBuffer(t,r,o){let n;if(o){if(n=this.externalBuffers.get(o),n===void 0)throw new Error("previous buffer is not registered");if(t===o)return De("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, buffer is the same, skip.`),n;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!`);this.externalBuffers.delete(o)}else n=wa();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,n),De("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, registered.`),n}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),De("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Hr(t),n,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||u){let a=s?this.freeBuffers:this.freeUniformBuffers,p=a.get(o);p||(p=[],a.set(o,p)),p.length>0?n=p.pop():n=this.backend.device.createBuffer({size:o,usage:r})}else n=this.backend.device.createBuffer({size:o,usage:r});let l={id:wa(),type:0,buffer:n};return this.storageCache.set(l.id,{gpuData:l,originalSize:t}),De("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${l.id}`),l}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return De("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await Dn(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let r of this.buffersPending)t.push(r);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onReleaseSession(t){let r=this.capturedPendingBuffers.get(t);r&&(r.forEach(o=>{o.destroy()}),this.capturedPendingBuffers.delete(t))}},$a=(...e)=>new Bn(...e)});var Mn,$e,je=q(()=>{"use strict";Mn=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},$e=e=>new Mn(e)});var zn,mt,z,zt,Lr,Fr,qr,_e=q(()=>{"use strict";zn=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},mt=class{static calcShape(t,r,o=!1){let n=t.length,s=r.length;if(n===0)return r;if(s===0)return t;let u=Math.max(t.length,r.length),l=new Array(u);if(o){if(n<2||s<2)return;let a=zn.calcMatMulShape([t[n-2],t[n-1]],[r[s-2],r[s-1]]);if(a===void 0)return;[l[u-2],l[u-1]]=a}for(let a=o?3:1;a<=u;a++){let p=n-a<0?1:t[n-a],m=s-a<0?1:r[s-a];if(p!==m&&p>1&&m>1)return;let f=Math.max(p,m);if(p&&m)l[u-a]=Math.max(p,m);else{if(f>1)return;l[u-a]=0}}return l}static isValidBroadcast(t,r){let o=t.length,n=r.length;if(o>n)return!1;for(let s=1;s<=o;s++)if(t[o-s]!==1&&t[o-s]!==r[n-s])return!1;return!0}},z=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,r=4){let o=t.length;if(o===0)return[];let n=new Array(o),s=o-1;for(;s>=0;){if(t[s]%r===0){n[s]=t[s]/r;break}if(r%t[s]!==0)throw new Error("cannot convert shape");n[s]=1,r/=t[s],s--}for(s--;s>=0;s--)n[s]=t[s];return n}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let n=1;for(let s=r;s<o;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=t[s]}return n}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let n=r-3;n>=0;--n)o[n]=o[n+1]*t[n+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((n,s)=>n+r[s]+r[s+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,n)=>o===r[n])}},zt=class e{static adjustPoolAttributes(t,r,o,n,s,u){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let l=0;l<r.length-2;l++)l>=o.length?o.push(r[l+2]):o[l]=r[l+2];for(let l=0;l<o.length;l++)if(l<n.length){if(n[l]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let l=0;l<o.length;l++)if(l<s.length){if(s[l]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let l=0;l<o.length*2;l++)if(l<u.length){if(u[l]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let l=0;l<o.length;l++){if(o[l]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[l]>=o[l]||u[l+o.length]>=o[l])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,n,s,u,l){if(l){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<t.length-2;a++)e.adjustPadAndReturnShape(t[a+(u?1:2)],r[a],o[a],n[a],s,a,a+t.length-2,l)}}static computePoolOutputShape(t,r,o,n,s,u,l){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let a=[r[0],r[1]];return e.computeShapeHelper(t,r,a,o,n,s,u,l),a}static computeConvOutputShape(t,r,o,n,s,u,l){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let a=[t[0],r[0]];return e.computeShapeHelper(!1,t,a,o,n,s,u,l),a}static computeShapeHelper(t,r,o,n,s,u,l,a){if(t)for(let p=0;p<r.length-2;p++)o.push(1);else for(let p=0;p<r.length-2;p++)o.push(e.adjustPadAndReturnShape(r[p+2],n[p],s[p],u[p],l,p,p+r.length-2,a))}static adjustPadAndReturnShape(t,r,o,n,s,u,l,a){let p=o*(n-1)+1;if(a&&a!=="NOTSET")switch(a){case"VALID":return s[u]=0,s[l]=0,Math.floor((t-p)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let f=((t+r-1)/r-1)*r+n-t;return s[u]=Math.floor(a==="SAME_LOWER"?(f+1)/2:f/2),s[l]=f-s[u],Math.floor((t+f-n)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[u]+s[l]-p)/r+1)}},Lr=class{static getShapeOfGemmResult(t,r,o,n,s){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let u,l,a;r?(u=t[1],l=t[0]):(u=t[0],l=t[1]);let p=-1;if(n?(a=o[0],p=1):(a=o[1],p=0),o[p]!==l)throw new Error("dimension mismatch");if(u<=0||a<=0||l<=0)throw new Error("invalid shape specified");if(s&&!mt.isValidBroadcast(s,[u,a]))throw new Error("gemm: invalid bias shape for broadcast");return[u,a,l]}},Fr=-34028234663852886e22,qr=34028234663852886e22});var Kr,Vn,Pe,et,j,Me,Ye,st,tt,re,Nn,M,F,jr,Un,xa,jt,be=q(()=>{"use strict";ie();_e();Kr=64,Vn=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Pe=(e,t=1)=>{let r=Vn(e,t);return typeof r=="string"?r:r[0]},et=(e,t=1)=>{let r=Vn(e,t);return typeof r=="string"?r:r[1]},j=(...e)=>{let t=[];return e.forEach(r=>{r.length!==0&&t.push({type:12,data:r},{type:12,data:z.computeStrides(r)})}),t},Me=e=>e%4===0?4:e%2===0?2:1,Ye=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,st=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,tt=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,re=(e,t,r,o)=>e.startsWith("uniforms.")&&r>4?typeof t=="string"?o==="f16"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:o==="f16"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,Nn=(e,t,r,o,n)=>{let s=typeof r=="number",u=s?r:r.length,l=[...new Array(u).keys()],a=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,p=Vn(t,n),m=typeof p=="string"?p:p[1],f=typeof p=="string"?p:p[0],b={indices:a,value:m,storage:f,tensor:t},_=G=>typeof G=="string"?G:`${G}u`,y={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},$=s?"uniforms.":"",I=`${$}${e}_shape`,C=`${$}${e}_strides`,v="";for(let G=0;G<u-1;G++)v+=`\n    let dim${G} = current / ${re(C,G,u)};\n    let rest${G} = current % ${re(C,G,u)};\n    indices[${G}] = dim${G};\n    current = rest${G};\n    `;v+=`indices[${u-1}] = current;`;let A=u<2?"":`\n  fn o2i_${e}(offset: u32) -> ${b.indices} {\n    var indices: ${b.indices};\n    var current = offset;\n    ${v}\n    return indices;\n  }`,T=G=>(y.offsetToIndices=!0,u<2?G:`o2i_${e}(${G})`),D=[];if(u>=2)for(let G=u-1;G>=0;G--)D.push(`${re(C,G,u)} * (indices[${G}])`);let U=u<2?"":`\n  fn i2o_${e}(indices: ${b.indices}) -> u32 {\n    return ${D.join("+")};\n  }`,V=G=>(y.indicesToOffset=!0,u<2?G:`i2o_${e}(${G})`),H=(...G)=>u===0?"0u":`${b.indices}(${G.map(_).join(",")})`,R=(G,J)=>u<2?`${G}`:`${re(G,J,u)}`,L=(G,J,Se)=>u<2?`${G}=${Se};`:`${re(G,J,u)}=${Se};`,pe={},Ie=(G,J)=>{y.broadcastedIndicesToOffset=!0;let Se=`${J.name}broadcastedIndicesTo${e}Offset`;if(Se in pe)return`${Se}(${G})`;let Qe=[];for(let Xe=u-1;Xe>=0;Xe--){let Le=J.indicesGet("outputIndices",Xe+J.rank-u);Qe.push(`${R(C,Xe)} * (${Le} % ${R(I,Xe)})`)}return pe[Se]=`fn ${Se}(outputIndices: ${J.type.indices}) -> u32 {\n             return ${Qe.length>0?Qe.join("+"):"0u"};\n           }`,`${Se}(${G})`},we=(G,J)=>(()=>{if(b.storage===b.value)return`${e}[${G}]=${J};`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`${e}[${G}]=vec2<u32>(u32(${J}), select(0u, 0xFFFFFFFFu, ${J} < 0));`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`${e}[${G}]=vec2<u32>(u32(${J}), 0u);`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`${e}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${J}));`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),ne=G=>(()=>{if(b.storage===b.value)return`${e}[${G}]`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`i32(${e}[${G}].x)`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`u32(${e}[${G}].x)`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${G}] & 0xFFu), bool(${e}[${G}] & 0xFF00u), bool(${e}[${G}] & 0xFF0000u), bool(${e}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),ze=u<2?"":`\n  fn get_${e}ByIndices(indices: ${b.indices}) -> ${m} {\n    return ${ne(`i2o_${e}(indices)`)};\n  }`,Q=u<2?"":(()=>{let G=l.map(Se=>`d${Se}: u32`).join(", "),J=l.map(Se=>`d${Se}`).join(", ");return`\n  fn get_${e}(${G}) -> ${m} {\n    return get_${e}ByIndices(${H(J)});\n  }`})(),xe=(...G)=>{if(G.length!==u)throw new Error(`indices length must be ${u}`);let J=G.map(_).join(",");return u===0?ne("0u"):u===1?ne(J[0]):(y.get=!0,y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}(${J})`)},me=G=>u<2?ne(G):(y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}ByIndices(${G})`),ue=u<2?"":`\n  fn set_${e}ByIndices(indices: ${b.indices}, value: ${m}) {\n    ${we(`i2o_${e}(indices)`,"value")}\n  }`,se=u<2?"":(()=>{let G=l.map(Se=>`d${Se}: u32`).join(", "),J=l.map(Se=>`d${Se}`).join(", ");return`\n  fn set_${e}(${G}, value: ${m}) {\n    set_${e}ByIndices(${H(J)}, value);\n  }`})();return{impl:()=>{let G=[],J=!1;return y.offsetToIndices&&(G.push(A),J=!0),y.indicesToOffset&&(G.push(U),J=!0),y.broadcastedIndicesToOffset&&(Object.values(pe).forEach(Se=>G.push(Se)),J=!0),y.set&&(G.push(se),J=!0),y.setByIndices&&(G.push(ue),J=!0),y.get&&(G.push(Q),J=!0),y.getByIndices&&(G.push(ze),J=!0),!s&&J&&G.unshift(`const ${I} = ${b.indices}(${r.join(",")});`,`const ${C} = ${b.indices}(${z.computeStrides(r).join(",")});`),G.join(`\n`)},type:b,offsetToIndices:T,indicesToOffset:V,broadcastedIndicesToOffset:Ie,indices:H,indicesGet:R,indicesSet:L,set:(...G)=>{if(G.length!==u+1)throw new Error(`indices length must be ${u}`);let J=G[u];if(typeof J!="string")throw new Error("value must be string");let Se=G.slice(0,u).map(_).join(",");return u===0?we("0u",J):u===1?we(Se[0],J):(y.set=!0,y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}(${Se}, ${J})`)},setByOffset:we,setByIndices:(G,J)=>u<2?we(G,J):(y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}ByIndices(${G}, ${J});`),get:xe,getByOffset:ne,getByIndices:me,usage:o,name:e,strides:C,shape:I,rank:u}},M=(e,t,r,o=1)=>Nn(e,t,r,"input",o),F=(e,t,r,o=1)=>Nn(e,t,r,"output",o),jr=(e,t,r,o=1)=>Nn(e,t,r,"internal",o),Un=class{constructor(t){this.normalizedDispatchGroup=t;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=Kr){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],n=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=s?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,l=s?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*o*n}u + local_idx;`;return`@compute @workgroup_size(${r}, ${o}, ${n})\n  fn main(${u}) {\n    ${l}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,r){if(t.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);let o=t.usage==="input"?"read":"read_write",n=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${n}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(r=>this.registerInternalVariable(r)),this}registerUniform(t,r,o=1){return this.uniforms.push({name:t,type:r,length:o}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o,length:n}of this.uniforms)if(n&&n>4)o==="f16"?t.push(`@align(16) ${r}:array<mat2x4<${o}>, ${Math.ceil(n/8)}>`):t.push(`${r}:array<vec4<${o}>, ${Math.ceil(n/4)}>`);else{let s=n==null||n===1?o:`vec${n}<${o}>`;t.push(`${r}:${s}`)}return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}},xa=e=>new Un(e),jt=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;n++){let s=r-1-n,u=e[s]||1;(t[t.length-1-n]||1)>1&&u===1&&o.unshift(s)}return o}});var kd,Sa,Rd,Bd,ot,Ca,Ia,Yt=q(()=>{"use strict";ie();_e();je();be();kd=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},Sa=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Rd=(e,t)=>z.sortBasedOnPerm(e,Sa(e.length,t)),Bd=(e,t,r,o)=>{let n=[];n.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let s=0;s<t;++s)n.push(r.indicesSet("a",e[s],`i[${s}]`));return n.push("return a;}"),n.join(`\n`)},ot=(e,t)=>{let r=e.dataType,o=e.dims.length,n=Sa(o,t),s=Rd(e.dims,n),u=F("output",r,s.length),l=M("a",r,o),a=p=>`\n  ${p.registerUniform("output_size","u32").declareVariables(l,u)}\n\n  ${Bd(n,o,l,u)}\n\n  ${p.mainStart()}\n    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${u.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${u.setByOffset("global_idx",l.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:p=>{let m=z.size(s);return{outputs:[{dims:s,dataType:p[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:12,data:m},...j(p[0].dims,s)]}},getShaderSource:a}},Ca=(e,t)=>{kd(e.inputs),e.compute(ot(e.inputs[0],t.perm))},Ia=e=>$e({perm:e.perm})});var Dd,Md,zd,Ud,Vd,Nd,Wd,Gd,Hd,Ld,ft,Aa,Ta,Ea,Pa,Oa,ka,Ra,Ba,Da,Ma,za=q(()=>{"use strict";ie();_e();be();Yr();Yt();Dd={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Md={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},zd={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Ud={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Vd=(e,t)=>{let r=[];for(let o=t-e;o<t;++o)r.push(o);return r},Nd=(e,t)=>{let r=[],o=e.length;for(let s=0;s<o;s++)t.indexOf(s)===-1&&r.push(e[s]);let n=t.map(s=>e[s]);return[r,n]},Wd=(e,t)=>{let r=e.length+t.length,o=[],n=0;for(let s=0;s<r;s++)t.indexOf(s)===-1?o.push(e[n++]):o.push(1);return o},Gd=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},Hd=(e,t)=>{let r=[];if(!Gd(e,t)){for(let o=0;o<t;++o)e.indexOf(o)===-1&&r.push(o);e.forEach(o=>r.push(o))}return r},Ld=(e,t,r,o,n,s,u)=>{let l=r[0].dims,a=z.size(s),p=z.size(u),m=M("_A",r[0].dataType,l),f=F("output",n,s),b=32,_=`\n          var<workgroup> aBestValues : array<f32, ${b}>;\n       `;return{name:e,shaderCache:t,getShaderSource:$=>`\n        ${$.registerUniform("reduceSize","u32").declareVariables(m,f)}\n        ${_}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${$.mainStart(b)}\n\n          let outputIndex = global_idx / ${b};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${zd[o]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${b}) {\n           let candidate = f32(${m.getByOffset("offset + k")});\n           bestValue = ${Dd[o]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${b}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${Md[o]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${f.setByOffset("outputIndex",`${o==="mean"?`${f.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${f.type.storage}(${Ud[o]})`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:s,dataType:n}],dispatchGroup:{x:a},programUniforms:[{type:12,data:p}]})}},ft=(e,t,r,o)=>{let n=e.inputs.length===1?r:Wn(e.inputs,r),s=n.axes;s.length===0&&!n.noopWithEmptyAxes&&(s=e.inputs[0].dims.map((_,y)=>y));let u=z.normalizeAxes(s,e.inputs[0].dims.length),l=u,a=e.inputs[0],p=Hd(l,e.inputs[0].dims.length);p.length>0&&(a=e.compute(ot(e.inputs[0],p),{inputs:[0],outputs:[-1]})[0],l=Vd(l.length,a.dims.length));let[m,f]=Nd(a.dims,l),b=m;n.keepDims&&(b=Wd(m,u)),e.compute(Ld(t,{hint:n.cacheKey,inputDependencies:["type"]},[a],o,e.inputs[0].dataType,b,f),{inputs:[a]})},Aa=(e,t)=>{ft(e,"ReduceMeanShared",t,"mean")},Ta=(e,t)=>{ft(e,"ReduceL1Shared",t,"l1")},Ea=(e,t)=>{ft(e,"ReduceL2Shared",t,"l2")},Pa=(e,t)=>{ft(e,"ReduceLogSumExpShared",t,"logSumExp")},Oa=(e,t)=>{ft(e,"ReduceMaxShared",t,"max")},ka=(e,t)=>{ft(e,"ReduceMinShared",t,"min")},Ra=(e,t)=>{ft(e,"ReduceProdShared",t,"prod")},Ba=(e,t)=>{ft(e,"ReduceSumShared",t,"sum")},Da=(e,t)=>{ft(e,"ReduceSumSquareShared",t,"sumSquare")},Ma=(e,t)=>{ft(e,"ReduceLogSumShared",t,"logSum")}});var ht,Fd,Zr,Wn,gt,qd,Kd,jd,Yd,Zd,Qd,Xd,Jd,el,tl,yt,Ua,Va,Na,Wa,Ga,Ha,La,Fa,qa,Ka,Yr=q(()=>{"use strict";ie();_e();je();be();za();ht=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Fd=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],Zr=(e,t,r,o,n,s,u=!1,l=!1)=>{let a=[],p=r[0].dims,m=p.length,f=z.normalizeAxes(n,m),b=!l&&f.length===0;p.forEach((I,C)=>{b||f.indexOf(C)>=0?u&&a.push(1):a.push(I)});let _=a.length,y=z.size(a);return{name:e,shaderCache:t,getShaderSource:I=>{let C=[],v=M("_A",r[0].dataType,m),A=F("output",s,_),T=o(v,A,f),D=T[2];for(let U=0,V=0;U<m;U++)b||f.indexOf(U)>=0?(u&&V++,D=`for(var j${U}: u32 = 0; j${U} < ${p[U]}; j${U}++) {\n                  ${T[2].includes("last_index")?`let last_index = j${U};`:""}\n                  ${v.indicesSet("input_indices",U,`j${U}`)}\n                  ${D}\n                }`):(C.push(`${v.indicesSet("input_indices",U,A.indicesGet("output_indices",V))};`),V++);return`\n\n        ${I.registerUniform("output_size","u32").declareVariables(v,A)}\n\n        ${I.mainStart()}\n          ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${v.type.indices};\n          let output_indices = ${A.offsetToIndices("global_idx")};\n\n          ${C.join(`\n`)}\n          ${T[0]}       // init ops for reduce max/min\n          ${T[1]}\n          ${D}\n          ${T[3]}\n          ${T.length===4?A.setByOffset("global_idx","value"):T.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},...j(p,a)]})}},Wn=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),$e({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},gt=(e,t,r,o)=>{let n=e.inputs,s=n.length===1?r:Wn(n,r);e.compute(Zr(t,{hint:s.cacheKey,inputDependencies:["rank"]},[n[0]],s.noopWithEmptyAxes&&s.axes.length===0?Fd:o,s.axes,n[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},qd=(e,t)=>{ht(e.inputs),gt(e,"ReduceLogSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,"value = log(value);"])},Kd=(e,t)=>{ht(e.inputs),gt(e,"ReduceL1",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${o.getByIndices("input_indices")});`,""])},jd=(e,t)=>{ht(e.inputs),gt(e,"ReduceL2",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Yd=(e,t)=>{ht(e.inputs),gt(e,"ReduceLogSumExp",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${o.getByIndices("input_indices")});`,"value = log(value);"])},Zd=(e,t)=>{ht(e.inputs),gt(e,"ReduceMax",t,(o,n,s)=>{let u=[];for(let l=0;l<o.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(o.indicesSet("input_indices",l,0));return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = max(value, ${o.getByIndices("input_indices")});`,""]})},Qd=(e,t)=>{ht(e.inputs),gt(e,"ReduceMean",t,(o,n,s)=>{let u=1;for(let l=0;l<o.rank;l++)(s.indexOf(l)>=0||s.length===0)&&(u*=e.inputs[0].dims[l]);return["var sum = f32(0);","",`sum += f32(${o.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${u});`]})},Xd=(e,t)=>{ht(e.inputs),gt(e,"ReduceMin",t,(o,n,s)=>{let u=[];for(let l=0;l<o.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(`input_indices[${l}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = min(value, ${o.getByIndices("input_indices")});`,""]})},Jd=(e,t)=>{ht(e.inputs),gt(e,"ReduceProd",t,(o,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${o.getByIndices("input_indices")};`,""])},el=(e,t)=>{ht(e.inputs),gt(e,"ReduceSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,""])},tl=(e,t)=>{ht(e.inputs),gt(e,"ReduceSumSquare",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += t * t;`,""])},yt=(e,t,r)=>{if(t.length===0)return r;let o=1,n=1;for(let s=0;s<t.length;s++)t.indexOf(s)===-1?o*=e[s]:n*=e[s];return n<32&&o>1024},Ua=(e,t)=>{yt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Qd(e,t):Aa(e,t)},Va=(e,t)=>{yt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Kd(e,t):Ta(e,t)},Na=(e,t)=>{yt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?jd(e,t):Ea(e,t)},Wa=(e,t)=>{yt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Yd(e,t):Pa(e,t)},Ga=(e,t)=>{yt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Zd(e,t):Oa(e,t)},Ha=(e,t)=>{yt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Xd(e,t):ka(e,t)},La=(e,t)=>{yt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Jd(e,t):Ra(e,t)},Fa=(e,t)=>{yt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?el(e,t):Ba(e,t)},qa=(e,t)=>{yt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?tl(e,t):Da(e,t)},Ka=(e,t)=>{yt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?qd(e,t):Ma(e,t)}});var ja,Ya,Za,Gn,Qa=q(()=>{"use strict";ie();je();Yr();ja=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Ya=(e,t)=>{ja(e.inputs);let r=(o,n,s)=>{let u=[];for(let l=0;l<o.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(`input_indices[${l}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]};e.compute(Zr("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},Za=(e,t)=>{ja(e.inputs);let r=(o,n,s)=>{let u=[];for(let l=0;l<o.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(`input_indices[${l}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]};e.compute(Zr("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},Gn=e=>$e(e)});var rl,nl,ol,al,Qr,il,Xa,Hn=q(()=>{"use strict";ie();Gr();be();rl=(e,t)=>{let r=e[0],o=e[1],n=e[2],s=e[3],u=e[4],l=e[5];if(u&&l)throw new Error("Attention cannot have both past and relative_position_bias");if(r.dims.length!==3)throw new Error(\'Input "input" must have 3 dimensions\');let a=r.dims[0],p=r.dims[1],m=r.dims[2];if(n.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimensions\');if(o.dims.length!==2)throw new Error(\'Input "weights" is expected to have 2 dimensions\');if(o.dims[0]!==m)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(n.dims[0]!==o.dims[1])throw new Error(\'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"\');let f=n.dims[0]/3,b=f,_=b;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let A of t.qkvHiddenSizes)if(A%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");f=t.qkvHiddenSizes[0],b=t.qkvHiddenSizes[1],_=t.qkvHiddenSizes[2]}let y=p;if(f!==b)throw new Error("qkv_hidden_sizes first element should be same as the second");if(n.dims[0]!==f+b+_)throw new Error(\'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes\');let $=0;if(u){if(b!==_)throw new Error(\'Input "past" expect k_hidden_size == v_hidden_size\');if(u.dims.length!==5)throw new Error(\'Input "past" must have 5 dimensions\');if(u.dims[0]!==2)throw new Error(\'Input "past" first dimension must be 2\');if(u.dims[1]!==a)throw new Error(\'Input "past" second dimension must be batch_size\');if(u.dims[2]!==t.numHeads)throw new Error(\'Input "past" third dimension must be num_heads\');if(u.dims[4]!==b/t.numHeads)throw new Error(\'Input "past" fifth dimension must be k_hidden_size / num_heads\');t.pastPresentShareBuffer||($=u.dims[3])}let I=y+$,C=-1,v=0;if(s)throw new Error("Mask not supported");if(u)throw new Error("past is not supported");if(l)throw new Error("relativePositionBias is not supported");return{batchSize:a,sequenceLength:p,pastSequenceLength:$,kvSequenceLength:y,totalSequenceLength:I,maxSequenceLength:C,inputHiddenSize:m,hiddenSize:f,vHiddenSize:_,headSize:Math.floor(f/t.numHeads),vHeadSize:Math.floor(_/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:v,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},nl=(e,t,r,o)=>{let n=Me(o),s=64,u=o/n;u<s?s=1:u/8<64&&(s=Math.ceil(u/8));let l=Math.ceil(o/n/s),a=[{type:t.dataType,data:1/o},{type:12,data:u},{type:12,data:l}],p=Pe(t.dataType,n),m=f=>{let b=F("x",t.dataType,t.dims,n),_="thread_max_vector";n===2?_="max(thread_max_vector.x, thread_max_vector.y)":n===4&&(_="max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))");let y=et(t.dataType),$=[{name:"d_inv",type:y},{name:"d_comp",type:"u32"},{name:"elements_per_wg",type:"u32"}];return`\n  var<workgroup> wgMax: array<f32, ${s}>;\n  var<workgroup> wgSum: array<f32, ${s}>;\n  ${f.registerUniforms($).declareVariables(b)}\n  ${f.mainStart([s,1,1])}\n    let localOffset = local_idx * uniforms.elements_per_wg;\n    let offset: u32 = workgroup_id.x * uniforms.d_comp + localOffset;\n\n    var thread_max_vector = ${Ye("f32",n,"-3.402823e+38f")};\n    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n      thread_max_vector = max(${st(y,n,"x[offset + i]")}, thread_max_vector);\n    }\n    wgMax[local_idx] = ${_};\n    workgroupBarrier();\n\n    var maxValue = -3.402823e+38f;\n    for (var i = 0u; i < ${s}; i++) {\n      maxValue = max(wgMax[i], maxValue);\n    }\n\n    var sumVector = ${Ye("f32",n,"0")};\n    for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n      sumVector += exp(${st(y,n,"x[offset + i]")} - maxValue);\n    }\n    wgSum[local_idx] = ${tt("sumVector",n)};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${s}; i++) {\n      sum += wgSum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n        x[offset + i] = ${Ye(y,n,"uniforms.d_inv")};\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_wg && i + localOffset < uniforms.d_comp; i++) {\n        let f32input = ${st(y,n,"x[offset + i]")};\n        x[offset + i] = ${b.type.value}(exp(f32input - maxValue) / sum);\n      }\n    }\n  }`};e.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${s};${p};${n}`},getShaderSource:m,getRunData:()=>({outputs:[],dispatchGroup:{x:r},programUniforms:a})},{inputs:[t],outputs:[]})},ol=(e,t,r,o,n,s)=>{let u=[n.batchSize,n.numHeads,n.sequenceLength,n.kvSequenceLength+n.pastSequenceLength],l=s.scale===0?1/Math.sqrt(n.headSize):s.scale,a=Me(n.headSize),p=n.headSize/a,m=12,f={x:Math.ceil(n.totalSequenceLength/m),y:Math.ceil(n.sequenceLength/m),z:n.batchSize*n.numHeads},b=[{type:12,data:n.sequenceLength},{type:12,data:p},{type:12,data:n.totalSequenceLength},{type:12,data:n.kvSequenceLength},{type:t.dataType,data:l}],_=[t,r],y=I=>{let C=M("q",t.dataType,t.dims,a),v=M("key",r.dataType,r.dims,a),A=F("output",t.dataType,u),T=Pe(t.dataType),D=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"alpha",type:T}];return`\n  const beta: ${T} = 1.0;\n  const TILE_SIZE = ${m}u;\n\n  var<workgroup> tileQ: array<${C.type.storage}, ${m*m}>;\n  var<workgroup> tileK: array<${C.type.storage}, ${m*m}>;\n  ${I.registerUniforms(D).declareVariables(C,v,A)}\n  ${I.mainStart([m,m,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let lm = m + local_id.y;\n    let ln = n + local_id.x;\n\n    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;\n    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx + n * uniforms.K;\n\n    var value = ${Ye(T,a)};\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m + local_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = headIdx * uniforms.M * uniforms.N;\n    if (lm < uniforms.M && ln < uniforms.N) {\n      let outputIdx = headOffset + lm * uniforms.N + ln;\n      output[outputIdx] = ${tt("value",a)} * uniforms.alpha;\n    }\n  }`},$=e.compute({name:"AttentionProbs",shaderCache:{hint:`${a}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType,gpuDataType:0}],dispatchGroup:f,programUniforms:b}),getShaderSource:y},{inputs:_,outputs:[-1]})[0];return nl(e,$,n.batchSize*n.numHeads*n.sequenceLength,n.totalSequenceLength),$},al=(e,t,r,o)=>{let n=[o.batchSize,o.sequenceLength,o.vHiddenSize],s=12,u={x:Math.ceil(o.vHeadSize/s),y:Math.ceil(o.sequenceLength/s),z:o.batchSize*o.numHeads},l=[{type:12,data:o.sequenceLength},{type:12,data:o.totalSequenceLength},{type:12,data:o.vHeadSize},{type:12,data:o.numHeads},{type:12,data:o.vHiddenSize}],a=p=>{let m=M("probs",t.dataType,t.dims),f=M("v",r.dataType,r.dims),b=F("output",t.dataType,n),_=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"}];return`\n  const TILE_SIZE = ${s}u;\n  var<workgroup> tileQ: array<${m.type.value}, ${s*s}>;\n  var<workgroup> tileK: array<${m.type.value}, ${s*s}>;\n  ${p.registerUniforms(_).declareVariables(m,f,b)}\n  ${p.mainStart([s,s,1])}\n   let headIdx = workgroup_id.z;\n   let m = workgroup_id.y * TILE_SIZE + local_id.y;\n   let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;\n   let offsetB = headIdx * (uniforms.N * uniforms.K) + n;\n\n   var value = ${m.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n     if (m < uniforms.M && w + local_id.x < uniforms.K) {\n       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n     }\n     if (n < uniforms.N && w + local_id.y < uniforms.K) {\n       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * uniforms.N];\n     }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;\n   let headOffset = (batchIdx * uniforms.M * uniforms.num_heads + currentBatchHeadNumber) * uniforms.N;\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M *uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + currentBatchHeadNumber * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`};return e.compute({name:"AttentionScore",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:t.dataType,gpuDataType:0}],dispatchGroup:u,programUniforms:l}),getShaderSource:a},{inputs:[t,r],outputs:[0]})[0]},Qr=(e,t,r,o,n,s,u,l,a,p,m)=>{let f=ol(e,t,r,a,p,m);al(e,f,o,p)},il=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],o=t.sequenceLength,n=t.inputHiddenSize,s=t.headSize,u=12,l={x:Math.ceil(t.headSize/u),y:Math.ceil(t.sequenceLength/u),z:t.batchSize*t.numHeads},a=[e.inputs[0],e.inputs[1],e.inputs[2]],p=[{type:12,data:o},{type:12,data:n},{type:12,data:s},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],m=f=>{let b=F("output_q",a[0].dataType,r),_=F("output_k",a[0].dataType,r),y=F("output_v",a[0].dataType,r),$=M("input",a[0].dataType,a[0].dims),I=M("weight",a[1].dataType,a[1].dims),C=M("bias",a[2].dataType,a[2].dims),v=$.type.storage,A=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`\n  const TILE_SIZE = ${u}u;\n  var<workgroup> tileInput: array<${v}, ${u*u}>;\n  var<workgroup> tileWeightQ: array<${v}, ${u*u}>;\n  var<workgroup> tileWeightK: array<${v}, ${u*u}>;\n  var<workgroup> tileWeightV: array<${v}, ${u*u}>;\n  ${f.registerUniforms(A).declareVariables($,I,C,b,_,y)}\n  ${f.mainStart([u,u,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE + local_id.y;\n    let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${v}(0);\n    var valueK = ${v}(0);\n    var valueV = ${v}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`};return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:l,programUniforms:p}),getShaderSource:m},{inputs:a,outputs:[-1,-1,-1]})},Xa=(e,t)=>{let r=rl(e.inputs,t),[o,n,s]=il(e,r);return Qr(e,o,n,s,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t)}});var sl,ul,dl,Ja,ei=q(()=>{"use strict";Kt();ie();_e();je();be();sl=(e,t)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let r=(o,n,s)=>{let u=n.length;if(u!==o.length)throw new Error(`${s}: num dimensions != ${u}`);n.forEach((l,a)=>{if(l!==o[a])throw new Error(`${s}: dim[${a}] do not match`)})};if(e[0].dims.length>1){let o=t.format==="NHWC"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,o,"Invalid input scale"),r(e[2].dims,o,"Invalid input B"),r(e[3].dims,o,"Invalid input mean"),r(e[4].dims,o,"Invalid input var")}else r(e[1].dims,[1],"Invalid input scale"),r(e[2].dims,[1],"Invalid input B"),r(e[3].dims,[1],"Invalid input mean"),r(e[4].dims,[1],"Invalid input var")},ul=(e,t)=>{let{epsilon:r,spatial:o,format:n}=t,s=e[0].dims,u=o?Me(s[s.length-1]):1,l=n==="NHWC"&&s.length>1?u:1,a=z.size(s)/u,p=o,m=p?s.length:s,f=M("x",e[0].dataType,e[0].dims,u),b=M("scale",e[1].dataType,e[1].dims,l),_=M("bias",e[2].dataType,e[2].dims,l),y=M("inputMean",e[3].dataType,e[3].dims,l),$=M("inputVar",e[4].dataType,e[4].dims,l),I=F("y",e[0].dataType,m,u),C=()=>{let A="";if(o)A=`let cOffset = ${s.length===1?"0u":n==="NHWC"?`outputIndices[${s.length-1}] / ${u}`:"outputIndices[1]"};`;else if(n==="NCHW")A=`\n            ${I.indicesSet("outputIndices","0","0")}\n            let cOffset = ${I.indicesToOffset("outputIndices")};`;else{A=`var cIndices = ${b.type.indices}(0);\n                       cIndices[0] = outputIndices[${s.length-1}];`;for(let T=1;T<b.rank;T++)A+=`cIndices[${T}] = outputIndices[${T}];`;A+=`let cOffset = ${b.indicesToOffset("cIndices")};`}return A},v=A=>`\n  const epsilon = ${r};\n  ${A.registerUniform("outputSize","u32").declareVariables(f,b,_,y,$,I)}\n  ${A.mainStart()}\n  ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${I.offsetToIndices(`global_idx * ${u}`)};\n    ${C()}\n    let scale = ${b.getByOffset("cOffset")};\n    let bias = ${_.getByOffset("cOffset")};\n    let inputMean = ${y.getByOffset("cOffset")};\n    let inputVar = ${$.getByOffset("cOffset")};\n    let x = ${f.getByOffset("global_idx")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${I.setByOffset("global_idx","value")}\n  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${o}_${u}`,inputDependencies:p?["rank","type","type","type","type"]:void 0},getShaderSource:v,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p?[{type:12,data:a},...j(s)]:[{type:12,data:a}]})}},dl=e=>$e(e),Ja=(e,t)=>{let{inputs:r,outputCount:o}=e,n=dl({...t,outputCount:o});if(qt.webgpu.validateInputContent&&sl(r,n),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(ul(r,n))}});var ll,cl,ti,ri=q(()=>{"use strict";_e();be();ll=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},cl=e=>{let t=e[0].dims,r=e[0].dims[2],o=z.size(t)/4,n=e[0].dataType,s=M("input",n,t,4),u=M("bias",n,[r],4),l=M("residual",n,t,4),a=F("output",n,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:m=>`\n  const channels = ${r}u / 4;\n  ${m.declareVariables(s,u,l,a)}\n\n  ${m.mainStart()}\n    ${m.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let value = ${s.getByOffset("global_idx")}\n      + ${u.getByOffset("global_idx % channels")} + ${l.getByOffset("global_idx")};\n    ${a.setByOffset("global_idx","value")}\n  }`}},ti=e=>{ll(e.inputs),e.compute(cl(e.inputs))}});var pl,Ee,ni,oi,ai,ii,si,ui,di,li,ci,ml,pi,mi,fi,hi,Xr,gi,Jr,yi,bi,wi,vi,$i,_i,xi,Si,Ci,Ii,Ai,Ti,Ei,Pi,Oi,ki,Ri,Bi,Ln,Fn,Di,Mi,zi,en=q(()=>{"use strict";ie();_e();je();be();pl=(e,t,r,o,n,s)=>{let u=Math.ceil(t/4),l="";typeof n=="string"?l=`${n}(a)`:l=n("a");let a=M("inputData",r,[u],4),p=F("outputData",o,[u],4);return`\n      ${e.registerUniform("vec_size","u32").declareVariables(a,p)}\n\n  ${s??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${a.getByOffset("global_idx")};\n    ${p.setByOffset("global_idx",l)}\n  }`},Ee=(e,t,r,o,n,s=e.dataType)=>({name:t,shaderCache:{hint:n,inputDependencies:["type"]},getShaderSource:u=>pl(u,z.size(e.dims),e.dataType,s,r,o),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(z.size(u[0].dims)/64/4)},programUniforms:[{type:12,data:Math.ceil(z.size(e.dims)/4)}]})}),ni=e=>{e.compute(Ee(e.inputs[0],"Abs","abs"))},oi=e=>{e.compute(Ee(e.inputs[0],"Acos","acos"))},ai=e=>{e.compute(Ee(e.inputs[0],"Acosh","acosh"))},ii=e=>{e.compute(Ee(e.inputs[0],"Asin","asin"))},si=e=>{e.compute(Ee(e.inputs[0],"Asinh","asinh"))},ui=e=>{e.compute(Ee(e.inputs[0],"Atan","atan"))},di=e=>{e.compute(Ee(e.inputs[0],"Atanh","atanh"))},li=e=>$e(e),ci=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(Ee(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},ml=e=>{let t=e.length>=2&&e[1].data!==0?e[1].getFloat32Array()[0]:Fr,r=e.length>=3&&e[2].data!==0?e[2].getFloat32Array()[0]:qr;return $e({min:t,max:r})},pi=(e,t)=>{let r=e.inputs.length===1?t:ml(e.inputs),o=et(e.inputs[0].dataType);e.compute(Ee(e.inputs[0],"Clip",n=>`clamp(${n}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${o}> = vec4(${o}(${r.min}));\n    const clip_max_: vec4<${o}> = vec4(${o}(${r.max}));\n`,r.cacheKey),{inputs:[0]})},mi=e=>{e.compute(Ee(e.inputs[0],"Ceil","ceil"))},fi=e=>{e.compute(Ee(e.inputs[0],"Cos","cos"))},hi=e=>{e.compute(Ee(e.inputs[0],"Cosh","cosh"))},Xr=e=>$e(e),gi=(e,t)=>{let r=et(e.inputs[0].dataType);e.compute(Ee(e.inputs[0],"Elu",o=>`elu_vf32(${o})`,`\n  const elu_alpha_ = ${r}(${t.alpha});\n\n  fn elu_f32(a: ${r}) -> ${r} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Jr=(e="f32")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,yi=e=>{let t=et(e.inputs[0].dataType);e.compute(Ee(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Jr(t)))},bi=e=>{e.compute(Ee(e.inputs[0],"Exp","exp"))},wi=e=>{e.compute(Ee(e.inputs[0],"Floor","floor"))},vi=e=>{let t=et(e.inputs[0].dataType);e.compute(Ee(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Jr(t)))},$i=(e,t)=>{let r=et(e.inputs[0].dataType);e.compute(Ee(e.inputs[0],"LeakyRelu",o=>`select(leaky_relu_alpha_ * ${o}, ${o}, ${o} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},_i=e=>{e.compute(Ee(e.inputs[0],"Not",t=>`!${t}`))},xi=e=>{e.compute(Ee(e.inputs[0],"Neg",t=>`-${t}`))},Si=e=>{e.compute(Ee(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},Ci=e=>{let t=et(e.inputs[0].dataType);e.compute(Ee(e.inputs[0],"Relu",r=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},Ii=e=>{e.compute(Ee(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},Ai=e=>$e(e),Ti=(e,t)=>{let r=et(e.inputs[0].dataType);e.compute(Ee(e.inputs[0],"HardSigmoid",o=>`max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${t.alpha} * ${o} + vec4<${r}>(${t.beta})))`,void 0,t.cacheKey))},Ei=e=>{e.compute(Ee(e.inputs[0],"Sin","sin"))},Pi=e=>{e.compute(Ee(e.inputs[0],"Sinh","sinh"))},Oi=e=>{e.compute(Ee(e.inputs[0],"Sqrt","sqrt"))},ki=e=>{e.compute(Ee(e.inputs[0],"Tan","tan"))},Ri=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,Bi=e=>{e.compute(Ee(e.inputs[0],"Tanh",Ri))},Ln=(e="f32")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${Ri("v")};\n}\n`,Fn=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,Di=e=>{let t=et(e.inputs[0].dataType);e.compute(Ee(e.inputs[0],"FastGelu",Fn,Ln(t),void 0,e.inputs[0].dataType))},Mi=(e,t)=>{let r=et(e.inputs[0].dataType);return e.compute(Ee(e.inputs[0],"ThresholdedRelu",o=>`select(vec4<${r}>(0.0), ${o}, ${o} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},zi=e=>{e.compute(Ee(e.inputs[0],"Log","log"))}});var fl,hl,Vi,Ni=q(()=>{"use strict";_e();be();en();fl=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},hl=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=M("input",e[0].dataType,e[0].dims,4),o=M("bias",e[0].dataType,[e[0].dims[2]],4),n=F("output",e[0].dataType,t,4),s=z.size(t)/4,u=Pe(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:a=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${a.declareVariables(r,o,n)}\n\n  ${Jr(u)}\n\n  ${a.mainStart()}\n    ${a.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${n.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Vi=e=>{fl(e.inputs),e.compute(hl(e.inputs))}});var gl,yl,bt,Wi,Gi,Hi,Li,Fi,qi,Ki,ji,Yi,Zi,Qi=q(()=>{"use strict";ie();_e();be();gl=(e,t,r,o,n,s,u,l,a,p,m,f)=>{let b,_;typeof l=="string"?b=_=(v,A)=>`${l}((${v}),(${A}))`:typeof l=="function"?b=_=l:(b=l.scalar,_=l.vector);let y=F("outputData",m,o.length,4),$=M("aData",a,t.length,4),I=M("bData",p,r.length,4),C;if(n)if(s){let v=z.size(t)===1,A=z.size(r)===1,T=t.length>0&&t[t.length-1]%4===0,D=r.length>0&&r[r.length-1]%4===0;v||A?C=y.setByOffset("global_idx",_(v?`${$.type.value}(${$.getByOffset("0")}.x)`:$.getByOffset("global_idx"),A?`${I.type.value}(${I.getByOffset("0")}.x)`:I.getByOffset("global_idx"))):C=`\n            let outputIndices = ${y.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${$.broadcastedIndicesToOffset("outputIndices",y)};\n            let offsetB = ${I.broadcastedIndicesToOffset("outputIndices",y)};\n            ${y.setByOffset("global_idx",_(u||T?$.getByOffset("offsetA / 4u"):`${$.type.value}(${$.getByOffset("offsetA / 4u")}[offsetA % 4u])`,u||D?I.getByOffset("offsetB / 4u"):`${I.type.value}(${I.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else C=y.setByOffset("global_idx",_($.getByOffset("global_idx"),I.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let v=(A,T,D="")=>{let U=`aData[indexA${T}][componentA${T}]`,V=`bData[indexB${T}][componentB${T}]`;return`\n            let outputIndices${T} = ${y.offsetToIndices(`global_idx * 4u + ${T}u`)};\n            let offsetA${T} = ${$.broadcastedIndicesToOffset(`outputIndices${T}`,y)};\n            let offsetB${T} = ${I.broadcastedIndicesToOffset(`outputIndices${T}`,y)};\n            let indexA${T} = offsetA${T} / 4u;\n            let indexB${T} = offsetB${T} / 4u;\n            let componentA${T} = offsetA${T} % 4u;\n            let componentB${T} = offsetB${T} % 4u;\n            ${A}[${T}] = ${D}(${b(U,V)});\n          `};m===9?C=`\n            var data = vec4<u32>(0);\n            ${v("data",0,"u32")}\n            ${v("data",1,"u32")}\n            ${v("data",2,"u32")}\n            ${v("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:C=`\n            ${v("outputData[global_idx]",0)}\n            ${v("outputData[global_idx]",1)}\n            ${v("outputData[global_idx]",2)}\n            ${v("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables($,I,y)}\n\n        ${f??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${C}\n      }`},yl=(e,t,r,o,n,s,u=r.dataType)=>{let l=!z.areEqual(r.dims,o.dims),a=r.dims,p=z.size(r.dims),m=!1,f=!1,b=[l];if(l){let _=mt.calcShape(r.dims,o.dims,!1);if(!_)throw new Error("Can\'t perform binary op on the given tensors");a=_,p=z.size(a);let y=z.size(r.dims)===1,$=z.size(o.dims)===1,I=r.dims.length>0&&r.dims[r.dims.length-1]%4===0,C=o.dims.length>0&&o.dims[o.dims.length-1]%4===0;b.push(y),b.push($),b.push(I),b.push(C);let v=1;for(let A=1;A<a.length;A++){let T=r.dims[r.dims.length-A]??1,D=o.dims[o.dims.length-A]??1;if(T===D)v*=T;else break}v%4===0?(f=!0,m=!0):(y||$||I||C)&&(m=!0)}else m=!0;return b.push(m),{name:e,shaderCache:{hint:t+b.map(_=>_.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:_=>gl(_,r.dims,o.dims,a,m,l,f,n,r.dataType,o.dataType,u,s),getRunData:()=>({outputs:[{dims:a,dataType:u}],dispatchGroup:{x:Math.ceil(p/64/4)},programUniforms:[{type:12,data:Math.ceil(z.size(a)/4)},...j(r.dims,o.dims,a)]})}},bt=(e,t,r,o,n,s)=>{e.compute(yl(t,n??"",e.inputs[0],e.inputs[1],r,o,s))},Wi=e=>{bt(e,"Add",(t,r)=>`${t}+${r}`)},Gi=e=>{bt(e,"Div",(t,r)=>`${t}/${r}`)},Hi=e=>{bt(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Li=e=>{bt(e,"Mul",(t,r)=>`${t}*${r}`)},Fi=e=>{let t=M("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;bt(e,"Pow",{scalar:(o,n)=>`pow_custom(${o},${n})`,vector:(o,n)=>`pow_vector_custom(${o},${n})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},qi=e=>{bt(e,"Sub",(t,r)=>`${t}-${r}`)},Ki=e=>{bt(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},ji=e=>{bt(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Yi=e=>{bt(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Zi=e=>{bt(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var wl,vl,$l,_l,Xi,Ji,es=q(()=>{"use strict";ie();_e();je();be();wl=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let r=0,o=e[r],n=o.dataType,s=o.dims.length;e.forEach((u,l)=>{if(l!==r){if(u.dataType!==n)throw new Error("input tensors should be one type");if(u.dims.length!==s)throw new Error("input tensors should have the same shape");u.dims.forEach((a,p)=>{if(p!==t&&a!==o.dims[p])throw new Error("non concat dimensions must match")})}})},vl=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,$l=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;++n){let s=t.setByOffset("global_idx",e[n].getByIndices("indices"));r===1?o.push(s):n===0?o.push(`if (inputIndex == ${n}u) { ${s} }`):n===r-1?o.push(`else { ${s} }`):o.push(`else if (inputIndex == ${n}) { ${s} }`)}return o.join(`\n`)},_l=(e,t,r,o)=>{let n=z.size(r),s=new Array(e.length),u=new Array(e.length),l=0,a=[],p=[],m=[{type:12,data:n}];for(let $=0;$<e.length;++$)l+=e[$].dims[t],s[$]=l,p.push(e[$].dims.length),u[$]=M(`input${$}`,o,p[$]),a.push("rank"),m.push({type:12,data:s[$]});for(let $=0;$<e.length;++$)m.push(...j(e[$].dims));m.push(...j(r));let f=F("output",o,r.length),b=f.indicesGet("indices",t),_=Array.from(Array(s.length).keys()).map($=>`uniforms.sizeInConcatAxis${$}`).join(","),y=$=>`\n\n  ${(()=>{$.registerUniform("outputSize","u32");for(let I=0;I<e.length;I++)$.registerUniform(`sizeInConcatAxis${I}`,"u32");return $.declareVariables(...u,f)})()}\n\n  ${vl(s.length,_)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${f.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${b});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${s.length}u>(${_});\n      ${b} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${$l(u,f)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:a},getRunData:()=>({outputs:[{dims:r,dataType:o}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:m}),getShaderSource:y}},Xi=(e,t)=>{let r=e.inputs,o=r[0].dims,n=z.normalizeAxis(t.axis,o.length);wl(r,n);let s=o.slice();s[n]=r.reduce((l,a)=>l+(a.dims.length>n?a.dims[n]:0),0);let u=r.filter(l=>z.size(l.dims)>0);e.compute(_l(u,n,s,r[0].dataType),{inputs:u})},Ji=e=>$e({axis:e.axis})});var ut,dt,lt,tn,Ot=q(()=>{"use strict";ie();_e();ut=(e,t,r="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${r}(uniforms.clip_min)), ${t}(${r}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${r}(uniforms.alpha) * value + ${r}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${r}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},dt=(e,t)=>{e.activation==="Clip"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation==="HardSigmoid"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation==="LeakyRelu"&&t.push({type:1,data:e.alpha})},lt=(e,t)=>{e.activation==="Clip"?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):e.activation==="HardSigmoid"?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):e.activation==="LeakyRelu"&&t.push({name:"alpha",type:"f32"})},tn=e=>{let t=e?.activation||"";if(t==="HardSigmoid"){let[r,o]=e?.activation_params||[.2,.5];return{activation:t,alpha:r,beta:o}}else if(t==="Clip"){let[r,o]=e?.activation_params||[Fr,qr];return{activation:t,clipMax:o,clipMin:r}}else if(t==="LeakyRelu"){let[r]=e?.activation_params||[.01];return{activation:t,alpha:r}}return{activation:t}}});var Ze,rn,nn=q(()=>{"use strict";Ze=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},rn=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `});var on,qn=q(()=>{"use strict";on=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var xl,Sl,gr,ts,Cl,yr,Il,an,br=q(()=>{"use strict";ie();_e();be();Ot();nn();xl=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,Sl=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,gr=(e,t,r="f32",o,n=!1,s=32,u=!1,l=32)=>{let a=t[1]*e[1],p=t[0]*e[0],m=n?a:s,f=n?s:a,b=m/t[0],_=s/t[1];if(!((n&&b===4&&e[1]===4||!n&&(b===3||b===4))&&m%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${n} is true, innerElementSize ${b} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${b} must be 3 or 4.\n  tileAWidth ${m} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${b}<${r}>, ${m/b}>, ${f}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${p/e[0]}>, ${s}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${b};\nconst tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${u?"0":"i32(globalId.z)"};\n  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${a};\n\n  let num_tiles = ${u?`${Math.ceil(l/s)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n  var kStart = ${u?`i32(globalId.z) * ${l}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${_};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${xl(n,o)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${b===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${Sl(n,b)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},ts=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,Cl=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",yr=(e,t,r="f32",o,n=!1,s=32,u=!1,l=32,a=!1)=>{let p=e[1]*t[1],m=e[0]*t[0],f=n?p:s,b=n?s:p;if(!(b%t[1]===0&&f%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${b} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${f} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let _=b/t[1],y=f/t[0],$=s/t[1],I=a?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${p};\n    let globalColStart = i32(workgroupId.x) * ${m};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${b}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${f}; inputCol = inputCol + ${t[0]}) {\n          ${ts(n,o)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${m}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${o?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${p};\n\nlet tileRowA = i32(localId.y) * ${_};\nlet tileColA = i32(localId.x) * ${y};\nlet tileRowB = i32(localId.y) * ${$};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${y}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${ts(n,o)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${$}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${o?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Cl(n)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${f}>, ${b}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${m}>, ${s}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${u?"0":"i32(globalId.z)"};\n    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n    let num_tiles = ${u?`${Math.ceil(l/s)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n    var kStart = ${u?`i32(globalId.z) * ${l}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${I}\n  }\n`},Il=(e,t,r,o,n,s=!1)=>{let[u,l,a]=n,[p,m,f,b]=o,_=jt(u,a),y=jt(l,a),$=Pe(o[0].type.tensor),I=()=>{let A=m.rank,T=p.rank,D=`var aIndices: ${m.type.indices};`;for(let U=A-2-1,V=T-1;U>=0;U--,V--)D+=`\naIndices[${U}] = ${T>1?`batchIndices[${V}]`:"batchIndices"};`;return _.forEach(U=>{D+=`\naIndices[${U}] = 0;`}),D+=`\naIndices[${A-2}] = u32(row);\n                   aIndices[${A-1}] = u32(colIn);`,D},C=()=>{let A=f.rank,T=p.rank,D=`var bIndices: ${f.type.indices};`;for(let U=A-2-1,V=T-1;U>=0;U--,V--)D+=`\nbIndices[${U}] = ${T>1?`batchIndices[${V}]`:"batchIndices"};`;return y.forEach(U=>{D+=`\nbIndices[${U}] = 0;`}),D+=`\nbIndices[${A-2}] = u32(row);\n                   bIndices[${A-1}] = u32(colIn);`,D};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${Ze(e,$)} {\n      var value = ${Ze(e,$)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        ${I()}\n        value = ${m.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${Ze(e,$)} {\n      var value = ${Ze(e,$)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        ${C()}\n        value = ${f.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ze(e,$)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${s?"bias[colIn]":`${Ze(e,$)}(bias[row])`};`:""}\n        ${r}\n        ${b.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},an=(e,t,r,o,n=!1)=>{let s=e[0].dims,u=e[1].dims,l=s.slice(0,-2),a=u.slice(0,-2),p=o?o.slice(0,-2):r.slice(0,-2),m=z.size(p),f=s[s.length-2],b=s[s.length-1],_=u[u.length-1],y=b%4===0&&_%4===0,$=f<=8?[4,1,1]:[4,4,1],I=[8,8,1],C=[Math.ceil(_/I[0]/$[0]),Math.ceil(f/I[1]/$[1]),Math.ceil(m/I[2]/$[2])],v=y?4:1,A=[...l,f,b/v],T=A.length,D=[...a,b,_/v],U=D.length,V=[m,f,_/v],H=[{type:6,data:f},{type:6,data:_},{type:6,data:b}];dt(t,H),H.push(...j(p,A,D));let R=["rank","rank"],L=e.length>2;L&&(H.push(...j(e[2].dims)),R.push("rank")),H.push(...j(V));let pe=Ie=>{let we=p.length,ne=jr("batchDims",e[0].dataType,we,1),ze=Pe(e[0].dataType),Q=M("a",e[0].dataType,T,v),xe=M("b",e[1].dataType,U,v),me=F("result",e[0].dataType,V.length,v),ue=[Q,xe];if(L){let G=n?v:1;ue.push(M("bias",e[2].dataType,e[2].dims.length,G))}let se=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];lt(t,se);let he=Pe(me.type.tensor),Ae=ut(t,me.type.value,he),He=Il(v,L,Ae,[ne,Q,xe,me],[l,a,p],n);return`\n  ${Ie.registerUniforms(se).registerInternalVariables(ne).declareVariables(...ue,me)}\n  ${He}\n  ${y?gr($,I,ze,ne):yr($,I,ze,ne)}\n                   `};return{name:"MatMul",shaderCache:{hint:`${$};${t.activation};${y};${n}`,inputDependencies:R},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:C[0],y:C[1],z:C[2]},programUniforms:H}),getShaderSource:pe}}});var Al,rs,ns=q(()=>{"use strict";ie();Pt();be();Ot();nn();qn();br();Al=(e,t,r,o,n=!1,s,u=4,l=4,a=4,p="f32")=>{let m=L=>{switch(L){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${p}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${L} is not supported.`)}},f=L=>{switch(L){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${L} is not supported.`)}},b=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,_=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,y=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",$=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",I=e?"row":"col",C=e?"col":"row",v=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${I} / outWidth;\n    let outCol = ${I} % outWidth;\n\n    let WRow = ${C} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${C} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${C} % inChannels;\n    var resData = ${Ze(u,p)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${$}) {\n      ${b}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${m(u)}\n    }\n    return resData;`,A=e?t&&o?`\n    let col = colIn * ${u};\n    ${v}`:`\n    let col = colIn * ${u};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${v}\n    }\n    return ${Ze(u,p)}(0.0);`:o&&r?`\n    let col = colIn * ${u};\n    ${v}`:`\n    let col = colIn * ${u};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${v}\n    }\n    return ${Ze(u,p)}(0.0);`,T=`${f(l)}`,D=Ze(a,p),U=e?Ze(u,p):Ze(l,p),V=e?Ze(l,p):Ze(u,p),H=ut(s,D,p);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${U} {\n      ${e?A:T}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${V} {\n      ${e?T:A}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${D}) {\n      let col = colIn * ${a};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${_}\n      ${rn(n)}\n      ${H}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},rs=(e,t,r,o,n,s,u,l)=>{let a=t.format==="NHWC",p=a?e[0].dims[3]:e[0].dims[1],m=r[0],f=a?r[2]:r[3],b=a?r[1]:r[2],_=a?r[3]:r[1],y=a&&(p%4===0||p%3===0)&&_%4===0,$=a?_:f*b,I=a?f*b:_,C=[8,8,1],v=o<=8?[4,1,1]:[4,4,1],A=[Math.ceil($/C[0]/v[0]),Math.ceil(I/C[1]/v[1]),Math.ceil(m/C[2]/v[2])];De("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${A}`);let T=y?a&&p%4!==0?3:4:1,D=C[1]*v[1],U=C[0]*v[0],V=Math.max(C[0]*T,C[1]),H=o%D===0,R=n%U===0,L=s%V===0,pe=y?[T,4,4]:[1,1,1],Ie=[{type:6,data:o},{type:6,data:n},{type:6,data:s},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];dt(t,Ie),Ie.push(...j(e[0].dims,e[1].dims));let we=["rank","rank"];u&&(Ie.push(...j(e[2].dims)),we.push("rank")),Ie.push(...j(r));let ne=ze=>{let Q=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];lt(t,Q);let xe=y?4:1,me=Pe(e[0].dataType),ue=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${y?`vec4<${me}>`:me}) {\n        result[flatIndex] = ${y?`vec4<${me}>`:me}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${y?`vec4<${me}>`:me}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${y?"/ 4":""}, value);\n      }`,se=M("x",e[0].dataType,e[0].dims.length,T===3?1:T),he=M("w",e[1].dataType,e[1].dims.length,xe),Ae=[se,he],He=F("result",e[0].dataType,r.length,xe);if(u){let G=M("bias",e[2].dataType,e[2].dims.length,xe);Ae.push(G),ue+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${y?`vec4<${me}>`:me} {\n          return bias[coords.${a?"w":"y"}${y?"/ 4":""}];\n        }`}return`\n        ${on("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${ze.registerUniforms(Q).declareVariables(...Ae,He)}\n        ${ue}\n        ${Al(a,H,R,L,u,t,pe[0],pe[1],pe[2],me)}\n        ${y?gr(v,C,me,void 0,!a,V):yr(v,C,me,void 0,!a,V,!1,void 0,l)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${T};${y};${H};${R};${L};${D};${U};${V}`,inputDependencies:we},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:A[0],y:A[1],z:A[2]},programUniforms:Ie}),getShaderSource:ne}}});var Kn,os,as=q(()=>{"use strict";ie();_e();be();jn();Ot();Kn=(e,t,r)=>{let o=e.length>2,n=o?"value += b[output_channel];":"",s=e[0].dims,u=e[1].dims,l=u[0]/t.group,a=t.format==="NHWC",p=sn(s,u,t.dilations,t.pads,t.strides,a),m=z.size(p),f=[{type:12,data:m},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:l}];dt(t,f),f.push(...j(s,u,p));let b=["rank","rank"];o&&(f.push(...j(e[2].dims)),b.push("rank")),f.push(...j(p));let _=y=>{let $=F("output",e[0].dataType,p.length),I=Pe($.type.tensor),C=ut(t,$.type.value,I),v=M("x",e[0].dataType,s.length),A=M("w",e[1].dataType,u.length),T=[v,A];o&&T.push(M("b",e[2].dataType,e[2].dims));let D=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];return lt(t,D),`\n  ${y.registerUniforms(D).declareVariables(...T,$)}\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let outputIndices = ${$.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${a?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${a?1:2}], outputIndices[${a?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel / uniforms.output_channels_per_group;\n\n    var value: ${$.type.value} = ${$.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[${a?1:2}]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[${a?2:3}]) {\n            continue;\n          }\n\n          let xVal = ${a?v.get("batch","xHeight","xWidth","input_channel"):v.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${A.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${n}\n    ${C}\n    ${$.setByOffset("global_idx","value")}\n  }`};return{name:"GroupedConv",shaderCache:{hint:t.cacheKey,inputDependencies:b},getRunData:()=>({outputs:[{dims:r?r(p):p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:f}),getShaderSource:_}},os=(e,t,r)=>{let o=e.length>2,n=Me(r[3]),s=Me(r[2]),u=z.size(r)/n/s,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/n],a=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/n],p=[r[0],r[1],r[2],r[3]/n],m=[{type:12,data:u},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];dt(t,m),m.push(...j(l,a,p));let f=(s-1)*t.strides[1]+a[1],b=_=>{let y=F("output",e[0].dataType,p.length,n),$=Pe(y.type.tensor),I=ut(t,y.type.value,$),C=M("x",e[0].dataType,l.length,n),v=M("w",e[1].dataType,a.length,n),A=[C,v];o&&A.push(M("b",e[2].dataType,e[2].dims,n));let T=o?"value += b[output_channel];":"",D=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return lt(t,D),`\n  ${_.registerUniforms(D).declareVariables(...A,y)}\n  ${_.mainStart()}\n    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${s}u;\n    let col = (index1 % width1) * ${s}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${C.type.value}, ${f}>;\n    var values: array<${y.type.value}, ${s}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w\'s height/width.\n    for (var w_height: u32 = 0u; w_height < ${a[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${f}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${C.get("batch","u32(x_height)","u32(x_width)","input_channel")};\n          } else {\n            x_vals[i] = ${C.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${a[1]}; w_width++) {\n          let w_val = ${v.get("w_height","w_width","0","output_channel")};\n          for (var i = 0u; i < ${s}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${s}u; i++) {\n      var value = values[i];\n      ${T}\n      ${I}\n      ${y.set("batch","row","col + i","output_channel","value")};\n    }\n  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${n};${s};${f};${a[0]};${a[1]}`,inputDependencies:o?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:m}),getShaderSource:b}}});var Yn,Tl,is,Zn=q(()=>{"use strict";ie();_e();br();be();Ot();Yn=(e,t,r,o,n=!1)=>{let s=e[0].dims,u=e[1].dims,l=s[s.length-2],a=u[u.length-1],p=s[s.length-1],m=Me(a),f=Me(p),b=Me(l),_=z.size(r)/m/b,y=e.length>2,$=o?o.slice(0,-2):r.slice(0,-2),C=[z.size($),l,a],v=[{type:12,data:_},{type:12,data:l},{type:12,data:a},{type:12,data:p}];dt(t,v),v.push(...j($,s,u)),y&&v.push(...j(e[2].dims)),v.push(...j(C));let A=T=>{let D=jr("batch_dims",e[0].dataType,$.length),U=M("a",e[0].dataType,s.length,f),V=M("b",e[1].dataType,u.length,m),H=F("output",e[0].dataType,C.length,m),R=Pe(H.type.tensor),L=ut(t,H.type.value,R),pe=[U,V],Ie="";if(y){let se=n?m:1;pe.push(M("bias",e[2].dataType,e[2].dims.length,se)),Ie=`${n?`value += bias[col / ${se}];`:`value += ${H.type.value}(bias[row + i]);`}`}let we=s.slice(0,-2),ne=u.slice(0,-2),ze=jt(we,$),Q=jt(ne,$),xe=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];lt(t,xe);let me=(se,he)=>{let Ae=se.rank,He=se.name;if(Ae===2)return`var ${He}_indices = ${se.type.indices}(0u, 0u);`;let G=D.rank,J=`var ${He}_indices: ${se.type.indices};`;for(let Se=Ae-2-1,Qe=G-1;Se>=0;Se--,Qe--)J+=`\n${He}_indices[${Se}] = ${G>1?`batch_indices[${Qe}]`:"batch_indices"};`;return he.forEach(Se=>{J+=`\n${He}_indices[${Se}] = 0;`}),J+=`${He}_indices[${Ae-2}] = 0u;\n                     ${He}_indices[${Ae-1}] = 0u;`,J},ue=()=>{let se=`var a_data: ${U.type.value};`;for(let he=0;he<f;he++)se+=`\n              let b_data${he} = b[(b_offset + (k + ${he}) * uniforms.N + col) / ${m}];`;for(let he=0;he<b;he++){se+=`a_data = a[(a_offset + (row + ${he}) * uniforms.K + k) / ${f}];`;for(let Ae=0;Ae<f;Ae++)se+=`\n            values[${he}] = fma(${V.type.value}(a_data${f===1?"":`[${Ae}]`}), b_data${Ae}, values[${he}]);\n`}return se};return`\n  ${T.registerUniforms(xe).registerInternalVariables(D).declareVariables(...pe,H)}\n  ${T.mainStart()}\n    ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let col = (global_idx % (uniforms.N / ${m})) * ${m};\n    var index1 = global_idx / (uniforms.N / ${m});\n    let stride1 = uniforms.M / ${b};\n    let row = (index1 % stride1) * ${b};\n    let batch = index1 / stride1;\n\n    ${r.length===2?"":`let batch_indices = ${D.offsetToIndices("batch")};`}\n    ${me(U,ze)}\n    let a_offset = ${U.indicesToOffset("a_indices")};\n    ${me(V,Q)}\n    let b_offset = ${V.indicesToOffset("b_indices")};\n    var values: array<${H.type.value}, ${b}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${f}) {\n      ${ue()}\n    }\n    for (var i = 0u; i < ${b}u; i++) {\n      var value = values[i];\n      ${Ie}\n      ${L}\n      let cur_indices = ${H.type.indices}(batch, row + i, col);\n      let offset = ${H.indicesToOffset("cur_indices")};\n      ${H.setByOffset(`offset / ${m}`,"value")};\n    }\n  }\n  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${m};${f};${b};${n}`,inputDependencies:y?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:v}),getShaderSource:A}},Tl=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},is=e=>{Tl(e.inputs);let t=mt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");let r=t[t.length-1],o=e.inputs[0].dims[e.inputs[0].dims.length-1];r<8&&o<8?e.compute(Yn(e.inputs,{activation:""},t)):e.compute(an(e.inputs,{activation:""},t))}});var sn,Qn,El,ss,Xn,Pl,Ol,Jn,jn=q(()=>{"use strict";_e();ns();br();as();Ot();Zn();Yt();sn=(e,t,r,o,n,s)=>{let u=e[0],l=e.slice(s?1:2,s?3:4),a=l.length,p=t[0],f=t.slice(2).map((y,$)=>y+(y-1)*(r[$]-1)),_=l.map((y,$)=>y+o[$]+o[$+a]).map((y,$)=>Math.floor((y-f[$]+n[$])/n[$]));return _.splice(0,0,u),_.splice(s?3:1,0,p),_},Qn=[2,3,1,0],El=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},ss=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let o=e.pads.slice();zt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let n=Object.assign({},e);return Object.assign(n,{kernelShape:r,pads:o}),n},Xn=e=>{let t=tn(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],n=e.dilations,s=e.group,u=e.kernel_shape,l=e.pads,a=e.strides,p=e.w_is_const();return{autoPad:o,format:r,dilations:n,group:s,kernelShape:u,pads:l,strides:a,wIsConst:p,...t,cacheKey:`${e.format};${t.activation};`}},Pl=(e,t,r)=>{let o=ss(r,t),n=r.format==="NHWC";if(r.group!==1){if(!e.adapterInfo.isArchitecture("ampere")&&n&&t[1].dims[0]===r.group&&t[1].dims[1]===1&&r.dilations[0]===1&&r.dilations[1]===1){let V=sn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,n),H=e.kernelCustomData.wT??e.compute(ot(t[1],Qn),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=H);let R=[t[0],H];t.length===3&&R.push(t[2]),e.compute(os(R,o,V),{inputs:R})}else e.compute(Kn(t,o));return}let s=t.length===3,u=t[0].dims[n?1:2],l=t[0].dims[n?2:3],a=t[0].dims[n?3:1],p=t[1].dims[2],m=t[1].dims[3],f=sn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,n),b=f[n?1:2],_=f[n?2:3],y=f[n?3:1],$=n&&p===u&&m===l&&r.pads[0]===0&&r.pads[1]===0;if($||p===1&&m===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let U=f[0],V,H,R,L=[];if(n){let we=e.kernelCustomData.wT??e.compute(ot(t[1],Qn),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=we),$){let ne=u*l*a;V=t[0].reshape([1,U,ne]),H=we.reshape([1,ne,y]),R=[1,U,y]}else V=t[0].reshape([U,u*l,a]),H=we.reshape([1,a,y]),R=[U,b*_,y];L.push(V),L.push(H)}else V=t[0].reshape([U,a,u*l]),H=t[1].reshape([1,y,a]),R=[U,y,b*_],L.push(H),L.push(V);s&&L.push(t[2]);let pe=R[2],Ie=L[0].dims[L[0].dims.length-1];pe<8&&Ie<8?e.compute(Yn(L,o,f,R,n),{inputs:L}):e.compute(an(L,o,f,R,n),{inputs:L});return}let I=!0,C=e.kernelCustomData.wT??e.compute(ot(t[1],Qn),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=C);let v=[t[0],C];s&&v.push(t[2]);let A=n?b*_:y,T=n?y:b*_,D=p*m*a;e.compute(rs(v,o,f,A,T,D,s,I),{inputs:v})},Ol=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let n=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),u=[1].concat(t.dilations),l=[1].concat(t.kernelShape),a=ss({...t,pads:n,strides:s,dilations:u,kernelShape:l},o);e.compute(Kn(o,a,p=>r?[p[0],p[2],p[3]]:[]))},Jn=(e,t)=>{El(e.inputs,t),e.inputs[0].dims.length===3?Ol(e,t):Pl(e,e.inputs,t)}});var kl,us,ds=q(()=>{"use strict";ie();Pt();be();Ot();nn();qn();br();kl=(e,t=!1,r,o,n=4)=>{let s=C=>{switch(C){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];\n            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];\n            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];\n            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];\n            return ${o}(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${C} is not supported.`)}},u=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,l=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,a=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",p=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",m=e?"row":"col",f=e?"col":"row",b=`\n      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      let outRow = ${m} / outWidth;\n      let outCol = ${m} % outWidth;\n\n      let WRow = ${f} / (uniforms.filter_dims[1] * inChannels);\n      let WCol = ${f} / inChannels % uniforms.filter_dims[1];\n      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(${a}) || fract(xR) > 0.0) {\n        return ${o}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${p}) || fract(xC) > 0.0) {\n        return ${o}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${f} % inChannels;\n      ${u}\n      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${n}];`,_=e?`\n      let col = colIn * ${n};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n        ${b}\n      }\n      return ${o}(0.0);`:`\n      let col = colIn * ${n};\n      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n        ${b}\n      }\n      return ${o}(0.0);`,y=`\n      let col = colIn * ${n};\n      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};\n      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);\n      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];\n      if (${e?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${s(n)}\n      }\n      return ${o}(0.0);\n      `,$=ut(r,o);return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${o} {\n    ${e?_:y}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${o} {\n    ${e?y:_}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${o}) {\n    let col = colIn * ${n};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n      var value = valueInput;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${l}\n      ${rn(t)}\n      ${$}\n      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${n}] = value;\n    }\n  }`},us=(e,t,r,o,n,s,u,l)=>{let a=t.format==="NHWC",p=a?e[0].dims[3]:e[0].dims[1],m=r[0],f=a?r[2]:r[3],b=a?r[1]:r[2],_=a?r[3]:r[1],y=a?p%4===0&&_%4===0:f%4===0&&_%4===0,$=a?_:f*b,I=a?f*b:_,C=y?[8,8,1]:[$<=4||I<=4?4:16,$>4&&I<=4?4:16,1],v=y?[4,4,1]:[$<=4?1:4,$>4&&I<=4?1:4,1],A=[Math.ceil($/C[0]/v[0]),Math.ceil(I/C[1]/v[1]),Math.ceil(m/C[2]/v[2])];De("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${A}`);let T=y?4:1,D=Math.max(C[0]*T,C[1]),U=y?4:1,V=[t.kernelShape[a?1:2],t.kernelShape[a?2:3]],H=[V[0]+(t.dilations[0]<=1?0:(V[0]-1)*(t.dilations[0]-1)),V[1]+(t.dilations[1]<=1?0:(V[1]-1)*(t.dilations[1]-1))],R=[H[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),H[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],L=[{type:6,data:o},{type:6,data:n},{type:6,data:s},{type:6,data:t.strides},{type:6,data:t.dilations},{type:6,data:V},{type:6,data:R}];dt(t,L),L.push(...j(e[0].dims,e[1].dims));let pe=["rank","rank"];u&&(L.push(...j(e[2].dims)),pe.push("rank")),L.push(...j(r));let Ie=we=>{let ne=M("x",e[0].dataType,e[0].dims.length,U),ze=M("w",e[1].dataType,e[1].dims.length,1),Q=F("result",e[0].dataType,r.length,U),xe=[ne,ze],me="";if(u){let he=M("bias",e[2].dataType,e[2].dims.length,U);xe.push(he),me+=`\n          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${he.type.value} {\n            return bias[coords.${a?"w":"y"}${y?"/ 4":""}];\n          }`}let ue=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:V.length},{name:"pads",type:"i32",length:R.length}];lt(t,ue);let se=Pe(e[0].dataType,1);if(se!=="f16"&&se!=="f32")throw new Error(`elemType ${se} is not supported.`);return`\n        ${on("uniforms.result_strides")}\n        ${we.registerUniforms(ue).declareVariables(...xe,Q)};\n        ${me}\n        ${kl(a,u,t,ne.type.value,T)}\n        ${y?gr(v,C,se,void 0,!a,D):yr(v,C,se,void 0,!a,D,!1,void 0,l)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${t.cacheKey};${v};${C};${y}`,inputDependencies:pe},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:A[0],y:A[1],z:A[2]},programUniforms:L}),getShaderSource:Ie}}});var Rl,eo,ls=q(()=>{"use strict";ie();Pt();_e();be();Rl=(e,t,r,o,n,s=!1,u,l,a=!1)=>{let p=a?1:2,m=a?2:3,f=a?3:1,b=s?2:1,_=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${s?`vec4<${u}>`:u}) {\n    result[flatIndex] = ${s?`vec4<${u}>`:u}(value);\n  }`;o&&(_+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${s?`vec4<${u}>`:u} {\n      return bias[coords.${a?"w":"y"}${s?"/ 4":""}];\n    }`);let y=s?4:1,$=M("W",t[1].dataType,t[1].dims.length,y),I=M("Dy",t[0].dataType,t[0].dims.length,y),C=[I,$];o&&C.push(M("bias",t[2].dataType,[r[f]].length,y));let v=F("result",t[0].dataType,r.length,y),A=`{\n        let batch: u32 = ${n?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];\n        let r = ${n?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];\n        let c = ${n?"global_id.y":"workgroup_id.y"} * ${b};\n        let d1: u32 = ${n?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${u}>, ${b}>;\n        for (var i = 0; i < ${b}; i++) {\n          dotProd[i] = vec4<${u}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {\n          var dyR = (${u}(dyCorner.x) + ${u}(wR)) / ${u}(uniforms.strides.x);\n          let wRPerm = uniforms.filter_dims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${u}(uniforms.Dy_shape[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {\n            let dyC = (${u}(dyCorner.y) + ${u}(wC)) / ${u}(uniforms.strides.y);\n            let dyC2 = (${u}(dyCorner.y) + 1.0 + ${u}(wC)) / ${u}(uniforms.strides.y);\n            let wCPerm = uniforms.filter_dims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${u}(uniforms.Dy_shape[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${u}(uniforms.Dy_shape[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = uniforms.Dy_shape[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${I.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${u}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${I.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${u}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = uniforms.Dy_shape[${f}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${I.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${u}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = uniforms.Dy_shape[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${I.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${u}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${b}; i = i + 1) {\n          let value = dotProd[i] + ${o?"bias[c+i]":`vec4<${u}>(0.0)`};\n          ${v.set("batch","r","c + i","d1","value")};\n        }\n      }`,T=`\n          let outputIndices = ${v.offsetToIndices("global_idx")};\n          let batch = ${v.indicesGet("outputIndices",0)};\n          let d1 = ${v.indicesGet("outputIndices",f)};\n          let r = ${v.indicesGet("outputIndices",p)};\n          let c = ${v.indicesGet("outputIndices",m)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / uniforms.output_channels_per_group;\n          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = ${u}(0.0);\n          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n            if (wR % uniforms.dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${u}(dyRCorner) + ${u}(wR)) / ${u}(uniforms.strides[0]);\n            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n            if (dyR < 0.0 || dyR >= ${u}(uniforms.Dy_shape[${p}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n              if (wC % uniforms.dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${u}(dyCCorner) + ${u}(wC)) / ${u}(uniforms.strides.y);\n              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n              if (dyC < 0.0 || dyC >= ${u}(uniforms.Dy_shape[${m}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * uniforms.input_channels_per_group;\n              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {\n                let xValue = ${a?I.get("batch","idyR","idyC","inputChannel"):I.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${$.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${o?"bias[d1]":`${u}(0.0)`};\n          ${v.setByOffset("global_idx","value")};\n        `;return`\n  ${e.registerUniforms(l).declareVariables(...C,v)}\n  ${_}\n\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};\n  ${s?A:T}}`},eo=(e,t,r)=>{let o=e.length>2,n=t.outputShape,s=z.size(n),u=[Math.ceil(s/64),1,1];De("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let l=t.format==="NHWC",a=["rank","rank"],p=[t.strides[0],t.strides[1]],m=[t.kernelShape[l?1:2],t.kernelShape[l?2:3]],f=[t.dilations[0],t.dilations[1]],b=[m[0]+(t.dilations[0]<=1?0:(t.kernelShape[l?1:2]-1)*(t.dilations[0]-1)),m[1]+(t.dilations[1]<=1?0:(t.kernelShape[l?2:3]-1)*(t.dilations[1]-1))],_=[b[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),b[1]-1-Math.floor(t.pads[1]+t.pads[3])/2],y=!1,$=t.group,I=e[1].dims,C=I[0]/$,v=I[1],A=[{type:6,data:s},{type:12,data:p},{type:12,data:m},{type:12,data:f},{type:12,data:b},{type:6,data:_},{type:12,data:C},{type:12,data:v},...j(e[0].dims,e[1].dims)];o&&(A.push(...j(e[2].dims)),a.push("rank")),A.push(...j(n));let T=u[1]===1&&u[2]===1,D=U=>{let V=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:p.length},{name:"filter_dims",type:"u32",length:m.length},{name:"dilations",type:"u32",length:m.length},{name:"effective_filter_dims",type:"u32",length:b.length},{name:"pads",type:"i32",length:_.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],H=Pe(e[0].dataType);return`${Rl(U,e,n,o,T,y,H,V,l)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};`,inputDependencies:a},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],programUniforms:A}),getShaderSource:D}}});var Bl,Dl,Ml,cs,ps,zl,Ul,Vl,Nl,ms,fs=q(()=>{"use strict";ds();ls();Ot();Yt();Bl=(e,t,r,o,n,s)=>(e-1)*t+r+(o-1)*n+1-s,Dl=(e,t,r,o,n)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=s,r[n]=e-s):t==="SAME_LOWER"&&(r[o]=e-s,r[n]=s)},Ml=(e,t,r,o,n,s,u,l,a,p)=>{let m=e.length-2,f=p.length===0;if(a.length===0)for(let y=0;y<m;++y)a.push(0);let b=e[0],_=t[l?3:1]*n;for(let y=0,$=e.length-m-(l?1:0);y<m;++y,++$){let I=e[$],C=f?I*u[y]:p[y],v=Bl(I,u[y],s[y],t[$],r[y],C);Dl(v,o,s,y,y+m),f&&p.push(u[y]*(I-1)+a[y]+(t[$]-1)*r[y]+1-s[y]-s[y+m])}p.splice(0,0,b),p.splice(l?3:1,0,_)},cs=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((f,b)=>f*b,1)===0){r.length=0;for(let f=2;f<t[1].dims.length;++f)r.push(t[1].dims[f])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let n=e.pads.slice(),s=e.outputShape.slice(),u=e.outputPadding.slice(),l=t[0].dims,a=e.dilations.slice();if(a.reduce((f,b)=>f+b,0)===0){let f=t[0].dims.length-2;a=new Array(f).fill(1)}let p=e.strides.slice();if(p.reduce((f,b)=>f+b,0)===0){let f=t[0].dims.length-2;p=new Array(f).fill(1)}Ml(l,r,a,e.autoPad,e.group,n,p,o,u,s);let m=Object.assign({},e);return Object.assign(m,{kernelShape:r,pads:n,outputPadding:u,outputShape:s,dilations:a,strides:p}),m},ps=e=>{let t=tn(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],n=e.dilations,s=e.group,u=e.kernelShape,l=e.pads,a=e.strides,p=e.wIsConst(),m=e.outputPadding,f=e.outputShape;return{autoPad:o,format:r,dilations:n,group:s,kernelShape:u,outputPadding:m,outputShape:f,pads:l,strides:a,wIsConst:p,...t,cacheKey:`${e.format};${t.activation};`}},zl=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==n))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((m,f)=>m+f,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((m,f)=>m+f,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((m,f)=>m+f,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((m,f)=>m+f,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Ul=[2,3,1,0],Vl=(e,t,r)=>{let o=cs(r,t),n=r.format==="NHWC",s=o.outputShape,u=s[n?3:1],l=t[0].dims[n?3:1];if(o.group!==1||u===1&&l===1){e.compute(eo(t,o));return}let a=s[n?1:2],p=s[n?2:3],m=t[1].dims[2],f=t[1].dims[3],b=n?a*p:u,_=n?u:a*p,y=m*f*l,$=!0,I=e.kernelCustomData.wT??e.compute(ot(t[1],Ul),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let C=[t[0],I],v=t.length===3;v&&(!n&&t[2].dims.length===1?C.push(t[2].reshape([t[2].dims[0],1,1])):C.push(t[2])),e.compute(us(C,o,s,b,_,y,v,$),{inputs:C})},Nl=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];o.length===3&&o.push(e.inputs[2]);let n=t.kernelShape;(n.length===0||n[0]===0)&&(n=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let l=t.pads;l.length===0&&(l=[0,0]),l=[0,l[0],0,l[1]],u=[1].concat(u),s=[1].concat(s),n=[1].concat(n);let a=cs({...t,pads:l,strides:u,dilations:s,kernelShape:n},o);e.compute(eo(o,a,p=>r?[p[0],p[2],p[3]]:[p[0],p[1],p[3]]))},ms=(e,t)=>{zl(e.inputs,t),e.inputs[0].dims.length===3?Nl(e,t):Vl(e,e.inputs,t)}});var Wl,hs,gs,ys=q(()=>{"use strict";ie();_e();je();be();Wl=(e,t,r,o)=>{let n=z.size(t),s=t.length,u=M("input",e,s),l=F("output",e,s),a=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),p=z.normalizeAxis(a,s),m=f=>{let b=` i32(${u.indicesGet("inputIndices","uniforms.axis")}) `,_=re("uniforms.input_shape","uniforms.axis",s),y=o.reverse?b+(o.exclusive?" + 1":""):"0",$=o.reverse?_:b+(o.exclusive?"":" + 1");return`\n                ${f.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(u,l)}\n                ${f.mainStart()}\n                  ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${l.offsetToIndices("global_idx")};\n                  var sum = ${l.type.value}(0);\n                  let first : i32 = ${y};\n                  let last : i32 = ${$};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${u.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${u.getByIndices("inputIndices")};\n                  }\n                  ${l.setByOffset("global_idx","sum")};\n                }`};return{name:"CumSum",shaderCache:{hint:o.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:[{type:12,data:n},{type:6,data:p},...j(t,t)]}),getShaderSource:m}},hs=(e,t)=>{let r=e.inputs[0].dims,o=e.inputs[0].dataType,n=e.inputs[1];e.compute(Wl(o,r,n,t),{inputs:[0]})},gs=e=>{let t=e.exclusive===1,r=e.reverse===1;return $e({exclusive:t,reverse:r})}});var to,un,bs,Gl,Hl,ro,no,ws,Ll,vs,$s,_s=q(()=>{"use strict";ie();_e();je();be();to="[a-zA-Z]|\\\\.\\\\.\\\\.",un="("+to+")+",bs="^"+un+"$",Gl="("+un+",)*"+un,Hl="^"+Gl+"$",ro=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},no=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,n]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(Hl)))throw new Error("Invalid LHS term");if(o.split(",").forEach((l,a)=>{let p=t[a].dims.slice();if(!l.match(RegExp(bs)))throw new Error("Invalid LHS term");let m=this.processTerm(l,!0,p,a);this.lhs.push(m)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([l,a])=>a.count===1||l==="...").map(([l])=>l).join("");else if(!n.match(RegExp(un)))throw new Error("Invalid RHS");n.match(RegExp(to,"g"))?.forEach(l=>{if(l==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let a=this.symbolToInfo.get(l);if(a===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(a.dimValue)}}),this.rhs=this.processTerm(n,!1,this.outputDims)}addSymbol(t,r,o){let n=this.symbolToInfo.get(t);if(n!==void 0){if(n.dimValue!==r&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(o)}else n={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,n)}processTerm(t,r,o,n=-1){let s=o.length,u=!1,l=[],a=0;if(!t.match(RegExp(bs))&&!r&&t!=="")throw new Error("Invalid LHS term");let p=t.match(RegExp(to,"g")),m=new ro(n);return p?.forEach((f,b)=>{if(f==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let _=s-p.length+1;if(_<0)throw new Error("Ellipsis out of bounds");if(l=o.slice(a,a+_),this.hasEllipsis){if(this.ellipsisDims.length!==l.length||this.ellipsisDims.toString()!==l.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=l;else throw new Error("Ellipsis must be specified in the LHS");for(let y=0;y<l.length;y++){let $=String.fromCharCode("0".charCodeAt(0)+y);m.addSymbol($,b+y),this.addSymbol($,o[a++],n)}}else m.addSymbol(f,b+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(f,o[a++],n)}),m}},ws=e=>e+"_max",Ll=(e,t,r,o)=>{let s=e.map(m=>m.length).map((m,f)=>M(`input${f}`,t,m)),u=z.size(o),l=F("output",t,o.length),a=[...r.symbolToInfo.keys()].filter(m=>!r.rhs.symbolToIndices.has(m)),p=m=>{let f=[],b="var prod = 1.0;",_="var sum = 0.0;",y="sum += prod;",$=[],I=[],C=[],v=[],A=r.symbolToInfo.size===r.rhs.symbolToIndices.size;r.symbolToInfo.forEach((D,U)=>{if(r.rhs.symbolToIndices.has(U)){let V=r.rhs.symbolToIndices.get(U)?.[0];V!==void 0&&r.lhs.forEach((H,R)=>{if(D.inputIndices.includes(R)){let L=H.symbolToIndices.get(U);if(L===void 0)throw new Error("Invalid symbol error");L.forEach(pe=>{f.push(`${s[R].indicesSet(`input${R}Indices`,pe,l.indicesGet("outputIndices",V))}`)})}})}else r.lhs.forEach((V,H)=>{if(D.inputIndices.includes(H)){let R=V.symbolToIndices.get(U);if(R===void 0)throw new Error("Invalid symbol error");R.forEach(L=>{$.push(`${s[H].indicesSet(`input${H}Indices`,L,`${U}`)}`)}),v.push(`prod *= ${s[H].getByIndices(`input${H}Indices`)};`)}}),I.push(`for(var ${U}: u32 = 0; ${U} < uniforms.${ws(U)}; ${U}++) {`),C.push("}")});let T=A?[...f,`let sum = ${s.map((D,U)=>D.getByIndices(`input${U}Indices`)).join(" * ")};`]:[...f,_,...I,...$,b,...v,y,...C];return`\n            ${m.registerUniforms(a.map(D=>({name:`${ws(D)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...s,l)}\n\n            ${m.mainStart()}\n            ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${l.offsetToIndices("global_idx")};\n            ${s.map((D,U)=>`var input${U}Indices: ${s[U].type.indices};`).join(`\n`)}\n            ${T.join(`\n`)};\n            ${l.setByOffset("global_idx","sum")};\n          }`};return{name:"Einsum",shaderCache:{hint:r.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let m=a.filter(b=>r.symbolToInfo.has(b)).map(b=>({type:12,data:r.symbolToInfo.get(b)?.dimValue||0}));m.push({type:12,data:u});let f=e.map((b,_)=>[...j(b)]).reduce((b,_)=>b.concat(_),m);return f.push(...j(o)),{outputs:[{dims:o,dataType:t}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:f}},getShaderSource:p}},vs=(e,t)=>{let r=new no(e.inputs,t.equation),o=r.outputDims,n=e.inputs.map((s,u)=>s.dims);e.compute(Ll(n,e.inputs[0].dataType,r,o))},$s=e=>{let t=e.equation.replace(/\\s+/g,"");return $e({equation:t})}});var Fl,xs,ql,Kl,Ss,Cs=q(()=>{"use strict";ie();_e();be();Fl=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,n=t.length<r.length?0:t.length-r.length;for(;o<r.length&&n<t.length;++o,++n)if(r[o]!==t[n]&&r[o]!==1&&t[n]!==1)throw new Error("Expand requires shape to be broadcastable to input")},xs=(e,t)=>{let r=e.length-t.length,o=[];for(let n=0;n<r;++n)o.push(e[n]);for(let n=0;n<t.length;++n)o.push(t[n]===1?e[n+r]:t[n]);return o},ql=(e,t)=>e.length>t.length?xs(e,t):xs(t,e),Kl=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=ql(t,r),n=e[0].dataType,s=n===9?4:1,u=Math.ceil(z.size(o)/s),l=p=>{let m=M("input",n,t.length,s),f=F("output",n,o.length,s),b;if(n===9){let _=(y,$,I="")=>`\n          let outputIndices${$} = ${f.offsetToIndices(`outputOffset + ${$}u`)};\n          let offset${$} = ${m.broadcastedIndicesToOffset(`outputIndices${$}`,f)};\n          let index${$} = offset${$} / 4u;\n          let component${$} = offset${$} % 4u;\n          ${y}[${$}] = ${I}(${m.getByOffset(`index${$}`)}[component${$}]);\n        `;b=`\n        let outputOffset = global_idx * ${s};\n        var data = vec4<u32>(0);\n        ${_("data",0,"u32")}\n        ${_("data",1,"u32")}\n        ${_("data",2,"u32")}\n        ${_("data",3,"u32")}\n        ${f.setByOffset("global_idx","data")}\n      }`}else b=`\n        let outputIndices = ${f.offsetToIndices("global_idx")};\n        let inputOffset = ${m.broadcastedIndicesToOffset("outputIndices",f)};\n        ${f.setByOffset("global_idx",m.getByOffset("inputOffset"))}\n      }`;return`\n    ${p.registerUniform("vec_size","u32").declareVariables(m,f)}\n    ${p.mainStart()}\n    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${b}`},a=[{type:12,data:u},...j(t,o)];return{name:"Expand",shaderCache:{hint:`${o.length}`,inputDependencies:["rank"]},getShaderSource:l,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:a})}},Ss=e=>{Fl(e.inputs),e.compute(Kl(e.inputs),{inputs:[0]})}});var jl,Is,As=q(()=>{"use strict";ie();_e();be();en();jl=e=>{let t=e[0].dataType,r=z.size(e[0].dims),o=z.size(e[1].dims),n=o%4===0,s=u=>{let l=M("x",t,[1],4),a=M("bias",t,[1],4),p=F("y",t,[1],4),m=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],f=_=>`\n      let bias${_}_offset: u32 = (global_idx * 4 + ${_}) % uniforms.bias_size;\n      let bias${_} = ${a.getByOffset(`bias${_}_offset / 4`)}[bias${_}_offset % 4];`,b=n?`\n      let bias = ${a.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${f(0)}${f(1)}${f(2)}${f(3)}\n      let bias = ${l.type.value}(bias0, bias1, bias2, bias3);`;return`${u.registerUniforms(m).declareVariables(l,a,p)}\n\n    ${Ln(et(t))}\n\n    ${u.mainStart(Kr)}\n      ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}\n\n      let x = ${l.getByOffset("global_idx")};\n      ${b}\n      let x_in = x + bias;\n      ${p.setByOffset("global_idx",Fn("x_in"))}\n    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${n}`,inputDependencies:["type","type"]},getShaderSource:s,getRunData:u=>({outputs:[{dims:u[0].dims,dataType:u[0].dataType}],programUniforms:[{type:12,data:Math.ceil(r/4)},{type:12,data:o}],dispatchGroup:{x:Math.ceil(r/Kr/4)}})}},Is=e=>{e.inputs.length<2||z.size(e.inputs[1].dims)===0?Di(e):e.compute(jl(e.inputs))}});var Yl,Zl,Ts,Es,Ps=q(()=>{"use strict";ie();_e();je();be();Yl=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},Zl=(e,t)=>{let r=e[0].dims,o=e[1].dims,n=r.length,s=z.normalizeAxis(t.axis,n),u=r.slice(0);u.splice(s,1,...o);let l=r[s],a=e[0].dataType===9?4:1,p=Math.ceil(z.size(u)/a),m=[{type:12,data:p},{type:6,data:l},{type:12,data:s},...j(e[0].dims,e[1].dims,u)],f=b=>{let _=M("data",e[0].dataType,e[0].dims.length,a),y=M("inputIndices",e[1].dataType,e[1].dims.length),$=F("output",e[0].dataType,u.length,a),I=v=>{let A=o.length,T=`var indicesIndices${v}  = ${y.type.indices}(0);`;for(let D=0;D<A;D++)T+=`${A>1?`indicesIndices${v}[${D}]`:`indicesIndices${v}`} = ${u.length>1?`outputIndices${v}[uniforms.axis + ${D}]`:`outputIndices${v}`};`;T+=`\n          var idx${v} = ${y.getByIndices(`indicesIndices${v}`)};\n          if (idx${v} < 0) {\n            idx${v} = idx${v} + uniforms.axisDimLimit;\n          }\n          var dataIndices${v} : ${_.type.indices};\n        `;for(let D=0,U=0;D<n;D++)D===s?(T+=`${n>1?`dataIndices${v}[${D}]`:`dataIndices${v}`} = u32(idx${v});`,U+=A):(T+=`${n>1?`dataIndices${v}[${D}]`:`dataIndices${v}`} = ${u.length>1?`outputIndices${v}[${U}]`:`outputIndices${v}`};`,U++);return T},C;if(e[0].dataType===9){let v=(A,T,D="")=>`\n          let outputIndices${T} = ${$.offsetToIndices(`outputOffset + ${T}u`)};\n          ${I(T)};\n          let offset${T} = ${_.indicesToOffset(`dataIndices${T}`)};\n          let index${T} = offset${T} / 4u;\n          let component${T} = offset${T} % 4u;\n          ${A}[${T}] = ${D}(${_.getByOffset(`index${T}`)}[component${T}]);\n        `;C=`\n        let outputOffset = global_idx * ${a};\n        var value = vec4<u32>(0);\n        ${v("value",0,"u32")}\n        ${v("value",1,"u32")}\n        ${v("value",2,"u32")}\n        ${v("value",3,"u32")}\n        ${$.setByOffset("global_idx","value")}\n      `}else C=`\n      let outputIndices = ${$.offsetToIndices("global_idx")};\n      ${I("")};\n      let value = ${_.getByIndices("dataIndices")};\n      ${$.setByOffset("global_idx","value")};\n      `;return`\n      ${b.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(_,y,$)}\n      ${b.mainStart()}\n        ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${C}\n      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:m}),getShaderSource:f}},Ts=e=>$e({axis:e.axis}),Es=(e,t)=>{let r=e.inputs;Yl(r),e.compute(Zl(e.inputs,t))}});var Ql,Xl,Os,ks,Rs=q(()=>{"use strict";ie();_e();je();be();Ql=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Xl=(e,t)=>{let r=e[0].dims,o=e[0].dataType,n=r.length,s=e[1].dims,u=e[1].dataType,l=z.normalizeAxis(t.axis,n),a=r[l],p=s.slice(0),m=z.size(p),f=M("input",o,n),b=M("indicesInput",u,s.length),_=F("output",o,p.length),y=[{type:12,data:m},{type:6,data:a},{type:12,data:l}];return y.push(...j(r,s,p)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:y}),getShaderSource:C=>`\n      ${C.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(f,b,_)}\n      ${C.mainStart()}\n      ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${_.offsetToIndices("global_idx")};\n\n      var idx = ${b.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${f.type.indices}(outputIndices);\n      ${f.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${f.getByIndices("inputIndices")};\n\n      ${_.setByOffset("global_idx","value")};\n  }`}},Os=e=>$e({axis:e.axis}),ks=(e,t)=>{let r=e.inputs;Ql(r),e.compute(Xl(e.inputs,t))}});var Jl,ec,Bs,Ds,Ms=q(()=>{"use strict";ie();_e();be();Jl=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},ec=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[n,s,u]=Lr.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),l=[n,s];if(!l)throw new Error("Can\'t use gemm on the given tensors");let a=z.size(l),p=[{type:12,data:a},{type:12,data:n},{type:12,data:s},{type:12,data:u},{type:1,data:t.alpha},{type:1,data:t.beta}],m=["type","type"];e.length===3&&(p.push(...j(e[2].dims)),m.push("rank")),p.push(...j(l));let f=b=>{let _="";t.transA&&t.transB?_="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":t.transA&&!t.transB?_="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!t.transA&&t.transB?_="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!t.transA&&!t.transB&&(_="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let y=t.alpha===1?"":"value *= uniforms.alpha;",$=M("a",e[0].dataType,e[0].dims),I=M("b",e[1].dataType,e[1].dims),C=$.type.value,v=null,A=[$,I];e.length===3&&(v=M("c",e[2].dataType,e[2].dims.length),A.push(v));let T=F("output",e[0].dataType,l.length);A.push(T);let D=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`\n  ${b.registerUniforms(D).declareVariables(...A)}\n\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${C}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${_}\n    }\n\n    ${y}\n    ${(()=>v!=null?`let cOffset = ${v.broadcastedIndicesToOffset("vec2(m, n)",T)}; value += ${C}(uniforms.beta) * ${v.getByOffset("cOffset")};`:"")()}\n    output[global_idx] = value;\n  }`};return{name:"Gemm",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p}),getShaderSource:f}},Bs=e=>{let t=e.transA,r=e.transB,o=e.alpha,n=e.beta;return{transA:t,transB:r,alpha:o,beta:n,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},Ds=(e,t)=>{Jl(e.inputs),e.compute(ec(e.inputs,t))}});var tc,rc,nc,zs,Us=q(()=>{"use strict";ie();_e();be();tc=(e,t)=>{let r=e[0].dims,o=r,n=2,s=z.sizeToDimension(r,n),u=z.sizeFromDimension(r,n),l=Me(u),a=u/l,p=[r[0],r[1],a],m=["rank","type","type"],f=[{type:12,data:u},{type:12,data:a}];f.push(...j(p,p));let b=_=>{let y=M("x",e[0].dataType,p.length,l),$=M("scale",e[1].dataType,e[1].dims),I=M("bias",e[2].dataType,e[2].dims),C=F("output",e[0].dataType,p.length,l),v=[y,$,I,C],A=y.type.value,T=l===1?"f32":`vec${l}<f32>`,D=64,U=[{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}];return`\n  var<workgroup> meanShared : f32;\n  var<workgroup> squaredNormShared : f32;\n  var<workgroup> workgroupShared : array<${T}, ${D}>;\n  const workgroupSize = ${D}u;\n  ${_.registerUniforms(U).declareVariables(...v)}\n  ${_.mainStart(D)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / uniforms.x_shape[1];\n    let channel = norm % uniforms.x_shape[1];\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial = ${T}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      initial = initial + ${T}(${y.get("batch","channel","h")});\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = ${tt("workgroupShared[0]",l)} / f32(uniforms.normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = ${T}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let deviation =  ${T}(${y.get("batch","channel","h")}) - ${T}(meanShared);\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = ${tt("workgroupShared[0]",l)};\n    }\n    workgroupBarrier();\n\n    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${t.epsilon}));\n    let channelScale = invStdDev * f32(${$.getByOffset("channel")});\n    let channelShift = f32(${I.getByOffset("channel")}) - meanShared * channelScale;\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let value = ${y.get("batch","channel","h")} * ${A}(${T}(channelScale)) + ${A}(${T}(channelShift));\n      ${C.set("batch","channel","h","value")};\n    }\n  }`};return{name:"InstanceNormalization",shaderCache:{hint:`${t.epsilon};${l}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:s},programUniforms:f}),getShaderSource:b}},rc=(e,t,r,o,n,s,u,l)=>{let a=Me(u),p=64,m=a===1?"vec2f":`mat2x${a}f`,f=a===1?"f32":`vec${a}f`,b=(U,V)=>`${m}(${U}, ${V})`,_=n*u/a,y=Math.ceil(s/p),$=["type"],I=[{type:12,data:y},{type:12,data:s},{type:12,data:Math.floor(u/a)},{type:12,data:Math.floor(s*u/a)}],C=U=>{let V=M("input",t.dataType,t.dims,a);return`\n  ${U.declareVariables(V)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${m}>;\n  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};\n  @group(0) @binding(2) var<uniform> uniforms: Uniforms;\n\n  ${U.mainStart(p)}\n    let currentImageNumber = global_idx / ${p} / uniforms.C;\n    let currentChannelNumber = (global_idx / ${p}) % uniforms.C;\n    let wgId = global_idx % ${p};\n    let wgOffset = wgId * uniforms.wg_size;\n    if (wgOffset >= uniforms.H) {\n        return;\n    }\n    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);\n\n    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;\n    var sum = ${Ye("f32",a)};\n    var squaredSum = ${Ye("f32",a)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${f}(input[offset + i * uniforms.C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${b("sum","squaredSum")};\n  }`},v=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${a}`,inputDependencies:$},getRunData:()=>({outputs:[{dims:[n,u,p,2],dataType:1}],dispatchGroup:{x:n*u/a},programUniforms:I}),getShaderSource:C},{inputs:[t],outputs:[-1]})[0],A=[{type:12,data:_},{type:12,data:s},{type:12,data:Math.floor(u/a)},{type:12,data:Math.floor(p*u/a)}],T=["type","type","type"],D=U=>{let V=M("scale",r.dataType,r.dims,a),H=M("bias",o.dataType,o.dims,a);return`\n  @group(0) @binding(0) var<storage, read> input : array<${m}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${V.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${H.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${m}>;\n  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};\n  @group(0) @binding(4) var<uniform> uniforms: Uniforms;\n\n  ${U.mainStart()}\n    ${U.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}\n    let currentImageNumber = global_idx / uniforms.C;\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let offset = currentImageNumber * uniforms.image_size;\n    var sum = ${Ye("f32",a)};\n    var squaredSum = ${Ye("f32",a)};\n    for (var i: u32 = 0; i < min(${p}, uniforms.H); i++) {\n        let value = input[offset + i + currentChannelNumber * ${p}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(uniforms.H);\n    squaredSum = squaredSum / f32(uniforms.H);\n    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${l}));\n    let channelScale = invStdDev * ${f}(scale[currentChannelNumber]);\n    let channelShift = ${f}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${b("channelScale","channelShift")};\n  }`};return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${a};${l}`,inputDependencies:T},getRunData:()=>({outputs:[{dims:[n,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:A}),getShaderSource:D},{inputs:[v,r,o],outputs:[-1]})[0]},nc=(e,t,r)=>{let o=t[0].dims,n=o,s=o[0],u=o[o.length-1],l=z.sizeFromDimension(o,1)/u,a=Me(u),p=z.size(n)/a,m=[{type:12,data:l},{type:12,data:Math.floor(u/a)}],f=["type","type"],b=rc(e,t[0],t[1],t[2],s,l,u,r.epsilon),_=y=>{let $=Pe(t[0].dataType),I=a===1?"vec2f":`mat2x${a}f`,C=a===1?$:`vec${a}<${$}>`,v=M("input",t[0].dataType,t[0].dims,a),A=F("output",t[0].dataType,n,a);return`\n  @group(0) @binding(0) var<storage, read> input : array<${v.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${I}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${A.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${y.mainStart()}\n    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${C}(scale[0]), ${C}(scale[1]));\n  }`};e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${a}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:m}),getShaderSource:_},{inputs:[t[0],b]})},zs=(e,t)=>{t.format==="NHWC"?nc(e,e.inputs,t):e.compute(tc(e.inputs,t))}});var oc,ac,Vs,Ns=q(()=>{"use strict";ie();_e();be();oc=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},ac=(e,t,r)=>{let o=e[0].dims,n=e[1],s=e[2],u=o,l=z.normalizeAxis(t.axis,o.length),a=z.sizeToDimension(o,l),p=z.sizeFromDimension(o,l),m=z.size(n.dims),f=s?z.size(s.dims):0;if(m!==p||s&&f!==p)throw new Error(`Size of X.shape()[axis:] == ${p}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${m} and bias size of ${f}`);let b=[];for(let T=0;T<o.length;++T)T<l?b.push(o[T]):b.push(1);let _=Me(p),y=["type","type"],$=[{type:12,data:a},{type:1,data:p},{type:12,data:Math.floor(p/_)},{type:1,data:t.epsilon}];s&&y.push("type");let I=r>1,C=r>2,v=T=>{let D=Pe(e[0].dataType),U=[M("x",e[0].dataType,e[0].dims,_),M("scale",n.dataType,n.dims,_)];s&&U.push(M("bias",s.dataType,s.dims,_)),U.push(F("output",e[0].dataType,u,_)),I&&U.push(F("mean_data_output",1,b)),C&&U.push(F("inv_std_output",1,b));let V=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`\n  ${T.registerUniforms(V).declareVariables(...U)}\n  ${T.mainStart()}\n    ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${Ye("f32",_)};\n    var mean_square_vector = ${Ye("f32",_)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${st(D,_,"x[h + offset]")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${tt("mean_vector",_)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${tt("mean_square_vector",_)} / uniforms.norm_size - mean * mean + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${st(D,_,"x[j + offset]")};\n      let f32scale = ${st(D,_,"scale[j]")};\n      output[j + offset] = ${U[0].type.value}((f32input - mean) * inv_std_dev * f32scale\n        ${s?`+ ${st(D,_,"bias[j]")}`:""}\n      );\n    }\n\n    ${I?"mean_data_output[global_idx] = mean":""};\n    ${C?"inv_std_output[global_idx] = inv_std_dev":""};\n  }`},A=[{dims:u,dataType:e[0].dataType}];return I&&A.push({dims:b,dataType:1}),C&&A.push({dims:b,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${_};${r}`,inputDependencies:y},getRunData:()=>({outputs:A,dispatchGroup:{x:Math.ceil(a/64)},programUniforms:$}),getShaderSource:v}},Vs=(e,t)=>{oc(e.inputs),e.compute(ac(e.inputs,t,e.outputCount))}});var ic,sc,Ws,Gs,Hs=q(()=>{"use strict";ie();_e();je();be();ic=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let r=e[0],o=r.dims.length;if(r.dims[o-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let n=Math.floor((t.k+t.blockSize-1)/t.blockSize),s=t.blockSize/8*t.bits,u=e[1];if(!z.areEqual(u.dims,[t.n,n,s]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let a=e[2].dims;if(z.size(a)!==t.n*n)throw new Error("scales input size error.");if(e.length===4){let m=e[3].dims,f=t.bits>4?t.n*n:t.n*Math.floor((n+1)/2);if(z.size(m)!==f)throw new Error("zeroPoints input size error.")}},sc=(e,t)=>{let r=e[0].dims,o=r.length,n=r.slice(0,o-1).concat(t.n),s=r[o-2],l=t.blockSize/8*t.bits/4,a=Me(s),p=Me(t.n),m=Me(t.k),f=Me(l),b=z.size(n)/p/a,_=[{type:12,data:b},{type:12,data:t.k},{type:12,data:t.n},{type:12,data:t.accuracyLevel},{type:12,data:t.bits},{type:12,data:t.blockSize}],y=r.slice();y.splice(-1,1,t.k/m);let $=z.convertShape(e[1].dims).slice();$.splice(-1,1,l/f),_.push(...j(y)),_.push(...j($)),_.push(...j(e[2].dims)),e.length===4&&_.push(...j(z.convertShape(e[3].dims)));let I=n.slice();I.splice(-1,1,t.n/p),_.push(...j(I));let C=v=>{let A=M("a",e[0].dataType,y.length,m),T=M("b",12,$.length,f),D=M("scales",e[2].dataType,e[2].dims.length),U=[A,T,D],V=e.length===4?M("zero_points",12,e[3].dims.length):void 0;V&&U.push(V);let H=F("output",e[0].dataType,n.length,p),R=[{name:"output_size",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"accuracy_level",type:"u32"},{name:"bits",type:"u32"},{name:"block_size",type:"u32"}],L=Math.floor((t.k+t.blockSize-1)/t.blockSize),pe=Pe(e[0].dataType),Ie=(()=>{switch(m){case 1:return`array<${pe}, 8>`;case 2:return`mat4x2<${pe}>`;case 4:return`mat2x4<${pe}>`;default:throw new Error(`${m}-component is not supported.`)}})(),we=`\n        fn dequantize(quantized: ${Ie}, zero_point: ${pe}, scale: ${pe}) -> ${Ie} {\n          ${(()=>m===1?`var dequantized = ${Ie}(${Array.from({length:8},(Q,xe)=>`(quantized[${xe}] - zero_point) * scale`).join(", ")});\n              return dequantized;`:`var zero_points: ${Ie} = ${Ie}(${Array(8).fill("zero_point").join(",")});\n              return (quantized - zero_points) * scale;`)()}\n        }`,ne=`\n        fn ortUnpack8x4snorm(value: u32) -> ${Ie} {\n          var quantized: ${Ie};\n          var offset: u32 = 0;\n          let count: u32 = 4;\n          for (var i: u32 = 0; i < 8u; i++) {\n            var result = ${pe}(extractBits(value, offset, count));\n            ${(()=>{switch(m){case 1:return"quantized[i] = result;";case 2:return"quantized[i / 2][i % 2] = result;";case 4:return"quantized[i / 4][i % 4] = result;";default:throw new Error(`${m}-component is not supported.`)}})()}\n            offset += count;\n          }\n          return quantized;\n        }`,ze=V?`\n          zero_point_offset += 4;\n          if (zero_point_offset == 32) {\n            zero_point_offset = 0;\n            zero_point_index++;\n            zero_point_word = ${V.getByOffset("zero_point_index")};\n          }`:"";return`\n        ${we};\n        ${ne};\n        ${v.registerUniforms(R).declareVariables(...U,H)}\n        ${v.mainStart()}\n          ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var output_values: array<${H.type.value}, ${a}>;\n          var output_indices = ${H.offsetToIndices("global_idx")};\n          var n = ${H.indicesGet("output_indices",o-1)};\n          var m = ${H.indicesGet("output_indices",o-2)};\n          var a_indices: ${A.type.indices} = output_indices;\n          // Two zero points are packed into one byte because uniforms.bits <= 4.\n          // zero_point_offset is either 0 or 4. It is bit offset within one byte.\n          // TODO support zero_point_offset for bits > 4\n          ${V?`\n          var zero_point_index: u32 = n * ${p} * ((${L} + 1) / 2) / 4;\n          var zero_point_word: u32 = ${V.getByOffset("zero_point_index")};\n          var zero_point_offset: u32 = 0;`:""}\n          var scale_index = n * ${L*p};\n          var b_indices: ${T.type.indices};\n          for (var c: u32 = 0; c < ${p}; c++) {\n            ${T.indicesSet("b_indices","0",`n * ${p} + c`)};\n            var block_offset: u32 = 0;\n            for (var block: u32 = 0; block < ${L}; block++) {\n              // The scale and zero points are computed per block.\n              let scale = ${D.getByOffset("scale_index")};\n              // The default zero point is 8 for unsigned 4-bit quantization.\n              let zero_point = ${pe}(${V?"extractBits(zero_point_word, zero_point_offset, 4)":8});\n              ${T.indicesSet("b_indices","1","block")};\n              var word_offset: u32 = block_offset;\n              for (var word: u32 = 0; word < ${l}; word += ${f}) {\n                ${T.indicesSet("b_indices","2","word")};\n                let b_data = ${T.getByIndices("b_indices")};\n                for (var i: u32 = 0; i < ${f}; i++) {\n                  let b_value = ${f===1?"b_data":"b_data[word + i]"};\n                  let b_quantized_values: ${Ie} = ortUnpack8x4snorm(b_value);\n                  let b_dequantized_values = dequantize(b_quantized_values, zero_point, scale);\n                  // Number of B elements per 32-bit word is 32/bits = 32/4 = 8\n                  var offset: u32 = word_offset;\n                  for (var j: u32 = 0; j < 8/${m}; j++) {\n                    ${A.indicesSet("a_indices",o-1,`offset/${m}`)};\n                    for (var k: u32 = 0; k < ${a}u; k++) {\n                      ${A.indicesSet("a_indices",o-2,`m * ${a} + k`)};\n                      let a_data = ${A.getByIndices("a_indices")};\n                      output_values[k]${p>1?"[c]":""} += ${m===1?"a_data * b_dequantized_values[j]":"dot(a_data, b_dequantized_values[j])"};\n                    }\n                    offset += ${m};\n                  }\n                  word_offset += 8;\n                }\n              }\n              scale_index++;\n              ${ze}\n              block_offset += uniforms.block_size;\n            }\n            // Drop the trailing 4 bits if the zero_poit_offset is not a byte boundary to align with the next byte.\n            ${V?`if (zero_point_offset % 8 > 0) {\n                ${ze}\n              }`:""}\n            }\n            for (var k: u32 = 0u; k < ${a}u; k++) {\n              ${H.indicesSet("output_indices",o-2,`${a+" * m + k"}`)};\n              ${H.setByIndices("output_indices","output_values[k]")}\n            }\n        }`};return{name:"MatMulNBits",shaderCache:{hint:`${t.cacheKey};${e.length}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:_}),getShaderSource:C}},Ws=(e,t)=>{ic(e.inputs,t),e.compute(sc(e.inputs,t))},Gs=e=>$e(e)});var uc,Fs,Ls,dc,oo,qs,Ks=q(()=>{"use strict";ie();_e();je();Gr();Hn();be();Yt();uc=(e,t)=>{let r=e[0],o=e[1],n=e[2],s=e[3],u=e[4],l=e[5],a=e[6],p=e[7];if(r.dims.length!==3&&r.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let m=!1,f=r.dims[0],b=r.dims[1],_=r.dims.length===3?m?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],y=b,$=0,I=0,C=Math.floor(_/t.numHeads);if(a&&p){if(a.dims.length!==4)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(p.dims.length!==4)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');$=a.dims[2],I=a.dims[2]}else if(a||p)throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');let v;if(o){if(r.dims.length!==3)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(o.dims.length<3||o.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(r.dims[0]!==o.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(o.dims.length===3){if(o.dims[2]!==r.dims[2])throw new Error(\'Input "query" and "key" shall have same dim 2 (hidden_size)\');v=2,y=o.dims[1]}else if(o.dims.length===5){if(o.dims[2]!==t.numHeads||o.dims[3]!==2||o.dims[4]!==C)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(n)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');v=5,y=o.dims[1]}else{if(o.dims[1]!==t.numHeads||o.dims[3]!==C)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');v=0,y=o.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\'Input "query" is expected to have 3 or 5 dimensions when key is empty\');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');v=3}if(s){if(s.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimension\');if(n&&r.dims.length===5&&r.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let A=0;if(u){A=8;let H=u.dims;throw H.length===1?H[0]===f?A=1:H[0]===3*f+2&&(A=3):H.length===2&&H[0]===f&&H[1]===y&&(A=5),A===8?new Error(\'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)\'):new Error("Mask not supported")}let T=!1,D=_;if(n){if(n.dims.length!==3&&n.dims.length!==4)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(r.dims[0]!==n.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(n.dims.length===3){if(y!==n.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');D=n.dims[2]}else{if(y!==n.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)\');D=n.dims[1]*n.dims[3],T=!0}}let U=$+y,V=!1;if(u)throw new Error("Key padding mask is not supported");if(l)throw new Error("extraAddQk is not supported");if(a)throw new Error("pastKey is not supported");if(p)throw new Error("pastValue is not supported");return{batchSize:f,sequenceLength:b,pastSequenceLength:$,kvSequenceLength:y,totalSequenceLength:U,maxSequenceLength:I,inputHiddenSize:0,hiddenSize:_,vHiddenSize:D,headSize:C,vHeadSize:Math.floor(D/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:A,scale:t.scale,broadcastResPosBias:V,passPastInKv:T,qkvFormat:v}},Fs=e=>$e({...e}),Ls=$e({perm:[0,2,1,3]}),dc=(e,t,r,o,n,s,u)=>{let l=[o,n,s],a=z.size(l),p=[{type:12,data:a},{type:12,data:u},{type:12,data:s}],m=f=>{let b=F("qkv_with_bias",t.dataType,l),_=M("qkv",t.dataType,l),y=M("bias",r.dataType,l),$=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`\n  ${f.registerUniforms($).declareVariables(_,y,b)}\n  ${f.mainStart()}\n    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`};return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:l,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p}),getShaderSource:m},{inputs:[t,r],outputs:[-1]})[0]},oo=(e,t,r,o,n,s,u,l)=>{let a=s;if(u){if(o===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return a=dc(e,s,u,t,o,r*n,l),a=a.reshape([t,o,r,n]),e.compute(ot(a,Ls.perm),{inputs:[a],outputs:[-1]})[0]}else return s.dims.length===3&&(a=s.reshape([t,o,r,n])),e.compute(ot(a,Ls.perm),{inputs:[a],outputs:[-1]})[0]},qs=(e,t)=>{let r=uc(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(e.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let o=e.inputs[1]&&e.inputs[2]&&e.inputs[1].dims.length===4&&e.inputs[2].dims.length===4,n=oo(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,e.inputs[0],e.inputs[3],0);if(o)return Qr(e,n,e.inputs[1],e.inputs[2],e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t);let s=oo(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,e.inputs[1],e.inputs[3],r.hiddenSize),u=oo(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,e.inputs[2],e.inputs[3],2*r.hiddenSize);Qr(e,n,s,u,e.inputs[4],void 0,e.inputs[6],e.inputs[7],e.inputs[5],r,t)}});var lc,cc,pc,mc,fc,hc,gc,yc,js,Ys=q(()=>{"use strict";ie();_e();be();lc=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},cc=(e,t,r)=>{let o="";for(let n=t-1;n>=0;--n)o+=`\n            k = i32(${e.indicesGet("indices",n)}) - ${re("uniforms.pads",n,r)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${re("uniforms.x_shape",n,t)})) {\n              break;\n            }\n            offset += k * i32(${re("uniforms.x_strides",n,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${o}\n            value = x[offset];\n          }\n      `},pc=(e,t,r)=>{let o="";for(let n=t-1;n>=0;--n)o+=`\n                k = i32(${e.indicesGet("indices",n)}) - ${re("uniforms.pads",n,r)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${re("uniforms.x_shape",n,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${re("uniforms.x_shape",n,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${re("uniforms.x_strides",n,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},mc=(e,t,r)=>{let o="";for(let n=t-1;n>=0;--n)o+=`\n                k = i32(${e.indicesGet("indices",n)}) - ${re("uniforms.pads",n,r)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${re("uniforms.x_shape",n,t)})) {\n                  k = i32(${re("uniforms.x_shape",n,t)}) - 1;\n                }\n                offset += k * i32(${re("uniforms.x_strides",n,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},fc=(e,t,r)=>{let o="";for(let n=t-1;n>=0;--n)o+=`\n                k = i32(${e.indicesGet("indices",n)}) - ${re("uniforms.pads",n,r)};\n                if (k < 0)  {\n                  k += i32(${re("uniforms.x_shape",n,t)}]);\n                }\n                if (k >= i32(${re("uniforms.x_shape",n,t)})) {\n                  k -= i32(${re("uniforms.x_shape",n,t)});\n                }\n                offset += k * i32(${re("uniforms.x_strides",n,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},hc=(e,t,r)=>{switch(r.mode){case 0:return cc(e,t,r.pads.length);case 1:return pc(e,t,r.pads.length);case 2:return mc(e,t,r.pads.length);case 3:return fc(e,t,r.pads.length);default:throw new Error("Invalid mode")}},gc=(e,t)=>{let r=z.padShape(e[0].dims.slice(),t.pads),o=e[0].dims,n=z.size(r),s=[{type:12,data:n},{type:12,data:t.pads}];t.mode===0&&s.push({type:e[0].dataType,data:t.value}),s.push(...j(e[0].dims,r));let u=["rank"],l=a=>{let p=F("output",e[0].dataType,r.length),m=M("x",e[0].dataType,o.length),f=m.type.value,b=hc(p,o.length,t),_=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return t.mode===0&&_.push({name:"constant_value",type:f}),`\n            ${a.registerUniforms(_).declareVariables(m,p)}\n            ${a.mainStart()}\n            ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n            let indices = ${p.offsetToIndices("global_idx")};\n\n            var value = ${f}(0);\n            ${b}\n            output[global_idx] = value;\n        }`};return{name:"Pad",shaderCache:{hint:`${t.mode}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(z.size(r)/64)},programUniforms:s}),getShaderSource:l}},yc=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,n=e[0].dims.length,s=new Int32Array(2*n).fill(0);if(e.length>=4){let l=e[3].getBigInt64Array();for(let a=0;a<l.length;a++)s[Number(l[a])]=Number(r[a]),s[Number(l[a])+n]=Number(r[a+l.length])}else r.forEach((l,a)=>s[Number(a)]=Number(l));let u=[];return s.forEach(l=>u.push(l)),{mode:t.mode,value:o,pads:u}}else return t},js=(e,t)=>{lc(e.inputs);let r=yc(e.inputs,t);e.compute(gc(e.inputs,r),{inputs:[0]})}});var dn,Zs,Qs,Xs,Js,bc,wc,eu,tu,ru,nu,ou,au,iu,su,uu,du,lu,cu,pu=q(()=>{"use strict";Kt();ie();_e();be();dn=e=>{if(qt.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},Zs=(e,t,r)=>{let o=t.format==="NHWC",n=e.dims.slice();o&&n.splice(1,0,n.pop());let s=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),l=t.strides.slice(),a=s?t.dilations.slice():[],p=t.pads.slice();zt.adjustPoolAttributes(r,n,u,l,a,p);let m=zt.computePoolOutputShape(r,n,l,a,u,p,t.autoPad),f=Object.assign({},t);s?Object.assign(f,{kernelShape:u,strides:l,pads:p,dilations:a,cacheKey:t.cacheKey}):Object.assign(f,{kernelShape:u,strides:l,pads:p,cacheKey:t.cacheKey});let b=m.slice();return b.push(b.splice(1,1)[0]),[f,o?b:m]},Qs=(e,t)=>{let r=t.format==="NHWC",o=z.size(e),n=z.size(t.kernelShape),s=[{type:12,data:o},{type:12,data:n}],u=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let l=t.kernelShape[t.kernelShape.length-1],a=t.strides[t.strides.length-1],p=t.pads[t.pads.length/2-1],m=t.pads[t.pads.length-1],f=!!(p+m);s.push({type:12,data:l},{type:12,data:a},{type:12,data:p},{type:12,data:m}),u.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let b=!1;if(t.kernelShape.length===2){let _=t.kernelShape[t.kernelShape.length-2],y=t.strides[t.strides.length-2],$=t.pads[t.pads.length/2-2],I=t.pads[t.pads.length-2];b=!!($+I),s.push({type:12,data:_},{type:12,data:y},{type:12,data:$},{type:12,data:I}),u.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[s,u,!0,f,b]}else{if(r)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let l=z.computeStrides(t.kernelShape);s.push({type:12,data:l},{type:12,data:t.pads},{type:12,data:t.strides}),u.push({name:"kernelStrides",type:"u32",length:l.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let a=t.pads.reduce((p,m)=>p+m);return[s,u,!!a,!1,!1]}},Xs=(e,t,r,o,n,s,u,l,a,p,m,f)=>{let b=n.format==="NHWC",_=t.type.value,y=F("output",t.type.tensor,o);if(n.kernelShape.length<=2){let $="",I="",C="",v=r-(b?2:1);if(m?$=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${v}] < 0 || xIndices[${v}]\n                      >= uniforms.x_shape[${v}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`:$=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`,n.kernelShape.length===2){let T=r-(b?3:2);f?I=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${T}] < 0 || xIndices[${T}] >= uniforms.x_shape[${T}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:I=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;\n                `,C=`\n              }\n            `}return`\n            ${e.registerUniforms(a).declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${y.offsetToIndices("global_idx")};\n              var xIndices = ${y.offsetToIndices("global_idx")};\n\n              var value = ${_}(${l});\n              var pad = 0;\n              ${I}\n              ${$}\n              ${C}\n              ${u}\n\n              output[global_idx] = value;\n            }`}else{if(b)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let $=n.kernelShape.length,I=n.pads.length,C="";return p?C=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`:C=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${s}\n            `,`\n            ${e.registerUniforms(a).declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${y.offsetToIndices("global_idx")};\n              var xIndices = ${y.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${$}>;\n\n              var value = ${_}(${l});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${$-1}u; j++) {\n                  offsets[j] = offset / ${re("uniforms.kernelStrides","j",$)};\n                  offset -= offsets[j] * ${re("uniforms.kernelStrides","j",$)};\n                }\n                offsets[${$-1}] = offset;\n\n                isPad = false;\n                for (var j = ${r-$}u; j < ${r}u; j++) {\n                  xIndices[j] = indices[j] * ${re("uniforms.strides",`j - ${r-$}u`,$)}\n                    + offsets[j - ${r-$}u] - ${re("uniforms.pads","j - 2u",I)};\n                  ${C}\n              }\n              ${u}\n\n              output[global_idx] = value;\n            }`}},Js=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,bc=e=>`${Js(e)};${e.countIncludePad}`,wc=e=>`${Js(e)};${e.storageOrder};${e.dilations}`,eu=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),tu=(e,t,r,o)=>{let[n,s]=Zs(t,o,r),u=M("x",t.dataType,t.dims.length),l=u.type.value,a="value += x_val;",p="";n.countIncludePad?p+=`value /= ${l}(uniforms.kernelSize);`:p+=`value /= ${l}(i32(uniforms.kernelSize) - pad);`;let[m,f,b,_,y]=Qs(s,n);m.push(...j(t.dims,s));let $=["rank"];return{name:e,shaderCache:{hint:`${o.cacheKey};${b};${_};${y}`,inputDependencies:$},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(z.size(s)/64)},programUniforms:m}),getShaderSource:I=>Xs(I,u,t.dims.length,s.length,n,a,p,0,f,b,_,y)}},ru=e=>{let t=e.count_include_pad!==0,r=eu(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let o={countIncludePad:t,...r,cacheKey:""};return{...o,cacheKey:bc(o)}},nu=(e,t)=>{dn(e.inputs),e.compute(tu("AveragePool",e.inputs[0],!1,t))},ou={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},au=e=>{let t=e.format;return{format:t,...ou,cacheKey:t}},iu=(e,t)=>{dn(e.inputs),e.compute(tu("GlobalAveragePool",e.inputs[0],!0,t))},su=(e,t,r,o)=>{let[n,s]=Zs(t,o,r),u=`\n      value = max(x_val, value);\n    `,l="",a=M("x",t.dataType,t.dims.length),p=["rank"],[m,f,b,_,y]=Qs(s,n);return m.push(...j(t.dims,s)),{name:e,shaderCache:{hint:`${o.cacheKey};${b};${_};${y}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(z.size(s)/64)},programUniforms:m}),getShaderSource:$=>Xs($,a,t.dims.length,s.length,n,u,l,t.dataType===10?-65504:-1e5,f,b,_,y)}},uu=(e,t)=>{dn(e.inputs),e.compute(su("MaxPool",e.inputs[0],!1,t))},du=e=>{let t=e.storage_order,r=e.dilations,o=eu(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let n={storageOrder:t,dilations:r,...o,cacheKey:""};return{...n,cacheKey:wc(n)}},lu=e=>{let t=e.format;return{format:t,...ou,cacheKey:t}},cu=(e,t)=>{dn(e.inputs),e.compute(su("GlobalMaxPool",e.inputs[0],!0,t))}});var $c,_c,mu,fu=q(()=>{"use strict";Kt();ie();be();$c=(e,t,r)=>{let o=e===t,n=e<t&&r<0,s=e>t&&r>0;if(o||n||s)throw new Error("Range these inputs\' contents are invalid.")},_c=(e,t,r,o)=>{let n=Math.abs(Math.ceil((t-e)/r)),s=[n],u=n,l=[{type:12,data:u},{type:o,data:e},{type:o,data:r},...j(s)],a=p=>{let m=F("output",o,s.length),f=m.type.value,b=[{name:"outputSize",type:"u32"},{name:"start",type:f},{name:"delta",type:f}];return`\n        ${p.registerUniforms(b).declareVariables(m)}\n        ${p.mainStart()}\n        ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        output[global_idx] = uniforms.start + ${f}(global_idx) * uniforms.delta;\n      }`};return{name:"Range",shaderCache:{hint:`${o}`},getShaderSource:a,getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:l})}},mu=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),qt.webgpu.validateInputContent&&$c(t,r,o),e.compute(_c(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var xc,Sc,Cc,Ic,Ac,Tc,Ec,Pc,Oc,kc,Rc,hu,Bc,Dc,Mc,zc,Uc,gu,yu,bu=q(()=>{"use strict";ie();_e();je();be();xc=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Sc=(e,t,r)=>{t.every(n=>n>=0&&n<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((n,s)=>o[n]=e[s]),o},Cc=(e,t,r,o,n,s)=>{let[u,l,a]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(m=>s.push(m));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(l>0&&e.length>l&&e[l].dims.length>0){if(e[l].getFloat32Array().forEach(m=>o.push(m)),o.length!==0&&o.length!==p&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");xc(o,t),t.axes.length>0&&Sc(o,t.axes,p).forEach((m,f)=>o[f]=m)}if(a>0&&e.length>a&&(e[a].getBigInt64Array().forEach(m=>n.push(Number(m))),n.length!==p||r>=18&&n.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(n.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof o<"u"&&typeof n<"u"&&o.length>0&&n.length>p)throw new Error("Resize requires only of scales or sizes to be specified")},Ic=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`return ${t}(xResized) / ${t}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n                    // offset-by-one error later in floor().\n                    let whole = ${t}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\n                    let fract =\n                        ${t}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${t}(lengthResized - 1);\n                    return whole + fract;\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",Ac=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Tc=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),n=e.length===0?o:e.slice();return t.length>0?(t.forEach((s,u)=>{o[s]=n[u],o[u+r]=n[t.length+u]}),o):n},Ec=(e,t,r,o)=>{let n=[];if(r.length>0)if(o.length>0){if(e.forEach(s=>n.push(s)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((s,u)=>n[s]=r[u])}else r.forEach(s=>n.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");n=e.map((s,u)=>Math.round(s*t[u]))}return n},Pc=(e,t,r)=>{let o=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map(s=>t[s]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map(s=>t[s]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let n=e.slice();return r.axes.length>0?(r.axes.forEach(s=>t[s]=o),r.axes.forEach(s=>n[s]=Math.round(e[s]*t[s]))):(t.fill(o,0,t.length),n.forEach((s,u)=>n[u]=Math.round(s*t[u]))),n},Oc=(e,t,r,o,n)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {\n      var original_indices: array<${e.type.value}, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${e.indicesGet("output_indices","i")};\n        var scale = ${re("uniforms.scales","i",o)};\n        var roi_low = ${re("uniforms.roi","i",n)};\n        var roi_hi = ${re("uniforms.roi",`i + ${t.length}`,n)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${re("uniforms.input_shape","i",t.length)};\n          var output_shape_i = ${re("uniforms.output_shape","i",r.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,kc=(e,t,r,o,n,s,u)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${o.length}; i++) {\n        var output_index = ${t.indicesGet("output_indices","i")};\n        var input_index: u32;\n        var scale = ${re("uniforms.scales","i",n)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${re("uniforms.roi","i",s)};\n          var roi_hi = ${re("uniforms.roi",`i + ${r.length}`,s)};\n          var input_shape_i = ${re("uniforms.input_shape","i",r.length)};\n          var output_shape_i = ${re("uniforms.output_shape","i",o.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${u} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet("input_indices","i"," input_index")}\n      }\n      return input_indices;\n    }`,Rc=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${re("uniforms.input_shape","i",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,hu=(e,t,r,o)=>e.rank>o?`\n    ${e.indicesSet("input_indices",t,"channel")};\n    ${e.indicesSet("input_indices",r,"batch")};\n`:"",Bc=(e,t,r,o,n)=>{let[u,l,a,p]=r.length===2?[-1,0,1,-1]:[0,2,3,1],m=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${m} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",l,`max(0, min(row, ${r[l]} - 1))`)};\n      ${e.indicesSet("input_indices",a,`max(0, min(col, ${r[a]} - 1))`)};\n      ${hu(e,p,u,2)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${m} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${m} = originalIndices[${l}];\n      var col:${m} = originalIndices[${a}];\n      ${o?`if (row < 0 || row > (${r[l]} - 1) || col < 0 || col > (${r[a]} - 1)) {\n        return ${n};\n      }`:""};\n      row = max(0, min(row, ${r[l]} - 1));\n      col = max(0, min(col, ${r[a]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${r.length>2?`u32(originalIndices[${p}])`:"0"};\n      var batch: u32 =  ${r.length>2?`u32(originalIndices[${u}])`:"0"};\n      var x11: ${m} = getInputValue(batch, channel, row1, col1);\n      var x12: ${m} = getInputValue(batch, channel, row1, col2);\n      var x21: ${m} = getInputValue(batch, channel, row2, col1);\n      var x22: ${m} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${m} = abs(row - ${m}(row1));\n      var dx2: ${m} = abs(${m}(row2) - row);\n      var dy1: ${m} = abs(col - ${m}(col1));\n      var dy2: ${m} = abs(${m}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Dc=(e,t,r,o,n,s,u,l,a,p)=>{let m=r.length===2,f=!0,[b,_]=m?[0,1]:f?[2,3]:[1,2],y=e.type.value,$=I=>{let C=I===b?"row":"col";return`\n      fn ${C}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${y} {\n        var output_index = ${t.indicesGet("output_indices",I)};\n        var originalIdx: ${y} = getOriginalCoordinateFromResizedCoordinate(output_index, ${n[I]},\n        ${o[I]}, ${r[I]}, ${s[I]}, ${s[I]} + ${r.length});\n        var fractOriginalIdx: ${y} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${l} && (originalIdx < 0 || originalIdx > (${r[I]} - 1))) {\n          return ${a};\n        }\n        var data: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${C}: ${y} = originalIdx + ${y}(i);\n          if (${C} < 0 || ${C} >= ${r[I]}) {\n            ${(()=>p?`coefs[i + 1] = 0.0;\n                        continue;`:l?`return ${a};`:`${C} = max(0, min(${C}, ${r[I]} - 1));`)()};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet("input_indices_copy",I,`u32(${C})`)};\n          data[i + 1] = ${I===b?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${$(b)};\n    ${$(_)};\n  fn getCubicInterpolationCoefs(s: ${y}) -> array<${y}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${y} = 1.0 - absS;\n    var twoMinusAbsS: ${y} = 2.0 - absS;\n    var onePlusAbsS: ${y} = 1.0 + absS;\n    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};\n    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${y}, 4>, coefs: array<${y}, 4>) -> ${y} {\n    var coefsSum: ${y} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${y} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},Mc=(e,t,r,o,n)=>{let[u,l,a,p,m]=r.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],f=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${f} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",l,`max(0, min(depth, ${r[l]} - 1))`)};\n      ${e.indicesSet("input_indices",a,`max(0, min(height, ${r[a]} - 1))`)};\n      ${e.indicesSet("input_indices",p,`max(0, min(width, ${r[p]} - 1))`)};\n      ${hu(e,m,u,3)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${f} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${f} = originalIndices[${l}];\n      var height:${f} = originalIndices[${a}];\n      var width:${f} = originalIndices[${p}];\n      ${o?`if (depth < 0 || depth > (${r[l]} - 1) || height < 0 || height > (${r[a]} - 1) || width < 0 || (width > ${r[p]} - 1)) {\n      return ${n};\n        }`:""};\n\n    depth = max(0, min(depth, ${r[l]} - 1));\n      height = max(0, min(height, ${r[a]} - 1));\n      width = max(0, min(width, ${r[p]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${r.length>3?`u32(originalIndices[${m}])`:"0"};\n      var batch: u32 =  ${r.length>3?`u32(originalIndices[${u}])`:"0"};\n\n      var x111: ${f} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${f} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${f} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${f} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${f} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${f} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${f} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${f} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${f} = abs(depth - ${f}(depth1));\n      var dx2: ${f} = abs(${f}(depth2) - depth);\n      var dy1: ${f} = abs(height - ${f}(height1));\n      var dy2: ${f} = abs(${f}(height2) - height);\n      var dz1: ${f} = abs(width - ${f}(width1));\n      var dz2: ${f} = abs(${f}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},zc=(e,t,r,o,n,s)=>{let u=e.dims,l=Tc(s,t.axes,u.length),a=Ec(u,o,n,t.axes),p=o.slice();o.length===0&&(p=u.map((v,A)=>v===0?1:a[A]/v),t.keepAspectRatioPolicy!=="stretch"&&(a=Pc(u,p,t)));let m=F("output",e.dataType,a.length),f=M("input",e.dataType,u.length),b=z.size(a),_=u.length===a.length&&u.every((v,A)=>v===a[A]),y=t.coordinateTransformMode==="tf_crop_and_resize",$=t.extrapolationValue,I=f.type.value,C=v=>`\n      ${_?"":`\n      ${Ic(t.coordinateTransformMode,I)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${Rc(f,u)};\n              ${Ac(t.nearestMode,r,I)};\n              ${kc(f,m,u,a,p.length,l.length,y)};\n              `;case"linear":return`\n              ${Oc(m,u,a,p.length,l.length)};\n              ${(()=>{if(u.length===2||u.length===4)return`${Bc(f,m,u,y,$)}`;if(u.length===3||u.length===5)return`${Mc(f,m,u,y,$)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\n            `;case"cubic":return`\n            ${(()=>{if(u.length===2||u.length===4)return`${Dc(f,m,u,a,p,l,t.cubicCoeffA,y,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${v.registerUniform("output_size","u32").registerUniform("scales","f32",p.length).registerUniform("roi","f32",l.length).declareVariables(f,m)}\n      ${v.mainStart()}\n        ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${_?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${m.offsetToIndices("global_idx")};\n        var input_indices: ${f.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${f.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return`output[global_idx] = ${u.length===2||u.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${p.length>0?p:""}|${n.length>0?n:""}|${l.length>0?l:""}|${_}|${u}`,inputDependencies:["rank"]},getShaderSource:C,getRunData:()=>({outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:[{type:12,data:b},{type:1,data:p},{type:1,data:l},...j(u,a)]})}},Uc=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},gu=(e,t)=>{let r=[],o=[],n=[],s=Uc(e);if(t.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");Cc(e.inputs,t,s,r,o,n),e.compute(zc(e.inputs[0],t,s,r,o,n),{inputs:[0]})},yu=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,n=e.cubicCoeffA,s=e.excludeOutside!==0,u=e.extrapolationValue,l=e.keepAspectRatioPolicy,a=e.mode,p=e.nearestMode===""?"simple":e.nearestMode;return $e({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:n,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:l,mode:a,nearestMode:p})}});var Vc,Nc,wu,vu=q(()=>{"use strict";ie();_e();be();Vc=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let n=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==n)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==n)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Bias must have the same hidden size as input")}},Nc=(e,t,r,o)=>{let n=e[0].dims,s=z.size(n),u=n,l=s,a=n.slice(-1)[0],p=o?n.slice(0,-1).concat(1):[],m=e.length>3,f=e.length>4,b=o&&r>1,_=o&&r>2,y=r>3,$=Me(a),I=[{type:12,data:l},{type:12,data:$},{type:12,data:a},{type:1,data:t.epsilon}],C=A=>{let T=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],D=[M("x",e[0].dataType,e[0].dims,$),M("skip",e[1].dataType,e[1].dims,$),M("gamma",e[2].dataType,e[2].dims,$)];m&&D.push(M("beta",e[3].dataType,e[3].dims,$)),f&&D.push(M("bias",e[4].dataType,e[4].dims,$)),D.push(F("output",e[0].dataType,u,$)),b&&D.push(F("mean_output",1,p)),_&&D.push(F("inv_std_output",1,p)),y&&D.push(F("input_skip_bias_sum",e[0].dataType,u,$));let U=Pe(e[0].dataType);return`\n\n      ${A.registerUniforms(T).declareVariables(...D)}\n\n      ${A.mainStart()}\n        ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size / uniforms.hidden_size")}\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        let offset = global_idx * hidden_size_vectorized;\n        var sum = ${Ye("f32",$)};\n        var squareSum = ${Ye("f32",$)};\n        for (var i: u32 = 0; i < hidden_size_vectorized; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${f?"bias[i]":"0.0"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${y?"input_skip_bias_sum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32_value = ${st(U,$,"value")};\n          sum += f32_value;\n          squareSum += f32_value * f32_value;\n        }\n        let mean = ${tt("sum",$)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${tt("squareSum",$)} / f32(uniforms.hidden_size) - mean * mean + uniforms.epsilon);\n        ${b?"mean_output[global_idx] = mean;":""}\n        ${_?"inv_std_output[global_idx] = inv_std_dev;":""}\n        for (var i: u32 = 0; i < hidden_size_vectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${U}(mean)) * ${U}(inv_std_dev) * gamma[i] + ${m?"beta[i]":"0.0"};\n        }\n      }`},v=[{dims:u,dataType:e[0].dataType}];return r>1&&v.push({dims:p,dataType:1}),r>2&&v.push({dims:p,dataType:1}),r>3&&v.push({dims:n,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${$};${b};${_};${y}`,inputDependencies:e.map((A,T)=>"type")},getShaderSource:C,getRunData:()=>({outputs:v,dispatchGroup:{x:Math.ceil(l/a/64)},programUniforms:I})}},wu=(e,t)=>{Vc(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(Nc(e.inputs,t,e.outputCount,!1),{outputs:o})}});var Wc,ln,Gc,$u,Hc,Lc,_u,xu,Su=q(()=>{"use strict";ie();_e();je();be();Wc=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},ln=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Gc=(e,t)=>{if(e.length>1){let r=ln(e,1),o=ln(e,2),n=ln(e,3);return n.length===0&&(n=[...Array(e[0].dims.length).keys()]),$e({starts:r,ends:o,axes:n})}else return t},$u=(e,t,r,o,n)=>{let s=e;return e<0&&(s+=r[o[t]]),n[t]<0?Math.max(0,Math.min(s,r[o[t]]-1)):Math.max(0,Math.min(s,r[o[t]]))},Hc=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${re("uniforms.input_shape","i",r.length)};\n            let steps_i = ${re("uniforms.steps","i",r.length)};\n            let signs_i = ${re("uniforms.signs","i",r.length)};\n            let starts_i = ${re("uniforms.starts","i",r.length)};\n            var output_index = ${t.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,Lc=(e,t)=>{let r=e[0].dims,o=z.size(r),n=t.axes.length>0?z.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=ln(e,4);s.forEach(C=>C!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(n.length).fill(1));let u=t.starts.map((C,v)=>$u(C,v,r,n,s)),l=t.ends.map((C,v)=>$u(C,v,r,n,s));if(n.length!==u.length||n.length!==l.length)throw new Error("start, ends and axes should have the same number of elements");if(n.length!==r.length)for(let C=0;C<r.length;++C)n.includes(C)||(u.splice(C,0,0),l.splice(C,0,r[C]),s.splice(C,0,1));let a=s.map(C=>Math.sign(C));s.forEach((C,v,A)=>{if(C<0){let T=(l[v]-u[v])/C,D=u[v],U=D+T*s[v];u[v]=U,l[v]=D,A[v]=-C}});let p=r.slice(0);n.forEach((C,v)=>{p[C]=Math.ceil((l[C]-u[C])/s[C])});let m={dims:p,dataType:e[0].dataType},f=F("output",e[0].dataType,p.length),b=M("input",e[0].dataType,e[0].dims.length),_=z.size(p),y=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:u.length},{name:"signs",type:"i32",length:a.length},{name:"steps",type:"u32",length:s.length}],$=[{type:12,data:_},{type:12,data:u},{type:6,data:a},{type:12,data:s},...j(e[0].dims,p)],I=C=>`\n      ${C.registerUniforms(y).declareVariables(b,f)}\n        ${Hc(b,f,r)}\n        ${C.mainStart()}\n          ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${f.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${f.setByOffset("global_idx",b.getByIndices("input_indices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${a.length}_${u.length}_${s.length}`,inputDependencies:["rank"]},getShaderSource:I,getRunData:()=>({outputs:[m],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:$})}},_u=(e,t)=>{Wc(e.inputs,t);let r=Gc(e.inputs,t);e.compute(Lc(e.inputs,r),{inputs:[0]})},xu=e=>{let t=e.starts,r=e.ends,o=e.axes;return $e({starts:t,ends:r,axes:o})}});var Fc,qc,Cu,Iu,Au=q(()=>{"use strict";ie();_e();je();be();Fc=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},qc=(e,t)=>{let r=e.dims,o=z.size(r),n=64,s=t.axis;if(s<0&&(s=r.length+s),s<r.length-1)throw new Error("softmax only supports last axis for now.");let u=r[s],l=o/u,a=Me(u),p=u/a,m=(I,C)=>C===4?`max(max(${I}.x, ${I}.y), max(${I}.z, ${I}.w))`:C===2?`max(${I}.x, ${I}.y)`:C===3?`max(max(${I}.x, ${I}.y), ${I}.z)`:I,f=M("x",e.dataType,e.dims,a),b=F("result",e.dataType,e.dims,a),_=f.type.value,y=Pe(e.dataType)==="f32"?`var threadMax = ${_}(-3.402823e+38f);`:`var threadMax = ${_}(-65504.0h);`,$=I=>`\n      var<workgroup> rowMaxShared : ${_};\n      var<workgroup> rowSumShared : ${_};\n      var<workgroup> threadShared : array<${_}, ${n}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${_} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${_}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${I.registerUniform("packedCols","i32").declareVariables(f,b)}\n      ${I.mainStart()}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${n};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${y}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${_}(${m("threadShared[0]",a)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${_}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${_}(${tt("threadShared[0]",a)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;return{name:"Softmax",shaderCache:{hint:`${a}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:l},programUniforms:[{type:12,data:p}]}),getShaderSource:$}},Cu=(e,t)=>{Fc(e.inputs),e.compute(qc(e.inputs[0],t))},Iu=e=>$e({axis:e.axis})});var Kc,jc,Yc,Zc,Qc,Tu,Eu,Pu=q(()=>{"use strict";ie();_e();je();be();Kc=e=>{if(!e||e.length<1)throw new Error("too few inputs")},jc=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),o=r.length),$e({numOutputs:o,axis:t.axis,splitSizes:r})},Yc=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${re("uniforms.size_in_split_axis","i",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Zc=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let n=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(n):o===0?r.push(`if (output_number == ${o}u) { ${n} }`):o===t-1?r.push(`else { ${n} }`):r.push(`else if (output_number == ${o}) { ${n} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},Qc=(e,t)=>{let r=e[0].dims,o=z.size(r),n=e[0].dataType,s=z.normalizeAxis(t.axis,r.length),u=new Array(t.numOutputs),l=M("input",n,r.length),a=new Array(t.numOutputs),p=[],m=[],f=0,b=[{type:12,data:o}];for(let y=0;y<t.numOutputs;y++){f+=t.splitSizes[y],a[y]=f;let $=r.slice();$[t.axis]=t.splitSizes[y],m.push($),u[y]=F(`output${y}`,n,$.length),p.push({dims:m[y],dataType:e[0].dataType})}b.push({type:12,data:a},...j(r,...m));let _=y=>`\n  ${y.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",a.length).declareVariables(l,...u)}\n  ${Yc(a.length)}\n  ${Zc(u)}\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${l.offsetToIndices("global_idx")};\n    var index = ${l.indicesGet("indices",s)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${re("uniforms.size_in_split_axis","output_number - 1u",a.length)};\n      ${l.indicesSet("indices",s,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:_,getRunData:()=>({outputs:p,dispatchGroup:{x:Math.ceil(o/64)},programUniforms:b})}},Tu=(e,t)=>{Kc(e.inputs);let r=e.inputs.length===1?t:jc(e.inputs,t);e.compute(Qc(e.inputs,r),{inputs:[0]})},Eu=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return $e({axis:t,numOutputs:o,splitSizes:r})}});var Ou,Xc,Jc,ep,ku,Ru=q(()=>{"use strict";ie();_e();be();Ou=e=>Array.from(e.getBigInt64Array(),Number),Xc=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Ou(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Jc=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},ep=e=>{let t=e[0].dims,r=Ou(e[1]),o=Jc(t,r),n=z.size(o),s=e[0].dataType,u=M("input",s,t.length),l=F("output",s,o.length),a=p=>`\n      const inputShape = ${u.indices(...t)};\n      ${p.registerUniform("output_size","u32").declareVariables(u,l)}\n      ${p.mainStart()}\n      ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${l.offsetToIndices("global_idx")};\n      var input_indices: ${u.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let input_dim_i = ${u.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${l.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${u.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${l.setByOffset("global_idx",u.getByIndices("input_indices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:[{type:12,data:n},...j(e[0].dims,o)]}),getShaderSource:a}},ku=e=>{Xc(e.inputs),e.compute(ep(e.inputs),{inputs:[0]})}});var tp,rp,Bu,Du=q(()=>{"use strict";ie();_e();be();tp=(e,t,r,o,n)=>{let s=F("output_data",n,r.length,4),u=M("a_data",t[1].dataType,t[1].dims.length,4),l=M("b_data",t[2].dataType,t[2].dims.length,4),a=M("c_data",t[0].dataType,t[0].dims.length,4),p,m=(f,b,_)=>`select(${b}, ${f}, ${_})`;if(!o)p=s.setByOffset("global_idx",m(u.getByOffset("global_idx"),l.getByOffset("global_idx"),a.getByOffset("global_idx")));else{let f=(b,_,y="")=>{let $=`a_data[index_a${_}][component_a${_}]`,I=`b_data[index_b${_}][component_b${_}]`,C=`bool(c_data[index_c${_}] & (0xffu << (component_c${_} * 8)))`;return`\n            let output_indices${_} = ${s.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offset_a${_} = ${u.broadcastedIndicesToOffset(`output_indices${_}`,s)};\n            let offset_b${_} = ${l.broadcastedIndicesToOffset(`output_indices${_}`,s)};\n            let offset_c${_} = ${a.broadcastedIndicesToOffset(`output_indices${_}`,s)};\n            let index_a${_} = offset_a${_} / 4u;\n            let index_b${_} = offset_b${_} / 4u;\n            let index_c${_} = offset_c${_} / 4u;\n            let component_a${_} = offset_a${_} % 4u;\n            let component_b${_} = offset_b${_} % 4u;\n            let component_c${_} = offset_c${_} % 4u;\n            ${b}[${_}] = ${y}(${m($,I,C)});\n          `};n===9?p=`\n            var data = vec4<u32>(0);\n            ${f("data",0,"u32")}\n            ${f("data",1,"u32")}\n            ${f("data",2,"u32")}\n            ${f("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:p=`\n            ${f("output_data[global_idx]",0)}\n            ${f("output_data[global_idx]",1)}\n            ${f("output_data[global_idx]",2)}\n            ${f("output_data[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(a,u,l,s)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${p}\n      }`},rp=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,n=e[1].dataType,s=!(z.areEqual(t,r)&&z.areEqual(r,o)),u=t,l=z.size(t);if(s){let p=mt.calcShape(mt.calcShape(t,r,!1),o,!1);if(!p)throw new Error("Can\'t perform where op on the given tensors");u=p,l=z.size(u)}let a=Math.ceil(l/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:p=>tp(p,e,u,s,n),getRunData:()=>({outputs:[{dims:u,dataType:n}],dispatchGroup:{x:Math.ceil(l/64/4)},programUniforms:[{type:12,data:a},...j(o,t,r,u)]})}},Bu=e=>{e.compute(rp(e.inputs))}});var Mu,zu=q(()=>{"use strict";Qa();Hn();ei();ri();Ni();Qi();es();jn();fs();ys();_s();Cs();As();Ps();Rs();Ms();Us();Ns();Zn();Hs();Ks();Ys();pu();fu();Yr();bu();vu();Su();Au();Pu();Ru();Yt();en();Du();Mu=new Map([["Abs",[ni]],["Acos",[oi]],["Acosh",[ai]],["Add",[Wi]],["ArgMax",[Za,Gn]],["ArgMin",[Ya,Gn]],["Asin",[ii]],["Asinh",[si]],["Atan",[ui]],["Atanh",[di]],["Attention",[Xa]],["AveragePool",[nu,ru]],["BatchNormalization",[Ja]],["BiasAdd",[ti]],["BiasSplitGelu",[Vi]],["Cast",[ci,li]],["Ceil",[mi]],["Clip",[pi]],["Concat",[Xi,Ji]],["Conv",[Jn,Xn]],["ConvTranspose",[ms,ps]],["Cos",[fi]],["Cosh",[hi]],["CumSum",[hs,gs]],["Div",[Gi]],["Einsum",[vs,$s]],["Elu",[gi,Xr]],["Equal",[Hi]],["Erf",[yi]],["Exp",[bi]],["Expand",[Ss]],["FastGelu",[Is]],["Floor",[wi]],["FusedConv",[Jn,Xn]],["Gather",[Es,Ts]],["GatherElements",[ks,Os]],["Gelu",[vi]],["Gemm",[Ds,Bs]],["GlobalAveragePool",[iu,au]],["GlobalMaxPool",[cu,lu]],["Greater",[Ki]],["GreaterOrEqual",[Yi]],["HardSigmoid",[Ti,Ai]],["InstanceNormalization",[zs]],["LayerNormalization",[Vs]],["LeakyRelu",[$i,Xr]],["Less",[ji]],["LessOrEqual",[Zi]],["Log",[zi]],["MatMul",[is]],["MatMulNBits",[Ws,Gs]],["MaxPool",[uu,du]],["Mul",[Li]],["MultiHeadAttention",[qs,Fs]],["Neg",[xi]],["Not",[_i]],["Pad",[js]],["Pow",[Fi]],["Range",[mu]],["Reciprocal",[Si]],["ReduceMin",[Ha]],["ReduceMean",[Ua]],["ReduceMax",[Ga]],["ReduceSum",[Fa]],["ReduceProd",[La]],["ReduceL1",[Va]],["ReduceL2",[Na]],["ReduceLogSum",[Ka]],["ReduceLogSumExp",[Wa]],["ReduceSumSquare",[qa]],["Relu",[Ci]],["Resize",[gu,yu]],["Sigmoid",[Ii]],["Sin",[Ei]],["Sinh",[Pi]],["Slice",[_u,xu]],["SkipLayerNormalization",[wu]],["Split",[Tu,Eu]],["Sqrt",[Oi]],["Softmax",[Cu,Iu]],["Sub",[qi]],["Tan",[ki]],["Tanh",[Bi]],["ThresholdedRelu",[Mi,Xr]],["Tile",[ku]],["Transpose",[Ca,Ia]],["Where",[Bu]]])});var cn,Uu=q(()=>{"use strict";Kt();Pt();be();cn=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,n,s){Mt(t.programInfo.name);let u=this.backend.device,l=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let a=[];for(let m of r)a.push({binding:a.length,resource:{buffer:m.buffer}});for(let m of o)a.push({binding:a.length,resource:{buffer:m.buffer}});s&&a.push({binding:a.length,resource:s});let p=u.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:a,label:t.programInfo.name});if(this.backend.sessionStatus==="capturing"){let m={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:p,dispatchGroup:n};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(m)}l.setPipeline(t.computePipeline),l.setBindGroup(0,p),l.dispatchWorkgroups(...n),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Et(t.programInfo.name)}dispose(){}build(t,r){Mt(t.name);let o=this.backend.device,n=[];o.features.has("shader-f16")&&n.push("enable f16;");let s=xa(r),u=t.getShaderSource(s),l=`${n.join(`\n`)}\n${s.additionalImplementations}\n${u}`,a=o.createShaderModule({code:l,label:t.name});De("verbose",()=>`[WebGPU] ${t.name} shader code: ${l}`);let p=o.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto",label:t.name});return Et(t.name),{programInfo:t,computePipeline:p}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,n=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&o<=s&&n<=s)return[r,o,n];let u=r*o*n,l=Math.ceil(Math.sqrt(u));if(l>s){if(l=Math.ceil(Math.cbrt(u)),l>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[l,l,l]}else return[l,l,1]}}});var np,op,ao,pn,Vu=q(()=>{"use strict";Kt();ie();Pt();ba();_a();zu();Uu();np=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let n=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${n}`);break}case"rank":{let s=e[o].dims.length;r.push(`${n};${s}`);break}case"dims":{let s=e[o].dims.join(",");r.push(`${n};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},op=(e,t,r)=>{let o=e.name;return e.shaderCache?.hint&&(o+="["+e.shaderCache.hint+"]"),o+=":"+r+`:${np(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,o},ao=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},pn=class{constructor(){this.currentSessionId=null;this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.maxDispatchNumber=16;this.pendingDispatchNumber=0;this.pendingKernels=[];this.pendingQueries=new Map;this.sessionStatus="default";this.capturedCommandList=new Map;this.capturedPendingKernels=new Map;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,r){this.env=t;let o=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("chromium-experimental-timestamp-query-inside-passes")?o.push("chromium-experimental-timestamp-query-inside-passes"):r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(n),this.adapterInfo=new ao(await r.requestAdapterInfo()),this.gpuDataManager=$a(this),this.programManager=new cn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,ga(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:r,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),r={};this.queryType==="at-passes"&&(r.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(r)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Mt(),this.endComputePass();let t;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&t.mapAsync(GPUMapMode.READ).then(()=>{let r=new BigUint64Array(t.getMappedRange()),o=this.pendingQueries.get(t);for(let n=0;n<r.length/2;n++){let s=o[n],u=s.kernelId,l=this.kernels.get(u),a=l.kernelType,p=l.kernelName,m=s.programName,f=s.inputTensorViews,b=s.outputTensorViews,_=r[n*2],y=r[n*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=_);let $=Number(_-this.queryTimeBase),I=Number(y-this.queryTimeBase);if(!Number.isSafeInteger($)||!Number.isSafeInteger(I))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:f.map(C=>({dims:C.dims,dataType:Tt(C.dataType)})),outputsMetadata:b.map(C=>({dims:C.dims,dataType:Tt(C.dataType)})),kernelId:u,kernelType:a,kernelName:p,programName:m,startTime:$,endTime:I});else{let C="";f.forEach((A,T)=>{C+=`input[${T}]: [${A.dims}] | ${Tt(A.dataType)}, `});let v="";b.forEach((A,T)=>{v+=`output[${T}]: [${A.dims}] | ${Tt(A.dataType)}, `}),console.log(`[profiling] kernel "${u}|${a}|${p}|${m}" ${C}${v}execution time: ${I-$} ns`)}kn("GPU",`${m}::${_}::${y}`)}t.unmap(),this.pendingQueries.delete(t)}),Et()}run(t,r,o,n,s){Mt(t.name);let u=[];for(let v=0;v<r.length;++v){let A=r[v].data;if(A===0)continue;let T=this.gpuDataManager.get(A);if(!T)throw new Error(`no GPU data for input: ${A}`);u.push(T)}let{outputs:l,dispatchGroup:a,programUniforms:p}=t.getRunData(r),m=o.length===0?l.map((v,A)=>A):o;if(m.length!==l.length)throw new Error(`Output size ${m.length} must be equal to ${l.length}.`);let f=[],b=[];for(let v=0;v<l.length;++v){if(!Number.isInteger(m[v])||m[v]<-3||m[v]>=l.length)throw new Error(`Invalid output index: ${m[v]}`);if(m[v]===-3)continue;let A=m[v]===-1,T=m[v]===-2,D=A||T?s(l[v].dataType,l[v].dims):n(m[v],l[v].dataType,l[v].dims);if(f.push(D),D.data===0)continue;let U=this.gpuDataManager.get(D.data);if(!U)throw new Error(`no GPU data for output: ${D.data}`);if(A&&this.temporaryData.push(U),T){let V=this.kernelPersistentData.get(this.currentKernelId);V||(V=[],this.kernelPersistentData.set(this.currentKernelId,V)),V.push(U)}b.push(U)}if(u.length!==r.length||b.length!==f.length){if(b.length===0)return Et(t.name),f;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let _;if(p){let v=0,A=[];p.forEach(V=>{let H=typeof V.data=="number"?[V.data]:V.data;if(H.length===0)return;let R=V.type===10?2:4,L,pe;V.type===10?(pe=H.length>4?16:H.length>2?8:H.length*R,L=H.length>4?16:R*H.length):(pe=H.length<=2?H.length*R:16,L=16),v=Math.ceil(v/pe)*pe,A.push(v);let Ie=V.type===10?8:4;v+=H.length>4?Math.ceil(H.length/Ie)*L:H.length*R});let T=16;v=Math.ceil(v/T)*T;let D=new ArrayBuffer(v);p.forEach((V,H)=>{let R=A[H],L=typeof V.data=="number"?[V.data]:V.data;if(V.type===6)new Int32Array(D,R,L.length).set(L);else if(V.type===12)new Uint32Array(D,R,L.length).set(L);else if(V.type===10)new Uint16Array(D,R,L.length).set(L);else if(V.type===1)new Float32Array(D,R,L.length).set(L);else throw new Error(`Unsupported uniform type: ${Tt(V.type)}`)});let U=this.gpuDataManager.create(v,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(U.buffer,0,D,0,v),this.gpuDataManager.release(U.id),_={offset:0,size:v,buffer:U.buffer}}let y=this.programManager.normalizeDispatchGroupSize(a),$=y[1]===1&&y[2]===1,I=op(t,r,$),C=this.programManager.getArtifact(I);if(C||(C=this.programManager.build(t,y),this.programManager.setArtifact(I,C),De("info",()=>`[artifact] key: ${I}, programName: ${t.name}`)),De("info",()=>`[ProgramManager] run "${t.name}" (key=${I}) with ${y[0]}x${y[1]}x${y[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let v={kernelId:this.currentKernelId,programName:C.programInfo.name,inputTensorViews:r,outputTensorViews:f};this.pendingKernels.push(v),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(v)}return this.programManager.run(C,u,b,y,_),Et(t.name),f}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,n){let s=Mu.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);let u={kernelType:t,kernelName:n,kernelEntry:s[0],attributes:[s[1],o]};this.kernels.set(r,u)}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let n=this.kernels.get(t);if(!n)throw new Error(`kernel not created: ${t}`);let s=n.kernelType,u=n.kernelName,l=n.kernelEntry,a=n.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),De("info",()=>`[WebGPU] Start to run kernel "[${s}] ${u}"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope("validation"),l(r,a[1]),0}catch(m){return o.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${u}" failed. ${m}`)),1}finally{p&&o.push(this.device.popErrorScope().then(m=>m?`GPU validation error for kernel "[${s}] ${u}": ${m.message}`:null));for(let m of this.temporaryData)this.gpuDataManager.release(m.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,n){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let u=s.get(r),l=this.gpuDataManager.registerExternalBuffer(o,n,u?.[1]);return s.set(r,[l,o]),l}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let n=await Dn(this,t,r);return ya(n.buffer,o)}}writeTimestamp(t){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){De("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){De("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){De("info","replay"),this.sessionStatus="replaying";let t=this.capturedCommandList.get(this.currentSessionId),r=this.capturedPendingKernels.get(this.currentSessionId),o=t.length;this.pendingKernels=[];for(let n=0;n<o;n++){let s=this.getComputePassEncoder(),u=t[n];this.writeTimestamp(this.pendingDispatchNumber*2),s.setPipeline(u.computePipeline),s.setBindGroup(0,u.bindGroup),s.dispatchWorkgroups(...u.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(r[n]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}});var Nu={};Mr(Nu,{init:()=>ap});var wr,io,ap,Wu=q(()=>{"use strict";ie();Vu();Pt();_e();wr=class e{constructor(t,r,o,n){this.module=t;this.dataType=r;this.data=o;this.dims=n}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(z.size(t)!==z.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},io=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;this.adapterInfo=r.adapterInfo;let n=t.HEAPU32,s=o>>>2;this.opKernelContext=n[s++];let u=n[s++];this.outputCount=n[s++],this.customDataOffset=n[s++],this.customDataSize=n[s++];let l=[];for(let a=0;a<u;a++){let p=n[s++],m=n[s++],f=n[s++],b=[];for(let _=0;_<f;_++)b.push(n[s++]);l.push(new wr(t,p,m,b))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let o=r?.inputs?.map(l=>typeof l=="number"?this.inputs[l]:l)??this.inputs,n=r?.outputs??[],s=(l,a,p)=>new wr(this.module,a,this.output(l,p),p),u=(l,a)=>{let p=fr(l);if(!p)throw new Error(`Unsupported data type: ${l}`);let m=p*z.size(a),f=m>0?this.backend.gpuDataManager.create(m).id:0;return new wr(this.module,l,f,a)};return this.backend.run(t,o,n,s,u)}output(t,r){let o=this.module.stackSave();try{let n=this.module.stackAlloc((1+r.length)*4),s=n>>2;this.module.HEAPU32[s++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[s++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(o)}}},ap=async(e,t,r,o)=>{let n=t.jsepInit;if(!n)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(e==="webgpu"){let s=new pn;await s.initialize(r,o),n("webgpu",[s,u=>s.alloc(u),u=>s.free(u),(u,l,a,p=!1)=>{if(p)De("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${u}, dst=${l}, size=${a}`),s.memcpy(u,l);else{De("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${u}, gpuDataId=${l}, size=${a}`);let m=t.HEAPU8.subarray(u>>>0,(u>>>0)+a);s.upload(l,m)}},async(u,l,a)=>{De("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${u}, dataOffset=${l}, size=${a}`),await s.download(u,()=>t.HEAPU8.subarray(l>>>0,(l>>>0)+a))},(u,l,a)=>s.createKernel(u,l,a,t.UTF8ToString(t._JsepGetNodeName(l))),u=>s.releaseKernel(u),(u,l,a,p)=>{De("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${a}, kernel=${u}, contextDataOffset=${l}`);let m=new io(t,s,l);return s.computeKernel(u,m,p)},()=>s.captureBegin(),()=>s.captureEnd(),()=>s.replay()])}else n("webnn")}});var Ho;Ho=Ro();var bd=No(),An,Tn=!1,zr=!1,Go=!1,wd=e=>{if(e===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+e+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+e+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},vd=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},$d=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Lo=async e=>{if(Tn)return Promise.resolve();if(zr)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Go)throw new Error("previous call to \'initializeWebAssembly()\' failed.");zr=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,n=wd(r),s=o&&vd(),u=e.wasmPaths,l=typeof u=="string"?u:void 0,a=$d(s,n),p=typeof u=="object"?u[a]:void 0,m=!1,f=[];if(t>0&&f.push(new Promise(b=>{setTimeout(()=>{m=!0,b()},t)})),f.push(new Promise((b,_)=>{let y=n?bd:Ho,$={locateFile:(I,C)=>{if(n&&I.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Wo()],{type:"text/javascript"}));if(I.endsWith(".wasm")){if(p)return p;let v=l??C;return a==="ort-wasm-simd.wasm"?v+"ort-wasm-simd.jsep.wasm":a==="ort-wasm-simd-threaded.wasm"?v+"ort-wasm-simd-threaded.jsep.wasm":v+a}return C+I}};if(n)if($.numThreads=r,typeof Blob>"u")$.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let I=`var ortWasmThreaded=${y.toString()};`;$.mainScriptUrlOrBlob=new Blob([I],{type:"text/javascript"})}y($).then(I=>{zr=!1,Tn=!0,An=I,b()},I=>{zr=!1,Go=!0,_(I)})})),await Promise.race(f),m)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},We=()=>{if(Tn&&An)return An;throw new Error("WebAssembly is not initialized yet.")};var Ge=(e,t)=>{let r=We(),o=r.lengthBytesUTF8(e)+1,n=r._malloc(o);return r.stringToUTF8(e,n,o),t.push(n),n},mr=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,s])=>{let u=t?t+n:n;if(typeof s=="object")mr(s,u+".",r,o);else if(typeof s=="string"||typeof s=="number")o(u,s.toString());else if(typeof s=="boolean")o(u,s?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof s}`)})},Be=e=>{let t=We(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let n=t.HEAP32[o/4],s=t.HEAPU32[o/4+1],u=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}};var Fo=e=>{let t=We(),r=0,o=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let s=0;return e?.tag!==void 0&&(s=Ge(e.tag,o)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&Be("Can\'t create run options."),e?.extra!==void 0&&mr(e.extra,"",new WeakSet,(u,l)=>{let a=Ge(u,o),p=Ge(l,o);t._OrtAddRunConfigEntry(r,a,p)!==0&&Be(`Can\'t set a run config entry: ${u} - ${l}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(u=>t._free(u)),s}};var _d=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},xd=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Sd=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},Cd=(e,t,r)=>{for(let o of t){let n=typeof o=="string"?o:o.name;switch(n){case"webnn":if(n="WEBNN",typeof o!="string"){let u=o;if(u?.deviceType){let l=Ge("deviceType",r),a=Ge(u.deviceType,r);We()._OrtAddSessionConfigEntry(e,l,a)!==0&&Be(`Can\'t set a session config entry: \'deviceType\' - ${u.deviceType}.`)}if(u?.numThreads){let l=u.numThreads;(typeof l!="number"||!Number.isInteger(l)||l<0)&&(l=0);let a=Ge("numThreads",r),p=Ge(l.toString(),r);We()._OrtAddSessionConfigEntry(e,a,p)!==0&&Be(`Can\'t set a session config entry: \'numThreads\' - ${u.numThreads}.`)}if(u?.powerPreference){let l=Ge("powerPreference",r),a=Ge(u.powerPreference,r);We()._OrtAddSessionConfigEntry(e,l,a)!==0&&Be(`Can\'t set a session config entry: \'powerPreference\' - ${u.powerPreference}.`)}}break;case"webgpu":if(n="JS",typeof o!="string"){let u=o;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${u.preferredLayout}`);let l=Ge("preferredLayout",r),a=Ge(u.preferredLayout,r);We()._OrtAddSessionConfigEntry(e,l,a)!==0&&Be(`Can\'t set a session config entry: \'preferredLayout\' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let s=Ge(n,r);We()._OrtAppendExecutionProvider(e,s)!==0&&Be(`Can\'t append execution provider: ${n}.`)}},qo=e=>{let t=We(),r=0,o=[],n=e||{};Sd(n);try{let s=_d(n.graphOptimizationLevel??"all"),u=xd(n.executionMode??"sequential"),l=typeof n.logId=="string"?Ge(n.logId,o):0,a=n.logSeverityLevel??2;if(!Number.isInteger(a)||a<0||a>4)throw new Error(`log serverity level is not valid: ${a}`);let p=n.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let m=typeof n.optimizedModelFilePath=="string"?Ge(n.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,u,!!n.enableProfiling,0,l,a,p,m),r===0&&Be("Can\'t create session options."),n.executionProviders&&Cd(r,n.executionProviders,o),n.enableGraphCapture!==void 0){if(typeof n.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${n.enableGraphCapture}`);let f=Ge("enableGraphCapture",o),b=Ge(n.enableGraphCapture.toString(),o);t._OrtAddSessionConfigEntry(r,f,b)!==0&&Be(`Can\'t set a session config entry: \'enableGraphCapture\' - ${n.enableGraphCapture}.`)}if(n.freeDimensionOverrides)for(let[f,b]of Object.entries(n.freeDimensionOverrides)){if(typeof f!="string")throw new Error(`free dimension override name must be a string: ${f}`);if(typeof b!="number"||!Number.isInteger(b)||b<0)throw new Error(`free dimension override value must be a non-negative integer: ${b}`);let _=Ge(f,o);t._OrtAddFreeDimensionOverride(r,_,b)!==0&&Be(`Can\'t set a free dimension override: ${f} - ${b}.`)}return n.extra!==void 0&&mr(n.extra,"",new WeakSet,(f,b)=>{let _=Ge(f,o),y=Ge(b,o);t._OrtAddSessionConfigEntry(r,_,y)!==0&&Be(`Can\'t set a session config entry: ${f} - ${b}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(u=>t._free(u)),s}};ie();var jo=async e=>{if(typeof e=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(e))}catch(t){if(t.code==="ERR_FS_FILE_TOO_LARGE"){let r=(void 0)(e),o=[];for await(let n of r)o.push(n);return new Uint8Array(Buffer.concat(o))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let r=t.headers.get("Content-Length"),o=r?parseInt(r,10):0;if(o<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let n=t.body.getReader(),s;try{s=new ArrayBuffer(o)}catch(l){if(l instanceof RangeError){let a=Math.ceil(o/65536);s=new WebAssembly.Memory({initial:a,maximum:a}).buffer}else throw l}let u=0;for(;;){let{done:l,value:a}=await n.read();if(l)break;let p=a.byteLength;new Uint8Array(s,u,p).set(a),u+=p}return new Uint8Array(s,0,o)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)};var ip=(e,t)=>{We()._OrtInit(e,t)!==0&&Be("Can\'t initialize onnxruntime.")},Hu=async e=>{ip(e.wasm.numThreads,hr(e.logLevel))},Lu=async(e,t)=>{{let r=(Wu(),Ft(Nu)).init;if(t==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let o=e.webgpu.adapter;if(o){if(typeof o.limits!="object"||typeof o.features!="object"||typeof o.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let n=e.webgpu.powerPreference;if(n!==void 0&&n!=="low-power"&&n!=="high-performance")throw new Error(`Invalid powerPreference setting: "${n}"`);let s=e.webgpu.forceFallbackAdapter;if(s!==void 0&&typeof s!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${s}"`);if(o=await navigator.gpu.requestAdapter({powerPreference:n,forceFallbackAdapter:s}),!o)throw new Error(\'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.\')}if(!e.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");await r("webgpu",We(),e,o)}if(t==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await r("webnn",We(),e)}}},Ut=new Map,sp=e=>{let t=We(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Be("Can\'t get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},so=e=>{let t=We(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Fu=async(e,t)=>{let r,o,n=We();Array.isArray(e)?[r,o]=e:e.buffer===n.HEAPU8.buffer?[r,o]=[e.byteOffset,e.byteLength]:[r,o]=so(e);let s=0,u=0,l=0,a=[],p=[],m=[];try{if([u,a]=qo(t),t?.externalData&&n.mountExternalData){let v=[];for(let A of t.externalData){let T=typeof A=="string"?A:A.path;v.push(jo(typeof A=="string"?A:A.data).then(D=>{n.mountExternalData(T,D)}))}await Promise.all(v)}s=await n._OrtCreateSession(r,o,u),s===0&&Be("Can\'t create a session.");let[f,b]=sp(s),_=!!t?.enableGraphCapture,y=[],$=[],I=[];for(let v=0;v<f;v++){let A=n._OrtGetInputName(s,v);A===0&&Be("Can\'t get an input name."),p.push(A),y.push(n.UTF8ToString(A))}for(let v=0;v<b;v++){let A=n._OrtGetOutputName(s,v);A===0&&Be("Can\'t get an output name."),m.push(A);let T=n.UTF8ToString(A);$.push(T);{if(_&&t?.preferredOutputLocation===void 0){I.push("gpu-buffer");continue}let D=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[T]??"cpu";if(D!=="cpu"&&D!=="cpu-pinned"&&D!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${D}.`);if(_&&D!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${D}. Only \'gpu-buffer\' location is supported when enableGraphCapture is true.`);I.push(D)}}let C=null;return I.some(v=>v==="gpu-buffer")&&(l=n._OrtCreateBinding(s),l===0&&Be("Can\'t create IO binding."),C={handle:l,outputPreferredLocations:I,outputPreferredLocationsEncoded:I.map(v=>Pn(v))}),Ut.set(s,[s,p,m,C,_,!1]),[s,y,$]}catch(f){throw p.forEach(b=>n._OrtFree(b)),m.forEach(b=>n._OrtFree(b)),l!==0&&n._OrtReleaseBinding(l),s!==0&&n._OrtReleaseSession(s),f}finally{n._free(r),u!==0&&n._OrtReleaseSessionOptions(u),a.forEach(f=>n._free(f)),n.unmountExternalData?.()}},qu=e=>{let t=We(),r=Ut.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,n,s,u,l]=r;u&&(l&&t._OrtClearBoundOutputs(u.handle),t._OrtReleaseBinding(u.handle)),t.jsepOnReleaseSession?.(e),n.forEach(a=>t._OrtFree(a)),s.forEach(a=>t._OrtFree(a)),t._OrtReleaseSession(o),Ut.delete(e)},Gu=(e,t,r,o,n,s=!1)=>{if(!e){t.push(0);return}let u=We(),l=e[0],a=e[1],p=e[3],m,f;if(l==="string"&&p==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(s&&p!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${n} when enableGraphCapture is true.`);if(p==="gpu-buffer"){let y=e[2].gpuBuffer,$=fr(En(l));f=a.reduce((C,v)=>C*v,1)*$;let I=u.jsepRegisterBuffer;if(!I)throw new Error(\'Tensor location "gpu-buffer" is not supported without using WebGPU.\');m=I(o,n,y,f)}else{let y=e[2];if(Array.isArray(y)){f=4*y.length,m=u._malloc(f),r.push(m);let $=m/4;for(let I=0;I<y.length;I++){if(typeof y[I]!="string")throw new TypeError(`tensor data at index ${I} is not a string`);u.HEAPU32[$++]=Ge(y[I],r)}}else f=y.byteLength,m=u._malloc(f),r.push(m),u.HEAPU8.set(new Uint8Array(y.buffer,y.byteOffset,f),m)}let b=u.stackSave(),_=u.stackAlloc(4*a.length);try{let y=_/4;a.forEach(I=>u.HEAP32[y++]=I);let $=u._OrtCreateTensor(En(l),m,f,_,a.length,Pn(p));$===0&&Be(`Can\'t create tensor for input/output. session=${o}, index=${n}.`),t.push($)}finally{u.stackRestore(b)}},Ku=async(e,t,r,o,n,s)=>{let u=We(),l=Ut.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let a=l[0],p=l[1],m=l[2],f=l[3],b=l[4],_=l[5],y=t.length,$=o.length,I=0,C=[],v=[],A=[],T=[],D=u.stackSave(),U=u.stackAlloc(y*4),V=u.stackAlloc(y*4),H=u.stackAlloc($*4),R=u.stackAlloc($*4);try{[I,C]=Fo(s);for(let Q=0;Q<y;Q++)Gu(r[Q],v,T,e,t[Q],b);for(let Q=0;Q<$;Q++)Gu(n[Q],A,T,e,y+o[Q],b);let L=U/4,pe=V/4,Ie=H/4,we=R/4;for(let Q=0;Q<y;Q++)u.HEAPU32[L++]=v[Q],u.HEAPU32[pe++]=p[t[Q]];for(let Q=0;Q<$;Q++)u.HEAPU32[Ie++]=A[Q],u.HEAPU32[we++]=m[o[Q]];if(f&&!_){let{handle:Q,outputPreferredLocations:xe,outputPreferredLocationsEncoded:me}=f;if(p.length!==y)throw new Error(`input count from feeds (${y}) is expected to be always equal to model\'s input count (${p.length}).`);for(let ue=0;ue<y;ue++){let se=t[ue];await u._OrtBindInput(Q,p[se],v[ue])!==0&&Be(`Can\'t bind input[${ue}] for session=${e}.`)}for(let ue=0;ue<$;ue++){let se=o[ue];n[ue]?.[3]?u._OrtBindOutput(Q,m[se],A[ue],0)!==0&&Be(`Can\'t bind pre-allocated output[${ue}] for session=${e}.`):u._OrtBindOutput(Q,m[se],0,me[se])!==0&&Be(`Can\'t bind output[${ue}] to ${xe[ue]} for session=${e}.`)}Ut.set(e,[a,p,m,f,b,!0])}u.jsepOnRunStart?.(a);let ne;f?ne=await u._OrtRunWithBinding(a,f.handle,$,H,I):ne=await u._OrtRun(a,V,U,y,R,$,H,I),ne!==0&&Be("failed to call OrtRun().");let ze=[];for(let Q=0;Q<$;Q++){let xe=u.HEAPU32[H/4+Q];if(xe===A[Q]){ze.push(n[Q]);continue}let me=u.stackSave(),ue=u.stackAlloc(4*4),se=!1,he,Ae=0;try{u._OrtGetTensorData(xe,ue,ue+4,ue+8,ue+12)!==0&&Be(`Can\'t access output tensor data on index ${Q}.`);let G=ue/4,J=u.HEAPU32[G++];Ae=u.HEAPU32[G++];let Se=u.HEAPU32[G++],Qe=u.HEAPU32[G++],Xe=[];for(let Ne=0;Ne<Qe;Ne++)Xe.push(u.HEAPU32[Se/4+Ne]);u._OrtFree(Se);let Le=Xe.reduce((Ne,Fe)=>Ne*Fe,1);he=Tt(J);let wt=f?.outputPreferredLocations[o[Q]];if(he==="string"){if(wt==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ne=[],Fe=Ae/4;for(let Je=0;Je<Le;Je++){let kt=u.HEAPU32[Fe++],vt=Je===Le-1?void 0:u.HEAPU32[Fe]-kt;Ne.push(u.UTF8ToString(kt,vt))}ze.push([he,Xe,Ne,"cpu"])}else if(wt==="gpu-buffer"&&Le>0){let Ne=u.jsepGetBuffer;if(!Ne)throw new Error(\'preferredLocation "gpu-buffer" is not supported without using WebGPU.\');let Fe=Ne(Ae),Je=fr(J);if(Je===void 0||!Ko(he))throw new Error(`Unsupported data type: ${he}`);se=!0,ze.push([he,Xe,{gpuBuffer:Fe,download:u.jsepCreateDownloader(Fe,Le*Je,he),dispose:()=>{u._OrtReleaseTensor(xe)}},"gpu-buffer"])}else{let Ne=Ur(he),Fe=new Ne(Le);new Uint8Array(Fe.buffer,Fe.byteOffset,Fe.byteLength).set(u.HEAPU8.subarray(Ae,Ae+Fe.byteLength)),ze.push([he,Xe,Fe,"cpu"])}}finally{u.stackRestore(me),he==="string"&&Ae&&u._free(Ae),se||u._OrtReleaseTensor(xe)}}return f&&!b&&(u._OrtClearBoundOutputs(f.handle),Ut.set(e,[a,p,m,f,b,!1])),ze}finally{u.stackRestore(D),v.forEach(L=>u._OrtReleaseTensor(L)),A.forEach(L=>u._OrtReleaseTensor(L)),T.forEach(L=>u._free(L)),I!==0&&u._OrtReleaseRunOptions(I),C.forEach(L=>u._free(L))}},ju=e=>{let t=We(),r=Ut.get(e);if(!r)throw new Error("invalid session id");let o=r[0],n=t._OrtEndProfiling(o);n===0&&Be("Can\'t get an profile file name."),t._OrtFree(n)},Yu=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t};self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case"init-wasm":Lo(r.wasm).then(()=>{Hu(r).then(()=>{postMessage({type:t})},o=>{postMessage({type:t,err:o})})},o=>{postMessage({type:t,err:o})});break;case"init-ep":{let{epName:o,env:n}=r;Lu(n,o).then(()=>{postMessage({type:t})},s=>{postMessage({type:t,err:s})});break}case"copy-from":{let{buffer:o}=r,n=so(o);postMessage({type:t,out:n});break}case"create":{let{model:o,options:n}=r;Fu(o,n).then(s=>{postMessage({type:t,out:s})},s=>{postMessage({type:t,err:s})});break}case"release":qu(r),postMessage({type:t});break;case"run":{let{sessionId:o,inputIndices:n,inputs:s,outputIndices:u,options:l}=r;Ku(o,n,s,u,new Array(u.length).fill(null),l).then(a=>{a.some(p=>p[3]!=="cpu")?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:a},Yu([...s,...a]))},a=>{postMessage({type:t,err:a})});break}case"end-profiling":ju(r),postMessage({type:t});break;default:}}catch(o){postMessage({type:t,err:o})}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'}),Kt,ct,Rr,zn,Bn,Ba,Da,or,sr,ff,Rn,Ul,Nl,Wl,Vl,Gl,Hl,Ll,Ma=F(()=>{var a;lt(),Dl(),nr(),Kt=()=>!!Ae.wasm.proxy&&typeof document<"u",Rr=!1,zn=!1,Bn=!1,Da=new Map,or=(e,o)=>{let s=Da.get(e);s?s.push(o):Da.set(e,[o])},sr=()=>{if(Rr||!zn||Bn||!ct)throw new Error("worker not ready")},ff=e=>{switch(e.data.type){case"init-wasm":Rr=!1,e.data.err?(Bn=!0,Ba[1](e.data.err)):(zn=!0,Ba[0]());break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let o=Da.get(e.data.type);e.data.err?o.shift()[1](e.data.err):o.shift()[0](e.data.out);break}}},Rn=typeof document<"u"?(a=document==null?void 0:document.currentScript)==null?void 0:a.src:void 0,Ul=async()=>{if(!zn){if(Rr)throw new Error("multiple calls to 'initWasm()' detected.");if(Bn)throw new Error("previous call to 'initWasm()' failed.");if(Rr=!0,Kt())return Ae.wasm.wasmPaths===void 0&&Rn&&Rn.indexOf("blob:")!==0&&(Ae.wasm.wasmPaths=Rn.substr(0,+Rn.lastIndexOf("/")+1)),new Promise((e,o)=>{ct==null||ct.terminate();let s=URL.createObjectURL(new Blob([Ml()],{type:"text/javascript"}));ct=new Worker(s,{name:"ort-wasm-proxy-worker"}),ct.onerror=c=>o(c),ct.onmessage=ff,URL.revokeObjectURL(s),Ba=[e,o];let d={type:"init-wasm",in:Ae};ct.postMessage(d)});try{await Ki(Ae.wasm),await Tl(Ae),zn=!0}catch(e){throw Bn=!0,e}finally{Rr=!1}}},Nl=async e=>{if(Kt())return sr(),new Promise((o,s)=>{or("init-ep",[o,s]);let d={type:"init-ep",in:{epName:e,env:Ae}};ct.postMessage(d)});await Ol(Ae,e)},Wl=async e=>Kt()?(sr(),new Promise((o,s)=>{or("copy-from",[o,s]);let d={type:"copy-from",in:{buffer:e}};ct.postMessage(d,[e.buffer])})):za(e),Vl=async(e,o)=>{if(Kt()){if(o!=null&&o.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return sr(),new Promise((s,d)=>{or("create",[s,d]);let c={type:"create",in:{model:e,options:{...o}}},h=[];e instanceof Uint8Array&&h.push(e.buffer),ct.postMessage(c,h)})}else return kl(e,o)},Gl=async e=>{if(Kt())return sr(),new Promise((o,s)=>{or("release",[o,s]);let d={type:"release",in:e};ct.postMessage(d)});Pl(e)},Hl=async(e,o,s,d,c,h)=>{if(Kt()){if(s.some(_=>_[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(c.some(_=>_))throw new Error("pre-allocated output tensor is not supported for proxy.");return sr(),new Promise((_,bt)=>{or("run",[_,bt]);let g=s,j={type:"run",in:{sessionId:e,inputIndices:o,inputs:g,outputIndices:d,options:h}};ct.postMessage(j,Bl(g))})}else return Rl(e,o,s,d,c,h)},Ll=async e=>{if(Kt())return sr(),new Promise((o,s)=>{or("end-profiling",[o,s]);let d={type:"end-profiling",in:e};ct.postMessage(d)});zl(e)}}),Fl,mf,Dn,ql=F(()=>{lt(),Ma(),ie(),oa(),Fl=(a,e)=>{switch(a.location){case"cpu":return[a.type,a.dims,a.data,"cpu"];case"gpu-buffer":return[a.type,a.dims,{gpuBuffer:a.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${a.location} for ${e()}`)}},mf=a=>{switch(a[3]){case"cpu":return new Ze(a[0],a[2],a[1]);case"gpu-buffer":{let e=a[0];if(!un(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:o,download:s,dispose:d}=a[2];return Ze.fromGpuBuffer(o,{dataType:e,dims:a[1],download:s,dispose:d})}default:throw new Error(`invalid data location: ${a[3]}`)}},Dn=class{async fetchModelAndCopyToWasmMemory(a){return Wl(await Ar(a))}async loadModel(a,e){st();let o;typeof a=="string"?typeof process<"u"&&process.versions&&process.versions.node?o=await Ar(a):o=await this.fetchModelAndCopyToWasmMemory(a):o=a,[this.sessionId,this.inputNames,this.outputNames]=await Vl(o,e),nt()}async dispose(){return Gl(this.sessionId)}async run(a,e,o){st();let s=[],d=[];Object.entries(a).forEach(b=>{let Et=b[0],It=b[1],zt=this.inputNames.indexOf(Et);if(zt===-1)throw new Error(`invalid input '${Et}'`);s.push(It),d.push(zt)});let c=[],h=[];Object.entries(e).forEach(b=>{let Et=b[0],It=b[1],zt=this.outputNames.indexOf(Et);if(zt===-1)throw new Error(`invalid output '${Et}'`);c.push(It),h.push(zt)});let _=s.map((b,Et)=>Fl(b,()=>`input "${this.inputNames[d[Et]]}"`)),bt=c.map((b,Et)=>b?Fl(b,()=>`output "${this.outputNames[h[Et]]}"`):null),g=await Hl(this.sessionId,d,_,h,bt,o),j={};for(let b=0;b<g.length;b++)j[this.outputNames[h[b]]]=c[b]??mf(g[b]);return nt(),j}startProfiling(){}endProfiling(){Ll(this.sessionId)}}}),hf,Mn,jl=F(()=>{lt(),Ma(),ql(),hf=()=>{if((typeof Ae.wasm.initTimeout!="number"||Ae.wasm.initTimeout<0)&&(Ae.wasm.initTimeout=0),typeof Ae.wasm.simd!="boolean"&&(Ae.wasm.simd=!0),typeof Ae.wasm.proxy!="boolean"&&(Ae.wasm.proxy=!1),typeof Ae.wasm.trace!="boolean"&&(Ae.wasm.trace=!1),typeof Ae.wasm.numThreads!="number"||!Number.isInteger(Ae.wasm.numThreads)||Ae.wasm.numThreads<=0){(typeof self<"u"&&!self.crossOriginIsolated||typeof process<"u"&&process.versions&&process.versions.node)&&(Ae.wasm.numThreads=1);let a=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;Ae.wasm.numThreads=Math.min(4,Math.ceil((a||1)/2))}},Mn=class{async init(a){hf(),await Ul(),await Nl(a)}async createInferenceSessionHandler(a,e){let o=new Dn;return await o.loadModel(a,e),Promise.resolve(o)}}}),Kl={};rr(Kl,{wasmBackend:()=>gf});var gf,Yl=F(()=>{jl(),gf=new Mn});lt();lt();lt();var Ri="1.17.3",Kv=Yn;{let a=(Yl(),Gt(Kl)).wasmBackend;Lt("webgpu",a,5),Lt("webnn",a,5),Lt("cpu",a,10),Lt("wasm",a,10)}Object.defineProperty(Ae.versions,"web",{value:Ri,enumerable:!0});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ort_gpu=Object.freeze(Object.defineProperty({__proto__:null,get InferenceSession(){return md},get TRACE(){return tn},get TRACE_FUNC_BEGIN(){return st},get TRACE_FUNC_END(){return nt},get Tensor(){return Ze},get TrainingSession(){return gd},default:Kv,get env(){return Ae},get registerBackend(){return Lt}},Symbol.toStringTag,{value:"Module"}));var util;(function(a){a.assertEqual=d=>d;function e(d){}a.assertIs=e;function o(d){throw new Error}a.assertNever=o,a.arrayToEnum=d=>{const c={};for(const h of d)c[h]=h;return c},a.getValidEnumValues=d=>{const c=a.objectKeys(d).filter(_=>typeof d[d[_]]!="number"),h={};for(const _ of c)h[_]=d[_];return a.objectValues(h)},a.objectValues=d=>a.objectKeys(d).map(function(c){return d[c]}),a.objectKeys=typeof Object.keys=="function"?d=>Object.keys(d):d=>{const c=[];for(const h in d)Object.prototype.hasOwnProperty.call(d,h)&&c.push(h);return c},a.find=(d,c)=>{for(const h of d)if(c(h))return h},a.isInteger=typeof Number.isInteger=="function"?d=>Number.isInteger(d):d=>typeof d=="number"&&isFinite(d)&&Math.floor(d)===d;function s(d,c=" | "){return d.map(h=>typeof h=="string"?`'${h}'`:h).join(c)}a.joinValues=s,a.jsonStringifyReplacer=(d,c)=>typeof c=="bigint"?c.toString():c})(util||(util={}));var objectUtil;(function(a){a.mergeShapes=(e,o)=>({...e,...o})})(objectUtil||(objectUtil={}));const ZodParsedType=util.arrayToEnum(["string","nan","number","integer","float","boolean","date","bigint","symbol","function","undefined","null","array","object","unknown","promise","void","never","map","set"]),getParsedType=a=>{switch(typeof a){case"undefined":return ZodParsedType.undefined;case"string":return ZodParsedType.string;case"number":return isNaN(a)?ZodParsedType.nan:ZodParsedType.number;case"boolean":return ZodParsedType.boolean;case"function":return ZodParsedType.function;case"bigint":return ZodParsedType.bigint;case"symbol":return ZodParsedType.symbol;case"object":return Array.isArray(a)?ZodParsedType.array:a===null?ZodParsedType.null:a.then&&typeof a.then=="function"&&a.catch&&typeof a.catch=="function"?ZodParsedType.promise:typeof Map<"u"&&a instanceof Map?ZodParsedType.map:typeof Set<"u"&&a instanceof Set?ZodParsedType.set:typeof Date<"u"&&a instanceof Date?ZodParsedType.date:ZodParsedType.object;default:return ZodParsedType.unknown}},ZodIssueCode=util.arrayToEnum(["invalid_type","invalid_literal","custom","invalid_union","invalid_union_discriminator","invalid_enum_value","unrecognized_keys","invalid_arguments","invalid_return_type","invalid_date","invalid_string","too_small","too_big","invalid_intersection_types","not_multiple_of","not_finite"]),quotelessJson=a=>JSON.stringify(a,null,2).replace(/"([^"]+)":/g,"$1:");class ZodError extends Error{constructor(e){super(),this.issues=[],this.addIssue=s=>{this.issues=[...this.issues,s]},this.addIssues=(s=[])=>{this.issues=[...this.issues,...s]};const o=new.target.prototype;Object.setPrototypeOf?Object.setPrototypeOf(this,o):this.__proto__=o,this.name="ZodError",this.issues=e}get errors(){return this.issues}format(e){const o=e||function(c){return c.message},s={_errors:[]},d=c=>{for(const h of c.issues)if(h.code==="invalid_union")h.unionErrors.map(d);else if(h.code==="invalid_return_type")d(h.returnTypeError);else if(h.code==="invalid_arguments")d(h.argumentsError);else if(h.path.length===0)s._errors.push(o(h));else{let _=s,bt=0;for(;bt<h.path.length;){const g=h.path[bt];bt===h.path.length-1?(_[g]=_[g]||{_errors:[]},_[g]._errors.push(o(h))):_[g]=_[g]||{_errors:[]},_=_[g],bt++}}};return d(this),s}static assert(e){if(!(e instanceof ZodError))throw new Error(`Not a ZodError: ${e}`)}toString(){return this.message}get message(){return JSON.stringify(this.issues,util.jsonStringifyReplacer,2)}get isEmpty(){return this.issues.length===0}flatten(e=o=>o.message){const o={},s=[];for(const d of this.issues)d.path.length>0?(o[d.path[0]]=o[d.path[0]]||[],o[d.path[0]].push(e(d))):s.push(e(d));return{formErrors:s,fieldErrors:o}}get formErrors(){return this.flatten()}}ZodError.create=a=>new ZodError(a);const errorMap=(a,e)=>{let o;switch(a.code){case ZodIssueCode.invalid_type:a.received===ZodParsedType.undefined?o="Required":o=`Expected ${a.expected}, received ${a.received}`;break;case ZodIssueCode.invalid_literal:o=`Invalid literal value, expected ${JSON.stringify(a.expected,util.jsonStringifyReplacer)}`;break;case ZodIssueCode.unrecognized_keys:o=`Unrecognized key(s) in object: ${util.joinValues(a.keys,", ")}`;break;case ZodIssueCode.invalid_union:o="Invalid input";break;case ZodIssueCode.invalid_union_discriminator:o=`Invalid discriminator value. Expected ${util.joinValues(a.options)}`;break;case ZodIssueCode.invalid_enum_value:o=`Invalid enum value. Expected ${util.joinValues(a.options)}, received '${a.received}'`;break;case ZodIssueCode.invalid_arguments:o="Invalid function arguments";break;case ZodIssueCode.invalid_return_type:o="Invalid function return type";break;case ZodIssueCode.invalid_date:o="Invalid date";break;case ZodIssueCode.invalid_string:typeof a.validation=="object"?"includes"in a.validation?(o=`Invalid input: must include "${a.validation.includes}"`,typeof a.validation.position=="number"&&(o=`${o} at one or more positions greater than or equal to ${a.validation.position}`)):"startsWith"in a.validation?o=`Invalid input: must start with "${a.validation.startsWith}"`:"endsWith"in a.validation?o=`Invalid input: must end with "${a.validation.endsWith}"`:util.assertNever(a.validation):a.validation!=="regex"?o=`Invalid ${a.validation}`:o="Invalid";break;case ZodIssueCode.too_small:a.type==="array"?o=`Array must contain ${a.exact?"exactly":a.inclusive?"at least":"more than"} ${a.minimum} element(s)`:a.type==="string"?o=`String must contain ${a.exact?"exactly":a.inclusive?"at least":"over"} ${a.minimum} character(s)`:a.type==="number"?o=`Number must be ${a.exact?"exactly equal to ":a.inclusive?"greater than or equal to ":"greater than "}${a.minimum}`:a.type==="date"?o=`Date must be ${a.exact?"exactly equal to ":a.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(a.minimum))}`:o="Invalid input";break;case ZodIssueCode.too_big:a.type==="array"?o=`Array must contain ${a.exact?"exactly":a.inclusive?"at most":"less than"} ${a.maximum} element(s)`:a.type==="string"?o=`String must contain ${a.exact?"exactly":a.inclusive?"at most":"under"} ${a.maximum} character(s)`:a.type==="number"?o=`Number must be ${a.exact?"exactly":a.inclusive?"less than or equal to":"less than"} ${a.maximum}`:a.type==="bigint"?o=`BigInt must be ${a.exact?"exactly":a.inclusive?"less than or equal to":"less than"} ${a.maximum}`:a.type==="date"?o=`Date must be ${a.exact?"exactly":a.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(a.maximum))}`:o="Invalid input";break;case ZodIssueCode.custom:o="Invalid input";break;case ZodIssueCode.invalid_intersection_types:o="Intersection results could not be merged";break;case ZodIssueCode.not_multiple_of:o=`Number must be a multiple of ${a.multipleOf}`;break;case ZodIssueCode.not_finite:o="Number must be finite";break;default:o=e.defaultError,util.assertNever(a)}return{message:o}};let overrideErrorMap=errorMap;function setErrorMap(a){overrideErrorMap=a}function getErrorMap(){return overrideErrorMap}const makeIssue=a=>{const{data:e,path:o,errorMaps:s,issueData:d}=a,c=[...o,...d.path||[]],h={...d,path:c};if(d.message!==void 0)return{...d,path:c,message:d.message};let _="";const bt=s.filter(g=>!!g).slice().reverse();for(const g of bt)_=g(h,{data:e,defaultError:_}).message;return{...d,path:c,message:_}},EMPTY_PATH=[];function addIssueToContext(a,e){const o=getErrorMap(),s=makeIssue({issueData:e,data:a.data,path:a.path,errorMaps:[a.common.contextualErrorMap,a.schemaErrorMap,o,o===errorMap?void 0:errorMap].filter(d=>!!d)});a.common.issues.push(s)}class ParseStatus{constructor(){this.value="valid"}dirty(){this.value==="valid"&&(this.value="dirty")}abort(){this.value!=="aborted"&&(this.value="aborted")}static mergeArray(e,o){const s=[];for(const d of o){if(d.status==="aborted")return INVALID;d.status==="dirty"&&e.dirty(),s.push(d.value)}return{status:e.value,value:s}}static async mergeObjectAsync(e,o){const s=[];for(const d of o){const c=await d.key,h=await d.value;s.push({key:c,value:h})}return ParseStatus.mergeObjectSync(e,s)}static mergeObjectSync(e,o){const s={};for(const d of o){const{key:c,value:h}=d;if(c.status==="aborted"||h.status==="aborted")return INVALID;c.status==="dirty"&&e.dirty(),h.status==="dirty"&&e.dirty(),c.value!=="__proto__"&&(typeof h.value<"u"||d.alwaysSet)&&(s[c.value]=h.value)}return{status:e.value,value:s}}}const INVALID=Object.freeze({status:"aborted"}),DIRTY=a=>({status:"dirty",value:a}),OK=a=>({status:"valid",value:a}),isAborted=a=>a.status==="aborted",isDirty=a=>a.status==="dirty",isValid=a=>a.status==="valid",isAsync=a=>typeof Promise<"u"&&a instanceof Promise;function __classPrivateFieldGet(a,e,o,s){if(o==="a"&&!s)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?a!==e||!s:!e.has(a))throw new TypeError("Cannot read private member from an object whose class did not declare it");return o==="m"?s:o==="a"?s.call(a):s?s.value:e.get(a)}function __classPrivateFieldSet(a,e,o,s,d){if(s==="m")throw new TypeError("Private method is not writable");if(s==="a"&&!d)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?a!==e||!d:!e.has(a))throw new TypeError("Cannot write private member to an object whose class did not declare it");return s==="a"?d.call(a,o):d?d.value=o:e.set(a,o),o}typeof SuppressedError=="function"&&SuppressedError;var errorUtil;(function(a){a.errToObj=e=>typeof e=="string"?{message:e}:e||{},a.toString=e=>typeof e=="string"?e:e==null?void 0:e.message})(errorUtil||(errorUtil={}));var _ZodEnum_cache,_ZodNativeEnum_cache;class ParseInputLazyPath{constructor(e,o,s,d){this._cachedPath=[],this.parent=e,this.data=o,this._path=s,this._key=d}get path(){return this._cachedPath.length||(this._key instanceof Array?this._cachedPath.push(...this._path,...this._key):this._cachedPath.push(...this._path,this._key)),this._cachedPath}}const handleResult=(a,e)=>{if(isValid(e))return{success:!0,data:e.value};if(!a.common.issues.length)throw new Error("Validation failed but no issues detected.");return{success:!1,get error(){if(this._error)return this._error;const o=new ZodError(a.common.issues);return this._error=o,this._error}}};function processCreateParams(a){if(!a)return{};const{errorMap:e,invalid_type_error:o,required_error:s,description:d}=a;if(e&&(o||s))throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);return e?{errorMap:e,description:d}:{errorMap:(h,_)=>{var bt,g;const{message:j}=a;return h.code==="invalid_enum_value"?{message:j??_.defaultError}:typeof _.data>"u"?{message:(bt=j??s)!==null&&bt!==void 0?bt:_.defaultError}:h.code!=="invalid_type"?{message:_.defaultError}:{message:(g=j??o)!==null&&g!==void 0?g:_.defaultError}},description:d}}class ZodType{constructor(e){this.spa=this.safeParseAsync,this._def=e,this.parse=this.parse.bind(this),this.safeParse=this.safeParse.bind(this),this.parseAsync=this.parseAsync.bind(this),this.safeParseAsync=this.safeParseAsync.bind(this),this.spa=this.spa.bind(this),this.refine=this.refine.bind(this),this.refinement=this.refinement.bind(this),this.superRefine=this.superRefine.bind(this),this.optional=this.optional.bind(this),this.nullable=this.nullable.bind(this),this.nullish=this.nullish.bind(this),this.array=this.array.bind(this),this.promise=this.promise.bind(this),this.or=this.or.bind(this),this.and=this.and.bind(this),this.transform=this.transform.bind(this),this.brand=this.brand.bind(this),this.default=this.default.bind(this),this.catch=this.catch.bind(this),this.describe=this.describe.bind(this),this.pipe=this.pipe.bind(this),this.readonly=this.readonly.bind(this),this.isNullable=this.isNullable.bind(this),this.isOptional=this.isOptional.bind(this)}get description(){return this._def.description}_getType(e){return getParsedType(e.data)}_getOrReturnCtx(e,o){return o||{common:e.parent.common,data:e.data,parsedType:getParsedType(e.data),schemaErrorMap:this._def.errorMap,path:e.path,parent:e.parent}}_processInputParams(e){return{status:new ParseStatus,ctx:{common:e.parent.common,data:e.data,parsedType:getParsedType(e.data),schemaErrorMap:this._def.errorMap,path:e.path,parent:e.parent}}}_parseSync(e){const o=this._parse(e);if(isAsync(o))throw new Error("Synchronous parse encountered promise.");return o}_parseAsync(e){const o=this._parse(e);return Promise.resolve(o)}parse(e,o){const s=this.safeParse(e,o);if(s.success)return s.data;throw s.error}safeParse(e,o){var s;const d={common:{issues:[],async:(s=o==null?void 0:o.async)!==null&&s!==void 0?s:!1,contextualErrorMap:o==null?void 0:o.errorMap},path:(o==null?void 0:o.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:e,parsedType:getParsedType(e)},c=this._parseSync({data:e,path:d.path,parent:d});return handleResult(d,c)}async parseAsync(e,o){const s=await this.safeParseAsync(e,o);if(s.success)return s.data;throw s.error}async safeParseAsync(e,o){const s={common:{issues:[],contextualErrorMap:o==null?void 0:o.errorMap,async:!0},path:(o==null?void 0:o.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:e,parsedType:getParsedType(e)},d=this._parse({data:e,path:s.path,parent:s}),c=await(isAsync(d)?d:Promise.resolve(d));return handleResult(s,c)}refine(e,o){const s=d=>typeof o=="string"||typeof o>"u"?{message:o}:typeof o=="function"?o(d):o;return this._refinement((d,c)=>{const h=e(d),_=()=>c.addIssue({code:ZodIssueCode.custom,...s(d)});return typeof Promise<"u"&&h instanceof Promise?h.then(bt=>bt?!0:(_(),!1)):h?!0:(_(),!1)})}refinement(e,o){return this._refinement((s,d)=>e(s)?!0:(d.addIssue(typeof o=="function"?o(s,d):o),!1))}_refinement(e){return new ZodEffects({schema:this,typeName:ZodFirstPartyTypeKind.ZodEffects,effect:{type:"refinement",refinement:e}})}superRefine(e){return this._refinement(e)}optional(){return ZodOptional.create(this,this._def)}nullable(){return ZodNullable.create(this,this._def)}nullish(){return this.nullable().optional()}array(){return ZodArray.create(this,this._def)}promise(){return ZodPromise.create(this,this._def)}or(e){return ZodUnion.create([this,e],this._def)}and(e){return ZodIntersection.create(this,e,this._def)}transform(e){return new ZodEffects({...processCreateParams(this._def),schema:this,typeName:ZodFirstPartyTypeKind.ZodEffects,effect:{type:"transform",transform:e}})}default(e){const o=typeof e=="function"?e:()=>e;return new ZodDefault({...processCreateParams(this._def),innerType:this,defaultValue:o,typeName:ZodFirstPartyTypeKind.ZodDefault})}brand(){return new ZodBranded({typeName:ZodFirstPartyTypeKind.ZodBranded,type:this,...processCreateParams(this._def)})}catch(e){const o=typeof e=="function"?e:()=>e;return new ZodCatch({...processCreateParams(this._def),innerType:this,catchValue:o,typeName:ZodFirstPartyTypeKind.ZodCatch})}describe(e){const o=this.constructor;return new o({...this._def,description:e})}pipe(e){return ZodPipeline.create(this,e)}readonly(){return ZodReadonly.create(this)}isOptional(){return this.safeParse(void 0).success}isNullable(){return this.safeParse(null).success}}const cuidRegex=/^c[^\s-]{8,}$/i,cuid2Regex=/^[0-9a-z]+$/,ulidRegex=/^[0-9A-HJKMNP-TV-Z]{26}$/,uuidRegex=/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,nanoidRegex=/^[a-z0-9_-]{21}$/i,durationRegex=/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,emailRegex=/^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,_emojiRegex="^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";let emojiRegex;const ipv4Regex=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,ipv6Regex=/^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,base64Regex=/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,dateRegexSource="((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",dateRegex=new RegExp(`^${dateRegexSource}$`);function timeRegexSource(a){let e="([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";return a.precision?e=`${e}\\.\\d{${a.precision}}`:a.precision==null&&(e=`${e}(\\.\\d+)?`),e}function timeRegex(a){return new RegExp(`^${timeRegexSource(a)}$`)}function datetimeRegex(a){let e=`${dateRegexSource}T${timeRegexSource(a)}`;const o=[];return o.push(a.local?"Z?":"Z"),a.offset&&o.push("([+-]\\d{2}:?\\d{2})"),e=`${e}(${o.join("|")})`,new RegExp(`^${e}$`)}function isValidIP(a,e){return!!((e==="v4"||!e)&&ipv4Regex.test(a)||(e==="v6"||!e)&&ipv6Regex.test(a))}class ZodString extends ZodType{_parse(e){if(this._def.coerce&&(e.data=String(e.data)),this._getType(e)!==ZodParsedType.string){const c=this._getOrReturnCtx(e);return addIssueToContext(c,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.string,received:c.parsedType}),INVALID}const s=new ParseStatus;let d;for(const c of this._def.checks)if(c.kind==="min")e.data.length<c.value&&(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{code:ZodIssueCode.too_small,minimum:c.value,type:"string",inclusive:!0,exact:!1,message:c.message}),s.dirty());else if(c.kind==="max")e.data.length>c.value&&(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{code:ZodIssueCode.too_big,maximum:c.value,type:"string",inclusive:!0,exact:!1,message:c.message}),s.dirty());else if(c.kind==="length"){const h=e.data.length>c.value,_=e.data.length<c.value;(h||_)&&(d=this._getOrReturnCtx(e,d),h?addIssueToContext(d,{code:ZodIssueCode.too_big,maximum:c.value,type:"string",inclusive:!0,exact:!0,message:c.message}):_&&addIssueToContext(d,{code:ZodIssueCode.too_small,minimum:c.value,type:"string",inclusive:!0,exact:!0,message:c.message}),s.dirty())}else if(c.kind==="email")emailRegex.test(e.data)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{validation:"email",code:ZodIssueCode.invalid_string,message:c.message}),s.dirty());else if(c.kind==="emoji")emojiRegex||(emojiRegex=new RegExp(_emojiRegex,"u")),emojiRegex.test(e.data)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{validation:"emoji",code:ZodIssueCode.invalid_string,message:c.message}),s.dirty());else if(c.kind==="uuid")uuidRegex.test(e.data)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{validation:"uuid",code:ZodIssueCode.invalid_string,message:c.message}),s.dirty());else if(c.kind==="nanoid")nanoidRegex.test(e.data)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{validation:"nanoid",code:ZodIssueCode.invalid_string,message:c.message}),s.dirty());else if(c.kind==="cuid")cuidRegex.test(e.data)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{validation:"cuid",code:ZodIssueCode.invalid_string,message:c.message}),s.dirty());else if(c.kind==="cuid2")cuid2Regex.test(e.data)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{validation:"cuid2",code:ZodIssueCode.invalid_string,message:c.message}),s.dirty());else if(c.kind==="ulid")ulidRegex.test(e.data)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{validation:"ulid",code:ZodIssueCode.invalid_string,message:c.message}),s.dirty());else if(c.kind==="url")try{new URL(e.data)}catch{d=this._getOrReturnCtx(e,d),addIssueToContext(d,{validation:"url",code:ZodIssueCode.invalid_string,message:c.message}),s.dirty()}else c.kind==="regex"?(c.regex.lastIndex=0,c.regex.test(e.data)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{validation:"regex",code:ZodIssueCode.invalid_string,message:c.message}),s.dirty())):c.kind==="trim"?e.data=e.data.trim():c.kind==="includes"?e.data.includes(c.value,c.position)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{code:ZodIssueCode.invalid_string,validation:{includes:c.value,position:c.position},message:c.message}),s.dirty()):c.kind==="toLowerCase"?e.data=e.data.toLowerCase():c.kind==="toUpperCase"?e.data=e.data.toUpperCase():c.kind==="startsWith"?e.data.startsWith(c.value)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{code:ZodIssueCode.invalid_string,validation:{startsWith:c.value},message:c.message}),s.dirty()):c.kind==="endsWith"?e.data.endsWith(c.value)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{code:ZodIssueCode.invalid_string,validation:{endsWith:c.value},message:c.message}),s.dirty()):c.kind==="datetime"?datetimeRegex(c).test(e.data)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{code:ZodIssueCode.invalid_string,validation:"datetime",message:c.message}),s.dirty()):c.kind==="date"?dateRegex.test(e.data)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{code:ZodIssueCode.invalid_string,validation:"date",message:c.message}),s.dirty()):c.kind==="time"?timeRegex(c).test(e.data)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{code:ZodIssueCode.invalid_string,validation:"time",message:c.message}),s.dirty()):c.kind==="duration"?durationRegex.test(e.data)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{validation:"duration",code:ZodIssueCode.invalid_string,message:c.message}),s.dirty()):c.kind==="ip"?isValidIP(e.data,c.version)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{validation:"ip",code:ZodIssueCode.invalid_string,message:c.message}),s.dirty()):c.kind==="base64"?base64Regex.test(e.data)||(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{validation:"base64",code:ZodIssueCode.invalid_string,message:c.message}),s.dirty()):util.assertNever(c);return{status:s.value,value:e.data}}_regex(e,o,s){return this.refinement(d=>e.test(d),{validation:o,code:ZodIssueCode.invalid_string,...errorUtil.errToObj(s)})}_addCheck(e){return new ZodString({...this._def,checks:[...this._def.checks,e]})}email(e){return this._addCheck({kind:"email",...errorUtil.errToObj(e)})}url(e){return this._addCheck({kind:"url",...errorUtil.errToObj(e)})}emoji(e){return this._addCheck({kind:"emoji",...errorUtil.errToObj(e)})}uuid(e){return this._addCheck({kind:"uuid",...errorUtil.errToObj(e)})}nanoid(e){return this._addCheck({kind:"nanoid",...errorUtil.errToObj(e)})}cuid(e){return this._addCheck({kind:"cuid",...errorUtil.errToObj(e)})}cuid2(e){return this._addCheck({kind:"cuid2",...errorUtil.errToObj(e)})}ulid(e){return this._addCheck({kind:"ulid",...errorUtil.errToObj(e)})}base64(e){return this._addCheck({kind:"base64",...errorUtil.errToObj(e)})}ip(e){return this._addCheck({kind:"ip",...errorUtil.errToObj(e)})}datetime(e){var o,s;return typeof e=="string"?this._addCheck({kind:"datetime",precision:null,offset:!1,local:!1,message:e}):this._addCheck({kind:"datetime",precision:typeof(e==null?void 0:e.precision)>"u"?null:e==null?void 0:e.precision,offset:(o=e==null?void 0:e.offset)!==null&&o!==void 0?o:!1,local:(s=e==null?void 0:e.local)!==null&&s!==void 0?s:!1,...errorUtil.errToObj(e==null?void 0:e.message)})}date(e){return this._addCheck({kind:"date",message:e})}time(e){return typeof e=="string"?this._addCheck({kind:"time",precision:null,message:e}):this._addCheck({kind:"time",precision:typeof(e==null?void 0:e.precision)>"u"?null:e==null?void 0:e.precision,...errorUtil.errToObj(e==null?void 0:e.message)})}duration(e){return this._addCheck({kind:"duration",...errorUtil.errToObj(e)})}regex(e,o){return this._addCheck({kind:"regex",regex:e,...errorUtil.errToObj(o)})}includes(e,o){return this._addCheck({kind:"includes",value:e,position:o==null?void 0:o.position,...errorUtil.errToObj(o==null?void 0:o.message)})}startsWith(e,o){return this._addCheck({kind:"startsWith",value:e,...errorUtil.errToObj(o)})}endsWith(e,o){return this._addCheck({kind:"endsWith",value:e,...errorUtil.errToObj(o)})}min(e,o){return this._addCheck({kind:"min",value:e,...errorUtil.errToObj(o)})}max(e,o){return this._addCheck({kind:"max",value:e,...errorUtil.errToObj(o)})}length(e,o){return this._addCheck({kind:"length",value:e,...errorUtil.errToObj(o)})}nonempty(e){return this.min(1,errorUtil.errToObj(e))}trim(){return new ZodString({...this._def,checks:[...this._def.checks,{kind:"trim"}]})}toLowerCase(){return new ZodString({...this._def,checks:[...this._def.checks,{kind:"toLowerCase"}]})}toUpperCase(){return new ZodString({...this._def,checks:[...this._def.checks,{kind:"toUpperCase"}]})}get isDatetime(){return!!this._def.checks.find(e=>e.kind==="datetime")}get isDate(){return!!this._def.checks.find(e=>e.kind==="date")}get isTime(){return!!this._def.checks.find(e=>e.kind==="time")}get isDuration(){return!!this._def.checks.find(e=>e.kind==="duration")}get isEmail(){return!!this._def.checks.find(e=>e.kind==="email")}get isURL(){return!!this._def.checks.find(e=>e.kind==="url")}get isEmoji(){return!!this._def.checks.find(e=>e.kind==="emoji")}get isUUID(){return!!this._def.checks.find(e=>e.kind==="uuid")}get isNANOID(){return!!this._def.checks.find(e=>e.kind==="nanoid")}get isCUID(){return!!this._def.checks.find(e=>e.kind==="cuid")}get isCUID2(){return!!this._def.checks.find(e=>e.kind==="cuid2")}get isULID(){return!!this._def.checks.find(e=>e.kind==="ulid")}get isIP(){return!!this._def.checks.find(e=>e.kind==="ip")}get isBase64(){return!!this._def.checks.find(e=>e.kind==="base64")}get minLength(){let e=null;for(const o of this._def.checks)o.kind==="min"&&(e===null||o.value>e)&&(e=o.value);return e}get maxLength(){let e=null;for(const o of this._def.checks)o.kind==="max"&&(e===null||o.value<e)&&(e=o.value);return e}}ZodString.create=a=>{var e;return new ZodString({checks:[],typeName:ZodFirstPartyTypeKind.ZodString,coerce:(e=a==null?void 0:a.coerce)!==null&&e!==void 0?e:!1,...processCreateParams(a)})};function floatSafeRemainder(a,e){const o=(a.toString().split(".")[1]||"").length,s=(e.toString().split(".")[1]||"").length,d=o>s?o:s,c=parseInt(a.toFixed(d).replace(".","")),h=parseInt(e.toFixed(d).replace(".",""));return c%h/Math.pow(10,d)}class ZodNumber extends ZodType{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte,this.step=this.multipleOf}_parse(e){if(this._def.coerce&&(e.data=Number(e.data)),this._getType(e)!==ZodParsedType.number){const c=this._getOrReturnCtx(e);return addIssueToContext(c,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.number,received:c.parsedType}),INVALID}let s;const d=new ParseStatus;for(const c of this._def.checks)c.kind==="int"?util.isInteger(e.data)||(s=this._getOrReturnCtx(e,s),addIssueToContext(s,{code:ZodIssueCode.invalid_type,expected:"integer",received:"float",message:c.message}),d.dirty()):c.kind==="min"?(c.inclusive?e.data<c.value:e.data<=c.value)&&(s=this._getOrReturnCtx(e,s),addIssueToContext(s,{code:ZodIssueCode.too_small,minimum:c.value,type:"number",inclusive:c.inclusive,exact:!1,message:c.message}),d.dirty()):c.kind==="max"?(c.inclusive?e.data>c.value:e.data>=c.value)&&(s=this._getOrReturnCtx(e,s),addIssueToContext(s,{code:ZodIssueCode.too_big,maximum:c.value,type:"number",inclusive:c.inclusive,exact:!1,message:c.message}),d.dirty()):c.kind==="multipleOf"?floatSafeRemainder(e.data,c.value)!==0&&(s=this._getOrReturnCtx(e,s),addIssueToContext(s,{code:ZodIssueCode.not_multiple_of,multipleOf:c.value,message:c.message}),d.dirty()):c.kind==="finite"?Number.isFinite(e.data)||(s=this._getOrReturnCtx(e,s),addIssueToContext(s,{code:ZodIssueCode.not_finite,message:c.message}),d.dirty()):util.assertNever(c);return{status:d.value,value:e.data}}gte(e,o){return this.setLimit("min",e,!0,errorUtil.toString(o))}gt(e,o){return this.setLimit("min",e,!1,errorUtil.toString(o))}lte(e,o){return this.setLimit("max",e,!0,errorUtil.toString(o))}lt(e,o){return this.setLimit("max",e,!1,errorUtil.toString(o))}setLimit(e,o,s,d){return new ZodNumber({...this._def,checks:[...this._def.checks,{kind:e,value:o,inclusive:s,message:errorUtil.toString(d)}]})}_addCheck(e){return new ZodNumber({...this._def,checks:[...this._def.checks,e]})}int(e){return this._addCheck({kind:"int",message:errorUtil.toString(e)})}positive(e){return this._addCheck({kind:"min",value:0,inclusive:!1,message:errorUtil.toString(e)})}negative(e){return this._addCheck({kind:"max",value:0,inclusive:!1,message:errorUtil.toString(e)})}nonpositive(e){return this._addCheck({kind:"max",value:0,inclusive:!0,message:errorUtil.toString(e)})}nonnegative(e){return this._addCheck({kind:"min",value:0,inclusive:!0,message:errorUtil.toString(e)})}multipleOf(e,o){return this._addCheck({kind:"multipleOf",value:e,message:errorUtil.toString(o)})}finite(e){return this._addCheck({kind:"finite",message:errorUtil.toString(e)})}safe(e){return this._addCheck({kind:"min",inclusive:!0,value:Number.MIN_SAFE_INTEGER,message:errorUtil.toString(e)})._addCheck({kind:"max",inclusive:!0,value:Number.MAX_SAFE_INTEGER,message:errorUtil.toString(e)})}get minValue(){let e=null;for(const o of this._def.checks)o.kind==="min"&&(e===null||o.value>e)&&(e=o.value);return e}get maxValue(){let e=null;for(const o of this._def.checks)o.kind==="max"&&(e===null||o.value<e)&&(e=o.value);return e}get isInt(){return!!this._def.checks.find(e=>e.kind==="int"||e.kind==="multipleOf"&&util.isInteger(e.value))}get isFinite(){let e=null,o=null;for(const s of this._def.checks){if(s.kind==="finite"||s.kind==="int"||s.kind==="multipleOf")return!0;s.kind==="min"?(o===null||s.value>o)&&(o=s.value):s.kind==="max"&&(e===null||s.value<e)&&(e=s.value)}return Number.isFinite(o)&&Number.isFinite(e)}}ZodNumber.create=a=>new ZodNumber({checks:[],typeName:ZodFirstPartyTypeKind.ZodNumber,coerce:(a==null?void 0:a.coerce)||!1,...processCreateParams(a)});class ZodBigInt extends ZodType{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte}_parse(e){if(this._def.coerce&&(e.data=BigInt(e.data)),this._getType(e)!==ZodParsedType.bigint){const c=this._getOrReturnCtx(e);return addIssueToContext(c,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.bigint,received:c.parsedType}),INVALID}let s;const d=new ParseStatus;for(const c of this._def.checks)c.kind==="min"?(c.inclusive?e.data<c.value:e.data<=c.value)&&(s=this._getOrReturnCtx(e,s),addIssueToContext(s,{code:ZodIssueCode.too_small,type:"bigint",minimum:c.value,inclusive:c.inclusive,message:c.message}),d.dirty()):c.kind==="max"?(c.inclusive?e.data>c.value:e.data>=c.value)&&(s=this._getOrReturnCtx(e,s),addIssueToContext(s,{code:ZodIssueCode.too_big,type:"bigint",maximum:c.value,inclusive:c.inclusive,message:c.message}),d.dirty()):c.kind==="multipleOf"?e.data%c.value!==BigInt(0)&&(s=this._getOrReturnCtx(e,s),addIssueToContext(s,{code:ZodIssueCode.not_multiple_of,multipleOf:c.value,message:c.message}),d.dirty()):util.assertNever(c);return{status:d.value,value:e.data}}gte(e,o){return this.setLimit("min",e,!0,errorUtil.toString(o))}gt(e,o){return this.setLimit("min",e,!1,errorUtil.toString(o))}lte(e,o){return this.setLimit("max",e,!0,errorUtil.toString(o))}lt(e,o){return this.setLimit("max",e,!1,errorUtil.toString(o))}setLimit(e,o,s,d){return new ZodBigInt({...this._def,checks:[...this._def.checks,{kind:e,value:o,inclusive:s,message:errorUtil.toString(d)}]})}_addCheck(e){return new ZodBigInt({...this._def,checks:[...this._def.checks,e]})}positive(e){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!1,message:errorUtil.toString(e)})}negative(e){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!1,message:errorUtil.toString(e)})}nonpositive(e){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!0,message:errorUtil.toString(e)})}nonnegative(e){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!0,message:errorUtil.toString(e)})}multipleOf(e,o){return this._addCheck({kind:"multipleOf",value:e,message:errorUtil.toString(o)})}get minValue(){let e=null;for(const o of this._def.checks)o.kind==="min"&&(e===null||o.value>e)&&(e=o.value);return e}get maxValue(){let e=null;for(const o of this._def.checks)o.kind==="max"&&(e===null||o.value<e)&&(e=o.value);return e}}ZodBigInt.create=a=>{var e;return new ZodBigInt({checks:[],typeName:ZodFirstPartyTypeKind.ZodBigInt,coerce:(e=a==null?void 0:a.coerce)!==null&&e!==void 0?e:!1,...processCreateParams(a)})};class ZodBoolean extends ZodType{_parse(e){if(this._def.coerce&&(e.data=!!e.data),this._getType(e)!==ZodParsedType.boolean){const s=this._getOrReturnCtx(e);return addIssueToContext(s,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.boolean,received:s.parsedType}),INVALID}return OK(e.data)}}ZodBoolean.create=a=>new ZodBoolean({typeName:ZodFirstPartyTypeKind.ZodBoolean,coerce:(a==null?void 0:a.coerce)||!1,...processCreateParams(a)});class ZodDate extends ZodType{_parse(e){if(this._def.coerce&&(e.data=new Date(e.data)),this._getType(e)!==ZodParsedType.date){const c=this._getOrReturnCtx(e);return addIssueToContext(c,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.date,received:c.parsedType}),INVALID}if(isNaN(e.data.getTime())){const c=this._getOrReturnCtx(e);return addIssueToContext(c,{code:ZodIssueCode.invalid_date}),INVALID}const s=new ParseStatus;let d;for(const c of this._def.checks)c.kind==="min"?e.data.getTime()<c.value&&(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{code:ZodIssueCode.too_small,message:c.message,inclusive:!0,exact:!1,minimum:c.value,type:"date"}),s.dirty()):c.kind==="max"?e.data.getTime()>c.value&&(d=this._getOrReturnCtx(e,d),addIssueToContext(d,{code:ZodIssueCode.too_big,message:c.message,inclusive:!0,exact:!1,maximum:c.value,type:"date"}),s.dirty()):util.assertNever(c);return{status:s.value,value:new Date(e.data.getTime())}}_addCheck(e){return new ZodDate({...this._def,checks:[...this._def.checks,e]})}min(e,o){return this._addCheck({kind:"min",value:e.getTime(),message:errorUtil.toString(o)})}max(e,o){return this._addCheck({kind:"max",value:e.getTime(),message:errorUtil.toString(o)})}get minDate(){let e=null;for(const o of this._def.checks)o.kind==="min"&&(e===null||o.value>e)&&(e=o.value);return e!=null?new Date(e):null}get maxDate(){let e=null;for(const o of this._def.checks)o.kind==="max"&&(e===null||o.value<e)&&(e=o.value);return e!=null?new Date(e):null}}ZodDate.create=a=>new ZodDate({checks:[],coerce:(a==null?void 0:a.coerce)||!1,typeName:ZodFirstPartyTypeKind.ZodDate,...processCreateParams(a)});class ZodSymbol extends ZodType{_parse(e){if(this._getType(e)!==ZodParsedType.symbol){const s=this._getOrReturnCtx(e);return addIssueToContext(s,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.symbol,received:s.parsedType}),INVALID}return OK(e.data)}}ZodSymbol.create=a=>new ZodSymbol({typeName:ZodFirstPartyTypeKind.ZodSymbol,...processCreateParams(a)});class ZodUndefined extends ZodType{_parse(e){if(this._getType(e)!==ZodParsedType.undefined){const s=this._getOrReturnCtx(e);return addIssueToContext(s,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.undefined,received:s.parsedType}),INVALID}return OK(e.data)}}ZodUndefined.create=a=>new ZodUndefined({typeName:ZodFirstPartyTypeKind.ZodUndefined,...processCreateParams(a)});class ZodNull extends ZodType{_parse(e){if(this._getType(e)!==ZodParsedType.null){const s=this._getOrReturnCtx(e);return addIssueToContext(s,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.null,received:s.parsedType}),INVALID}return OK(e.data)}}ZodNull.create=a=>new ZodNull({typeName:ZodFirstPartyTypeKind.ZodNull,...processCreateParams(a)});class ZodAny extends ZodType{constructor(){super(...arguments),this._any=!0}_parse(e){return OK(e.data)}}ZodAny.create=a=>new ZodAny({typeName:ZodFirstPartyTypeKind.ZodAny,...processCreateParams(a)});class ZodUnknown extends ZodType{constructor(){super(...arguments),this._unknown=!0}_parse(e){return OK(e.data)}}ZodUnknown.create=a=>new ZodUnknown({typeName:ZodFirstPartyTypeKind.ZodUnknown,...processCreateParams(a)});class ZodNever extends ZodType{_parse(e){const o=this._getOrReturnCtx(e);return addIssueToContext(o,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.never,received:o.parsedType}),INVALID}}ZodNever.create=a=>new ZodNever({typeName:ZodFirstPartyTypeKind.ZodNever,...processCreateParams(a)});class ZodVoid extends ZodType{_parse(e){if(this._getType(e)!==ZodParsedType.undefined){const s=this._getOrReturnCtx(e);return addIssueToContext(s,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.void,received:s.parsedType}),INVALID}return OK(e.data)}}ZodVoid.create=a=>new ZodVoid({typeName:ZodFirstPartyTypeKind.ZodVoid,...processCreateParams(a)});class ZodArray extends ZodType{_parse(e){const{ctx:o,status:s}=this._processInputParams(e),d=this._def;if(o.parsedType!==ZodParsedType.array)return addIssueToContext(o,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.array,received:o.parsedType}),INVALID;if(d.exactLength!==null){const h=o.data.length>d.exactLength.value,_=o.data.length<d.exactLength.value;(h||_)&&(addIssueToContext(o,{code:h?ZodIssueCode.too_big:ZodIssueCode.too_small,minimum:_?d.exactLength.value:void 0,maximum:h?d.exactLength.value:void 0,type:"array",inclusive:!0,exact:!0,message:d.exactLength.message}),s.dirty())}if(d.minLength!==null&&o.data.length<d.minLength.value&&(addIssueToContext(o,{code:ZodIssueCode.too_small,minimum:d.minLength.value,type:"array",inclusive:!0,exact:!1,message:d.minLength.message}),s.dirty()),d.maxLength!==null&&o.data.length>d.maxLength.value&&(addIssueToContext(o,{code:ZodIssueCode.too_big,maximum:d.maxLength.value,type:"array",inclusive:!0,exact:!1,message:d.maxLength.message}),s.dirty()),o.common.async)return Promise.all([...o.data].map((h,_)=>d.type._parseAsync(new ParseInputLazyPath(o,h,o.path,_)))).then(h=>ParseStatus.mergeArray(s,h));const c=[...o.data].map((h,_)=>d.type._parseSync(new ParseInputLazyPath(o,h,o.path,_)));return ParseStatus.mergeArray(s,c)}get element(){return this._def.type}min(e,o){return new ZodArray({...this._def,minLength:{value:e,message:errorUtil.toString(o)}})}max(e,o){return new ZodArray({...this._def,maxLength:{value:e,message:errorUtil.toString(o)}})}length(e,o){return new ZodArray({...this._def,exactLength:{value:e,message:errorUtil.toString(o)}})}nonempty(e){return this.min(1,e)}}ZodArray.create=(a,e)=>new ZodArray({type:a,minLength:null,maxLength:null,exactLength:null,typeName:ZodFirstPartyTypeKind.ZodArray,...processCreateParams(e)});function deepPartialify(a){if(a instanceof ZodObject){const e={};for(const o in a.shape){const s=a.shape[o];e[o]=ZodOptional.create(deepPartialify(s))}return new ZodObject({...a._def,shape:()=>e})}else return a instanceof ZodArray?new ZodArray({...a._def,type:deepPartialify(a.element)}):a instanceof ZodOptional?ZodOptional.create(deepPartialify(a.unwrap())):a instanceof ZodNullable?ZodNullable.create(deepPartialify(a.unwrap())):a instanceof ZodTuple?ZodTuple.create(a.items.map(e=>deepPartialify(e))):a}class ZodObject extends ZodType{constructor(){super(...arguments),this._cached=null,this.nonstrict=this.passthrough,this.augment=this.extend}_getCached(){if(this._cached!==null)return this._cached;const e=this._def.shape(),o=util.objectKeys(e);return this._cached={shape:e,keys:o}}_parse(e){if(this._getType(e)!==ZodParsedType.object){const g=this._getOrReturnCtx(e);return addIssueToContext(g,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.object,received:g.parsedType}),INVALID}const{status:s,ctx:d}=this._processInputParams(e),{shape:c,keys:h}=this._getCached(),_=[];if(!(this._def.catchall instanceof ZodNever&&this._def.unknownKeys==="strip"))for(const g in d.data)h.includes(g)||_.push(g);const bt=[];for(const g of h){const j=c[g],b=d.data[g];bt.push({key:{status:"valid",value:g},value:j._parse(new ParseInputLazyPath(d,b,d.path,g)),alwaysSet:g in d.data})}if(this._def.catchall instanceof ZodNever){const g=this._def.unknownKeys;if(g==="passthrough")for(const j of _)bt.push({key:{status:"valid",value:j},value:{status:"valid",value:d.data[j]}});else if(g==="strict")_.length>0&&(addIssueToContext(d,{code:ZodIssueCode.unrecognized_keys,keys:_}),s.dirty());else if(g!=="strip")throw new Error("Internal ZodObject error: invalid unknownKeys value.")}else{const g=this._def.catchall;for(const j of _){const b=d.data[j];bt.push({key:{status:"valid",value:j},value:g._parse(new ParseInputLazyPath(d,b,d.path,j)),alwaysSet:j in d.data})}}return d.common.async?Promise.resolve().then(async()=>{const g=[];for(const j of bt){const b=await j.key,Et=await j.value;g.push({key:b,value:Et,alwaysSet:j.alwaysSet})}return g}).then(g=>ParseStatus.mergeObjectSync(s,g)):ParseStatus.mergeObjectSync(s,bt)}get shape(){return this._def.shape()}strict(e){return errorUtil.errToObj,new ZodObject({...this._def,unknownKeys:"strict",...e!==void 0?{errorMap:(o,s)=>{var d,c,h,_;const bt=(h=(c=(d=this._def).errorMap)===null||c===void 0?void 0:c.call(d,o,s).message)!==null&&h!==void 0?h:s.defaultError;return o.code==="unrecognized_keys"?{message:(_=errorUtil.errToObj(e).message)!==null&&_!==void 0?_:bt}:{message:bt}}}:{}})}strip(){return new ZodObject({...this._def,unknownKeys:"strip"})}passthrough(){return new ZodObject({...this._def,unknownKeys:"passthrough"})}extend(e){return new ZodObject({...this._def,shape:()=>({...this._def.shape(),...e})})}merge(e){return new ZodObject({unknownKeys:e._def.unknownKeys,catchall:e._def.catchall,shape:()=>({...this._def.shape(),...e._def.shape()}),typeName:ZodFirstPartyTypeKind.ZodObject})}setKey(e,o){return this.augment({[e]:o})}catchall(e){return new ZodObject({...this._def,catchall:e})}pick(e){const o={};return util.objectKeys(e).forEach(s=>{e[s]&&this.shape[s]&&(o[s]=this.shape[s])}),new ZodObject({...this._def,shape:()=>o})}omit(e){const o={};return util.objectKeys(this.shape).forEach(s=>{e[s]||(o[s]=this.shape[s])}),new ZodObject({...this._def,shape:()=>o})}deepPartial(){return deepPartialify(this)}partial(e){const o={};return util.objectKeys(this.shape).forEach(s=>{const d=this.shape[s];e&&!e[s]?o[s]=d:o[s]=d.optional()}),new ZodObject({...this._def,shape:()=>o})}required(e){const o={};return util.objectKeys(this.shape).forEach(s=>{if(e&&!e[s])o[s]=this.shape[s];else{let c=this.shape[s];for(;c instanceof ZodOptional;)c=c._def.innerType;o[s]=c}}),new ZodObject({...this._def,shape:()=>o})}keyof(){return createZodEnum(util.objectKeys(this.shape))}}ZodObject.create=(a,e)=>new ZodObject({shape:()=>a,unknownKeys:"strip",catchall:ZodNever.create(),typeName:ZodFirstPartyTypeKind.ZodObject,...processCreateParams(e)});ZodObject.strictCreate=(a,e)=>new ZodObject({shape:()=>a,unknownKeys:"strict",catchall:ZodNever.create(),typeName:ZodFirstPartyTypeKind.ZodObject,...processCreateParams(e)});ZodObject.lazycreate=(a,e)=>new ZodObject({shape:a,unknownKeys:"strip",catchall:ZodNever.create(),typeName:ZodFirstPartyTypeKind.ZodObject,...processCreateParams(e)});class ZodUnion extends ZodType{_parse(e){const{ctx:o}=this._processInputParams(e),s=this._def.options;function d(c){for(const _ of c)if(_.result.status==="valid")return _.result;for(const _ of c)if(_.result.status==="dirty")return o.common.issues.push(..._.ctx.common.issues),_.result;const h=c.map(_=>new ZodError(_.ctx.common.issues));return addIssueToContext(o,{code:ZodIssueCode.invalid_union,unionErrors:h}),INVALID}if(o.common.async)return Promise.all(s.map(async c=>{const h={...o,common:{...o.common,issues:[]},parent:null};return{result:await c._parseAsync({data:o.data,path:o.path,parent:h}),ctx:h}})).then(d);{let c;const h=[];for(const bt of s){const g={...o,common:{...o.common,issues:[]},parent:null},j=bt._parseSync({data:o.data,path:o.path,parent:g});if(j.status==="valid")return j;j.status==="dirty"&&!c&&(c={result:j,ctx:g}),g.common.issues.length&&h.push(g.common.issues)}if(c)return o.common.issues.push(...c.ctx.common.issues),c.result;const _=h.map(bt=>new ZodError(bt));return addIssueToContext(o,{code:ZodIssueCode.invalid_union,unionErrors:_}),INVALID}}get options(){return this._def.options}}ZodUnion.create=(a,e)=>new ZodUnion({options:a,typeName:ZodFirstPartyTypeKind.ZodUnion,...processCreateParams(e)});const getDiscriminator=a=>a instanceof ZodLazy?getDiscriminator(a.schema):a instanceof ZodEffects?getDiscriminator(a.innerType()):a instanceof ZodLiteral?[a.value]:a instanceof ZodEnum?a.options:a instanceof ZodNativeEnum?util.objectValues(a.enum):a instanceof ZodDefault?getDiscriminator(a._def.innerType):a instanceof ZodUndefined?[void 0]:a instanceof ZodNull?[null]:a instanceof ZodOptional?[void 0,...getDiscriminator(a.unwrap())]:a instanceof ZodNullable?[null,...getDiscriminator(a.unwrap())]:a instanceof ZodBranded||a instanceof ZodReadonly?getDiscriminator(a.unwrap()):a instanceof ZodCatch?getDiscriminator(a._def.innerType):[];class ZodDiscriminatedUnion extends ZodType{_parse(e){const{ctx:o}=this._processInputParams(e);if(o.parsedType!==ZodParsedType.object)return addIssueToContext(o,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.object,received:o.parsedType}),INVALID;const s=this.discriminator,d=o.data[s],c=this.optionsMap.get(d);return c?o.common.async?c._parseAsync({data:o.data,path:o.path,parent:o}):c._parseSync({data:o.data,path:o.path,parent:o}):(addIssueToContext(o,{code:ZodIssueCode.invalid_union_discriminator,options:Array.from(this.optionsMap.keys()),path:[s]}),INVALID)}get discriminator(){return this._def.discriminator}get options(){return this._def.options}get optionsMap(){return this._def.optionsMap}static create(e,o,s){const d=new Map;for(const c of o){const h=getDiscriminator(c.shape[e]);if(!h.length)throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);for(const _ of h){if(d.has(_))throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(_)}`);d.set(_,c)}}return new ZodDiscriminatedUnion({typeName:ZodFirstPartyTypeKind.ZodDiscriminatedUnion,discriminator:e,options:o,optionsMap:d,...processCreateParams(s)})}}function mergeValues(a,e){const o=getParsedType(a),s=getParsedType(e);if(a===e)return{valid:!0,data:a};if(o===ZodParsedType.object&&s===ZodParsedType.object){const d=util.objectKeys(e),c=util.objectKeys(a).filter(_=>d.indexOf(_)!==-1),h={...a,...e};for(const _ of c){const bt=mergeValues(a[_],e[_]);if(!bt.valid)return{valid:!1};h[_]=bt.data}return{valid:!0,data:h}}else if(o===ZodParsedType.array&&s===ZodParsedType.array){if(a.length!==e.length)return{valid:!1};const d=[];for(let c=0;c<a.length;c++){const h=a[c],_=e[c],bt=mergeValues(h,_);if(!bt.valid)return{valid:!1};d.push(bt.data)}return{valid:!0,data:d}}else return o===ZodParsedType.date&&s===ZodParsedType.date&&+a==+e?{valid:!0,data:a}:{valid:!1}}class ZodIntersection extends ZodType{_parse(e){const{status:o,ctx:s}=this._processInputParams(e),d=(c,h)=>{if(isAborted(c)||isAborted(h))return INVALID;const _=mergeValues(c.value,h.value);return _.valid?((isDirty(c)||isDirty(h))&&o.dirty(),{status:o.value,value:_.data}):(addIssueToContext(s,{code:ZodIssueCode.invalid_intersection_types}),INVALID)};return s.common.async?Promise.all([this._def.left._parseAsync({data:s.data,path:s.path,parent:s}),this._def.right._parseAsync({data:s.data,path:s.path,parent:s})]).then(([c,h])=>d(c,h)):d(this._def.left._parseSync({data:s.data,path:s.path,parent:s}),this._def.right._parseSync({data:s.data,path:s.path,parent:s}))}}ZodIntersection.create=(a,e,o)=>new ZodIntersection({left:a,right:e,typeName:ZodFirstPartyTypeKind.ZodIntersection,...processCreateParams(o)});class ZodTuple extends ZodType{_parse(e){const{status:o,ctx:s}=this._processInputParams(e);if(s.parsedType!==ZodParsedType.array)return addIssueToContext(s,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.array,received:s.parsedType}),INVALID;if(s.data.length<this._def.items.length)return addIssueToContext(s,{code:ZodIssueCode.too_small,minimum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),INVALID;!this._def.rest&&s.data.length>this._def.items.length&&(addIssueToContext(s,{code:ZodIssueCode.too_big,maximum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),o.dirty());const c=[...s.data].map((h,_)=>{const bt=this._def.items[_]||this._def.rest;return bt?bt._parse(new ParseInputLazyPath(s,h,s.path,_)):null}).filter(h=>!!h);return s.common.async?Promise.all(c).then(h=>ParseStatus.mergeArray(o,h)):ParseStatus.mergeArray(o,c)}get items(){return this._def.items}rest(e){return new ZodTuple({...this._def,rest:e})}}ZodTuple.create=(a,e)=>{if(!Array.isArray(a))throw new Error("You must pass an array of schemas to z.tuple([ ... ])");return new ZodTuple({items:a,typeName:ZodFirstPartyTypeKind.ZodTuple,rest:null,...processCreateParams(e)})};class ZodRecord extends ZodType{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(e){const{status:o,ctx:s}=this._processInputParams(e);if(s.parsedType!==ZodParsedType.object)return addIssueToContext(s,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.object,received:s.parsedType}),INVALID;const d=[],c=this._def.keyType,h=this._def.valueType;for(const _ in s.data)d.push({key:c._parse(new ParseInputLazyPath(s,_,s.path,_)),value:h._parse(new ParseInputLazyPath(s,s.data[_],s.path,_)),alwaysSet:_ in s.data});return s.common.async?ParseStatus.mergeObjectAsync(o,d):ParseStatus.mergeObjectSync(o,d)}get element(){return this._def.valueType}static create(e,o,s){return o instanceof ZodType?new ZodRecord({keyType:e,valueType:o,typeName:ZodFirstPartyTypeKind.ZodRecord,...processCreateParams(s)}):new ZodRecord({keyType:ZodString.create(),valueType:e,typeName:ZodFirstPartyTypeKind.ZodRecord,...processCreateParams(o)})}}class ZodMap extends ZodType{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(e){const{status:o,ctx:s}=this._processInputParams(e);if(s.parsedType!==ZodParsedType.map)return addIssueToContext(s,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.map,received:s.parsedType}),INVALID;const d=this._def.keyType,c=this._def.valueType,h=[...s.data.entries()].map(([_,bt],g)=>({key:d._parse(new ParseInputLazyPath(s,_,s.path,[g,"key"])),value:c._parse(new ParseInputLazyPath(s,bt,s.path,[g,"value"]))}));if(s.common.async){const _=new Map;return Promise.resolve().then(async()=>{for(const bt of h){const g=await bt.key,j=await bt.value;if(g.status==="aborted"||j.status==="aborted")return INVALID;(g.status==="dirty"||j.status==="dirty")&&o.dirty(),_.set(g.value,j.value)}return{status:o.value,value:_}})}else{const _=new Map;for(const bt of h){const g=bt.key,j=bt.value;if(g.status==="aborted"||j.status==="aborted")return INVALID;(g.status==="dirty"||j.status==="dirty")&&o.dirty(),_.set(g.value,j.value)}return{status:o.value,value:_}}}}ZodMap.create=(a,e,o)=>new ZodMap({valueType:e,keyType:a,typeName:ZodFirstPartyTypeKind.ZodMap,...processCreateParams(o)});class ZodSet extends ZodType{_parse(e){const{status:o,ctx:s}=this._processInputParams(e);if(s.parsedType!==ZodParsedType.set)return addIssueToContext(s,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.set,received:s.parsedType}),INVALID;const d=this._def;d.minSize!==null&&s.data.size<d.minSize.value&&(addIssueToContext(s,{code:ZodIssueCode.too_small,minimum:d.minSize.value,type:"set",inclusive:!0,exact:!1,message:d.minSize.message}),o.dirty()),d.maxSize!==null&&s.data.size>d.maxSize.value&&(addIssueToContext(s,{code:ZodIssueCode.too_big,maximum:d.maxSize.value,type:"set",inclusive:!0,exact:!1,message:d.maxSize.message}),o.dirty());const c=this._def.valueType;function h(bt){const g=new Set;for(const j of bt){if(j.status==="aborted")return INVALID;j.status==="dirty"&&o.dirty(),g.add(j.value)}return{status:o.value,value:g}}const _=[...s.data.values()].map((bt,g)=>c._parse(new ParseInputLazyPath(s,bt,s.path,g)));return s.common.async?Promise.all(_).then(bt=>h(bt)):h(_)}min(e,o){return new ZodSet({...this._def,minSize:{value:e,message:errorUtil.toString(o)}})}max(e,o){return new ZodSet({...this._def,maxSize:{value:e,message:errorUtil.toString(o)}})}size(e,o){return this.min(e,o).max(e,o)}nonempty(e){return this.min(1,e)}}ZodSet.create=(a,e)=>new ZodSet({valueType:a,minSize:null,maxSize:null,typeName:ZodFirstPartyTypeKind.ZodSet,...processCreateParams(e)});class ZodFunction extends ZodType{constructor(){super(...arguments),this.validate=this.implement}_parse(e){const{ctx:o}=this._processInputParams(e);if(o.parsedType!==ZodParsedType.function)return addIssueToContext(o,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.function,received:o.parsedType}),INVALID;function s(_,bt){return makeIssue({data:_,path:o.path,errorMaps:[o.common.contextualErrorMap,o.schemaErrorMap,getErrorMap(),errorMap].filter(g=>!!g),issueData:{code:ZodIssueCode.invalid_arguments,argumentsError:bt}})}function d(_,bt){return makeIssue({data:_,path:o.path,errorMaps:[o.common.contextualErrorMap,o.schemaErrorMap,getErrorMap(),errorMap].filter(g=>!!g),issueData:{code:ZodIssueCode.invalid_return_type,returnTypeError:bt}})}const c={errorMap:o.common.contextualErrorMap},h=o.data;if(this._def.returns instanceof ZodPromise){const _=this;return OK(async function(...bt){const g=new ZodError([]),j=await _._def.args.parseAsync(bt,c).catch(It=>{throw g.addIssue(s(bt,It)),g}),b=await Reflect.apply(h,this,j);return await _._def.returns._def.type.parseAsync(b,c).catch(It=>{throw g.addIssue(d(b,It)),g})})}else{const _=this;return OK(function(...bt){const g=_._def.args.safeParse(bt,c);if(!g.success)throw new ZodError([s(bt,g.error)]);const j=Reflect.apply(h,this,g.data),b=_._def.returns.safeParse(j,c);if(!b.success)throw new ZodError([d(j,b.error)]);return b.data})}}parameters(){return this._def.args}returnType(){return this._def.returns}args(...e){return new ZodFunction({...this._def,args:ZodTuple.create(e).rest(ZodUnknown.create())})}returns(e){return new ZodFunction({...this._def,returns:e})}implement(e){return this.parse(e)}strictImplement(e){return this.parse(e)}static create(e,o,s){return new ZodFunction({args:e||ZodTuple.create([]).rest(ZodUnknown.create()),returns:o||ZodUnknown.create(),typeName:ZodFirstPartyTypeKind.ZodFunction,...processCreateParams(s)})}}class ZodLazy extends ZodType{get schema(){return this._def.getter()}_parse(e){const{ctx:o}=this._processInputParams(e);return this._def.getter()._parse({data:o.data,path:o.path,parent:o})}}ZodLazy.create=(a,e)=>new ZodLazy({getter:a,typeName:ZodFirstPartyTypeKind.ZodLazy,...processCreateParams(e)});class ZodLiteral extends ZodType{_parse(e){if(e.data!==this._def.value){const o=this._getOrReturnCtx(e);return addIssueToContext(o,{received:o.data,code:ZodIssueCode.invalid_literal,expected:this._def.value}),INVALID}return{status:"valid",value:e.data}}get value(){return this._def.value}}ZodLiteral.create=(a,e)=>new ZodLiteral({value:a,typeName:ZodFirstPartyTypeKind.ZodLiteral,...processCreateParams(e)});function createZodEnum(a,e){return new ZodEnum({values:a,typeName:ZodFirstPartyTypeKind.ZodEnum,...processCreateParams(e)})}class ZodEnum extends ZodType{constructor(){super(...arguments),_ZodEnum_cache.set(this,void 0)}_parse(e){if(typeof e.data!="string"){const o=this._getOrReturnCtx(e),s=this._def.values;return addIssueToContext(o,{expected:util.joinValues(s),received:o.parsedType,code:ZodIssueCode.invalid_type}),INVALID}if(__classPrivateFieldGet(this,_ZodEnum_cache,"f")||__classPrivateFieldSet(this,_ZodEnum_cache,new Set(this._def.values),"f"),!__classPrivateFieldGet(this,_ZodEnum_cache,"f").has(e.data)){const o=this._getOrReturnCtx(e),s=this._def.values;return addIssueToContext(o,{received:o.data,code:ZodIssueCode.invalid_enum_value,options:s}),INVALID}return OK(e.data)}get options(){return this._def.values}get enum(){const e={};for(const o of this._def.values)e[o]=o;return e}get Values(){const e={};for(const o of this._def.values)e[o]=o;return e}get Enum(){const e={};for(const o of this._def.values)e[o]=o;return e}extract(e,o=this._def){return ZodEnum.create(e,{...this._def,...o})}exclude(e,o=this._def){return ZodEnum.create(this.options.filter(s=>!e.includes(s)),{...this._def,...o})}}_ZodEnum_cache=new WeakMap;ZodEnum.create=createZodEnum;class ZodNativeEnum extends ZodType{constructor(){super(...arguments),_ZodNativeEnum_cache.set(this,void 0)}_parse(e){const o=util.getValidEnumValues(this._def.values),s=this._getOrReturnCtx(e);if(s.parsedType!==ZodParsedType.string&&s.parsedType!==ZodParsedType.number){const d=util.objectValues(o);return addIssueToContext(s,{expected:util.joinValues(d),received:s.parsedType,code:ZodIssueCode.invalid_type}),INVALID}if(__classPrivateFieldGet(this,_ZodNativeEnum_cache,"f")||__classPrivateFieldSet(this,_ZodNativeEnum_cache,new Set(util.getValidEnumValues(this._def.values)),"f"),!__classPrivateFieldGet(this,_ZodNativeEnum_cache,"f").has(e.data)){const d=util.objectValues(o);return addIssueToContext(s,{received:s.data,code:ZodIssueCode.invalid_enum_value,options:d}),INVALID}return OK(e.data)}get enum(){return this._def.values}}_ZodNativeEnum_cache=new WeakMap;ZodNativeEnum.create=(a,e)=>new ZodNativeEnum({values:a,typeName:ZodFirstPartyTypeKind.ZodNativeEnum,...processCreateParams(e)});class ZodPromise extends ZodType{unwrap(){return this._def.type}_parse(e){const{ctx:o}=this._processInputParams(e);if(o.parsedType!==ZodParsedType.promise&&o.common.async===!1)return addIssueToContext(o,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.promise,received:o.parsedType}),INVALID;const s=o.parsedType===ZodParsedType.promise?o.data:Promise.resolve(o.data);return OK(s.then(d=>this._def.type.parseAsync(d,{path:o.path,errorMap:o.common.contextualErrorMap})))}}ZodPromise.create=(a,e)=>new ZodPromise({type:a,typeName:ZodFirstPartyTypeKind.ZodPromise,...processCreateParams(e)});class ZodEffects extends ZodType{innerType(){return this._def.schema}sourceType(){return this._def.schema._def.typeName===ZodFirstPartyTypeKind.ZodEffects?this._def.schema.sourceType():this._def.schema}_parse(e){const{status:o,ctx:s}=this._processInputParams(e),d=this._def.effect||null,c={addIssue:h=>{addIssueToContext(s,h),h.fatal?o.abort():o.dirty()},get path(){return s.path}};if(c.addIssue=c.addIssue.bind(c),d.type==="preprocess"){const h=d.transform(s.data,c);if(s.common.async)return Promise.resolve(h).then(async _=>{if(o.value==="aborted")return INVALID;const bt=await this._def.schema._parseAsync({data:_,path:s.path,parent:s});return bt.status==="aborted"?INVALID:bt.status==="dirty"||o.value==="dirty"?DIRTY(bt.value):bt});{if(o.value==="aborted")return INVALID;const _=this._def.schema._parseSync({data:h,path:s.path,parent:s});return _.status==="aborted"?INVALID:_.status==="dirty"||o.value==="dirty"?DIRTY(_.value):_}}if(d.type==="refinement"){const h=_=>{const bt=d.refinement(_,c);if(s.common.async)return Promise.resolve(bt);if(bt instanceof Promise)throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");return _};if(s.common.async===!1){const _=this._def.schema._parseSync({data:s.data,path:s.path,parent:s});return _.status==="aborted"?INVALID:(_.status==="dirty"&&o.dirty(),h(_.value),{status:o.value,value:_.value})}else return this._def.schema._parseAsync({data:s.data,path:s.path,parent:s}).then(_=>_.status==="aborted"?INVALID:(_.status==="dirty"&&o.dirty(),h(_.value).then(()=>({status:o.value,value:_.value}))))}if(d.type==="transform")if(s.common.async===!1){const h=this._def.schema._parseSync({data:s.data,path:s.path,parent:s});if(!isValid(h))return h;const _=d.transform(h.value,c);if(_ instanceof Promise)throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");return{status:o.value,value:_}}else return this._def.schema._parseAsync({data:s.data,path:s.path,parent:s}).then(h=>isValid(h)?Promise.resolve(d.transform(h.value,c)).then(_=>({status:o.value,value:_})):h);util.assertNever(d)}}ZodEffects.create=(a,e,o)=>new ZodEffects({schema:a,typeName:ZodFirstPartyTypeKind.ZodEffects,effect:e,...processCreateParams(o)});ZodEffects.createWithPreprocess=(a,e,o)=>new ZodEffects({schema:e,effect:{type:"preprocess",transform:a},typeName:ZodFirstPartyTypeKind.ZodEffects,...processCreateParams(o)});class ZodOptional extends ZodType{_parse(e){return this._getType(e)===ZodParsedType.undefined?OK(void 0):this._def.innerType._parse(e)}unwrap(){return this._def.innerType}}ZodOptional.create=(a,e)=>new ZodOptional({innerType:a,typeName:ZodFirstPartyTypeKind.ZodOptional,...processCreateParams(e)});class ZodNullable extends ZodType{_parse(e){return this._getType(e)===ZodParsedType.null?OK(null):this._def.innerType._parse(e)}unwrap(){return this._def.innerType}}ZodNullable.create=(a,e)=>new ZodNullable({innerType:a,typeName:ZodFirstPartyTypeKind.ZodNullable,...processCreateParams(e)});class ZodDefault extends ZodType{_parse(e){const{ctx:o}=this._processInputParams(e);let s=o.data;return o.parsedType===ZodParsedType.undefined&&(s=this._def.defaultValue()),this._def.innerType._parse({data:s,path:o.path,parent:o})}removeDefault(){return this._def.innerType}}ZodDefault.create=(a,e)=>new ZodDefault({innerType:a,typeName:ZodFirstPartyTypeKind.ZodDefault,defaultValue:typeof e.default=="function"?e.default:()=>e.default,...processCreateParams(e)});class ZodCatch extends ZodType{_parse(e){const{ctx:o}=this._processInputParams(e),s={...o,common:{...o.common,issues:[]}},d=this._def.innerType._parse({data:s.data,path:s.path,parent:{...s}});return isAsync(d)?d.then(c=>({status:"valid",value:c.status==="valid"?c.value:this._def.catchValue({get error(){return new ZodError(s.common.issues)},input:s.data})})):{status:"valid",value:d.status==="valid"?d.value:this._def.catchValue({get error(){return new ZodError(s.common.issues)},input:s.data})}}removeCatch(){return this._def.innerType}}ZodCatch.create=(a,e)=>new ZodCatch({innerType:a,typeName:ZodFirstPartyTypeKind.ZodCatch,catchValue:typeof e.catch=="function"?e.catch:()=>e.catch,...processCreateParams(e)});class ZodNaN extends ZodType{_parse(e){if(this._getType(e)!==ZodParsedType.nan){const s=this._getOrReturnCtx(e);return addIssueToContext(s,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.nan,received:s.parsedType}),INVALID}return{status:"valid",value:e.data}}}ZodNaN.create=a=>new ZodNaN({typeName:ZodFirstPartyTypeKind.ZodNaN,...processCreateParams(a)});const BRAND=Symbol("zod_brand");class ZodBranded extends ZodType{_parse(e){const{ctx:o}=this._processInputParams(e),s=o.data;return this._def.type._parse({data:s,path:o.path,parent:o})}unwrap(){return this._def.type}}class ZodPipeline extends ZodType{_parse(e){const{status:o,ctx:s}=this._processInputParams(e);if(s.common.async)return(async()=>{const c=await this._def.in._parseAsync({data:s.data,path:s.path,parent:s});return c.status==="aborted"?INVALID:c.status==="dirty"?(o.dirty(),DIRTY(c.value)):this._def.out._parseAsync({data:c.value,path:s.path,parent:s})})();{const d=this._def.in._parseSync({data:s.data,path:s.path,parent:s});return d.status==="aborted"?INVALID:d.status==="dirty"?(o.dirty(),{status:"dirty",value:d.value}):this._def.out._parseSync({data:d.value,path:s.path,parent:s})}}static create(e,o){return new ZodPipeline({in:e,out:o,typeName:ZodFirstPartyTypeKind.ZodPipeline})}}class ZodReadonly extends ZodType{_parse(e){const o=this._def.innerType._parse(e),s=d=>(isValid(d)&&(d.value=Object.freeze(d.value)),d);return isAsync(o)?o.then(d=>s(d)):s(o)}unwrap(){return this._def.innerType}}ZodReadonly.create=(a,e)=>new ZodReadonly({innerType:a,typeName:ZodFirstPartyTypeKind.ZodReadonly,...processCreateParams(e)});function custom(a,e={},o){return a?ZodAny.create().superRefine((s,d)=>{var c,h;if(!a(s)){const _=typeof e=="function"?e(s):typeof e=="string"?{message:e}:e,bt=(h=(c=_.fatal)!==null&&c!==void 0?c:o)!==null&&h!==void 0?h:!0,g=typeof _=="string"?{message:_}:_;d.addIssue({code:"custom",...g,fatal:bt})}}):ZodAny.create()}const late={object:ZodObject.lazycreate};var ZodFirstPartyTypeKind;(function(a){a.ZodString="ZodString",a.ZodNumber="ZodNumber",a.ZodNaN="ZodNaN",a.ZodBigInt="ZodBigInt",a.ZodBoolean="ZodBoolean",a.ZodDate="ZodDate",a.ZodSymbol="ZodSymbol",a.ZodUndefined="ZodUndefined",a.ZodNull="ZodNull",a.ZodAny="ZodAny",a.ZodUnknown="ZodUnknown",a.ZodNever="ZodNever",a.ZodVoid="ZodVoid",a.ZodArray="ZodArray",a.ZodObject="ZodObject",a.ZodUnion="ZodUnion",a.ZodDiscriminatedUnion="ZodDiscriminatedUnion",a.ZodIntersection="ZodIntersection",a.ZodTuple="ZodTuple",a.ZodRecord="ZodRecord",a.ZodMap="ZodMap",a.ZodSet="ZodSet",a.ZodFunction="ZodFunction",a.ZodLazy="ZodLazy",a.ZodLiteral="ZodLiteral",a.ZodEnum="ZodEnum",a.ZodEffects="ZodEffects",a.ZodNativeEnum="ZodNativeEnum",a.ZodOptional="ZodOptional",a.ZodNullable="ZodNullable",a.ZodDefault="ZodDefault",a.ZodCatch="ZodCatch",a.ZodPromise="ZodPromise",a.ZodBranded="ZodBranded",a.ZodPipeline="ZodPipeline",a.ZodReadonly="ZodReadonly"})(ZodFirstPartyTypeKind||(ZodFirstPartyTypeKind={}));const instanceOfType=(a,e={message:`Input not instance of ${a.name}`})=>custom(o=>o instanceof a,e),stringType=ZodString.create,numberType=ZodNumber.create,nanType=ZodNaN.create,bigIntType=ZodBigInt.create,booleanType=ZodBoolean.create,dateType=ZodDate.create,symbolType=ZodSymbol.create,undefinedType=ZodUndefined.create,nullType=ZodNull.create,anyType=ZodAny.create,unknownType=ZodUnknown.create,neverType=ZodNever.create,voidType=ZodVoid.create,arrayType=ZodArray.create,objectType=ZodObject.create,strictObjectType=ZodObject.strictCreate,unionType=ZodUnion.create,discriminatedUnionType=ZodDiscriminatedUnion.create,intersectionType=ZodIntersection.create,tupleType=ZodTuple.create,recordType=ZodRecord.create,mapType=ZodMap.create,setType=ZodSet.create,functionType=ZodFunction.create,lazyType=ZodLazy.create,literalType=ZodLiteral.create,enumType=ZodEnum.create,nativeEnumType=ZodNativeEnum.create,promiseType=ZodPromise.create,effectsType=ZodEffects.create,optionalType=ZodOptional.create,nullableType=ZodNullable.create,preprocessType=ZodEffects.createWithPreprocess,pipelineType=ZodPipeline.create,ostring=()=>stringType().optional(),onumber=()=>numberType().optional(),oboolean=()=>booleanType().optional(),coerce={string:a=>ZodString.create({...a,coerce:!0}),number:a=>ZodNumber.create({...a,coerce:!0}),boolean:a=>ZodBoolean.create({...a,coerce:!0}),bigint:a=>ZodBigInt.create({...a,coerce:!0}),date:a=>ZodDate.create({...a,coerce:!0})},NEVER=INVALID;var z=Object.freeze({__proto__:null,defaultErrorMap:errorMap,setErrorMap,getErrorMap,makeIssue,EMPTY_PATH,addIssueToContext,ParseStatus,INVALID,DIRTY,OK,isAborted,isDirty,isValid,isAsync,get util(){return util},get objectUtil(){return objectUtil},ZodParsedType,getParsedType,ZodType,datetimeRegex,ZodString,ZodNumber,ZodBigInt,ZodBoolean,ZodDate,ZodSymbol,ZodUndefined,ZodNull,ZodAny,ZodUnknown,ZodNever,ZodVoid,ZodArray,ZodObject,ZodUnion,ZodDiscriminatedUnion,ZodIntersection,ZodTuple,ZodRecord,ZodMap,ZodSet,ZodFunction,ZodLazy,ZodLiteral,ZodEnum,ZodNativeEnum,ZodPromise,ZodEffects,ZodTransformer:ZodEffects,ZodOptional,ZodNullable,ZodDefault,ZodCatch,ZodNaN,BRAND,ZodBranded,ZodPipeline,ZodReadonly,custom,Schema:ZodType,ZodSchema:ZodType,late,get ZodFirstPartyTypeKind(){return ZodFirstPartyTypeKind},coerce,any:anyType,array:arrayType,bigint:bigIntType,boolean:booleanType,date:dateType,discriminatedUnion:discriminatedUnionType,effect:effectsType,enum:enumType,function:functionType,instanceof:instanceOfType,intersection:intersectionType,lazy:lazyType,literal:literalType,map:mapType,nan:nanType,nativeEnum:nativeEnumType,never:neverType,null:nullType,nullable:nullableType,number:numberType,object:objectType,oboolean,onumber,optional:optionalType,ostring,pipeline:pipelineType,preprocess:preprocessType,promise:promiseType,record:recordType,set:setType,strictObject:strictObjectType,string:stringType,symbol:symbolType,transformer:effectsType,tuple:tupleType,undefined:undefinedType,union:unionType,unknown:unknownType,void:voidType,NEVER,ZodIssueCode,quotelessJson,ZodError}),__create=Object.create,__defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty,__commonJS=(a,e)=>function(){return e||(0,a[__getOwnPropNames(a)[0]])((e={exports:{}}).exports,e),e.exports},__copyProps=(a,e,o,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let d of __getOwnPropNames(e))!__hasOwnProp.call(a,d)&&d!==o&&__defProp(a,d,{get:()=>e[d],enumerable:!(s=__getOwnPropDesc(e,d))||s.enumerable});return a},__toESM=(a,e,o)=>(o=a!=null?__create(__getProtoOf(a)):{},__copyProps(e||!a||!a.__esModule?__defProp(o,"default",{value:a,enumerable:!0}):o,a)),require_lodash=__commonJS({"../../node_modules/lodash/lodash.js"(a,e){(function(){var o,s="4.17.21",d=200,c="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",h="Expected a function",_="Invalid `variable` option passed into `_.template`",bt="__lodash_hash_undefined__",g=500,j="__lodash_placeholder__",b=1,Et=2,It=4,zt=1,er=2,Hn=1,Qt=2,cr=4,fr=8,jr=16,e0=32,t0=64,o0=128,l0=256,g0=512,i0=30,f0="...",C0=800,Z0=16,R0=1,Y0=2,H0=3,ty=1/0,w0=9007199254740991,L0=17976931348623157e292,k0=NaN,T0=4294967295,q0=T0-1,vy=T0>>>1,J0=[["ary",o0],["bind",Hn],["bindKey",Qt],["curry",fr],["curryRight",jr],["flip",g0],["partial",e0],["partialRight",t0],["rearg",l0]],cy="[object Arguments]",Ty="[object Array]",Uy="[object AsyncFunction]",Qy="[object Boolean]",Zy="[object Date]",iv="[object DOMException]",zy="[object Error]",B0="[object Function]",Ay="[object GeneratorFunction]",hy="[object Map]",Ly="[object Number]",Iy="[object Null]",Jy="[object Object]",Gy="[object Promise]",sv="[object Proxy]",yv="[object RegExp]",I0="[object Set]",b0="[object String]",uy="[object Symbol]",Ey="[object Undefined]",Dy="[object WeakMap]",By="[object WeakSet]",bv="[object ArrayBuffer]",av="[object DataView]",Wy="[object Float32Array]",my="[object Float64Array]",uv="[object Int8Array]",Hy="[object Int16Array]",wv="[object Int32Array]",mv="[object Uint8Array]",cv="[object Uint8ClampedArray]",O0="[object Uint16Array]",oy="[object Uint32Array]",Py=/\b__p \+= '';/g,nv=/\b(__p \+=) '' \+/g,d0=/(__e\(.*?\)|\b__t\)) \+\n'';/g,v0=/&(?:amp|lt|gt|quot|#39);/g,N0=/[&<>"']/g,F0=RegExp(v0.source),sy=RegExp(N0.source),xy=/<%-([\s\S]+?)%>/g,ev=/<%([\s\S]+?)%>/g,Sv=/<%=([\s\S]+?)%>/g,kv=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Vv=/^\w*$/,$v=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,ov=/[\\^$.*+?()[\]{}|]/g,C_=RegExp(ov.source),wy=/^\s+/,Zv=/\s/,Xv=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,v_=/\{\n\/\* \[wrapped with (.+)\] \*/,Rv=/,? & /,i1=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,h1=/[()=,{}\[\]\/\s]/,m0=/\\(\\)?/g,E0=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,j0=/\w*$/,h0=/^[-+]0x[0-9a-f]+$/i,$0=/^0b[01]+$/i,P0=/^\[object .+?Constructor\]$/,Yr=/^0o[0-7]+$/i,r0=/^(?:0|[1-9]\d*)$/,p0=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,_0=/($^)/,D0=/['\n\r\u2028\u2029\\]/g,V0="\\ud800-\\udfff",yy="\\u0300-\\u036f",ly="\\ufe20-\\ufe2f",gy="\\u20d0-\\u20ff",ky=yy+ly+gy,jy="\\u2700-\\u27bf",rv="a-z\\xdf-\\xf6\\xf8-\\xff",dv="\\xac\\xb1\\xd7\\xf7",K0="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",Cy="\\u2000-\\u206f",lv=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",vv="A-Z\\xc0-\\xd6\\xd8-\\xde",Mv="\\ufe0e\\ufe0f",f_=dv+K0+Cy+lv,b_="['’]",x_="["+V0+"]",o_="["+f_+"]",Yy="["+ky+"]",w_="\\d+",Ov="["+jy+"]",Qv="["+rv+"]",s_="[^"+V0+f_+w_+jy+rv+vv+"]",S_="\\ud83c[\\udffb-\\udfff]",B_="(?:"+Yy+"|"+S_+")",z_="[^"+V0+"]",D1="(?:\\ud83c[\\udde6-\\uddff]){2}",B1="[\\ud800-\\udbff][\\udc00-\\udfff]",m1="["+vv+"]",S1="\\u200d",vw="(?:"+Qv+"|"+s_+")",Hw="(?:"+m1+"|"+s_+")",Cw="(?:"+b_+"(?:d|ll|m|re|s|t|ve))?",H1="(?:"+b_+"(?:D|LL|M|RE|S|T|VE))?",W1=B_+"?",u0="["+Mv+"]?",M0="(?:"+S1+"(?:"+[z_,D1,B1].join("|")+")"+u0+W1+")*",G0="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",X0="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",Ky=u0+W1+M0,Xy="(?:"+[Ov,D1,B1].join("|")+")"+Ky,_v="(?:"+[z_+Yy+"?",Yy,D1,B1,x_].join("|")+")",A_=RegExp(b_,"g"),y_=RegExp(Yy,"g"),$_=RegExp(S_+"(?="+S_+")|"+_v+Ky,"g"),G_=RegExp([m1+"?"+Qv+"+"+Cw+"(?="+[o_,m1,"$"].join("|")+")",Hw+"+"+H1+"(?="+[o_,m1+vw,"$"].join("|")+")",m1+"?"+vw+"+"+Cw,m1+"+"+H1,X0,G0,w_,Xy].join("|"),"g"),aw=RegExp("["+S1+V0+ky+Mv+"]"),Ww=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,Ry=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],t_=-1,Pv={};Pv[Wy]=Pv[my]=Pv[uv]=Pv[Hy]=Pv[wv]=Pv[mv]=Pv[cv]=Pv[O0]=Pv[oy]=!0,Pv[cy]=Pv[Ty]=Pv[bv]=Pv[Qy]=Pv[av]=Pv[Zy]=Pv[zy]=Pv[B0]=Pv[hy]=Pv[Ly]=Pv[Jy]=Pv[yv]=Pv[I0]=Pv[b0]=Pv[Dy]=!1;var l_={};l_[cy]=l_[Ty]=l_[bv]=l_[av]=l_[Qy]=l_[Zy]=l_[Wy]=l_[my]=l_[uv]=l_[Hy]=l_[wv]=l_[hy]=l_[Ly]=l_[Jy]=l_[yv]=l_[I0]=l_[b0]=l_[uy]=l_[mv]=l_[cv]=l_[O0]=l_[oy]=!0,l_[zy]=l_[B0]=l_[Dy]=!1;var t1={À:"A",Á:"A",Â:"A",Ã:"A",Ä:"A",Å:"A",à:"a",á:"a",â:"a",ã:"a",ä:"a",å:"a",Ç:"C",ç:"c",Ð:"D",ð:"d",È:"E",É:"E",Ê:"E",Ë:"E",è:"e",é:"e",ê:"e",ë:"e",Ì:"I",Í:"I",Î:"I",Ï:"I",ì:"i",í:"i",î:"i",ï:"i",Ñ:"N",ñ:"n",Ò:"O",Ó:"O",Ô:"O",Õ:"O",Ö:"O",Ø:"O",ò:"o",ó:"o",ô:"o",õ:"o",ö:"o",ø:"o",Ù:"U",Ú:"U",Û:"U",Ü:"U",ù:"u",ú:"u",û:"u",ü:"u",Ý:"Y",ý:"y",ÿ:"y",Æ:"Ae",æ:"ae",Þ:"Th",þ:"th",ß:"ss",Ā:"A",Ă:"A",Ą:"A",ā:"a",ă:"a",ą:"a",Ć:"C",Ĉ:"C",Ċ:"C",Č:"C",ć:"c",ĉ:"c",ċ:"c",č:"c",Ď:"D",Đ:"D",ď:"d",đ:"d",Ē:"E",Ĕ:"E",Ė:"E",Ę:"E",Ě:"E",ē:"e",ĕ:"e",ė:"e",ę:"e",ě:"e",Ĝ:"G",Ğ:"G",Ġ:"G",Ģ:"G",ĝ:"g",ğ:"g",ġ:"g",ģ:"g",Ĥ:"H",Ħ:"H",ĥ:"h",ħ:"h",Ĩ:"I",Ī:"I",Ĭ:"I",Į:"I",İ:"I",ĩ:"i",ī:"i",ĭ:"i",į:"i",ı:"i",Ĵ:"J",ĵ:"j",Ķ:"K",ķ:"k",ĸ:"k",Ĺ:"L",Ļ:"L",Ľ:"L",Ŀ:"L",Ł:"L",ĺ:"l",ļ:"l",ľ:"l",ŀ:"l",ł:"l",Ń:"N",Ņ:"N",Ň:"N",Ŋ:"N",ń:"n",ņ:"n",ň:"n",ŋ:"n",Ō:"O",Ŏ:"O",Ő:"O",ō:"o",ŏ:"o",ő:"o",Ŕ:"R",Ŗ:"R",Ř:"R",ŕ:"r",ŗ:"r",ř:"r",Ś:"S",Ŝ:"S",Ş:"S",Š:"S",ś:"s",ŝ:"s",ş:"s",š:"s",Ţ:"T",Ť:"T",Ŧ:"T",ţ:"t",ť:"t",ŧ:"t",Ũ:"U",Ū:"U",Ŭ:"U",Ů:"U",Ű:"U",Ų:"U",ũ:"u",ū:"u",ŭ:"u",ů:"u",ű:"u",ų:"u",Ŵ:"W",ŵ:"w",Ŷ:"Y",ŷ:"y",Ÿ:"Y",Ź:"Z",Ż:"Z",Ž:"Z",ź:"z",ż:"z",ž:"z",Ĳ:"IJ",ĳ:"ij",Œ:"Oe",œ:"oe",ŉ:"'n",ſ:"s"},L1={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},jw={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},lx={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Fx=parseFloat,y2=parseInt,E1=typeof global=="object"&&global&&global.Object===Object&&global,ux=typeof self=="object"&&self&&self.Object===Object&&self,O_=E1||ux||Function("return this")(),om=typeof a=="object"&&a&&!a.nodeType&&a,c0=om&&typeof e=="object"&&e&&!e.nodeType&&e,x0=c0&&c0.exports===om,U0=x0&&E1.process,ry=function(){try{var ey=c0&&c0.require&&c0.require("util").types;return ey||U0&&U0.binding&&U0.binding("util")}catch{}}(),by=ry&&ry.isArrayBuffer,Vy=ry&&ry.isDate,Ev=ry&&ry.isMap,Hv=ry&&ry.isRegExp,Nv=ry&&ry.isSet,jv=ry&&ry.isTypedArray;function Lv(ey,Oy,Sy){switch(Sy.length){case 0:return ey.call(Oy);case 1:return ey.call(Oy,Sy[0]);case 2:return ey.call(Oy,Sy[0],Sy[1]);case 3:return ey.call(Oy,Sy[0],Sy[1],Sy[2])}return ey.apply(Oy,Sy)}function p_(ey,Oy,Sy,gv){for(var Wv=-1,e_=ey==null?0:ey.length;++Wv<e_;){var D_=ey[Wv];Oy(gv,D_,Sy(D_),ey)}return gv}function dy(ey,Oy){for(var Sy=-1,gv=ey==null?0:ey.length;++Sy<gv&&Oy(ey[Sy],Sy,ey)!==!1;);return ey}function qv(ey,Oy){for(var Sy=ey==null?0:ey.length;Sy--&&Oy(ey[Sy],Sy,ey)!==!1;);return ey}function d_(ey,Oy){for(var Sy=-1,gv=ey==null?0:ey.length;++Sy<gv;)if(!Oy(ey[Sy],Sy,ey))return!1;return!0}function P_(ey,Oy){for(var Sy=-1,gv=ey==null?0:ey.length,Wv=0,e_=[];++Sy<gv;){var D_=ey[Sy];Oy(D_,Sy,ey)&&(e_[Wv++]=D_)}return e_}function _1(ey,Oy){var Sy=ey==null?0:ey.length;return!!Sy&&q1(ey,Oy,0)>-1}function cx(ey,Oy,Sy){for(var gv=-1,Wv=ey==null?0:ey.length;++gv<Wv;)if(Sy(Oy,ey[gv]))return!0;return!1}function M_(ey,Oy){for(var Sy=-1,gv=ey==null?0:ey.length,Wv=Array(gv);++Sy<gv;)Wv[Sy]=Oy(ey[Sy],Sy,ey);return Wv}function j1(ey,Oy){for(var Sy=-1,gv=Oy.length,Wv=ey.length;++Sy<gv;)ey[Wv+Sy]=Oy[Sy];return ey}function v2(ey,Oy,Sy,gv){var Wv=-1,e_=ey==null?0:ey.length;for(gv&&e_&&(Sy=ey[++Wv]);++Wv<e_;)Sy=Oy(Sy,ey[Wv],Wv,ey);return Sy}function DS(ey,Oy,Sy,gv){var Wv=ey==null?0:ey.length;for(gv&&Wv&&(Sy=ey[--Wv]);Wv--;)Sy=Oy(Sy,ey[Wv],Wv,ey);return Sy}function Ux(ey,Oy){for(var Sy=-1,gv=ey==null?0:ey.length;++Sy<gv;)if(Oy(ey[Sy],Sy,ey))return!0;return!1}var _2=b1("length");function BS(ey){return ey.split("")}function LS(ey){return ey.match(i1)||[]}function j2(ey,Oy,Sy){var gv;return Sy(ey,function(Wv,e_,D_){if(Oy(Wv,e_,D_))return gv=e_,!1}),gv}function dx(ey,Oy,Sy,gv){for(var Wv=ey.length,e_=Sy+(gv?1:-1);gv?e_--:++e_<Wv;)if(Oy(ey[e_],e_,ey))return e_;return-1}function q1(ey,Oy,Sy){return Oy===Oy?yx(ey,Oy,Sy):dx(ey,zx,Sy)}function fx(ey,Oy,Sy,gv){for(var Wv=Sy-1,e_=ey.length;++Wv<e_;)if(gv(ey[Wv],Oy))return Wv;return-1}function zx(ey){return ey!==ey}function Gx(ey,Oy){var Sy=ey==null?0:ey.length;return Sy?Z1(ey,Oy)/Sy:k0}function b1(ey){return function(Oy){return Oy==null?o:Oy[ey]}}function w1(ey){return function(Oy){return ey==null?o:ey[Oy]}}function Mw(ey,Oy,Sy,gv,Wv){return Wv(ey,function(e_,D_,Uv){Sy=gv?(gv=!1,e_):Oy(Sy,e_,D_,Uv)}),Sy}function _w(ey,Oy){var Sy=ey.length;for(ey.sort(Oy);Sy--;)ey[Sy]=ey[Sy].value;return ey}function Z1(ey,Oy){for(var Sy,gv=-1,Wv=ey.length;++gv<Wv;){var e_=Oy(ey[gv]);e_!==o&&(Sy=Sy===o?e_:Sy+e_)}return Sy}function bw(ey,Oy){for(var Sy=-1,gv=Array(ey);++Sy<ey;)gv[Sy]=Oy(Sy);return gv}function kS(ey,Oy){return M_(Oy,function(Sy){return[Sy,ey[Sy]]})}function b2(ey){return ey&&ey.slice(0,vx(ey)+1).replace(wy,"")}function g1(ey){return function(Oy){return ey(Oy)}}function y1(ey,Oy){return M_(Oy,function(Sy){return ey[Sy]})}function n1(ey,Oy){return ey.has(Oy)}function I_(ey,Oy){for(var Sy=-1,gv=ey.length;++Sy<gv&&q1(Oy,ey[Sy],0)>-1;);return Sy}function hx(ey,Oy){for(var Sy=ey.length;Sy--&&q1(Oy,ey[Sy],0)>-1;);return Sy}function K1(ey,Oy){for(var Sy=ey.length,gv=0;Sy--;)ey[Sy]===Oy&&++gv;return gv}var NS=w1(t1),FS=w1(L1);function q2(ey){return"\\"+lx[ey]}function Z2(ey,Oy){return ey==null?o:ey[Oy]}function qw(ey){return aw.test(ey)}function Vx(ey){return Ww.test(ey)}function mx(ey){for(var Oy,Sy=[];!(Oy=ey.next()).done;)Sy.push(Oy.value);return Sy}function Hx(ey){var Oy=-1,Sy=Array(ey.size);return ey.forEach(function(gv,Wv){Sy[++Oy]=[Wv,gv]}),Sy}function gx(ey,Oy){return function(Sy){return ey(Oy(Sy))}}function X1(ey,Oy){for(var Sy=-1,gv=ey.length,Wv=0,e_=[];++Sy<gv;){var D_=ey[Sy];(D_===Oy||D_===j)&&(ey[Sy]=j,e_[Wv++]=Sy)}return e_}function Wx(ey){var Oy=-1,Sy=Array(ey.size);return ey.forEach(function(gv){Sy[++Oy]=gv}),Sy}function US(ey){var Oy=-1,Sy=Array(ey.size);return ey.forEach(function(gv){Sy[++Oy]=[gv,gv]}),Sy}function yx(ey,Oy,Sy){for(var gv=Sy-1,Wv=ey.length;++gv<Wv;)if(ey[gv]===Oy)return gv;return-1}function zS(ey,Oy,Sy){for(var gv=Sy+1;gv--;)if(ey[gv]===Oy)return gv;return gv}function ow(ey){return qw(ey)?sw(ey):_2(ey)}function L_(ey){return qw(ey)?K2(ey):BS(ey)}function vx(ey){for(var Oy=ey.length;Oy--&&Zv.test(ey.charAt(Oy)););return Oy}var bx=w1(jw);function sw(ey){for(var Oy=$_.lastIndex=0;$_.test(ey);)++Oy;return Oy}function K2(ey){return ey.match($_)||[]}function wx(ey){return ey.match(G_)||[]}var GS=function ey(Oy){Oy=Oy==null?O_:lw.defaults(O_.Object(),Oy,lw.pick(O_,Ry));var Sy=Oy.Array,gv=Oy.Date,Wv=Oy.Error,e_=Oy.Function,D_=Oy.Math,Uv=Oy.Object,J_=Oy.RegExp,Q_=Oy.String,v1=Oy.TypeError,Iw=Sy.prototype,jx=e_.prototype,xx=Uv.prototype,q_=Oy["__core-js_shared__"],Sx=jx.toString,__=xx.hasOwnProperty,X2=0,uw=function(){var At=/[^.]+$/.exec(q_&&q_.keys&&q_.keys.IE_PROTO||"");return At?"Symbol(src)_1."+At:""}(),T1=xx.toString,Zw=Sx.call(Uv),w2=O_._,x2=J_("^"+Sx.call(__).replace(ov,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),qx=x0?Oy.Buffer:o,ww=Oy.Symbol,Zx=Oy.Uint8Array,Y2=qx?qx.allocUnsafe:o,Kx=gx(Uv.getPrototypeOf,Uv),J2=Uv.create,S2=xx.propertyIsEnumerable,Rw=Iw.splice,Q2=ww?ww.isConcatSpreadable:o,Ow=ww?ww.iterator:o,cw=ww?ww.toStringTag:o,Ex=function(){try{var At=h2(Uv,"defineProperty");return At({},"",{}),At}catch{}}(),Xx=Oy.clearTimeout!==O_.clearTimeout&&Oy.clearTimeout,VS=gv&&gv.now!==O_.Date.now&&gv.now,HS=Oy.setTimeout!==O_.setTimeout&&Oy.setTimeout,Yx=D_.ceil,Jx=D_.floor,Qx=Uv.getOwnPropertySymbols,WS=qx?qx.isBuffer:o,eS=Oy.isFinite,kE=Iw.join,jS=gx(Uv.keys,Uv),Z_=D_.max,a1=D_.min,qS=gv.now,ZS=Oy.parseInt,tS=D_.random,KS=Iw.reverse,Tx=h2(Oy,"DataView"),e2=h2(Oy,"Map"),nS=h2(Oy,"Promise"),Ax=h2(Oy,"Set"),Kw=h2(Oy,"WeakMap"),Xw=h2(Uv,"create"),E2=Kw&&new Kw,Yw={},XS=m2(Tx),YS=m2(e2),JS=m2(nS),QS=m2(Ax),dw=m2(Kw),t2=ww?ww.prototype:o,xw=t2?t2.valueOf:o,$x=t2?t2.toString:o;function S0(At){if(j_(At)&&!n_(At)&&!(At instanceof Bv)){if(At instanceof o1)return At;if(__.call(At,"__wrapped__"))return MT(At)}return new o1(At)}var Sw=function(){function At(){}return function(Yt){if(!U_(Yt))return{};if(J2)return J2(Yt);At.prototype=Yt;var _r=new At;return At.prototype=o,_r}}();function n2(){}function o1(At,Yt){this.__wrapped__=At,this.__actions__=[],this.__chain__=!!Yt,this.__index__=0,this.__values__=o}S0.templateSettings={escape:xy,evaluate:ev,interpolate:Sv,variable:"",imports:{_:S0}},S0.prototype=n2.prototype,S0.prototype.constructor=S0,o1.prototype=Sw(n2.prototype),o1.prototype.constructor=o1;function Bv(At){this.__wrapped__=At,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=T0,this.__views__=[]}function NE(){var At=new Bv(this.__wrapped__);return At.__actions__=d1(this.__actions__),At.__dir__=this.__dir__,At.__filtered__=this.__filtered__,At.__iteratees__=d1(this.__iteratees__),At.__takeCount__=this.__takeCount__,At.__views__=d1(this.__views__),At}function FE(){if(this.__filtered__){var At=new Bv(this);At.__dir__=-1,At.__filtered__=!0}else At=this.clone(),At.__dir__*=-1;return At}function A1(){var At=this.__wrapped__.value(),Yt=this.__dir__,_r=n_(At),a0=Yt<0,y0=_r?At.length:0,A0=yA(0,y0,this.__views__),W0=A0.start,Q0=A0.end,ay=Q0-W0,Ny=a0?Q0:W0-1,Fy=this.__iteratees__,qy=Fy.length,pv=0,Cv=a1(ay,this.__takeCount__);if(!_r||!a0&&y0==ay&&Cv==ay)return Nw(At,this.__actions__);var zv=[];e:for(;ay--&&pv<Cv;){Ny+=Yt;for(var c_=-1,Gv=At[Ny];++c_<qy;){var h_=Fy[c_],g_=h_.iteratee,rw=h_.type,P1=g_(Gv);if(rw==Y0)Gv=P1;else if(!P1){if(rw==R0)continue e;break e}}zv[pv++]=Gv}return zv}Bv.prototype=Sw(n2.prototype),Bv.prototype.constructor=Bv;function k_(At){var Yt=-1,_r=At==null?0:At.length;for(this.clear();++Yt<_r;){var a0=At[Yt];this.set(a0[0],a0[1])}}function eE(){this.__data__=Xw?Xw(null):{},this.size=0}function tE(At){var Yt=this.has(At)&&delete this.__data__[At];return this.size-=Yt?1:0,Yt}function nE(At){var Yt=this.__data__;if(Xw){var _r=Yt[At];return _r===bt?o:_r}return __.call(Yt,At)?Yt[At]:o}function rE(At){var Yt=this.__data__;return Xw?Yt[At]!==o:__.call(Yt,At)}function iE(At,Yt){var _r=this.__data__;return this.size+=this.has(At)?0:1,_r[At]=Xw&&Yt===o?bt:Yt,this}k_.prototype.clear=eE,k_.prototype.delete=tE,k_.prototype.get=nE,k_.prototype.has=rE,k_.prototype.set=iE;function Y1(At){var Yt=-1,_r=At==null?0:At.length;for(this.clear();++Yt<_r;){var a0=At[Yt];this.set(a0[0],a0[1])}}function aE(){this.__data__=[],this.size=0}function rS(At){var Yt=this.__data__,_r=Dw(Yt,At);if(_r<0)return!1;var a0=Yt.length-1;return _r==a0?Yt.pop():Rw.call(Yt,_r,1),--this.size,!0}function oE(At){var Yt=this.__data__,_r=Dw(Yt,At);return _r<0?o:Yt[_r][1]}function sE(At){return Dw(this.__data__,At)>-1}function T2(At,Yt){var _r=this.__data__,a0=Dw(_r,At);return a0<0?(++this.size,_r.push([At,Yt])):_r[a0][1]=Yt,this}Y1.prototype.clear=aE,Y1.prototype.delete=rS,Y1.prototype.get=oE,Y1.prototype.has=sE,Y1.prototype.set=T2;function k1(At){var Yt=-1,_r=At==null?0:At.length;for(this.clear();++Yt<_r;){var a0=At[Yt];this.set(a0[0],a0[1])}}function lE(){this.size=0,this.__data__={hash:new k_,map:new(e2||Y1),string:new k_}}function iS(At){var Yt=TE(this,At).delete(At);return this.size-=Yt?1:0,Yt}function uE(At){return TE(this,At).get(At)}function cE(At){return TE(this,At).has(At)}function A2(At,Yt){var _r=TE(this,At),a0=_r.size;return _r.set(At,Yt),this.size+=_r.size==a0?0:1,this}k1.prototype.clear=lE,k1.prototype.delete=iS,k1.prototype.get=uE,k1.prototype.has=cE,k1.prototype.set=A2;function Pw(At){var Yt=-1,_r=At==null?0:At.length;for(this.__data__=new k1;++Yt<_r;)this.add(At[Yt])}function aS(At){return this.__data__.set(At,bt),this}function dE(At){return this.__data__.has(At)}Pw.prototype.add=Pw.prototype.push=aS,Pw.prototype.has=dE;function K_(At){var Yt=this.__data__=new Y1(At);this.size=Yt.size}function UE(){this.__data__=new Y1,this.size=0}function zE(At){var Yt=this.__data__,_r=Yt.delete(At);return this.size=Yt.size,_r}function $2(At){return this.__data__.get(At)}function Jw(At){return this.__data__.has(At)}function GE(At,Yt){var _r=this.__data__;if(_r instanceof Y1){var a0=_r.__data__;if(!e2||a0.length<d-1)return a0.push([At,Yt]),this.size=++_r.size,this;_r=this.__data__=new k1(a0)}return _r.set(At,Yt),this.size=_r.size,this}K_.prototype.clear=UE,K_.prototype.delete=zE,K_.prototype.get=$2,K_.prototype.has=Jw,K_.prototype.set=GE;function fv(At,Yt){var _r=n_(At),a0=!_r&&g2(At),y0=!_r&&!a0&&kx(At),A0=!_r&&!a0&&!y0&&H2(At),W0=_r||a0||y0||A0,Q0=W0?bw(At.length,Q_):[],ay=Q0.length;for(var Ny in At)(Yt||__.call(At,Ny))&&!(W0&&(Ny=="length"||y0&&(Ny=="offset"||Ny=="parent")||A0&&(Ny=="buffer"||Ny=="byteLength"||Ny=="byteOffset")||ix(Ny,ay)))&&Q0.push(Ny);return Q0}function r2(At){var Yt=At.length;return Yt?At[pw(0,Yt-1)]:o}function oS(At,Yt){return AE(d1(At),Bw(Yt,0,At.length))}function fE(At){return AE(d1(At))}function sS(At,Yt,_r){(_r!==o&&!Aw(At[Yt],_r)||_r===o&&!(Yt in At))&&fw(At,Yt,_r)}function J1(At,Yt,_r){var a0=At[Yt];(!(__.call(At,Yt)&&Aw(a0,_r))||_r===o&&!(Yt in At))&&fw(At,Yt,_r)}function Dw(At,Yt){for(var _r=At.length;_r--;)if(Aw(At[_r][0],Yt))return _r;return-1}function lS(At,Yt,_r,a0){return Q1(At,function(y0,A0,W0){Yt(a0,y0,_r(y0),W0)}),a0}function uS(At,Yt){return At&&U1(Yt,p1(Yt),At)}function pE(At,Yt){return At&&U1(Yt,G1(Yt),At)}function fw(At,Yt,_r){Yt=="__proto__"&&Ex?Ex(At,Yt,{configurable:!0,enumerable:!0,value:_r,writable:!0}):At[Yt]=_r}function C2(At,Yt){for(var _r=-1,a0=Yt.length,y0=Sy(a0),A0=At==null;++_r<a0;)y0[_r]=A0?o:oT(At,Yt[_r]);return y0}function Bw(At,Yt,_r){return At===At&&(_r!==o&&(At=At<=_r?At:_r),Yt!==o&&(At=At>=Yt?At:Yt)),At}function $1(At,Yt,_r,a0,y0,A0){var W0,Q0=Yt&b,ay=Yt&Et,Ny=Yt&It;if(_r&&(W0=y0?_r(At,a0,y0,A0):_r(At)),W0!==o)return W0;if(!U_(At))return At;var Fy=n_(At);if(Fy){if(W0=_A(At),!Q0)return d1(At,W0)}else{var qy=x1(At),pv=qy==B0||qy==Ay;if(kx(At))return SS(At,Q0);if(qy==Jy||qy==cy||pv&&!y0){if(W0=ay||pv?{}:bT(At),!Q0)return ay?SE(At,pE(W0,At)):jE(At,uS(W0,At))}else{if(!l_[qy])return y0?At:{};W0=bA(At,qy,Q0)}}A0||(A0=new K_);var Cv=A0.get(At);if(Cv)return Cv;A0.set(At,W0),KT(At)?At.forEach(function(Gv){W0.add($1(Gv,Yt,_r,Gv,At,A0))}):qT(At)&&At.forEach(function(Gv,h_){W0.set(h_,$1(Gv,Yt,_r,h_,At,A0))});var zv=Ny?ay?m_:W_:ay?G1:p1,c_=Fy?o:zv(At);return dy(c_||At,function(Gv,h_){c_&&(h_=Gv,Gv=At[h_]),J1(W0,h_,$1(Gv,Yt,_r,h_,At,A0))}),W0}function cS(At){var Yt=p1(At);return function(_r){return M2(_r,At,Yt)}}function M2(At,Yt,_r){var a0=_r.length;if(At==null)return!a0;for(At=Uv(At);a0--;){var y0=_r[a0],A0=Yt[y0],W0=At[y0];if(W0===o&&!(y0 in At)||!A0(W0))return!1}return!0}function dS(At,Yt,_r){if(typeof At!="function")throw new v1(h);return $S(function(){At.apply(o,_r)},Yt)}function Qw(At,Yt,_r,a0){var y0=-1,A0=_1,W0=!0,Q0=At.length,ay=[],Ny=Yt.length;if(!Q0)return ay;_r&&(Yt=M_(Yt,g1(_r))),a0?(A0=cx,W0=!1):Yt.length>=d&&(A0=n1,W0=!1,Yt=new Pw(Yt));e:for(;++y0<Q0;){var Fy=At[y0],qy=_r==null?Fy:_r(Fy);if(Fy=a0||Fy!==0?Fy:0,W0&&qy===qy){for(var pv=Ny;pv--;)if(Yt[pv]===qy)continue e;ay.push(Fy)}else A0(Yt,qy,a0)||ay.push(Fy)}return ay}var Q1=TS(C1),hE=TS(Mx,!0);function VE(At,Yt){var _r=!0;return Q1(At,function(a0,y0,A0){return _r=!!Yt(a0,y0,A0),_r}),_r}function i2(At,Yt,_r){for(var a0=-1,y0=At.length;++a0<y0;){var A0=At[a0],W0=Yt(A0);if(W0!=null&&(Q0===o?W0===W0&&!nw(W0):_r(W0,Q0)))var Q0=W0,ay=A0}return ay}function mE(At,Yt,_r,a0){var y0=At.length;for(_r=u_(_r),_r<0&&(_r=-_r>y0?0:y0+_r),a0=a0===o||a0>y0?y0:u_(a0),a0<0&&(a0+=y0),a0=_r>a0?0:YT(a0);_r<a0;)At[_r++]=Yt;return At}function fS(At,Yt){var _r=[];return Q1(At,function(a0,y0,A0){Yt(a0,y0,A0)&&_r.push(a0)}),_r}function e1(At,Yt,_r,a0,y0){var A0=-1,W0=At.length;for(_r||(_r=xA),y0||(y0=[]);++A0<W0;){var Q0=At[A0];Yt>0&&_r(Q0)?Yt>1?e1(Q0,Yt-1,_r,a0,y0):j1(y0,Q0):a0||(y0[y0.length]=Q0)}return y0}var Cx=z2(),a2=z2(!0);function C1(At,Yt){return At&&Cx(At,Yt,p1)}function Mx(At,Yt){return At&&a2(At,Yt,p1)}function ex(At,Yt){return P_(Yt,function(_r){return ax(At[_r])})}function ew(At,Yt){Yt=Uw(Yt,At);for(var _r=0,a0=Yt.length;At!=null&&_r<a0;)At=At[Vw(Yt[_r++])];return _r&&_r==a0?At:o}function I2(At,Yt,_r){var a0=Yt(At);return n_(At)?a0:j1(a0,_r(At))}function r1(At){return At==null?At===o?Ey:Iy:cw&&cw in Uv(At)?gA(At):MA(At)}function o2(At,Yt){return At>Yt}function gE(At,Yt){return At!=null&&__.call(At,Yt)}function pS(At,Yt){return At!=null&&Yt in Uv(At)}function HE(At,Yt,_r){return At>=a1(Yt,_r)&&At<Z_(Yt,_r)}function Ix(At,Yt,_r){for(var a0=_r?cx:_1,y0=At[0].length,A0=At.length,W0=A0,Q0=Sy(A0),ay=1/0,Ny=[];W0--;){var Fy=At[W0];W0&&Yt&&(Fy=M_(Fy,g1(Yt))),ay=a1(Fy.length,ay),Q0[W0]=!_r&&(Yt||y0>=120&&Fy.length>=120)?new Pw(W0&&Fy):o}Fy=At[0];var qy=-1,pv=Q0[0];e:for(;++qy<y0&&Ny.length<ay;){var Cv=Fy[qy],zv=Yt?Yt(Cv):Cv;if(Cv=_r||Cv!==0?Cv:0,!(pv?n1(pv,zv):a0(Ny,zv,_r))){for(W0=A0;--W0;){var c_=Q0[W0];if(!(c_?n1(c_,zv):a0(At[W0],zv,_r)))continue e}pv&&pv.push(zv),Ny.push(Cv)}}return Ny}function hS(At,Yt,_r,a0){return C1(At,function(y0,A0,W0){Yt(a0,_r(y0),A0,W0)}),a0}function R_(At,Yt,_r){Yt=Uw(Yt,At),At=ET(At,Yt);var a0=At==null?At:At[Vw(gw(Yt))];return a0==null?o:Lv(a0,At,_r)}function r_(At){return j_(At)&&r1(At)==cy}function V_(At){return j_(At)&&r1(At)==bv}function H_(At){return j_(At)&&r1(At)==Zy}function N_(At,Yt,_r,a0,y0){return At===Yt?!0:At==null||Yt==null||!j_(At)&&!j_(Yt)?At!==At&&Yt!==Yt:M1(At,Yt,_r,a0,N_,y0)}function M1(At,Yt,_r,a0,y0,A0){var W0=n_(At),Q0=n_(Yt),ay=W0?Ty:x1(At),Ny=Q0?Ty:x1(Yt);ay=ay==cy?Jy:ay,Ny=Ny==cy?Jy:Ny;var Fy=ay==Jy,qy=Ny==Jy,pv=ay==Ny;if(pv&&kx(At)){if(!kx(Yt))return!1;W0=!0,Fy=!1}if(pv&&!Fy)return A0||(A0=new K_),W0||H2(At)?Av(At,Yt,_r,a0,y0,A0):i_(At,Yt,ay,_r,a0,y0,A0);if(!(_r&zt)){var Cv=Fy&&__.call(At,"__wrapped__"),zv=qy&&__.call(Yt,"__wrapped__");if(Cv||zv){var c_=Cv?At.value():At,Gv=zv?Yt.value():Yt;return A0||(A0=new K_),y0(c_,Gv,_r,a0,A0)}}return pv?(A0||(A0=new K_),Jv(At,Yt,_r,a0,y0,A0)):!1}function Rx(At){return j_(At)&&x1(At)==hy}function F_(At,Yt,_r,a0){var y0=_r.length,A0=y0,W0=!a0;if(At==null)return!A0;for(At=Uv(At);y0--;){var Q0=_r[y0];if(W0&&Q0[2]?Q0[1]!==At[Q0[0]]:!(Q0[0]in At))return!1}for(;++y0<A0;){Q0=_r[y0];var ay=Q0[0],Ny=At[ay],Fy=Q0[1];if(W0&&Q0[2]){if(Ny===o&&!(ay in At))return!1}else{var qy=new K_;if(a0)var pv=a0(Ny,Fy,ay,At,Yt,qy);if(!(pv===o?N_(Fy,Ny,zt|er,a0,qy):pv))return!1}}return!0}function Ox(At){if(!U_(At)||EA(At))return!1;var Yt=ax(At)?x2:P0;return Yt.test(m2(At))}function Px(At){return j_(At)&&r1(At)==yv}function R2(At){return j_(At)&&x1(At)==I0}function mS(At){return j_(At)&&OE(At.length)&&!!Pv[r1(At)]}function Dx(At){return typeof At=="function"?At:At==null?V1:typeof At=="object"?n_(At)?O2(At[0],At[1]):l2(At):lA(At)}function s1(At){if(!AS(At))return jS(At);var Yt=[];for(var _r in Uv(At))__.call(At,_r)&&_r!="constructor"&&Yt.push(_r);return Yt}function gS(At){if(!U_(At))return CA(At);var Yt=AS(At),_r=[];for(var a0 in At)a0=="constructor"&&(Yt||!__.call(At,a0))||_r.push(a0);return _r}function s2(At,Yt){return At<Yt}function tx(At,Yt){var _r=-1,a0=z1(At)?Sy(At.length):[];return Q1(At,function(y0,A0,W0){a0[++_r]=Yt(y0,A0,W0)}),a0}function l2(At){var Yt=ZE(At);return Yt.length==1&&Yt[0][2]?xT(Yt[0][0],Yt[0][1]):function(_r){return _r===At||F_(_r,At,Yt)}}function O2(At,Yt){return XE(At)&&wT(Yt)?xT(Vw(At),Yt):function(_r){var a0=oT(_r,At);return a0===o&&a0===Yt?sT(_r,At):N_(Yt,a0,zt|er)}}function tw(At,Yt,_r,a0,y0){At!==Yt&&Cx(Yt,function(A0,W0){if(y0||(y0=new K_),U_(A0))P2(At,Yt,W0,_r,tw,a0,y0);else{var Q0=a0?a0(JE(At,W0),A0,W0+"",At,Yt,y0):o;Q0===o&&(Q0=A0),sS(At,W0,Q0)}},G1)}function P2(At,Yt,_r,a0,y0,A0,W0){var Q0=JE(At,_r),ay=JE(Yt,_r),Ny=W0.get(ay);if(Ny){sS(At,_r,Ny);return}var Fy=A0?A0(Q0,ay,_r+"",At,Yt,W0):o,qy=Fy===o;if(qy){var pv=n_(ay),Cv=!pv&&kx(ay),zv=!pv&&!Cv&&H2(ay);Fy=ay,pv||Cv||zv?n_(Q0)?Fy=Q0:X_(Q0)?Fy=d1(Q0):Cv?(qy=!1,Fy=SS(ay,!0)):zv?(qy=!1,Fy=xE(ay,!0)):Fy=[]:CS(ay)||g2(ay)?(Fy=Q0,g2(Q0)?Fy=JT(Q0):(!U_(Q0)||ax(Q0))&&(Fy=bT(ay))):qy=!1}qy&&(W0.set(ay,Fy),y0(Fy,ay,a0,A0,W0),W0.delete(ay)),sS(At,_r,Fy)}function Ew(At,Yt){var _r=At.length;if(_r)return Yt+=Yt<0?_r:0,ix(Yt,_r)?At[Yt]:o}function u2(At,Yt,_r){Yt.length?Yt=M_(Yt,function(A0){return n_(A0)?function(W0){return ew(W0,A0.length===1?A0[0]:A0)}:A0}):Yt=[V1];var a0=-1;Yt=M_(Yt,g1(Fv()));var y0=tx(At,function(A0,W0,Q0){var ay=M_(Yt,function(Ny){return Ny(A0)});return{criteria:ay,index:++a0,value:A0}});return _w(y0,function(A0,W0){return U2(A0,W0,_r)})}function c2(At,Yt){return D2(At,Yt,function(_r,a0){return sT(At,a0)})}function D2(At,Yt,_r){for(var a0=-1,y0=Yt.length,A0={};++a0<y0;){var W0=Yt[a0],Q0=ew(At,W0);_r(Q0,W0)&&nx(A0,Uw(W0,At),Q0)}return A0}function B2(At){return function(Yt){return ew(Yt,At)}}function Bx(At,Yt,_r,a0){var y0=a0?fx:q1,A0=-1,W0=Yt.length,Q0=At;for(At===Yt&&(Yt=d1(Yt)),_r&&(Q0=M_(At,g1(_r)));++A0<W0;)for(var ay=0,Ny=Yt[A0],Fy=_r?_r(Ny):Ny;(ay=y0(Q0,Fy,ay,a0))>-1;)Q0!==At&&Rw.call(Q0,ay,1),Rw.call(At,ay,1);return At}function l1(At,Yt){for(var _r=At?Yt.length:0,a0=_r-1;_r--;){var y0=Yt[_r];if(_r==a0||y0!==A0){var A0=y0;ix(y0)?Rw.call(At,y0,1):bS(At,y0)}}return At}function pw(At,Yt){return At+Jx(tS()*(Yt-At+1))}function N1(At,Yt,_r,a0){for(var y0=-1,A0=Z_(Yx((Yt-At)/(_r||1)),0),W0=Sy(A0);A0--;)W0[a0?A0:++y0]=At,At+=_r;return W0}function Lx(At,Yt){var _r="";if(!At||Yt<1||Yt>w0)return _r;do Yt%2&&(_r+=At),Yt=Jx(Yt/2),Yt&&(At+=At);while(Yt);return _r}function Dv(At,Yt){return QE(ST(At,Yt,V1),At+"")}function yE(At){return r2(W2(At))}function yS(At,Yt){var _r=W2(At);return AE(_r,Bw(Yt,0,_r.length))}function nx(At,Yt,_r,a0){if(!U_(At))return At;Yt=Uw(Yt,At);for(var y0=-1,A0=Yt.length,W0=A0-1,Q0=At;Q0!=null&&++y0<A0;){var ay=Vw(Yt[y0]),Ny=_r;if(ay==="__proto__"||ay==="constructor"||ay==="prototype")return At;if(y0!=W0){var Fy=Q0[ay];Ny=a0?a0(Fy,ay,Q0):o,Ny===o&&(Ny=U_(Fy)?Fy:ix(Yt[y0+1])?[]:{})}J1(Q0,ay,Ny),Q0=Q0[ay]}return At}var vE=E2?function(At,Yt){return E2.set(At,Yt),At}:V1,Lw=Ex?function(At,Yt){return Ex(At,"toString",{configurable:!0,enumerable:!1,value:uT(Yt),writable:!0})}:V1;function _E(At){return AE(W2(At))}function I1(At,Yt,_r){var a0=-1,y0=At.length;Yt<0&&(Yt=-Yt>y0?0:y0+Yt),_r=_r>y0?y0:_r,_r<0&&(_r+=y0),y0=Yt>_r?0:_r-Yt>>>0,Yt>>>=0;for(var A0=Sy(y0);++a0<y0;)A0[a0]=At[a0+Yt];return A0}function vS(At,Yt){var _r;return Q1(At,function(a0,y0,A0){return _r=Yt(a0,y0,A0),!_r}),!!_r}function hw(At,Yt,_r){var a0=0,y0=At==null?a0:At.length;if(typeof Yt=="number"&&Yt===Yt&&y0<=vy){for(;a0<y0;){var A0=a0+y0>>>1,W0=At[A0];W0!==null&&!nw(W0)&&(_r?W0<=Yt:W0<Yt)?a0=A0+1:y0=A0}return y0}return L2(At,Yt,V1,_r)}function L2(At,Yt,_r,a0){var y0=0,A0=At==null?0:At.length;if(A0===0)return 0;Yt=_r(Yt);for(var W0=Yt!==Yt,Q0=Yt===null,ay=nw(Yt),Ny=Yt===o;y0<A0;){var Fy=Jx((y0+A0)/2),qy=_r(At[Fy]),pv=qy!==o,Cv=qy===null,zv=qy===qy,c_=nw(qy);if(W0)var Gv=a0||zv;else Ny?Gv=zv&&(a0||pv):Q0?Gv=zv&&pv&&(a0||!Cv):ay?Gv=zv&&pv&&!Cv&&(a0||!c_):Cv||c_?Gv=!1:Gv=a0?qy<=Yt:qy<Yt;Gv?y0=Fy+1:A0=Fy}return a1(A0,q0)}function _S(At,Yt){for(var _r=-1,a0=At.length,y0=0,A0=[];++_r<a0;){var W0=At[_r],Q0=Yt?Yt(W0):W0;if(!_r||!Aw(Q0,ay)){var ay=Q0;A0[y0++]=W0===0?0:W0}}return A0}function k2(At){return typeof At=="number"?At:nw(At)?k0:+At}function u1(At){if(typeof At=="string")return At;if(n_(At))return M_(At,u1)+"";if(nw(At))return $x?$x.call(At):"";var Yt=At+"";return Yt=="0"&&1/At==-ty?"-0":Yt}function kw(At,Yt,_r){var a0=-1,y0=_1,A0=At.length,W0=!0,Q0=[],ay=Q0;if(_r)W0=!1,y0=cx;else if(A0>=d){var Ny=Yt?null:f1(At);if(Ny)return Wx(Ny);W0=!1,y0=n1,ay=new Pw}else ay=Yt?[]:Q0;e:for(;++a0<A0;){var Fy=At[a0],qy=Yt?Yt(Fy):Fy;if(Fy=_r||Fy!==0?Fy:0,W0&&qy===qy){for(var pv=ay.length;pv--;)if(ay[pv]===qy)continue e;Yt&&ay.push(qy),Q0.push(Fy)}else y0(ay,qy,_r)||(ay!==Q0&&ay.push(qy),Q0.push(Fy))}return Q0}function bS(At,Yt){return Yt=Uw(Yt,At),At=ET(At,Yt),At==null||delete At[Vw(gw(Yt))]}function wS(At,Yt,_r,a0){return nx(At,Yt,_r(ew(At,Yt)),a0)}function d2(At,Yt,_r,a0){for(var y0=At.length,A0=a0?y0:-1;(a0?A0--:++A0<y0)&&Yt(At[A0],A0,At););return _r?I1(At,a0?0:A0,a0?A0+1:y0):I1(At,a0?A0+1:0,a0?y0:A0)}function Nw(At,Yt){var _r=At;return _r instanceof Bv&&(_r=_r.value()),v2(Yt,function(a0,y0){return y0.func.apply(y0.thisArg,j1([a0],y0.args))},_r)}function xS(At,Yt,_r){var a0=At.length;if(a0<2)return a0?kw(At[0]):[];for(var y0=-1,A0=Sy(a0);++y0<a0;)for(var W0=At[y0],Q0=-1;++Q0<a0;)Q0!=y0&&(A0[y0]=Qw(A0[y0]||W0,At[Q0],Yt,_r));return kw(e1(A0,1),Yt,_r)}function Fw(At,Yt,_r){for(var a0=-1,y0=At.length,A0=Yt.length,W0={};++a0<y0;){var Q0=a0<A0?Yt[a0]:o;_r(W0,At[a0],Q0)}return W0}function N2(At){return X_(At)?At:[]}function c1(At){return typeof At=="function"?At:V1}function Uw(At,Yt){return n_(At)?At:XE(At,Yt)?[At]:CT(T_(At))}var bE=Dv;function zw(At,Yt,_r){var a0=At.length;return _r=_r===o?a0:_r,!Yt&&_r>=a0?At:I1(At,Yt,_r)}var wE=Xx||function(At){return O_.clearTimeout(At)};function SS(At,Yt){if(Yt)return At.slice();var _r=At.length,a0=Y2?Y2(_r):new At.constructor(_r);return At.copy(a0),a0}function F2(At){var Yt=new At.constructor(At.byteLength);return new Zx(Yt).set(new Zx(At)),Yt}function WE(At,Yt){var _r=Yt?F2(At.buffer):At.buffer;return new At.constructor(_r,At.byteOffset,At.byteLength)}function F1(At){var Yt=new At.constructor(At.source,j0.exec(At));return Yt.lastIndex=At.lastIndex,Yt}function ES(At){return xw?Uv(xw.call(At)):{}}function xE(At,Yt){var _r=Yt?F2(At.buffer):At.buffer;return new At.constructor(_r,At.byteOffset,At.length)}function Tw(At,Yt){if(At!==Yt){var _r=At!==o,a0=At===null,y0=At===At,A0=nw(At),W0=Yt!==o,Q0=Yt===null,ay=Yt===Yt,Ny=nw(Yt);if(!Q0&&!Ny&&!A0&&At>Yt||A0&&W0&&ay&&!Q0&&!Ny||a0&&W0&&ay||!_r&&ay||!y0)return 1;if(!a0&&!A0&&!Ny&&At<Yt||Ny&&_r&&y0&&!a0&&!A0||Q0&&_r&&y0||!W0&&y0||!ay)return-1}return 0}function U2(At,Yt,_r){for(var a0=-1,y0=At.criteria,A0=Yt.criteria,W0=y0.length,Q0=_r.length;++a0<W0;){var ay=Tw(y0[a0],A0[a0]);if(ay){if(a0>=Q0)return ay;var Ny=_r[a0];return ay*(Ny=="desc"?-1:1)}}return At.index-Yt.index}function Gw(At,Yt,_r,a0){for(var y0=-1,A0=At.length,W0=_r.length,Q0=-1,ay=Yt.length,Ny=Z_(A0-W0,0),Fy=Sy(ay+Ny),qy=!a0;++Q0<ay;)Fy[Q0]=Yt[Q0];for(;++y0<W0;)(qy||y0<A0)&&(Fy[_r[y0]]=At[y0]);for(;Ny--;)Fy[Q0++]=At[y0++];return Fy}function f2(At,Yt,_r,a0){for(var y0=-1,A0=At.length,W0=-1,Q0=_r.length,ay=-1,Ny=Yt.length,Fy=Z_(A0-Q0,0),qy=Sy(Fy+Ny),pv=!a0;++y0<Fy;)qy[y0]=At[y0];for(var Cv=y0;++ay<Ny;)qy[Cv+ay]=Yt[ay];for(;++W0<Q0;)(pv||y0<A0)&&(qy[Cv+_r[W0]]=At[y0++]);return qy}function d1(At,Yt){var _r=-1,a0=At.length;for(Yt||(Yt=Sy(a0));++_r<a0;)Yt[_r]=At[_r];return Yt}function U1(At,Yt,_r,a0){var y0=!_r;_r||(_r={});for(var A0=-1,W0=Yt.length;++A0<W0;){var Q0=Yt[A0],ay=a0?a0(_r[Q0],At[Q0],Q0,_r,At):o;ay===o&&(ay=At[Q0]),y0?fw(_r,Q0,ay):J1(_r,Q0,ay)}return _r}function jE(At,Yt){return U1(At,KE(At),Yt)}function SE(At,Yt){return U1(At,vT(At),Yt)}function p2(At,Yt){return function(_r,a0){var y0=n_(_r)?p_:lS,A0=Yt?Yt():{};return y0(_r,At,Fv(a0,2),A0)}}function rx(At){return Dv(function(Yt,_r){var a0=-1,y0=_r.length,A0=y0>1?_r[y0-1]:o,W0=y0>2?_r[2]:o;for(A0=At.length>3&&typeof A0=="function"?(y0--,A0):o,W0&&O1(_r[0],_r[1],W0)&&(A0=y0<3?o:A0,y0=1),Yt=Uv(Yt);++a0<y0;){var Q0=_r[a0];Q0&&At(Yt,Q0,a0,A0)}return Yt})}function TS(At,Yt){return function(_r,a0){if(_r==null)return _r;if(!z1(_r))return At(_r,a0);for(var y0=_r.length,A0=Yt?y0:-1,W0=Uv(_r);(Yt?A0--:++A0<y0)&&a0(W0[A0],A0,W0)!==!1;);return _r}}function z2(At){return function(Yt,_r,a0){for(var y0=-1,A0=Uv(Yt),W0=a0(Yt),Q0=W0.length;Q0--;){var ay=W0[At?Q0:++y0];if(_r(A0[ay],ay,A0)===!1)break}return Yt}}function qE(At,Yt,_r){var a0=Yt&Hn,y0=Ut(At);function A0(){var W0=this&&this!==O_&&this instanceof A0?y0:At;return W0.apply(a0?_r:this,arguments)}return A0}function EE(At){return function(Yt){Yt=T_(Yt);var _r=qw(Yt)?L_(Yt):o,a0=_r?_r[0]:Yt.charAt(0),y0=_r?zw(_r,1).join(""):Yt.slice(1);return a0[At]()+y0}}function Pt(At){return function(Yt){return v2(oA(aA(Yt).replace(A_,"")),At,"")}}function Ut(At){return function(){var Yt=arguments;switch(Yt.length){case 0:return new At;case 1:return new At(Yt[0]);case 2:return new At(Yt[0],Yt[1]);case 3:return new At(Yt[0],Yt[1],Yt[2]);case 4:return new At(Yt[0],Yt[1],Yt[2],Yt[3]);case 5:return new At(Yt[0],Yt[1],Yt[2],Yt[3],Yt[4]);case 6:return new At(Yt[0],Yt[1],Yt[2],Yt[3],Yt[4],Yt[5]);case 7:return new At(Yt[0],Yt[1],Yt[2],Yt[3],Yt[4],Yt[5],Yt[6])}var _r=Sw(At.prototype),a0=At.apply(_r,Yt);return U_(a0)?a0:_r}}function vr(At,Yt,_r){var a0=Ut(At);function y0(){for(var A0=arguments.length,W0=Sy(A0),Q0=A0,ay=V2(y0);Q0--;)W0[Q0]=arguments[Q0];var Ny=A0<3&&W0[0]!==ay&&W0[A0-1]!==ay?[]:X1(W0,ay);if(A0-=Ny.length,A0<_r)return E_(At,Yt,s0,y0.placeholder,o,W0,Ny,o,o,_r-A0);var Fy=this&&this!==O_&&this instanceof y0?a0:At;return Lv(Fy,this,W0)}return y0}function Kr(At){return function(Yt,_r,a0){var y0=Uv(Yt);if(!z1(Yt)){var A0=Fv(_r,3);Yt=p1(Yt),_r=function(Q0){return A0(y0[Q0],Q0,y0)}}var W0=At(Yt,_r,a0);return W0>-1?y0[A0?Yt[W0]:W0]:o}}function n0(At){return a_(function(Yt){var _r=Yt.length,a0=_r,y0=o1.prototype.thru;for(At&&Yt.reverse();a0--;){var A0=Yt[a0];if(typeof A0!="function")throw new v1(h);if(y0&&!W0&&G2(A0)=="wrapper")var W0=new o1([],!0)}for(a0=W0?a0:_r;++a0<_r;){A0=Yt[a0];var Q0=G2(A0),ay=Q0=="wrapper"?mw(A0):o;ay&&YE(ay[0])&&ay[1]==(o0|fr|e0|l0)&&!ay[4].length&&ay[9]==1?W0=W0[G2(ay[0])].apply(W0,ay[3]):W0=A0.length==1&&YE(A0)?W0[Q0]():W0.thru(A0)}return function(){var Ny=arguments,Fy=Ny[0];if(W0&&Ny.length==1&&n_(Fy))return W0.plant(Fy).value();for(var qy=0,pv=_r?Yt[qy].apply(this,Ny):Fy;++qy<_r;)pv=Yt[qy].call(this,pv);return pv}})}function s0(At,Yt,_r,a0,y0,A0,W0,Q0,ay,Ny){var Fy=Yt&o0,qy=Yt&Hn,pv=Yt&Qt,Cv=Yt&(fr|jr),zv=Yt&g0,c_=pv?o:Ut(At);function Gv(){for(var h_=arguments.length,g_=Sy(h_),rw=h_;rw--;)g_[rw]=arguments[rw];if(Cv)var P1=V2(Gv),iw=K1(g_,P1);if(a0&&(g_=Gw(g_,a0,y0,Cv)),A0&&(g_=f2(g_,A0,W0,Cv)),h_-=iw,Cv&&h_<Ny){var Y_=X1(g_,P1);return E_(At,Yt,s0,Gv.placeholder,_r,g_,Y_,Q0,ay,Ny-h_)}var $w=qy?_r:this,sx=pv?$w[At]:At;return h_=g_.length,Q0?g_=IA(g_,Q0):zv&&h_>1&&g_.reverse(),Fy&&ay<h_&&(g_.length=ay),this&&this!==O_&&this instanceof Gv&&(sx=c_||Ut(sx)),sx.apply($w,g_)}return Gv}function z0(At,Yt){return function(_r,a0){return hS(_r,At,Yt(a0),{})}}function ny(At,Yt){return function(_r,a0){var y0;if(_r===o&&a0===o)return Yt;if(_r!==o&&(y0=_r),a0!==o){if(y0===o)return a0;typeof _r=="string"||typeof a0=="string"?(_r=u1(_r),a0=u1(a0)):(_r=k2(_r),a0=k2(a0)),y0=At(_r,a0)}return y0}}function My(At){return a_(function(Yt){return Yt=M_(Yt,g1(Fv())),Dv(function(_r){var a0=this;return At(Yt,function(y0){return Lv(y0,a0,_r)})})})}function tv(At,Yt){Yt=Yt===o?" ":u1(Yt);var _r=Yt.length;if(_r<2)return _r?Lx(Yt,At):Yt;var a0=Lx(Yt,Yx(At/ow(Yt)));return qw(Yt)?zw(L_(a0),0,At).join(""):a0.slice(0,At)}function xv(At,Yt,_r,a0){var y0=Yt&Hn,A0=Ut(At);function W0(){for(var Q0=-1,ay=arguments.length,Ny=-1,Fy=a0.length,qy=Sy(Fy+ay),pv=this&&this!==O_&&this instanceof W0?A0:At;++Ny<Fy;)qy[Ny]=a0[Ny];for(;ay--;)qy[Ny++]=arguments[++Q0];return Lv(pv,y0?_r:this,qy)}return W0}function Yv(At){return function(Yt,_r,a0){return a0&&typeof a0!="number"&&O1(Yt,_r,a0)&&(_r=a0=o),Yt=ox(Yt),_r===o?(_r=Yt,Yt=0):_r=ox(_r),a0=a0===o?Yt<_r?1:-1:ox(a0),N1(Yt,_r,a0,At)}}function Iv(At){return function(Yt,_r){return typeof Yt=="string"&&typeof _r=="string"||(Yt=yw(Yt),_r=yw(_r)),At(Yt,_r)}}function E_(At,Yt,_r,a0,y0,A0,W0,Q0,ay,Ny){var Fy=Yt&fr,qy=Fy?W0:o,pv=Fy?o:W0,Cv=Fy?A0:o,zv=Fy?o:A0;Yt|=Fy?e0:t0,Yt&=~(Fy?t0:e0),Yt&cr||(Yt&=~(Hn|Qt));var c_=[At,Yt,y0,Cv,qy,zv,pv,Q0,ay,Ny],Gv=_r.apply(o,c_);return YE(At)&&TT(Gv,c_),Gv.placeholder=a0,AT(Gv,At,Yt)}function Tv(At){var Yt=D_[At];return function(_r,a0){if(_r=yw(_r),a0=a0==null?0:a1(u_(a0),292),a0&&eS(_r)){var y0=(T_(_r)+"e").split("e"),A0=Yt(y0[0]+"e"+(+y0[1]+a0));return y0=(T_(A0)+"e").split("e"),+(y0[0]+"e"+(+y0[1]-a0))}return Yt(_r)}}var f1=Ax&&1/Wx(new Ax([,-0]))[1]==ty?function(At){return new Ax(At)}:fT;function R1(At){return function(Yt){var _r=x1(Yt);return _r==hy?Hx(Yt):_r==I0?US(Yt):kS(Yt,At(Yt))}}function fy(At,Yt,_r,a0,y0,A0,W0,Q0){var ay=Yt&Qt;if(!ay&&typeof At!="function")throw new v1(h);var Ny=a0?a0.length:0;if(Ny||(Yt&=~(e0|t0),a0=y0=o),W0=W0===o?W0:Z_(u_(W0),0),Q0=Q0===o?Q0:u_(Q0),Ny-=y0?y0.length:0,Yt&t0){var Fy=a0,qy=y0;a0=y0=o}var pv=ay?o:mw(At),Cv=[At,Yt,_r,a0,y0,Fy,qy,A0,W0,Q0];if(pv&&$A(Cv,pv),At=Cv[0],Yt=Cv[1],_r=Cv[2],a0=Cv[3],y0=Cv[4],Q0=Cv[9]=Cv[9]===o?ay?0:At.length:Z_(Cv[9]-Ny,0),!Q0&&Yt&(fr|jr)&&(Yt&=~(fr|jr)),!Yt||Yt==Hn)var zv=qE(At,Yt,_r);else Yt==fr||Yt==jr?zv=vr(At,Yt,Q0):(Yt==e0||Yt==(Hn|e0))&&!y0.length?zv=xv(At,Yt,_r,a0):zv=s0.apply(o,Cv);var c_=pv?vE:TT;return AT(c_(zv,Cv),At,Yt)}function iy(At,Yt,_r,a0){return At===o||Aw(At,xx[_r])&&!__.call(a0,_r)?Yt:At}function $y(At,Yt,_r,a0,y0,A0){return U_(At)&&U_(Yt)&&(A0.set(Yt,At),tw(At,Yt,o,$y,A0),A0.delete(Yt)),At}function hv(At){return CS(At)?o:At}function Av(At,Yt,_r,a0,y0,A0){var W0=_r&zt,Q0=At.length,ay=Yt.length;if(Q0!=ay&&!(W0&&ay>Q0))return!1;var Ny=A0.get(At),Fy=A0.get(Yt);if(Ny&&Fy)return Ny==Yt&&Fy==At;var qy=-1,pv=!0,Cv=_r&er?new Pw:o;for(A0.set(At,Yt),A0.set(Yt,At);++qy<Q0;){var zv=At[qy],c_=Yt[qy];if(a0)var Gv=W0?a0(c_,zv,qy,Yt,At,A0):a0(zv,c_,qy,At,Yt,A0);if(Gv!==o){if(Gv)continue;pv=!1;break}if(Cv){if(!Ux(Yt,function(h_,g_){if(!n1(Cv,g_)&&(zv===h_||y0(zv,h_,_r,a0,A0)))return Cv.push(g_)})){pv=!1;break}}else if(!(zv===c_||y0(zv,c_,_r,a0,A0))){pv=!1;break}}return A0.delete(At),A0.delete(Yt),pv}function i_(At,Yt,_r,a0,y0,A0,W0){switch(_r){case av:if(At.byteLength!=Yt.byteLength||At.byteOffset!=Yt.byteOffset)return!1;At=At.buffer,Yt=Yt.buffer;case bv:return!(At.byteLength!=Yt.byteLength||!A0(new Zx(At),new Zx(Yt)));case Qy:case Zy:case Ly:return Aw(+At,+Yt);case zy:return At.name==Yt.name&&At.message==Yt.message;case yv:case b0:return At==Yt+"";case hy:var Q0=Hx;case I0:var ay=a0&zt;if(Q0||(Q0=Wx),At.size!=Yt.size&&!ay)return!1;var Ny=W0.get(At);if(Ny)return Ny==Yt;a0|=er,W0.set(At,Yt);var Fy=Av(Q0(At),Q0(Yt),a0,y0,A0,W0);return W0.delete(At),Fy;case uy:if(xw)return xw.call(At)==xw.call(Yt)}return!1}function Jv(At,Yt,_r,a0,y0,A0){var W0=_r&zt,Q0=W_(At),ay=Q0.length,Ny=W_(Yt),Fy=Ny.length;if(ay!=Fy&&!W0)return!1;for(var qy=ay;qy--;){var pv=Q0[qy];if(!(W0?pv in Yt:__.call(Yt,pv)))return!1}var Cv=A0.get(At),zv=A0.get(Yt);if(Cv&&zv)return Cv==Yt&&zv==At;var c_=!0;A0.set(At,Yt),A0.set(Yt,At);for(var Gv=W0;++qy<ay;){pv=Q0[qy];var h_=At[pv],g_=Yt[pv];if(a0)var rw=W0?a0(g_,h_,pv,Yt,At,A0):a0(h_,g_,pv,At,Yt,A0);if(!(rw===o?h_===g_||y0(h_,g_,_r,a0,A0):rw)){c_=!1;break}Gv||(Gv=pv=="constructor")}if(c_&&!Gv){var P1=At.constructor,iw=Yt.constructor;P1!=iw&&"constructor"in At&&"constructor"in Yt&&!(typeof P1=="function"&&P1 instanceof P1&&typeof iw=="function"&&iw instanceof iw)&&(c_=!1)}return A0.delete(At),A0.delete(Yt),c_}function a_(At){return QE(ST(At,o,OT),At+"")}function W_(At){return I2(At,p1,KE)}function m_(At){return I2(At,G1,vT)}var mw=E2?function(At){return E2.get(At)}:fT;function G2(At){for(var Yt=At.name+"",_r=Yw[Yt],a0=__.call(Yw,Yt)?_r.length:0;a0--;){var y0=_r[a0],A0=y0.func;if(A0==null||A0==At)return y0.name}return Yt}function V2(At){var Yt=__.call(S0,"placeholder")?S0:At;return Yt.placeholder}function Fv(){var At=S0.iteratee||cT;return At=At===cT?Dx:At,arguments.length?At(arguments[0],arguments[1]):At}function TE(At,Yt){var _r=At.__data__;return SA(Yt)?_r[typeof Yt=="string"?"string":"hash"]:_r.map}function ZE(At){for(var Yt=p1(At),_r=Yt.length;_r--;){var a0=Yt[_r],y0=At[a0];Yt[_r]=[a0,y0,wT(y0)]}return Yt}function h2(At,Yt){var _r=Z2(At,Yt);return Ox(_r)?_r:o}function gA(At){var Yt=__.call(At,cw),_r=At[cw];try{At[cw]=o;var a0=!0}catch{}var y0=T1.call(At);return a0&&(Yt?At[cw]=_r:delete At[cw]),y0}var KE=Qx?function(At){return At==null?[]:(At=Uv(At),P_(Qx(At),function(Yt){return S2.call(At,Yt)}))}:pT,vT=Qx?function(At){for(var Yt=[];At;)j1(Yt,KE(At)),At=Kx(At);return Yt}:pT,x1=r1;(Tx&&x1(new Tx(new ArrayBuffer(1)))!=av||e2&&x1(new e2)!=hy||nS&&x1(nS.resolve())!=Gy||Ax&&x1(new Ax)!=I0||Kw&&x1(new Kw)!=Dy)&&(x1=function(At){var Yt=r1(At),_r=Yt==Jy?At.constructor:o,a0=_r?m2(_r):"";if(a0)switch(a0){case XS:return av;case YS:return hy;case JS:return Gy;case QS:return I0;case dw:return Dy}return Yt});function yA(At,Yt,_r){for(var a0=-1,y0=_r.length;++a0<y0;){var A0=_r[a0],W0=A0.size;switch(A0.type){case"drop":At+=W0;break;case"dropRight":Yt-=W0;break;case"take":Yt=a1(Yt,At+W0);break;case"takeRight":At=Z_(At,Yt-W0);break}}return{start:At,end:Yt}}function vA(At){var Yt=At.match(v_);return Yt?Yt[1].split(Rv):[]}function _T(At,Yt,_r){Yt=Uw(Yt,At);for(var a0=-1,y0=Yt.length,A0=!1;++a0<y0;){var W0=Vw(Yt[a0]);if(!(A0=At!=null&&_r(At,W0)))break;At=At[W0]}return A0||++a0!=y0?A0:(y0=At==null?0:At.length,!!y0&&OE(y0)&&ix(W0,y0)&&(n_(At)||g2(At)))}function _A(At){var Yt=At.length,_r=new At.constructor(Yt);return Yt&&typeof At[0]=="string"&&__.call(At,"index")&&(_r.index=At.index,_r.input=At.input),_r}function bT(At){return typeof At.constructor=="function"&&!AS(At)?Sw(Kx(At)):{}}function bA(At,Yt,_r){var a0=At.constructor;switch(Yt){case bv:return F2(At);case Qy:case Zy:return new a0(+At);case av:return WE(At,_r);case Wy:case my:case uv:case Hy:case wv:case mv:case cv:case O0:case oy:return xE(At,_r);case hy:return new a0;case Ly:case b0:return new a0(At);case yv:return F1(At);case I0:return new a0;case uy:return ES(At)}}function wA(At,Yt){var _r=Yt.length;if(!_r)return At;var a0=_r-1;return Yt[a0]=(_r>1?"& ":"")+Yt[a0],Yt=Yt.join(_r>2?", ":" "),At.replace(Xv,`{
/* [wrapped with `+Yt+`] */
`)}function xA(At){return n_(At)||g2(At)||!!(Q2&&At&&At[Q2])}function ix(At,Yt){var _r=typeof At;return Yt=Yt??w0,!!Yt&&(_r=="number"||_r!="symbol"&&r0.test(At))&&At>-1&&At%1==0&&At<Yt}function O1(At,Yt,_r){if(!U_(_r))return!1;var a0=typeof Yt;return(a0=="number"?z1(_r)&&ix(Yt,_r.length):a0=="string"&&Yt in _r)?Aw(_r[Yt],At):!1}function XE(At,Yt){if(n_(At))return!1;var _r=typeof At;return _r=="number"||_r=="symbol"||_r=="boolean"||At==null||nw(At)?!0:Vv.test(At)||!kv.test(At)||Yt!=null&&At in Uv(Yt)}function SA(At){var Yt=typeof At;return Yt=="string"||Yt=="number"||Yt=="symbol"||Yt=="boolean"?At!=="__proto__":At===null}function YE(At){var Yt=G2(At),_r=S0[Yt];if(typeof _r!="function"||!(Yt in Bv.prototype))return!1;if(At===_r)return!0;var a0=mw(_r);return!!a0&&At===a0[0]}function EA(At){return!!uw&&uw in At}var TA=q_?ax:hT;function AS(At){var Yt=At&&At.constructor,_r=typeof Yt=="function"&&Yt.prototype||xx;return At===_r}function wT(At){return At===At&&!U_(At)}function xT(At,Yt){return function(_r){return _r==null?!1:_r[At]===Yt&&(Yt!==o||At in Uv(_r))}}function AA(At){var Yt=IE(At,function(a0){return _r.size===g&&_r.clear(),a0}),_r=Yt.cache;return Yt}function $A(At,Yt){var _r=At[1],a0=Yt[1],y0=_r|a0,A0=y0<(Hn|Qt|o0),W0=a0==o0&&_r==fr||a0==o0&&_r==l0&&At[7].length<=Yt[8]||a0==(o0|l0)&&Yt[7].length<=Yt[8]&&_r==fr;if(!(A0||W0))return At;a0&Hn&&(At[2]=Yt[2],y0|=_r&Hn?0:cr);var Q0=Yt[3];if(Q0){var ay=At[3];At[3]=ay?Gw(ay,Q0,Yt[4]):Q0,At[4]=ay?X1(At[3],j):Yt[4]}return Q0=Yt[5],Q0&&(ay=At[5],At[5]=ay?f2(ay,Q0,Yt[6]):Q0,At[6]=ay?X1(At[5],j):Yt[6]),Q0=Yt[7],Q0&&(At[7]=Q0),a0&o0&&(At[8]=At[8]==null?Yt[8]:a1(At[8],Yt[8])),At[9]==null&&(At[9]=Yt[9]),At[0]=Yt[0],At[1]=y0,At}function CA(At){var Yt=[];if(At!=null)for(var _r in Uv(At))Yt.push(_r);return Yt}function MA(At){return T1.call(At)}function ST(At,Yt,_r){return Yt=Z_(Yt===o?At.length-1:Yt,0),function(){for(var a0=arguments,y0=-1,A0=Z_(a0.length-Yt,0),W0=Sy(A0);++y0<A0;)W0[y0]=a0[Yt+y0];y0=-1;for(var Q0=Sy(Yt+1);++y0<Yt;)Q0[y0]=a0[y0];return Q0[Yt]=_r(W0),Lv(At,this,Q0)}}function ET(At,Yt){return Yt.length<2?At:ew(At,I1(Yt,0,-1))}function IA(At,Yt){for(var _r=At.length,a0=a1(Yt.length,_r),y0=d1(At);a0--;){var A0=Yt[a0];At[a0]=ix(A0,_r)?y0[A0]:o}return At}function JE(At,Yt){if(!(Yt==="constructor"&&typeof At[Yt]=="function")&&Yt!="__proto__")return At[Yt]}var TT=$T(vE),$S=HS||function(At,Yt){return O_.setTimeout(At,Yt)},QE=$T(Lw);function AT(At,Yt,_r){var a0=Yt+"";return QE(At,wA(a0,RA(vA(a0),_r)))}function $T(At){var Yt=0,_r=0;return function(){var a0=qS(),y0=Z0-(a0-_r);if(_r=a0,y0>0){if(++Yt>=C0)return arguments[0]}else Yt=0;return At.apply(o,arguments)}}function AE(At,Yt){var _r=-1,a0=At.length,y0=a0-1;for(Yt=Yt===o?a0:Yt;++_r<Yt;){var A0=pw(_r,y0),W0=At[A0];At[A0]=At[_r],At[_r]=W0}return At.length=Yt,At}var CT=AA(function(At){var Yt=[];return At.charCodeAt(0)===46&&Yt.push(""),At.replace($v,function(_r,a0,y0,A0){Yt.push(y0?A0.replace(m0,"$1"):a0||_r)}),Yt});function Vw(At){if(typeof At=="string"||nw(At))return At;var Yt=At+"";return Yt=="0"&&1/At==-ty?"-0":Yt}function m2(At){if(At!=null){try{return Sx.call(At)}catch{}try{return At+""}catch{}}return""}function RA(At,Yt){return dy(J0,function(_r){var a0="_."+_r[0];Yt&_r[1]&&!_1(At,a0)&&At.push(a0)}),At.sort()}function MT(At){if(At instanceof Bv)return At.clone();var Yt=new o1(At.__wrapped__,At.__chain__);return Yt.__actions__=d1(At.__actions__),Yt.__index__=At.__index__,Yt.__values__=At.__values__,Yt}function OA(At,Yt,_r){(_r?O1(At,Yt,_r):Yt===o)?Yt=1:Yt=Z_(u_(Yt),0);var a0=At==null?0:At.length;if(!a0||Yt<1)return[];for(var y0=0,A0=0,W0=Sy(Yx(a0/Yt));y0<a0;)W0[A0++]=I1(At,y0,y0+=Yt);return W0}function PA(At){for(var Yt=-1,_r=At==null?0:At.length,a0=0,y0=[];++Yt<_r;){var A0=At[Yt];A0&&(y0[a0++]=A0)}return y0}function DA(){var At=arguments.length;if(!At)return[];for(var Yt=Sy(At-1),_r=arguments[0],a0=At;a0--;)Yt[a0-1]=arguments[a0];return j1(n_(_r)?d1(_r):[_r],e1(Yt,1))}var BA=Dv(function(At,Yt){return X_(At)?Qw(At,e1(Yt,1,X_,!0)):[]}),LA=Dv(function(At,Yt){var _r=gw(Yt);return X_(_r)&&(_r=o),X_(At)?Qw(At,e1(Yt,1,X_,!0),Fv(_r,2)):[]}),kA=Dv(function(At,Yt){var _r=gw(Yt);return X_(_r)&&(_r=o),X_(At)?Qw(At,e1(Yt,1,X_,!0),o,_r):[]});function NA(At,Yt,_r){var a0=At==null?0:At.length;return a0?(Yt=_r||Yt===o?1:u_(Yt),I1(At,Yt<0?0:Yt,a0)):[]}function FA(At,Yt,_r){var a0=At==null?0:At.length;return a0?(Yt=_r||Yt===o?1:u_(Yt),Yt=a0-Yt,I1(At,0,Yt<0?0:Yt)):[]}function UA(At,Yt){return At&&At.length?d2(At,Fv(Yt,3),!0,!0):[]}function zA(At,Yt){return At&&At.length?d2(At,Fv(Yt,3),!0):[]}function GA(At,Yt,_r,a0){var y0=At==null?0:At.length;return y0?(_r&&typeof _r!="number"&&O1(At,Yt,_r)&&(_r=0,a0=y0),mE(At,Yt,_r,a0)):[]}function IT(At,Yt,_r){var a0=At==null?0:At.length;if(!a0)return-1;var y0=_r==null?0:u_(_r);return y0<0&&(y0=Z_(a0+y0,0)),dx(At,Fv(Yt,3),y0)}function RT(At,Yt,_r){var a0=At==null?0:At.length;if(!a0)return-1;var y0=a0-1;return _r!==o&&(y0=u_(_r),y0=_r<0?Z_(a0+y0,0):a1(y0,a0-1)),dx(At,Fv(Yt,3),y0,!0)}function OT(At){var Yt=At==null?0:At.length;return Yt?e1(At,1):[]}function VA(At){var Yt=At==null?0:At.length;return Yt?e1(At,ty):[]}function HA(At,Yt){var _r=At==null?0:At.length;return _r?(Yt=Yt===o?1:u_(Yt),e1(At,Yt)):[]}function WA(At){for(var Yt=-1,_r=At==null?0:At.length,a0={};++Yt<_r;){var y0=At[Yt];a0[y0[0]]=y0[1]}return a0}function PT(At){return At&&At.length?At[0]:o}function jA(At,Yt,_r){var a0=At==null?0:At.length;if(!a0)return-1;var y0=_r==null?0:u_(_r);return y0<0&&(y0=Z_(a0+y0,0)),q1(At,Yt,y0)}function qA(At){var Yt=At==null?0:At.length;return Yt?I1(At,0,-1):[]}var ZA=Dv(function(At){var Yt=M_(At,N2);return Yt.length&&Yt[0]===At[0]?Ix(Yt):[]}),KA=Dv(function(At){var Yt=gw(At),_r=M_(At,N2);return Yt===gw(_r)?Yt=o:_r.pop(),_r.length&&_r[0]===At[0]?Ix(_r,Fv(Yt,2)):[]}),XA=Dv(function(At){var Yt=gw(At),_r=M_(At,N2);return Yt=typeof Yt=="function"?Yt:o,Yt&&_r.pop(),_r.length&&_r[0]===At[0]?Ix(_r,o,Yt):[]});function YA(At,Yt){return At==null?"":kE.call(At,Yt)}function gw(At){var Yt=At==null?0:At.length;return Yt?At[Yt-1]:o}function JA(At,Yt,_r){var a0=At==null?0:At.length;if(!a0)return-1;var y0=a0;return _r!==o&&(y0=u_(_r),y0=y0<0?Z_(a0+y0,0):a1(y0,a0-1)),Yt===Yt?zS(At,Yt,y0):dx(At,zx,y0,!0)}function QA(At,Yt){return At&&At.length?Ew(At,u_(Yt)):o}var e$=Dv(DT);function DT(At,Yt){return At&&At.length&&Yt&&Yt.length?Bx(At,Yt):At}function t$(At,Yt,_r){return At&&At.length&&Yt&&Yt.length?Bx(At,Yt,Fv(_r,2)):At}function n$(At,Yt,_r){return At&&At.length&&Yt&&Yt.length?Bx(At,Yt,o,_r):At}var r$=a_(function(At,Yt){var _r=At==null?0:At.length,a0=C2(At,Yt);return l1(At,M_(Yt,function(y0){return ix(y0,_r)?+y0:y0}).sort(Tw)),a0});function i$(At,Yt){var _r=[];if(!(At&&At.length))return _r;var a0=-1,y0=[],A0=At.length;for(Yt=Fv(Yt,3);++a0<A0;){var W0=At[a0];Yt(W0,a0,At)&&(_r.push(W0),y0.push(a0))}return l1(At,y0),_r}function eT(At){return At==null?At:KS.call(At)}function a$(At,Yt,_r){var a0=At==null?0:At.length;return a0?(_r&&typeof _r!="number"&&O1(At,Yt,_r)?(Yt=0,_r=a0):(Yt=Yt==null?0:u_(Yt),_r=_r===o?a0:u_(_r)),I1(At,Yt,_r)):[]}function o$(At,Yt){return hw(At,Yt)}function s$(At,Yt,_r){return L2(At,Yt,Fv(_r,2))}function l$(At,Yt){var _r=At==null?0:At.length;if(_r){var a0=hw(At,Yt);if(a0<_r&&Aw(At[a0],Yt))return a0}return-1}function u$(At,Yt){return hw(At,Yt,!0)}function c$(At,Yt,_r){return L2(At,Yt,Fv(_r,2),!0)}function d$(At,Yt){var _r=At==null?0:At.length;if(_r){var a0=hw(At,Yt,!0)-1;if(Aw(At[a0],Yt))return a0}return-1}function f$(At){return At&&At.length?_S(At):[]}function p$(At,Yt){return At&&At.length?_S(At,Fv(Yt,2)):[]}function h$(At){var Yt=At==null?0:At.length;return Yt?I1(At,1,Yt):[]}function m$(At,Yt,_r){return At&&At.length?(Yt=_r||Yt===o?1:u_(Yt),I1(At,0,Yt<0?0:Yt)):[]}function g$(At,Yt,_r){var a0=At==null?0:At.length;return a0?(Yt=_r||Yt===o?1:u_(Yt),Yt=a0-Yt,I1(At,Yt<0?0:Yt,a0)):[]}function y$(At,Yt){return At&&At.length?d2(At,Fv(Yt,3),!1,!0):[]}function v$(At,Yt){return At&&At.length?d2(At,Fv(Yt,3)):[]}var _$=Dv(function(At){return kw(e1(At,1,X_,!0))}),b$=Dv(function(At){var Yt=gw(At);return X_(Yt)&&(Yt=o),kw(e1(At,1,X_,!0),Fv(Yt,2))}),w$=Dv(function(At){var Yt=gw(At);return Yt=typeof Yt=="function"?Yt:o,kw(e1(At,1,X_,!0),o,Yt)});function x$(At){return At&&At.length?kw(At):[]}function S$(At,Yt){return At&&At.length?kw(At,Fv(Yt,2)):[]}function E$(At,Yt){return Yt=typeof Yt=="function"?Yt:o,At&&At.length?kw(At,o,Yt):[]}function tT(At){if(!(At&&At.length))return[];var Yt=0;return At=P_(At,function(_r){if(X_(_r))return Yt=Z_(_r.length,Yt),!0}),bw(Yt,function(_r){return M_(At,b1(_r))})}function BT(At,Yt){if(!(At&&At.length))return[];var _r=tT(At);return Yt==null?_r:M_(_r,function(a0){return Lv(Yt,o,a0)})}var T$=Dv(function(At,Yt){return X_(At)?Qw(At,Yt):[]}),A$=Dv(function(At){return xS(P_(At,X_))}),$$=Dv(function(At){var Yt=gw(At);return X_(Yt)&&(Yt=o),xS(P_(At,X_),Fv(Yt,2))}),C$=Dv(function(At){var Yt=gw(At);return Yt=typeof Yt=="function"?Yt:o,xS(P_(At,X_),o,Yt)}),M$=Dv(tT);function I$(At,Yt){return Fw(At||[],Yt||[],J1)}function R$(At,Yt){return Fw(At||[],Yt||[],nx)}var O$=Dv(function(At){var Yt=At.length,_r=Yt>1?At[Yt-1]:o;return _r=typeof _r=="function"?(At.pop(),_r):o,BT(At,_r)});function LT(At){var Yt=S0(At);return Yt.__chain__=!0,Yt}function P$(At,Yt){return Yt(At),At}function $E(At,Yt){return Yt(At)}var D$=a_(function(At){var Yt=At.length,_r=Yt?At[0]:0,a0=this.__wrapped__,y0=function(A0){return C2(A0,At)};return Yt>1||this.__actions__.length||!(a0 instanceof Bv)||!ix(_r)?this.thru(y0):(a0=a0.slice(_r,+_r+(Yt?1:0)),a0.__actions__.push({func:$E,args:[y0],thisArg:o}),new o1(a0,this.__chain__).thru(function(A0){return Yt&&!A0.length&&A0.push(o),A0}))});function B$(){return LT(this)}function L$(){return new o1(this.value(),this.__chain__)}function k$(){this.__values__===o&&(this.__values__=XT(this.value()));var At=this.__index__>=this.__values__.length,Yt=At?o:this.__values__[this.__index__++];return{done:At,value:Yt}}function N$(){return this}function F$(At){for(var Yt,_r=this;_r instanceof n2;){var a0=MT(_r);a0.__index__=0,a0.__values__=o,Yt?y0.__wrapped__=a0:Yt=a0;var y0=a0;_r=_r.__wrapped__}return y0.__wrapped__=At,Yt}function U$(){var At=this.__wrapped__;if(At instanceof Bv){var Yt=At;return this.__actions__.length&&(Yt=new Bv(this)),Yt=Yt.reverse(),Yt.__actions__.push({func:$E,args:[eT],thisArg:o}),new o1(Yt,this.__chain__)}return this.thru(eT)}function z$(){return Nw(this.__wrapped__,this.__actions__)}var G$=p2(function(At,Yt,_r){__.call(At,_r)?++At[_r]:fw(At,_r,1)});function V$(At,Yt,_r){var a0=n_(At)?d_:VE;return _r&&O1(At,Yt,_r)&&(Yt=o),a0(At,Fv(Yt,3))}function H$(At,Yt){var _r=n_(At)?P_:fS;return _r(At,Fv(Yt,3))}var W$=Kr(IT),j$=Kr(RT);function q$(At,Yt){return e1(CE(At,Yt),1)}function Z$(At,Yt){return e1(CE(At,Yt),ty)}function K$(At,Yt,_r){return _r=_r===o?1:u_(_r),e1(CE(At,Yt),_r)}function kT(At,Yt){var _r=n_(At)?dy:Q1;return _r(At,Fv(Yt,3))}function NT(At,Yt){var _r=n_(At)?qv:hE;return _r(At,Fv(Yt,3))}var X$=p2(function(At,Yt,_r){__.call(At,_r)?At[_r].push(Yt):fw(At,_r,[Yt])});function Y$(At,Yt,_r,a0){At=z1(At)?At:W2(At),_r=_r&&!a0?u_(_r):0;var y0=At.length;return _r<0&&(_r=Z_(y0+_r,0)),PE(At)?_r<=y0&&At.indexOf(Yt,_r)>-1:!!y0&&q1(At,Yt,_r)>-1}var J$=Dv(function(At,Yt,_r){var a0=-1,y0=typeof Yt=="function",A0=z1(At)?Sy(At.length):[];return Q1(At,function(W0){A0[++a0]=y0?Lv(Yt,W0,_r):R_(W0,Yt,_r)}),A0}),Q$=p2(function(At,Yt,_r){fw(At,_r,Yt)});function CE(At,Yt){var _r=n_(At)?M_:tx;return _r(At,Fv(Yt,3))}function eC(At,Yt,_r,a0){return At==null?[]:(n_(Yt)||(Yt=Yt==null?[]:[Yt]),_r=a0?o:_r,n_(_r)||(_r=_r==null?[]:[_r]),u2(At,Yt,_r))}var tC=p2(function(At,Yt,_r){At[_r?0:1].push(Yt)},function(){return[[],[]]});function nC(At,Yt,_r){var a0=n_(At)?v2:Mw,y0=arguments.length<3;return a0(At,Fv(Yt,4),_r,y0,Q1)}function rC(At,Yt,_r){var a0=n_(At)?DS:Mw,y0=arguments.length<3;return a0(At,Fv(Yt,4),_r,y0,hE)}function iC(At,Yt){var _r=n_(At)?P_:fS;return _r(At,RE(Fv(Yt,3)))}function aC(At){var Yt=n_(At)?r2:yE;return Yt(At)}function oC(At,Yt,_r){(_r?O1(At,Yt,_r):Yt===o)?Yt=1:Yt=u_(Yt);var a0=n_(At)?oS:yS;return a0(At,Yt)}function sC(At){var Yt=n_(At)?fE:_E;return Yt(At)}function lC(At){if(At==null)return 0;if(z1(At))return PE(At)?ow(At):At.length;var Yt=x1(At);return Yt==hy||Yt==I0?At.size:s1(At).length}function uC(At,Yt,_r){var a0=n_(At)?Ux:vS;return _r&&O1(At,Yt,_r)&&(Yt=o),a0(At,Fv(Yt,3))}var cC=Dv(function(At,Yt){if(At==null)return[];var _r=Yt.length;return _r>1&&O1(At,Yt[0],Yt[1])?Yt=[]:_r>2&&O1(Yt[0],Yt[1],Yt[2])&&(Yt=[Yt[0]]),u2(At,e1(Yt,1),[])}),ME=VS||function(){return O_.Date.now()};function dC(At,Yt){if(typeof Yt!="function")throw new v1(h);return At=u_(At),function(){if(--At<1)return Yt.apply(this,arguments)}}function FT(At,Yt,_r){return Yt=_r?o:Yt,Yt=At&&Yt==null?At.length:Yt,fy(At,o0,o,o,o,o,Yt)}function UT(At,Yt){var _r;if(typeof Yt!="function")throw new v1(h);return At=u_(At),function(){return--At>0&&(_r=Yt.apply(this,arguments)),At<=1&&(Yt=o),_r}}var nT=Dv(function(At,Yt,_r){var a0=Hn;if(_r.length){var y0=X1(_r,V2(nT));a0|=e0}return fy(At,a0,Yt,_r,y0)}),zT=Dv(function(At,Yt,_r){var a0=Hn|Qt;if(_r.length){var y0=X1(_r,V2(zT));a0|=e0}return fy(Yt,a0,At,_r,y0)});function GT(At,Yt,_r){Yt=_r?o:Yt;var a0=fy(At,fr,o,o,o,o,o,Yt);return a0.placeholder=GT.placeholder,a0}function VT(At,Yt,_r){Yt=_r?o:Yt;var a0=fy(At,jr,o,o,o,o,o,Yt);return a0.placeholder=VT.placeholder,a0}function HT(At,Yt,_r){var a0,y0,A0,W0,Q0,ay,Ny=0,Fy=!1,qy=!1,pv=!0;if(typeof At!="function")throw new v1(h);Yt=yw(Yt)||0,U_(_r)&&(Fy=!!_r.leading,qy="maxWait"in _r,A0=qy?Z_(yw(_r.maxWait)||0,Yt):A0,pv="trailing"in _r?!!_r.trailing:pv);function Cv(Y_){var $w=a0,sx=y0;return a0=y0=o,Ny=Y_,W0=At.apply(sx,$w),W0}function zv(Y_){return Ny=Y_,Q0=$S(h_,Yt),Fy?Cv(Y_):W0}function c_(Y_){var $w=Y_-ay,sx=Y_-Ny,uA=Yt-$w;return qy?a1(uA,A0-sx):uA}function Gv(Y_){var $w=Y_-ay,sx=Y_-Ny;return ay===o||$w>=Yt||$w<0||qy&&sx>=A0}function h_(){var Y_=ME();if(Gv(Y_))return g_(Y_);Q0=$S(h_,c_(Y_))}function g_(Y_){return Q0=o,pv&&a0?Cv(Y_):(a0=y0=o,W0)}function rw(){Q0!==o&&wE(Q0),Ny=0,a0=ay=y0=Q0=o}function P1(){return Q0===o?W0:g_(ME())}function iw(){var Y_=ME(),$w=Gv(Y_);if(a0=arguments,y0=this,ay=Y_,$w){if(Q0===o)return zv(ay);if(qy)return wE(Q0),Q0=$S(h_,Yt),Cv(ay)}return Q0===o&&(Q0=$S(h_,Yt)),W0}return iw.cancel=rw,iw.flush=P1,iw}var fC=Dv(function(At,Yt){return dS(At,1,Yt)}),pC=Dv(function(At,Yt,_r){return dS(At,yw(Yt)||0,_r)});function hC(At){return fy(At,g0)}function IE(At,Yt){if(typeof At!="function"||Yt!=null&&typeof Yt!="function")throw new v1(h);var _r=function(){var a0=arguments,y0=Yt?Yt.apply(this,a0):a0[0],A0=_r.cache;if(A0.has(y0))return A0.get(y0);var W0=At.apply(this,a0);return _r.cache=A0.set(y0,W0)||A0,W0};return _r.cache=new(IE.Cache||k1),_r}IE.Cache=k1;function RE(At){if(typeof At!="function")throw new v1(h);return function(){var Yt=arguments;switch(Yt.length){case 0:return!At.call(this);case 1:return!At.call(this,Yt[0]);case 2:return!At.call(this,Yt[0],Yt[1]);case 3:return!At.call(this,Yt[0],Yt[1],Yt[2])}return!At.apply(this,Yt)}}function mC(At){return UT(2,At)}var gC=bE(function(At,Yt){Yt=Yt.length==1&&n_(Yt[0])?M_(Yt[0],g1(Fv())):M_(e1(Yt,1),g1(Fv()));var _r=Yt.length;return Dv(function(a0){for(var y0=-1,A0=a1(a0.length,_r);++y0<A0;)a0[y0]=Yt[y0].call(this,a0[y0]);return Lv(At,this,a0)})}),rT=Dv(function(At,Yt){var _r=X1(Yt,V2(rT));return fy(At,e0,o,Yt,_r)}),WT=Dv(function(At,Yt){var _r=X1(Yt,V2(WT));return fy(At,t0,o,Yt,_r)}),yC=a_(function(At,Yt){return fy(At,l0,o,o,o,Yt)});function vC(At,Yt){if(typeof At!="function")throw new v1(h);return Yt=Yt===o?Yt:u_(Yt),Dv(At,Yt)}function _C(At,Yt){if(typeof At!="function")throw new v1(h);return Yt=Yt==null?0:Z_(u_(Yt),0),Dv(function(_r){var a0=_r[Yt],y0=zw(_r,0,Yt);return a0&&j1(y0,a0),Lv(At,this,y0)})}function bC(At,Yt,_r){var a0=!0,y0=!0;if(typeof At!="function")throw new v1(h);return U_(_r)&&(a0="leading"in _r?!!_r.leading:a0,y0="trailing"in _r?!!_r.trailing:y0),HT(At,Yt,{leading:a0,maxWait:Yt,trailing:y0})}function wC(At){return FT(At,1)}function xC(At,Yt){return rT(c1(Yt),At)}function SC(){if(!arguments.length)return[];var At=arguments[0];return n_(At)?At:[At]}function EC(At){return $1(At,It)}function TC(At,Yt){return Yt=typeof Yt=="function"?Yt:o,$1(At,It,Yt)}function AC(At){return $1(At,b|It)}function $C(At,Yt){return Yt=typeof Yt=="function"?Yt:o,$1(At,b|It,Yt)}function CC(At,Yt){return Yt==null||M2(At,Yt,p1(Yt))}function Aw(At,Yt){return At===Yt||At!==At&&Yt!==Yt}var MC=Iv(o2),IC=Iv(function(At,Yt){return At>=Yt}),g2=r_(function(){return arguments}())?r_:function(At){return j_(At)&&__.call(At,"callee")&&!S2.call(At,"callee")},n_=Sy.isArray,RC=by?g1(by):V_;function z1(At){return At!=null&&OE(At.length)&&!ax(At)}function X_(At){return j_(At)&&z1(At)}function OC(At){return At===!0||At===!1||j_(At)&&r1(At)==Qy}var kx=WS||hT,PC=Vy?g1(Vy):H_;function DC(At){return j_(At)&&At.nodeType===1&&!CS(At)}function BC(At){if(At==null)return!0;if(z1(At)&&(n_(At)||typeof At=="string"||typeof At.splice=="function"||kx(At)||H2(At)||g2(At)))return!At.length;var Yt=x1(At);if(Yt==hy||Yt==I0)return!At.size;if(AS(At))return!s1(At).length;for(var _r in At)if(__.call(At,_r))return!1;return!0}function LC(At,Yt){return N_(At,Yt)}function kC(At,Yt,_r){_r=typeof _r=="function"?_r:o;var a0=_r?_r(At,Yt):o;return a0===o?N_(At,Yt,o,_r):!!a0}function iT(At){if(!j_(At))return!1;var Yt=r1(At);return Yt==zy||Yt==iv||typeof At.message=="string"&&typeof At.name=="string"&&!CS(At)}function NC(At){return typeof At=="number"&&eS(At)}function ax(At){if(!U_(At))return!1;var Yt=r1(At);return Yt==B0||Yt==Ay||Yt==Uy||Yt==sv}function jT(At){return typeof At=="number"&&At==u_(At)}function OE(At){return typeof At=="number"&&At>-1&&At%1==0&&At<=w0}function U_(At){var Yt=typeof At;return At!=null&&(Yt=="object"||Yt=="function")}function j_(At){return At!=null&&typeof At=="object"}var qT=Ev?g1(Ev):Rx;function FC(At,Yt){return At===Yt||F_(At,Yt,ZE(Yt))}function UC(At,Yt,_r){return _r=typeof _r=="function"?_r:o,F_(At,Yt,ZE(Yt),_r)}function zC(At){return ZT(At)&&At!=+At}function GC(At){if(TA(At))throw new Wv(c);return Ox(At)}function VC(At){return At===null}function HC(At){return At==null}function ZT(At){return typeof At=="number"||j_(At)&&r1(At)==Ly}function CS(At){if(!j_(At)||r1(At)!=Jy)return!1;var Yt=Kx(At);if(Yt===null)return!0;var _r=__.call(Yt,"constructor")&&Yt.constructor;return typeof _r=="function"&&_r instanceof _r&&Sx.call(_r)==Zw}var aT=Hv?g1(Hv):Px;function WC(At){return jT(At)&&At>=-w0&&At<=w0}var KT=Nv?g1(Nv):R2;function PE(At){return typeof At=="string"||!n_(At)&&j_(At)&&r1(At)==b0}function nw(At){return typeof At=="symbol"||j_(At)&&r1(At)==uy}var H2=jv?g1(jv):mS;function jC(At){return At===o}function qC(At){return j_(At)&&x1(At)==Dy}function ZC(At){return j_(At)&&r1(At)==By}var KC=Iv(s2),XC=Iv(function(At,Yt){return At<=Yt});function XT(At){if(!At)return[];if(z1(At))return PE(At)?L_(At):d1(At);if(Ow&&At[Ow])return mx(At[Ow]());var Yt=x1(At),_r=Yt==hy?Hx:Yt==I0?Wx:W2;return _r(At)}function ox(At){if(!At)return At===0?At:0;if(At=yw(At),At===ty||At===-ty){var Yt=At<0?-1:1;return Yt*L0}return At===At?At:0}function u_(At){var Yt=ox(At),_r=Yt%1;return Yt===Yt?_r?Yt-_r:Yt:0}function YT(At){return At?Bw(u_(At),0,T0):0}function yw(At){if(typeof At=="number")return At;if(nw(At))return k0;if(U_(At)){var Yt=typeof At.valueOf=="function"?At.valueOf():At;At=U_(Yt)?Yt+"":Yt}if(typeof At!="string")return At===0?At:+At;At=b2(At);var _r=$0.test(At);return _r||Yr.test(At)?y2(At.slice(2),_r?2:8):h0.test(At)?k0:+At}function JT(At){return U1(At,G1(At))}function YC(At){return At?Bw(u_(At),-w0,w0):At===0?At:0}function T_(At){return At==null?"":u1(At)}var JC=rx(function(At,Yt){if(AS(Yt)||z1(Yt)){U1(Yt,p1(Yt),At);return}for(var _r in Yt)__.call(Yt,_r)&&J1(At,_r,Yt[_r])}),QT=rx(function(At,Yt){U1(Yt,G1(Yt),At)}),DE=rx(function(At,Yt,_r,a0){U1(Yt,G1(Yt),At,a0)}),QC=rx(function(At,Yt,_r,a0){U1(Yt,p1(Yt),At,a0)}),eM=a_(C2);function tM(At,Yt){var _r=Sw(At);return Yt==null?_r:uS(_r,Yt)}var nM=Dv(function(At,Yt){At=Uv(At);var _r=-1,a0=Yt.length,y0=a0>2?Yt[2]:o;for(y0&&O1(Yt[0],Yt[1],y0)&&(a0=1);++_r<a0;)for(var A0=Yt[_r],W0=G1(A0),Q0=-1,ay=W0.length;++Q0<ay;){var Ny=W0[Q0],Fy=At[Ny];(Fy===o||Aw(Fy,xx[Ny])&&!__.call(At,Ny))&&(At[Ny]=A0[Ny])}return At}),rM=Dv(function(At){return At.push(o,$y),Lv(eA,o,At)});function iM(At,Yt){return j2(At,Fv(Yt,3),C1)}function aM(At,Yt){return j2(At,Fv(Yt,3),Mx)}function oM(At,Yt){return At==null?At:Cx(At,Fv(Yt,3),G1)}function sM(At,Yt){return At==null?At:a2(At,Fv(Yt,3),G1)}function lM(At,Yt){return At&&C1(At,Fv(Yt,3))}function uM(At,Yt){return At&&Mx(At,Fv(Yt,3))}function cM(At){return At==null?[]:ex(At,p1(At))}function dM(At){return At==null?[]:ex(At,G1(At))}function oT(At,Yt,_r){var a0=At==null?o:ew(At,Yt);return a0===o?_r:a0}function fM(At,Yt){return At!=null&&_T(At,Yt,gE)}function sT(At,Yt){return At!=null&&_T(At,Yt,pS)}var pM=z0(function(At,Yt,_r){Yt!=null&&typeof Yt.toString!="function"&&(Yt=T1.call(Yt)),At[Yt]=_r},uT(V1)),hM=z0(function(At,Yt,_r){Yt!=null&&typeof Yt.toString!="function"&&(Yt=T1.call(Yt)),__.call(At,Yt)?At[Yt].push(_r):At[Yt]=[_r]},Fv),mM=Dv(R_);function p1(At){return z1(At)?fv(At):s1(At)}function G1(At){return z1(At)?fv(At,!0):gS(At)}function gM(At,Yt){var _r={};return Yt=Fv(Yt,3),C1(At,function(a0,y0,A0){fw(_r,Yt(a0,y0,A0),a0)}),_r}function yM(At,Yt){var _r={};return Yt=Fv(Yt,3),C1(At,function(a0,y0,A0){fw(_r,y0,Yt(a0,y0,A0))}),_r}var vM=rx(function(At,Yt,_r){tw(At,Yt,_r)}),eA=rx(function(At,Yt,_r,a0){tw(At,Yt,_r,a0)}),_M=a_(function(At,Yt){var _r={};if(At==null)return _r;var a0=!1;Yt=M_(Yt,function(A0){return A0=Uw(A0,At),a0||(a0=A0.length>1),A0}),U1(At,m_(At),_r),a0&&(_r=$1(_r,b|Et|It,hv));for(var y0=Yt.length;y0--;)bS(_r,Yt[y0]);return _r});function bM(At,Yt){return tA(At,RE(Fv(Yt)))}var wM=a_(function(At,Yt){return At==null?{}:c2(At,Yt)});function tA(At,Yt){if(At==null)return{};var _r=M_(m_(At),function(a0){return[a0]});return Yt=Fv(Yt),D2(At,_r,function(a0,y0){return Yt(a0,y0[0])})}function xM(At,Yt,_r){Yt=Uw(Yt,At);var a0=-1,y0=Yt.length;for(y0||(y0=1,At=o);++a0<y0;){var A0=At==null?o:At[Vw(Yt[a0])];A0===o&&(a0=y0,A0=_r),At=ax(A0)?A0.call(At):A0}return At}function SM(At,Yt,_r){return At==null?At:nx(At,Yt,_r)}function EM(At,Yt,_r,a0){return a0=typeof a0=="function"?a0:o,At==null?At:nx(At,Yt,_r,a0)}var nA=R1(p1),rA=R1(G1);function TM(At,Yt,_r){var a0=n_(At),y0=a0||kx(At)||H2(At);if(Yt=Fv(Yt,4),_r==null){var A0=At&&At.constructor;y0?_r=a0?new A0:[]:U_(At)?_r=ax(A0)?Sw(Kx(At)):{}:_r={}}return(y0?dy:C1)(At,function(W0,Q0,ay){return Yt(_r,W0,Q0,ay)}),_r}function AM(At,Yt){return At==null?!0:bS(At,Yt)}function $M(At,Yt,_r){return At==null?At:wS(At,Yt,c1(_r))}function CM(At,Yt,_r,a0){return a0=typeof a0=="function"?a0:o,At==null?At:wS(At,Yt,c1(_r),a0)}function W2(At){return At==null?[]:y1(At,p1(At))}function MM(At){return At==null?[]:y1(At,G1(At))}function IM(At,Yt,_r){return _r===o&&(_r=Yt,Yt=o),_r!==o&&(_r=yw(_r),_r=_r===_r?_r:0),Yt!==o&&(Yt=yw(Yt),Yt=Yt===Yt?Yt:0),Bw(yw(At),Yt,_r)}function RM(At,Yt,_r){return Yt=ox(Yt),_r===o?(_r=Yt,Yt=0):_r=ox(_r),At=yw(At),HE(At,Yt,_r)}function OM(At,Yt,_r){if(_r&&typeof _r!="boolean"&&O1(At,Yt,_r)&&(Yt=_r=o),_r===o&&(typeof Yt=="boolean"?(_r=Yt,Yt=o):typeof At=="boolean"&&(_r=At,At=o)),At===o&&Yt===o?(At=0,Yt=1):(At=ox(At),Yt===o?(Yt=At,At=0):Yt=ox(Yt)),At>Yt){var a0=At;At=Yt,Yt=a0}if(_r||At%1||Yt%1){var y0=tS();return a1(At+y0*(Yt-At+Fx("1e-"+((y0+"").length-1))),Yt)}return pw(At,Yt)}var PM=Pt(function(At,Yt,_r){return Yt=Yt.toLowerCase(),At+(_r?iA(Yt):Yt)});function iA(At){return lT(T_(At).toLowerCase())}function aA(At){return At=T_(At),At&&At.replace(p0,NS).replace(y_,"")}function DM(At,Yt,_r){At=T_(At),Yt=u1(Yt);var a0=At.length;_r=_r===o?a0:Bw(u_(_r),0,a0);var y0=_r;return _r-=Yt.length,_r>=0&&At.slice(_r,y0)==Yt}function BM(At){return At=T_(At),At&&sy.test(At)?At.replace(N0,FS):At}function LM(At){return At=T_(At),At&&C_.test(At)?At.replace(ov,"\\$&"):At}var kM=Pt(function(At,Yt,_r){return At+(_r?"-":"")+Yt.toLowerCase()}),NM=Pt(function(At,Yt,_r){return At+(_r?" ":"")+Yt.toLowerCase()}),FM=EE("toLowerCase");function UM(At,Yt,_r){At=T_(At),Yt=u_(Yt);var a0=Yt?ow(At):0;if(!Yt||a0>=Yt)return At;var y0=(Yt-a0)/2;return tv(Jx(y0),_r)+At+tv(Yx(y0),_r)}function zM(At,Yt,_r){At=T_(At),Yt=u_(Yt);var a0=Yt?ow(At):0;return Yt&&a0<Yt?At+tv(Yt-a0,_r):At}function GM(At,Yt,_r){At=T_(At),Yt=u_(Yt);var a0=Yt?ow(At):0;return Yt&&a0<Yt?tv(Yt-a0,_r)+At:At}function VM(At,Yt,_r){return _r||Yt==null?Yt=0:Yt&&(Yt=+Yt),ZS(T_(At).replace(wy,""),Yt||0)}function HM(At,Yt,_r){return(_r?O1(At,Yt,_r):Yt===o)?Yt=1:Yt=u_(Yt),Lx(T_(At),Yt)}function WM(){var At=arguments,Yt=T_(At[0]);return At.length<3?Yt:Yt.replace(At[1],At[2])}var jM=Pt(function(At,Yt,_r){return At+(_r?"_":"")+Yt.toLowerCase()});function qM(At,Yt,_r){return _r&&typeof _r!="number"&&O1(At,Yt,_r)&&(Yt=_r=o),_r=_r===o?T0:_r>>>0,_r?(At=T_(At),At&&(typeof Yt=="string"||Yt!=null&&!aT(Yt))&&(Yt=u1(Yt),!Yt&&qw(At))?zw(L_(At),0,_r):At.split(Yt,_r)):[]}var ZM=Pt(function(At,Yt,_r){return At+(_r?" ":"")+lT(Yt)});function KM(At,Yt,_r){return At=T_(At),_r=_r==null?0:Bw(u_(_r),0,At.length),Yt=u1(Yt),At.slice(_r,_r+Yt.length)==Yt}function XM(At,Yt,_r){var a0=S0.templateSettings;_r&&O1(At,Yt,_r)&&(Yt=o),At=T_(At),Yt=DE({},Yt,a0,iy);var y0=DE({},Yt.imports,a0.imports,iy),A0=p1(y0),W0=y1(y0,A0),Q0,ay,Ny=0,Fy=Yt.interpolate||_0,qy="__p += '",pv=J_((Yt.escape||_0).source+"|"+Fy.source+"|"+(Fy===Sv?E0:_0).source+"|"+(Yt.evaluate||_0).source+"|$","g"),Cv="//# sourceURL="+(__.call(Yt,"sourceURL")?(Yt.sourceURL+"").replace(/\s/g," "):"lodash.templateSources["+ ++t_+"]")+`
`;At.replace(pv,function(Gv,h_,g_,rw,P1,iw){return g_||(g_=rw),qy+=At.slice(Ny,iw).replace(D0,q2),h_&&(Q0=!0,qy+=`' +
__e(`+h_+`) +
'`),P1&&(ay=!0,qy+=`';
`+P1+`;
__p += '`),g_&&(qy+=`' +
((__t = (`+g_+`)) == null ? '' : __t) +
'`),Ny=iw+Gv.length,Gv}),qy+=`';
`;var zv=__.call(Yt,"variable")&&Yt.variable;if(!zv)qy=`with (obj) {
`+qy+`
}
`;else if(h1.test(zv))throw new Wv(_);qy=(ay?qy.replace(Py,""):qy).replace(nv,"$1").replace(d0,"$1;"),qy="function("+(zv||"obj")+`) {
`+(zv?"":`obj || (obj = {});
`)+"var __t, __p = ''"+(Q0?", __e = _.escape":"")+(ay?`, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`:`;
`)+qy+`return __p
}`;var c_=sA(function(){return e_(A0,Cv+"return "+qy).apply(o,W0)});if(c_.source=qy,iT(c_))throw c_;return c_}function YM(At){return T_(At).toLowerCase()}function JM(At){return T_(At).toUpperCase()}function QM(At,Yt,_r){if(At=T_(At),At&&(_r||Yt===o))return b2(At);if(!At||!(Yt=u1(Yt)))return At;var a0=L_(At),y0=L_(Yt),A0=I_(a0,y0),W0=hx(a0,y0)+1;return zw(a0,A0,W0).join("")}function e3(At,Yt,_r){if(At=T_(At),At&&(_r||Yt===o))return At.slice(0,vx(At)+1);if(!At||!(Yt=u1(Yt)))return At;var a0=L_(At),y0=hx(a0,L_(Yt))+1;return zw(a0,0,y0).join("")}function t3(At,Yt,_r){if(At=T_(At),At&&(_r||Yt===o))return At.replace(wy,"");if(!At||!(Yt=u1(Yt)))return At;var a0=L_(At),y0=I_(a0,L_(Yt));return zw(a0,y0).join("")}function n3(At,Yt){var _r=i0,a0=f0;if(U_(Yt)){var y0="separator"in Yt?Yt.separator:y0;_r="length"in Yt?u_(Yt.length):_r,a0="omission"in Yt?u1(Yt.omission):a0}At=T_(At);var A0=At.length;if(qw(At)){var W0=L_(At);A0=W0.length}if(_r>=A0)return At;var Q0=_r-ow(a0);if(Q0<1)return a0;var ay=W0?zw(W0,0,Q0).join(""):At.slice(0,Q0);if(y0===o)return ay+a0;if(W0&&(Q0+=ay.length-Q0),aT(y0)){if(At.slice(Q0).search(y0)){var Ny,Fy=ay;for(y0.global||(y0=J_(y0.source,T_(j0.exec(y0))+"g")),y0.lastIndex=0;Ny=y0.exec(Fy);)var qy=Ny.index;ay=ay.slice(0,qy===o?Q0:qy)}}else if(At.indexOf(u1(y0),Q0)!=Q0){var pv=ay.lastIndexOf(y0);pv>-1&&(ay=ay.slice(0,pv))}return ay+a0}function r3(At){return At=T_(At),At&&F0.test(At)?At.replace(v0,bx):At}var i3=Pt(function(At,Yt,_r){return At+(_r?" ":"")+Yt.toUpperCase()}),lT=EE("toUpperCase");function oA(At,Yt,_r){return At=T_(At),Yt=_r?o:Yt,Yt===o?Vx(At)?wx(At):LS(At):At.match(Yt)||[]}var sA=Dv(function(At,Yt){try{return Lv(At,o,Yt)}catch(_r){return iT(_r)?_r:new Wv(_r)}}),a3=a_(function(At,Yt){return dy(Yt,function(_r){_r=Vw(_r),fw(At,_r,nT(At[_r],At))}),At});function o3(At){var Yt=At==null?0:At.length,_r=Fv();return At=Yt?M_(At,function(a0){if(typeof a0[1]!="function")throw new v1(h);return[_r(a0[0]),a0[1]]}):[],Dv(function(a0){for(var y0=-1;++y0<Yt;){var A0=At[y0];if(Lv(A0[0],this,a0))return Lv(A0[1],this,a0)}})}function s3(At){return cS($1(At,b))}function uT(At){return function(){return At}}function l3(At,Yt){return At==null||At!==At?Yt:At}var u3=n0(),c3=n0(!0);function V1(At){return At}function cT(At){return Dx(typeof At=="function"?At:$1(At,b))}function d3(At){return l2($1(At,b))}function f3(At,Yt){return O2(At,$1(Yt,b))}var p3=Dv(function(At,Yt){return function(_r){return R_(_r,At,Yt)}}),h3=Dv(function(At,Yt){return function(_r){return R_(At,_r,Yt)}});function dT(At,Yt,_r){var a0=p1(Yt),y0=ex(Yt,a0);_r==null&&!(U_(Yt)&&(y0.length||!a0.length))&&(_r=Yt,Yt=At,At=this,y0=ex(Yt,p1(Yt)));var A0=!(U_(_r)&&"chain"in _r)||!!_r.chain,W0=ax(At);return dy(y0,function(Q0){var ay=Yt[Q0];At[Q0]=ay,W0&&(At.prototype[Q0]=function(){var Ny=this.__chain__;if(A0||Ny){var Fy=At(this.__wrapped__),qy=Fy.__actions__=d1(this.__actions__);return qy.push({func:ay,args:arguments,thisArg:At}),Fy.__chain__=Ny,Fy}return ay.apply(At,j1([this.value()],arguments))})}),At}function m3(){return O_._===this&&(O_._=w2),this}function fT(){}function g3(At){return At=u_(At),Dv(function(Yt){return Ew(Yt,At)})}var y3=My(M_),v3=My(d_),_3=My(Ux);function lA(At){return XE(At)?b1(Vw(At)):B2(At)}function b3(At){return function(Yt){return At==null?o:ew(At,Yt)}}var w3=Yv(),x3=Yv(!0);function pT(){return[]}function hT(){return!1}function S3(){return{}}function E3(){return""}function T3(){return!0}function A3(At,Yt){if(At=u_(At),At<1||At>w0)return[];var _r=T0,a0=a1(At,T0);Yt=Fv(Yt),At-=T0;for(var y0=bw(a0,Yt);++_r<At;)Yt(_r);return y0}function $3(At){return n_(At)?M_(At,Vw):nw(At)?[At]:d1(CT(T_(At)))}function C3(At){var Yt=++X2;return T_(At)+Yt}var M3=ny(function(At,Yt){return At+Yt},0),I3=Tv("ceil"),R3=ny(function(At,Yt){return At/Yt},1),O3=Tv("floor");function P3(At){return At&&At.length?i2(At,V1,o2):o}function D3(At,Yt){return At&&At.length?i2(At,Fv(Yt,2),o2):o}function B3(At){return Gx(At,V1)}function L3(At,Yt){return Gx(At,Fv(Yt,2))}function k3(At){return At&&At.length?i2(At,V1,s2):o}function N3(At,Yt){return At&&At.length?i2(At,Fv(Yt,2),s2):o}var F3=ny(function(At,Yt){return At*Yt},1),U3=Tv("round"),z3=ny(function(At,Yt){return At-Yt},0);function G3(At){return At&&At.length?Z1(At,V1):0}function V3(At,Yt){return At&&At.length?Z1(At,Fv(Yt,2)):0}return S0.after=dC,S0.ary=FT,S0.assign=JC,S0.assignIn=QT,S0.assignInWith=DE,S0.assignWith=QC,S0.at=eM,S0.before=UT,S0.bind=nT,S0.bindAll=a3,S0.bindKey=zT,S0.castArray=SC,S0.chain=LT,S0.chunk=OA,S0.compact=PA,S0.concat=DA,S0.cond=o3,S0.conforms=s3,S0.constant=uT,S0.countBy=G$,S0.create=tM,S0.curry=GT,S0.curryRight=VT,S0.debounce=HT,S0.defaults=nM,S0.defaultsDeep=rM,S0.defer=fC,S0.delay=pC,S0.difference=BA,S0.differenceBy=LA,S0.differenceWith=kA,S0.drop=NA,S0.dropRight=FA,S0.dropRightWhile=UA,S0.dropWhile=zA,S0.fill=GA,S0.filter=H$,S0.flatMap=q$,S0.flatMapDeep=Z$,S0.flatMapDepth=K$,S0.flatten=OT,S0.flattenDeep=VA,S0.flattenDepth=HA,S0.flip=hC,S0.flow=u3,S0.flowRight=c3,S0.fromPairs=WA,S0.functions=cM,S0.functionsIn=dM,S0.groupBy=X$,S0.initial=qA,S0.intersection=ZA,S0.intersectionBy=KA,S0.intersectionWith=XA,S0.invert=pM,S0.invertBy=hM,S0.invokeMap=J$,S0.iteratee=cT,S0.keyBy=Q$,S0.keys=p1,S0.keysIn=G1,S0.map=CE,S0.mapKeys=gM,S0.mapValues=yM,S0.matches=d3,S0.matchesProperty=f3,S0.memoize=IE,S0.merge=vM,S0.mergeWith=eA,S0.method=p3,S0.methodOf=h3,S0.mixin=dT,S0.negate=RE,S0.nthArg=g3,S0.omit=_M,S0.omitBy=bM,S0.once=mC,S0.orderBy=eC,S0.over=y3,S0.overArgs=gC,S0.overEvery=v3,S0.overSome=_3,S0.partial=rT,S0.partialRight=WT,S0.partition=tC,S0.pick=wM,S0.pickBy=tA,S0.property=lA,S0.propertyOf=b3,S0.pull=e$,S0.pullAll=DT,S0.pullAllBy=t$,S0.pullAllWith=n$,S0.pullAt=r$,S0.range=w3,S0.rangeRight=x3,S0.rearg=yC,S0.reject=iC,S0.remove=i$,S0.rest=vC,S0.reverse=eT,S0.sampleSize=oC,S0.set=SM,S0.setWith=EM,S0.shuffle=sC,S0.slice=a$,S0.sortBy=cC,S0.sortedUniq=f$,S0.sortedUniqBy=p$,S0.split=qM,S0.spread=_C,S0.tail=h$,S0.take=m$,S0.takeRight=g$,S0.takeRightWhile=y$,S0.takeWhile=v$,S0.tap=P$,S0.throttle=bC,S0.thru=$E,S0.toArray=XT,S0.toPairs=nA,S0.toPairsIn=rA,S0.toPath=$3,S0.toPlainObject=JT,S0.transform=TM,S0.unary=wC,S0.union=_$,S0.unionBy=b$,S0.unionWith=w$,S0.uniq=x$,S0.uniqBy=S$,S0.uniqWith=E$,S0.unset=AM,S0.unzip=tT,S0.unzipWith=BT,S0.update=$M,S0.updateWith=CM,S0.values=W2,S0.valuesIn=MM,S0.without=T$,S0.words=oA,S0.wrap=xC,S0.xor=A$,S0.xorBy=$$,S0.xorWith=C$,S0.zip=M$,S0.zipObject=I$,S0.zipObjectDeep=R$,S0.zipWith=O$,S0.entries=nA,S0.entriesIn=rA,S0.extend=QT,S0.extendWith=DE,dT(S0,S0),S0.add=M3,S0.attempt=sA,S0.camelCase=PM,S0.capitalize=iA,S0.ceil=I3,S0.clamp=IM,S0.clone=EC,S0.cloneDeep=AC,S0.cloneDeepWith=$C,S0.cloneWith=TC,S0.conformsTo=CC,S0.deburr=aA,S0.defaultTo=l3,S0.divide=R3,S0.endsWith=DM,S0.eq=Aw,S0.escape=BM,S0.escapeRegExp=LM,S0.every=V$,S0.find=W$,S0.findIndex=IT,S0.findKey=iM,S0.findLast=j$,S0.findLastIndex=RT,S0.findLastKey=aM,S0.floor=O3,S0.forEach=kT,S0.forEachRight=NT,S0.forIn=oM,S0.forInRight=sM,S0.forOwn=lM,S0.forOwnRight=uM,S0.get=oT,S0.gt=MC,S0.gte=IC,S0.has=fM,S0.hasIn=sT,S0.head=PT,S0.identity=V1,S0.includes=Y$,S0.indexOf=jA,S0.inRange=RM,S0.invoke=mM,S0.isArguments=g2,S0.isArray=n_,S0.isArrayBuffer=RC,S0.isArrayLike=z1,S0.isArrayLikeObject=X_,S0.isBoolean=OC,S0.isBuffer=kx,S0.isDate=PC,S0.isElement=DC,S0.isEmpty=BC,S0.isEqual=LC,S0.isEqualWith=kC,S0.isError=iT,S0.isFinite=NC,S0.isFunction=ax,S0.isInteger=jT,S0.isLength=OE,S0.isMap=qT,S0.isMatch=FC,S0.isMatchWith=UC,S0.isNaN=zC,S0.isNative=GC,S0.isNil=HC,S0.isNull=VC,S0.isNumber=ZT,S0.isObject=U_,S0.isObjectLike=j_,S0.isPlainObject=CS,S0.isRegExp=aT,S0.isSafeInteger=WC,S0.isSet=KT,S0.isString=PE,S0.isSymbol=nw,S0.isTypedArray=H2,S0.isUndefined=jC,S0.isWeakMap=qC,S0.isWeakSet=ZC,S0.join=YA,S0.kebabCase=kM,S0.last=gw,S0.lastIndexOf=JA,S0.lowerCase=NM,S0.lowerFirst=FM,S0.lt=KC,S0.lte=XC,S0.max=P3,S0.maxBy=D3,S0.mean=B3,S0.meanBy=L3,S0.min=k3,S0.minBy=N3,S0.stubArray=pT,S0.stubFalse=hT,S0.stubObject=S3,S0.stubString=E3,S0.stubTrue=T3,S0.multiply=F3,S0.nth=QA,S0.noConflict=m3,S0.noop=fT,S0.now=ME,S0.pad=UM,S0.padEnd=zM,S0.padStart=GM,S0.parseInt=VM,S0.random=OM,S0.reduce=nC,S0.reduceRight=rC,S0.repeat=HM,S0.replace=WM,S0.result=xM,S0.round=U3,S0.runInContext=ey,S0.sample=aC,S0.size=lC,S0.snakeCase=jM,S0.some=uC,S0.sortedIndex=o$,S0.sortedIndexBy=s$,S0.sortedIndexOf=l$,S0.sortedLastIndex=u$,S0.sortedLastIndexBy=c$,S0.sortedLastIndexOf=d$,S0.startCase=ZM,S0.startsWith=KM,S0.subtract=z3,S0.sum=G3,S0.sumBy=V3,S0.template=XM,S0.times=A3,S0.toFinite=ox,S0.toInteger=u_,S0.toLength=YT,S0.toLower=YM,S0.toNumber=yw,S0.toSafeInteger=YC,S0.toString=T_,S0.toUpper=JM,S0.trim=QM,S0.trimEnd=e3,S0.trimStart=t3,S0.truncate=n3,S0.unescape=r3,S0.uniqueId=C3,S0.upperCase=i3,S0.upperFirst=lT,S0.each=kT,S0.eachRight=NT,S0.first=PT,dT(S0,function(){var At={};return C1(S0,function(Yt,_r){__.call(S0.prototype,_r)||(At[_r]=Yt)}),At}(),{chain:!1}),S0.VERSION=s,dy(["bind","bindKey","curry","curryRight","partial","partialRight"],function(At){S0[At].placeholder=S0}),dy(["drop","take"],function(At,Yt){Bv.prototype[At]=function(_r){_r=_r===o?1:Z_(u_(_r),0);var a0=this.__filtered__&&!Yt?new Bv(this):this.clone();return a0.__filtered__?a0.__takeCount__=a1(_r,a0.__takeCount__):a0.__views__.push({size:a1(_r,T0),type:At+(a0.__dir__<0?"Right":"")}),a0},Bv.prototype[At+"Right"]=function(_r){return this.reverse()[At](_r).reverse()}}),dy(["filter","map","takeWhile"],function(At,Yt){var _r=Yt+1,a0=_r==R0||_r==H0;Bv.prototype[At]=function(y0){var A0=this.clone();return A0.__iteratees__.push({iteratee:Fv(y0,3),type:_r}),A0.__filtered__=A0.__filtered__||a0,A0}}),dy(["head","last"],function(At,Yt){var _r="take"+(Yt?"Right":"");Bv.prototype[At]=function(){return this[_r](1).value()[0]}}),dy(["initial","tail"],function(At,Yt){var _r="drop"+(Yt?"":"Right");Bv.prototype[At]=function(){return this.__filtered__?new Bv(this):this[_r](1)}}),Bv.prototype.compact=function(){return this.filter(V1)},Bv.prototype.find=function(At){return this.filter(At).head()},Bv.prototype.findLast=function(At){return this.reverse().find(At)},Bv.prototype.invokeMap=Dv(function(At,Yt){return typeof At=="function"?new Bv(this):this.map(function(_r){return R_(_r,At,Yt)})}),Bv.prototype.reject=function(At){return this.filter(RE(Fv(At)))},Bv.prototype.slice=function(At,Yt){At=u_(At);var _r=this;return _r.__filtered__&&(At>0||Yt<0)?new Bv(_r):(At<0?_r=_r.takeRight(-At):At&&(_r=_r.drop(At)),Yt!==o&&(Yt=u_(Yt),_r=Yt<0?_r.dropRight(-Yt):_r.take(Yt-At)),_r)},Bv.prototype.takeRightWhile=function(At){return this.reverse().takeWhile(At).reverse()},Bv.prototype.toArray=function(){return this.take(T0)},C1(Bv.prototype,function(At,Yt){var _r=/^(?:filter|find|map|reject)|While$/.test(Yt),a0=/^(?:head|last)$/.test(Yt),y0=S0[a0?"take"+(Yt=="last"?"Right":""):Yt],A0=a0||/^find/.test(Yt);y0&&(S0.prototype[Yt]=function(){var W0=this.__wrapped__,Q0=a0?[1]:arguments,ay=W0 instanceof Bv,Ny=Q0[0],Fy=ay||n_(W0),qy=function(h_){var g_=y0.apply(S0,j1([h_],Q0));return a0&&pv?g_[0]:g_};Fy&&_r&&typeof Ny=="function"&&Ny.length!=1&&(ay=Fy=!1);var pv=this.__chain__,Cv=!!this.__actions__.length,zv=A0&&!pv,c_=ay&&!Cv;if(!A0&&Fy){W0=c_?W0:new Bv(this);var Gv=At.apply(W0,Q0);return Gv.__actions__.push({func:$E,args:[qy],thisArg:o}),new o1(Gv,pv)}return zv&&c_?At.apply(this,Q0):(Gv=this.thru(qy),zv?a0?Gv.value()[0]:Gv.value():Gv)})}),dy(["pop","push","shift","sort","splice","unshift"],function(At){var Yt=Iw[At],_r=/^(?:push|sort|unshift)$/.test(At)?"tap":"thru",a0=/^(?:pop|shift)$/.test(At);S0.prototype[At]=function(){var y0=arguments;if(a0&&!this.__chain__){var A0=this.value();return Yt.apply(n_(A0)?A0:[],y0)}return this[_r](function(W0){return Yt.apply(n_(W0)?W0:[],y0)})}}),C1(Bv.prototype,function(At,Yt){var _r=S0[Yt];if(_r){var a0=_r.name+"";__.call(Yw,a0)||(Yw[a0]=[]),Yw[a0].push({name:Yt,func:_r})}}),Yw[s0(o,Qt).name]=[{name:"wrapper",func:o}],Bv.prototype.clone=NE,Bv.prototype.reverse=FE,Bv.prototype.value=A1,S0.prototype.at=D$,S0.prototype.chain=B$,S0.prototype.commit=L$,S0.prototype.next=k$,S0.prototype.plant=F$,S0.prototype.reverse=U$,S0.prototype.toJSON=S0.prototype.valueOf=S0.prototype.value=z$,S0.prototype.first=S0.prototype.head,Ow&&(S0.prototype[Ow]=N$),S0},lw=GS();typeof define=="function"&&typeof define.amd=="object"&&define.amd?(O_._=lw,define(function(){return lw})):c0?((c0.exports=lw)._=lw,om._=lw):O_._=lw}).call(a)}}),import_lodash=__toESM(require_lodash());async function imageDecode(a){const e=MimeType.fromString(a.type);switch(e.type){case"image/x-alpha8":{const o=parseInt(e.params.width),s=parseInt(e.params.height);return ndarray4(new Uint8Array(await a.arrayBuffer()),[s,o,1])}case"image/x-rgba8":{const o=parseInt(e.params.width),s=parseInt(e.params.height);return ndarray4(new Uint8Array(await a.arrayBuffer()),[s,o,4])}case"application/octet-stream":case"image/png":case"image/jpeg":case"image/jpg":case"image/webp":{const o=await createImageBitmap(a),s=imageBitmapToImageData(o);return ndarray4(new Uint8Array(s.data),[s.height,s.width,4])}default:throw new Error(`Invalid format: ${e.type} with params: ${e.params}`)}}async function imageEncode(a,e=.8,o="image/png"){const[s,d,c]=a.shape;switch(o){case"image/x-alpha8":case"image/x-rgba8":{const bt=MimeType.create(o,{width:d.toString(),height:s.toString()});return new Blob([a.data],{type:bt.toString()})}case"image/png":case"image/jpeg":case"image/webp":{const bt=new ImageData(new Uint8ClampedArray(a.data),d,s);var h=createCanvas(bt.width,bt.height),_=h.getContext("2d");return _.putImageData(bt,0,0),h.convertToBlob({quality:e,type:o})}default:throw new Error(`Invalid format: ${o}`)}}var MimeType=class yT{constructor(e,o){this.type="application/octet-stream",this.params={},this.type=e,this.params=o}toString(){const e=[];for(const o in this.params){const s=this.params[o];e.push(`${o}=${s}`)}return[this.type,...e].join(";")}static create(e,o){return new yT(e,o)}isIdentical(e){return this.type===e.type&&this.params===e.params}isEqual(e){return this.type===e.type}static fromString(e){const[o,...s]=e.split(";"),d={};for(const c of s){const[h,_]=c.split("=");d[h.trim()]=_.trim()}return new yT(o,d)}};function isAbsoluteURI(a){return new RegExp("^(?:[a-z+]+:)?//","i").test(a)}function ensureAbsoluteURI(a,e){return isAbsoluteURI(a)?a:new URL(a,e).href}function imageBitmapToImageData(a){var e=createCanvas(a.width,a.height),o=e.getContext("2d");return o.drawImage(a,0,0),o.getImageData(0,0,e.width,e.height)}function createTypeArray(a){if(typeof Uint8Array<"u")return new Uint8Array(a);if(typeof Uint8ClampedArray<"u")return new Uint8ClampedArray(a);if(typeof Uint16Array<"u")return new Uint16Array(a);if(typeof Uint32Array<"u")return new Uint32Array(a);if(typeof Float32Array<"u")return new Float32Array(a);if(typeof Float64Array<"u")return new Float64Array(a);throw new Error("TypedArray not supported")}function tensorResizeBilinear(a,e,o,s=!1){const[d,c,h]=a.shape;let _=c/e,bt=d/o;s&&(_=bt=Math.max(_,bt)>1?Math.max(_,bt):Math.min(_,bt));const g=ndarray4(createTypeArray(h*e*o),[o,e,h]);for(let j=0;j<o;j++)for(let b=0;b<e;b++){const Et=b*_,It=j*bt,zt=Math.max(Math.floor(Et),0),er=Math.min(Math.ceil(Et),c-1),Hn=Math.max(Math.floor(It),0),Qt=Math.min(Math.ceil(It),d-1),cr=Et-zt,fr=It-Hn;for(let jr=0;jr<h;jr++){const e0=a.get(Hn,zt,jr),t0=a.get(Hn,er,jr),o0=a.get(Qt,zt,jr),l0=a.get(Qt,er,jr),g0=(1-cr)*(1-fr)*e0+cr*(1-fr)*t0+(1-cr)*fr*o0+cr*fr*l0;g.set(j,b,jr,g0)}}return g}function tensorHWCtoBCHW(a,e=[128,128,128],o=[256,256,256]){var s=a.data;const[d,c,h]=a.shape,_=d*c,bt=new Float32Array(3*_);for(let g=0,j=0;g<s.length;g+=4,j+=1)bt[j]=(s[g]-e[0])/o[0],bt[j+_]=(s[g+1]-e[1])/o[1],bt[j+_+_]=(s[g+2]-e[2])/o[2];return ndarray4(bt,[1,3,d,c])}async function imageSourceToImageData(a,e){return typeof a=="string"&&(a=ensureAbsoluteURI(a,e.publicPath),a=new URL(a)),a instanceof URL&&(a=await(await fetch(a,{})).blob()),(a instanceof ArrayBuffer||ArrayBuffer.isView(a))&&(a=new Blob([a])),a instanceof Blob&&(a=await imageDecode(a)),a}function convertFloat32ToUint8(a){const e=new Uint8Array(a.data.length);for(let o=0;o<a.data.length;o++)e[o]=a.data[o]*255;return ndarray4(e,a.shape)}function createCanvas(a,e){let o;if(typeof OffscreenCanvas<"u"?o=new OffscreenCanvas(a,e):o=document.createElement("canvas"),!o)throw new Error("Canvas nor OffscreenCanvas are available in the current context.");return o}async function loadAsUrl(a,e){return URL.createObjectURL(await loadAsBlob(a,e))}async function loadAsBlob(a,e){const o=new URL("resources.json",e.publicPath),s=await fetch(o);if(!s.ok)throw new Error("Resource metadata not found. Ensure that the config.publicPath is configured correctly.");const c=(await s.json())[a];if(!c)throw new Error(`Resource ${a} not found. Ensure that the config.publicPath is configured correctly.`);const h=c.chunks;let _=0;const bt=h.map(async b=>{const Et=b.offsets[1]-b.offsets[0],It=e.publicPath?new URL(b.hash,e.publicPath).toString():b.hash,er=await(await fetch(It,e.fetchArgs)).blob();if(Et!==er.size)throw new Error(`Failed to fetch ${a} with size ${Et} but got ${er.size}`);return e.progress&&(_+=Et,e.progress(`fetch:${a}`,_,c.size)),er}),g=await Promise.all(bt),j=new Blob(g,{type:c.mime});if(j.size!==c.size)throw new Error(`Failed to fetch ${a} with size ${c.size} but got ${j.size}`);return j}var simd=()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,10,1,8,0,65,0,253,15,253,98,11])),threads=()=>(async a=>{try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(a)}catch{return!1}})(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])),webgpu=()=>navigator.gpu!==void 0,maxNumThreads=()=>navigator.hardwareConcurrency??4;async function createOnnxSession(a,e){const o=e.device==="gpu",s=await threads(),d=simd(),c=e.proxyToWorker,h=[o?"webgpu":"wasm"],_=o?ort_gpu:ort_cpu;e.debug&&(console.debug("	Using Threads:",s),console.debug("	Using SIMD:",d),console.debug("	Using WebGPU:",o),console.debug("	Proxy to Worker:",c),_.env.debug=!0,_.env.logLevel="verbose"),_.env.wasm.numThreads=maxNumThreads(),_.env.wasm.simd=simd(),_.env.wasm.proxy=c;const bt={"ort-wasm-simd-threaded.wasm":s&&d,"ort-wasm-simd.wasm":!s&&d,"ort-wasm-threaded.wasm":!o&&s&&!d,"ort-wasm.wasm":!o&&!s&&!d},g={};for(const[Et,It]of Object.entries(bt))if(It){const zt=o&&Et.includes("simd")?`/onnxruntime-web/${Et.replace(".wasm",".jsep.wasm")}`:`/onnxruntime-web/${Et}`;g[Et]=await loadAsUrl(zt,e)}_.env.wasm.wasmPaths=g,e.debug&&console.debug("ort.env.wasm:",_.env.wasm);const j={executionProviders:h,graphOptimizationLevel:"all",executionMode:"parallel",enableCpuMemArena:!0};return await _.InferenceSession.create(a,j).catch(Et=>{throw new Error(`Failed to create session: "${Et}". Please check if the publicPath is set correctly.`)})}async function runOnnxSession(a,e,o,s){const c=s.device==="gpu"?ort_gpu:ort_cpu,h={};for(const[g,j]of e)h[g]=new c.Tensor("float32",new Float32Array(j.data),j.shape);const _=await a.run(h,{}),bt=[];for(const g of o){const j=_[g],b=j.dims,Et=j.data,It=ndarray4(Et,b);bt.push(It)}return bt}var package_default={name:"@imgly/background-removal",version:"1.5.1",description:"Background Removal in the Browser",keywords:["background-removal","client-side","data-privacy","image-segmentation","image-matting","onnx"],repository:{type:"git",url:"git+https://github.com/imgly/background-removal-js.git"},license:"SEE LICENSE IN LICENSE.md",author:{name:"IMG.LY GmbH",email:"support@img.ly",url:"https://img.ly"},bugs:{email:"support@img.ly"},source:"./src/index.ts",main:"./dist/index.cjs",module:"./dist/index.mjs",types:"./dist/src/index.d.ts",exports:{".":{require:"./dist/index.cjs",import:"./dist/index.mjs",types:"./dist/src/index.d.ts"}},homepage:"https://img.ly/showcases/cesdk/web/background-removal",files:["LICENSE.md","README.md","CHANGELOG.md","ThirdPartyLicenses.json","dist/","bin/"],scripts:{start:"npm run watch",clean:"npx rimraf dist",test:"true",resources:"node ../../scripts/package-resources.mjs","changelog:create":"node ../../scripts/changelog/changelog-create.mjs","changelog:generate":"node ../../scripts/changelog/changelog-generate.mjs",build:"npm run clean && npm run types && npm run resources && npm run changelog:generate && node scripts/build.mjs",types:" npx tsc --declaration --emitDeclarationOnly --declarationDir dist --declarationMap",watch:"npm run clean && npm run resources && npm run changelog:generate && node scripts/watch.mjs","publish:latest":"npm publish --tag latest --access public","publish:next":"npm publish --tag next --access public","package:pack":"npm pack . --pack-destination ../../releases",lint:"npx prettier --write ."},dependencies:{"@types/lodash-es":"^4.17.12","@types/ndarray":"~1.0.14","@types/node":"~20.3.0","lodash-es":"^4.17.21",ndarray:"~1.0.0","onnxruntime-web":"~1.17.0",zod:"^3.23.8"},devDependencies:{assert:"~2.0.0",esbuild:"~0.18.0",glob:"~10.3.0","npm-dts":"~1.3.0",process:"~0.11.0","ts-loader":"~9.4.0",tslib:"~2.5.0",typescript:"~5.1.0",util:"~0.12.0",webpack:"~5.85.0","webpack-cli":"~5.1.0"},bundleDependencies:[]},ConfigSchema=z.object({publicPath:z.string().optional().describe("The public path to the wasm files and the onnx model.").default("https://staticimgly.com/@imgly/background-removal-data/${PACKAGE_VERSION}/dist/").transform(a=>a.replace("${PACKAGE_NAME}",package_default.name).replace("${PACKAGE_VERSION}",package_default.version)),debug:z.boolean().default(!1).describe("Whether to enable debug logging."),rescale:z.boolean().default(!0).describe("Whether to rescale the image."),device:z.enum(["cpu","gpu"]).default("cpu").describe("The device to run the model on."),proxyToWorker:z.boolean().default(!0).describe("Whether to proxy inference to a web worker."),fetchArgs:z.any().default({}).describe("Arguments to pass to fetch when loading the model."),progress:z.function().args(z.string(),z.number(),z.number()).returns(z.void()).describe("Progress callback.").optional(),model:z.preprocess(a=>{switch(a){case"large":return"isnet";case"small":return"isnet_quint8";case"medium":return"isnet_fp16";default:return a}},z.enum(["isnet","isnet_fp16","isnet_quint8"])).default("medium"),output:z.object({format:z.enum(["image/png","image/jpeg","image/webp","image/x-rgba8","image/x-alpha8"]).default("image/png"),quality:z.number().default(.8)}).default({})}).default({}).transform(a=>{if(a.debug&&console.log("Config:",a),a.debug&&!a.progress&&(a.progress=a.progress??((e,o,s)=>{console.debug(`Downloading ${e}: ${o} of ${s}`)}),crossOriginIsolated||a.debug&&console.debug("Cross-Origin-Isolated is not enabled. Performance will be degraded. Please see  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer.")),a.device=="gpu")if(!webgpu())a.debug&&console.debug("Switching to CPU for GPU not supported."),a.device="cpu";else switch(a.model){case"isnet":break;case"isnet_fp16":case"isnet_quint8":a.debug&&console.debug("Switching to f32 model for GPU"),a.model="isnet";break}return a});function validateConfig(a){return ConfigSchema.parse(a??{})}async function initBase(a){a.debug&&console.debug("Loading model...",a.model);const e=a.model,s=await(await loadAsBlob(`/models/${e}`,a)).arrayBuffer();return await createOnnxSession(s,a)}async function initInference(a){a=validateConfig(a);const e=await initBase(a);return{config:a,session:{base:e}}}async function runInference(a,e,o){const[d,c,h]=a.shape,_=!1;let bt=tensorResizeBilinear(a,1024,1024,_);const g=tensorHWCtoBCHW(bt);let j=await runOnnxSession(o.base,[["input",g]],["output"],e),b=ndarray4(j[0].data,[1024,1024,1]),Et=convertFloat32ToUint8(b);return e.rescale?(Et=tensorResizeBilinear(Et,c,d,_),[Et,a]):[Et,bt]}var init=(0,import_lodash.memoize)(initInference,a=>JSON.stringify(a));async function removeBackground(a,e){var Et,It,zt,er;const{config:o,session:s}=await init(e);o.progress&&o.progress("compute:decode",0,4);const d=await imageSourceToImageData(a,o);(Et=o.progress)==null||Et.call(o,"compute:inference",1,4);const[c,h]=await runInference(d,o,s);(It=o.progress)==null||It.call(o,"compute:mask",2,4);const _=h,[bt,g]=_.shape,j=bt*g;for(let Hn=0;Hn<j;Hn+=1)_.data[4*Hn+3]=c.data[Hn];(zt=o.progress)==null||zt.call(o,"compute:encode",3,4);const b=await imageEncode(_,o.output.quality,o.output.format);return(er=o.progress)==null||er.call(o,"compute:encode",4,4),b}/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/function App(){const[a,e]=reactExports.useState(0),[o,s]=reactExports.useState(""),[d,c]=reactExports.useState(new Vector3(1,1,1)),h=async j=>{try{const b=await _(j);console.log("Upload Success:",b);const Et=await removeBackground(j),It=URL.createObjectURL(Et),zt=await bt(It);if(console.log("Prominent colors:",zt),zt&&zt.length>0){const er=g(zt.toString());e(er)}else console.error("No colors found")}catch(b){console.error("Error:",b)}},_=async j=>{const b=new FormData;b.append("image",j);const Et=await fetch("/upload",{method:"POST",body:b});if(!Et.ok)throw new Error("File upload failed");return Et.json()},bt=async j=>{try{return await prominent(j,{amount:1,format:"hex"})}catch(b){throw b instanceof Error?new Error("Error extracting colors: "+b.message):new Error("Error extracting colors: Unknown error")}},g=j=>parseInt(j.slice(1),16);return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment,{children:[jsxRuntimeExports.jsx(ThreeScene,{hexColor:a,texture:o,scale:d}),jsxRuntimeExports.jsx(Overlay,{setParentTexture:s,setParentHexColor:e,setParentScale:c,handleFileUpload:h})]})}client.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(React.StrictMode,{children:jsxRuntimeExports.jsx(App,{})}));
