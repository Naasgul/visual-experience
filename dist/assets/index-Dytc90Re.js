function _mergeNamespaces(st,at){for(var pt=0;pt<at.length;pt++){const vt=at[pt];if(typeof vt!="string"&&!Array.isArray(vt)){for(const wt in vt)if(wt!=="default"&&!(wt in st)){const $t=Object.getOwnPropertyDescriptor(vt,wt);$t&&Object.defineProperty(st,wt,$t.get?$t:{enumerable:!0,get:()=>vt[wt]})}}}return Object.freeze(Object.defineProperty(st,Symbol.toStringTag,{value:"Module"}))}(function(){const at=document.createElement("link").relList;if(at&&at.supports&&at.supports("modulepreload"))return;for(const wt of document.querySelectorAll('link[rel="modulepreload"]'))vt(wt);new MutationObserver(wt=>{for(const $t of wt)if($t.type==="childList")for(const Tt of $t.addedNodes)Tt.tagName==="LINK"&&Tt.rel==="modulepreload"&&vt(Tt)}).observe(document,{childList:!0,subtree:!0});function pt(wt){const $t={};return wt.integrity&&($t.integrity=wt.integrity),wt.referrerPolicy&&($t.referrerPolicy=wt.referrerPolicy),wt.crossOrigin==="use-credentials"?$t.credentials="include":wt.crossOrigin==="anonymous"?$t.credentials="omit":$t.credentials="same-origin",$t}function vt(wt){if(wt.ep)return;wt.ep=!0;const $t=pt(wt);fetch(wt.href,$t)}})();function getDefaultExportFromCjs(st){return st&&st.__esModule&&Object.prototype.hasOwnProperty.call(st,"default")?st.default:st}var jsxRuntime={exports:{}},reactJsxRuntime_production_min={},react={exports:{}},react_production_min={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var l$3=Symbol.for("react.element"),n$3=Symbol.for("react.portal"),p$5=Symbol.for("react.fragment"),q$3=Symbol.for("react.strict_mode"),r$2=Symbol.for("react.profiler"),t$2=Symbol.for("react.provider"),u$3=Symbol.for("react.context"),v$4=Symbol.for("react.forward_ref"),w$2=Symbol.for("react.suspense"),x$3=Symbol.for("react.memo"),y$3=Symbol.for("react.lazy"),z$3=Symbol.iterator;function A$2(st){return st===null||typeof st!="object"?null:(st=z$3&&st[z$3]||st["@@iterator"],typeof st=="function"?st:null)}var B$3={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C$2=Object.assign,D$2={};function E$2(st,at,pt){this.props=st,this.context=at,this.refs=D$2,this.updater=pt||B$3}E$2.prototype.isReactComponent={};E$2.prototype.setState=function(st,at){if(typeof st!="object"&&typeof st!="function"&&st!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,st,at,"setState")};E$2.prototype.forceUpdate=function(st){this.updater.enqueueForceUpdate(this,st,"forceUpdate")};function F$2(){}F$2.prototype=E$2.prototype;function G$2(st,at,pt){this.props=st,this.context=at,this.refs=D$2,this.updater=pt||B$3}var H$4=G$2.prototype=new F$2;H$4.constructor=G$2;C$2(H$4,E$2.prototype);H$4.isPureReactComponent=!0;var I$4=Array.isArray,J$2=Object.prototype.hasOwnProperty,K$2={current:null},L$4={key:!0,ref:!0,__self:!0,__source:!0};function M$4(st,at,pt){var vt,wt={},$t=null,Tt=null;if(at!=null)for(vt in at.ref!==void 0&&(Tt=at.ref),at.key!==void 0&&($t=""+at.key),at)J$2.call(at,vt)&&!L$4.hasOwnProperty(vt)&&(wt[vt]=at[vt]);var Lt=arguments.length-2;if(Lt===1)wt.children=pt;else if(1<Lt){for(var Ft=Array(Lt),Ct=0;Ct<Lt;Ct++)Ft[Ct]=arguments[Ct+2];wt.children=Ft}if(st&&st.defaultProps)for(vt in Lt=st.defaultProps,Lt)wt[vt]===void 0&&(wt[vt]=Lt[vt]);return{$$typeof:l$3,type:st,key:$t,ref:Tt,props:wt,_owner:K$2.current}}function N$3(st,at){return{$$typeof:l$3,type:st.type,key:at,ref:st.ref,props:st.props,_owner:st._owner}}function O$2(st){return typeof st=="object"&&st!==null&&st.$$typeof===l$3}function escape$1(st){var at={"=":"=0",":":"=2"};return"$"+st.replace(/[=:]/g,function(pt){return at[pt]})}var P$2=/\/+/g;function Q$3(st,at){return typeof st=="object"&&st!==null&&st.key!=null?escape$1(""+st.key):at.toString(36)}function R$3(st,at,pt,vt,wt){var $t=typeof st;($t==="undefined"||$t==="boolean")&&(st=null);var Tt=!1;if(st===null)Tt=!0;else switch($t){case"string":case"number":Tt=!0;break;case"object":switch(st.$$typeof){case l$3:case n$3:Tt=!0}}if(Tt)return Tt=st,wt=wt(Tt),st=vt===""?"."+Q$3(Tt,0):vt,I$4(wt)?(pt="",st!=null&&(pt=st.replace(P$2,"$&/")+"/"),R$3(wt,at,pt,"",function(Ct){return Ct})):wt!=null&&(O$2(wt)&&(wt=N$3(wt,pt+(!wt.key||Tt&&Tt.key===wt.key?"":(""+wt.key).replace(P$2,"$&/")+"/")+st)),at.push(wt)),1;if(Tt=0,vt=vt===""?".":vt+":",I$4(st))for(var Lt=0;Lt<st.length;Lt++){$t=st[Lt];var Ft=vt+Q$3($t,Lt);Tt+=R$3($t,at,pt,Ft,wt)}else if(Ft=A$2(st),typeof Ft=="function")for(st=Ft.call(st),Lt=0;!($t=st.next()).done;)$t=$t.value,Ft=vt+Q$3($t,Lt++),Tt+=R$3($t,at,pt,Ft,wt);else if($t==="object")throw at=String(st),Error("Objects are not valid as a React child (found: "+(at==="[object Object]"?"object with keys {"+Object.keys(st).join(", ")+"}":at)+"). If you meant to render a collection of children, use an array instead.");return Tt}function S$4(st,at,pt){if(st==null)return st;var vt=[],wt=0;return R$3(st,vt,"","",function($t){return at.call(pt,$t,wt++)}),vt}function T$3(st){if(st._status===-1){var at=st._result;at=at(),at.then(function(pt){(st._status===0||st._status===-1)&&(st._status=1,st._result=pt)},function(pt){(st._status===0||st._status===-1)&&(st._status=2,st._result=pt)}),st._status===-1&&(st._status=0,st._result=at)}if(st._status===1)return st._result.default;throw st._result}var U$5={current:null},V$5={transition:null},W$2={ReactCurrentDispatcher:U$5,ReactCurrentBatchConfig:V$5,ReactCurrentOwner:K$2};function X$2(){throw Error("act(...) is not supported in production builds of React.")}react_production_min.Children={map:S$4,forEach:function(st,at,pt){S$4(st,function(){at.apply(this,arguments)},pt)},count:function(st){var at=0;return S$4(st,function(){at++}),at},toArray:function(st){return S$4(st,function(at){return at})||[]},only:function(st){if(!O$2(st))throw Error("React.Children.only expected to receive a single React element child.");return st}};react_production_min.Component=E$2;react_production_min.Fragment=p$5;react_production_min.Profiler=r$2;react_production_min.PureComponent=G$2;react_production_min.StrictMode=q$3;react_production_min.Suspense=w$2;react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W$2;react_production_min.act=X$2;react_production_min.cloneElement=function(st,at,pt){if(st==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+st+".");var vt=C$2({},st.props),wt=st.key,$t=st.ref,Tt=st._owner;if(at!=null){if(at.ref!==void 0&&($t=at.ref,Tt=K$2.current),at.key!==void 0&&(wt=""+at.key),st.type&&st.type.defaultProps)var Lt=st.type.defaultProps;for(Ft in at)J$2.call(at,Ft)&&!L$4.hasOwnProperty(Ft)&&(vt[Ft]=at[Ft]===void 0&&Lt!==void 0?Lt[Ft]:at[Ft])}var Ft=arguments.length-2;if(Ft===1)vt.children=pt;else if(1<Ft){Lt=Array(Ft);for(var Ct=0;Ct<Ft;Ct++)Lt[Ct]=arguments[Ct+2];vt.children=Lt}return{$$typeof:l$3,type:st.type,key:wt,ref:$t,props:vt,_owner:Tt}};react_production_min.createContext=function(st){return st={$$typeof:u$3,_currentValue:st,_currentValue2:st,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},st.Provider={$$typeof:t$2,_context:st},st.Consumer=st};react_production_min.createElement=M$4;react_production_min.createFactory=function(st){var at=M$4.bind(null,st);return at.type=st,at};react_production_min.createRef=function(){return{current:null}};react_production_min.forwardRef=function(st){return{$$typeof:v$4,render:st}};react_production_min.isValidElement=O$2;react_production_min.lazy=function(st){return{$$typeof:y$3,_payload:{_status:-1,_result:st},_init:T$3}};react_production_min.memo=function(st,at){return{$$typeof:x$3,type:st,compare:at===void 0?null:at}};react_production_min.startTransition=function(st){var at=V$5.transition;V$5.transition={};try{st()}finally{V$5.transition=at}};react_production_min.unstable_act=X$2;react_production_min.useCallback=function(st,at){return U$5.current.useCallback(st,at)};react_production_min.useContext=function(st){return U$5.current.useContext(st)};react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(st){return U$5.current.useDeferredValue(st)};react_production_min.useEffect=function(st,at){return U$5.current.useEffect(st,at)};react_production_min.useId=function(){return U$5.current.useId()};react_production_min.useImperativeHandle=function(st,at,pt){return U$5.current.useImperativeHandle(st,at,pt)};react_production_min.useInsertionEffect=function(st,at){return U$5.current.useInsertionEffect(st,at)};react_production_min.useLayoutEffect=function(st,at){return U$5.current.useLayoutEffect(st,at)};react_production_min.useMemo=function(st,at){return U$5.current.useMemo(st,at)};react_production_min.useReducer=function(st,at,pt){return U$5.current.useReducer(st,at,pt)};react_production_min.useRef=function(st){return U$5.current.useRef(st)};react_production_min.useState=function(st){return U$5.current.useState(st)};react_production_min.useSyncExternalStore=function(st,at,pt){return U$5.current.useSyncExternalStore(st,at,pt)};react_production_min.useTransition=function(){return U$5.current.useTransition()};react_production_min.version="18.3.1";react.exports=react_production_min;var reactExports=react.exports;const React=getDefaultExportFromCjs(reactExports),$2AODx$react=_mergeNamespaces({__proto__:null,default:React},[reactExports]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var f$3=reactExports,k$3=Symbol.for("react.element"),l$2=Symbol.for("react.fragment"),m$4=Object.prototype.hasOwnProperty,n$2=f$3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p$4={key:!0,ref:!0,__self:!0,__source:!0};function q$2(st,at,pt){var vt,wt={},$t=null,Tt=null;pt!==void 0&&($t=""+pt),at.key!==void 0&&($t=""+at.key),at.ref!==void 0&&(Tt=at.ref);for(vt in at)m$4.call(at,vt)&&!p$4.hasOwnProperty(vt)&&(wt[vt]=at[vt]);if(st&&st.defaultProps)for(vt in at=st.defaultProps,at)wt[vt]===void 0&&(wt[vt]=at[vt]);return{$$typeof:k$3,type:st,key:$t,ref:Tt,props:wt,_owner:n$2.current}}reactJsxRuntime_production_min.Fragment=l$2;reactJsxRuntime_production_min.jsx=q$2;reactJsxRuntime_production_min.jsxs=q$2;jsxRuntime.exports=reactJsxRuntime_production_min;var jsxRuntimeExports=jsxRuntime.exports,client={},reactDom={exports:{}},reactDom_production_min={},scheduler$1={exports:{}},scheduler_production_min$1={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(st){function at(n0,m0){var h0=n0.length;n0.push(m0);e:for(;0<h0;){var a0=h0-1>>>1,P0=n0[a0];if(0<wt(P0,m0))n0[a0]=m0,n0[h0]=P0,h0=a0;else break e}}function pt(n0){return n0.length===0?null:n0[0]}function vt(n0){if(n0.length===0)return null;var m0=n0[0],h0=n0.pop();if(h0!==m0){n0[0]=h0;e:for(var a0=0,P0=n0.length,V0=P0>>>1;a0<V0;){var B0=2*(a0+1)-1,W0=n0[B0],K0=B0+1,Ty=n0[K0];if(0>wt(W0,h0))K0<P0&&0>wt(Ty,W0)?(n0[a0]=Ty,n0[K0]=h0,a0=K0):(n0[a0]=W0,n0[B0]=h0,a0=B0);else if(K0<P0&&0>wt(Ty,h0))n0[a0]=Ty,n0[K0]=h0,a0=K0;else break e}}return m0}function wt(n0,m0){var h0=n0.sortIndex-m0.sortIndex;return h0!==0?h0:n0.id-m0.id}if(typeof performance=="object"&&typeof performance.now=="function"){var $t=performance;st.unstable_now=function(){return $t.now()}}else{var Tt=Date,Lt=Tt.now();st.unstable_now=function(){return Tt.now()-Lt}}var Ft=[],Ct=[],Ht=1,Gt=null,jt=3,qt=!1,Kt=!1,An=!1,Sn=typeof setTimeout=="function"?setTimeout:null,wn=typeof clearTimeout=="function"?clearTimeout:null,In=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function tr(n0){for(var m0=pt(Ct);m0!==null;){if(m0.callback===null)vt(Ct);else if(m0.startTime<=n0)vt(Ct),m0.sortIndex=m0.expirationTime,at(Ft,m0);else break;m0=pt(Ct)}}function rr(n0){if(An=!1,tr(n0),!Kt)if(pt(Ft)!==null)Kt=!0,t0(Hr);else{var m0=pt(Ct);m0!==null&&E0(rr,m0.startTime-n0)}}function Hr(n0,m0){Kt=!1,An&&(An=!1,wn(Bo),Bo=-1),qt=!0;var h0=jt;try{for(tr(m0),Gt=pt(Ft);Gt!==null&&(!(Gt.expirationTime>m0)||n0&&!ko());){var a0=Gt.callback;if(typeof a0=="function"){Gt.callback=null,jt=Gt.priorityLevel;var P0=a0(Gt.expirationTime<=m0);m0=st.unstable_now(),typeof P0=="function"?Gt.callback=P0:Gt===pt(Ft)&&vt(Ft),tr(m0)}else vt(Ft);Gt=pt(Ft)}if(Gt!==null)var V0=!0;else{var B0=pt(Ct);B0!==null&&E0(rr,B0.startTime-m0),V0=!1}return V0}finally{Gt=null,jt=h0,qt=!1}}var qr=!1,Zr=null,Bo=-1,Xo=5,Kr=-1;function ko(){return!(st.unstable_now()-Kr<Xo)}function f0(){if(Zr!==null){var n0=st.unstable_now();Kr=n0;var m0=!0;try{m0=Zr(!0,n0)}finally{m0?x0():(qr=!1,Zr=null)}}else qr=!1}var x0;if(typeof In=="function")x0=function(){In(f0)};else if(typeof MessageChannel<"u"){var l0=new MessageChannel,T0=l0.port2;l0.port1.onmessage=f0,x0=function(){T0.postMessage(null)}}else x0=function(){Sn(f0,0)};function t0(n0){Zr=n0,qr||(qr=!0,x0())}function E0(n0,m0){Bo=Sn(function(){n0(st.unstable_now())},m0)}st.unstable_IdlePriority=5,st.unstable_ImmediatePriority=1,st.unstable_LowPriority=4,st.unstable_NormalPriority=3,st.unstable_Profiling=null,st.unstable_UserBlockingPriority=2,st.unstable_cancelCallback=function(n0){n0.callback=null},st.unstable_continueExecution=function(){Kt||qt||(Kt=!0,t0(Hr))},st.unstable_forceFrameRate=function(n0){0>n0||125<n0?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):Xo=0<n0?Math.floor(1e3/n0):5},st.unstable_getCurrentPriorityLevel=function(){return jt},st.unstable_getFirstCallbackNode=function(){return pt(Ft)},st.unstable_next=function(n0){switch(jt){case 1:case 2:case 3:var m0=3;break;default:m0=jt}var h0=jt;jt=m0;try{return n0()}finally{jt=h0}},st.unstable_pauseExecution=function(){},st.unstable_requestPaint=function(){},st.unstable_runWithPriority=function(n0,m0){switch(n0){case 1:case 2:case 3:case 4:case 5:break;default:n0=3}var h0=jt;jt=n0;try{return m0()}finally{jt=h0}},st.unstable_scheduleCallback=function(n0,m0,h0){var a0=st.unstable_now();switch(typeof h0=="object"&&h0!==null?(h0=h0.delay,h0=typeof h0=="number"&&0<h0?a0+h0:a0):h0=a0,n0){case 1:var P0=-1;break;case 2:P0=250;break;case 5:P0=1073741823;break;case 4:P0=1e4;break;default:P0=5e3}return P0=h0+P0,n0={id:Ht++,callback:m0,priorityLevel:n0,startTime:h0,expirationTime:P0,sortIndex:-1},h0>a0?(n0.sortIndex=h0,at(Ct,n0),pt(Ft)===null&&n0===pt(Ct)&&(An?(wn(Bo),Bo=-1):An=!0,E0(rr,h0-a0))):(n0.sortIndex=P0,at(Ft,n0),Kt||qt||(Kt=!0,t0(Hr))),n0},st.unstable_shouldYield=ko,st.unstable_wrapCallback=function(n0){var m0=jt;return function(){var h0=jt;jt=m0;try{return n0.apply(this,arguments)}finally{jt=h0}}}})(scheduler_production_min$1);scheduler$1.exports=scheduler_production_min$1;var schedulerExports$1=scheduler$1.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var aa$2=reactExports,ca$2=schedulerExports$1;function p$3(st){for(var at="https://reactjs.org/docs/error-decoder.html?invariant="+st,pt=1;pt<arguments.length;pt++)at+="&args[]="+encodeURIComponent(arguments[pt]);return"Minified React error #"+st+"; visit "+at+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da$2=new Set,ea$1={};function fa$2(st,at){ha$1(st,at),ha$1(st+"Capture",at)}function ha$1(st,at){for(ea$1[st]=at,st=0;st<at.length;st++)da$2.add(at[st])}var ia$2=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),ja$2=Object.prototype.hasOwnProperty,ka$1=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la$2={},ma$1={};function oa$2(st){return ja$2.call(ma$1,st)?!0:ja$2.call(la$2,st)?!1:ka$1.test(st)?ma$1[st]=!0:(la$2[st]=!0,!1)}function pa$2(st,at,pt,vt){if(pt!==null&&pt.type===0)return!1;switch(typeof at){case"function":case"symbol":return!0;case"boolean":return vt?!1:pt!==null?!pt.acceptsBooleans:(st=st.toLowerCase().slice(0,5),st!=="data-"&&st!=="aria-");default:return!1}}function qa$2(st,at,pt,vt){if(at===null||typeof at>"u"||pa$2(st,at,pt,vt))return!0;if(vt)return!1;if(pt!==null)switch(pt.type){case 3:return!at;case 4:return at===!1;case 5:return isNaN(at);case 6:return isNaN(at)||1>at}return!1}function v$3(st,at,pt,vt,wt,$t,Tt){this.acceptsBooleans=at===2||at===3||at===4,this.attributeName=vt,this.attributeNamespace=wt,this.mustUseProperty=pt,this.propertyName=st,this.type=at,this.sanitizeURL=$t,this.removeEmptyString=Tt}var z$2={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(st){z$2[st]=new v$3(st,0,!1,st,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(st){var at=st[0];z$2[at]=new v$3(at,1,!1,st[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(st){z$2[st]=new v$3(st,2,!1,st.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(st){z$2[st]=new v$3(st,2,!1,st,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(st){z$2[st]=new v$3(st,3,!1,st.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(st){z$2[st]=new v$3(st,3,!0,st,null,!1,!1)});["capture","download"].forEach(function(st){z$2[st]=new v$3(st,4,!1,st,null,!1,!1)});["cols","rows","size","span"].forEach(function(st){z$2[st]=new v$3(st,6,!1,st,null,!1,!1)});["rowSpan","start"].forEach(function(st){z$2[st]=new v$3(st,5,!1,st.toLowerCase(),null,!1,!1)});var ra$1=/[\-:]([a-z])/g;function sa$2(st){return st[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(st){var at=st.replace(ra$1,sa$2);z$2[at]=new v$3(at,1,!1,st,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(st){var at=st.replace(ra$1,sa$2);z$2[at]=new v$3(at,1,!1,st,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(st){var at=st.replace(ra$1,sa$2);z$2[at]=new v$3(at,1,!1,st,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(st){z$2[st]=new v$3(st,1,!1,st.toLowerCase(),null,!1,!1)});z$2.xlinkHref=new v$3("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(st){z$2[st]=new v$3(st,1,!1,st.toLowerCase(),null,!0,!0)});function ta$1(st,at,pt,vt){var wt=z$2.hasOwnProperty(at)?z$2[at]:null;(wt!==null?wt.type!==0:vt||!(2<at.length)||at[0]!=="o"&&at[0]!=="O"||at[1]!=="n"&&at[1]!=="N")&&(qa$2(at,pt,wt,vt)&&(pt=null),vt||wt===null?oa$2(at)&&(pt===null?st.removeAttribute(at):st.setAttribute(at,""+pt)):wt.mustUseProperty?st[wt.propertyName]=pt===null?wt.type===3?!1:"":pt:(at=wt.attributeName,vt=wt.attributeNamespace,pt===null?st.removeAttribute(at):(wt=wt.type,pt=wt===3||wt===4&&pt===!0?"":""+pt,vt?st.setAttributeNS(vt,at,pt):st.setAttribute(at,pt))))}var ua$2=aa$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va$1=Symbol.for("react.element"),wa$1=Symbol.for("react.portal"),ya$1=Symbol.for("react.fragment"),za$1=Symbol.for("react.strict_mode"),Aa$1=Symbol.for("react.profiler"),Ba$1=Symbol.for("react.provider"),Ca$1=Symbol.for("react.context"),Da$1=Symbol.for("react.forward_ref"),Ea$1=Symbol.for("react.suspense"),Fa$1=Symbol.for("react.suspense_list"),Ga$1=Symbol.for("react.memo"),Ha$2=Symbol.for("react.lazy"),Ia$1=Symbol.for("react.offscreen"),Ja$2=Symbol.iterator;function Ka$2(st){return st===null||typeof st!="object"?null:(st=Ja$2&&st[Ja$2]||st["@@iterator"],typeof st=="function"?st:null)}var A$1=Object.assign,La$1;function Ma$1(st){if(La$1===void 0)try{throw Error()}catch(pt){var at=pt.stack.trim().match(/\n( *(at )?)/);La$1=at&&at[1]||""}return`
`+La$1+st}var Na=!1;function Oa$1(st,at){if(!st||Na)return"";Na=!0;var pt=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(at)if(at=function(){throw Error()},Object.defineProperty(at.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(at,[])}catch(Ct){var vt=Ct}Reflect.construct(st,[],at)}else{try{at.call()}catch(Ct){vt=Ct}st.call(at.prototype)}else{try{throw Error()}catch(Ct){vt=Ct}st()}}catch(Ct){if(Ct&&vt&&typeof Ct.stack=="string"){for(var wt=Ct.stack.split(`
`),$t=vt.stack.split(`
`),Tt=wt.length-1,Lt=$t.length-1;1<=Tt&&0<=Lt&&wt[Tt]!==$t[Lt];)Lt--;for(;1<=Tt&&0<=Lt;Tt--,Lt--)if(wt[Tt]!==$t[Lt]){if(Tt!==1||Lt!==1)do if(Tt--,Lt--,0>Lt||wt[Tt]!==$t[Lt]){var Ft=`
`+wt[Tt].replace(" at new "," at ");return st.displayName&&Ft.includes("<anonymous>")&&(Ft=Ft.replace("<anonymous>",st.displayName)),Ft}while(1<=Tt&&0<=Lt);break}}}finally{Na=!1,Error.prepareStackTrace=pt}return(st=st?st.displayName||st.name:"")?Ma$1(st):""}function Pa(st){switch(st.tag){case 5:return Ma$1(st.type);case 16:return Ma$1("Lazy");case 13:return Ma$1("Suspense");case 19:return Ma$1("SuspenseList");case 0:case 2:case 15:return st=Oa$1(st.type,!1),st;case 11:return st=Oa$1(st.type.render,!1),st;case 1:return st=Oa$1(st.type,!0),st;default:return""}}function Qa$2(st){if(st==null)return null;if(typeof st=="function")return st.displayName||st.name||null;if(typeof st=="string")return st;switch(st){case ya$1:return"Fragment";case wa$1:return"Portal";case Aa$1:return"Profiler";case za$1:return"StrictMode";case Ea$1:return"Suspense";case Fa$1:return"SuspenseList"}if(typeof st=="object")switch(st.$$typeof){case Ca$1:return(st.displayName||"Context")+".Consumer";case Ba$1:return(st._context.displayName||"Context")+".Provider";case Da$1:var at=st.render;return st=st.displayName,st||(st=at.displayName||at.name||"",st=st!==""?"ForwardRef("+st+")":"ForwardRef"),st;case Ga$1:return at=st.displayName||null,at!==null?at:Qa$2(st.type)||"Memo";case Ha$2:at=st._payload,st=st._init;try{return Qa$2(st(at))}catch{}}return null}function Ra(st){var at=st.type;switch(st.tag){case 24:return"Cache";case 9:return(at.displayName||"Context")+".Consumer";case 10:return(at._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return st=at.render,st=st.displayName||st.name||"",at.displayName||(st!==""?"ForwardRef("+st+")":"ForwardRef");case 7:return"Fragment";case 5:return at;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Qa$2(at);case 8:return at===za$1?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof at=="function")return at.displayName||at.name||null;if(typeof at=="string")return at}return null}function Sa$1(st){switch(typeof st){case"boolean":case"number":case"string":case"undefined":return st;case"object":return st;default:return""}}function Ta$1(st){var at=st.type;return(st=st.nodeName)&&st.toLowerCase()==="input"&&(at==="checkbox"||at==="radio")}function Ua$1(st){var at=Ta$1(st)?"checked":"value",pt=Object.getOwnPropertyDescriptor(st.constructor.prototype,at),vt=""+st[at];if(!st.hasOwnProperty(at)&&typeof pt<"u"&&typeof pt.get=="function"&&typeof pt.set=="function"){var wt=pt.get,$t=pt.set;return Object.defineProperty(st,at,{configurable:!0,get:function(){return wt.call(this)},set:function(Tt){vt=""+Tt,$t.call(this,Tt)}}),Object.defineProperty(st,at,{enumerable:pt.enumerable}),{getValue:function(){return vt},setValue:function(Tt){vt=""+Tt},stopTracking:function(){st._valueTracker=null,delete st[at]}}}}function Va$2(st){st._valueTracker||(st._valueTracker=Ua$1(st))}function Wa$1(st){if(!st)return!1;var at=st._valueTracker;if(!at)return!0;var pt=at.getValue(),vt="";return st&&(vt=Ta$1(st)?st.checked?"true":"false":st.value),st=vt,st!==pt?(at.setValue(st),!0):!1}function Xa$2(st){if(st=st||(typeof document<"u"?document:void 0),typeof st>"u")return null;try{return st.activeElement||st.body}catch{return st.body}}function Ya$2(st,at){var pt=at.checked;return A$1({},at,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:pt??st._wrapperState.initialChecked})}function Za$2(st,at){var pt=at.defaultValue==null?"":at.defaultValue,vt=at.checked!=null?at.checked:at.defaultChecked;pt=Sa$1(at.value!=null?at.value:pt),st._wrapperState={initialChecked:vt,initialValue:pt,controlled:at.type==="checkbox"||at.type==="radio"?at.checked!=null:at.value!=null}}function ab$1(st,at){at=at.checked,at!=null&&ta$1(st,"checked",at,!1)}function bb$1(st,at){ab$1(st,at);var pt=Sa$1(at.value),vt=at.type;if(pt!=null)vt==="number"?(pt===0&&st.value===""||st.value!=pt)&&(st.value=""+pt):st.value!==""+pt&&(st.value=""+pt);else if(vt==="submit"||vt==="reset"){st.removeAttribute("value");return}at.hasOwnProperty("value")?cb$1(st,at.type,pt):at.hasOwnProperty("defaultValue")&&cb$1(st,at.type,Sa$1(at.defaultValue)),at.checked==null&&at.defaultChecked!=null&&(st.defaultChecked=!!at.defaultChecked)}function db$1(st,at,pt){if(at.hasOwnProperty("value")||at.hasOwnProperty("defaultValue")){var vt=at.type;if(!(vt!=="submit"&&vt!=="reset"||at.value!==void 0&&at.value!==null))return;at=""+st._wrapperState.initialValue,pt||at===st.value||(st.value=at),st.defaultValue=at}pt=st.name,pt!==""&&(st.name=""),st.defaultChecked=!!st._wrapperState.initialChecked,pt!==""&&(st.name=pt)}function cb$1(st,at,pt){(at!=="number"||Xa$2(st.ownerDocument)!==st)&&(pt==null?st.defaultValue=""+st._wrapperState.initialValue:st.defaultValue!==""+pt&&(st.defaultValue=""+pt))}var eb$1=Array.isArray;function fb$1(st,at,pt,vt){if(st=st.options,at){at={};for(var wt=0;wt<pt.length;wt++)at["$"+pt[wt]]=!0;for(pt=0;pt<st.length;pt++)wt=at.hasOwnProperty("$"+st[pt].value),st[pt].selected!==wt&&(st[pt].selected=wt),wt&&vt&&(st[pt].defaultSelected=!0)}else{for(pt=""+Sa$1(pt),at=null,wt=0;wt<st.length;wt++){if(st[wt].value===pt){st[wt].selected=!0,vt&&(st[wt].defaultSelected=!0);return}at!==null||st[wt].disabled||(at=st[wt])}at!==null&&(at.selected=!0)}}function gb$1(st,at){if(at.dangerouslySetInnerHTML!=null)throw Error(p$3(91));return A$1({},at,{value:void 0,defaultValue:void 0,children:""+st._wrapperState.initialValue})}function hb$1(st,at){var pt=at.value;if(pt==null){if(pt=at.children,at=at.defaultValue,pt!=null){if(at!=null)throw Error(p$3(92));if(eb$1(pt)){if(1<pt.length)throw Error(p$3(93));pt=pt[0]}at=pt}at==null&&(at=""),pt=at}st._wrapperState={initialValue:Sa$1(pt)}}function ib$1(st,at){var pt=Sa$1(at.value),vt=Sa$1(at.defaultValue);pt!=null&&(pt=""+pt,pt!==st.value&&(st.value=pt),at.defaultValue==null&&st.defaultValue!==pt&&(st.defaultValue=pt)),vt!=null&&(st.defaultValue=""+vt)}function jb$1(st){var at=st.textContent;at===st._wrapperState.initialValue&&at!==""&&at!==null&&(st.value=at)}function kb$1(st){switch(st){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function lb$1(st,at){return st==null||st==="http://www.w3.org/1999/xhtml"?kb$1(at):st==="http://www.w3.org/2000/svg"&&at==="foreignObject"?"http://www.w3.org/1999/xhtml":st}var mb$1,nb$1=function(st){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(at,pt,vt,wt){MSApp.execUnsafeLocalFunction(function(){return st(at,pt,vt,wt)})}:st}(function(st,at){if(st.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in st)st.innerHTML=at;else{for(mb$1=mb$1||document.createElement("div"),mb$1.innerHTML="<svg>"+at.valueOf().toString()+"</svg>",at=mb$1.firstChild;st.firstChild;)st.removeChild(st.firstChild);for(;at.firstChild;)st.appendChild(at.firstChild)}});function ob$1(st,at){if(at){var pt=st.firstChild;if(pt&&pt===st.lastChild&&pt.nodeType===3){pt.nodeValue=at;return}}st.textContent=at}var pb$1={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb$1=["Webkit","ms","Moz","O"];Object.keys(pb$1).forEach(function(st){qb$1.forEach(function(at){at=at+st.charAt(0).toUpperCase()+st.substring(1),pb$1[at]=pb$1[st]})});function rb$1(st,at,pt){return at==null||typeof at=="boolean"||at===""?"":pt||typeof at!="number"||at===0||pb$1.hasOwnProperty(st)&&pb$1[st]?(""+at).trim():at+"px"}function sb$1(st,at){st=st.style;for(var pt in at)if(at.hasOwnProperty(pt)){var vt=pt.indexOf("--")===0,wt=rb$1(pt,at[pt],vt);pt==="float"&&(pt="cssFloat"),vt?st.setProperty(pt,wt):st[pt]=wt}}var tb$1=A$1({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ub$1(st,at){if(at){if(tb$1[st]&&(at.children!=null||at.dangerouslySetInnerHTML!=null))throw Error(p$3(137,st));if(at.dangerouslySetInnerHTML!=null){if(at.children!=null)throw Error(p$3(60));if(typeof at.dangerouslySetInnerHTML!="object"||!("__html"in at.dangerouslySetInnerHTML))throw Error(p$3(61))}if(at.style!=null&&typeof at.style!="object")throw Error(p$3(62))}}function vb$1(st,at){if(st.indexOf("-")===-1)return typeof at.is=="string";switch(st){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var wb$1=null;function xb$1(st){return st=st.target||st.srcElement||window,st.correspondingUseElement&&(st=st.correspondingUseElement),st.nodeType===3?st.parentNode:st}var yb$1=null,zb$1=null,Ab$1=null;function Bb$1(st){if(st=Cb$1(st)){if(typeof yb$1!="function")throw Error(p$3(280));var at=st.stateNode;at&&(at=Db$1(at),yb$1(st.stateNode,st.type,at))}}function Eb$1(st){zb$1?Ab$1?Ab$1.push(st):Ab$1=[st]:zb$1=st}function Fb$1(){if(zb$1){var st=zb$1,at=Ab$1;if(Ab$1=zb$1=null,Bb$1(st),at)for(st=0;st<at.length;st++)Bb$1(at[st])}}function Gb$1(st,at){return st(at)}function Hb(){}var Ib$1=!1;function Jb$1(st,at,pt){if(Ib$1)return st(at,pt);Ib$1=!0;try{return Gb$1(st,at,pt)}finally{Ib$1=!1,(zb$1!==null||Ab$1!==null)&&(Hb(),Fb$1())}}function Kb$1(st,at){var pt=st.stateNode;if(pt===null)return null;var vt=Db$1(pt);if(vt===null)return null;pt=vt[at];e:switch(at){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(vt=!vt.disabled)||(st=st.type,vt=!(st==="button"||st==="input"||st==="select"||st==="textarea")),st=!vt;break e;default:st=!1}if(st)return null;if(pt&&typeof pt!="function")throw Error(p$3(231,at,typeof pt));return pt}var Lb$1=!1;if(ia$2)try{var Mb$1={};Object.defineProperty(Mb$1,"passive",{get:function(){Lb$1=!0}}),window.addEventListener("test",Mb$1,Mb$1),window.removeEventListener("test",Mb$1,Mb$1)}catch{Lb$1=!1}function Nb$1(st,at,pt,vt,wt,$t,Tt,Lt,Ft){var Ct=Array.prototype.slice.call(arguments,3);try{at.apply(pt,Ct)}catch(Ht){this.onError(Ht)}}var Ob$1=!1,Pb$1=null,Qb$1=!1,Rb$1=null,Sb$1={onError:function(st){Ob$1=!0,Pb$1=st}};function Tb$1(st,at,pt,vt,wt,$t,Tt,Lt,Ft){Ob$1=!1,Pb$1=null,Nb$1.apply(Sb$1,arguments)}function Ub$1(st,at,pt,vt,wt,$t,Tt,Lt,Ft){if(Tb$1.apply(this,arguments),Ob$1){if(Ob$1){var Ct=Pb$1;Ob$1=!1,Pb$1=null}else throw Error(p$3(198));Qb$1||(Qb$1=!0,Rb$1=Ct)}}function Vb$1(st){var at=st,pt=st;if(st.alternate)for(;at.return;)at=at.return;else{st=at;do at=st,at.flags&4098&&(pt=at.return),st=at.return;while(st)}return at.tag===3?pt:null}function Wb(st){if(st.tag===13){var at=st.memoizedState;if(at===null&&(st=st.alternate,st!==null&&(at=st.memoizedState)),at!==null)return at.dehydrated}return null}function Xb$1(st){if(Vb$1(st)!==st)throw Error(p$3(188))}function Yb$1(st){var at=st.alternate;if(!at){if(at=Vb$1(st),at===null)throw Error(p$3(188));return at!==st?null:st}for(var pt=st,vt=at;;){var wt=pt.return;if(wt===null)break;var $t=wt.alternate;if($t===null){if(vt=wt.return,vt!==null){pt=vt;continue}break}if(wt.child===$t.child){for($t=wt.child;$t;){if($t===pt)return Xb$1(wt),st;if($t===vt)return Xb$1(wt),at;$t=$t.sibling}throw Error(p$3(188))}if(pt.return!==vt.return)pt=wt,vt=$t;else{for(var Tt=!1,Lt=wt.child;Lt;){if(Lt===pt){Tt=!0,pt=wt,vt=$t;break}if(Lt===vt){Tt=!0,vt=wt,pt=$t;break}Lt=Lt.sibling}if(!Tt){for(Lt=$t.child;Lt;){if(Lt===pt){Tt=!0,pt=$t,vt=wt;break}if(Lt===vt){Tt=!0,vt=$t,pt=wt;break}Lt=Lt.sibling}if(!Tt)throw Error(p$3(189))}}if(pt.alternate!==vt)throw Error(p$3(190))}if(pt.tag!==3)throw Error(p$3(188));return pt.stateNode.current===pt?st:at}function Zb$1(st){return st=Yb$1(st),st!==null?$b$1(st):null}function $b$1(st){if(st.tag===5||st.tag===6)return st;for(st=st.child;st!==null;){var at=$b$1(st);if(at!==null)return at;st=st.sibling}return null}var ac$2=ca$2.unstable_scheduleCallback,bc$2=ca$2.unstable_cancelCallback,cc$2=ca$2.unstable_shouldYield,dc$2=ca$2.unstable_requestPaint,B$2=ca$2.unstable_now,ec$1=ca$2.unstable_getCurrentPriorityLevel,fc$2=ca$2.unstable_ImmediatePriority,gc$2=ca$2.unstable_UserBlockingPriority,hc$1=ca$2.unstable_NormalPriority,ic$2=ca$2.unstable_LowPriority,jc$2=ca$2.unstable_IdlePriority,kc$2=null,lc$2=null;function mc$2(st){if(lc$2&&typeof lc$2.onCommitFiberRoot=="function")try{lc$2.onCommitFiberRoot(kc$2,st,void 0,(st.current.flags&128)===128)}catch{}}var oc$2=Math.clz32?Math.clz32:nc$2,pc$2=Math.log,qc$2=Math.LN2;function nc$2(st){return st>>>=0,st===0?32:31-(pc$2(st)/qc$2|0)|0}var rc$1=64,sc$2=4194304;function tc$1(st){switch(st&-st){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return st&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return st&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return st}}function uc$2(st,at){var pt=st.pendingLanes;if(pt===0)return 0;var vt=0,wt=st.suspendedLanes,$t=st.pingedLanes,Tt=pt&268435455;if(Tt!==0){var Lt=Tt&~wt;Lt!==0?vt=tc$1(Lt):($t&=Tt,$t!==0&&(vt=tc$1($t)))}else Tt=pt&~wt,Tt!==0?vt=tc$1(Tt):$t!==0&&(vt=tc$1($t));if(vt===0)return 0;if(at!==0&&at!==vt&&!(at&wt)&&(wt=vt&-vt,$t=at&-at,wt>=$t||wt===16&&($t&4194240)!==0))return at;if(vt&4&&(vt|=pt&16),at=st.entangledLanes,at!==0)for(st=st.entanglements,at&=vt;0<at;)pt=31-oc$2(at),wt=1<<pt,vt|=st[pt],at&=~wt;return vt}function vc$2(st,at){switch(st){case 1:case 2:case 4:return at+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return at+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function wc$2(st,at){for(var pt=st.suspendedLanes,vt=st.pingedLanes,wt=st.expirationTimes,$t=st.pendingLanes;0<$t;){var Tt=31-oc$2($t),Lt=1<<Tt,Ft=wt[Tt];Ft===-1?(!(Lt&pt)||Lt&vt)&&(wt[Tt]=vc$2(Lt,at)):Ft<=at&&(st.expiredLanes|=Lt),$t&=~Lt}}function xc$2(st){return st=st.pendingLanes&-1073741825,st!==0?st:st&1073741824?1073741824:0}function yc$2(){var st=rc$1;return rc$1<<=1,!(rc$1&4194240)&&(rc$1=64),st}function zc$2(st){for(var at=[],pt=0;31>pt;pt++)at.push(st);return at}function Ac$2(st,at,pt){st.pendingLanes|=at,at!==536870912&&(st.suspendedLanes=0,st.pingedLanes=0),st=st.eventTimes,at=31-oc$2(at),st[at]=pt}function Bc$2(st,at){var pt=st.pendingLanes&~at;st.pendingLanes=at,st.suspendedLanes=0,st.pingedLanes=0,st.expiredLanes&=at,st.mutableReadLanes&=at,st.entangledLanes&=at,at=st.entanglements;var vt=st.eventTimes;for(st=st.expirationTimes;0<pt;){var wt=31-oc$2(pt),$t=1<<wt;at[wt]=0,vt[wt]=-1,st[wt]=-1,pt&=~$t}}function Cc$2(st,at){var pt=st.entangledLanes|=at;for(st=st.entanglements;pt;){var vt=31-oc$2(pt),wt=1<<vt;wt&at|st[vt]&at&&(st[vt]|=at),pt&=~wt}}var C$1=0;function Dc$2(st){return st&=-st,1<st?4<st?st&268435455?16:536870912:4:1}var Ec$2,Fc$2,Gc$2,Hc$2,Ic$2,Jc$2=!1,Kc$2=[],Lc$2=null,Mc$2=null,Nc$2=null,Oc$2=new Map,Pc$2=new Map,Qc$2=[],Rc$2="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Sc$2(st,at){switch(st){case"focusin":case"focusout":Lc$2=null;break;case"dragenter":case"dragleave":Mc$2=null;break;case"mouseover":case"mouseout":Nc$2=null;break;case"pointerover":case"pointerout":Oc$2.delete(at.pointerId);break;case"gotpointercapture":case"lostpointercapture":Pc$2.delete(at.pointerId)}}function Tc$2(st,at,pt,vt,wt,$t){return st===null||st.nativeEvent!==$t?(st={blockedOn:at,domEventName:pt,eventSystemFlags:vt,nativeEvent:$t,targetContainers:[wt]},at!==null&&(at=Cb$1(at),at!==null&&Fc$2(at)),st):(st.eventSystemFlags|=vt,at=st.targetContainers,wt!==null&&at.indexOf(wt)===-1&&at.push(wt),st)}function Uc$2(st,at,pt,vt,wt){switch(at){case"focusin":return Lc$2=Tc$2(Lc$2,st,at,pt,vt,wt),!0;case"dragenter":return Mc$2=Tc$2(Mc$2,st,at,pt,vt,wt),!0;case"mouseover":return Nc$2=Tc$2(Nc$2,st,at,pt,vt,wt),!0;case"pointerover":var $t=wt.pointerId;return Oc$2.set($t,Tc$2(Oc$2.get($t)||null,st,at,pt,vt,wt)),!0;case"gotpointercapture":return $t=wt.pointerId,Pc$2.set($t,Tc$2(Pc$2.get($t)||null,st,at,pt,vt,wt)),!0}return!1}function Vc$2(st){var at=Wc$2(st.target);if(at!==null){var pt=Vb$1(at);if(pt!==null){if(at=pt.tag,at===13){if(at=Wb(pt),at!==null){st.blockedOn=at,Ic$2(st.priority,function(){Gc$2(pt)});return}}else if(at===3&&pt.stateNode.current.memoizedState.isDehydrated){st.blockedOn=pt.tag===3?pt.stateNode.containerInfo:null;return}}}st.blockedOn=null}function Xc$2(st){if(st.blockedOn!==null)return!1;for(var at=st.targetContainers;0<at.length;){var pt=Yc$2(st.domEventName,st.eventSystemFlags,at[0],st.nativeEvent);if(pt===null){pt=st.nativeEvent;var vt=new pt.constructor(pt.type,pt);wb$1=vt,pt.target.dispatchEvent(vt),wb$1=null}else return at=Cb$1(pt),at!==null&&Fc$2(at),st.blockedOn=pt,!1;at.shift()}return!0}function Zc$2(st,at,pt){Xc$2(st)&&pt.delete(at)}function $c$2(){Jc$2=!1,Lc$2!==null&&Xc$2(Lc$2)&&(Lc$2=null),Mc$2!==null&&Xc$2(Mc$2)&&(Mc$2=null),Nc$2!==null&&Xc$2(Nc$2)&&(Nc$2=null),Oc$2.forEach(Zc$2),Pc$2.forEach(Zc$2)}function ad$2(st,at){st.blockedOn===at&&(st.blockedOn=null,Jc$2||(Jc$2=!0,ca$2.unstable_scheduleCallback(ca$2.unstable_NormalPriority,$c$2)))}function bd$1(st){function at(wt){return ad$2(wt,st)}if(0<Kc$2.length){ad$2(Kc$2[0],st);for(var pt=1;pt<Kc$2.length;pt++){var vt=Kc$2[pt];vt.blockedOn===st&&(vt.blockedOn=null)}}for(Lc$2!==null&&ad$2(Lc$2,st),Mc$2!==null&&ad$2(Mc$2,st),Nc$2!==null&&ad$2(Nc$2,st),Oc$2.forEach(at),Pc$2.forEach(at),pt=0;pt<Qc$2.length;pt++)vt=Qc$2[pt],vt.blockedOn===st&&(vt.blockedOn=null);for(;0<Qc$2.length&&(pt=Qc$2[0],pt.blockedOn===null);)Vc$2(pt),pt.blockedOn===null&&Qc$2.shift()}var cd$2=ua$2.ReactCurrentBatchConfig,dd$2=!0;function ed$2(st,at,pt,vt){var wt=C$1,$t=cd$2.transition;cd$2.transition=null;try{C$1=1,fd$3(st,at,pt,vt)}finally{C$1=wt,cd$2.transition=$t}}function gd$1(st,at,pt,vt){var wt=C$1,$t=cd$2.transition;cd$2.transition=null;try{C$1=4,fd$3(st,at,pt,vt)}finally{C$1=wt,cd$2.transition=$t}}function fd$3(st,at,pt,vt){if(dd$2){var wt=Yc$2(st,at,pt,vt);if(wt===null)hd$2(st,at,vt,id$2,pt),Sc$2(st,vt);else if(Uc$2(wt,st,at,pt,vt))vt.stopPropagation();else if(Sc$2(st,vt),at&4&&-1<Rc$2.indexOf(st)){for(;wt!==null;){var $t=Cb$1(wt);if($t!==null&&Ec$2($t),$t=Yc$2(st,at,pt,vt),$t===null&&hd$2(st,at,vt,id$2,pt),$t===wt)break;wt=$t}wt!==null&&vt.stopPropagation()}else hd$2(st,at,vt,null,pt)}}var id$2=null;function Yc$2(st,at,pt,vt){if(id$2=null,st=xb$1(vt),st=Wc$2(st),st!==null)if(at=Vb$1(st),at===null)st=null;else if(pt=at.tag,pt===13){if(st=Wb(at),st!==null)return st;st=null}else if(pt===3){if(at.stateNode.current.memoizedState.isDehydrated)return at.tag===3?at.stateNode.containerInfo:null;st=null}else at!==st&&(st=null);return id$2=st,null}function jd$2(st){switch(st){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(ec$1()){case fc$2:return 1;case gc$2:return 4;case hc$1:case ic$2:return 16;case jc$2:return 536870912;default:return 16}default:return 16}}var kd$2=null,ld$2=null,md$2=null;function nd$2(){if(md$2)return md$2;var st,at=ld$2,pt=at.length,vt,wt="value"in kd$2?kd$2.value:kd$2.textContent,$t=wt.length;for(st=0;st<pt&&at[st]===wt[st];st++);var Tt=pt-st;for(vt=1;vt<=Tt&&at[pt-vt]===wt[$t-vt];vt++);return md$2=wt.slice(st,1<vt?1-vt:void 0)}function od$2(st){var at=st.keyCode;return"charCode"in st?(st=st.charCode,st===0&&at===13&&(st=13)):st=at,st===10&&(st=13),32<=st||st===13?st:0}function pd$2(){return!0}function qd$2(){return!1}function rd$2(st){function at(pt,vt,wt,$t,Tt){this._reactName=pt,this._targetInst=wt,this.type=vt,this.nativeEvent=$t,this.target=Tt,this.currentTarget=null;for(var Lt in st)st.hasOwnProperty(Lt)&&(pt=st[Lt],this[Lt]=pt?pt($t):$t[Lt]);return this.isDefaultPrevented=($t.defaultPrevented!=null?$t.defaultPrevented:$t.returnValue===!1)?pd$2:qd$2,this.isPropagationStopped=qd$2,this}return A$1(at.prototype,{preventDefault:function(){this.defaultPrevented=!0;var pt=this.nativeEvent;pt&&(pt.preventDefault?pt.preventDefault():typeof pt.returnValue!="unknown"&&(pt.returnValue=!1),this.isDefaultPrevented=pd$2)},stopPropagation:function(){var pt=this.nativeEvent;pt&&(pt.stopPropagation?pt.stopPropagation():typeof pt.cancelBubble!="unknown"&&(pt.cancelBubble=!0),this.isPropagationStopped=pd$2)},persist:function(){},isPersistent:pd$2}),at}var sd$2={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(st){return st.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td$3=rd$2(sd$2),ud$2=A$1({},sd$2,{view:0,detail:0}),vd$2=rd$2(ud$2),wd$1,xd$1,yd$1,Ad$2=A$1({},ud$2,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd$1,button:0,buttons:0,relatedTarget:function(st){return st.relatedTarget===void 0?st.fromElement===st.srcElement?st.toElement:st.fromElement:st.relatedTarget},movementX:function(st){return"movementX"in st?st.movementX:(st!==yd$1&&(yd$1&&st.type==="mousemove"?(wd$1=st.screenX-yd$1.screenX,xd$1=st.screenY-yd$1.screenY):xd$1=wd$1=0,yd$1=st),wd$1)},movementY:function(st){return"movementY"in st?st.movementY:xd$1}}),Bd$1=rd$2(Ad$2),Cd$2=A$1({},Ad$2,{dataTransfer:0}),Dd$2=rd$2(Cd$2),Ed$2=A$1({},ud$2,{relatedTarget:0}),Fd$2=rd$2(Ed$2),Gd$1=A$1({},sd$2,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd$2=rd$2(Gd$1),Id$2=A$1({},sd$2,{clipboardData:function(st){return"clipboardData"in st?st.clipboardData:window.clipboardData}}),Jd$1=rd$2(Id$2),Kd$2=A$1({},sd$2,{data:0}),Ld$2=rd$2(Kd$2),Md$1={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd$1={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od$2={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd$2(st){var at=this.nativeEvent;return at.getModifierState?at.getModifierState(st):(st=Od$2[st])?!!at[st]:!1}function zd$1(){return Pd$2}var Qd$1=A$1({},ud$2,{key:function(st){if(st.key){var at=Md$1[st.key]||st.key;if(at!=="Unidentified")return at}return st.type==="keypress"?(st=od$2(st),st===13?"Enter":String.fromCharCode(st)):st.type==="keydown"||st.type==="keyup"?Nd$1[st.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd$1,charCode:function(st){return st.type==="keypress"?od$2(st):0},keyCode:function(st){return st.type==="keydown"||st.type==="keyup"?st.keyCode:0},which:function(st){return st.type==="keypress"?od$2(st):st.type==="keydown"||st.type==="keyup"?st.keyCode:0}}),Rd$1=rd$2(Qd$1),Sd$2=A$1({},Ad$2,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td$1=rd$2(Sd$2),Ud$1=A$1({},ud$2,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd$1}),Vd$1=rd$2(Ud$1),Wd$1=A$1({},sd$2,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd$2=rd$2(Wd$1),Yd$2=A$1({},Ad$2,{deltaX:function(st){return"deltaX"in st?st.deltaX:"wheelDeltaX"in st?-st.wheelDeltaX:0},deltaY:function(st){return"deltaY"in st?st.deltaY:"wheelDeltaY"in st?-st.wheelDeltaY:"wheelDelta"in st?-st.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd$1=rd$2(Yd$2),$d$1=[9,13,27,32],ae$1=ia$2&&"CompositionEvent"in window,be$1=null;ia$2&&"documentMode"in document&&(be$1=document.documentMode);var ce$1=ia$2&&"TextEvent"in window&&!be$1,de=ia$2&&(!ae$1||be$1&&8<be$1&&11>=be$1),ee$1=" ",fe$2=!1;function ge(st,at){switch(st){case"keyup":return $d$1.indexOf(at.keyCode)!==-1;case"keydown":return at.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function he(st){return st=st.detail,typeof st=="object"&&"data"in st?st.data:null}var ie=!1;function je(st,at){switch(st){case"compositionend":return he(at);case"keypress":return at.which!==32?null:(fe$2=!0,ee$1);case"textInput":return st=at.data,st===ee$1&&fe$2?null:st;default:return null}}function ke$1(st,at){if(ie)return st==="compositionend"||!ae$1&&ge(st,at)?(st=nd$2(),md$2=ld$2=kd$2=null,ie=!1,st):null;switch(st){case"paste":return null;case"keypress":if(!(at.ctrlKey||at.altKey||at.metaKey)||at.ctrlKey&&at.altKey){if(at.char&&1<at.char.length)return at.char;if(at.which)return String.fromCharCode(at.which)}return null;case"compositionend":return de&&at.locale!=="ko"?null:at.data;default:return null}}var le$1={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me$1(st){var at=st&&st.nodeName&&st.nodeName.toLowerCase();return at==="input"?!!le$1[st.type]:at==="textarea"}function ne$1(st,at,pt,vt){Eb$1(vt),at=oe$1(at,"onChange"),0<at.length&&(pt=new td$3("onChange","change",null,pt,vt),st.push({event:pt,listeners:at}))}var pe=null,qe$1=null;function re$1(st){se(st,0)}function te(st){var at=ue(st);if(Wa$1(at))return st}function ve$1(st,at){if(st==="change")return at}var we$2=!1;if(ia$2){var xe$2;if(ia$2){var ye$2="oninput"in document;if(!ye$2){var ze=document.createElement("div");ze.setAttribute("oninput","return;"),ye$2=typeof ze.oninput=="function"}xe$2=ye$2}else xe$2=!1;we$2=xe$2&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be),qe$1=pe=null)}function Be(st){if(st.propertyName==="value"&&te(qe$1)){var at=[];ne$1(at,qe$1,st,xb$1(st)),Jb$1(re$1,at)}}function Ce$1(st,at,pt){st==="focusin"?(Ae(),pe=at,qe$1=pt,pe.attachEvent("onpropertychange",Be)):st==="focusout"&&Ae()}function De$2(st){if(st==="selectionchange"||st==="keyup"||st==="keydown")return te(qe$1)}function Ee$1(st,at){if(st==="click")return te(at)}function Fe$1(st,at){if(st==="input"||st==="change")return te(at)}function Ge(st,at){return st===at&&(st!==0||1/st===1/at)||st!==st&&at!==at}var He=typeof Object.is=="function"?Object.is:Ge;function Ie(st,at){if(He(st,at))return!0;if(typeof st!="object"||st===null||typeof at!="object"||at===null)return!1;var pt=Object.keys(st),vt=Object.keys(at);if(pt.length!==vt.length)return!1;for(vt=0;vt<pt.length;vt++){var wt=pt[vt];if(!ja$2.call(at,wt)||!He(st[wt],at[wt]))return!1}return!0}function Je$1(st){for(;st&&st.firstChild;)st=st.firstChild;return st}function Ke(st,at){var pt=Je$1(st);st=0;for(var vt;pt;){if(pt.nodeType===3){if(vt=st+pt.textContent.length,st<=at&&vt>=at)return{node:pt,offset:at-st};st=vt}e:{for(;pt;){if(pt.nextSibling){pt=pt.nextSibling;break e}pt=pt.parentNode}pt=void 0}pt=Je$1(pt)}}function Le(st,at){return st&&at?st===at?!0:st&&st.nodeType===3?!1:at&&at.nodeType===3?Le(st,at.parentNode):"contains"in st?st.contains(at):st.compareDocumentPosition?!!(st.compareDocumentPosition(at)&16):!1:!1}function Me$2(){for(var st=window,at=Xa$2();at instanceof st.HTMLIFrameElement;){try{var pt=typeof at.contentWindow.location.href=="string"}catch{pt=!1}if(pt)st=at.contentWindow;else break;at=Xa$2(st.document)}return at}function Ne$2(st){var at=st&&st.nodeName&&st.nodeName.toLowerCase();return at&&(at==="input"&&(st.type==="text"||st.type==="search"||st.type==="tel"||st.type==="url"||st.type==="password")||at==="textarea"||st.contentEditable==="true")}function Oe(st){var at=Me$2(),pt=st.focusedElem,vt=st.selectionRange;if(at!==pt&&pt&&pt.ownerDocument&&Le(pt.ownerDocument.documentElement,pt)){if(vt!==null&&Ne$2(pt)){if(at=vt.start,st=vt.end,st===void 0&&(st=at),"selectionStart"in pt)pt.selectionStart=at,pt.selectionEnd=Math.min(st,pt.value.length);else if(st=(at=pt.ownerDocument||document)&&at.defaultView||window,st.getSelection){st=st.getSelection();var wt=pt.textContent.length,$t=Math.min(vt.start,wt);vt=vt.end===void 0?$t:Math.min(vt.end,wt),!st.extend&&$t>vt&&(wt=vt,vt=$t,$t=wt),wt=Ke(pt,$t);var Tt=Ke(pt,vt);wt&&Tt&&(st.rangeCount!==1||st.anchorNode!==wt.node||st.anchorOffset!==wt.offset||st.focusNode!==Tt.node||st.focusOffset!==Tt.offset)&&(at=at.createRange(),at.setStart(wt.node,wt.offset),st.removeAllRanges(),$t>vt?(st.addRange(at),st.extend(Tt.node,Tt.offset)):(at.setEnd(Tt.node,Tt.offset),st.addRange(at)))}}for(at=[],st=pt;st=st.parentNode;)st.nodeType===1&&at.push({element:st,left:st.scrollLeft,top:st.scrollTop});for(typeof pt.focus=="function"&&pt.focus(),pt=0;pt<at.length;pt++)st=at[pt],st.element.scrollLeft=st.left,st.element.scrollTop=st.top}}var Pe$1=ia$2&&"documentMode"in document&&11>=document.documentMode,Qe$1=null,Re=null,Se=null,Te=!1;function Ue$2(st,at,pt){var vt=pt.window===pt?pt.document:pt.nodeType===9?pt:pt.ownerDocument;Te||Qe$1==null||Qe$1!==Xa$2(vt)||(vt=Qe$1,"selectionStart"in vt&&Ne$2(vt)?vt={start:vt.selectionStart,end:vt.selectionEnd}:(vt=(vt.ownerDocument&&vt.ownerDocument.defaultView||window).getSelection(),vt={anchorNode:vt.anchorNode,anchorOffset:vt.anchorOffset,focusNode:vt.focusNode,focusOffset:vt.focusOffset}),Se&&Ie(Se,vt)||(Se=vt,vt=oe$1(Re,"onSelect"),0<vt.length&&(at=new td$3("onSelect","select",null,at,pt),st.push({event:at,listeners:vt}),at.target=Qe$1)))}function Ve(st,at){var pt={};return pt[st.toLowerCase()]=at.toLowerCase(),pt["Webkit"+st]="webkit"+at,pt["Moz"+st]="moz"+at,pt}var We$2={animationend:Ve("Animation","AnimationEnd"),animationiteration:Ve("Animation","AnimationIteration"),animationstart:Ve("Animation","AnimationStart"),transitionend:Ve("Transition","TransitionEnd")},Xe$1={},Ye={};ia$2&&(Ye=document.createElement("div").style,"AnimationEvent"in window||(delete We$2.animationend.animation,delete We$2.animationiteration.animation,delete We$2.animationstart.animation),"TransitionEvent"in window||delete We$2.transitionend.transition);function Ze$2(st){if(Xe$1[st])return Xe$1[st];if(!We$2[st])return st;var at=We$2[st],pt;for(pt in at)if(at.hasOwnProperty(pt)&&pt in Ye)return Xe$1[st]=at[pt];return st}var $e$1=Ze$2("animationend"),af$2=Ze$2("animationiteration"),bf$1=Ze$2("animationstart"),cf$1=Ze$2("transitionend"),df$1=new Map,ef$2="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function ff$2(st,at){df$1.set(st,at),fa$2(at,[st])}for(var gf$1=0;gf$1<ef$2.length;gf$1++){var hf$2=ef$2[gf$1],jf$1=hf$2.toLowerCase(),kf$1=hf$2[0].toUpperCase()+hf$2.slice(1);ff$2(jf$1,"on"+kf$1)}ff$2($e$1,"onAnimationEnd");ff$2(af$2,"onAnimationIteration");ff$2(bf$1,"onAnimationStart");ff$2("dblclick","onDoubleClick");ff$2("focusin","onFocus");ff$2("focusout","onBlur");ff$2(cf$1,"onTransitionEnd");ha$1("onMouseEnter",["mouseout","mouseover"]);ha$1("onMouseLeave",["mouseout","mouseover"]);ha$1("onPointerEnter",["pointerout","pointerover"]);ha$1("onPointerLeave",["pointerout","pointerover"]);fa$2("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa$2("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa$2("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa$2("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa$2("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));fa$2("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf$2="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf$2=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf$2));function nf$2(st,at,pt){var vt=st.type||"unknown-event";st.currentTarget=pt,Ub$1(vt,at,void 0,st),st.currentTarget=null}function se(st,at){at=(at&4)!==0;for(var pt=0;pt<st.length;pt++){var vt=st[pt],wt=vt.event;vt=vt.listeners;e:{var $t=void 0;if(at)for(var Tt=vt.length-1;0<=Tt;Tt--){var Lt=vt[Tt],Ft=Lt.instance,Ct=Lt.currentTarget;if(Lt=Lt.listener,Ft!==$t&&wt.isPropagationStopped())break e;nf$2(wt,Lt,Ct),$t=Ft}else for(Tt=0;Tt<vt.length;Tt++){if(Lt=vt[Tt],Ft=Lt.instance,Ct=Lt.currentTarget,Lt=Lt.listener,Ft!==$t&&wt.isPropagationStopped())break e;nf$2(wt,Lt,Ct),$t=Ft}}}if(Qb$1)throw st=Rb$1,Qb$1=!1,Rb$1=null,st}function D$1(st,at){var pt=at[of$2];pt===void 0&&(pt=at[of$2]=new Set);var vt=st+"__bubble";pt.has(vt)||(pf$2(at,st,2,!1),pt.add(vt))}function qf$1(st,at,pt){var vt=0;at&&(vt|=4),pf$2(pt,st,vt,at)}var rf$2="_reactListening"+Math.random().toString(36).slice(2);function sf$2(st){if(!st[rf$2]){st[rf$2]=!0,da$2.forEach(function(pt){pt!=="selectionchange"&&(mf$2.has(pt)||qf$1(pt,!1,st),qf$1(pt,!0,st))});var at=st.nodeType===9?st:st.ownerDocument;at===null||at[rf$2]||(at[rf$2]=!0,qf$1("selectionchange",!1,at))}}function pf$2(st,at,pt,vt){switch(jd$2(at)){case 1:var wt=ed$2;break;case 4:wt=gd$1;break;default:wt=fd$3}pt=wt.bind(null,at,pt,st),wt=void 0,!Lb$1||at!=="touchstart"&&at!=="touchmove"&&at!=="wheel"||(wt=!0),vt?wt!==void 0?st.addEventListener(at,pt,{capture:!0,passive:wt}):st.addEventListener(at,pt,!0):wt!==void 0?st.addEventListener(at,pt,{passive:wt}):st.addEventListener(at,pt,!1)}function hd$2(st,at,pt,vt,wt){var $t=vt;if(!(at&1)&&!(at&2)&&vt!==null)e:for(;;){if(vt===null)return;var Tt=vt.tag;if(Tt===3||Tt===4){var Lt=vt.stateNode.containerInfo;if(Lt===wt||Lt.nodeType===8&&Lt.parentNode===wt)break;if(Tt===4)for(Tt=vt.return;Tt!==null;){var Ft=Tt.tag;if((Ft===3||Ft===4)&&(Ft=Tt.stateNode.containerInfo,Ft===wt||Ft.nodeType===8&&Ft.parentNode===wt))return;Tt=Tt.return}for(;Lt!==null;){if(Tt=Wc$2(Lt),Tt===null)return;if(Ft=Tt.tag,Ft===5||Ft===6){vt=$t=Tt;continue e}Lt=Lt.parentNode}}vt=vt.return}Jb$1(function(){var Ct=$t,Ht=xb$1(pt),Gt=[];e:{var jt=df$1.get(st);if(jt!==void 0){var qt=td$3,Kt=st;switch(st){case"keypress":if(od$2(pt)===0)break e;case"keydown":case"keyup":qt=Rd$1;break;case"focusin":Kt="focus",qt=Fd$2;break;case"focusout":Kt="blur",qt=Fd$2;break;case"beforeblur":case"afterblur":qt=Fd$2;break;case"click":if(pt.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":qt=Bd$1;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":qt=Dd$2;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":qt=Vd$1;break;case $e$1:case af$2:case bf$1:qt=Hd$2;break;case cf$1:qt=Xd$2;break;case"scroll":qt=vd$2;break;case"wheel":qt=Zd$1;break;case"copy":case"cut":case"paste":qt=Jd$1;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":qt=Td$1}var An=(at&4)!==0,Sn=!An&&st==="scroll",wn=An?jt!==null?jt+"Capture":null:jt;An=[];for(var In=Ct,tr;In!==null;){tr=In;var rr=tr.stateNode;if(tr.tag===5&&rr!==null&&(tr=rr,wn!==null&&(rr=Kb$1(In,wn),rr!=null&&An.push(tf$2(In,rr,tr)))),Sn)break;In=In.return}0<An.length&&(jt=new qt(jt,Kt,null,pt,Ht),Gt.push({event:jt,listeners:An}))}}if(!(at&7)){e:{if(jt=st==="mouseover"||st==="pointerover",qt=st==="mouseout"||st==="pointerout",jt&&pt!==wb$1&&(Kt=pt.relatedTarget||pt.fromElement)&&(Wc$2(Kt)||Kt[uf$2]))break e;if((qt||jt)&&(jt=Ht.window===Ht?Ht:(jt=Ht.ownerDocument)?jt.defaultView||jt.parentWindow:window,qt?(Kt=pt.relatedTarget||pt.toElement,qt=Ct,Kt=Kt?Wc$2(Kt):null,Kt!==null&&(Sn=Vb$1(Kt),Kt!==Sn||Kt.tag!==5&&Kt.tag!==6)&&(Kt=null)):(qt=null,Kt=Ct),qt!==Kt)){if(An=Bd$1,rr="onMouseLeave",wn="onMouseEnter",In="mouse",(st==="pointerout"||st==="pointerover")&&(An=Td$1,rr="onPointerLeave",wn="onPointerEnter",In="pointer"),Sn=qt==null?jt:ue(qt),tr=Kt==null?jt:ue(Kt),jt=new An(rr,In+"leave",qt,pt,Ht),jt.target=Sn,jt.relatedTarget=tr,rr=null,Wc$2(Ht)===Ct&&(An=new An(wn,In+"enter",Kt,pt,Ht),An.target=tr,An.relatedTarget=Sn,rr=An),Sn=rr,qt&&Kt)t:{for(An=qt,wn=Kt,In=0,tr=An;tr;tr=vf$1(tr))In++;for(tr=0,rr=wn;rr;rr=vf$1(rr))tr++;for(;0<In-tr;)An=vf$1(An),In--;for(;0<tr-In;)wn=vf$1(wn),tr--;for(;In--;){if(An===wn||wn!==null&&An===wn.alternate)break t;An=vf$1(An),wn=vf$1(wn)}An=null}else An=null;qt!==null&&wf$1(Gt,jt,qt,An,!1),Kt!==null&&Sn!==null&&wf$1(Gt,Sn,Kt,An,!0)}}e:{if(jt=Ct?ue(Ct):window,qt=jt.nodeName&&jt.nodeName.toLowerCase(),qt==="select"||qt==="input"&&jt.type==="file")var Hr=ve$1;else if(me$1(jt))if(we$2)Hr=Fe$1;else{Hr=De$2;var qr=Ce$1}else(qt=jt.nodeName)&&qt.toLowerCase()==="input"&&(jt.type==="checkbox"||jt.type==="radio")&&(Hr=Ee$1);if(Hr&&(Hr=Hr(st,Ct))){ne$1(Gt,Hr,pt,Ht);break e}qr&&qr(st,jt,Ct),st==="focusout"&&(qr=jt._wrapperState)&&qr.controlled&&jt.type==="number"&&cb$1(jt,"number",jt.value)}switch(qr=Ct?ue(Ct):window,st){case"focusin":(me$1(qr)||qr.contentEditable==="true")&&(Qe$1=qr,Re=Ct,Se=null);break;case"focusout":Se=Re=Qe$1=null;break;case"mousedown":Te=!0;break;case"contextmenu":case"mouseup":case"dragend":Te=!1,Ue$2(Gt,pt,Ht);break;case"selectionchange":if(Pe$1)break;case"keydown":case"keyup":Ue$2(Gt,pt,Ht)}var Zr;if(ae$1)e:{switch(st){case"compositionstart":var Bo="onCompositionStart";break e;case"compositionend":Bo="onCompositionEnd";break e;case"compositionupdate":Bo="onCompositionUpdate";break e}Bo=void 0}else ie?ge(st,pt)&&(Bo="onCompositionEnd"):st==="keydown"&&pt.keyCode===229&&(Bo="onCompositionStart");Bo&&(de&&pt.locale!=="ko"&&(ie||Bo!=="onCompositionStart"?Bo==="onCompositionEnd"&&ie&&(Zr=nd$2()):(kd$2=Ht,ld$2="value"in kd$2?kd$2.value:kd$2.textContent,ie=!0)),qr=oe$1(Ct,Bo),0<qr.length&&(Bo=new Ld$2(Bo,st,null,pt,Ht),Gt.push({event:Bo,listeners:qr}),Zr?Bo.data=Zr:(Zr=he(pt),Zr!==null&&(Bo.data=Zr)))),(Zr=ce$1?je(st,pt):ke$1(st,pt))&&(Ct=oe$1(Ct,"onBeforeInput"),0<Ct.length&&(Ht=new Ld$2("onBeforeInput","beforeinput",null,pt,Ht),Gt.push({event:Ht,listeners:Ct}),Ht.data=Zr))}se(Gt,at)})}function tf$2(st,at,pt){return{instance:st,listener:at,currentTarget:pt}}function oe$1(st,at){for(var pt=at+"Capture",vt=[];st!==null;){var wt=st,$t=wt.stateNode;wt.tag===5&&$t!==null&&(wt=$t,$t=Kb$1(st,pt),$t!=null&&vt.unshift(tf$2(st,$t,wt)),$t=Kb$1(st,at),$t!=null&&vt.push(tf$2(st,$t,wt))),st=st.return}return vt}function vf$1(st){if(st===null)return null;do st=st.return;while(st&&st.tag!==5);return st||null}function wf$1(st,at,pt,vt,wt){for(var $t=at._reactName,Tt=[];pt!==null&&pt!==vt;){var Lt=pt,Ft=Lt.alternate,Ct=Lt.stateNode;if(Ft!==null&&Ft===vt)break;Lt.tag===5&&Ct!==null&&(Lt=Ct,wt?(Ft=Kb$1(pt,$t),Ft!=null&&Tt.unshift(tf$2(pt,Ft,Lt))):wt||(Ft=Kb$1(pt,$t),Ft!=null&&Tt.push(tf$2(pt,Ft,Lt)))),pt=pt.return}Tt.length!==0&&st.push({event:at,listeners:Tt})}var xf$1=/\r\n?/g,yf$1=/\u0000|\uFFFD/g;function zf$1(st){return(typeof st=="string"?st:""+st).replace(xf$1,`
`).replace(yf$1,"")}function Af$1(st,at,pt){if(at=zf$1(at),zf$1(st)!==at&&pt)throw Error(p$3(425))}function Bf$1(){}var Cf$1=null,Df$1=null;function Ef$1(st,at){return st==="textarea"||st==="noscript"||typeof at.children=="string"||typeof at.children=="number"||typeof at.dangerouslySetInnerHTML=="object"&&at.dangerouslySetInnerHTML!==null&&at.dangerouslySetInnerHTML.__html!=null}var Ff$1=typeof setTimeout=="function"?setTimeout:void 0,Gf$1=typeof clearTimeout=="function"?clearTimeout:void 0,Hf$1=typeof Promise=="function"?Promise:void 0,Jf$1=typeof queueMicrotask=="function"?queueMicrotask:typeof Hf$1<"u"?function(st){return Hf$1.resolve(null).then(st).catch(If$1)}:Ff$1;function If$1(st){setTimeout(function(){throw st})}function Kf$1(st,at){var pt=at,vt=0;do{var wt=pt.nextSibling;if(st.removeChild(pt),wt&&wt.nodeType===8)if(pt=wt.data,pt==="/$"){if(vt===0){st.removeChild(wt),bd$1(at);return}vt--}else pt!=="$"&&pt!=="$?"&&pt!=="$!"||vt++;pt=wt}while(pt);bd$1(at)}function Lf$1(st){for(;st!=null;st=st.nextSibling){var at=st.nodeType;if(at===1||at===3)break;if(at===8){if(at=st.data,at==="$"||at==="$!"||at==="$?")break;if(at==="/$")return null}}return st}function Mf$1(st){st=st.previousSibling;for(var at=0;st;){if(st.nodeType===8){var pt=st.data;if(pt==="$"||pt==="$!"||pt==="$?"){if(at===0)return st;at--}else pt==="/$"&&at++}st=st.previousSibling}return null}var Nf$1=Math.random().toString(36).slice(2),Of$1="__reactFiber$"+Nf$1,Pf$1="__reactProps$"+Nf$1,uf$2="__reactContainer$"+Nf$1,of$2="__reactEvents$"+Nf$1,Qf$1="__reactListeners$"+Nf$1,Rf$1="__reactHandles$"+Nf$1;function Wc$2(st){var at=st[Of$1];if(at)return at;for(var pt=st.parentNode;pt;){if(at=pt[uf$2]||pt[Of$1]){if(pt=at.alternate,at.child!==null||pt!==null&&pt.child!==null)for(st=Mf$1(st);st!==null;){if(pt=st[Of$1])return pt;st=Mf$1(st)}return at}st=pt,pt=st.parentNode}return null}function Cb$1(st){return st=st[Of$1]||st[uf$2],!st||st.tag!==5&&st.tag!==6&&st.tag!==13&&st.tag!==3?null:st}function ue(st){if(st.tag===5||st.tag===6)return st.stateNode;throw Error(p$3(33))}function Db$1(st){return st[Pf$1]||null}var Sf$1=[],Tf$1=-1;function Uf$1(st){return{current:st}}function E$1(st){0>Tf$1||(st.current=Sf$1[Tf$1],Sf$1[Tf$1]=null,Tf$1--)}function G$1(st,at){Tf$1++,Sf$1[Tf$1]=st.current,st.current=at}var Vf$1={},H$3=Uf$1(Vf$1),Wf$1=Uf$1(!1),Xf$1=Vf$1;function Yf$1(st,at){var pt=st.type.contextTypes;if(!pt)return Vf$1;var vt=st.stateNode;if(vt&&vt.__reactInternalMemoizedUnmaskedChildContext===at)return vt.__reactInternalMemoizedMaskedChildContext;var wt={},$t;for($t in pt)wt[$t]=at[$t];return vt&&(st=st.stateNode,st.__reactInternalMemoizedUnmaskedChildContext=at,st.__reactInternalMemoizedMaskedChildContext=wt),wt}function Zf$1(st){return st=st.childContextTypes,st!=null}function $f$1(){E$1(Wf$1),E$1(H$3)}function ag(st,at,pt){if(H$3.current!==Vf$1)throw Error(p$3(168));G$1(H$3,at),G$1(Wf$1,pt)}function bg$1(st,at,pt){var vt=st.stateNode;if(at=at.childContextTypes,typeof vt.getChildContext!="function")return pt;vt=vt.getChildContext();for(var wt in vt)if(!(wt in at))throw Error(p$3(108,Ra(st)||"Unknown",wt));return A$1({},pt,vt)}function cg$1(st){return st=(st=st.stateNode)&&st.__reactInternalMemoizedMergedChildContext||Vf$1,Xf$1=H$3.current,G$1(H$3,st),G$1(Wf$1,Wf$1.current),!0}function dg$1(st,at,pt){var vt=st.stateNode;if(!vt)throw Error(p$3(169));pt?(st=bg$1(st,at,Xf$1),vt.__reactInternalMemoizedMergedChildContext=st,E$1(Wf$1),E$1(H$3),G$1(H$3,st)):E$1(Wf$1),G$1(Wf$1,pt)}var eg=null,fg$1=!1,gg=!1;function hg$1(st){eg===null?eg=[st]:eg.push(st)}function ig$1(st){fg$1=!0,hg$1(st)}function jg(){if(!gg&&eg!==null){gg=!0;var st=0,at=C$1;try{var pt=eg;for(C$1=1;st<pt.length;st++){var vt=pt[st];do vt=vt(!0);while(vt!==null)}eg=null,fg$1=!1}catch(wt){throw eg!==null&&(eg=eg.slice(st+1)),ac$2(fc$2,jg),wt}finally{C$1=at,gg=!1}}return null}var kg=[],lg$1=0,mg$1=null,ng$1=0,og$1=[],pg$1=0,qg=null,rg$1=1,sg$1="";function tg$1(st,at){kg[lg$1++]=ng$1,kg[lg$1++]=mg$1,mg$1=st,ng$1=at}function ug$1(st,at,pt){og$1[pg$1++]=rg$1,og$1[pg$1++]=sg$1,og$1[pg$1++]=qg,qg=st;var vt=rg$1;st=sg$1;var wt=32-oc$2(vt)-1;vt&=~(1<<wt),pt+=1;var $t=32-oc$2(at)+wt;if(30<$t){var Tt=wt-wt%5;$t=(vt&(1<<Tt)-1).toString(32),vt>>=Tt,wt-=Tt,rg$1=1<<32-oc$2(at)+wt|pt<<wt|vt,sg$1=$t+st}else rg$1=1<<$t|pt<<wt|vt,sg$1=st}function vg$1(st){st.return!==null&&(tg$1(st,1),ug$1(st,1,0))}function wg$1(st){for(;st===mg$1;)mg$1=kg[--lg$1],kg[lg$1]=null,ng$1=kg[--lg$1],kg[lg$1]=null;for(;st===qg;)qg=og$1[--pg$1],og$1[pg$1]=null,sg$1=og$1[--pg$1],og$1[pg$1]=null,rg$1=og$1[--pg$1],og$1[pg$1]=null}var xg$1=null,yg=null,I$3=!1,zg=null;function Ag(st,at){var pt=Bg(5,null,null,0);pt.elementType="DELETED",pt.stateNode=at,pt.return=st,at=st.deletions,at===null?(st.deletions=[pt],st.flags|=16):at.push(pt)}function Cg(st,at){switch(st.tag){case 5:var pt=st.type;return at=at.nodeType!==1||pt.toLowerCase()!==at.nodeName.toLowerCase()?null:at,at!==null?(st.stateNode=at,xg$1=st,yg=Lf$1(at.firstChild),!0):!1;case 6:return at=st.pendingProps===""||at.nodeType!==3?null:at,at!==null?(st.stateNode=at,xg$1=st,yg=null,!0):!1;case 13:return at=at.nodeType!==8?null:at,at!==null?(pt=qg!==null?{id:rg$1,overflow:sg$1}:null,st.memoizedState={dehydrated:at,treeContext:pt,retryLane:1073741824},pt=Bg(18,null,null,0),pt.stateNode=at,pt.return=st,st.child=pt,xg$1=st,yg=null,!0):!1;default:return!1}}function Dg(st){return(st.mode&1)!==0&&(st.flags&128)===0}function Eg(st){if(I$3){var at=yg;if(at){var pt=at;if(!Cg(st,at)){if(Dg(st))throw Error(p$3(418));at=Lf$1(pt.nextSibling);var vt=xg$1;at&&Cg(st,at)?Ag(vt,pt):(st.flags=st.flags&-4097|2,I$3=!1,xg$1=st)}}else{if(Dg(st))throw Error(p$3(418));st.flags=st.flags&-4097|2,I$3=!1,xg$1=st}}}function Fg(st){for(st=st.return;st!==null&&st.tag!==5&&st.tag!==3&&st.tag!==13;)st=st.return;xg$1=st}function Gg(st){if(st!==xg$1)return!1;if(!I$3)return Fg(st),I$3=!0,!1;var at;if((at=st.tag!==3)&&!(at=st.tag!==5)&&(at=st.type,at=at!=="head"&&at!=="body"&&!Ef$1(st.type,st.memoizedProps)),at&&(at=yg)){if(Dg(st))throw Hg(),Error(p$3(418));for(;at;)Ag(st,at),at=Lf$1(at.nextSibling)}if(Fg(st),st.tag===13){if(st=st.memoizedState,st=st!==null?st.dehydrated:null,!st)throw Error(p$3(317));e:{for(st=st.nextSibling,at=0;st;){if(st.nodeType===8){var pt=st.data;if(pt==="/$"){if(at===0){yg=Lf$1(st.nextSibling);break e}at--}else pt!=="$"&&pt!=="$!"&&pt!=="$?"||at++}st=st.nextSibling}yg=null}}else yg=xg$1?Lf$1(st.stateNode.nextSibling):null;return!0}function Hg(){for(var st=yg;st;)st=Lf$1(st.nextSibling)}function Ig(){yg=xg$1=null,I$3=!1}function Jg(st){zg===null?zg=[st]:zg.push(st)}var Kg=ua$2.ReactCurrentBatchConfig;function Lg(st,at,pt){if(st=pt.ref,st!==null&&typeof st!="function"&&typeof st!="object"){if(pt._owner){if(pt=pt._owner,pt){if(pt.tag!==1)throw Error(p$3(309));var vt=pt.stateNode}if(!vt)throw Error(p$3(147,st));var wt=vt,$t=""+st;return at!==null&&at.ref!==null&&typeof at.ref=="function"&&at.ref._stringRef===$t?at.ref:(at=function(Tt){var Lt=wt.refs;Tt===null?delete Lt[$t]:Lt[$t]=Tt},at._stringRef=$t,at)}if(typeof st!="string")throw Error(p$3(284));if(!pt._owner)throw Error(p$3(290,st))}return st}function Mg(st,at){throw st=Object.prototype.toString.call(at),Error(p$3(31,st==="[object Object]"?"object with keys {"+Object.keys(at).join(", ")+"}":st))}function Ng(st){var at=st._init;return at(st._payload)}function Og(st){function at(wn,In){if(st){var tr=wn.deletions;tr===null?(wn.deletions=[In],wn.flags|=16):tr.push(In)}}function pt(wn,In){if(!st)return null;for(;In!==null;)at(wn,In),In=In.sibling;return null}function vt(wn,In){for(wn=new Map;In!==null;)In.key!==null?wn.set(In.key,In):wn.set(In.index,In),In=In.sibling;return wn}function wt(wn,In){return wn=Pg(wn,In),wn.index=0,wn.sibling=null,wn}function $t(wn,In,tr){return wn.index=tr,st?(tr=wn.alternate,tr!==null?(tr=tr.index,tr<In?(wn.flags|=2,In):tr):(wn.flags|=2,In)):(wn.flags|=1048576,In)}function Tt(wn){return st&&wn.alternate===null&&(wn.flags|=2),wn}function Lt(wn,In,tr,rr){return In===null||In.tag!==6?(In=Qg(tr,wn.mode,rr),In.return=wn,In):(In=wt(In,tr),In.return=wn,In)}function Ft(wn,In,tr,rr){var Hr=tr.type;return Hr===ya$1?Ht(wn,In,tr.props.children,rr,tr.key):In!==null&&(In.elementType===Hr||typeof Hr=="object"&&Hr!==null&&Hr.$$typeof===Ha$2&&Ng(Hr)===In.type)?(rr=wt(In,tr.props),rr.ref=Lg(wn,In,tr),rr.return=wn,rr):(rr=Rg(tr.type,tr.key,tr.props,null,wn.mode,rr),rr.ref=Lg(wn,In,tr),rr.return=wn,rr)}function Ct(wn,In,tr,rr){return In===null||In.tag!==4||In.stateNode.containerInfo!==tr.containerInfo||In.stateNode.implementation!==tr.implementation?(In=Sg(tr,wn.mode,rr),In.return=wn,In):(In=wt(In,tr.children||[]),In.return=wn,In)}function Ht(wn,In,tr,rr,Hr){return In===null||In.tag!==7?(In=Tg$1(tr,wn.mode,rr,Hr),In.return=wn,In):(In=wt(In,tr),In.return=wn,In)}function Gt(wn,In,tr){if(typeof In=="string"&&In!==""||typeof In=="number")return In=Qg(""+In,wn.mode,tr),In.return=wn,In;if(typeof In=="object"&&In!==null){switch(In.$$typeof){case va$1:return tr=Rg(In.type,In.key,In.props,null,wn.mode,tr),tr.ref=Lg(wn,null,In),tr.return=wn,tr;case wa$1:return In=Sg(In,wn.mode,tr),In.return=wn,In;case Ha$2:var rr=In._init;return Gt(wn,rr(In._payload),tr)}if(eb$1(In)||Ka$2(In))return In=Tg$1(In,wn.mode,tr,null),In.return=wn,In;Mg(wn,In)}return null}function jt(wn,In,tr,rr){var Hr=In!==null?In.key:null;if(typeof tr=="string"&&tr!==""||typeof tr=="number")return Hr!==null?null:Lt(wn,In,""+tr,rr);if(typeof tr=="object"&&tr!==null){switch(tr.$$typeof){case va$1:return tr.key===Hr?Ft(wn,In,tr,rr):null;case wa$1:return tr.key===Hr?Ct(wn,In,tr,rr):null;case Ha$2:return Hr=tr._init,jt(wn,In,Hr(tr._payload),rr)}if(eb$1(tr)||Ka$2(tr))return Hr!==null?null:Ht(wn,In,tr,rr,null);Mg(wn,tr)}return null}function qt(wn,In,tr,rr,Hr){if(typeof rr=="string"&&rr!==""||typeof rr=="number")return wn=wn.get(tr)||null,Lt(In,wn,""+rr,Hr);if(typeof rr=="object"&&rr!==null){switch(rr.$$typeof){case va$1:return wn=wn.get(rr.key===null?tr:rr.key)||null,Ft(In,wn,rr,Hr);case wa$1:return wn=wn.get(rr.key===null?tr:rr.key)||null,Ct(In,wn,rr,Hr);case Ha$2:var qr=rr._init;return qt(wn,In,tr,qr(rr._payload),Hr)}if(eb$1(rr)||Ka$2(rr))return wn=wn.get(tr)||null,Ht(In,wn,rr,Hr,null);Mg(In,rr)}return null}function Kt(wn,In,tr,rr){for(var Hr=null,qr=null,Zr=In,Bo=In=0,Xo=null;Zr!==null&&Bo<tr.length;Bo++){Zr.index>Bo?(Xo=Zr,Zr=null):Xo=Zr.sibling;var Kr=jt(wn,Zr,tr[Bo],rr);if(Kr===null){Zr===null&&(Zr=Xo);break}st&&Zr&&Kr.alternate===null&&at(wn,Zr),In=$t(Kr,In,Bo),qr===null?Hr=Kr:qr.sibling=Kr,qr=Kr,Zr=Xo}if(Bo===tr.length)return pt(wn,Zr),I$3&&tg$1(wn,Bo),Hr;if(Zr===null){for(;Bo<tr.length;Bo++)Zr=Gt(wn,tr[Bo],rr),Zr!==null&&(In=$t(Zr,In,Bo),qr===null?Hr=Zr:qr.sibling=Zr,qr=Zr);return I$3&&tg$1(wn,Bo),Hr}for(Zr=vt(wn,Zr);Bo<tr.length;Bo++)Xo=qt(Zr,wn,Bo,tr[Bo],rr),Xo!==null&&(st&&Xo.alternate!==null&&Zr.delete(Xo.key===null?Bo:Xo.key),In=$t(Xo,In,Bo),qr===null?Hr=Xo:qr.sibling=Xo,qr=Xo);return st&&Zr.forEach(function(ko){return at(wn,ko)}),I$3&&tg$1(wn,Bo),Hr}function An(wn,In,tr,rr){var Hr=Ka$2(tr);if(typeof Hr!="function")throw Error(p$3(150));if(tr=Hr.call(tr),tr==null)throw Error(p$3(151));for(var qr=Hr=null,Zr=In,Bo=In=0,Xo=null,Kr=tr.next();Zr!==null&&!Kr.done;Bo++,Kr=tr.next()){Zr.index>Bo?(Xo=Zr,Zr=null):Xo=Zr.sibling;var ko=jt(wn,Zr,Kr.value,rr);if(ko===null){Zr===null&&(Zr=Xo);break}st&&Zr&&ko.alternate===null&&at(wn,Zr),In=$t(ko,In,Bo),qr===null?Hr=ko:qr.sibling=ko,qr=ko,Zr=Xo}if(Kr.done)return pt(wn,Zr),I$3&&tg$1(wn,Bo),Hr;if(Zr===null){for(;!Kr.done;Bo++,Kr=tr.next())Kr=Gt(wn,Kr.value,rr),Kr!==null&&(In=$t(Kr,In,Bo),qr===null?Hr=Kr:qr.sibling=Kr,qr=Kr);return I$3&&tg$1(wn,Bo),Hr}for(Zr=vt(wn,Zr);!Kr.done;Bo++,Kr=tr.next())Kr=qt(Zr,wn,Bo,Kr.value,rr),Kr!==null&&(st&&Kr.alternate!==null&&Zr.delete(Kr.key===null?Bo:Kr.key),In=$t(Kr,In,Bo),qr===null?Hr=Kr:qr.sibling=Kr,qr=Kr);return st&&Zr.forEach(function(f0){return at(wn,f0)}),I$3&&tg$1(wn,Bo),Hr}function Sn(wn,In,tr,rr){if(typeof tr=="object"&&tr!==null&&tr.type===ya$1&&tr.key===null&&(tr=tr.props.children),typeof tr=="object"&&tr!==null){switch(tr.$$typeof){case va$1:e:{for(var Hr=tr.key,qr=In;qr!==null;){if(qr.key===Hr){if(Hr=tr.type,Hr===ya$1){if(qr.tag===7){pt(wn,qr.sibling),In=wt(qr,tr.props.children),In.return=wn,wn=In;break e}}else if(qr.elementType===Hr||typeof Hr=="object"&&Hr!==null&&Hr.$$typeof===Ha$2&&Ng(Hr)===qr.type){pt(wn,qr.sibling),In=wt(qr,tr.props),In.ref=Lg(wn,qr,tr),In.return=wn,wn=In;break e}pt(wn,qr);break}else at(wn,qr);qr=qr.sibling}tr.type===ya$1?(In=Tg$1(tr.props.children,wn.mode,rr,tr.key),In.return=wn,wn=In):(rr=Rg(tr.type,tr.key,tr.props,null,wn.mode,rr),rr.ref=Lg(wn,In,tr),rr.return=wn,wn=rr)}return Tt(wn);case wa$1:e:{for(qr=tr.key;In!==null;){if(In.key===qr)if(In.tag===4&&In.stateNode.containerInfo===tr.containerInfo&&In.stateNode.implementation===tr.implementation){pt(wn,In.sibling),In=wt(In,tr.children||[]),In.return=wn,wn=In;break e}else{pt(wn,In);break}else at(wn,In);In=In.sibling}In=Sg(tr,wn.mode,rr),In.return=wn,wn=In}return Tt(wn);case Ha$2:return qr=tr._init,Sn(wn,In,qr(tr._payload),rr)}if(eb$1(tr))return Kt(wn,In,tr,rr);if(Ka$2(tr))return An(wn,In,tr,rr);Mg(wn,tr)}return typeof tr=="string"&&tr!==""||typeof tr=="number"?(tr=""+tr,In!==null&&In.tag===6?(pt(wn,In.sibling),In=wt(In,tr),In.return=wn,wn=In):(pt(wn,In),In=Qg(tr,wn.mode,rr),In.return=wn,wn=In),Tt(wn)):pt(wn,In)}return Sn}var Ug=Og(!0),Vg=Og(!1),Wg=Uf$1(null),Xg=null,Yg=null,Zg=null;function $g(){Zg=Yg=Xg=null}function ah(st){var at=Wg.current;E$1(Wg),st._currentValue=at}function bh$1(st,at,pt){for(;st!==null;){var vt=st.alternate;if((st.childLanes&at)!==at?(st.childLanes|=at,vt!==null&&(vt.childLanes|=at)):vt!==null&&(vt.childLanes&at)!==at&&(vt.childLanes|=at),st===pt)break;st=st.return}}function ch$1(st,at){Xg=st,Zg=Yg=null,st=st.dependencies,st!==null&&st.firstContext!==null&&(st.lanes&at&&(dh$1=!0),st.firstContext=null)}function eh$1(st){var at=st._currentValue;if(Zg!==st)if(st={context:st,memoizedValue:at,next:null},Yg===null){if(Xg===null)throw Error(p$3(308));Yg=st,Xg.dependencies={lanes:0,firstContext:st}}else Yg=Yg.next=st;return at}var fh=null;function gh$1(st){fh===null?fh=[st]:fh.push(st)}function hh$1(st,at,pt,vt){var wt=at.interleaved;return wt===null?(pt.next=pt,gh$1(at)):(pt.next=wt.next,wt.next=pt),at.interleaved=pt,ih$1(st,vt)}function ih$1(st,at){st.lanes|=at;var pt=st.alternate;for(pt!==null&&(pt.lanes|=at),pt=st,st=st.return;st!==null;)st.childLanes|=at,pt=st.alternate,pt!==null&&(pt.childLanes|=at),pt=st,st=st.return;return pt.tag===3?pt.stateNode:null}var jh$1=!1;function kh$1(st){st.updateQueue={baseState:st.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function lh$1(st,at){st=st.updateQueue,at.updateQueue===st&&(at.updateQueue={baseState:st.baseState,firstBaseUpdate:st.firstBaseUpdate,lastBaseUpdate:st.lastBaseUpdate,shared:st.shared,effects:st.effects})}function mh$1(st,at){return{eventTime:st,lane:at,tag:0,payload:null,callback:null,next:null}}function nh$1(st,at,pt){var vt=st.updateQueue;if(vt===null)return null;if(vt=vt.shared,K$1&2){var wt=vt.pending;return wt===null?at.next=at:(at.next=wt.next,wt.next=at),vt.pending=at,ih$1(st,pt)}return wt=vt.interleaved,wt===null?(at.next=at,gh$1(vt)):(at.next=wt.next,wt.next=at),vt.interleaved=at,ih$1(st,pt)}function oh$1(st,at,pt){if(at=at.updateQueue,at!==null&&(at=at.shared,(pt&4194240)!==0)){var vt=at.lanes;vt&=st.pendingLanes,pt|=vt,at.lanes=pt,Cc$2(st,pt)}}function ph$1(st,at){var pt=st.updateQueue,vt=st.alternate;if(vt!==null&&(vt=vt.updateQueue,pt===vt)){var wt=null,$t=null;if(pt=pt.firstBaseUpdate,pt!==null){do{var Tt={eventTime:pt.eventTime,lane:pt.lane,tag:pt.tag,payload:pt.payload,callback:pt.callback,next:null};$t===null?wt=$t=Tt:$t=$t.next=Tt,pt=pt.next}while(pt!==null);$t===null?wt=$t=at:$t=$t.next=at}else wt=$t=at;pt={baseState:vt.baseState,firstBaseUpdate:wt,lastBaseUpdate:$t,shared:vt.shared,effects:vt.effects},st.updateQueue=pt;return}st=pt.lastBaseUpdate,st===null?pt.firstBaseUpdate=at:st.next=at,pt.lastBaseUpdate=at}function qh$1(st,at,pt,vt){var wt=st.updateQueue;jh$1=!1;var $t=wt.firstBaseUpdate,Tt=wt.lastBaseUpdate,Lt=wt.shared.pending;if(Lt!==null){wt.shared.pending=null;var Ft=Lt,Ct=Ft.next;Ft.next=null,Tt===null?$t=Ct:Tt.next=Ct,Tt=Ft;var Ht=st.alternate;Ht!==null&&(Ht=Ht.updateQueue,Lt=Ht.lastBaseUpdate,Lt!==Tt&&(Lt===null?Ht.firstBaseUpdate=Ct:Lt.next=Ct,Ht.lastBaseUpdate=Ft))}if($t!==null){var Gt=wt.baseState;Tt=0,Ht=Ct=Ft=null,Lt=$t;do{var jt=Lt.lane,qt=Lt.eventTime;if((vt&jt)===jt){Ht!==null&&(Ht=Ht.next={eventTime:qt,lane:0,tag:Lt.tag,payload:Lt.payload,callback:Lt.callback,next:null});e:{var Kt=st,An=Lt;switch(jt=at,qt=pt,An.tag){case 1:if(Kt=An.payload,typeof Kt=="function"){Gt=Kt.call(qt,Gt,jt);break e}Gt=Kt;break e;case 3:Kt.flags=Kt.flags&-65537|128;case 0:if(Kt=An.payload,jt=typeof Kt=="function"?Kt.call(qt,Gt,jt):Kt,jt==null)break e;Gt=A$1({},Gt,jt);break e;case 2:jh$1=!0}}Lt.callback!==null&&Lt.lane!==0&&(st.flags|=64,jt=wt.effects,jt===null?wt.effects=[Lt]:jt.push(Lt))}else qt={eventTime:qt,lane:jt,tag:Lt.tag,payload:Lt.payload,callback:Lt.callback,next:null},Ht===null?(Ct=Ht=qt,Ft=Gt):Ht=Ht.next=qt,Tt|=jt;if(Lt=Lt.next,Lt===null){if(Lt=wt.shared.pending,Lt===null)break;jt=Lt,Lt=jt.next,jt.next=null,wt.lastBaseUpdate=jt,wt.shared.pending=null}}while(!0);if(Ht===null&&(Ft=Gt),wt.baseState=Ft,wt.firstBaseUpdate=Ct,wt.lastBaseUpdate=Ht,at=wt.shared.interleaved,at!==null){wt=at;do Tt|=wt.lane,wt=wt.next;while(wt!==at)}else $t===null&&(wt.shared.lanes=0);rh$1|=Tt,st.lanes=Tt,st.memoizedState=Gt}}function sh$1(st,at,pt){if(st=at.effects,at.effects=null,st!==null)for(at=0;at<st.length;at++){var vt=st[at],wt=vt.callback;if(wt!==null){if(vt.callback=null,vt=pt,typeof wt!="function")throw Error(p$3(191,wt));wt.call(vt)}}}var th$1={},uh$1=Uf$1(th$1),vh$1=Uf$1(th$1),wh$1=Uf$1(th$1);function xh$1(st){if(st===th$1)throw Error(p$3(174));return st}function yh$1(st,at){switch(G$1(wh$1,at),G$1(vh$1,st),G$1(uh$1,th$1),st=at.nodeType,st){case 9:case 11:at=(at=at.documentElement)?at.namespaceURI:lb$1(null,"");break;default:st=st===8?at.parentNode:at,at=st.namespaceURI||null,st=st.tagName,at=lb$1(at,st)}E$1(uh$1),G$1(uh$1,at)}function zh$1(){E$1(uh$1),E$1(vh$1),E$1(wh$1)}function Ah$1(st){xh$1(wh$1.current);var at=xh$1(uh$1.current),pt=lb$1(at,st.type);at!==pt&&(G$1(vh$1,st),G$1(uh$1,pt))}function Bh$1(st){vh$1.current===st&&(E$1(uh$1),E$1(vh$1))}var L$3=Uf$1(0);function Ch$1(st){for(var at=st;at!==null;){if(at.tag===13){var pt=at.memoizedState;if(pt!==null&&(pt=pt.dehydrated,pt===null||pt.data==="$?"||pt.data==="$!"))return at}else if(at.tag===19&&at.memoizedProps.revealOrder!==void 0){if(at.flags&128)return at}else if(at.child!==null){at.child.return=at,at=at.child;continue}if(at===st)break;for(;at.sibling===null;){if(at.return===null||at.return===st)return null;at=at.return}at.sibling.return=at.return,at=at.sibling}return null}var Dh$1=[];function Eh$1(){for(var st=0;st<Dh$1.length;st++)Dh$1[st]._workInProgressVersionPrimary=null;Dh$1.length=0}var Fh$1=ua$2.ReactCurrentDispatcher,Gh$1=ua$2.ReactCurrentBatchConfig,Hh$1=0,M$3=null,N$2=null,O$1=null,Ih=!1,Jh$1=!1,Kh$1=0,Lh$1=0;function P$1(){throw Error(p$3(321))}function Mh$1(st,at){if(at===null)return!1;for(var pt=0;pt<at.length&&pt<st.length;pt++)if(!He(st[pt],at[pt]))return!1;return!0}function Nh$1(st,at,pt,vt,wt,$t){if(Hh$1=$t,M$3=at,at.memoizedState=null,at.updateQueue=null,at.lanes=0,Fh$1.current=st===null||st.memoizedState===null?Oh$1:Ph$1,st=pt(vt,wt),Jh$1){$t=0;do{if(Jh$1=!1,Kh$1=0,25<=$t)throw Error(p$3(301));$t+=1,O$1=N$2=null,at.updateQueue=null,Fh$1.current=Qh$1,st=pt(vt,wt)}while(Jh$1)}if(Fh$1.current=Rh$1,at=N$2!==null&&N$2.next!==null,Hh$1=0,O$1=N$2=M$3=null,Ih=!1,at)throw Error(p$3(300));return st}function Sh$1(){var st=Kh$1!==0;return Kh$1=0,st}function Th$1(){var st={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return O$1===null?M$3.memoizedState=O$1=st:O$1=O$1.next=st,O$1}function Uh$1(){if(N$2===null){var st=M$3.alternate;st=st!==null?st.memoizedState:null}else st=N$2.next;var at=O$1===null?M$3.memoizedState:O$1.next;if(at!==null)O$1=at,N$2=st;else{if(st===null)throw Error(p$3(310));N$2=st,st={memoizedState:N$2.memoizedState,baseState:N$2.baseState,baseQueue:N$2.baseQueue,queue:N$2.queue,next:null},O$1===null?M$3.memoizedState=O$1=st:O$1=O$1.next=st}return O$1}function Vh$1(st,at){return typeof at=="function"?at(st):at}function Wh$1(st){var at=Uh$1(),pt=at.queue;if(pt===null)throw Error(p$3(311));pt.lastRenderedReducer=st;var vt=N$2,wt=vt.baseQueue,$t=pt.pending;if($t!==null){if(wt!==null){var Tt=wt.next;wt.next=$t.next,$t.next=Tt}vt.baseQueue=wt=$t,pt.pending=null}if(wt!==null){$t=wt.next,vt=vt.baseState;var Lt=Tt=null,Ft=null,Ct=$t;do{var Ht=Ct.lane;if((Hh$1&Ht)===Ht)Ft!==null&&(Ft=Ft.next={lane:0,action:Ct.action,hasEagerState:Ct.hasEagerState,eagerState:Ct.eagerState,next:null}),vt=Ct.hasEagerState?Ct.eagerState:st(vt,Ct.action);else{var Gt={lane:Ht,action:Ct.action,hasEagerState:Ct.hasEagerState,eagerState:Ct.eagerState,next:null};Ft===null?(Lt=Ft=Gt,Tt=vt):Ft=Ft.next=Gt,M$3.lanes|=Ht,rh$1|=Ht}Ct=Ct.next}while(Ct!==null&&Ct!==$t);Ft===null?Tt=vt:Ft.next=Lt,He(vt,at.memoizedState)||(dh$1=!0),at.memoizedState=vt,at.baseState=Tt,at.baseQueue=Ft,pt.lastRenderedState=vt}if(st=pt.interleaved,st!==null){wt=st;do $t=wt.lane,M$3.lanes|=$t,rh$1|=$t,wt=wt.next;while(wt!==st)}else wt===null&&(pt.lanes=0);return[at.memoizedState,pt.dispatch]}function Xh$1(st){var at=Uh$1(),pt=at.queue;if(pt===null)throw Error(p$3(311));pt.lastRenderedReducer=st;var vt=pt.dispatch,wt=pt.pending,$t=at.memoizedState;if(wt!==null){pt.pending=null;var Tt=wt=wt.next;do $t=st($t,Tt.action),Tt=Tt.next;while(Tt!==wt);He($t,at.memoizedState)||(dh$1=!0),at.memoizedState=$t,at.baseQueue===null&&(at.baseState=$t),pt.lastRenderedState=$t}return[$t,vt]}function Yh$1(){}function Zh$1(st,at){var pt=M$3,vt=Uh$1(),wt=at(),$t=!He(vt.memoizedState,wt);if($t&&(vt.memoizedState=wt,dh$1=!0),vt=vt.queue,$h$1(ai$1.bind(null,pt,vt,st),[st]),vt.getSnapshot!==at||$t||O$1!==null&&O$1.memoizedState.tag&1){if(pt.flags|=2048,bi$1(9,ci$1.bind(null,pt,vt,wt,at),void 0,null),Q$2===null)throw Error(p$3(349));Hh$1&30||di$2(pt,at,wt)}return wt}function di$2(st,at,pt){st.flags|=16384,st={getSnapshot:at,value:pt},at=M$3.updateQueue,at===null?(at={lastEffect:null,stores:null},M$3.updateQueue=at,at.stores=[st]):(pt=at.stores,pt===null?at.stores=[st]:pt.push(st))}function ci$1(st,at,pt,vt){at.value=pt,at.getSnapshot=vt,ei$1(at)&&fi$2(st)}function ai$1(st,at,pt){return pt(function(){ei$1(at)&&fi$2(st)})}function ei$1(st){var at=st.getSnapshot;st=st.value;try{var pt=at();return!He(st,pt)}catch{return!0}}function fi$2(st){var at=ih$1(st,1);at!==null&&gi$1(at,st,1,-1)}function hi$2(st){var at=Th$1();return typeof st=="function"&&(st=st()),at.memoizedState=at.baseState=st,st={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh$1,lastRenderedState:st},at.queue=st,st=st.dispatch=ii$1.bind(null,M$3,st),[at.memoizedState,st]}function bi$1(st,at,pt,vt){return st={tag:st,create:at,destroy:pt,deps:vt,next:null},at=M$3.updateQueue,at===null?(at={lastEffect:null,stores:null},M$3.updateQueue=at,at.lastEffect=st.next=st):(pt=at.lastEffect,pt===null?at.lastEffect=st.next=st:(vt=pt.next,pt.next=st,st.next=vt,at.lastEffect=st)),st}function ji$2(){return Uh$1().memoizedState}function ki$1(st,at,pt,vt){var wt=Th$1();M$3.flags|=st,wt.memoizedState=bi$1(1|at,pt,void 0,vt===void 0?null:vt)}function li$1(st,at,pt,vt){var wt=Uh$1();vt=vt===void 0?null:vt;var $t=void 0;if(N$2!==null){var Tt=N$2.memoizedState;if($t=Tt.destroy,vt!==null&&Mh$1(vt,Tt.deps)){wt.memoizedState=bi$1(at,pt,$t,vt);return}}M$3.flags|=st,wt.memoizedState=bi$1(1|at,pt,$t,vt)}function mi$2(st,at){return ki$1(8390656,8,st,at)}function $h$1(st,at){return li$1(2048,8,st,at)}function ni$1(st,at){return li$1(4,2,st,at)}function oi$1(st,at){return li$1(4,4,st,at)}function pi$2(st,at){if(typeof at=="function")return st=st(),at(st),function(){at(null)};if(at!=null)return st=st(),at.current=st,function(){at.current=null}}function qi$2(st,at,pt){return pt=pt!=null?pt.concat([st]):null,li$1(4,4,pi$2.bind(null,at,st),pt)}function ri$1(){}function si$2(st,at){var pt=Uh$1();at=at===void 0?null:at;var vt=pt.memoizedState;return vt!==null&&at!==null&&Mh$1(at,vt[1])?vt[0]:(pt.memoizedState=[st,at],st)}function ti$1(st,at){var pt=Uh$1();at=at===void 0?null:at;var vt=pt.memoizedState;return vt!==null&&at!==null&&Mh$1(at,vt[1])?vt[0]:(st=st(),pt.memoizedState=[st,at],st)}function ui$1(st,at,pt){return Hh$1&21?(He(pt,at)||(pt=yc$2(),M$3.lanes|=pt,rh$1|=pt,st.baseState=!0),at):(st.baseState&&(st.baseState=!1,dh$1=!0),st.memoizedState=pt)}function vi$1(st,at){var pt=C$1;C$1=pt!==0&&4>pt?pt:4,st(!0);var vt=Gh$1.transition;Gh$1.transition={};try{st(!1),at()}finally{C$1=pt,Gh$1.transition=vt}}function wi$1(){return Uh$1().memoizedState}function xi$1(st,at,pt){var vt=yi$1(st);if(pt={lane:vt,action:pt,hasEagerState:!1,eagerState:null,next:null},zi$2(st))Ai$1(at,pt);else if(pt=hh$1(st,at,pt,vt),pt!==null){var wt=R$2();gi$1(pt,st,vt,wt),Bi$2(pt,at,vt)}}function ii$1(st,at,pt){var vt=yi$1(st),wt={lane:vt,action:pt,hasEagerState:!1,eagerState:null,next:null};if(zi$2(st))Ai$1(at,wt);else{var $t=st.alternate;if(st.lanes===0&&($t===null||$t.lanes===0)&&($t=at.lastRenderedReducer,$t!==null))try{var Tt=at.lastRenderedState,Lt=$t(Tt,pt);if(wt.hasEagerState=!0,wt.eagerState=Lt,He(Lt,Tt)){var Ft=at.interleaved;Ft===null?(wt.next=wt,gh$1(at)):(wt.next=Ft.next,Ft.next=wt),at.interleaved=wt;return}}catch{}finally{}pt=hh$1(st,at,wt,vt),pt!==null&&(wt=R$2(),gi$1(pt,st,vt,wt),Bi$2(pt,at,vt))}}function zi$2(st){var at=st.alternate;return st===M$3||at!==null&&at===M$3}function Ai$1(st,at){Jh$1=Ih=!0;var pt=st.pending;pt===null?at.next=at:(at.next=pt.next,pt.next=at),st.pending=at}function Bi$2(st,at,pt){if(pt&4194240){var vt=at.lanes;vt&=st.pendingLanes,pt|=vt,at.lanes=pt,Cc$2(st,pt)}}var Rh$1={readContext:eh$1,useCallback:P$1,useContext:P$1,useEffect:P$1,useImperativeHandle:P$1,useInsertionEffect:P$1,useLayoutEffect:P$1,useMemo:P$1,useReducer:P$1,useRef:P$1,useState:P$1,useDebugValue:P$1,useDeferredValue:P$1,useTransition:P$1,useMutableSource:P$1,useSyncExternalStore:P$1,useId:P$1,unstable_isNewReconciler:!1},Oh$1={readContext:eh$1,useCallback:function(st,at){return Th$1().memoizedState=[st,at===void 0?null:at],st},useContext:eh$1,useEffect:mi$2,useImperativeHandle:function(st,at,pt){return pt=pt!=null?pt.concat([st]):null,ki$1(4194308,4,pi$2.bind(null,at,st),pt)},useLayoutEffect:function(st,at){return ki$1(4194308,4,st,at)},useInsertionEffect:function(st,at){return ki$1(4,2,st,at)},useMemo:function(st,at){var pt=Th$1();return at=at===void 0?null:at,st=st(),pt.memoizedState=[st,at],st},useReducer:function(st,at,pt){var vt=Th$1();return at=pt!==void 0?pt(at):at,vt.memoizedState=vt.baseState=at,st={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:st,lastRenderedState:at},vt.queue=st,st=st.dispatch=xi$1.bind(null,M$3,st),[vt.memoizedState,st]},useRef:function(st){var at=Th$1();return st={current:st},at.memoizedState=st},useState:hi$2,useDebugValue:ri$1,useDeferredValue:function(st){return Th$1().memoizedState=st},useTransition:function(){var st=hi$2(!1),at=st[0];return st=vi$1.bind(null,st[1]),Th$1().memoizedState=st,[at,st]},useMutableSource:function(){},useSyncExternalStore:function(st,at,pt){var vt=M$3,wt=Th$1();if(I$3){if(pt===void 0)throw Error(p$3(407));pt=pt()}else{if(pt=at(),Q$2===null)throw Error(p$3(349));Hh$1&30||di$2(vt,at,pt)}wt.memoizedState=pt;var $t={value:pt,getSnapshot:at};return wt.queue=$t,mi$2(ai$1.bind(null,vt,$t,st),[st]),vt.flags|=2048,bi$1(9,ci$1.bind(null,vt,$t,pt,at),void 0,null),pt},useId:function(){var st=Th$1(),at=Q$2.identifierPrefix;if(I$3){var pt=sg$1,vt=rg$1;pt=(vt&~(1<<32-oc$2(vt)-1)).toString(32)+pt,at=":"+at+"R"+pt,pt=Kh$1++,0<pt&&(at+="H"+pt.toString(32)),at+=":"}else pt=Lh$1++,at=":"+at+"r"+pt.toString(32)+":";return st.memoizedState=at},unstable_isNewReconciler:!1},Ph$1={readContext:eh$1,useCallback:si$2,useContext:eh$1,useEffect:$h$1,useImperativeHandle:qi$2,useInsertionEffect:ni$1,useLayoutEffect:oi$1,useMemo:ti$1,useReducer:Wh$1,useRef:ji$2,useState:function(){return Wh$1(Vh$1)},useDebugValue:ri$1,useDeferredValue:function(st){var at=Uh$1();return ui$1(at,N$2.memoizedState,st)},useTransition:function(){var st=Wh$1(Vh$1)[0],at=Uh$1().memoizedState;return[st,at]},useMutableSource:Yh$1,useSyncExternalStore:Zh$1,useId:wi$1,unstable_isNewReconciler:!1},Qh$1={readContext:eh$1,useCallback:si$2,useContext:eh$1,useEffect:$h$1,useImperativeHandle:qi$2,useInsertionEffect:ni$1,useLayoutEffect:oi$1,useMemo:ti$1,useReducer:Xh$1,useRef:ji$2,useState:function(){return Xh$1(Vh$1)},useDebugValue:ri$1,useDeferredValue:function(st){var at=Uh$1();return N$2===null?at.memoizedState=st:ui$1(at,N$2.memoizedState,st)},useTransition:function(){var st=Xh$1(Vh$1)[0],at=Uh$1().memoizedState;return[st,at]},useMutableSource:Yh$1,useSyncExternalStore:Zh$1,useId:wi$1,unstable_isNewReconciler:!1};function Ci$1(st,at){if(st&&st.defaultProps){at=A$1({},at),st=st.defaultProps;for(var pt in st)at[pt]===void 0&&(at[pt]=st[pt]);return at}return at}function Di$2(st,at,pt,vt){at=st.memoizedState,pt=pt(vt,at),pt=pt==null?at:A$1({},at,pt),st.memoizedState=pt,st.lanes===0&&(st.updateQueue.baseState=pt)}var Ei$1={isMounted:function(st){return(st=st._reactInternals)?Vb$1(st)===st:!1},enqueueSetState:function(st,at,pt){st=st._reactInternals;var vt=R$2(),wt=yi$1(st),$t=mh$1(vt,wt);$t.payload=at,pt!=null&&($t.callback=pt),at=nh$1(st,$t,wt),at!==null&&(gi$1(at,st,wt,vt),oh$1(at,st,wt))},enqueueReplaceState:function(st,at,pt){st=st._reactInternals;var vt=R$2(),wt=yi$1(st),$t=mh$1(vt,wt);$t.tag=1,$t.payload=at,pt!=null&&($t.callback=pt),at=nh$1(st,$t,wt),at!==null&&(gi$1(at,st,wt,vt),oh$1(at,st,wt))},enqueueForceUpdate:function(st,at){st=st._reactInternals;var pt=R$2(),vt=yi$1(st),wt=mh$1(pt,vt);wt.tag=2,at!=null&&(wt.callback=at),at=nh$1(st,wt,vt),at!==null&&(gi$1(at,st,vt,pt),oh$1(at,st,vt))}};function Fi$2(st,at,pt,vt,wt,$t,Tt){return st=st.stateNode,typeof st.shouldComponentUpdate=="function"?st.shouldComponentUpdate(vt,$t,Tt):at.prototype&&at.prototype.isPureReactComponent?!Ie(pt,vt)||!Ie(wt,$t):!0}function Gi$2(st,at,pt){var vt=!1,wt=Vf$1,$t=at.contextType;return typeof $t=="object"&&$t!==null?$t=eh$1($t):(wt=Zf$1(at)?Xf$1:H$3.current,vt=at.contextTypes,$t=(vt=vt!=null)?Yf$1(st,wt):Vf$1),at=new at(pt,$t),st.memoizedState=at.state!==null&&at.state!==void 0?at.state:null,at.updater=Ei$1,st.stateNode=at,at._reactInternals=st,vt&&(st=st.stateNode,st.__reactInternalMemoizedUnmaskedChildContext=wt,st.__reactInternalMemoizedMaskedChildContext=$t),at}function Hi$2(st,at,pt,vt){st=at.state,typeof at.componentWillReceiveProps=="function"&&at.componentWillReceiveProps(pt,vt),typeof at.UNSAFE_componentWillReceiveProps=="function"&&at.UNSAFE_componentWillReceiveProps(pt,vt),at.state!==st&&Ei$1.enqueueReplaceState(at,at.state,null)}function Ii$1(st,at,pt,vt){var wt=st.stateNode;wt.props=pt,wt.state=st.memoizedState,wt.refs={},kh$1(st);var $t=at.contextType;typeof $t=="object"&&$t!==null?wt.context=eh$1($t):($t=Zf$1(at)?Xf$1:H$3.current,wt.context=Yf$1(st,$t)),wt.state=st.memoizedState,$t=at.getDerivedStateFromProps,typeof $t=="function"&&(Di$2(st,at,$t,pt),wt.state=st.memoizedState),typeof at.getDerivedStateFromProps=="function"||typeof wt.getSnapshotBeforeUpdate=="function"||typeof wt.UNSAFE_componentWillMount!="function"&&typeof wt.componentWillMount!="function"||(at=wt.state,typeof wt.componentWillMount=="function"&&wt.componentWillMount(),typeof wt.UNSAFE_componentWillMount=="function"&&wt.UNSAFE_componentWillMount(),at!==wt.state&&Ei$1.enqueueReplaceState(wt,wt.state,null),qh$1(st,pt,wt,vt),wt.state=st.memoizedState),typeof wt.componentDidMount=="function"&&(st.flags|=4194308)}function Ji$2(st,at){try{var pt="",vt=at;do pt+=Pa(vt),vt=vt.return;while(vt);var wt=pt}catch($t){wt=`
Error generating stack: `+$t.message+`
`+$t.stack}return{value:st,source:at,stack:wt,digest:null}}function Ki$2(st,at,pt){return{value:st,source:null,stack:pt??null,digest:at??null}}function Li$2(st,at){try{console.error(at.value)}catch(pt){setTimeout(function(){throw pt})}}var Mi$2=typeof WeakMap=="function"?WeakMap:Map;function Ni$1(st,at,pt){pt=mh$1(-1,pt),pt.tag=3,pt.payload={element:null};var vt=at.value;return pt.callback=function(){Oi$2||(Oi$2=!0,Pi$2=vt),Li$2(st,at)},pt}function Qi$2(st,at,pt){pt=mh$1(-1,pt),pt.tag=3;var vt=st.type.getDerivedStateFromError;if(typeof vt=="function"){var wt=at.value;pt.payload=function(){return vt(wt)},pt.callback=function(){Li$2(st,at)}}var $t=st.stateNode;return $t!==null&&typeof $t.componentDidCatch=="function"&&(pt.callback=function(){Li$2(st,at),typeof vt!="function"&&(Ri$2===null?Ri$2=new Set([this]):Ri$2.add(this));var Tt=at.stack;this.componentDidCatch(at.value,{componentStack:Tt!==null?Tt:""})}),pt}function Si$1(st,at,pt){var vt=st.pingCache;if(vt===null){vt=st.pingCache=new Mi$2;var wt=new Set;vt.set(at,wt)}else wt=vt.get(at),wt===void 0&&(wt=new Set,vt.set(at,wt));wt.has(pt)||(wt.add(pt),st=Ti$1.bind(null,st,at,pt),at.then(st,st))}function Ui$2(st){do{var at;if((at=st.tag===13)&&(at=st.memoizedState,at=at!==null?at.dehydrated!==null:!0),at)return st;st=st.return}while(st!==null);return null}function Vi$1(st,at,pt,vt,wt){return st.mode&1?(st.flags|=65536,st.lanes=wt,st):(st===at?st.flags|=65536:(st.flags|=128,pt.flags|=131072,pt.flags&=-52805,pt.tag===1&&(pt.alternate===null?pt.tag=17:(at=mh$1(-1,1),at.tag=2,nh$1(pt,at,1))),pt.lanes|=1),st)}var Wi$2=ua$2.ReactCurrentOwner,dh$1=!1;function Xi$2(st,at,pt,vt){at.child=st===null?Vg(at,null,pt,vt):Ug(at,st.child,pt,vt)}function Yi$2(st,at,pt,vt,wt){pt=pt.render;var $t=at.ref;return ch$1(at,wt),vt=Nh$1(st,at,pt,vt,$t,wt),pt=Sh$1(),st!==null&&!dh$1?(at.updateQueue=st.updateQueue,at.flags&=-2053,st.lanes&=~wt,Zi$2(st,at,wt)):(I$3&&pt&&vg$1(at),at.flags|=1,Xi$2(st,at,vt,wt),at.child)}function $i$1(st,at,pt,vt,wt){if(st===null){var $t=pt.type;return typeof $t=="function"&&!aj($t)&&$t.defaultProps===void 0&&pt.compare===null&&pt.defaultProps===void 0?(at.tag=15,at.type=$t,bj(st,at,$t,vt,wt)):(st=Rg(pt.type,null,vt,at,at.mode,wt),st.ref=at.ref,st.return=at,at.child=st)}if($t=st.child,!(st.lanes&wt)){var Tt=$t.memoizedProps;if(pt=pt.compare,pt=pt!==null?pt:Ie,pt(Tt,vt)&&st.ref===at.ref)return Zi$2(st,at,wt)}return at.flags|=1,st=Pg($t,vt),st.ref=at.ref,st.return=at,at.child=st}function bj(st,at,pt,vt,wt){if(st!==null){var $t=st.memoizedProps;if(Ie($t,vt)&&st.ref===at.ref)if(dh$1=!1,at.pendingProps=vt=$t,(st.lanes&wt)!==0)st.flags&131072&&(dh$1=!0);else return at.lanes=st.lanes,Zi$2(st,at,wt)}return cj(st,at,pt,vt,wt)}function dj(st,at,pt){var vt=at.pendingProps,wt=vt.children,$t=st!==null?st.memoizedState:null;if(vt.mode==="hidden")if(!(at.mode&1))at.memoizedState={baseLanes:0,cachePool:null,transitions:null},G$1(ej,fj),fj|=pt;else{if(!(pt&1073741824))return st=$t!==null?$t.baseLanes|pt:pt,at.lanes=at.childLanes=1073741824,at.memoizedState={baseLanes:st,cachePool:null,transitions:null},at.updateQueue=null,G$1(ej,fj),fj|=st,null;at.memoizedState={baseLanes:0,cachePool:null,transitions:null},vt=$t!==null?$t.baseLanes:pt,G$1(ej,fj),fj|=vt}else $t!==null?(vt=$t.baseLanes|pt,at.memoizedState=null):vt=pt,G$1(ej,fj),fj|=vt;return Xi$2(st,at,wt,pt),at.child}function gj(st,at){var pt=at.ref;(st===null&&pt!==null||st!==null&&st.ref!==pt)&&(at.flags|=512,at.flags|=2097152)}function cj(st,at,pt,vt,wt){var $t=Zf$1(pt)?Xf$1:H$3.current;return $t=Yf$1(at,$t),ch$1(at,wt),pt=Nh$1(st,at,pt,vt,$t,wt),vt=Sh$1(),st!==null&&!dh$1?(at.updateQueue=st.updateQueue,at.flags&=-2053,st.lanes&=~wt,Zi$2(st,at,wt)):(I$3&&vt&&vg$1(at),at.flags|=1,Xi$2(st,at,pt,wt),at.child)}function hj(st,at,pt,vt,wt){if(Zf$1(pt)){var $t=!0;cg$1(at)}else $t=!1;if(ch$1(at,wt),at.stateNode===null)ij(st,at),Gi$2(at,pt,vt),Ii$1(at,pt,vt,wt),vt=!0;else if(st===null){var Tt=at.stateNode,Lt=at.memoizedProps;Tt.props=Lt;var Ft=Tt.context,Ct=pt.contextType;typeof Ct=="object"&&Ct!==null?Ct=eh$1(Ct):(Ct=Zf$1(pt)?Xf$1:H$3.current,Ct=Yf$1(at,Ct));var Ht=pt.getDerivedStateFromProps,Gt=typeof Ht=="function"||typeof Tt.getSnapshotBeforeUpdate=="function";Gt||typeof Tt.UNSAFE_componentWillReceiveProps!="function"&&typeof Tt.componentWillReceiveProps!="function"||(Lt!==vt||Ft!==Ct)&&Hi$2(at,Tt,vt,Ct),jh$1=!1;var jt=at.memoizedState;Tt.state=jt,qh$1(at,vt,Tt,wt),Ft=at.memoizedState,Lt!==vt||jt!==Ft||Wf$1.current||jh$1?(typeof Ht=="function"&&(Di$2(at,pt,Ht,vt),Ft=at.memoizedState),(Lt=jh$1||Fi$2(at,pt,Lt,vt,jt,Ft,Ct))?(Gt||typeof Tt.UNSAFE_componentWillMount!="function"&&typeof Tt.componentWillMount!="function"||(typeof Tt.componentWillMount=="function"&&Tt.componentWillMount(),typeof Tt.UNSAFE_componentWillMount=="function"&&Tt.UNSAFE_componentWillMount()),typeof Tt.componentDidMount=="function"&&(at.flags|=4194308)):(typeof Tt.componentDidMount=="function"&&(at.flags|=4194308),at.memoizedProps=vt,at.memoizedState=Ft),Tt.props=vt,Tt.state=Ft,Tt.context=Ct,vt=Lt):(typeof Tt.componentDidMount=="function"&&(at.flags|=4194308),vt=!1)}else{Tt=at.stateNode,lh$1(st,at),Lt=at.memoizedProps,Ct=at.type===at.elementType?Lt:Ci$1(at.type,Lt),Tt.props=Ct,Gt=at.pendingProps,jt=Tt.context,Ft=pt.contextType,typeof Ft=="object"&&Ft!==null?Ft=eh$1(Ft):(Ft=Zf$1(pt)?Xf$1:H$3.current,Ft=Yf$1(at,Ft));var qt=pt.getDerivedStateFromProps;(Ht=typeof qt=="function"||typeof Tt.getSnapshotBeforeUpdate=="function")||typeof Tt.UNSAFE_componentWillReceiveProps!="function"&&typeof Tt.componentWillReceiveProps!="function"||(Lt!==Gt||jt!==Ft)&&Hi$2(at,Tt,vt,Ft),jh$1=!1,jt=at.memoizedState,Tt.state=jt,qh$1(at,vt,Tt,wt);var Kt=at.memoizedState;Lt!==Gt||jt!==Kt||Wf$1.current||jh$1?(typeof qt=="function"&&(Di$2(at,pt,qt,vt),Kt=at.memoizedState),(Ct=jh$1||Fi$2(at,pt,Ct,vt,jt,Kt,Ft)||!1)?(Ht||typeof Tt.UNSAFE_componentWillUpdate!="function"&&typeof Tt.componentWillUpdate!="function"||(typeof Tt.componentWillUpdate=="function"&&Tt.componentWillUpdate(vt,Kt,Ft),typeof Tt.UNSAFE_componentWillUpdate=="function"&&Tt.UNSAFE_componentWillUpdate(vt,Kt,Ft)),typeof Tt.componentDidUpdate=="function"&&(at.flags|=4),typeof Tt.getSnapshotBeforeUpdate=="function"&&(at.flags|=1024)):(typeof Tt.componentDidUpdate!="function"||Lt===st.memoizedProps&&jt===st.memoizedState||(at.flags|=4),typeof Tt.getSnapshotBeforeUpdate!="function"||Lt===st.memoizedProps&&jt===st.memoizedState||(at.flags|=1024),at.memoizedProps=vt,at.memoizedState=Kt),Tt.props=vt,Tt.state=Kt,Tt.context=Ft,vt=Ct):(typeof Tt.componentDidUpdate!="function"||Lt===st.memoizedProps&&jt===st.memoizedState||(at.flags|=4),typeof Tt.getSnapshotBeforeUpdate!="function"||Lt===st.memoizedProps&&jt===st.memoizedState||(at.flags|=1024),vt=!1)}return jj(st,at,pt,vt,$t,wt)}function jj(st,at,pt,vt,wt,$t){gj(st,at);var Tt=(at.flags&128)!==0;if(!vt&&!Tt)return wt&&dg$1(at,pt,!1),Zi$2(st,at,$t);vt=at.stateNode,Wi$2.current=at;var Lt=Tt&&typeof pt.getDerivedStateFromError!="function"?null:vt.render();return at.flags|=1,st!==null&&Tt?(at.child=Ug(at,st.child,null,$t),at.child=Ug(at,null,Lt,$t)):Xi$2(st,at,Lt,$t),at.memoizedState=vt.state,wt&&dg$1(at,pt,!0),at.child}function kj(st){var at=st.stateNode;at.pendingContext?ag(st,at.pendingContext,at.pendingContext!==at.context):at.context&&ag(st,at.context,!1),yh$1(st,at.containerInfo)}function lj(st,at,pt,vt,wt){return Ig(),Jg(wt),at.flags|=256,Xi$2(st,at,pt,vt),at.child}var mj={dehydrated:null,treeContext:null,retryLane:0};function nj(st){return{baseLanes:st,cachePool:null,transitions:null}}function oj(st,at,pt){var vt=at.pendingProps,wt=L$3.current,$t=!1,Tt=(at.flags&128)!==0,Lt;if((Lt=Tt)||(Lt=st!==null&&st.memoizedState===null?!1:(wt&2)!==0),Lt?($t=!0,at.flags&=-129):(st===null||st.memoizedState!==null)&&(wt|=1),G$1(L$3,wt&1),st===null)return Eg(at),st=at.memoizedState,st!==null&&(st=st.dehydrated,st!==null)?(at.mode&1?st.data==="$!"?at.lanes=8:at.lanes=1073741824:at.lanes=1,null):(Tt=vt.children,st=vt.fallback,$t?(vt=at.mode,$t=at.child,Tt={mode:"hidden",children:Tt},!(vt&1)&&$t!==null?($t.childLanes=0,$t.pendingProps=Tt):$t=pj(Tt,vt,0,null),st=Tg$1(st,vt,pt,null),$t.return=at,st.return=at,$t.sibling=st,at.child=$t,at.child.memoizedState=nj(pt),at.memoizedState=mj,st):qj(at,Tt));if(wt=st.memoizedState,wt!==null&&(Lt=wt.dehydrated,Lt!==null))return rj(st,at,Tt,vt,Lt,wt,pt);if($t){$t=vt.fallback,Tt=at.mode,wt=st.child,Lt=wt.sibling;var Ft={mode:"hidden",children:vt.children};return!(Tt&1)&&at.child!==wt?(vt=at.child,vt.childLanes=0,vt.pendingProps=Ft,at.deletions=null):(vt=Pg(wt,Ft),vt.subtreeFlags=wt.subtreeFlags&14680064),Lt!==null?$t=Pg(Lt,$t):($t=Tg$1($t,Tt,pt,null),$t.flags|=2),$t.return=at,vt.return=at,vt.sibling=$t,at.child=vt,vt=$t,$t=at.child,Tt=st.child.memoizedState,Tt=Tt===null?nj(pt):{baseLanes:Tt.baseLanes|pt,cachePool:null,transitions:Tt.transitions},$t.memoizedState=Tt,$t.childLanes=st.childLanes&~pt,at.memoizedState=mj,vt}return $t=st.child,st=$t.sibling,vt=Pg($t,{mode:"visible",children:vt.children}),!(at.mode&1)&&(vt.lanes=pt),vt.return=at,vt.sibling=null,st!==null&&(pt=at.deletions,pt===null?(at.deletions=[st],at.flags|=16):pt.push(st)),at.child=vt,at.memoizedState=null,vt}function qj(st,at){return at=pj({mode:"visible",children:at},st.mode,0,null),at.return=st,st.child=at}function sj(st,at,pt,vt){return vt!==null&&Jg(vt),Ug(at,st.child,null,pt),st=qj(at,at.pendingProps.children),st.flags|=2,at.memoizedState=null,st}function rj(st,at,pt,vt,wt,$t,Tt){if(pt)return at.flags&256?(at.flags&=-257,vt=Ki$2(Error(p$3(422))),sj(st,at,Tt,vt)):at.memoizedState!==null?(at.child=st.child,at.flags|=128,null):($t=vt.fallback,wt=at.mode,vt=pj({mode:"visible",children:vt.children},wt,0,null),$t=Tg$1($t,wt,Tt,null),$t.flags|=2,vt.return=at,$t.return=at,vt.sibling=$t,at.child=vt,at.mode&1&&Ug(at,st.child,null,Tt),at.child.memoizedState=nj(Tt),at.memoizedState=mj,$t);if(!(at.mode&1))return sj(st,at,Tt,null);if(wt.data==="$!"){if(vt=wt.nextSibling&&wt.nextSibling.dataset,vt)var Lt=vt.dgst;return vt=Lt,$t=Error(p$3(419)),vt=Ki$2($t,vt,void 0),sj(st,at,Tt,vt)}if(Lt=(Tt&st.childLanes)!==0,dh$1||Lt){if(vt=Q$2,vt!==null){switch(Tt&-Tt){case 4:wt=2;break;case 16:wt=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:wt=32;break;case 536870912:wt=268435456;break;default:wt=0}wt=wt&(vt.suspendedLanes|Tt)?0:wt,wt!==0&&wt!==$t.retryLane&&($t.retryLane=wt,ih$1(st,wt),gi$1(vt,st,wt,-1))}return tj(),vt=Ki$2(Error(p$3(421))),sj(st,at,Tt,vt)}return wt.data==="$?"?(at.flags|=128,at.child=st.child,at=uj.bind(null,st),wt._reactRetry=at,null):(st=$t.treeContext,yg=Lf$1(wt.nextSibling),xg$1=at,I$3=!0,zg=null,st!==null&&(og$1[pg$1++]=rg$1,og$1[pg$1++]=sg$1,og$1[pg$1++]=qg,rg$1=st.id,sg$1=st.overflow,qg=at),at=qj(at,vt.children),at.flags|=4096,at)}function vj(st,at,pt){st.lanes|=at;var vt=st.alternate;vt!==null&&(vt.lanes|=at),bh$1(st.return,at,pt)}function wj(st,at,pt,vt,wt){var $t=st.memoizedState;$t===null?st.memoizedState={isBackwards:at,rendering:null,renderingStartTime:0,last:vt,tail:pt,tailMode:wt}:($t.isBackwards=at,$t.rendering=null,$t.renderingStartTime=0,$t.last=vt,$t.tail=pt,$t.tailMode=wt)}function xj(st,at,pt){var vt=at.pendingProps,wt=vt.revealOrder,$t=vt.tail;if(Xi$2(st,at,vt.children,pt),vt=L$3.current,vt&2)vt=vt&1|2,at.flags|=128;else{if(st!==null&&st.flags&128)e:for(st=at.child;st!==null;){if(st.tag===13)st.memoizedState!==null&&vj(st,pt,at);else if(st.tag===19)vj(st,pt,at);else if(st.child!==null){st.child.return=st,st=st.child;continue}if(st===at)break e;for(;st.sibling===null;){if(st.return===null||st.return===at)break e;st=st.return}st.sibling.return=st.return,st=st.sibling}vt&=1}if(G$1(L$3,vt),!(at.mode&1))at.memoizedState=null;else switch(wt){case"forwards":for(pt=at.child,wt=null;pt!==null;)st=pt.alternate,st!==null&&Ch$1(st)===null&&(wt=pt),pt=pt.sibling;pt=wt,pt===null?(wt=at.child,at.child=null):(wt=pt.sibling,pt.sibling=null),wj(at,!1,wt,pt,$t);break;case"backwards":for(pt=null,wt=at.child,at.child=null;wt!==null;){if(st=wt.alternate,st!==null&&Ch$1(st)===null){at.child=wt;break}st=wt.sibling,wt.sibling=pt,pt=wt,wt=st}wj(at,!0,pt,null,$t);break;case"together":wj(at,!1,null,null,void 0);break;default:at.memoizedState=null}return at.child}function ij(st,at){!(at.mode&1)&&st!==null&&(st.alternate=null,at.alternate=null,at.flags|=2)}function Zi$2(st,at,pt){if(st!==null&&(at.dependencies=st.dependencies),rh$1|=at.lanes,!(pt&at.childLanes))return null;if(st!==null&&at.child!==st.child)throw Error(p$3(153));if(at.child!==null){for(st=at.child,pt=Pg(st,st.pendingProps),at.child=pt,pt.return=at;st.sibling!==null;)st=st.sibling,pt=pt.sibling=Pg(st,st.pendingProps),pt.return=at;pt.sibling=null}return at.child}function yj(st,at,pt){switch(at.tag){case 3:kj(at),Ig();break;case 5:Ah$1(at);break;case 1:Zf$1(at.type)&&cg$1(at);break;case 4:yh$1(at,at.stateNode.containerInfo);break;case 10:var vt=at.type._context,wt=at.memoizedProps.value;G$1(Wg,vt._currentValue),vt._currentValue=wt;break;case 13:if(vt=at.memoizedState,vt!==null)return vt.dehydrated!==null?(G$1(L$3,L$3.current&1),at.flags|=128,null):pt&at.child.childLanes?oj(st,at,pt):(G$1(L$3,L$3.current&1),st=Zi$2(st,at,pt),st!==null?st.sibling:null);G$1(L$3,L$3.current&1);break;case 19:if(vt=(pt&at.childLanes)!==0,st.flags&128){if(vt)return xj(st,at,pt);at.flags|=128}if(wt=at.memoizedState,wt!==null&&(wt.rendering=null,wt.tail=null,wt.lastEffect=null),G$1(L$3,L$3.current),vt)break;return null;case 22:case 23:return at.lanes=0,dj(st,at,pt)}return Zi$2(st,at,pt)}var zj,Aj,Bj,Cj;zj=function(st,at){for(var pt=at.child;pt!==null;){if(pt.tag===5||pt.tag===6)st.appendChild(pt.stateNode);else if(pt.tag!==4&&pt.child!==null){pt.child.return=pt,pt=pt.child;continue}if(pt===at)break;for(;pt.sibling===null;){if(pt.return===null||pt.return===at)return;pt=pt.return}pt.sibling.return=pt.return,pt=pt.sibling}};Aj=function(){};Bj=function(st,at,pt,vt){var wt=st.memoizedProps;if(wt!==vt){st=at.stateNode,xh$1(uh$1.current);var $t=null;switch(pt){case"input":wt=Ya$2(st,wt),vt=Ya$2(st,vt),$t=[];break;case"select":wt=A$1({},wt,{value:void 0}),vt=A$1({},vt,{value:void 0}),$t=[];break;case"textarea":wt=gb$1(st,wt),vt=gb$1(st,vt),$t=[];break;default:typeof wt.onClick!="function"&&typeof vt.onClick=="function"&&(st.onclick=Bf$1)}ub$1(pt,vt);var Tt;pt=null;for(Ct in wt)if(!vt.hasOwnProperty(Ct)&&wt.hasOwnProperty(Ct)&&wt[Ct]!=null)if(Ct==="style"){var Lt=wt[Ct];for(Tt in Lt)Lt.hasOwnProperty(Tt)&&(pt||(pt={}),pt[Tt]="")}else Ct!=="dangerouslySetInnerHTML"&&Ct!=="children"&&Ct!=="suppressContentEditableWarning"&&Ct!=="suppressHydrationWarning"&&Ct!=="autoFocus"&&(ea$1.hasOwnProperty(Ct)?$t||($t=[]):($t=$t||[]).push(Ct,null));for(Ct in vt){var Ft=vt[Ct];if(Lt=wt!=null?wt[Ct]:void 0,vt.hasOwnProperty(Ct)&&Ft!==Lt&&(Ft!=null||Lt!=null))if(Ct==="style")if(Lt){for(Tt in Lt)!Lt.hasOwnProperty(Tt)||Ft&&Ft.hasOwnProperty(Tt)||(pt||(pt={}),pt[Tt]="");for(Tt in Ft)Ft.hasOwnProperty(Tt)&&Lt[Tt]!==Ft[Tt]&&(pt||(pt={}),pt[Tt]=Ft[Tt])}else pt||($t||($t=[]),$t.push(Ct,pt)),pt=Ft;else Ct==="dangerouslySetInnerHTML"?(Ft=Ft?Ft.__html:void 0,Lt=Lt?Lt.__html:void 0,Ft!=null&&Lt!==Ft&&($t=$t||[]).push(Ct,Ft)):Ct==="children"?typeof Ft!="string"&&typeof Ft!="number"||($t=$t||[]).push(Ct,""+Ft):Ct!=="suppressContentEditableWarning"&&Ct!=="suppressHydrationWarning"&&(ea$1.hasOwnProperty(Ct)?(Ft!=null&&Ct==="onScroll"&&D$1("scroll",st),$t||Lt===Ft||($t=[])):($t=$t||[]).push(Ct,Ft))}pt&&($t=$t||[]).push("style",pt);var Ct=$t;(at.updateQueue=Ct)&&(at.flags|=4)}};Cj=function(st,at,pt,vt){pt!==vt&&(at.flags|=4)};function Dj(st,at){if(!I$3)switch(st.tailMode){case"hidden":at=st.tail;for(var pt=null;at!==null;)at.alternate!==null&&(pt=at),at=at.sibling;pt===null?st.tail=null:pt.sibling=null;break;case"collapsed":pt=st.tail;for(var vt=null;pt!==null;)pt.alternate!==null&&(vt=pt),pt=pt.sibling;vt===null?at||st.tail===null?st.tail=null:st.tail.sibling=null:vt.sibling=null}}function S$3(st){var at=st.alternate!==null&&st.alternate.child===st.child,pt=0,vt=0;if(at)for(var wt=st.child;wt!==null;)pt|=wt.lanes|wt.childLanes,vt|=wt.subtreeFlags&14680064,vt|=wt.flags&14680064,wt.return=st,wt=wt.sibling;else for(wt=st.child;wt!==null;)pt|=wt.lanes|wt.childLanes,vt|=wt.subtreeFlags,vt|=wt.flags,wt.return=st,wt=wt.sibling;return st.subtreeFlags|=vt,st.childLanes=pt,at}function Ej(st,at,pt){var vt=at.pendingProps;switch(wg$1(at),at.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S$3(at),null;case 1:return Zf$1(at.type)&&$f$1(),S$3(at),null;case 3:return vt=at.stateNode,zh$1(),E$1(Wf$1),E$1(H$3),Eh$1(),vt.pendingContext&&(vt.context=vt.pendingContext,vt.pendingContext=null),(st===null||st.child===null)&&(Gg(at)?at.flags|=4:st===null||st.memoizedState.isDehydrated&&!(at.flags&256)||(at.flags|=1024,zg!==null&&(Fj(zg),zg=null))),Aj(st,at),S$3(at),null;case 5:Bh$1(at);var wt=xh$1(wh$1.current);if(pt=at.type,st!==null&&at.stateNode!=null)Bj(st,at,pt,vt,wt),st.ref!==at.ref&&(at.flags|=512,at.flags|=2097152);else{if(!vt){if(at.stateNode===null)throw Error(p$3(166));return S$3(at),null}if(st=xh$1(uh$1.current),Gg(at)){vt=at.stateNode,pt=at.type;var $t=at.memoizedProps;switch(vt[Of$1]=at,vt[Pf$1]=$t,st=(at.mode&1)!==0,pt){case"dialog":D$1("cancel",vt),D$1("close",vt);break;case"iframe":case"object":case"embed":D$1("load",vt);break;case"video":case"audio":for(wt=0;wt<lf$2.length;wt++)D$1(lf$2[wt],vt);break;case"source":D$1("error",vt);break;case"img":case"image":case"link":D$1("error",vt),D$1("load",vt);break;case"details":D$1("toggle",vt);break;case"input":Za$2(vt,$t),D$1("invalid",vt);break;case"select":vt._wrapperState={wasMultiple:!!$t.multiple},D$1("invalid",vt);break;case"textarea":hb$1(vt,$t),D$1("invalid",vt)}ub$1(pt,$t),wt=null;for(var Tt in $t)if($t.hasOwnProperty(Tt)){var Lt=$t[Tt];Tt==="children"?typeof Lt=="string"?vt.textContent!==Lt&&($t.suppressHydrationWarning!==!0&&Af$1(vt.textContent,Lt,st),wt=["children",Lt]):typeof Lt=="number"&&vt.textContent!==""+Lt&&($t.suppressHydrationWarning!==!0&&Af$1(vt.textContent,Lt,st),wt=["children",""+Lt]):ea$1.hasOwnProperty(Tt)&&Lt!=null&&Tt==="onScroll"&&D$1("scroll",vt)}switch(pt){case"input":Va$2(vt),db$1(vt,$t,!0);break;case"textarea":Va$2(vt),jb$1(vt);break;case"select":case"option":break;default:typeof $t.onClick=="function"&&(vt.onclick=Bf$1)}vt=wt,at.updateQueue=vt,vt!==null&&(at.flags|=4)}else{Tt=wt.nodeType===9?wt:wt.ownerDocument,st==="http://www.w3.org/1999/xhtml"&&(st=kb$1(pt)),st==="http://www.w3.org/1999/xhtml"?pt==="script"?(st=Tt.createElement("div"),st.innerHTML="<script><\/script>",st=st.removeChild(st.firstChild)):typeof vt.is=="string"?st=Tt.createElement(pt,{is:vt.is}):(st=Tt.createElement(pt),pt==="select"&&(Tt=st,vt.multiple?Tt.multiple=!0:vt.size&&(Tt.size=vt.size))):st=Tt.createElementNS(st,pt),st[Of$1]=at,st[Pf$1]=vt,zj(st,at,!1,!1),at.stateNode=st;e:{switch(Tt=vb$1(pt,vt),pt){case"dialog":D$1("cancel",st),D$1("close",st),wt=vt;break;case"iframe":case"object":case"embed":D$1("load",st),wt=vt;break;case"video":case"audio":for(wt=0;wt<lf$2.length;wt++)D$1(lf$2[wt],st);wt=vt;break;case"source":D$1("error",st),wt=vt;break;case"img":case"image":case"link":D$1("error",st),D$1("load",st),wt=vt;break;case"details":D$1("toggle",st),wt=vt;break;case"input":Za$2(st,vt),wt=Ya$2(st,vt),D$1("invalid",st);break;case"option":wt=vt;break;case"select":st._wrapperState={wasMultiple:!!vt.multiple},wt=A$1({},vt,{value:void 0}),D$1("invalid",st);break;case"textarea":hb$1(st,vt),wt=gb$1(st,vt),D$1("invalid",st);break;default:wt=vt}ub$1(pt,wt),Lt=wt;for($t in Lt)if(Lt.hasOwnProperty($t)){var Ft=Lt[$t];$t==="style"?sb$1(st,Ft):$t==="dangerouslySetInnerHTML"?(Ft=Ft?Ft.__html:void 0,Ft!=null&&nb$1(st,Ft)):$t==="children"?typeof Ft=="string"?(pt!=="textarea"||Ft!=="")&&ob$1(st,Ft):typeof Ft=="number"&&ob$1(st,""+Ft):$t!=="suppressContentEditableWarning"&&$t!=="suppressHydrationWarning"&&$t!=="autoFocus"&&(ea$1.hasOwnProperty($t)?Ft!=null&&$t==="onScroll"&&D$1("scroll",st):Ft!=null&&ta$1(st,$t,Ft,Tt))}switch(pt){case"input":Va$2(st),db$1(st,vt,!1);break;case"textarea":Va$2(st),jb$1(st);break;case"option":vt.value!=null&&st.setAttribute("value",""+Sa$1(vt.value));break;case"select":st.multiple=!!vt.multiple,$t=vt.value,$t!=null?fb$1(st,!!vt.multiple,$t,!1):vt.defaultValue!=null&&fb$1(st,!!vt.multiple,vt.defaultValue,!0);break;default:typeof wt.onClick=="function"&&(st.onclick=Bf$1)}switch(pt){case"button":case"input":case"select":case"textarea":vt=!!vt.autoFocus;break e;case"img":vt=!0;break e;default:vt=!1}}vt&&(at.flags|=4)}at.ref!==null&&(at.flags|=512,at.flags|=2097152)}return S$3(at),null;case 6:if(st&&at.stateNode!=null)Cj(st,at,st.memoizedProps,vt);else{if(typeof vt!="string"&&at.stateNode===null)throw Error(p$3(166));if(pt=xh$1(wh$1.current),xh$1(uh$1.current),Gg(at)){if(vt=at.stateNode,pt=at.memoizedProps,vt[Of$1]=at,($t=vt.nodeValue!==pt)&&(st=xg$1,st!==null))switch(st.tag){case 3:Af$1(vt.nodeValue,pt,(st.mode&1)!==0);break;case 5:st.memoizedProps.suppressHydrationWarning!==!0&&Af$1(vt.nodeValue,pt,(st.mode&1)!==0)}$t&&(at.flags|=4)}else vt=(pt.nodeType===9?pt:pt.ownerDocument).createTextNode(vt),vt[Of$1]=at,at.stateNode=vt}return S$3(at),null;case 13:if(E$1(L$3),vt=at.memoizedState,st===null||st.memoizedState!==null&&st.memoizedState.dehydrated!==null){if(I$3&&yg!==null&&at.mode&1&&!(at.flags&128))Hg(),Ig(),at.flags|=98560,$t=!1;else if($t=Gg(at),vt!==null&&vt.dehydrated!==null){if(st===null){if(!$t)throw Error(p$3(318));if($t=at.memoizedState,$t=$t!==null?$t.dehydrated:null,!$t)throw Error(p$3(317));$t[Of$1]=at}else Ig(),!(at.flags&128)&&(at.memoizedState=null),at.flags|=4;S$3(at),$t=!1}else zg!==null&&(Fj(zg),zg=null),$t=!0;if(!$t)return at.flags&65536?at:null}return at.flags&128?(at.lanes=pt,at):(vt=vt!==null,vt!==(st!==null&&st.memoizedState!==null)&&vt&&(at.child.flags|=8192,at.mode&1&&(st===null||L$3.current&1?T$2===0&&(T$2=3):tj())),at.updateQueue!==null&&(at.flags|=4),S$3(at),null);case 4:return zh$1(),Aj(st,at),st===null&&sf$2(at.stateNode.containerInfo),S$3(at),null;case 10:return ah(at.type._context),S$3(at),null;case 17:return Zf$1(at.type)&&$f$1(),S$3(at),null;case 19:if(E$1(L$3),$t=at.memoizedState,$t===null)return S$3(at),null;if(vt=(at.flags&128)!==0,Tt=$t.rendering,Tt===null)if(vt)Dj($t,!1);else{if(T$2!==0||st!==null&&st.flags&128)for(st=at.child;st!==null;){if(Tt=Ch$1(st),Tt!==null){for(at.flags|=128,Dj($t,!1),vt=Tt.updateQueue,vt!==null&&(at.updateQueue=vt,at.flags|=4),at.subtreeFlags=0,vt=pt,pt=at.child;pt!==null;)$t=pt,st=vt,$t.flags&=14680066,Tt=$t.alternate,Tt===null?($t.childLanes=0,$t.lanes=st,$t.child=null,$t.subtreeFlags=0,$t.memoizedProps=null,$t.memoizedState=null,$t.updateQueue=null,$t.dependencies=null,$t.stateNode=null):($t.childLanes=Tt.childLanes,$t.lanes=Tt.lanes,$t.child=Tt.child,$t.subtreeFlags=0,$t.deletions=null,$t.memoizedProps=Tt.memoizedProps,$t.memoizedState=Tt.memoizedState,$t.updateQueue=Tt.updateQueue,$t.type=Tt.type,st=Tt.dependencies,$t.dependencies=st===null?null:{lanes:st.lanes,firstContext:st.firstContext}),pt=pt.sibling;return G$1(L$3,L$3.current&1|2),at.child}st=st.sibling}$t.tail!==null&&B$2()>Gj&&(at.flags|=128,vt=!0,Dj($t,!1),at.lanes=4194304)}else{if(!vt)if(st=Ch$1(Tt),st!==null){if(at.flags|=128,vt=!0,pt=st.updateQueue,pt!==null&&(at.updateQueue=pt,at.flags|=4),Dj($t,!0),$t.tail===null&&$t.tailMode==="hidden"&&!Tt.alternate&&!I$3)return S$3(at),null}else 2*B$2()-$t.renderingStartTime>Gj&&pt!==1073741824&&(at.flags|=128,vt=!0,Dj($t,!1),at.lanes=4194304);$t.isBackwards?(Tt.sibling=at.child,at.child=Tt):(pt=$t.last,pt!==null?pt.sibling=Tt:at.child=Tt,$t.last=Tt)}return $t.tail!==null?(at=$t.tail,$t.rendering=at,$t.tail=at.sibling,$t.renderingStartTime=B$2(),at.sibling=null,pt=L$3.current,G$1(L$3,vt?pt&1|2:pt&1),at):(S$3(at),null);case 22:case 23:return Hj(),vt=at.memoizedState!==null,st!==null&&st.memoizedState!==null!==vt&&(at.flags|=8192),vt&&at.mode&1?fj&1073741824&&(S$3(at),at.subtreeFlags&6&&(at.flags|=8192)):S$3(at),null;case 24:return null;case 25:return null}throw Error(p$3(156,at.tag))}function Ij(st,at){switch(wg$1(at),at.tag){case 1:return Zf$1(at.type)&&$f$1(),st=at.flags,st&65536?(at.flags=st&-65537|128,at):null;case 3:return zh$1(),E$1(Wf$1),E$1(H$3),Eh$1(),st=at.flags,st&65536&&!(st&128)?(at.flags=st&-65537|128,at):null;case 5:return Bh$1(at),null;case 13:if(E$1(L$3),st=at.memoizedState,st!==null&&st.dehydrated!==null){if(at.alternate===null)throw Error(p$3(340));Ig()}return st=at.flags,st&65536?(at.flags=st&-65537|128,at):null;case 19:return E$1(L$3),null;case 4:return zh$1(),null;case 10:return ah(at.type._context),null;case 22:case 23:return Hj(),null;case 24:return null;default:return null}}var Jj=!1,U$4=!1,Kj=typeof WeakSet=="function"?WeakSet:Set,V$4=null;function Lj(st,at){var pt=st.ref;if(pt!==null)if(typeof pt=="function")try{pt(null)}catch(vt){W$1(st,at,vt)}else pt.current=null}function Mj(st,at,pt){try{pt()}catch(vt){W$1(st,at,vt)}}var Nj=!1;function Oj(st,at){if(Cf$1=dd$2,st=Me$2(),Ne$2(st)){if("selectionStart"in st)var pt={start:st.selectionStart,end:st.selectionEnd};else e:{pt=(pt=st.ownerDocument)&&pt.defaultView||window;var vt=pt.getSelection&&pt.getSelection();if(vt&&vt.rangeCount!==0){pt=vt.anchorNode;var wt=vt.anchorOffset,$t=vt.focusNode;vt=vt.focusOffset;try{pt.nodeType,$t.nodeType}catch{pt=null;break e}var Tt=0,Lt=-1,Ft=-1,Ct=0,Ht=0,Gt=st,jt=null;t:for(;;){for(var qt;Gt!==pt||wt!==0&&Gt.nodeType!==3||(Lt=Tt+wt),Gt!==$t||vt!==0&&Gt.nodeType!==3||(Ft=Tt+vt),Gt.nodeType===3&&(Tt+=Gt.nodeValue.length),(qt=Gt.firstChild)!==null;)jt=Gt,Gt=qt;for(;;){if(Gt===st)break t;if(jt===pt&&++Ct===wt&&(Lt=Tt),jt===$t&&++Ht===vt&&(Ft=Tt),(qt=Gt.nextSibling)!==null)break;Gt=jt,jt=Gt.parentNode}Gt=qt}pt=Lt===-1||Ft===-1?null:{start:Lt,end:Ft}}else pt=null}pt=pt||{start:0,end:0}}else pt=null;for(Df$1={focusedElem:st,selectionRange:pt},dd$2=!1,V$4=at;V$4!==null;)if(at=V$4,st=at.child,(at.subtreeFlags&1028)!==0&&st!==null)st.return=at,V$4=st;else for(;V$4!==null;){at=V$4;try{var Kt=at.alternate;if(at.flags&1024)switch(at.tag){case 0:case 11:case 15:break;case 1:if(Kt!==null){var An=Kt.memoizedProps,Sn=Kt.memoizedState,wn=at.stateNode,In=wn.getSnapshotBeforeUpdate(at.elementType===at.type?An:Ci$1(at.type,An),Sn);wn.__reactInternalSnapshotBeforeUpdate=In}break;case 3:var tr=at.stateNode.containerInfo;tr.nodeType===1?tr.textContent="":tr.nodeType===9&&tr.documentElement&&tr.removeChild(tr.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p$3(163))}}catch(rr){W$1(at,at.return,rr)}if(st=at.sibling,st!==null){st.return=at.return,V$4=st;break}V$4=at.return}return Kt=Nj,Nj=!1,Kt}function Pj(st,at,pt){var vt=at.updateQueue;if(vt=vt!==null?vt.lastEffect:null,vt!==null){var wt=vt=vt.next;do{if((wt.tag&st)===st){var $t=wt.destroy;wt.destroy=void 0,$t!==void 0&&Mj(at,pt,$t)}wt=wt.next}while(wt!==vt)}}function Qj(st,at){if(at=at.updateQueue,at=at!==null?at.lastEffect:null,at!==null){var pt=at=at.next;do{if((pt.tag&st)===st){var vt=pt.create;pt.destroy=vt()}pt=pt.next}while(pt!==at)}}function Rj(st){var at=st.ref;if(at!==null){var pt=st.stateNode;switch(st.tag){case 5:st=pt;break;default:st=pt}typeof at=="function"?at(st):at.current=st}}function Sj(st){var at=st.alternate;at!==null&&(st.alternate=null,Sj(at)),st.child=null,st.deletions=null,st.sibling=null,st.tag===5&&(at=st.stateNode,at!==null&&(delete at[Of$1],delete at[Pf$1],delete at[of$2],delete at[Qf$1],delete at[Rf$1])),st.stateNode=null,st.return=null,st.dependencies=null,st.memoizedProps=null,st.memoizedState=null,st.pendingProps=null,st.stateNode=null,st.updateQueue=null}function Tj(st){return st.tag===5||st.tag===3||st.tag===4}function Uj(st){e:for(;;){for(;st.sibling===null;){if(st.return===null||Tj(st.return))return null;st=st.return}for(st.sibling.return=st.return,st=st.sibling;st.tag!==5&&st.tag!==6&&st.tag!==18;){if(st.flags&2||st.child===null||st.tag===4)continue e;st.child.return=st,st=st.child}if(!(st.flags&2))return st.stateNode}}function Vj(st,at,pt){var vt=st.tag;if(vt===5||vt===6)st=st.stateNode,at?pt.nodeType===8?pt.parentNode.insertBefore(st,at):pt.insertBefore(st,at):(pt.nodeType===8?(at=pt.parentNode,at.insertBefore(st,pt)):(at=pt,at.appendChild(st)),pt=pt._reactRootContainer,pt!=null||at.onclick!==null||(at.onclick=Bf$1));else if(vt!==4&&(st=st.child,st!==null))for(Vj(st,at,pt),st=st.sibling;st!==null;)Vj(st,at,pt),st=st.sibling}function Wj(st,at,pt){var vt=st.tag;if(vt===5||vt===6)st=st.stateNode,at?pt.insertBefore(st,at):pt.appendChild(st);else if(vt!==4&&(st=st.child,st!==null))for(Wj(st,at,pt),st=st.sibling;st!==null;)Wj(st,at,pt),st=st.sibling}var X$1=null,Xj=!1;function Yj(st,at,pt){for(pt=pt.child;pt!==null;)Zj(st,at,pt),pt=pt.sibling}function Zj(st,at,pt){if(lc$2&&typeof lc$2.onCommitFiberUnmount=="function")try{lc$2.onCommitFiberUnmount(kc$2,pt)}catch{}switch(pt.tag){case 5:U$4||Lj(pt,at);case 6:var vt=X$1,wt=Xj;X$1=null,Yj(st,at,pt),X$1=vt,Xj=wt,X$1!==null&&(Xj?(st=X$1,pt=pt.stateNode,st.nodeType===8?st.parentNode.removeChild(pt):st.removeChild(pt)):X$1.removeChild(pt.stateNode));break;case 18:X$1!==null&&(Xj?(st=X$1,pt=pt.stateNode,st.nodeType===8?Kf$1(st.parentNode,pt):st.nodeType===1&&Kf$1(st,pt),bd$1(st)):Kf$1(X$1,pt.stateNode));break;case 4:vt=X$1,wt=Xj,X$1=pt.stateNode.containerInfo,Xj=!0,Yj(st,at,pt),X$1=vt,Xj=wt;break;case 0:case 11:case 14:case 15:if(!U$4&&(vt=pt.updateQueue,vt!==null&&(vt=vt.lastEffect,vt!==null))){wt=vt=vt.next;do{var $t=wt,Tt=$t.destroy;$t=$t.tag,Tt!==void 0&&($t&2||$t&4)&&Mj(pt,at,Tt),wt=wt.next}while(wt!==vt)}Yj(st,at,pt);break;case 1:if(!U$4&&(Lj(pt,at),vt=pt.stateNode,typeof vt.componentWillUnmount=="function"))try{vt.props=pt.memoizedProps,vt.state=pt.memoizedState,vt.componentWillUnmount()}catch(Lt){W$1(pt,at,Lt)}Yj(st,at,pt);break;case 21:Yj(st,at,pt);break;case 22:pt.mode&1?(U$4=(vt=U$4)||pt.memoizedState!==null,Yj(st,at,pt),U$4=vt):Yj(st,at,pt);break;default:Yj(st,at,pt)}}function ak(st){var at=st.updateQueue;if(at!==null){st.updateQueue=null;var pt=st.stateNode;pt===null&&(pt=st.stateNode=new Kj),at.forEach(function(vt){var wt=bk.bind(null,st,vt);pt.has(vt)||(pt.add(vt),vt.then(wt,wt))})}}function ck(st,at){var pt=at.deletions;if(pt!==null)for(var vt=0;vt<pt.length;vt++){var wt=pt[vt];try{var $t=st,Tt=at,Lt=Tt;e:for(;Lt!==null;){switch(Lt.tag){case 5:X$1=Lt.stateNode,Xj=!1;break e;case 3:X$1=Lt.stateNode.containerInfo,Xj=!0;break e;case 4:X$1=Lt.stateNode.containerInfo,Xj=!0;break e}Lt=Lt.return}if(X$1===null)throw Error(p$3(160));Zj($t,Tt,wt),X$1=null,Xj=!1;var Ft=wt.alternate;Ft!==null&&(Ft.return=null),wt.return=null}catch(Ct){W$1(wt,at,Ct)}}if(at.subtreeFlags&12854)for(at=at.child;at!==null;)dk(at,st),at=at.sibling}function dk(st,at){var pt=st.alternate,vt=st.flags;switch(st.tag){case 0:case 11:case 14:case 15:if(ck(at,st),ek(st),vt&4){try{Pj(3,st,st.return),Qj(3,st)}catch(An){W$1(st,st.return,An)}try{Pj(5,st,st.return)}catch(An){W$1(st,st.return,An)}}break;case 1:ck(at,st),ek(st),vt&512&&pt!==null&&Lj(pt,pt.return);break;case 5:if(ck(at,st),ek(st),vt&512&&pt!==null&&Lj(pt,pt.return),st.flags&32){var wt=st.stateNode;try{ob$1(wt,"")}catch(An){W$1(st,st.return,An)}}if(vt&4&&(wt=st.stateNode,wt!=null)){var $t=st.memoizedProps,Tt=pt!==null?pt.memoizedProps:$t,Lt=st.type,Ft=st.updateQueue;if(st.updateQueue=null,Ft!==null)try{Lt==="input"&&$t.type==="radio"&&$t.name!=null&&ab$1(wt,$t),vb$1(Lt,Tt);var Ct=vb$1(Lt,$t);for(Tt=0;Tt<Ft.length;Tt+=2){var Ht=Ft[Tt],Gt=Ft[Tt+1];Ht==="style"?sb$1(wt,Gt):Ht==="dangerouslySetInnerHTML"?nb$1(wt,Gt):Ht==="children"?ob$1(wt,Gt):ta$1(wt,Ht,Gt,Ct)}switch(Lt){case"input":bb$1(wt,$t);break;case"textarea":ib$1(wt,$t);break;case"select":var jt=wt._wrapperState.wasMultiple;wt._wrapperState.wasMultiple=!!$t.multiple;var qt=$t.value;qt!=null?fb$1(wt,!!$t.multiple,qt,!1):jt!==!!$t.multiple&&($t.defaultValue!=null?fb$1(wt,!!$t.multiple,$t.defaultValue,!0):fb$1(wt,!!$t.multiple,$t.multiple?[]:"",!1))}wt[Pf$1]=$t}catch(An){W$1(st,st.return,An)}}break;case 6:if(ck(at,st),ek(st),vt&4){if(st.stateNode===null)throw Error(p$3(162));wt=st.stateNode,$t=st.memoizedProps;try{wt.nodeValue=$t}catch(An){W$1(st,st.return,An)}}break;case 3:if(ck(at,st),ek(st),vt&4&&pt!==null&&pt.memoizedState.isDehydrated)try{bd$1(at.containerInfo)}catch(An){W$1(st,st.return,An)}break;case 4:ck(at,st),ek(st);break;case 13:ck(at,st),ek(st),wt=st.child,wt.flags&8192&&($t=wt.memoizedState!==null,wt.stateNode.isHidden=$t,!$t||wt.alternate!==null&&wt.alternate.memoizedState!==null||(fk=B$2())),vt&4&&ak(st);break;case 22:if(Ht=pt!==null&&pt.memoizedState!==null,st.mode&1?(U$4=(Ct=U$4)||Ht,ck(at,st),U$4=Ct):ck(at,st),ek(st),vt&8192){if(Ct=st.memoizedState!==null,(st.stateNode.isHidden=Ct)&&!Ht&&st.mode&1)for(V$4=st,Ht=st.child;Ht!==null;){for(Gt=V$4=Ht;V$4!==null;){switch(jt=V$4,qt=jt.child,jt.tag){case 0:case 11:case 14:case 15:Pj(4,jt,jt.return);break;case 1:Lj(jt,jt.return);var Kt=jt.stateNode;if(typeof Kt.componentWillUnmount=="function"){vt=jt,pt=jt.return;try{at=vt,Kt.props=at.memoizedProps,Kt.state=at.memoizedState,Kt.componentWillUnmount()}catch(An){W$1(vt,pt,An)}}break;case 5:Lj(jt,jt.return);break;case 22:if(jt.memoizedState!==null){gk(Gt);continue}}qt!==null?(qt.return=jt,V$4=qt):gk(Gt)}Ht=Ht.sibling}e:for(Ht=null,Gt=st;;){if(Gt.tag===5){if(Ht===null){Ht=Gt;try{wt=Gt.stateNode,Ct?($t=wt.style,typeof $t.setProperty=="function"?$t.setProperty("display","none","important"):$t.display="none"):(Lt=Gt.stateNode,Ft=Gt.memoizedProps.style,Tt=Ft!=null&&Ft.hasOwnProperty("display")?Ft.display:null,Lt.style.display=rb$1("display",Tt))}catch(An){W$1(st,st.return,An)}}}else if(Gt.tag===6){if(Ht===null)try{Gt.stateNode.nodeValue=Ct?"":Gt.memoizedProps}catch(An){W$1(st,st.return,An)}}else if((Gt.tag!==22&&Gt.tag!==23||Gt.memoizedState===null||Gt===st)&&Gt.child!==null){Gt.child.return=Gt,Gt=Gt.child;continue}if(Gt===st)break e;for(;Gt.sibling===null;){if(Gt.return===null||Gt.return===st)break e;Ht===Gt&&(Ht=null),Gt=Gt.return}Ht===Gt&&(Ht=null),Gt.sibling.return=Gt.return,Gt=Gt.sibling}}break;case 19:ck(at,st),ek(st),vt&4&&ak(st);break;case 21:break;default:ck(at,st),ek(st)}}function ek(st){var at=st.flags;if(at&2){try{e:{for(var pt=st.return;pt!==null;){if(Tj(pt)){var vt=pt;break e}pt=pt.return}throw Error(p$3(160))}switch(vt.tag){case 5:var wt=vt.stateNode;vt.flags&32&&(ob$1(wt,""),vt.flags&=-33);var $t=Uj(st);Wj(st,$t,wt);break;case 3:case 4:var Tt=vt.stateNode.containerInfo,Lt=Uj(st);Vj(st,Lt,Tt);break;default:throw Error(p$3(161))}}catch(Ft){W$1(st,st.return,Ft)}st.flags&=-3}at&4096&&(st.flags&=-4097)}function hk(st,at,pt){V$4=st,ik(st)}function ik(st,at,pt){for(var vt=(st.mode&1)!==0;V$4!==null;){var wt=V$4,$t=wt.child;if(wt.tag===22&&vt){var Tt=wt.memoizedState!==null||Jj;if(!Tt){var Lt=wt.alternate,Ft=Lt!==null&&Lt.memoizedState!==null||U$4;Lt=Jj;var Ct=U$4;if(Jj=Tt,(U$4=Ft)&&!Ct)for(V$4=wt;V$4!==null;)Tt=V$4,Ft=Tt.child,Tt.tag===22&&Tt.memoizedState!==null?jk(wt):Ft!==null?(Ft.return=Tt,V$4=Ft):jk(wt);for(;$t!==null;)V$4=$t,ik($t),$t=$t.sibling;V$4=wt,Jj=Lt,U$4=Ct}kk(st)}else wt.subtreeFlags&8772&&$t!==null?($t.return=wt,V$4=$t):kk(st)}}function kk(st){for(;V$4!==null;){var at=V$4;if(at.flags&8772){var pt=at.alternate;try{if(at.flags&8772)switch(at.tag){case 0:case 11:case 15:U$4||Qj(5,at);break;case 1:var vt=at.stateNode;if(at.flags&4&&!U$4)if(pt===null)vt.componentDidMount();else{var wt=at.elementType===at.type?pt.memoizedProps:Ci$1(at.type,pt.memoizedProps);vt.componentDidUpdate(wt,pt.memoizedState,vt.__reactInternalSnapshotBeforeUpdate)}var $t=at.updateQueue;$t!==null&&sh$1(at,$t,vt);break;case 3:var Tt=at.updateQueue;if(Tt!==null){if(pt=null,at.child!==null)switch(at.child.tag){case 5:pt=at.child.stateNode;break;case 1:pt=at.child.stateNode}sh$1(at,Tt,pt)}break;case 5:var Lt=at.stateNode;if(pt===null&&at.flags&4){pt=Lt;var Ft=at.memoizedProps;switch(at.type){case"button":case"input":case"select":case"textarea":Ft.autoFocus&&pt.focus();break;case"img":Ft.src&&(pt.src=Ft.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(at.memoizedState===null){var Ct=at.alternate;if(Ct!==null){var Ht=Ct.memoizedState;if(Ht!==null){var Gt=Ht.dehydrated;Gt!==null&&bd$1(Gt)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(p$3(163))}U$4||at.flags&512&&Rj(at)}catch(jt){W$1(at,at.return,jt)}}if(at===st){V$4=null;break}if(pt=at.sibling,pt!==null){pt.return=at.return,V$4=pt;break}V$4=at.return}}function gk(st){for(;V$4!==null;){var at=V$4;if(at===st){V$4=null;break}var pt=at.sibling;if(pt!==null){pt.return=at.return,V$4=pt;break}V$4=at.return}}function jk(st){for(;V$4!==null;){var at=V$4;try{switch(at.tag){case 0:case 11:case 15:var pt=at.return;try{Qj(4,at)}catch(Ft){W$1(at,pt,Ft)}break;case 1:var vt=at.stateNode;if(typeof vt.componentDidMount=="function"){var wt=at.return;try{vt.componentDidMount()}catch(Ft){W$1(at,wt,Ft)}}var $t=at.return;try{Rj(at)}catch(Ft){W$1(at,$t,Ft)}break;case 5:var Tt=at.return;try{Rj(at)}catch(Ft){W$1(at,Tt,Ft)}}}catch(Ft){W$1(at,at.return,Ft)}if(at===st){V$4=null;break}var Lt=at.sibling;if(Lt!==null){Lt.return=at.return,V$4=Lt;break}V$4=at.return}}var lk=Math.ceil,mk=ua$2.ReactCurrentDispatcher,nk=ua$2.ReactCurrentOwner,ok=ua$2.ReactCurrentBatchConfig,K$1=0,Q$2=null,Y$2=null,Z$1=0,fj=0,ej=Uf$1(0),T$2=0,pk=null,rh$1=0,qk=0,rk=0,sk=null,tk=null,fk=0,Gj=1/0,uk=null,Oi$2=!1,Pi$2=null,Ri$2=null,vk=!1,wk=null,xk=0,yk=0,zk=null,Ak=-1,Bk=0;function R$2(){return K$1&6?B$2():Ak!==-1?Ak:Ak=B$2()}function yi$1(st){return st.mode&1?K$1&2&&Z$1!==0?Z$1&-Z$1:Kg.transition!==null?(Bk===0&&(Bk=yc$2()),Bk):(st=C$1,st!==0||(st=window.event,st=st===void 0?16:jd$2(st.type)),st):1}function gi$1(st,at,pt,vt){if(50<yk)throw yk=0,zk=null,Error(p$3(185));Ac$2(st,pt,vt),(!(K$1&2)||st!==Q$2)&&(st===Q$2&&(!(K$1&2)&&(qk|=pt),T$2===4&&Ck(st,Z$1)),Dk(st,vt),pt===1&&K$1===0&&!(at.mode&1)&&(Gj=B$2()+500,fg$1&&jg()))}function Dk(st,at){var pt=st.callbackNode;wc$2(st,at);var vt=uc$2(st,st===Q$2?Z$1:0);if(vt===0)pt!==null&&bc$2(pt),st.callbackNode=null,st.callbackPriority=0;else if(at=vt&-vt,st.callbackPriority!==at){if(pt!=null&&bc$2(pt),at===1)st.tag===0?ig$1(Ek.bind(null,st)):hg$1(Ek.bind(null,st)),Jf$1(function(){!(K$1&6)&&jg()}),pt=null;else{switch(Dc$2(vt)){case 1:pt=fc$2;break;case 4:pt=gc$2;break;case 16:pt=hc$1;break;case 536870912:pt=jc$2;break;default:pt=hc$1}pt=Fk(pt,Gk.bind(null,st))}st.callbackPriority=at,st.callbackNode=pt}}function Gk(st,at){if(Ak=-1,Bk=0,K$1&6)throw Error(p$3(327));var pt=st.callbackNode;if(Hk()&&st.callbackNode!==pt)return null;var vt=uc$2(st,st===Q$2?Z$1:0);if(vt===0)return null;if(vt&30||vt&st.expiredLanes||at)at=Ik(st,vt);else{at=vt;var wt=K$1;K$1|=2;var $t=Jk();(Q$2!==st||Z$1!==at)&&(uk=null,Gj=B$2()+500,Kk(st,at));do try{Lk();break}catch(Lt){Mk(st,Lt)}while(!0);$g(),mk.current=$t,K$1=wt,Y$2!==null?at=0:(Q$2=null,Z$1=0,at=T$2)}if(at!==0){if(at===2&&(wt=xc$2(st),wt!==0&&(vt=wt,at=Nk(st,wt))),at===1)throw pt=pk,Kk(st,0),Ck(st,vt),Dk(st,B$2()),pt;if(at===6)Ck(st,vt);else{if(wt=st.current.alternate,!(vt&30)&&!Ok(wt)&&(at=Ik(st,vt),at===2&&($t=xc$2(st),$t!==0&&(vt=$t,at=Nk(st,$t))),at===1))throw pt=pk,Kk(st,0),Ck(st,vt),Dk(st,B$2()),pt;switch(st.finishedWork=wt,st.finishedLanes=vt,at){case 0:case 1:throw Error(p$3(345));case 2:Pk(st,tk,uk);break;case 3:if(Ck(st,vt),(vt&130023424)===vt&&(at=fk+500-B$2(),10<at)){if(uc$2(st,0)!==0)break;if(wt=st.suspendedLanes,(wt&vt)!==vt){R$2(),st.pingedLanes|=st.suspendedLanes&wt;break}st.timeoutHandle=Ff$1(Pk.bind(null,st,tk,uk),at);break}Pk(st,tk,uk);break;case 4:if(Ck(st,vt),(vt&4194240)===vt)break;for(at=st.eventTimes,wt=-1;0<vt;){var Tt=31-oc$2(vt);$t=1<<Tt,Tt=at[Tt],Tt>wt&&(wt=Tt),vt&=~$t}if(vt=wt,vt=B$2()-vt,vt=(120>vt?120:480>vt?480:1080>vt?1080:1920>vt?1920:3e3>vt?3e3:4320>vt?4320:1960*lk(vt/1960))-vt,10<vt){st.timeoutHandle=Ff$1(Pk.bind(null,st,tk,uk),vt);break}Pk(st,tk,uk);break;case 5:Pk(st,tk,uk);break;default:throw Error(p$3(329))}}}return Dk(st,B$2()),st.callbackNode===pt?Gk.bind(null,st):null}function Nk(st,at){var pt=sk;return st.current.memoizedState.isDehydrated&&(Kk(st,at).flags|=256),st=Ik(st,at),st!==2&&(at=tk,tk=pt,at!==null&&Fj(at)),st}function Fj(st){tk===null?tk=st:tk.push.apply(tk,st)}function Ok(st){for(var at=st;;){if(at.flags&16384){var pt=at.updateQueue;if(pt!==null&&(pt=pt.stores,pt!==null))for(var vt=0;vt<pt.length;vt++){var wt=pt[vt],$t=wt.getSnapshot;wt=wt.value;try{if(!He($t(),wt))return!1}catch{return!1}}}if(pt=at.child,at.subtreeFlags&16384&&pt!==null)pt.return=at,at=pt;else{if(at===st)break;for(;at.sibling===null;){if(at.return===null||at.return===st)return!0;at=at.return}at.sibling.return=at.return,at=at.sibling}}return!0}function Ck(st,at){for(at&=~rk,at&=~qk,st.suspendedLanes|=at,st.pingedLanes&=~at,st=st.expirationTimes;0<at;){var pt=31-oc$2(at),vt=1<<pt;st[pt]=-1,at&=~vt}}function Ek(st){if(K$1&6)throw Error(p$3(327));Hk();var at=uc$2(st,0);if(!(at&1))return Dk(st,B$2()),null;var pt=Ik(st,at);if(st.tag!==0&&pt===2){var vt=xc$2(st);vt!==0&&(at=vt,pt=Nk(st,vt))}if(pt===1)throw pt=pk,Kk(st,0),Ck(st,at),Dk(st,B$2()),pt;if(pt===6)throw Error(p$3(345));return st.finishedWork=st.current.alternate,st.finishedLanes=at,Pk(st,tk,uk),Dk(st,B$2()),null}function Qk(st,at){var pt=K$1;K$1|=1;try{return st(at)}finally{K$1=pt,K$1===0&&(Gj=B$2()+500,fg$1&&jg())}}function Rk(st){wk!==null&&wk.tag===0&&!(K$1&6)&&Hk();var at=K$1;K$1|=1;var pt=ok.transition,vt=C$1;try{if(ok.transition=null,C$1=1,st)return st()}finally{C$1=vt,ok.transition=pt,K$1=at,!(K$1&6)&&jg()}}function Hj(){fj=ej.current,E$1(ej)}function Kk(st,at){st.finishedWork=null,st.finishedLanes=0;var pt=st.timeoutHandle;if(pt!==-1&&(st.timeoutHandle=-1,Gf$1(pt)),Y$2!==null)for(pt=Y$2.return;pt!==null;){var vt=pt;switch(wg$1(vt),vt.tag){case 1:vt=vt.type.childContextTypes,vt!=null&&$f$1();break;case 3:zh$1(),E$1(Wf$1),E$1(H$3),Eh$1();break;case 5:Bh$1(vt);break;case 4:zh$1();break;case 13:E$1(L$3);break;case 19:E$1(L$3);break;case 10:ah(vt.type._context);break;case 22:case 23:Hj()}pt=pt.return}if(Q$2=st,Y$2=st=Pg(st.current,null),Z$1=fj=at,T$2=0,pk=null,rk=qk=rh$1=0,tk=sk=null,fh!==null){for(at=0;at<fh.length;at++)if(pt=fh[at],vt=pt.interleaved,vt!==null){pt.interleaved=null;var wt=vt.next,$t=pt.pending;if($t!==null){var Tt=$t.next;$t.next=wt,vt.next=Tt}pt.pending=vt}fh=null}return st}function Mk(st,at){do{var pt=Y$2;try{if($g(),Fh$1.current=Rh$1,Ih){for(var vt=M$3.memoizedState;vt!==null;){var wt=vt.queue;wt!==null&&(wt.pending=null),vt=vt.next}Ih=!1}if(Hh$1=0,O$1=N$2=M$3=null,Jh$1=!1,Kh$1=0,nk.current=null,pt===null||pt.return===null){T$2=1,pk=at,Y$2=null;break}e:{var $t=st,Tt=pt.return,Lt=pt,Ft=at;if(at=Z$1,Lt.flags|=32768,Ft!==null&&typeof Ft=="object"&&typeof Ft.then=="function"){var Ct=Ft,Ht=Lt,Gt=Ht.tag;if(!(Ht.mode&1)&&(Gt===0||Gt===11||Gt===15)){var jt=Ht.alternate;jt?(Ht.updateQueue=jt.updateQueue,Ht.memoizedState=jt.memoizedState,Ht.lanes=jt.lanes):(Ht.updateQueue=null,Ht.memoizedState=null)}var qt=Ui$2(Tt);if(qt!==null){qt.flags&=-257,Vi$1(qt,Tt,Lt,$t,at),qt.mode&1&&Si$1($t,Ct,at),at=qt,Ft=Ct;var Kt=at.updateQueue;if(Kt===null){var An=new Set;An.add(Ft),at.updateQueue=An}else Kt.add(Ft);break e}else{if(!(at&1)){Si$1($t,Ct,at),tj();break e}Ft=Error(p$3(426))}}else if(I$3&&Lt.mode&1){var Sn=Ui$2(Tt);if(Sn!==null){!(Sn.flags&65536)&&(Sn.flags|=256),Vi$1(Sn,Tt,Lt,$t,at),Jg(Ji$2(Ft,Lt));break e}}$t=Ft=Ji$2(Ft,Lt),T$2!==4&&(T$2=2),sk===null?sk=[$t]:sk.push($t),$t=Tt;do{switch($t.tag){case 3:$t.flags|=65536,at&=-at,$t.lanes|=at;var wn=Ni$1($t,Ft,at);ph$1($t,wn);break e;case 1:Lt=Ft;var In=$t.type,tr=$t.stateNode;if(!($t.flags&128)&&(typeof In.getDerivedStateFromError=="function"||tr!==null&&typeof tr.componentDidCatch=="function"&&(Ri$2===null||!Ri$2.has(tr)))){$t.flags|=65536,at&=-at,$t.lanes|=at;var rr=Qi$2($t,Lt,at);ph$1($t,rr);break e}}$t=$t.return}while($t!==null)}Sk(pt)}catch(Hr){at=Hr,Y$2===pt&&pt!==null&&(Y$2=pt=pt.return);continue}break}while(!0)}function Jk(){var st=mk.current;return mk.current=Rh$1,st===null?Rh$1:st}function tj(){(T$2===0||T$2===3||T$2===2)&&(T$2=4),Q$2===null||!(rh$1&268435455)&&!(qk&268435455)||Ck(Q$2,Z$1)}function Ik(st,at){var pt=K$1;K$1|=2;var vt=Jk();(Q$2!==st||Z$1!==at)&&(uk=null,Kk(st,at));do try{Tk();break}catch(wt){Mk(st,wt)}while(!0);if($g(),K$1=pt,mk.current=vt,Y$2!==null)throw Error(p$3(261));return Q$2=null,Z$1=0,T$2}function Tk(){for(;Y$2!==null;)Uk(Y$2)}function Lk(){for(;Y$2!==null&&!cc$2();)Uk(Y$2)}function Uk(st){var at=Vk(st.alternate,st,fj);st.memoizedProps=st.pendingProps,at===null?Sk(st):Y$2=at,nk.current=null}function Sk(st){var at=st;do{var pt=at.alternate;if(st=at.return,at.flags&32768){if(pt=Ij(pt,at),pt!==null){pt.flags&=32767,Y$2=pt;return}if(st!==null)st.flags|=32768,st.subtreeFlags=0,st.deletions=null;else{T$2=6,Y$2=null;return}}else if(pt=Ej(pt,at,fj),pt!==null){Y$2=pt;return}if(at=at.sibling,at!==null){Y$2=at;return}Y$2=at=st}while(at!==null);T$2===0&&(T$2=5)}function Pk(st,at,pt){var vt=C$1,wt=ok.transition;try{ok.transition=null,C$1=1,Wk(st,at,pt,vt)}finally{ok.transition=wt,C$1=vt}return null}function Wk(st,at,pt,vt){do Hk();while(wk!==null);if(K$1&6)throw Error(p$3(327));pt=st.finishedWork;var wt=st.finishedLanes;if(pt===null)return null;if(st.finishedWork=null,st.finishedLanes=0,pt===st.current)throw Error(p$3(177));st.callbackNode=null,st.callbackPriority=0;var $t=pt.lanes|pt.childLanes;if(Bc$2(st,$t),st===Q$2&&(Y$2=Q$2=null,Z$1=0),!(pt.subtreeFlags&2064)&&!(pt.flags&2064)||vk||(vk=!0,Fk(hc$1,function(){return Hk(),null})),$t=(pt.flags&15990)!==0,pt.subtreeFlags&15990||$t){$t=ok.transition,ok.transition=null;var Tt=C$1;C$1=1;var Lt=K$1;K$1|=4,nk.current=null,Oj(st,pt),dk(pt,st),Oe(Df$1),dd$2=!!Cf$1,Df$1=Cf$1=null,st.current=pt,hk(pt),dc$2(),K$1=Lt,C$1=Tt,ok.transition=$t}else st.current=pt;if(vk&&(vk=!1,wk=st,xk=wt),$t=st.pendingLanes,$t===0&&(Ri$2=null),mc$2(pt.stateNode),Dk(st,B$2()),at!==null)for(vt=st.onRecoverableError,pt=0;pt<at.length;pt++)wt=at[pt],vt(wt.value,{componentStack:wt.stack,digest:wt.digest});if(Oi$2)throw Oi$2=!1,st=Pi$2,Pi$2=null,st;return xk&1&&st.tag!==0&&Hk(),$t=st.pendingLanes,$t&1?st===zk?yk++:(yk=0,zk=st):yk=0,jg(),null}function Hk(){if(wk!==null){var st=Dc$2(xk),at=ok.transition,pt=C$1;try{if(ok.transition=null,C$1=16>st?16:st,wk===null)var vt=!1;else{if(st=wk,wk=null,xk=0,K$1&6)throw Error(p$3(331));var wt=K$1;for(K$1|=4,V$4=st.current;V$4!==null;){var $t=V$4,Tt=$t.child;if(V$4.flags&16){var Lt=$t.deletions;if(Lt!==null){for(var Ft=0;Ft<Lt.length;Ft++){var Ct=Lt[Ft];for(V$4=Ct;V$4!==null;){var Ht=V$4;switch(Ht.tag){case 0:case 11:case 15:Pj(8,Ht,$t)}var Gt=Ht.child;if(Gt!==null)Gt.return=Ht,V$4=Gt;else for(;V$4!==null;){Ht=V$4;var jt=Ht.sibling,qt=Ht.return;if(Sj(Ht),Ht===Ct){V$4=null;break}if(jt!==null){jt.return=qt,V$4=jt;break}V$4=qt}}}var Kt=$t.alternate;if(Kt!==null){var An=Kt.child;if(An!==null){Kt.child=null;do{var Sn=An.sibling;An.sibling=null,An=Sn}while(An!==null)}}V$4=$t}}if($t.subtreeFlags&2064&&Tt!==null)Tt.return=$t,V$4=Tt;else e:for(;V$4!==null;){if($t=V$4,$t.flags&2048)switch($t.tag){case 0:case 11:case 15:Pj(9,$t,$t.return)}var wn=$t.sibling;if(wn!==null){wn.return=$t.return,V$4=wn;break e}V$4=$t.return}}var In=st.current;for(V$4=In;V$4!==null;){Tt=V$4;var tr=Tt.child;if(Tt.subtreeFlags&2064&&tr!==null)tr.return=Tt,V$4=tr;else e:for(Tt=In;V$4!==null;){if(Lt=V$4,Lt.flags&2048)try{switch(Lt.tag){case 0:case 11:case 15:Qj(9,Lt)}}catch(Hr){W$1(Lt,Lt.return,Hr)}if(Lt===Tt){V$4=null;break e}var rr=Lt.sibling;if(rr!==null){rr.return=Lt.return,V$4=rr;break e}V$4=Lt.return}}if(K$1=wt,jg(),lc$2&&typeof lc$2.onPostCommitFiberRoot=="function")try{lc$2.onPostCommitFiberRoot(kc$2,st)}catch{}vt=!0}return vt}finally{C$1=pt,ok.transition=at}}return!1}function Xk(st,at,pt){at=Ji$2(pt,at),at=Ni$1(st,at,1),st=nh$1(st,at,1),at=R$2(),st!==null&&(Ac$2(st,1,at),Dk(st,at))}function W$1(st,at,pt){if(st.tag===3)Xk(st,st,pt);else for(;at!==null;){if(at.tag===3){Xk(at,st,pt);break}else if(at.tag===1){var vt=at.stateNode;if(typeof at.type.getDerivedStateFromError=="function"||typeof vt.componentDidCatch=="function"&&(Ri$2===null||!Ri$2.has(vt))){st=Ji$2(pt,st),st=Qi$2(at,st,1),at=nh$1(at,st,1),st=R$2(),at!==null&&(Ac$2(at,1,st),Dk(at,st));break}}at=at.return}}function Ti$1(st,at,pt){var vt=st.pingCache;vt!==null&&vt.delete(at),at=R$2(),st.pingedLanes|=st.suspendedLanes&pt,Q$2===st&&(Z$1&pt)===pt&&(T$2===4||T$2===3&&(Z$1&130023424)===Z$1&&500>B$2()-fk?Kk(st,0):rk|=pt),Dk(st,at)}function Yk(st,at){at===0&&(st.mode&1?(at=sc$2,sc$2<<=1,!(sc$2&130023424)&&(sc$2=4194304)):at=1);var pt=R$2();st=ih$1(st,at),st!==null&&(Ac$2(st,at,pt),Dk(st,pt))}function uj(st){var at=st.memoizedState,pt=0;at!==null&&(pt=at.retryLane),Yk(st,pt)}function bk(st,at){var pt=0;switch(st.tag){case 13:var vt=st.stateNode,wt=st.memoizedState;wt!==null&&(pt=wt.retryLane);break;case 19:vt=st.stateNode;break;default:throw Error(p$3(314))}vt!==null&&vt.delete(at),Yk(st,pt)}var Vk;Vk=function(st,at,pt){if(st!==null)if(st.memoizedProps!==at.pendingProps||Wf$1.current)dh$1=!0;else{if(!(st.lanes&pt)&&!(at.flags&128))return dh$1=!1,yj(st,at,pt);dh$1=!!(st.flags&131072)}else dh$1=!1,I$3&&at.flags&1048576&&ug$1(at,ng$1,at.index);switch(at.lanes=0,at.tag){case 2:var vt=at.type;ij(st,at),st=at.pendingProps;var wt=Yf$1(at,H$3.current);ch$1(at,pt),wt=Nh$1(null,at,vt,st,wt,pt);var $t=Sh$1();return at.flags|=1,typeof wt=="object"&&wt!==null&&typeof wt.render=="function"&&wt.$$typeof===void 0?(at.tag=1,at.memoizedState=null,at.updateQueue=null,Zf$1(vt)?($t=!0,cg$1(at)):$t=!1,at.memoizedState=wt.state!==null&&wt.state!==void 0?wt.state:null,kh$1(at),wt.updater=Ei$1,at.stateNode=wt,wt._reactInternals=at,Ii$1(at,vt,st,pt),at=jj(null,at,vt,!0,$t,pt)):(at.tag=0,I$3&&$t&&vg$1(at),Xi$2(null,at,wt,pt),at=at.child),at;case 16:vt=at.elementType;e:{switch(ij(st,at),st=at.pendingProps,wt=vt._init,vt=wt(vt._payload),at.type=vt,wt=at.tag=Zk(vt),st=Ci$1(vt,st),wt){case 0:at=cj(null,at,vt,st,pt);break e;case 1:at=hj(null,at,vt,st,pt);break e;case 11:at=Yi$2(null,at,vt,st,pt);break e;case 14:at=$i$1(null,at,vt,Ci$1(vt.type,st),pt);break e}throw Error(p$3(306,vt,""))}return at;case 0:return vt=at.type,wt=at.pendingProps,wt=at.elementType===vt?wt:Ci$1(vt,wt),cj(st,at,vt,wt,pt);case 1:return vt=at.type,wt=at.pendingProps,wt=at.elementType===vt?wt:Ci$1(vt,wt),hj(st,at,vt,wt,pt);case 3:e:{if(kj(at),st===null)throw Error(p$3(387));vt=at.pendingProps,$t=at.memoizedState,wt=$t.element,lh$1(st,at),qh$1(at,vt,null,pt);var Tt=at.memoizedState;if(vt=Tt.element,$t.isDehydrated)if($t={element:vt,isDehydrated:!1,cache:Tt.cache,pendingSuspenseBoundaries:Tt.pendingSuspenseBoundaries,transitions:Tt.transitions},at.updateQueue.baseState=$t,at.memoizedState=$t,at.flags&256){wt=Ji$2(Error(p$3(423)),at),at=lj(st,at,vt,pt,wt);break e}else if(vt!==wt){wt=Ji$2(Error(p$3(424)),at),at=lj(st,at,vt,pt,wt);break e}else for(yg=Lf$1(at.stateNode.containerInfo.firstChild),xg$1=at,I$3=!0,zg=null,pt=Vg(at,null,vt,pt),at.child=pt;pt;)pt.flags=pt.flags&-3|4096,pt=pt.sibling;else{if(Ig(),vt===wt){at=Zi$2(st,at,pt);break e}Xi$2(st,at,vt,pt)}at=at.child}return at;case 5:return Ah$1(at),st===null&&Eg(at),vt=at.type,wt=at.pendingProps,$t=st!==null?st.memoizedProps:null,Tt=wt.children,Ef$1(vt,wt)?Tt=null:$t!==null&&Ef$1(vt,$t)&&(at.flags|=32),gj(st,at),Xi$2(st,at,Tt,pt),at.child;case 6:return st===null&&Eg(at),null;case 13:return oj(st,at,pt);case 4:return yh$1(at,at.stateNode.containerInfo),vt=at.pendingProps,st===null?at.child=Ug(at,null,vt,pt):Xi$2(st,at,vt,pt),at.child;case 11:return vt=at.type,wt=at.pendingProps,wt=at.elementType===vt?wt:Ci$1(vt,wt),Yi$2(st,at,vt,wt,pt);case 7:return Xi$2(st,at,at.pendingProps,pt),at.child;case 8:return Xi$2(st,at,at.pendingProps.children,pt),at.child;case 12:return Xi$2(st,at,at.pendingProps.children,pt),at.child;case 10:e:{if(vt=at.type._context,wt=at.pendingProps,$t=at.memoizedProps,Tt=wt.value,G$1(Wg,vt._currentValue),vt._currentValue=Tt,$t!==null)if(He($t.value,Tt)){if($t.children===wt.children&&!Wf$1.current){at=Zi$2(st,at,pt);break e}}else for($t=at.child,$t!==null&&($t.return=at);$t!==null;){var Lt=$t.dependencies;if(Lt!==null){Tt=$t.child;for(var Ft=Lt.firstContext;Ft!==null;){if(Ft.context===vt){if($t.tag===1){Ft=mh$1(-1,pt&-pt),Ft.tag=2;var Ct=$t.updateQueue;if(Ct!==null){Ct=Ct.shared;var Ht=Ct.pending;Ht===null?Ft.next=Ft:(Ft.next=Ht.next,Ht.next=Ft),Ct.pending=Ft}}$t.lanes|=pt,Ft=$t.alternate,Ft!==null&&(Ft.lanes|=pt),bh$1($t.return,pt,at),Lt.lanes|=pt;break}Ft=Ft.next}}else if($t.tag===10)Tt=$t.type===at.type?null:$t.child;else if($t.tag===18){if(Tt=$t.return,Tt===null)throw Error(p$3(341));Tt.lanes|=pt,Lt=Tt.alternate,Lt!==null&&(Lt.lanes|=pt),bh$1(Tt,pt,at),Tt=$t.sibling}else Tt=$t.child;if(Tt!==null)Tt.return=$t;else for(Tt=$t;Tt!==null;){if(Tt===at){Tt=null;break}if($t=Tt.sibling,$t!==null){$t.return=Tt.return,Tt=$t;break}Tt=Tt.return}$t=Tt}Xi$2(st,at,wt.children,pt),at=at.child}return at;case 9:return wt=at.type,vt=at.pendingProps.children,ch$1(at,pt),wt=eh$1(wt),vt=vt(wt),at.flags|=1,Xi$2(st,at,vt,pt),at.child;case 14:return vt=at.type,wt=Ci$1(vt,at.pendingProps),wt=Ci$1(vt.type,wt),$i$1(st,at,vt,wt,pt);case 15:return bj(st,at,at.type,at.pendingProps,pt);case 17:return vt=at.type,wt=at.pendingProps,wt=at.elementType===vt?wt:Ci$1(vt,wt),ij(st,at),at.tag=1,Zf$1(vt)?(st=!0,cg$1(at)):st=!1,ch$1(at,pt),Gi$2(at,vt,wt),Ii$1(at,vt,wt,pt),jj(null,at,vt,!0,st,pt);case 19:return xj(st,at,pt);case 22:return dj(st,at,pt)}throw Error(p$3(156,at.tag))};function Fk(st,at){return ac$2(st,at)}function $k(st,at,pt,vt){this.tag=st,this.key=pt,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=at,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=vt,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Bg(st,at,pt,vt){return new $k(st,at,pt,vt)}function aj(st){return st=st.prototype,!(!st||!st.isReactComponent)}function Zk(st){if(typeof st=="function")return aj(st)?1:0;if(st!=null){if(st=st.$$typeof,st===Da$1)return 11;if(st===Ga$1)return 14}return 2}function Pg(st,at){var pt=st.alternate;return pt===null?(pt=Bg(st.tag,at,st.key,st.mode),pt.elementType=st.elementType,pt.type=st.type,pt.stateNode=st.stateNode,pt.alternate=st,st.alternate=pt):(pt.pendingProps=at,pt.type=st.type,pt.flags=0,pt.subtreeFlags=0,pt.deletions=null),pt.flags=st.flags&14680064,pt.childLanes=st.childLanes,pt.lanes=st.lanes,pt.child=st.child,pt.memoizedProps=st.memoizedProps,pt.memoizedState=st.memoizedState,pt.updateQueue=st.updateQueue,at=st.dependencies,pt.dependencies=at===null?null:{lanes:at.lanes,firstContext:at.firstContext},pt.sibling=st.sibling,pt.index=st.index,pt.ref=st.ref,pt}function Rg(st,at,pt,vt,wt,$t){var Tt=2;if(vt=st,typeof st=="function")aj(st)&&(Tt=1);else if(typeof st=="string")Tt=5;else e:switch(st){case ya$1:return Tg$1(pt.children,wt,$t,at);case za$1:Tt=8,wt|=8;break;case Aa$1:return st=Bg(12,pt,at,wt|2),st.elementType=Aa$1,st.lanes=$t,st;case Ea$1:return st=Bg(13,pt,at,wt),st.elementType=Ea$1,st.lanes=$t,st;case Fa$1:return st=Bg(19,pt,at,wt),st.elementType=Fa$1,st.lanes=$t,st;case Ia$1:return pj(pt,wt,$t,at);default:if(typeof st=="object"&&st!==null)switch(st.$$typeof){case Ba$1:Tt=10;break e;case Ca$1:Tt=9;break e;case Da$1:Tt=11;break e;case Ga$1:Tt=14;break e;case Ha$2:Tt=16,vt=null;break e}throw Error(p$3(130,st==null?st:typeof st,""))}return at=Bg(Tt,pt,at,wt),at.elementType=st,at.type=vt,at.lanes=$t,at}function Tg$1(st,at,pt,vt){return st=Bg(7,st,vt,at),st.lanes=pt,st}function pj(st,at,pt,vt){return st=Bg(22,st,vt,at),st.elementType=Ia$1,st.lanes=pt,st.stateNode={isHidden:!1},st}function Qg(st,at,pt){return st=Bg(6,st,null,at),st.lanes=pt,st}function Sg(st,at,pt){return at=Bg(4,st.children!==null?st.children:[],st.key,at),at.lanes=pt,at.stateNode={containerInfo:st.containerInfo,pendingChildren:null,implementation:st.implementation},at}function al$2(st,at,pt,vt,wt){this.tag=at,this.containerInfo=st,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=zc$2(0),this.expirationTimes=zc$2(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=zc$2(0),this.identifierPrefix=vt,this.onRecoverableError=wt,this.mutableSourceEagerHydrationData=null}function bl$2(st,at,pt,vt,wt,$t,Tt,Lt,Ft){return st=new al$2(st,at,pt,Lt,Ft),at===1?(at=1,$t===!0&&(at|=8)):at=0,$t=Bg(3,null,null,at),st.current=$t,$t.stateNode=st,$t.memoizedState={element:vt,isDehydrated:pt,cache:null,transitions:null,pendingSuspenseBoundaries:null},kh$1($t),st}function cl$2(st,at,pt){var vt=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:wa$1,key:vt==null?null:""+vt,children:st,containerInfo:at,implementation:pt}}function dl$2(st){if(!st)return Vf$1;st=st._reactInternals;e:{if(Vb$1(st)!==st||st.tag!==1)throw Error(p$3(170));var at=st;do{switch(at.tag){case 3:at=at.stateNode.context;break e;case 1:if(Zf$1(at.type)){at=at.stateNode.__reactInternalMemoizedMergedChildContext;break e}}at=at.return}while(at!==null);throw Error(p$3(171))}if(st.tag===1){var pt=st.type;if(Zf$1(pt))return bg$1(st,pt,at)}return at}function el$2(st,at,pt,vt,wt,$t,Tt,Lt,Ft){return st=bl$2(pt,vt,!0,st,wt,$t,Tt,Lt,Ft),st.context=dl$2(null),pt=st.current,vt=R$2(),wt=yi$1(pt),$t=mh$1(vt,wt),$t.callback=at??null,nh$1(pt,$t,wt),st.current.lanes=wt,Ac$2(st,wt,vt),Dk(st,vt),st}function fl$3(st,at,pt,vt){var wt=at.current,$t=R$2(),Tt=yi$1(wt);return pt=dl$2(pt),at.context===null?at.context=pt:at.pendingContext=pt,at=mh$1($t,Tt),at.payload={element:st},vt=vt===void 0?null:vt,vt!==null&&(at.callback=vt),st=nh$1(wt,at,Tt),st!==null&&(gi$1(st,wt,Tt,$t),oh$1(st,wt,Tt)),Tt}function gl$2(st){if(st=st.current,!st.child)return null;switch(st.child.tag){case 5:return st.child.stateNode;default:return st.child.stateNode}}function hl$2(st,at){if(st=st.memoizedState,st!==null&&st.dehydrated!==null){var pt=st.retryLane;st.retryLane=pt!==0&&pt<at?pt:at}}function il$2(st,at){hl$2(st,at),(st=st.alternate)&&hl$2(st,at)}function jl$2(){return null}var kl$2=typeof reportError=="function"?reportError:function(st){console.error(st)};function ll$2(st){this._internalRoot=st}ml$2.prototype.render=ll$2.prototype.render=function(st){var at=this._internalRoot;if(at===null)throw Error(p$3(409));fl$3(st,at,null,null)};ml$2.prototype.unmount=ll$2.prototype.unmount=function(){var st=this._internalRoot;if(st!==null){this._internalRoot=null;var at=st.containerInfo;Rk(function(){fl$3(null,st,null,null)}),at[uf$2]=null}};function ml$2(st){this._internalRoot=st}ml$2.prototype.unstable_scheduleHydration=function(st){if(st){var at=Hc$2();st={blockedOn:null,target:st,priority:at};for(var pt=0;pt<Qc$2.length&&at!==0&&at<Qc$2[pt].priority;pt++);Qc$2.splice(pt,0,st),pt===0&&Vc$2(st)}};function nl$2(st){return!(!st||st.nodeType!==1&&st.nodeType!==9&&st.nodeType!==11)}function ol$2(st){return!(!st||st.nodeType!==1&&st.nodeType!==9&&st.nodeType!==11&&(st.nodeType!==8||st.nodeValue!==" react-mount-point-unstable "))}function pl$2(){}function ql$2(st,at,pt,vt,wt){if(wt){if(typeof vt=="function"){var $t=vt;vt=function(){var Ct=gl$2(Tt);$t.call(Ct)}}var Tt=el$2(at,vt,st,0,null,!1,!1,"",pl$2);return st._reactRootContainer=Tt,st[uf$2]=Tt.current,sf$2(st.nodeType===8?st.parentNode:st),Rk(),Tt}for(;wt=st.lastChild;)st.removeChild(wt);if(typeof vt=="function"){var Lt=vt;vt=function(){var Ct=gl$2(Ft);Lt.call(Ct)}}var Ft=bl$2(st,0,!1,null,null,!1,!1,"",pl$2);return st._reactRootContainer=Ft,st[uf$2]=Ft.current,sf$2(st.nodeType===8?st.parentNode:st),Rk(function(){fl$3(at,Ft,pt,vt)}),Ft}function rl$2(st,at,pt,vt,wt){var $t=pt._reactRootContainer;if($t){var Tt=$t;if(typeof wt=="function"){var Lt=wt;wt=function(){var Ft=gl$2(Tt);Lt.call(Ft)}}fl$3(at,Tt,st,wt)}else Tt=ql$2(pt,at,st,wt,vt);return gl$2(Tt)}Ec$2=function(st){switch(st.tag){case 3:var at=st.stateNode;if(at.current.memoizedState.isDehydrated){var pt=tc$1(at.pendingLanes);pt!==0&&(Cc$2(at,pt|1),Dk(at,B$2()),!(K$1&6)&&(Gj=B$2()+500,jg()))}break;case 13:Rk(function(){var vt=ih$1(st,1);if(vt!==null){var wt=R$2();gi$1(vt,st,1,wt)}}),il$2(st,1)}};Fc$2=function(st){if(st.tag===13){var at=ih$1(st,134217728);if(at!==null){var pt=R$2();gi$1(at,st,134217728,pt)}il$2(st,134217728)}};Gc$2=function(st){if(st.tag===13){var at=yi$1(st),pt=ih$1(st,at);if(pt!==null){var vt=R$2();gi$1(pt,st,at,vt)}il$2(st,at)}};Hc$2=function(){return C$1};Ic$2=function(st,at){var pt=C$1;try{return C$1=st,at()}finally{C$1=pt}};yb$1=function(st,at,pt){switch(at){case"input":if(bb$1(st,pt),at=pt.name,pt.type==="radio"&&at!=null){for(pt=st;pt.parentNode;)pt=pt.parentNode;for(pt=pt.querySelectorAll("input[name="+JSON.stringify(""+at)+'][type="radio"]'),at=0;at<pt.length;at++){var vt=pt[at];if(vt!==st&&vt.form===st.form){var wt=Db$1(vt);if(!wt)throw Error(p$3(90));Wa$1(vt),bb$1(vt,wt)}}}break;case"textarea":ib$1(st,pt);break;case"select":at=pt.value,at!=null&&fb$1(st,!!pt.multiple,at,!1)}};Gb$1=Qk;Hb=Rk;var sl$2={usingClientEntryPoint:!1,Events:[Cb$1,ue,Db$1,Eb$1,Fb$1,Qk]},tl$2={findFiberByHostInstance:Wc$2,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},ul$2={bundleType:tl$2.bundleType,version:tl$2.version,rendererPackageName:tl$2.rendererPackageName,rendererConfig:tl$2.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua$2.ReactCurrentDispatcher,findHostInstanceByFiber:function(st){return st=Zb$1(st),st===null?null:st.stateNode},findFiberByHostInstance:tl$2.findFiberByHostInstance||jl$2,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var vl$2=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vl$2.isDisabled&&vl$2.supportsFiber)try{kc$2=vl$2.inject(ul$2),lc$2=vl$2}catch{}}reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sl$2;reactDom_production_min.createPortal=function(st,at){var pt=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!nl$2(at))throw Error(p$3(200));return cl$2(st,at,null,pt)};reactDom_production_min.createRoot=function(st,at){if(!nl$2(st))throw Error(p$3(299));var pt=!1,vt="",wt=kl$2;return at!=null&&(at.unstable_strictMode===!0&&(pt=!0),at.identifierPrefix!==void 0&&(vt=at.identifierPrefix),at.onRecoverableError!==void 0&&(wt=at.onRecoverableError)),at=bl$2(st,1,!1,null,null,pt,!1,vt,wt),st[uf$2]=at.current,sf$2(st.nodeType===8?st.parentNode:st),new ll$2(at)};reactDom_production_min.findDOMNode=function(st){if(st==null)return null;if(st.nodeType===1)return st;var at=st._reactInternals;if(at===void 0)throw typeof st.render=="function"?Error(p$3(188)):(st=Object.keys(st).join(","),Error(p$3(268,st)));return st=Zb$1(at),st=st===null?null:st.stateNode,st};reactDom_production_min.flushSync=function(st){return Rk(st)};reactDom_production_min.hydrate=function(st,at,pt){if(!ol$2(at))throw Error(p$3(200));return rl$2(null,st,at,!0,pt)};reactDom_production_min.hydrateRoot=function(st,at,pt){if(!nl$2(st))throw Error(p$3(405));var vt=pt!=null&&pt.hydratedSources||null,wt=!1,$t="",Tt=kl$2;if(pt!=null&&(pt.unstable_strictMode===!0&&(wt=!0),pt.identifierPrefix!==void 0&&($t=pt.identifierPrefix),pt.onRecoverableError!==void 0&&(Tt=pt.onRecoverableError)),at=el$2(at,null,st,1,pt??null,wt,!1,$t,Tt),st[uf$2]=at.current,sf$2(st),vt)for(st=0;st<vt.length;st++)pt=vt[st],wt=pt._getVersion,wt=wt(pt._source),at.mutableSourceEagerHydrationData==null?at.mutableSourceEagerHydrationData=[pt,wt]:at.mutableSourceEagerHydrationData.push(pt,wt);return new ml$2(at)};reactDom_production_min.render=function(st,at,pt){if(!ol$2(at))throw Error(p$3(200));return rl$2(null,st,at,!1,pt)};reactDom_production_min.unmountComponentAtNode=function(st){if(!ol$2(st))throw Error(p$3(40));return st._reactRootContainer?(Rk(function(){rl$2(null,null,st,!1,function(){st._reactRootContainer=null,st[uf$2]=null})}),!0):!1};reactDom_production_min.unstable_batchedUpdates=Qk;reactDom_production_min.unstable_renderSubtreeIntoContainer=function(st,at,pt,vt){if(!ol$2(pt))throw Error(p$3(200));if(st==null||st._reactInternals===void 0)throw Error(p$3(38));return rl$2(st,at,pt,!1,vt)};reactDom_production_min.version="18.3.1-next-f1338f8080-20240426";function checkDCE(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)}catch(st){console.error(st)}}checkDCE(),reactDom.exports=reactDom_production_min;var reactDomExports=reactDom.exports;const ReactDOM=getDefaultExportFromCjs(reactDomExports);var m$3=reactDomExports;client.createRoot=m$3.createRoot,client.hydrateRoot=m$3.hydrateRoot;/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const REVISION="162",MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},CullFaceNone=0,CullFaceBack=1,CullFaceFront=2,CullFaceFrontBack=3,BasicShadowMap=0,PCFShadowMap=1,PCFSoftShadowMap=2,VSMShadowMap=3,FrontSide=0,BackSide=1,DoubleSide=2,NoBlending=0,NormalBlending=1,AdditiveBlending=2,SubtractiveBlending=3,MultiplyBlending=4,CustomBlending=5,AddEquation=100,SubtractEquation=101,ReverseSubtractEquation=102,MinEquation=103,MaxEquation=104,ZeroFactor=200,OneFactor=201,SrcColorFactor=202,OneMinusSrcColorFactor=203,SrcAlphaFactor=204,OneMinusSrcAlphaFactor=205,DstAlphaFactor=206,OneMinusDstAlphaFactor=207,DstColorFactor=208,OneMinusDstColorFactor=209,SrcAlphaSaturateFactor=210,ConstantColorFactor=211,OneMinusConstantColorFactor=212,ConstantAlphaFactor=213,OneMinusConstantAlphaFactor=214,NeverDepth=0,AlwaysDepth=1,LessDepth=2,LessEqualDepth=3,EqualDepth=4,GreaterEqualDepth=5,GreaterDepth=6,NotEqualDepth=7,MultiplyOperation=0,MixOperation=1,AddOperation=2,NoToneMapping=0,LinearToneMapping=1,ReinhardToneMapping=2,CineonToneMapping=3,ACESFilmicToneMapping=4,CustomToneMapping=5,AgXToneMapping=6,NeutralToneMapping=7,AttachedBindMode="attached",DetachedBindMode="detached",UVMapping=300,CubeReflectionMapping=301,CubeRefractionMapping=302,EquirectangularReflectionMapping=303,EquirectangularRefractionMapping=304,CubeUVReflectionMapping=306,RepeatWrapping=1e3,ClampToEdgeWrapping=1001,MirroredRepeatWrapping=1002,NearestFilter=1003,NearestMipmapNearestFilter=1004,NearestMipMapNearestFilter=1004,NearestMipmapLinearFilter=1005,NearestMipMapLinearFilter=1005,LinearFilter=1006,LinearMipmapNearestFilter=1007,LinearMipMapNearestFilter=1007,LinearMipmapLinearFilter=1008,LinearMipMapLinearFilter=1008,UnsignedByteType=1009,ByteType=1010,ShortType=1011,UnsignedShortType=1012,IntType=1013,UnsignedIntType=1014,FloatType=1015,HalfFloatType=1016,UnsignedShort4444Type=1017,UnsignedShort5551Type=1018,UnsignedInt248Type=1020,AlphaFormat=1021,RGBAFormat=1023,LuminanceFormat=1024,LuminanceAlphaFormat=1025,DepthFormat=1026,DepthStencilFormat=1027,RedFormat=1028,RedIntegerFormat=1029,RGFormat=1030,RGIntegerFormat=1031,RGBAIntegerFormat=1033,RGB_S3TC_DXT1_Format=33776,RGBA_S3TC_DXT1_Format=33777,RGBA_S3TC_DXT3_Format=33778,RGBA_S3TC_DXT5_Format=33779,RGB_PVRTC_4BPPV1_Format=35840,RGB_PVRTC_2BPPV1_Format=35841,RGBA_PVRTC_4BPPV1_Format=35842,RGBA_PVRTC_2BPPV1_Format=35843,RGB_ETC1_Format=36196,RGB_ETC2_Format=37492,RGBA_ETC2_EAC_Format=37496,RGBA_ASTC_4x4_Format=37808,RGBA_ASTC_5x4_Format=37809,RGBA_ASTC_5x5_Format=37810,RGBA_ASTC_6x5_Format=37811,RGBA_ASTC_6x6_Format=37812,RGBA_ASTC_8x5_Format=37813,RGBA_ASTC_8x6_Format=37814,RGBA_ASTC_8x8_Format=37815,RGBA_ASTC_10x5_Format=37816,RGBA_ASTC_10x6_Format=37817,RGBA_ASTC_10x8_Format=37818,RGBA_ASTC_10x10_Format=37819,RGBA_ASTC_12x10_Format=37820,RGBA_ASTC_12x12_Format=37821,RGBA_BPTC_Format=36492,RGB_BPTC_SIGNED_Format=36494,RGB_BPTC_UNSIGNED_Format=36495,RED_RGTC1_Format=36283,SIGNED_RED_RGTC1_Format=36284,RED_GREEN_RGTC2_Format=36285,SIGNED_RED_GREEN_RGTC2_Format=36286,LoopOnce=2200,LoopRepeat=2201,LoopPingPong=2202,InterpolateDiscrete=2300,InterpolateLinear=2301,InterpolateSmooth=2302,ZeroCurvatureEnding=2400,ZeroSlopeEnding=2401,WrapAroundEnding=2402,NormalAnimationBlendMode=2500,AdditiveAnimationBlendMode=2501,TrianglesDrawMode=0,TriangleStripDrawMode=1,TriangleFanDrawMode=2,BasicDepthPacking=3200,RGBADepthPacking=3201,TangentSpaceNormalMap=0,ObjectSpaceNormalMap=1,NoColorSpace="",SRGBColorSpace$1="srgb",LinearSRGBColorSpace$1="srgb-linear",DisplayP3ColorSpace="display-p3",LinearDisplayP3ColorSpace="display-p3-linear",LinearTransfer="linear",SRGBTransfer="srgb",Rec709Primaries="rec709",P3Primaries="p3",ZeroStencilOp=0,KeepStencilOp=7680,ReplaceStencilOp=7681,IncrementStencilOp=7682,DecrementStencilOp=7683,IncrementWrapStencilOp=34055,DecrementWrapStencilOp=34056,InvertStencilOp=5386,NeverStencilFunc=512,LessStencilFunc=513,EqualStencilFunc=514,LessEqualStencilFunc=515,GreaterStencilFunc=516,NotEqualStencilFunc=517,GreaterEqualStencilFunc=518,AlwaysStencilFunc=519,NeverCompare=512,LessCompare=513,EqualCompare=514,LessEqualCompare=515,GreaterCompare=516,NotEqualCompare=517,GreaterEqualCompare=518,AlwaysCompare=519,StaticDrawUsage=35044,DynamicDrawUsage=35048,StreamDrawUsage=35040,StaticReadUsage=35045,DynamicReadUsage=35049,StreamReadUsage=35041,StaticCopyUsage=35046,DynamicCopyUsage=35050,StreamCopyUsage=35042,GLSL1="100",GLSL3="300 es",_SRGBAFormat=1035,WebGLCoordinateSystem=2e3,WebGPUCoordinateSystem=2001;class EventDispatcher{addEventListener(at,pt){this._listeners===void 0&&(this._listeners={});const vt=this._listeners;vt[at]===void 0&&(vt[at]=[]),vt[at].indexOf(pt)===-1&&vt[at].push(pt)}hasEventListener(at,pt){if(this._listeners===void 0)return!1;const vt=this._listeners;return vt[at]!==void 0&&vt[at].indexOf(pt)!==-1}removeEventListener(at,pt){if(this._listeners===void 0)return;const wt=this._listeners[at];if(wt!==void 0){const $t=wt.indexOf(pt);$t!==-1&&wt.splice($t,1)}}dispatchEvent(at){if(this._listeners===void 0)return;const vt=this._listeners[at.type];if(vt!==void 0){at.target=this;const wt=vt.slice(0);for(let $t=0,Tt=wt.length;$t<Tt;$t++)wt[$t].call(this,at);at.target=null}}}const _lut=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let _seed=1234567;const DEG2RAD=Math.PI/180,RAD2DEG=180/Math.PI;function generateUUID(){const st=Math.random()*4294967295|0,at=Math.random()*4294967295|0,pt=Math.random()*4294967295|0,vt=Math.random()*4294967295|0;return(_lut[st&255]+_lut[st>>8&255]+_lut[st>>16&255]+_lut[st>>24&255]+"-"+_lut[at&255]+_lut[at>>8&255]+"-"+_lut[at>>16&15|64]+_lut[at>>24&255]+"-"+_lut[pt&63|128]+_lut[pt>>8&255]+"-"+_lut[pt>>16&255]+_lut[pt>>24&255]+_lut[vt&255]+_lut[vt>>8&255]+_lut[vt>>16&255]+_lut[vt>>24&255]).toLowerCase()}function clamp$3(st,at,pt){return Math.max(at,Math.min(pt,st))}function euclideanModulo(st,at){return(st%at+at)%at}function mapLinear(st,at,pt,vt,wt){return vt+(st-at)*(wt-vt)/(pt-at)}function inverseLerp(st,at,pt){return st!==at?(pt-st)/(at-st):0}function lerp(st,at,pt){return(1-pt)*st+pt*at}function damp(st,at,pt,vt){return lerp(st,at,1-Math.exp(-pt*vt))}function pingpong(st,at=1){return at-Math.abs(euclideanModulo(st,at*2)-at)}function smoothstep(st,at,pt){return st<=at?0:st>=pt?1:(st=(st-at)/(pt-at),st*st*(3-2*st))}function smootherstep(st,at,pt){return st<=at?0:st>=pt?1:(st=(st-at)/(pt-at),st*st*st*(st*(st*6-15)+10))}function randInt(st,at){return st+Math.floor(Math.random()*(at-st+1))}function randFloat(st,at){return st+Math.random()*(at-st)}function randFloatSpread(st){return st*(.5-Math.random())}function seededRandom(st){st!==void 0&&(_seed=st);let at=_seed+=1831565813;return at=Math.imul(at^at>>>15,at|1),at^=at+Math.imul(at^at>>>7,at|61),((at^at>>>14)>>>0)/4294967296}function degToRad(st){return st*DEG2RAD}function radToDeg(st){return st*RAD2DEG}function isPowerOfTwo(st){return(st&st-1)===0&&st!==0}function ceilPowerOfTwo(st){return Math.pow(2,Math.ceil(Math.log(st)/Math.LN2))}function floorPowerOfTwo(st){return Math.pow(2,Math.floor(Math.log(st)/Math.LN2))}function setQuaternionFromProperEuler(st,at,pt,vt,wt){const $t=Math.cos,Tt=Math.sin,Lt=$t(pt/2),Ft=Tt(pt/2),Ct=$t((at+vt)/2),Ht=Tt((at+vt)/2),Gt=$t((at-vt)/2),jt=Tt((at-vt)/2),qt=$t((vt-at)/2),Kt=Tt((vt-at)/2);switch(wt){case"XYX":st.set(Lt*Ht,Ft*Gt,Ft*jt,Lt*Ct);break;case"YZY":st.set(Ft*jt,Lt*Ht,Ft*Gt,Lt*Ct);break;case"ZXZ":st.set(Ft*Gt,Ft*jt,Lt*Ht,Lt*Ct);break;case"XZX":st.set(Lt*Ht,Ft*Kt,Ft*qt,Lt*Ct);break;case"YXY":st.set(Ft*qt,Lt*Ht,Ft*Kt,Lt*Ct);break;case"ZYZ":st.set(Ft*Kt,Ft*qt,Lt*Ht,Lt*Ct);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+wt)}}function denormalize(st,at){switch(at.constructor){case Float32Array:return st;case Uint32Array:return st/4294967295;case Uint16Array:return st/65535;case Uint8Array:return st/255;case Int32Array:return Math.max(st/2147483647,-1);case Int16Array:return Math.max(st/32767,-1);case Int8Array:return Math.max(st/127,-1);default:throw new Error("Invalid component type.")}}function normalize$5(st,at){switch(at.constructor){case Float32Array:return st;case Uint32Array:return Math.round(st*4294967295);case Uint16Array:return Math.round(st*65535);case Uint8Array:return Math.round(st*255);case Int32Array:return Math.round(st*2147483647);case Int16Array:return Math.round(st*32767);case Int8Array:return Math.round(st*127);default:throw new Error("Invalid component type.")}}const MathUtils={DEG2RAD,RAD2DEG,generateUUID,clamp:clamp$3,euclideanModulo,mapLinear,inverseLerp,lerp,damp,pingpong,smoothstep,smootherstep,randInt,randFloat,randFloatSpread,seededRandom,degToRad,radToDeg,isPowerOfTwo,ceilPowerOfTwo,floorPowerOfTwo,setQuaternionFromProperEuler,normalize:normalize$5,denormalize};class Vector2{constructor(at=0,pt=0){Vector2.prototype.isVector2=!0,this.x=at,this.y=pt}get width(){return this.x}set width(at){this.x=at}get height(){return this.y}set height(at){this.y=at}set(at,pt){return this.x=at,this.y=pt,this}setScalar(at){return this.x=at,this.y=at,this}setX(at){return this.x=at,this}setY(at){return this.y=at,this}setComponent(at,pt){switch(at){case 0:this.x=pt;break;case 1:this.y=pt;break;default:throw new Error("index is out of range: "+at)}return this}getComponent(at){switch(at){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+at)}}clone(){return new this.constructor(this.x,this.y)}copy(at){return this.x=at.x,this.y=at.y,this}add(at){return this.x+=at.x,this.y+=at.y,this}addScalar(at){return this.x+=at,this.y+=at,this}addVectors(at,pt){return this.x=at.x+pt.x,this.y=at.y+pt.y,this}addScaledVector(at,pt){return this.x+=at.x*pt,this.y+=at.y*pt,this}sub(at){return this.x-=at.x,this.y-=at.y,this}subScalar(at){return this.x-=at,this.y-=at,this}subVectors(at,pt){return this.x=at.x-pt.x,this.y=at.y-pt.y,this}multiply(at){return this.x*=at.x,this.y*=at.y,this}multiplyScalar(at){return this.x*=at,this.y*=at,this}divide(at){return this.x/=at.x,this.y/=at.y,this}divideScalar(at){return this.multiplyScalar(1/at)}applyMatrix3(at){const pt=this.x,vt=this.y,wt=at.elements;return this.x=wt[0]*pt+wt[3]*vt+wt[6],this.y=wt[1]*pt+wt[4]*vt+wt[7],this}min(at){return this.x=Math.min(this.x,at.x),this.y=Math.min(this.y,at.y),this}max(at){return this.x=Math.max(this.x,at.x),this.y=Math.max(this.y,at.y),this}clamp(at,pt){return this.x=Math.max(at.x,Math.min(pt.x,this.x)),this.y=Math.max(at.y,Math.min(pt.y,this.y)),this}clampScalar(at,pt){return this.x=Math.max(at,Math.min(pt,this.x)),this.y=Math.max(at,Math.min(pt,this.y)),this}clampLength(at,pt){const vt=this.length();return this.divideScalar(vt||1).multiplyScalar(Math.max(at,Math.min(pt,vt)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(at){return this.x*at.x+this.y*at.y}cross(at){return this.x*at.y-this.y*at.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(at){const pt=Math.sqrt(this.lengthSq()*at.lengthSq());if(pt===0)return Math.PI/2;const vt=this.dot(at)/pt;return Math.acos(clamp$3(vt,-1,1))}distanceTo(at){return Math.sqrt(this.distanceToSquared(at))}distanceToSquared(at){const pt=this.x-at.x,vt=this.y-at.y;return pt*pt+vt*vt}manhattanDistanceTo(at){return Math.abs(this.x-at.x)+Math.abs(this.y-at.y)}setLength(at){return this.normalize().multiplyScalar(at)}lerp(at,pt){return this.x+=(at.x-this.x)*pt,this.y+=(at.y-this.y)*pt,this}lerpVectors(at,pt,vt){return this.x=at.x+(pt.x-at.x)*vt,this.y=at.y+(pt.y-at.y)*vt,this}equals(at){return at.x===this.x&&at.y===this.y}fromArray(at,pt=0){return this.x=at[pt],this.y=at[pt+1],this}toArray(at=[],pt=0){return at[pt]=this.x,at[pt+1]=this.y,at}fromBufferAttribute(at,pt){return this.x=at.getX(pt),this.y=at.getY(pt),this}rotateAround(at,pt){const vt=Math.cos(pt),wt=Math.sin(pt),$t=this.x-at.x,Tt=this.y-at.y;return this.x=$t*vt-Tt*wt+at.x,this.y=$t*wt+Tt*vt+at.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Matrix3{constructor(at,pt,vt,wt,$t,Tt,Lt,Ft,Ct){Matrix3.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],at!==void 0&&this.set(at,pt,vt,wt,$t,Tt,Lt,Ft,Ct)}set(at,pt,vt,wt,$t,Tt,Lt,Ft,Ct){const Ht=this.elements;return Ht[0]=at,Ht[1]=wt,Ht[2]=Lt,Ht[3]=pt,Ht[4]=$t,Ht[5]=Ft,Ht[6]=vt,Ht[7]=Tt,Ht[8]=Ct,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(at){const pt=this.elements,vt=at.elements;return pt[0]=vt[0],pt[1]=vt[1],pt[2]=vt[2],pt[3]=vt[3],pt[4]=vt[4],pt[5]=vt[5],pt[6]=vt[6],pt[7]=vt[7],pt[8]=vt[8],this}extractBasis(at,pt,vt){return at.setFromMatrix3Column(this,0),pt.setFromMatrix3Column(this,1),vt.setFromMatrix3Column(this,2),this}setFromMatrix4(at){const pt=at.elements;return this.set(pt[0],pt[4],pt[8],pt[1],pt[5],pt[9],pt[2],pt[6],pt[10]),this}multiply(at){return this.multiplyMatrices(this,at)}premultiply(at){return this.multiplyMatrices(at,this)}multiplyMatrices(at,pt){const vt=at.elements,wt=pt.elements,$t=this.elements,Tt=vt[0],Lt=vt[3],Ft=vt[6],Ct=vt[1],Ht=vt[4],Gt=vt[7],jt=vt[2],qt=vt[5],Kt=vt[8],An=wt[0],Sn=wt[3],wn=wt[6],In=wt[1],tr=wt[4],rr=wt[7],Hr=wt[2],qr=wt[5],Zr=wt[8];return $t[0]=Tt*An+Lt*In+Ft*Hr,$t[3]=Tt*Sn+Lt*tr+Ft*qr,$t[6]=Tt*wn+Lt*rr+Ft*Zr,$t[1]=Ct*An+Ht*In+Gt*Hr,$t[4]=Ct*Sn+Ht*tr+Gt*qr,$t[7]=Ct*wn+Ht*rr+Gt*Zr,$t[2]=jt*An+qt*In+Kt*Hr,$t[5]=jt*Sn+qt*tr+Kt*qr,$t[8]=jt*wn+qt*rr+Kt*Zr,this}multiplyScalar(at){const pt=this.elements;return pt[0]*=at,pt[3]*=at,pt[6]*=at,pt[1]*=at,pt[4]*=at,pt[7]*=at,pt[2]*=at,pt[5]*=at,pt[8]*=at,this}determinant(){const at=this.elements,pt=at[0],vt=at[1],wt=at[2],$t=at[3],Tt=at[4],Lt=at[5],Ft=at[6],Ct=at[7],Ht=at[8];return pt*Tt*Ht-pt*Lt*Ct-vt*$t*Ht+vt*Lt*Ft+wt*$t*Ct-wt*Tt*Ft}invert(){const at=this.elements,pt=at[0],vt=at[1],wt=at[2],$t=at[3],Tt=at[4],Lt=at[5],Ft=at[6],Ct=at[7],Ht=at[8],Gt=Ht*Tt-Lt*Ct,jt=Lt*Ft-Ht*$t,qt=Ct*$t-Tt*Ft,Kt=pt*Gt+vt*jt+wt*qt;if(Kt===0)return this.set(0,0,0,0,0,0,0,0,0);const An=1/Kt;return at[0]=Gt*An,at[1]=(wt*Ct-Ht*vt)*An,at[2]=(Lt*vt-wt*Tt)*An,at[3]=jt*An,at[4]=(Ht*pt-wt*Ft)*An,at[5]=(wt*$t-Lt*pt)*An,at[6]=qt*An,at[7]=(vt*Ft-Ct*pt)*An,at[8]=(Tt*pt-vt*$t)*An,this}transpose(){let at;const pt=this.elements;return at=pt[1],pt[1]=pt[3],pt[3]=at,at=pt[2],pt[2]=pt[6],pt[6]=at,at=pt[5],pt[5]=pt[7],pt[7]=at,this}getNormalMatrix(at){return this.setFromMatrix4(at).invert().transpose()}transposeIntoArray(at){const pt=this.elements;return at[0]=pt[0],at[1]=pt[3],at[2]=pt[6],at[3]=pt[1],at[4]=pt[4],at[5]=pt[7],at[6]=pt[2],at[7]=pt[5],at[8]=pt[8],this}setUvTransform(at,pt,vt,wt,$t,Tt,Lt){const Ft=Math.cos($t),Ct=Math.sin($t);return this.set(vt*Ft,vt*Ct,-vt*(Ft*Tt+Ct*Lt)+Tt+at,-wt*Ct,wt*Ft,-wt*(-Ct*Tt+Ft*Lt)+Lt+pt,0,0,1),this}scale(at,pt){return this.premultiply(_m3.makeScale(at,pt)),this}rotate(at){return this.premultiply(_m3.makeRotation(-at)),this}translate(at,pt){return this.premultiply(_m3.makeTranslation(at,pt)),this}makeTranslation(at,pt){return at.isVector2?this.set(1,0,at.x,0,1,at.y,0,0,1):this.set(1,0,at,0,1,pt,0,0,1),this}makeRotation(at){const pt=Math.cos(at),vt=Math.sin(at);return this.set(pt,-vt,0,vt,pt,0,0,0,1),this}makeScale(at,pt){return this.set(at,0,0,0,pt,0,0,0,1),this}equals(at){const pt=this.elements,vt=at.elements;for(let wt=0;wt<9;wt++)if(pt[wt]!==vt[wt])return!1;return!0}fromArray(at,pt=0){for(let vt=0;vt<9;vt++)this.elements[vt]=at[vt+pt];return this}toArray(at=[],pt=0){const vt=this.elements;return at[pt]=vt[0],at[pt+1]=vt[1],at[pt+2]=vt[2],at[pt+3]=vt[3],at[pt+4]=vt[4],at[pt+5]=vt[5],at[pt+6]=vt[6],at[pt+7]=vt[7],at[pt+8]=vt[8],at}clone(){return new this.constructor().fromArray(this.elements)}}const _m3=new Matrix3;function arrayNeedsUint32(st){for(let at=st.length-1;at>=0;--at)if(st[at]>=65535)return!0;return!1}const TYPED_ARRAYS={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function getTypedArray(st,at){return new TYPED_ARRAYS[st](at)}function createElementNS(st){return document.createElementNS("http://www.w3.org/1999/xhtml",st)}function createCanvasElement(){const st=createElementNS("canvas");return st.style.display="block",st}const _cache={};function warnOnce(st){st in _cache||(_cache[st]=!0,console.warn(st))}const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3=new Matrix3().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),LINEAR_DISPLAY_P3_TO_LINEAR_SRGB=new Matrix3().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),COLOR_SPACES={[LinearSRGBColorSpace$1]:{transfer:LinearTransfer,primaries:Rec709Primaries,toReference:st=>st,fromReference:st=>st},[SRGBColorSpace$1]:{transfer:SRGBTransfer,primaries:Rec709Primaries,toReference:st=>st.convertSRGBToLinear(),fromReference:st=>st.convertLinearToSRGB()},[LinearDisplayP3ColorSpace]:{transfer:LinearTransfer,primaries:P3Primaries,toReference:st=>st.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),fromReference:st=>st.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)},[DisplayP3ColorSpace]:{transfer:SRGBTransfer,primaries:P3Primaries,toReference:st=>st.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),fromReference:st=>st.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()}},SUPPORTED_WORKING_COLOR_SPACES=new Set([LinearSRGBColorSpace$1,LinearDisplayP3ColorSpace]),ColorManagement={enabled:!0,_workingColorSpace:LinearSRGBColorSpace$1,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(st){if(!SUPPORTED_WORKING_COLOR_SPACES.has(st))throw new Error(`Unsupported working color space, "${st}".`);this._workingColorSpace=st},convert:function(st,at,pt){if(this.enabled===!1||at===pt||!at||!pt)return st;const vt=COLOR_SPACES[at].toReference,wt=COLOR_SPACES[pt].fromReference;return wt(vt(st))},fromWorkingColorSpace:function(st,at){return this.convert(st,this._workingColorSpace,at)},toWorkingColorSpace:function(st,at){return this.convert(st,at,this._workingColorSpace)},getPrimaries:function(st){return COLOR_SPACES[st].primaries},getTransfer:function(st){return st===NoColorSpace?LinearTransfer:COLOR_SPACES[st].transfer}};function SRGBToLinear(st){return st<.04045?st*.0773993808:Math.pow(st*.9478672986+.0521327014,2.4)}function LinearToSRGB(st){return st<.0031308?st*12.92:1.055*Math.pow(st,.41666)-.055}let _canvas;class ImageUtils{static getDataURL(at){if(/^data:/i.test(at.src)||typeof HTMLCanvasElement>"u")return at.src;let pt;if(at instanceof HTMLCanvasElement)pt=at;else{_canvas===void 0&&(_canvas=createElementNS("canvas")),_canvas.width=at.width,_canvas.height=at.height;const vt=_canvas.getContext("2d");at instanceof ImageData?vt.putImageData(at,0,0):vt.drawImage(at,0,0,at.width,at.height),pt=_canvas}return pt.width>2048||pt.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",at),pt.toDataURL("image/jpeg",.6)):pt.toDataURL("image/png")}static sRGBToLinear(at){if(typeof HTMLImageElement<"u"&&at instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&at instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&at instanceof ImageBitmap){const pt=createElementNS("canvas");pt.width=at.width,pt.height=at.height;const vt=pt.getContext("2d");vt.drawImage(at,0,0,at.width,at.height);const wt=vt.getImageData(0,0,at.width,at.height),$t=wt.data;for(let Tt=0;Tt<$t.length;Tt++)$t[Tt]=SRGBToLinear($t[Tt]/255)*255;return vt.putImageData(wt,0,0),pt}else if(at.data){const pt=at.data.slice(0);for(let vt=0;vt<pt.length;vt++)pt instanceof Uint8Array||pt instanceof Uint8ClampedArray?pt[vt]=Math.floor(SRGBToLinear(pt[vt]/255)*255):pt[vt]=SRGBToLinear(pt[vt]);return{data:pt,width:at.width,height:at.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),at}}let _sourceId=0;class Source{constructor(at=null){this.isSource=!0,Object.defineProperty(this,"id",{value:_sourceId++}),this.uuid=generateUUID(),this.data=at,this.dataReady=!0,this.version=0}set needsUpdate(at){at===!0&&this.version++}toJSON(at){const pt=at===void 0||typeof at=="string";if(!pt&&at.images[this.uuid]!==void 0)return at.images[this.uuid];const vt={uuid:this.uuid,url:""},wt=this.data;if(wt!==null){let $t;if(Array.isArray(wt)){$t=[];for(let Tt=0,Lt=wt.length;Tt<Lt;Tt++)wt[Tt].isDataTexture?$t.push(serializeImage(wt[Tt].image)):$t.push(serializeImage(wt[Tt]))}else $t=serializeImage(wt);vt.url=$t}return pt||(at.images[this.uuid]=vt),vt}}function serializeImage(st){return typeof HTMLImageElement<"u"&&st instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&st instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&st instanceof ImageBitmap?ImageUtils.getDataURL(st):st.data?{data:Array.from(st.data),width:st.width,height:st.height,type:st.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let _textureId=0;class Texture extends EventDispatcher{constructor(at=Texture.DEFAULT_IMAGE,pt=Texture.DEFAULT_MAPPING,vt=ClampToEdgeWrapping,wt=ClampToEdgeWrapping,$t=LinearFilter,Tt=LinearMipmapLinearFilter,Lt=RGBAFormat,Ft=UnsignedByteType,Ct=Texture.DEFAULT_ANISOTROPY,Ht=NoColorSpace){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:_textureId++}),this.uuid=generateUUID(),this.name="",this.source=new Source(at),this.mipmaps=[],this.mapping=pt,this.channel=0,this.wrapS=vt,this.wrapT=wt,this.magFilter=$t,this.minFilter=Tt,this.anisotropy=Ct,this.format=Lt,this.internalFormat=null,this.type=Ft,this.offset=new Vector2(0,0),this.repeat=new Vector2(1,1),this.center=new Vector2(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Matrix3,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=Ht,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(at=null){this.source.data=at}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(at){return this.name=at.name,this.source=at.source,this.mipmaps=at.mipmaps.slice(0),this.mapping=at.mapping,this.channel=at.channel,this.wrapS=at.wrapS,this.wrapT=at.wrapT,this.magFilter=at.magFilter,this.minFilter=at.minFilter,this.anisotropy=at.anisotropy,this.format=at.format,this.internalFormat=at.internalFormat,this.type=at.type,this.offset.copy(at.offset),this.repeat.copy(at.repeat),this.center.copy(at.center),this.rotation=at.rotation,this.matrixAutoUpdate=at.matrixAutoUpdate,this.matrix.copy(at.matrix),this.generateMipmaps=at.generateMipmaps,this.premultiplyAlpha=at.premultiplyAlpha,this.flipY=at.flipY,this.unpackAlignment=at.unpackAlignment,this.colorSpace=at.colorSpace,this.userData=JSON.parse(JSON.stringify(at.userData)),this.needsUpdate=!0,this}toJSON(at){const pt=at===void 0||typeof at=="string";if(!pt&&at.textures[this.uuid]!==void 0)return at.textures[this.uuid];const vt={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(at).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(vt.userData=this.userData),pt||(at.textures[this.uuid]=vt),vt}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(at){if(this.mapping!==UVMapping)return at;if(at.applyMatrix3(this.matrix),at.x<0||at.x>1)switch(this.wrapS){case RepeatWrapping:at.x=at.x-Math.floor(at.x);break;case ClampToEdgeWrapping:at.x=at.x<0?0:1;break;case MirroredRepeatWrapping:Math.abs(Math.floor(at.x)%2)===1?at.x=Math.ceil(at.x)-at.x:at.x=at.x-Math.floor(at.x);break}if(at.y<0||at.y>1)switch(this.wrapT){case RepeatWrapping:at.y=at.y-Math.floor(at.y);break;case ClampToEdgeWrapping:at.y=at.y<0?0:1;break;case MirroredRepeatWrapping:Math.abs(Math.floor(at.y)%2)===1?at.y=Math.ceil(at.y)-at.y:at.y=at.y-Math.floor(at.y);break}return this.flipY&&(at.y=1-at.y),at}set needsUpdate(at){at===!0&&(this.version++,this.source.needsUpdate=!0)}}Texture.DEFAULT_IMAGE=null;Texture.DEFAULT_MAPPING=UVMapping;Texture.DEFAULT_ANISOTROPY=1;class Vector4{constructor(at=0,pt=0,vt=0,wt=1){Vector4.prototype.isVector4=!0,this.x=at,this.y=pt,this.z=vt,this.w=wt}get width(){return this.z}set width(at){this.z=at}get height(){return this.w}set height(at){this.w=at}set(at,pt,vt,wt){return this.x=at,this.y=pt,this.z=vt,this.w=wt,this}setScalar(at){return this.x=at,this.y=at,this.z=at,this.w=at,this}setX(at){return this.x=at,this}setY(at){return this.y=at,this}setZ(at){return this.z=at,this}setW(at){return this.w=at,this}setComponent(at,pt){switch(at){case 0:this.x=pt;break;case 1:this.y=pt;break;case 2:this.z=pt;break;case 3:this.w=pt;break;default:throw new Error("index is out of range: "+at)}return this}getComponent(at){switch(at){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+at)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(at){return this.x=at.x,this.y=at.y,this.z=at.z,this.w=at.w!==void 0?at.w:1,this}add(at){return this.x+=at.x,this.y+=at.y,this.z+=at.z,this.w+=at.w,this}addScalar(at){return this.x+=at,this.y+=at,this.z+=at,this.w+=at,this}addVectors(at,pt){return this.x=at.x+pt.x,this.y=at.y+pt.y,this.z=at.z+pt.z,this.w=at.w+pt.w,this}addScaledVector(at,pt){return this.x+=at.x*pt,this.y+=at.y*pt,this.z+=at.z*pt,this.w+=at.w*pt,this}sub(at){return this.x-=at.x,this.y-=at.y,this.z-=at.z,this.w-=at.w,this}subScalar(at){return this.x-=at,this.y-=at,this.z-=at,this.w-=at,this}subVectors(at,pt){return this.x=at.x-pt.x,this.y=at.y-pt.y,this.z=at.z-pt.z,this.w=at.w-pt.w,this}multiply(at){return this.x*=at.x,this.y*=at.y,this.z*=at.z,this.w*=at.w,this}multiplyScalar(at){return this.x*=at,this.y*=at,this.z*=at,this.w*=at,this}applyMatrix4(at){const pt=this.x,vt=this.y,wt=this.z,$t=this.w,Tt=at.elements;return this.x=Tt[0]*pt+Tt[4]*vt+Tt[8]*wt+Tt[12]*$t,this.y=Tt[1]*pt+Tt[5]*vt+Tt[9]*wt+Tt[13]*$t,this.z=Tt[2]*pt+Tt[6]*vt+Tt[10]*wt+Tt[14]*$t,this.w=Tt[3]*pt+Tt[7]*vt+Tt[11]*wt+Tt[15]*$t,this}divideScalar(at){return this.multiplyScalar(1/at)}setAxisAngleFromQuaternion(at){this.w=2*Math.acos(at.w);const pt=Math.sqrt(1-at.w*at.w);return pt<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=at.x/pt,this.y=at.y/pt,this.z=at.z/pt),this}setAxisAngleFromRotationMatrix(at){let pt,vt,wt,$t;const Ft=at.elements,Ct=Ft[0],Ht=Ft[4],Gt=Ft[8],jt=Ft[1],qt=Ft[5],Kt=Ft[9],An=Ft[2],Sn=Ft[6],wn=Ft[10];if(Math.abs(Ht-jt)<.01&&Math.abs(Gt-An)<.01&&Math.abs(Kt-Sn)<.01){if(Math.abs(Ht+jt)<.1&&Math.abs(Gt+An)<.1&&Math.abs(Kt+Sn)<.1&&Math.abs(Ct+qt+wn-3)<.1)return this.set(1,0,0,0),this;pt=Math.PI;const tr=(Ct+1)/2,rr=(qt+1)/2,Hr=(wn+1)/2,qr=(Ht+jt)/4,Zr=(Gt+An)/4,Bo=(Kt+Sn)/4;return tr>rr&&tr>Hr?tr<.01?(vt=0,wt=.707106781,$t=.707106781):(vt=Math.sqrt(tr),wt=qr/vt,$t=Zr/vt):rr>Hr?rr<.01?(vt=.707106781,wt=0,$t=.707106781):(wt=Math.sqrt(rr),vt=qr/wt,$t=Bo/wt):Hr<.01?(vt=.707106781,wt=.707106781,$t=0):($t=Math.sqrt(Hr),vt=Zr/$t,wt=Bo/$t),this.set(vt,wt,$t,pt),this}let In=Math.sqrt((Sn-Kt)*(Sn-Kt)+(Gt-An)*(Gt-An)+(jt-Ht)*(jt-Ht));return Math.abs(In)<.001&&(In=1),this.x=(Sn-Kt)/In,this.y=(Gt-An)/In,this.z=(jt-Ht)/In,this.w=Math.acos((Ct+qt+wn-1)/2),this}min(at){return this.x=Math.min(this.x,at.x),this.y=Math.min(this.y,at.y),this.z=Math.min(this.z,at.z),this.w=Math.min(this.w,at.w),this}max(at){return this.x=Math.max(this.x,at.x),this.y=Math.max(this.y,at.y),this.z=Math.max(this.z,at.z),this.w=Math.max(this.w,at.w),this}clamp(at,pt){return this.x=Math.max(at.x,Math.min(pt.x,this.x)),this.y=Math.max(at.y,Math.min(pt.y,this.y)),this.z=Math.max(at.z,Math.min(pt.z,this.z)),this.w=Math.max(at.w,Math.min(pt.w,this.w)),this}clampScalar(at,pt){return this.x=Math.max(at,Math.min(pt,this.x)),this.y=Math.max(at,Math.min(pt,this.y)),this.z=Math.max(at,Math.min(pt,this.z)),this.w=Math.max(at,Math.min(pt,this.w)),this}clampLength(at,pt){const vt=this.length();return this.divideScalar(vt||1).multiplyScalar(Math.max(at,Math.min(pt,vt)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(at){return this.x*at.x+this.y*at.y+this.z*at.z+this.w*at.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(at){return this.normalize().multiplyScalar(at)}lerp(at,pt){return this.x+=(at.x-this.x)*pt,this.y+=(at.y-this.y)*pt,this.z+=(at.z-this.z)*pt,this.w+=(at.w-this.w)*pt,this}lerpVectors(at,pt,vt){return this.x=at.x+(pt.x-at.x)*vt,this.y=at.y+(pt.y-at.y)*vt,this.z=at.z+(pt.z-at.z)*vt,this.w=at.w+(pt.w-at.w)*vt,this}equals(at){return at.x===this.x&&at.y===this.y&&at.z===this.z&&at.w===this.w}fromArray(at,pt=0){return this.x=at[pt],this.y=at[pt+1],this.z=at[pt+2],this.w=at[pt+3],this}toArray(at=[],pt=0){return at[pt]=this.x,at[pt+1]=this.y,at[pt+2]=this.z,at[pt+3]=this.w,at}fromBufferAttribute(at,pt){return this.x=at.getX(pt),this.y=at.getY(pt),this.z=at.getZ(pt),this.w=at.getW(pt),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class RenderTarget extends EventDispatcher{constructor(at=1,pt=1,vt={}){super(),this.isRenderTarget=!0,this.width=at,this.height=pt,this.depth=1,this.scissor=new Vector4(0,0,at,pt),this.scissorTest=!1,this.viewport=new Vector4(0,0,at,pt);const wt={width:at,height:pt,depth:1};vt=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:LinearFilter,depthBuffer:!0,stencilBuffer:!1,depthTexture:null,samples:0,count:1},vt);const $t=new Texture(wt,vt.mapping,vt.wrapS,vt.wrapT,vt.magFilter,vt.minFilter,vt.format,vt.type,vt.anisotropy,vt.colorSpace);$t.flipY=!1,$t.generateMipmaps=vt.generateMipmaps,$t.internalFormat=vt.internalFormat,this.textures=[];const Tt=vt.count;for(let Lt=0;Lt<Tt;Lt++)this.textures[Lt]=$t.clone(),this.textures[Lt].isRenderTargetTexture=!0;this.depthBuffer=vt.depthBuffer,this.stencilBuffer=vt.stencilBuffer,this.depthTexture=vt.depthTexture,this.samples=vt.samples}get texture(){return this.textures[0]}set texture(at){this.textures[0]=at}setSize(at,pt,vt=1){if(this.width!==at||this.height!==pt||this.depth!==vt){this.width=at,this.height=pt,this.depth=vt;for(let wt=0,$t=this.textures.length;wt<$t;wt++)this.textures[wt].image.width=at,this.textures[wt].image.height=pt,this.textures[wt].image.depth=vt;this.dispose()}this.viewport.set(0,0,at,pt),this.scissor.set(0,0,at,pt)}clone(){return new this.constructor().copy(this)}copy(at){this.width=at.width,this.height=at.height,this.depth=at.depth,this.scissor.copy(at.scissor),this.scissorTest=at.scissorTest,this.viewport.copy(at.viewport),this.textures.length=0;for(let vt=0,wt=at.textures.length;vt<wt;vt++)this.textures[vt]=at.textures[vt].clone(),this.textures[vt].isRenderTargetTexture=!0;const pt=Object.assign({},at.texture.image);return this.texture.source=new Source(pt),this.depthBuffer=at.depthBuffer,this.stencilBuffer=at.stencilBuffer,at.depthTexture!==null&&(this.depthTexture=at.depthTexture.clone()),this.samples=at.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class WebGLRenderTarget extends RenderTarget{constructor(at=1,pt=1,vt={}){super(at,pt,vt),this.isWebGLRenderTarget=!0}}class DataArrayTexture extends Texture{constructor(at=null,pt=1,vt=1,wt=1){super(null),this.isDataArrayTexture=!0,this.image={data:at,width:pt,height:vt,depth:wt},this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.wrapR=ClampToEdgeWrapping,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class WebGLArrayRenderTarget extends WebGLRenderTarget{constructor(at=1,pt=1,vt=1,wt={}){super(at,pt,wt),this.isWebGLArrayRenderTarget=!0,this.depth=vt,this.texture=new DataArrayTexture(null,at,pt,vt),this.texture.isRenderTargetTexture=!0}}class Data3DTexture extends Texture{constructor(at=null,pt=1,vt=1,wt=1){super(null),this.isData3DTexture=!0,this.image={data:at,width:pt,height:vt,depth:wt},this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.wrapR=ClampToEdgeWrapping,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class WebGL3DRenderTarget extends WebGLRenderTarget{constructor(at=1,pt=1,vt=1,wt={}){super(at,pt,wt),this.isWebGL3DRenderTarget=!0,this.depth=vt,this.texture=new Data3DTexture(null,at,pt,vt),this.texture.isRenderTargetTexture=!0}}class Quaternion{constructor(at=0,pt=0,vt=0,wt=1){this.isQuaternion=!0,this._x=at,this._y=pt,this._z=vt,this._w=wt}static slerpFlat(at,pt,vt,wt,$t,Tt,Lt){let Ft=vt[wt+0],Ct=vt[wt+1],Ht=vt[wt+2],Gt=vt[wt+3];const jt=$t[Tt+0],qt=$t[Tt+1],Kt=$t[Tt+2],An=$t[Tt+3];if(Lt===0){at[pt+0]=Ft,at[pt+1]=Ct,at[pt+2]=Ht,at[pt+3]=Gt;return}if(Lt===1){at[pt+0]=jt,at[pt+1]=qt,at[pt+2]=Kt,at[pt+3]=An;return}if(Gt!==An||Ft!==jt||Ct!==qt||Ht!==Kt){let Sn=1-Lt;const wn=Ft*jt+Ct*qt+Ht*Kt+Gt*An,In=wn>=0?1:-1,tr=1-wn*wn;if(tr>Number.EPSILON){const Hr=Math.sqrt(tr),qr=Math.atan2(Hr,wn*In);Sn=Math.sin(Sn*qr)/Hr,Lt=Math.sin(Lt*qr)/Hr}const rr=Lt*In;if(Ft=Ft*Sn+jt*rr,Ct=Ct*Sn+qt*rr,Ht=Ht*Sn+Kt*rr,Gt=Gt*Sn+An*rr,Sn===1-Lt){const Hr=1/Math.sqrt(Ft*Ft+Ct*Ct+Ht*Ht+Gt*Gt);Ft*=Hr,Ct*=Hr,Ht*=Hr,Gt*=Hr}}at[pt]=Ft,at[pt+1]=Ct,at[pt+2]=Ht,at[pt+3]=Gt}static multiplyQuaternionsFlat(at,pt,vt,wt,$t,Tt){const Lt=vt[wt],Ft=vt[wt+1],Ct=vt[wt+2],Ht=vt[wt+3],Gt=$t[Tt],jt=$t[Tt+1],qt=$t[Tt+2],Kt=$t[Tt+3];return at[pt]=Lt*Kt+Ht*Gt+Ft*qt-Ct*jt,at[pt+1]=Ft*Kt+Ht*jt+Ct*Gt-Lt*qt,at[pt+2]=Ct*Kt+Ht*qt+Lt*jt-Ft*Gt,at[pt+3]=Ht*Kt-Lt*Gt-Ft*jt-Ct*qt,at}get x(){return this._x}set x(at){this._x=at,this._onChangeCallback()}get y(){return this._y}set y(at){this._y=at,this._onChangeCallback()}get z(){return this._z}set z(at){this._z=at,this._onChangeCallback()}get w(){return this._w}set w(at){this._w=at,this._onChangeCallback()}set(at,pt,vt,wt){return this._x=at,this._y=pt,this._z=vt,this._w=wt,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(at){return this._x=at.x,this._y=at.y,this._z=at.z,this._w=at.w,this._onChangeCallback(),this}setFromEuler(at,pt=!0){const vt=at._x,wt=at._y,$t=at._z,Tt=at._order,Lt=Math.cos,Ft=Math.sin,Ct=Lt(vt/2),Ht=Lt(wt/2),Gt=Lt($t/2),jt=Ft(vt/2),qt=Ft(wt/2),Kt=Ft($t/2);switch(Tt){case"XYZ":this._x=jt*Ht*Gt+Ct*qt*Kt,this._y=Ct*qt*Gt-jt*Ht*Kt,this._z=Ct*Ht*Kt+jt*qt*Gt,this._w=Ct*Ht*Gt-jt*qt*Kt;break;case"YXZ":this._x=jt*Ht*Gt+Ct*qt*Kt,this._y=Ct*qt*Gt-jt*Ht*Kt,this._z=Ct*Ht*Kt-jt*qt*Gt,this._w=Ct*Ht*Gt+jt*qt*Kt;break;case"ZXY":this._x=jt*Ht*Gt-Ct*qt*Kt,this._y=Ct*qt*Gt+jt*Ht*Kt,this._z=Ct*Ht*Kt+jt*qt*Gt,this._w=Ct*Ht*Gt-jt*qt*Kt;break;case"ZYX":this._x=jt*Ht*Gt-Ct*qt*Kt,this._y=Ct*qt*Gt+jt*Ht*Kt,this._z=Ct*Ht*Kt-jt*qt*Gt,this._w=Ct*Ht*Gt+jt*qt*Kt;break;case"YZX":this._x=jt*Ht*Gt+Ct*qt*Kt,this._y=Ct*qt*Gt+jt*Ht*Kt,this._z=Ct*Ht*Kt-jt*qt*Gt,this._w=Ct*Ht*Gt-jt*qt*Kt;break;case"XZY":this._x=jt*Ht*Gt-Ct*qt*Kt,this._y=Ct*qt*Gt-jt*Ht*Kt,this._z=Ct*Ht*Kt+jt*qt*Gt,this._w=Ct*Ht*Gt+jt*qt*Kt;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+Tt)}return pt===!0&&this._onChangeCallback(),this}setFromAxisAngle(at,pt){const vt=pt/2,wt=Math.sin(vt);return this._x=at.x*wt,this._y=at.y*wt,this._z=at.z*wt,this._w=Math.cos(vt),this._onChangeCallback(),this}setFromRotationMatrix(at){const pt=at.elements,vt=pt[0],wt=pt[4],$t=pt[8],Tt=pt[1],Lt=pt[5],Ft=pt[9],Ct=pt[2],Ht=pt[6],Gt=pt[10],jt=vt+Lt+Gt;if(jt>0){const qt=.5/Math.sqrt(jt+1);this._w=.25/qt,this._x=(Ht-Ft)*qt,this._y=($t-Ct)*qt,this._z=(Tt-wt)*qt}else if(vt>Lt&&vt>Gt){const qt=2*Math.sqrt(1+vt-Lt-Gt);this._w=(Ht-Ft)/qt,this._x=.25*qt,this._y=(wt+Tt)/qt,this._z=($t+Ct)/qt}else if(Lt>Gt){const qt=2*Math.sqrt(1+Lt-vt-Gt);this._w=($t-Ct)/qt,this._x=(wt+Tt)/qt,this._y=.25*qt,this._z=(Ft+Ht)/qt}else{const qt=2*Math.sqrt(1+Gt-vt-Lt);this._w=(Tt-wt)/qt,this._x=($t+Ct)/qt,this._y=(Ft+Ht)/qt,this._z=.25*qt}return this._onChangeCallback(),this}setFromUnitVectors(at,pt){let vt=at.dot(pt)+1;return vt<Number.EPSILON?(vt=0,Math.abs(at.x)>Math.abs(at.z)?(this._x=-at.y,this._y=at.x,this._z=0,this._w=vt):(this._x=0,this._y=-at.z,this._z=at.y,this._w=vt)):(this._x=at.y*pt.z-at.z*pt.y,this._y=at.z*pt.x-at.x*pt.z,this._z=at.x*pt.y-at.y*pt.x,this._w=vt),this.normalize()}angleTo(at){return 2*Math.acos(Math.abs(clamp$3(this.dot(at),-1,1)))}rotateTowards(at,pt){const vt=this.angleTo(at);if(vt===0)return this;const wt=Math.min(1,pt/vt);return this.slerp(at,wt),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(at){return this._x*at._x+this._y*at._y+this._z*at._z+this._w*at._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let at=this.length();return at===0?(this._x=0,this._y=0,this._z=0,this._w=1):(at=1/at,this._x=this._x*at,this._y=this._y*at,this._z=this._z*at,this._w=this._w*at),this._onChangeCallback(),this}multiply(at){return this.multiplyQuaternions(this,at)}premultiply(at){return this.multiplyQuaternions(at,this)}multiplyQuaternions(at,pt){const vt=at._x,wt=at._y,$t=at._z,Tt=at._w,Lt=pt._x,Ft=pt._y,Ct=pt._z,Ht=pt._w;return this._x=vt*Ht+Tt*Lt+wt*Ct-$t*Ft,this._y=wt*Ht+Tt*Ft+$t*Lt-vt*Ct,this._z=$t*Ht+Tt*Ct+vt*Ft-wt*Lt,this._w=Tt*Ht-vt*Lt-wt*Ft-$t*Ct,this._onChangeCallback(),this}slerp(at,pt){if(pt===0)return this;if(pt===1)return this.copy(at);const vt=this._x,wt=this._y,$t=this._z,Tt=this._w;let Lt=Tt*at._w+vt*at._x+wt*at._y+$t*at._z;if(Lt<0?(this._w=-at._w,this._x=-at._x,this._y=-at._y,this._z=-at._z,Lt=-Lt):this.copy(at),Lt>=1)return this._w=Tt,this._x=vt,this._y=wt,this._z=$t,this;const Ft=1-Lt*Lt;if(Ft<=Number.EPSILON){const qt=1-pt;return this._w=qt*Tt+pt*this._w,this._x=qt*vt+pt*this._x,this._y=qt*wt+pt*this._y,this._z=qt*$t+pt*this._z,this.normalize(),this}const Ct=Math.sqrt(Ft),Ht=Math.atan2(Ct,Lt),Gt=Math.sin((1-pt)*Ht)/Ct,jt=Math.sin(pt*Ht)/Ct;return this._w=Tt*Gt+this._w*jt,this._x=vt*Gt+this._x*jt,this._y=wt*Gt+this._y*jt,this._z=$t*Gt+this._z*jt,this._onChangeCallback(),this}slerpQuaternions(at,pt,vt){return this.copy(at).slerp(pt,vt)}random(){const at=2*Math.PI*Math.random(),pt=2*Math.PI*Math.random(),vt=Math.random(),wt=Math.sqrt(1-vt),$t=Math.sqrt(vt);return this.set(wt*Math.sin(at),wt*Math.cos(at),$t*Math.sin(pt),$t*Math.cos(pt))}equals(at){return at._x===this._x&&at._y===this._y&&at._z===this._z&&at._w===this._w}fromArray(at,pt=0){return this._x=at[pt],this._y=at[pt+1],this._z=at[pt+2],this._w=at[pt+3],this._onChangeCallback(),this}toArray(at=[],pt=0){return at[pt]=this._x,at[pt+1]=this._y,at[pt+2]=this._z,at[pt+3]=this._w,at}fromBufferAttribute(at,pt){return this._x=at.getX(pt),this._y=at.getY(pt),this._z=at.getZ(pt),this._w=at.getW(pt),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(at){return this._onChangeCallback=at,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Vector3{constructor(at=0,pt=0,vt=0){Vector3.prototype.isVector3=!0,this.x=at,this.y=pt,this.z=vt}set(at,pt,vt){return vt===void 0&&(vt=this.z),this.x=at,this.y=pt,this.z=vt,this}setScalar(at){return this.x=at,this.y=at,this.z=at,this}setX(at){return this.x=at,this}setY(at){return this.y=at,this}setZ(at){return this.z=at,this}setComponent(at,pt){switch(at){case 0:this.x=pt;break;case 1:this.y=pt;break;case 2:this.z=pt;break;default:throw new Error("index is out of range: "+at)}return this}getComponent(at){switch(at){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+at)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(at){return this.x=at.x,this.y=at.y,this.z=at.z,this}add(at){return this.x+=at.x,this.y+=at.y,this.z+=at.z,this}addScalar(at){return this.x+=at,this.y+=at,this.z+=at,this}addVectors(at,pt){return this.x=at.x+pt.x,this.y=at.y+pt.y,this.z=at.z+pt.z,this}addScaledVector(at,pt){return this.x+=at.x*pt,this.y+=at.y*pt,this.z+=at.z*pt,this}sub(at){return this.x-=at.x,this.y-=at.y,this.z-=at.z,this}subScalar(at){return this.x-=at,this.y-=at,this.z-=at,this}subVectors(at,pt){return this.x=at.x-pt.x,this.y=at.y-pt.y,this.z=at.z-pt.z,this}multiply(at){return this.x*=at.x,this.y*=at.y,this.z*=at.z,this}multiplyScalar(at){return this.x*=at,this.y*=at,this.z*=at,this}multiplyVectors(at,pt){return this.x=at.x*pt.x,this.y=at.y*pt.y,this.z=at.z*pt.z,this}applyEuler(at){return this.applyQuaternion(_quaternion$4.setFromEuler(at))}applyAxisAngle(at,pt){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(at,pt))}applyMatrix3(at){const pt=this.x,vt=this.y,wt=this.z,$t=at.elements;return this.x=$t[0]*pt+$t[3]*vt+$t[6]*wt,this.y=$t[1]*pt+$t[4]*vt+$t[7]*wt,this.z=$t[2]*pt+$t[5]*vt+$t[8]*wt,this}applyNormalMatrix(at){return this.applyMatrix3(at).normalize()}applyMatrix4(at){const pt=this.x,vt=this.y,wt=this.z,$t=at.elements,Tt=1/($t[3]*pt+$t[7]*vt+$t[11]*wt+$t[15]);return this.x=($t[0]*pt+$t[4]*vt+$t[8]*wt+$t[12])*Tt,this.y=($t[1]*pt+$t[5]*vt+$t[9]*wt+$t[13])*Tt,this.z=($t[2]*pt+$t[6]*vt+$t[10]*wt+$t[14])*Tt,this}applyQuaternion(at){const pt=this.x,vt=this.y,wt=this.z,$t=at.x,Tt=at.y,Lt=at.z,Ft=at.w,Ct=2*(Tt*wt-Lt*vt),Ht=2*(Lt*pt-$t*wt),Gt=2*($t*vt-Tt*pt);return this.x=pt+Ft*Ct+Tt*Gt-Lt*Ht,this.y=vt+Ft*Ht+Lt*Ct-$t*Gt,this.z=wt+Ft*Gt+$t*Ht-Tt*Ct,this}project(at){return this.applyMatrix4(at.matrixWorldInverse).applyMatrix4(at.projectionMatrix)}unproject(at){return this.applyMatrix4(at.projectionMatrixInverse).applyMatrix4(at.matrixWorld)}transformDirection(at){const pt=this.x,vt=this.y,wt=this.z,$t=at.elements;return this.x=$t[0]*pt+$t[4]*vt+$t[8]*wt,this.y=$t[1]*pt+$t[5]*vt+$t[9]*wt,this.z=$t[2]*pt+$t[6]*vt+$t[10]*wt,this.normalize()}divide(at){return this.x/=at.x,this.y/=at.y,this.z/=at.z,this}divideScalar(at){return this.multiplyScalar(1/at)}min(at){return this.x=Math.min(this.x,at.x),this.y=Math.min(this.y,at.y),this.z=Math.min(this.z,at.z),this}max(at){return this.x=Math.max(this.x,at.x),this.y=Math.max(this.y,at.y),this.z=Math.max(this.z,at.z),this}clamp(at,pt){return this.x=Math.max(at.x,Math.min(pt.x,this.x)),this.y=Math.max(at.y,Math.min(pt.y,this.y)),this.z=Math.max(at.z,Math.min(pt.z,this.z)),this}clampScalar(at,pt){return this.x=Math.max(at,Math.min(pt,this.x)),this.y=Math.max(at,Math.min(pt,this.y)),this.z=Math.max(at,Math.min(pt,this.z)),this}clampLength(at,pt){const vt=this.length();return this.divideScalar(vt||1).multiplyScalar(Math.max(at,Math.min(pt,vt)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(at){return this.x*at.x+this.y*at.y+this.z*at.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(at){return this.normalize().multiplyScalar(at)}lerp(at,pt){return this.x+=(at.x-this.x)*pt,this.y+=(at.y-this.y)*pt,this.z+=(at.z-this.z)*pt,this}lerpVectors(at,pt,vt){return this.x=at.x+(pt.x-at.x)*vt,this.y=at.y+(pt.y-at.y)*vt,this.z=at.z+(pt.z-at.z)*vt,this}cross(at){return this.crossVectors(this,at)}crossVectors(at,pt){const vt=at.x,wt=at.y,$t=at.z,Tt=pt.x,Lt=pt.y,Ft=pt.z;return this.x=wt*Ft-$t*Lt,this.y=$t*Tt-vt*Ft,this.z=vt*Lt-wt*Tt,this}projectOnVector(at){const pt=at.lengthSq();if(pt===0)return this.set(0,0,0);const vt=at.dot(this)/pt;return this.copy(at).multiplyScalar(vt)}projectOnPlane(at){return _vector$c.copy(this).projectOnVector(at),this.sub(_vector$c)}reflect(at){return this.sub(_vector$c.copy(at).multiplyScalar(2*this.dot(at)))}angleTo(at){const pt=Math.sqrt(this.lengthSq()*at.lengthSq());if(pt===0)return Math.PI/2;const vt=this.dot(at)/pt;return Math.acos(clamp$3(vt,-1,1))}distanceTo(at){return Math.sqrt(this.distanceToSquared(at))}distanceToSquared(at){const pt=this.x-at.x,vt=this.y-at.y,wt=this.z-at.z;return pt*pt+vt*vt+wt*wt}manhattanDistanceTo(at){return Math.abs(this.x-at.x)+Math.abs(this.y-at.y)+Math.abs(this.z-at.z)}setFromSpherical(at){return this.setFromSphericalCoords(at.radius,at.phi,at.theta)}setFromSphericalCoords(at,pt,vt){const wt=Math.sin(pt)*at;return this.x=wt*Math.sin(vt),this.y=Math.cos(pt)*at,this.z=wt*Math.cos(vt),this}setFromCylindrical(at){return this.setFromCylindricalCoords(at.radius,at.theta,at.y)}setFromCylindricalCoords(at,pt,vt){return this.x=at*Math.sin(pt),this.y=vt,this.z=at*Math.cos(pt),this}setFromMatrixPosition(at){const pt=at.elements;return this.x=pt[12],this.y=pt[13],this.z=pt[14],this}setFromMatrixScale(at){const pt=this.setFromMatrixColumn(at,0).length(),vt=this.setFromMatrixColumn(at,1).length(),wt=this.setFromMatrixColumn(at,2).length();return this.x=pt,this.y=vt,this.z=wt,this}setFromMatrixColumn(at,pt){return this.fromArray(at.elements,pt*4)}setFromMatrix3Column(at,pt){return this.fromArray(at.elements,pt*3)}setFromEuler(at){return this.x=at._x,this.y=at._y,this.z=at._z,this}setFromColor(at){return this.x=at.r,this.y=at.g,this.z=at.b,this}equals(at){return at.x===this.x&&at.y===this.y&&at.z===this.z}fromArray(at,pt=0){return this.x=at[pt],this.y=at[pt+1],this.z=at[pt+2],this}toArray(at=[],pt=0){return at[pt]=this.x,at[pt+1]=this.y,at[pt+2]=this.z,at}fromBufferAttribute(at,pt){return this.x=at.getX(pt),this.y=at.getY(pt),this.z=at.getZ(pt),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const at=Math.random()*Math.PI*2,pt=Math.random()*2-1,vt=Math.sqrt(1-pt*pt);return this.x=vt*Math.cos(at),this.y=pt,this.z=vt*Math.sin(at),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const _vector$c=new Vector3,_quaternion$4=new Quaternion;class Box3{constructor(at=new Vector3(1/0,1/0,1/0),pt=new Vector3(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=at,this.max=pt}set(at,pt){return this.min.copy(at),this.max.copy(pt),this}setFromArray(at){this.makeEmpty();for(let pt=0,vt=at.length;pt<vt;pt+=3)this.expandByPoint(_vector$b.fromArray(at,pt));return this}setFromBufferAttribute(at){this.makeEmpty();for(let pt=0,vt=at.count;pt<vt;pt++)this.expandByPoint(_vector$b.fromBufferAttribute(at,pt));return this}setFromPoints(at){this.makeEmpty();for(let pt=0,vt=at.length;pt<vt;pt++)this.expandByPoint(at[pt]);return this}setFromCenterAndSize(at,pt){const vt=_vector$b.copy(pt).multiplyScalar(.5);return this.min.copy(at).sub(vt),this.max.copy(at).add(vt),this}setFromObject(at,pt=!1){return this.makeEmpty(),this.expandByObject(at,pt)}clone(){return new this.constructor().copy(this)}copy(at){return this.min.copy(at.min),this.max.copy(at.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(at){return this.isEmpty()?at.set(0,0,0):at.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(at){return this.isEmpty()?at.set(0,0,0):at.subVectors(this.max,this.min)}expandByPoint(at){return this.min.min(at),this.max.max(at),this}expandByVector(at){return this.min.sub(at),this.max.add(at),this}expandByScalar(at){return this.min.addScalar(-at),this.max.addScalar(at),this}expandByObject(at,pt=!1){at.updateWorldMatrix(!1,!1);const vt=at.geometry;if(vt!==void 0){const $t=vt.getAttribute("position");if(pt===!0&&$t!==void 0&&at.isInstancedMesh!==!0)for(let Tt=0,Lt=$t.count;Tt<Lt;Tt++)at.isMesh===!0?at.getVertexPosition(Tt,_vector$b):_vector$b.fromBufferAttribute($t,Tt),_vector$b.applyMatrix4(at.matrixWorld),this.expandByPoint(_vector$b);else at.boundingBox!==void 0?(at.boundingBox===null&&at.computeBoundingBox(),_box$4.copy(at.boundingBox)):(vt.boundingBox===null&&vt.computeBoundingBox(),_box$4.copy(vt.boundingBox)),_box$4.applyMatrix4(at.matrixWorld),this.union(_box$4)}const wt=at.children;for(let $t=0,Tt=wt.length;$t<Tt;$t++)this.expandByObject(wt[$t],pt);return this}containsPoint(at){return!(at.x<this.min.x||at.x>this.max.x||at.y<this.min.y||at.y>this.max.y||at.z<this.min.z||at.z>this.max.z)}containsBox(at){return this.min.x<=at.min.x&&at.max.x<=this.max.x&&this.min.y<=at.min.y&&at.max.y<=this.max.y&&this.min.z<=at.min.z&&at.max.z<=this.max.z}getParameter(at,pt){return pt.set((at.x-this.min.x)/(this.max.x-this.min.x),(at.y-this.min.y)/(this.max.y-this.min.y),(at.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(at){return!(at.max.x<this.min.x||at.min.x>this.max.x||at.max.y<this.min.y||at.min.y>this.max.y||at.max.z<this.min.z||at.min.z>this.max.z)}intersectsSphere(at){return this.clampPoint(at.center,_vector$b),_vector$b.distanceToSquared(at.center)<=at.radius*at.radius}intersectsPlane(at){let pt,vt;return at.normal.x>0?(pt=at.normal.x*this.min.x,vt=at.normal.x*this.max.x):(pt=at.normal.x*this.max.x,vt=at.normal.x*this.min.x),at.normal.y>0?(pt+=at.normal.y*this.min.y,vt+=at.normal.y*this.max.y):(pt+=at.normal.y*this.max.y,vt+=at.normal.y*this.min.y),at.normal.z>0?(pt+=at.normal.z*this.min.z,vt+=at.normal.z*this.max.z):(pt+=at.normal.z*this.max.z,vt+=at.normal.z*this.min.z),pt<=-at.constant&&vt>=-at.constant}intersectsTriangle(at){if(this.isEmpty())return!1;this.getCenter(_center),_extents.subVectors(this.max,_center),_v0$2.subVectors(at.a,_center),_v1$7.subVectors(at.b,_center),_v2$4.subVectors(at.c,_center),_f0.subVectors(_v1$7,_v0$2),_f1.subVectors(_v2$4,_v1$7),_f2.subVectors(_v0$2,_v2$4);let pt=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];return!satForAxes(pt,_v0$2,_v1$7,_v2$4,_extents)||(pt=[1,0,0,0,1,0,0,0,1],!satForAxes(pt,_v0$2,_v1$7,_v2$4,_extents))?!1:(_triangleNormal.crossVectors(_f0,_f1),pt=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z],satForAxes(pt,_v0$2,_v1$7,_v2$4,_extents))}clampPoint(at,pt){return pt.copy(at).clamp(this.min,this.max)}distanceToPoint(at){return this.clampPoint(at,_vector$b).distanceTo(at)}getBoundingSphere(at){return this.isEmpty()?at.makeEmpty():(this.getCenter(at.center),at.radius=this.getSize(_vector$b).length()*.5),at}intersect(at){return this.min.max(at.min),this.max.min(at.max),this.isEmpty()&&this.makeEmpty(),this}union(at){return this.min.min(at.min),this.max.max(at.max),this}applyMatrix4(at){return this.isEmpty()?this:(_points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(at),_points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(at),_points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(at),_points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(at),_points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(at),_points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(at),_points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(at),_points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(at),this.setFromPoints(_points),this)}translate(at){return this.min.add(at),this.max.add(at),this}equals(at){return at.min.equals(this.min)&&at.max.equals(this.max)}}const _points=[new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3],_vector$b=new Vector3,_box$4=new Box3,_v0$2=new Vector3,_v1$7=new Vector3,_v2$4=new Vector3,_f0=new Vector3,_f1=new Vector3,_f2=new Vector3,_center=new Vector3,_extents=new Vector3,_triangleNormal=new Vector3,_testAxis=new Vector3;function satForAxes(st,at,pt,vt,wt){for(let $t=0,Tt=st.length-3;$t<=Tt;$t+=3){_testAxis.fromArray(st,$t);const Lt=wt.x*Math.abs(_testAxis.x)+wt.y*Math.abs(_testAxis.y)+wt.z*Math.abs(_testAxis.z),Ft=at.dot(_testAxis),Ct=pt.dot(_testAxis),Ht=vt.dot(_testAxis);if(Math.max(-Math.max(Ft,Ct,Ht),Math.min(Ft,Ct,Ht))>Lt)return!1}return!0}const _box$3=new Box3,_v1$6=new Vector3,_v2$3=new Vector3;class Sphere{constructor(at=new Vector3,pt=-1){this.isSphere=!0,this.center=at,this.radius=pt}set(at,pt){return this.center.copy(at),this.radius=pt,this}setFromPoints(at,pt){const vt=this.center;pt!==void 0?vt.copy(pt):_box$3.setFromPoints(at).getCenter(vt);let wt=0;for(let $t=0,Tt=at.length;$t<Tt;$t++)wt=Math.max(wt,vt.distanceToSquared(at[$t]));return this.radius=Math.sqrt(wt),this}copy(at){return this.center.copy(at.center),this.radius=at.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(at){return at.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(at){return at.distanceTo(this.center)-this.radius}intersectsSphere(at){const pt=this.radius+at.radius;return at.center.distanceToSquared(this.center)<=pt*pt}intersectsBox(at){return at.intersectsSphere(this)}intersectsPlane(at){return Math.abs(at.distanceToPoint(this.center))<=this.radius}clampPoint(at,pt){const vt=this.center.distanceToSquared(at);return pt.copy(at),vt>this.radius*this.radius&&(pt.sub(this.center).normalize(),pt.multiplyScalar(this.radius).add(this.center)),pt}getBoundingBox(at){return this.isEmpty()?(at.makeEmpty(),at):(at.set(this.center,this.center),at.expandByScalar(this.radius),at)}applyMatrix4(at){return this.center.applyMatrix4(at),this.radius=this.radius*at.getMaxScaleOnAxis(),this}translate(at){return this.center.add(at),this}expandByPoint(at){if(this.isEmpty())return this.center.copy(at),this.radius=0,this;_v1$6.subVectors(at,this.center);const pt=_v1$6.lengthSq();if(pt>this.radius*this.radius){const vt=Math.sqrt(pt),wt=(vt-this.radius)*.5;this.center.addScaledVector(_v1$6,wt/vt),this.radius+=wt}return this}union(at){return at.isEmpty()?this:this.isEmpty()?(this.copy(at),this):(this.center.equals(at.center)===!0?this.radius=Math.max(this.radius,at.radius):(_v2$3.subVectors(at.center,this.center).setLength(at.radius),this.expandByPoint(_v1$6.copy(at.center).add(_v2$3)),this.expandByPoint(_v1$6.copy(at.center).sub(_v2$3))),this)}equals(at){return at.center.equals(this.center)&&at.radius===this.radius}clone(){return new this.constructor().copy(this)}}const _vector$a=new Vector3,_segCenter=new Vector3,_segDir=new Vector3,_diff=new Vector3,_edge1=new Vector3,_edge2=new Vector3,_normal$1=new Vector3;class Ray{constructor(at=new Vector3,pt=new Vector3(0,0,-1)){this.origin=at,this.direction=pt}set(at,pt){return this.origin.copy(at),this.direction.copy(pt),this}copy(at){return this.origin.copy(at.origin),this.direction.copy(at.direction),this}at(at,pt){return pt.copy(this.origin).addScaledVector(this.direction,at)}lookAt(at){return this.direction.copy(at).sub(this.origin).normalize(),this}recast(at){return this.origin.copy(this.at(at,_vector$a)),this}closestPointToPoint(at,pt){pt.subVectors(at,this.origin);const vt=pt.dot(this.direction);return vt<0?pt.copy(this.origin):pt.copy(this.origin).addScaledVector(this.direction,vt)}distanceToPoint(at){return Math.sqrt(this.distanceSqToPoint(at))}distanceSqToPoint(at){const pt=_vector$a.subVectors(at,this.origin).dot(this.direction);return pt<0?this.origin.distanceToSquared(at):(_vector$a.copy(this.origin).addScaledVector(this.direction,pt),_vector$a.distanceToSquared(at))}distanceSqToSegment(at,pt,vt,wt){_segCenter.copy(at).add(pt).multiplyScalar(.5),_segDir.copy(pt).sub(at).normalize(),_diff.copy(this.origin).sub(_segCenter);const $t=at.distanceTo(pt)*.5,Tt=-this.direction.dot(_segDir),Lt=_diff.dot(this.direction),Ft=-_diff.dot(_segDir),Ct=_diff.lengthSq(),Ht=Math.abs(1-Tt*Tt);let Gt,jt,qt,Kt;if(Ht>0)if(Gt=Tt*Ft-Lt,jt=Tt*Lt-Ft,Kt=$t*Ht,Gt>=0)if(jt>=-Kt)if(jt<=Kt){const An=1/Ht;Gt*=An,jt*=An,qt=Gt*(Gt+Tt*jt+2*Lt)+jt*(Tt*Gt+jt+2*Ft)+Ct}else jt=$t,Gt=Math.max(0,-(Tt*jt+Lt)),qt=-Gt*Gt+jt*(jt+2*Ft)+Ct;else jt=-$t,Gt=Math.max(0,-(Tt*jt+Lt)),qt=-Gt*Gt+jt*(jt+2*Ft)+Ct;else jt<=-Kt?(Gt=Math.max(0,-(-Tt*$t+Lt)),jt=Gt>0?-$t:Math.min(Math.max(-$t,-Ft),$t),qt=-Gt*Gt+jt*(jt+2*Ft)+Ct):jt<=Kt?(Gt=0,jt=Math.min(Math.max(-$t,-Ft),$t),qt=jt*(jt+2*Ft)+Ct):(Gt=Math.max(0,-(Tt*$t+Lt)),jt=Gt>0?$t:Math.min(Math.max(-$t,-Ft),$t),qt=-Gt*Gt+jt*(jt+2*Ft)+Ct);else jt=Tt>0?-$t:$t,Gt=Math.max(0,-(Tt*jt+Lt)),qt=-Gt*Gt+jt*(jt+2*Ft)+Ct;return vt&&vt.copy(this.origin).addScaledVector(this.direction,Gt),wt&&wt.copy(_segCenter).addScaledVector(_segDir,jt),qt}intersectSphere(at,pt){_vector$a.subVectors(at.center,this.origin);const vt=_vector$a.dot(this.direction),wt=_vector$a.dot(_vector$a)-vt*vt,$t=at.radius*at.radius;if(wt>$t)return null;const Tt=Math.sqrt($t-wt),Lt=vt-Tt,Ft=vt+Tt;return Ft<0?null:Lt<0?this.at(Ft,pt):this.at(Lt,pt)}intersectsSphere(at){return this.distanceSqToPoint(at.center)<=at.radius*at.radius}distanceToPlane(at){const pt=at.normal.dot(this.direction);if(pt===0)return at.distanceToPoint(this.origin)===0?0:null;const vt=-(this.origin.dot(at.normal)+at.constant)/pt;return vt>=0?vt:null}intersectPlane(at,pt){const vt=this.distanceToPlane(at);return vt===null?null:this.at(vt,pt)}intersectsPlane(at){const pt=at.distanceToPoint(this.origin);return pt===0||at.normal.dot(this.direction)*pt<0}intersectBox(at,pt){let vt,wt,$t,Tt,Lt,Ft;const Ct=1/this.direction.x,Ht=1/this.direction.y,Gt=1/this.direction.z,jt=this.origin;return Ct>=0?(vt=(at.min.x-jt.x)*Ct,wt=(at.max.x-jt.x)*Ct):(vt=(at.max.x-jt.x)*Ct,wt=(at.min.x-jt.x)*Ct),Ht>=0?($t=(at.min.y-jt.y)*Ht,Tt=(at.max.y-jt.y)*Ht):($t=(at.max.y-jt.y)*Ht,Tt=(at.min.y-jt.y)*Ht),vt>Tt||$t>wt||(($t>vt||isNaN(vt))&&(vt=$t),(Tt<wt||isNaN(wt))&&(wt=Tt),Gt>=0?(Lt=(at.min.z-jt.z)*Gt,Ft=(at.max.z-jt.z)*Gt):(Lt=(at.max.z-jt.z)*Gt,Ft=(at.min.z-jt.z)*Gt),vt>Ft||Lt>wt)||((Lt>vt||vt!==vt)&&(vt=Lt),(Ft<wt||wt!==wt)&&(wt=Ft),wt<0)?null:this.at(vt>=0?vt:wt,pt)}intersectsBox(at){return this.intersectBox(at,_vector$a)!==null}intersectTriangle(at,pt,vt,wt,$t){_edge1.subVectors(pt,at),_edge2.subVectors(vt,at),_normal$1.crossVectors(_edge1,_edge2);let Tt=this.direction.dot(_normal$1),Lt;if(Tt>0){if(wt)return null;Lt=1}else if(Tt<0)Lt=-1,Tt=-Tt;else return null;_diff.subVectors(this.origin,at);const Ft=Lt*this.direction.dot(_edge2.crossVectors(_diff,_edge2));if(Ft<0)return null;const Ct=Lt*this.direction.dot(_edge1.cross(_diff));if(Ct<0||Ft+Ct>Tt)return null;const Ht=-Lt*_diff.dot(_normal$1);return Ht<0?null:this.at(Ht/Tt,$t)}applyMatrix4(at){return this.origin.applyMatrix4(at),this.direction.transformDirection(at),this}equals(at){return at.origin.equals(this.origin)&&at.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Matrix4{constructor(at,pt,vt,wt,$t,Tt,Lt,Ft,Ct,Ht,Gt,jt,qt,Kt,An,Sn){Matrix4.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],at!==void 0&&this.set(at,pt,vt,wt,$t,Tt,Lt,Ft,Ct,Ht,Gt,jt,qt,Kt,An,Sn)}set(at,pt,vt,wt,$t,Tt,Lt,Ft,Ct,Ht,Gt,jt,qt,Kt,An,Sn){const wn=this.elements;return wn[0]=at,wn[4]=pt,wn[8]=vt,wn[12]=wt,wn[1]=$t,wn[5]=Tt,wn[9]=Lt,wn[13]=Ft,wn[2]=Ct,wn[6]=Ht,wn[10]=Gt,wn[14]=jt,wn[3]=qt,wn[7]=Kt,wn[11]=An,wn[15]=Sn,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Matrix4().fromArray(this.elements)}copy(at){const pt=this.elements,vt=at.elements;return pt[0]=vt[0],pt[1]=vt[1],pt[2]=vt[2],pt[3]=vt[3],pt[4]=vt[4],pt[5]=vt[5],pt[6]=vt[6],pt[7]=vt[7],pt[8]=vt[8],pt[9]=vt[9],pt[10]=vt[10],pt[11]=vt[11],pt[12]=vt[12],pt[13]=vt[13],pt[14]=vt[14],pt[15]=vt[15],this}copyPosition(at){const pt=this.elements,vt=at.elements;return pt[12]=vt[12],pt[13]=vt[13],pt[14]=vt[14],this}setFromMatrix3(at){const pt=at.elements;return this.set(pt[0],pt[3],pt[6],0,pt[1],pt[4],pt[7],0,pt[2],pt[5],pt[8],0,0,0,0,1),this}extractBasis(at,pt,vt){return at.setFromMatrixColumn(this,0),pt.setFromMatrixColumn(this,1),vt.setFromMatrixColumn(this,2),this}makeBasis(at,pt,vt){return this.set(at.x,pt.x,vt.x,0,at.y,pt.y,vt.y,0,at.z,pt.z,vt.z,0,0,0,0,1),this}extractRotation(at){const pt=this.elements,vt=at.elements,wt=1/_v1$5.setFromMatrixColumn(at,0).length(),$t=1/_v1$5.setFromMatrixColumn(at,1).length(),Tt=1/_v1$5.setFromMatrixColumn(at,2).length();return pt[0]=vt[0]*wt,pt[1]=vt[1]*wt,pt[2]=vt[2]*wt,pt[3]=0,pt[4]=vt[4]*$t,pt[5]=vt[5]*$t,pt[6]=vt[6]*$t,pt[7]=0,pt[8]=vt[8]*Tt,pt[9]=vt[9]*Tt,pt[10]=vt[10]*Tt,pt[11]=0,pt[12]=0,pt[13]=0,pt[14]=0,pt[15]=1,this}makeRotationFromEuler(at){const pt=this.elements,vt=at.x,wt=at.y,$t=at.z,Tt=Math.cos(vt),Lt=Math.sin(vt),Ft=Math.cos(wt),Ct=Math.sin(wt),Ht=Math.cos($t),Gt=Math.sin($t);if(at.order==="XYZ"){const jt=Tt*Ht,qt=Tt*Gt,Kt=Lt*Ht,An=Lt*Gt;pt[0]=Ft*Ht,pt[4]=-Ft*Gt,pt[8]=Ct,pt[1]=qt+Kt*Ct,pt[5]=jt-An*Ct,pt[9]=-Lt*Ft,pt[2]=An-jt*Ct,pt[6]=Kt+qt*Ct,pt[10]=Tt*Ft}else if(at.order==="YXZ"){const jt=Ft*Ht,qt=Ft*Gt,Kt=Ct*Ht,An=Ct*Gt;pt[0]=jt+An*Lt,pt[4]=Kt*Lt-qt,pt[8]=Tt*Ct,pt[1]=Tt*Gt,pt[5]=Tt*Ht,pt[9]=-Lt,pt[2]=qt*Lt-Kt,pt[6]=An+jt*Lt,pt[10]=Tt*Ft}else if(at.order==="ZXY"){const jt=Ft*Ht,qt=Ft*Gt,Kt=Ct*Ht,An=Ct*Gt;pt[0]=jt-An*Lt,pt[4]=-Tt*Gt,pt[8]=Kt+qt*Lt,pt[1]=qt+Kt*Lt,pt[5]=Tt*Ht,pt[9]=An-jt*Lt,pt[2]=-Tt*Ct,pt[6]=Lt,pt[10]=Tt*Ft}else if(at.order==="ZYX"){const jt=Tt*Ht,qt=Tt*Gt,Kt=Lt*Ht,An=Lt*Gt;pt[0]=Ft*Ht,pt[4]=Kt*Ct-qt,pt[8]=jt*Ct+An,pt[1]=Ft*Gt,pt[5]=An*Ct+jt,pt[9]=qt*Ct-Kt,pt[2]=-Ct,pt[6]=Lt*Ft,pt[10]=Tt*Ft}else if(at.order==="YZX"){const jt=Tt*Ft,qt=Tt*Ct,Kt=Lt*Ft,An=Lt*Ct;pt[0]=Ft*Ht,pt[4]=An-jt*Gt,pt[8]=Kt*Gt+qt,pt[1]=Gt,pt[5]=Tt*Ht,pt[9]=-Lt*Ht,pt[2]=-Ct*Ht,pt[6]=qt*Gt+Kt,pt[10]=jt-An*Gt}else if(at.order==="XZY"){const jt=Tt*Ft,qt=Tt*Ct,Kt=Lt*Ft,An=Lt*Ct;pt[0]=Ft*Ht,pt[4]=-Gt,pt[8]=Ct*Ht,pt[1]=jt*Gt+An,pt[5]=Tt*Ht,pt[9]=qt*Gt-Kt,pt[2]=Kt*Gt-qt,pt[6]=Lt*Ht,pt[10]=An*Gt+jt}return pt[3]=0,pt[7]=0,pt[11]=0,pt[12]=0,pt[13]=0,pt[14]=0,pt[15]=1,this}makeRotationFromQuaternion(at){return this.compose(_zero,at,_one)}lookAt(at,pt,vt){const wt=this.elements;return _z.subVectors(at,pt),_z.lengthSq()===0&&(_z.z=1),_z.normalize(),_x.crossVectors(vt,_z),_x.lengthSq()===0&&(Math.abs(vt.z)===1?_z.x+=1e-4:_z.z+=1e-4,_z.normalize(),_x.crossVectors(vt,_z)),_x.normalize(),_y.crossVectors(_z,_x),wt[0]=_x.x,wt[4]=_y.x,wt[8]=_z.x,wt[1]=_x.y,wt[5]=_y.y,wt[9]=_z.y,wt[2]=_x.z,wt[6]=_y.z,wt[10]=_z.z,this}multiply(at){return this.multiplyMatrices(this,at)}premultiply(at){return this.multiplyMatrices(at,this)}multiplyMatrices(at,pt){const vt=at.elements,wt=pt.elements,$t=this.elements,Tt=vt[0],Lt=vt[4],Ft=vt[8],Ct=vt[12],Ht=vt[1],Gt=vt[5],jt=vt[9],qt=vt[13],Kt=vt[2],An=vt[6],Sn=vt[10],wn=vt[14],In=vt[3],tr=vt[7],rr=vt[11],Hr=vt[15],qr=wt[0],Zr=wt[4],Bo=wt[8],Xo=wt[12],Kr=wt[1],ko=wt[5],f0=wt[9],x0=wt[13],l0=wt[2],T0=wt[6],t0=wt[10],E0=wt[14],n0=wt[3],m0=wt[7],h0=wt[11],a0=wt[15];return $t[0]=Tt*qr+Lt*Kr+Ft*l0+Ct*n0,$t[4]=Tt*Zr+Lt*ko+Ft*T0+Ct*m0,$t[8]=Tt*Bo+Lt*f0+Ft*t0+Ct*h0,$t[12]=Tt*Xo+Lt*x0+Ft*E0+Ct*a0,$t[1]=Ht*qr+Gt*Kr+jt*l0+qt*n0,$t[5]=Ht*Zr+Gt*ko+jt*T0+qt*m0,$t[9]=Ht*Bo+Gt*f0+jt*t0+qt*h0,$t[13]=Ht*Xo+Gt*x0+jt*E0+qt*a0,$t[2]=Kt*qr+An*Kr+Sn*l0+wn*n0,$t[6]=Kt*Zr+An*ko+Sn*T0+wn*m0,$t[10]=Kt*Bo+An*f0+Sn*t0+wn*h0,$t[14]=Kt*Xo+An*x0+Sn*E0+wn*a0,$t[3]=In*qr+tr*Kr+rr*l0+Hr*n0,$t[7]=In*Zr+tr*ko+rr*T0+Hr*m0,$t[11]=In*Bo+tr*f0+rr*t0+Hr*h0,$t[15]=In*Xo+tr*x0+rr*E0+Hr*a0,this}multiplyScalar(at){const pt=this.elements;return pt[0]*=at,pt[4]*=at,pt[8]*=at,pt[12]*=at,pt[1]*=at,pt[5]*=at,pt[9]*=at,pt[13]*=at,pt[2]*=at,pt[6]*=at,pt[10]*=at,pt[14]*=at,pt[3]*=at,pt[7]*=at,pt[11]*=at,pt[15]*=at,this}determinant(){const at=this.elements,pt=at[0],vt=at[4],wt=at[8],$t=at[12],Tt=at[1],Lt=at[5],Ft=at[9],Ct=at[13],Ht=at[2],Gt=at[6],jt=at[10],qt=at[14],Kt=at[3],An=at[7],Sn=at[11],wn=at[15];return Kt*(+$t*Ft*Gt-wt*Ct*Gt-$t*Lt*jt+vt*Ct*jt+wt*Lt*qt-vt*Ft*qt)+An*(+pt*Ft*qt-pt*Ct*jt+$t*Tt*jt-wt*Tt*qt+wt*Ct*Ht-$t*Ft*Ht)+Sn*(+pt*Ct*Gt-pt*Lt*qt-$t*Tt*Gt+vt*Tt*qt+$t*Lt*Ht-vt*Ct*Ht)+wn*(-wt*Lt*Ht-pt*Ft*Gt+pt*Lt*jt+wt*Tt*Gt-vt*Tt*jt+vt*Ft*Ht)}transpose(){const at=this.elements;let pt;return pt=at[1],at[1]=at[4],at[4]=pt,pt=at[2],at[2]=at[8],at[8]=pt,pt=at[6],at[6]=at[9],at[9]=pt,pt=at[3],at[3]=at[12],at[12]=pt,pt=at[7],at[7]=at[13],at[13]=pt,pt=at[11],at[11]=at[14],at[14]=pt,this}setPosition(at,pt,vt){const wt=this.elements;return at.isVector3?(wt[12]=at.x,wt[13]=at.y,wt[14]=at.z):(wt[12]=at,wt[13]=pt,wt[14]=vt),this}invert(){const at=this.elements,pt=at[0],vt=at[1],wt=at[2],$t=at[3],Tt=at[4],Lt=at[5],Ft=at[6],Ct=at[7],Ht=at[8],Gt=at[9],jt=at[10],qt=at[11],Kt=at[12],An=at[13],Sn=at[14],wn=at[15],In=Gt*Sn*Ct-An*jt*Ct+An*Ft*qt-Lt*Sn*qt-Gt*Ft*wn+Lt*jt*wn,tr=Kt*jt*Ct-Ht*Sn*Ct-Kt*Ft*qt+Tt*Sn*qt+Ht*Ft*wn-Tt*jt*wn,rr=Ht*An*Ct-Kt*Gt*Ct+Kt*Lt*qt-Tt*An*qt-Ht*Lt*wn+Tt*Gt*wn,Hr=Kt*Gt*Ft-Ht*An*Ft-Kt*Lt*jt+Tt*An*jt+Ht*Lt*Sn-Tt*Gt*Sn,qr=pt*In+vt*tr+wt*rr+$t*Hr;if(qr===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const Zr=1/qr;return at[0]=In*Zr,at[1]=(An*jt*$t-Gt*Sn*$t-An*wt*qt+vt*Sn*qt+Gt*wt*wn-vt*jt*wn)*Zr,at[2]=(Lt*Sn*$t-An*Ft*$t+An*wt*Ct-vt*Sn*Ct-Lt*wt*wn+vt*Ft*wn)*Zr,at[3]=(Gt*Ft*$t-Lt*jt*$t-Gt*wt*Ct+vt*jt*Ct+Lt*wt*qt-vt*Ft*qt)*Zr,at[4]=tr*Zr,at[5]=(Ht*Sn*$t-Kt*jt*$t+Kt*wt*qt-pt*Sn*qt-Ht*wt*wn+pt*jt*wn)*Zr,at[6]=(Kt*Ft*$t-Tt*Sn*$t-Kt*wt*Ct+pt*Sn*Ct+Tt*wt*wn-pt*Ft*wn)*Zr,at[7]=(Tt*jt*$t-Ht*Ft*$t+Ht*wt*Ct-pt*jt*Ct-Tt*wt*qt+pt*Ft*qt)*Zr,at[8]=rr*Zr,at[9]=(Kt*Gt*$t-Ht*An*$t-Kt*vt*qt+pt*An*qt+Ht*vt*wn-pt*Gt*wn)*Zr,at[10]=(Tt*An*$t-Kt*Lt*$t+Kt*vt*Ct-pt*An*Ct-Tt*vt*wn+pt*Lt*wn)*Zr,at[11]=(Ht*Lt*$t-Tt*Gt*$t-Ht*vt*Ct+pt*Gt*Ct+Tt*vt*qt-pt*Lt*qt)*Zr,at[12]=Hr*Zr,at[13]=(Ht*An*wt-Kt*Gt*wt+Kt*vt*jt-pt*An*jt-Ht*vt*Sn+pt*Gt*Sn)*Zr,at[14]=(Kt*Lt*wt-Tt*An*wt-Kt*vt*Ft+pt*An*Ft+Tt*vt*Sn-pt*Lt*Sn)*Zr,at[15]=(Tt*Gt*wt-Ht*Lt*wt+Ht*vt*Ft-pt*Gt*Ft-Tt*vt*jt+pt*Lt*jt)*Zr,this}scale(at){const pt=this.elements,vt=at.x,wt=at.y,$t=at.z;return pt[0]*=vt,pt[4]*=wt,pt[8]*=$t,pt[1]*=vt,pt[5]*=wt,pt[9]*=$t,pt[2]*=vt,pt[6]*=wt,pt[10]*=$t,pt[3]*=vt,pt[7]*=wt,pt[11]*=$t,this}getMaxScaleOnAxis(){const at=this.elements,pt=at[0]*at[0]+at[1]*at[1]+at[2]*at[2],vt=at[4]*at[4]+at[5]*at[5]+at[6]*at[6],wt=at[8]*at[8]+at[9]*at[9]+at[10]*at[10];return Math.sqrt(Math.max(pt,vt,wt))}makeTranslation(at,pt,vt){return at.isVector3?this.set(1,0,0,at.x,0,1,0,at.y,0,0,1,at.z,0,0,0,1):this.set(1,0,0,at,0,1,0,pt,0,0,1,vt,0,0,0,1),this}makeRotationX(at){const pt=Math.cos(at),vt=Math.sin(at);return this.set(1,0,0,0,0,pt,-vt,0,0,vt,pt,0,0,0,0,1),this}makeRotationY(at){const pt=Math.cos(at),vt=Math.sin(at);return this.set(pt,0,vt,0,0,1,0,0,-vt,0,pt,0,0,0,0,1),this}makeRotationZ(at){const pt=Math.cos(at),vt=Math.sin(at);return this.set(pt,-vt,0,0,vt,pt,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(at,pt){const vt=Math.cos(pt),wt=Math.sin(pt),$t=1-vt,Tt=at.x,Lt=at.y,Ft=at.z,Ct=$t*Tt,Ht=$t*Lt;return this.set(Ct*Tt+vt,Ct*Lt-wt*Ft,Ct*Ft+wt*Lt,0,Ct*Lt+wt*Ft,Ht*Lt+vt,Ht*Ft-wt*Tt,0,Ct*Ft-wt*Lt,Ht*Ft+wt*Tt,$t*Ft*Ft+vt,0,0,0,0,1),this}makeScale(at,pt,vt){return this.set(at,0,0,0,0,pt,0,0,0,0,vt,0,0,0,0,1),this}makeShear(at,pt,vt,wt,$t,Tt){return this.set(1,vt,$t,0,at,1,Tt,0,pt,wt,1,0,0,0,0,1),this}compose(at,pt,vt){const wt=this.elements,$t=pt._x,Tt=pt._y,Lt=pt._z,Ft=pt._w,Ct=$t+$t,Ht=Tt+Tt,Gt=Lt+Lt,jt=$t*Ct,qt=$t*Ht,Kt=$t*Gt,An=Tt*Ht,Sn=Tt*Gt,wn=Lt*Gt,In=Ft*Ct,tr=Ft*Ht,rr=Ft*Gt,Hr=vt.x,qr=vt.y,Zr=vt.z;return wt[0]=(1-(An+wn))*Hr,wt[1]=(qt+rr)*Hr,wt[2]=(Kt-tr)*Hr,wt[3]=0,wt[4]=(qt-rr)*qr,wt[5]=(1-(jt+wn))*qr,wt[6]=(Sn+In)*qr,wt[7]=0,wt[8]=(Kt+tr)*Zr,wt[9]=(Sn-In)*Zr,wt[10]=(1-(jt+An))*Zr,wt[11]=0,wt[12]=at.x,wt[13]=at.y,wt[14]=at.z,wt[15]=1,this}decompose(at,pt,vt){const wt=this.elements;let $t=_v1$5.set(wt[0],wt[1],wt[2]).length();const Tt=_v1$5.set(wt[4],wt[5],wt[6]).length(),Lt=_v1$5.set(wt[8],wt[9],wt[10]).length();this.determinant()<0&&($t=-$t),at.x=wt[12],at.y=wt[13],at.z=wt[14],_m1$4.copy(this);const Ct=1/$t,Ht=1/Tt,Gt=1/Lt;return _m1$4.elements[0]*=Ct,_m1$4.elements[1]*=Ct,_m1$4.elements[2]*=Ct,_m1$4.elements[4]*=Ht,_m1$4.elements[5]*=Ht,_m1$4.elements[6]*=Ht,_m1$4.elements[8]*=Gt,_m1$4.elements[9]*=Gt,_m1$4.elements[10]*=Gt,pt.setFromRotationMatrix(_m1$4),vt.x=$t,vt.y=Tt,vt.z=Lt,this}makePerspective(at,pt,vt,wt,$t,Tt,Lt=WebGLCoordinateSystem){const Ft=this.elements,Ct=2*$t/(pt-at),Ht=2*$t/(vt-wt),Gt=(pt+at)/(pt-at),jt=(vt+wt)/(vt-wt);let qt,Kt;if(Lt===WebGLCoordinateSystem)qt=-(Tt+$t)/(Tt-$t),Kt=-2*Tt*$t/(Tt-$t);else if(Lt===WebGPUCoordinateSystem)qt=-Tt/(Tt-$t),Kt=-Tt*$t/(Tt-$t);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+Lt);return Ft[0]=Ct,Ft[4]=0,Ft[8]=Gt,Ft[12]=0,Ft[1]=0,Ft[5]=Ht,Ft[9]=jt,Ft[13]=0,Ft[2]=0,Ft[6]=0,Ft[10]=qt,Ft[14]=Kt,Ft[3]=0,Ft[7]=0,Ft[11]=-1,Ft[15]=0,this}makeOrthographic(at,pt,vt,wt,$t,Tt,Lt=WebGLCoordinateSystem){const Ft=this.elements,Ct=1/(pt-at),Ht=1/(vt-wt),Gt=1/(Tt-$t),jt=(pt+at)*Ct,qt=(vt+wt)*Ht;let Kt,An;if(Lt===WebGLCoordinateSystem)Kt=(Tt+$t)*Gt,An=-2*Gt;else if(Lt===WebGPUCoordinateSystem)Kt=$t*Gt,An=-1*Gt;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+Lt);return Ft[0]=2*Ct,Ft[4]=0,Ft[8]=0,Ft[12]=-jt,Ft[1]=0,Ft[5]=2*Ht,Ft[9]=0,Ft[13]=-qt,Ft[2]=0,Ft[6]=0,Ft[10]=An,Ft[14]=-Kt,Ft[3]=0,Ft[7]=0,Ft[11]=0,Ft[15]=1,this}equals(at){const pt=this.elements,vt=at.elements;for(let wt=0;wt<16;wt++)if(pt[wt]!==vt[wt])return!1;return!0}fromArray(at,pt=0){for(let vt=0;vt<16;vt++)this.elements[vt]=at[vt+pt];return this}toArray(at=[],pt=0){const vt=this.elements;return at[pt]=vt[0],at[pt+1]=vt[1],at[pt+2]=vt[2],at[pt+3]=vt[3],at[pt+4]=vt[4],at[pt+5]=vt[5],at[pt+6]=vt[6],at[pt+7]=vt[7],at[pt+8]=vt[8],at[pt+9]=vt[9],at[pt+10]=vt[10],at[pt+11]=vt[11],at[pt+12]=vt[12],at[pt+13]=vt[13],at[pt+14]=vt[14],at[pt+15]=vt[15],at}}const _v1$5=new Vector3,_m1$4=new Matrix4,_zero=new Vector3(0,0,0),_one=new Vector3(1,1,1),_x=new Vector3,_y=new Vector3,_z=new Vector3,_matrix$2=new Matrix4,_quaternion$3=new Quaternion;class Euler{constructor(at=0,pt=0,vt=0,wt=Euler.DEFAULT_ORDER){this.isEuler=!0,this._x=at,this._y=pt,this._z=vt,this._order=wt}get x(){return this._x}set x(at){this._x=at,this._onChangeCallback()}get y(){return this._y}set y(at){this._y=at,this._onChangeCallback()}get z(){return this._z}set z(at){this._z=at,this._onChangeCallback()}get order(){return this._order}set order(at){this._order=at,this._onChangeCallback()}set(at,pt,vt,wt=this._order){return this._x=at,this._y=pt,this._z=vt,this._order=wt,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(at){return this._x=at._x,this._y=at._y,this._z=at._z,this._order=at._order,this._onChangeCallback(),this}setFromRotationMatrix(at,pt=this._order,vt=!0){const wt=at.elements,$t=wt[0],Tt=wt[4],Lt=wt[8],Ft=wt[1],Ct=wt[5],Ht=wt[9],Gt=wt[2],jt=wt[6],qt=wt[10];switch(pt){case"XYZ":this._y=Math.asin(clamp$3(Lt,-1,1)),Math.abs(Lt)<.9999999?(this._x=Math.atan2(-Ht,qt),this._z=Math.atan2(-Tt,$t)):(this._x=Math.atan2(jt,Ct),this._z=0);break;case"YXZ":this._x=Math.asin(-clamp$3(Ht,-1,1)),Math.abs(Ht)<.9999999?(this._y=Math.atan2(Lt,qt),this._z=Math.atan2(Ft,Ct)):(this._y=Math.atan2(-Gt,$t),this._z=0);break;case"ZXY":this._x=Math.asin(clamp$3(jt,-1,1)),Math.abs(jt)<.9999999?(this._y=Math.atan2(-Gt,qt),this._z=Math.atan2(-Tt,Ct)):(this._y=0,this._z=Math.atan2(Ft,$t));break;case"ZYX":this._y=Math.asin(-clamp$3(Gt,-1,1)),Math.abs(Gt)<.9999999?(this._x=Math.atan2(jt,qt),this._z=Math.atan2(Ft,$t)):(this._x=0,this._z=Math.atan2(-Tt,Ct));break;case"YZX":this._z=Math.asin(clamp$3(Ft,-1,1)),Math.abs(Ft)<.9999999?(this._x=Math.atan2(-Ht,Ct),this._y=Math.atan2(-Gt,$t)):(this._x=0,this._y=Math.atan2(Lt,qt));break;case"XZY":this._z=Math.asin(-clamp$3(Tt,-1,1)),Math.abs(Tt)<.9999999?(this._x=Math.atan2(jt,Ct),this._y=Math.atan2(Lt,$t)):(this._x=Math.atan2(-Ht,qt),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+pt)}return this._order=pt,vt===!0&&this._onChangeCallback(),this}setFromQuaternion(at,pt,vt){return _matrix$2.makeRotationFromQuaternion(at),this.setFromRotationMatrix(_matrix$2,pt,vt)}setFromVector3(at,pt=this._order){return this.set(at.x,at.y,at.z,pt)}reorder(at){return _quaternion$3.setFromEuler(this),this.setFromQuaternion(_quaternion$3,at)}equals(at){return at._x===this._x&&at._y===this._y&&at._z===this._z&&at._order===this._order}fromArray(at){return this._x=at[0],this._y=at[1],this._z=at[2],at[3]!==void 0&&(this._order=at[3]),this._onChangeCallback(),this}toArray(at=[],pt=0){return at[pt]=this._x,at[pt+1]=this._y,at[pt+2]=this._z,at[pt+3]=this._order,at}_onChange(at){return this._onChangeCallback=at,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Euler.DEFAULT_ORDER="XYZ";class Layers{constructor(){this.mask=1}set(at){this.mask=(1<<at|0)>>>0}enable(at){this.mask|=1<<at|0}enableAll(){this.mask=-1}toggle(at){this.mask^=1<<at|0}disable(at){this.mask&=~(1<<at|0)}disableAll(){this.mask=0}test(at){return(this.mask&at.mask)!==0}isEnabled(at){return(this.mask&(1<<at|0))!==0}}let _object3DId=0;const _v1$4=new Vector3,_q1=new Quaternion,_m1$3=new Matrix4,_target=new Vector3,_position$3=new Vector3,_scale$2=new Vector3,_quaternion$2=new Quaternion,_xAxis=new Vector3(1,0,0),_yAxis=new Vector3(0,1,0),_zAxis=new Vector3(0,0,1),_addedEvent={type:"added"},_removedEvent={type:"removed"},_childaddedEvent={type:"childadded",child:null},_childremovedEvent={type:"childremoved",child:null};class Object3D extends EventDispatcher{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:_object3DId++}),this.uuid=generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Object3D.DEFAULT_UP.clone();const at=new Vector3,pt=new Euler,vt=new Quaternion,wt=new Vector3(1,1,1);function $t(){vt.setFromEuler(pt,!1)}function Tt(){pt.setFromQuaternion(vt,void 0,!1)}pt._onChange($t),vt._onChange(Tt),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:at},rotation:{configurable:!0,enumerable:!0,value:pt},quaternion:{configurable:!0,enumerable:!0,value:vt},scale:{configurable:!0,enumerable:!0,value:wt},modelViewMatrix:{value:new Matrix4},normalMatrix:{value:new Matrix3}}),this.matrix=new Matrix4,this.matrixWorld=new Matrix4,this.matrixAutoUpdate=Object3D.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Layers,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(at){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(at),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(at){return this.quaternion.premultiply(at),this}setRotationFromAxisAngle(at,pt){this.quaternion.setFromAxisAngle(at,pt)}setRotationFromEuler(at){this.quaternion.setFromEuler(at,!0)}setRotationFromMatrix(at){this.quaternion.setFromRotationMatrix(at)}setRotationFromQuaternion(at){this.quaternion.copy(at)}rotateOnAxis(at,pt){return _q1.setFromAxisAngle(at,pt),this.quaternion.multiply(_q1),this}rotateOnWorldAxis(at,pt){return _q1.setFromAxisAngle(at,pt),this.quaternion.premultiply(_q1),this}rotateX(at){return this.rotateOnAxis(_xAxis,at)}rotateY(at){return this.rotateOnAxis(_yAxis,at)}rotateZ(at){return this.rotateOnAxis(_zAxis,at)}translateOnAxis(at,pt){return _v1$4.copy(at).applyQuaternion(this.quaternion),this.position.add(_v1$4.multiplyScalar(pt)),this}translateX(at){return this.translateOnAxis(_xAxis,at)}translateY(at){return this.translateOnAxis(_yAxis,at)}translateZ(at){return this.translateOnAxis(_zAxis,at)}localToWorld(at){return this.updateWorldMatrix(!0,!1),at.applyMatrix4(this.matrixWorld)}worldToLocal(at){return this.updateWorldMatrix(!0,!1),at.applyMatrix4(_m1$3.copy(this.matrixWorld).invert())}lookAt(at,pt,vt){at.isVector3?_target.copy(at):_target.set(at,pt,vt);const wt=this.parent;this.updateWorldMatrix(!0,!1),_position$3.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?_m1$3.lookAt(_position$3,_target,this.up):_m1$3.lookAt(_target,_position$3,this.up),this.quaternion.setFromRotationMatrix(_m1$3),wt&&(_m1$3.extractRotation(wt.matrixWorld),_q1.setFromRotationMatrix(_m1$3),this.quaternion.premultiply(_q1.invert()))}add(at){if(arguments.length>1){for(let pt=0;pt<arguments.length;pt++)this.add(arguments[pt]);return this}return at===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",at),this):(at&&at.isObject3D?(at.parent!==null&&at.parent.remove(at),at.parent=this,this.children.push(at),at.dispatchEvent(_addedEvent),_childaddedEvent.child=at,this.dispatchEvent(_childaddedEvent),_childaddedEvent.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",at),this)}remove(at){if(arguments.length>1){for(let vt=0;vt<arguments.length;vt++)this.remove(arguments[vt]);return this}const pt=this.children.indexOf(at);return pt!==-1&&(at.parent=null,this.children.splice(pt,1),at.dispatchEvent(_removedEvent),_childremovedEvent.child=at,this.dispatchEvent(_childremovedEvent),_childremovedEvent.child=null),this}removeFromParent(){const at=this.parent;return at!==null&&at.remove(this),this}clear(){return this.remove(...this.children)}attach(at){return this.updateWorldMatrix(!0,!1),_m1$3.copy(this.matrixWorld).invert(),at.parent!==null&&(at.parent.updateWorldMatrix(!0,!1),_m1$3.multiply(at.parent.matrixWorld)),at.applyMatrix4(_m1$3),this.add(at),at.updateWorldMatrix(!1,!0),this}getObjectById(at){return this.getObjectByProperty("id",at)}getObjectByName(at){return this.getObjectByProperty("name",at)}getObjectByProperty(at,pt){if(this[at]===pt)return this;for(let vt=0,wt=this.children.length;vt<wt;vt++){const Tt=this.children[vt].getObjectByProperty(at,pt);if(Tt!==void 0)return Tt}}getObjectsByProperty(at,pt,vt=[]){this[at]===pt&&vt.push(this);const wt=this.children;for(let $t=0,Tt=wt.length;$t<Tt;$t++)wt[$t].getObjectsByProperty(at,pt,vt);return vt}getWorldPosition(at){return this.updateWorldMatrix(!0,!1),at.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(at){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$3,at,_scale$2),at}getWorldScale(at){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$3,_quaternion$2,at),at}getWorldDirection(at){this.updateWorldMatrix(!0,!1);const pt=this.matrixWorld.elements;return at.set(pt[8],pt[9],pt[10]).normalize()}raycast(){}traverse(at){at(this);const pt=this.children;for(let vt=0,wt=pt.length;vt<wt;vt++)pt[vt].traverse(at)}traverseVisible(at){if(this.visible===!1)return;at(this);const pt=this.children;for(let vt=0,wt=pt.length;vt<wt;vt++)pt[vt].traverseVisible(at)}traverseAncestors(at){const pt=this.parent;pt!==null&&(at(pt),pt.traverseAncestors(at))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(at){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||at)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,at=!0);const pt=this.children;for(let vt=0,wt=pt.length;vt<wt;vt++){const $t=pt[vt];($t.matrixWorldAutoUpdate===!0||at===!0)&&$t.updateMatrixWorld(at)}}updateWorldMatrix(at,pt){const vt=this.parent;if(at===!0&&vt!==null&&vt.matrixWorldAutoUpdate===!0&&vt.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),pt===!0){const wt=this.children;for(let $t=0,Tt=wt.length;$t<Tt;$t++){const Lt=wt[$t];Lt.matrixWorldAutoUpdate===!0&&Lt.updateWorldMatrix(!1,!0)}}}toJSON(at){const pt=at===void 0||typeof at=="string",vt={};pt&&(at={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},vt.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const wt={};wt.uuid=this.uuid,wt.type=this.type,this.name!==""&&(wt.name=this.name),this.castShadow===!0&&(wt.castShadow=!0),this.receiveShadow===!0&&(wt.receiveShadow=!0),this.visible===!1&&(wt.visible=!1),this.frustumCulled===!1&&(wt.frustumCulled=!1),this.renderOrder!==0&&(wt.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(wt.userData=this.userData),wt.layers=this.layers.mask,wt.matrix=this.matrix.toArray(),wt.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(wt.matrixAutoUpdate=!1),this.isInstancedMesh&&(wt.type="InstancedMesh",wt.count=this.count,wt.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(wt.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(wt.type="BatchedMesh",wt.perObjectFrustumCulled=this.perObjectFrustumCulled,wt.sortObjects=this.sortObjects,wt.drawRanges=this._drawRanges,wt.reservedRanges=this._reservedRanges,wt.visibility=this._visibility,wt.active=this._active,wt.bounds=this._bounds.map(Lt=>({boxInitialized:Lt.boxInitialized,boxMin:Lt.box.min.toArray(),boxMax:Lt.box.max.toArray(),sphereInitialized:Lt.sphereInitialized,sphereRadius:Lt.sphere.radius,sphereCenter:Lt.sphere.center.toArray()})),wt.maxGeometryCount=this._maxGeometryCount,wt.maxVertexCount=this._maxVertexCount,wt.maxIndexCount=this._maxIndexCount,wt.geometryInitialized=this._geometryInitialized,wt.geometryCount=this._geometryCount,wt.matricesTexture=this._matricesTexture.toJSON(at),this.boundingSphere!==null&&(wt.boundingSphere={center:wt.boundingSphere.center.toArray(),radius:wt.boundingSphere.radius}),this.boundingBox!==null&&(wt.boundingBox={min:wt.boundingBox.min.toArray(),max:wt.boundingBox.max.toArray()}));function $t(Lt,Ft){return Lt[Ft.uuid]===void 0&&(Lt[Ft.uuid]=Ft.toJSON(at)),Ft.uuid}if(this.isScene)this.background&&(this.background.isColor?wt.background=this.background.toJSON():this.background.isTexture&&(wt.background=this.background.toJSON(at).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(wt.environment=this.environment.toJSON(at).uuid);else if(this.isMesh||this.isLine||this.isPoints){wt.geometry=$t(at.geometries,this.geometry);const Lt=this.geometry.parameters;if(Lt!==void 0&&Lt.shapes!==void 0){const Ft=Lt.shapes;if(Array.isArray(Ft))for(let Ct=0,Ht=Ft.length;Ct<Ht;Ct++){const Gt=Ft[Ct];$t(at.shapes,Gt)}else $t(at.shapes,Ft)}}if(this.isSkinnedMesh&&(wt.bindMode=this.bindMode,wt.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&($t(at.skeletons,this.skeleton),wt.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const Lt=[];for(let Ft=0,Ct=this.material.length;Ft<Ct;Ft++)Lt.push($t(at.materials,this.material[Ft]));wt.material=Lt}else wt.material=$t(at.materials,this.material);if(this.children.length>0){wt.children=[];for(let Lt=0;Lt<this.children.length;Lt++)wt.children.push(this.children[Lt].toJSON(at).object)}if(this.animations.length>0){wt.animations=[];for(let Lt=0;Lt<this.animations.length;Lt++){const Ft=this.animations[Lt];wt.animations.push($t(at.animations,Ft))}}if(pt){const Lt=Tt(at.geometries),Ft=Tt(at.materials),Ct=Tt(at.textures),Ht=Tt(at.images),Gt=Tt(at.shapes),jt=Tt(at.skeletons),qt=Tt(at.animations),Kt=Tt(at.nodes);Lt.length>0&&(vt.geometries=Lt),Ft.length>0&&(vt.materials=Ft),Ct.length>0&&(vt.textures=Ct),Ht.length>0&&(vt.images=Ht),Gt.length>0&&(vt.shapes=Gt),jt.length>0&&(vt.skeletons=jt),qt.length>0&&(vt.animations=qt),Kt.length>0&&(vt.nodes=Kt)}return vt.object=wt,vt;function Tt(Lt){const Ft=[];for(const Ct in Lt){const Ht=Lt[Ct];delete Ht.metadata,Ft.push(Ht)}return Ft}}clone(at){return new this.constructor().copy(this,at)}copy(at,pt=!0){if(this.name=at.name,this.up.copy(at.up),this.position.copy(at.position),this.rotation.order=at.rotation.order,this.quaternion.copy(at.quaternion),this.scale.copy(at.scale),this.matrix.copy(at.matrix),this.matrixWorld.copy(at.matrixWorld),this.matrixAutoUpdate=at.matrixAutoUpdate,this.matrixWorldAutoUpdate=at.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=at.matrixWorldNeedsUpdate,this.layers.mask=at.layers.mask,this.visible=at.visible,this.castShadow=at.castShadow,this.receiveShadow=at.receiveShadow,this.frustumCulled=at.frustumCulled,this.renderOrder=at.renderOrder,this.animations=at.animations.slice(),this.userData=JSON.parse(JSON.stringify(at.userData)),pt===!0)for(let vt=0;vt<at.children.length;vt++){const wt=at.children[vt];this.add(wt.clone())}return this}}Object3D.DEFAULT_UP=new Vector3(0,1,0);Object3D.DEFAULT_MATRIX_AUTO_UPDATE=!0;Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const _v0$1=new Vector3,_v1$3=new Vector3,_v2$2=new Vector3,_v3$2=new Vector3,_vab=new Vector3,_vac=new Vector3,_vbc=new Vector3,_vap=new Vector3,_vbp=new Vector3,_vcp=new Vector3;class Triangle{constructor(at=new Vector3,pt=new Vector3,vt=new Vector3){this.a=at,this.b=pt,this.c=vt}static getNormal(at,pt,vt,wt){wt.subVectors(vt,pt),_v0$1.subVectors(at,pt),wt.cross(_v0$1);const $t=wt.lengthSq();return $t>0?wt.multiplyScalar(1/Math.sqrt($t)):wt.set(0,0,0)}static getBarycoord(at,pt,vt,wt,$t){_v0$1.subVectors(wt,pt),_v1$3.subVectors(vt,pt),_v2$2.subVectors(at,pt);const Tt=_v0$1.dot(_v0$1),Lt=_v0$1.dot(_v1$3),Ft=_v0$1.dot(_v2$2),Ct=_v1$3.dot(_v1$3),Ht=_v1$3.dot(_v2$2),Gt=Tt*Ct-Lt*Lt;if(Gt===0)return $t.set(0,0,0),null;const jt=1/Gt,qt=(Ct*Ft-Lt*Ht)*jt,Kt=(Tt*Ht-Lt*Ft)*jt;return $t.set(1-qt-Kt,Kt,qt)}static containsPoint(at,pt,vt,wt){return this.getBarycoord(at,pt,vt,wt,_v3$2)===null?!1:_v3$2.x>=0&&_v3$2.y>=0&&_v3$2.x+_v3$2.y<=1}static getInterpolation(at,pt,vt,wt,$t,Tt,Lt,Ft){return this.getBarycoord(at,pt,vt,wt,_v3$2)===null?(Ft.x=0,Ft.y=0,"z"in Ft&&(Ft.z=0),"w"in Ft&&(Ft.w=0),null):(Ft.setScalar(0),Ft.addScaledVector($t,_v3$2.x),Ft.addScaledVector(Tt,_v3$2.y),Ft.addScaledVector(Lt,_v3$2.z),Ft)}static isFrontFacing(at,pt,vt,wt){return _v0$1.subVectors(vt,pt),_v1$3.subVectors(at,pt),_v0$1.cross(_v1$3).dot(wt)<0}set(at,pt,vt){return this.a.copy(at),this.b.copy(pt),this.c.copy(vt),this}setFromPointsAndIndices(at,pt,vt,wt){return this.a.copy(at[pt]),this.b.copy(at[vt]),this.c.copy(at[wt]),this}setFromAttributeAndIndices(at,pt,vt,wt){return this.a.fromBufferAttribute(at,pt),this.b.fromBufferAttribute(at,vt),this.c.fromBufferAttribute(at,wt),this}clone(){return new this.constructor().copy(this)}copy(at){return this.a.copy(at.a),this.b.copy(at.b),this.c.copy(at.c),this}getArea(){return _v0$1.subVectors(this.c,this.b),_v1$3.subVectors(this.a,this.b),_v0$1.cross(_v1$3).length()*.5}getMidpoint(at){return at.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(at){return Triangle.getNormal(this.a,this.b,this.c,at)}getPlane(at){return at.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(at,pt){return Triangle.getBarycoord(at,this.a,this.b,this.c,pt)}getInterpolation(at,pt,vt,wt,$t){return Triangle.getInterpolation(at,this.a,this.b,this.c,pt,vt,wt,$t)}containsPoint(at){return Triangle.containsPoint(at,this.a,this.b,this.c)}isFrontFacing(at){return Triangle.isFrontFacing(this.a,this.b,this.c,at)}intersectsBox(at){return at.intersectsTriangle(this)}closestPointToPoint(at,pt){const vt=this.a,wt=this.b,$t=this.c;let Tt,Lt;_vab.subVectors(wt,vt),_vac.subVectors($t,vt),_vap.subVectors(at,vt);const Ft=_vab.dot(_vap),Ct=_vac.dot(_vap);if(Ft<=0&&Ct<=0)return pt.copy(vt);_vbp.subVectors(at,wt);const Ht=_vab.dot(_vbp),Gt=_vac.dot(_vbp);if(Ht>=0&&Gt<=Ht)return pt.copy(wt);const jt=Ft*Gt-Ht*Ct;if(jt<=0&&Ft>=0&&Ht<=0)return Tt=Ft/(Ft-Ht),pt.copy(vt).addScaledVector(_vab,Tt);_vcp.subVectors(at,$t);const qt=_vab.dot(_vcp),Kt=_vac.dot(_vcp);if(Kt>=0&&qt<=Kt)return pt.copy($t);const An=qt*Ct-Ft*Kt;if(An<=0&&Ct>=0&&Kt<=0)return Lt=Ct/(Ct-Kt),pt.copy(vt).addScaledVector(_vac,Lt);const Sn=Ht*Kt-qt*Gt;if(Sn<=0&&Gt-Ht>=0&&qt-Kt>=0)return _vbc.subVectors($t,wt),Lt=(Gt-Ht)/(Gt-Ht+(qt-Kt)),pt.copy(wt).addScaledVector(_vbc,Lt);const wn=1/(Sn+An+jt);return Tt=An*wn,Lt=jt*wn,pt.copy(vt).addScaledVector(_vab,Tt).addScaledVector(_vac,Lt)}equals(at){return at.a.equals(this.a)&&at.b.equals(this.b)&&at.c.equals(this.c)}}const _colorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},_hslA={h:0,s:0,l:0},_hslB={h:0,s:0,l:0};function hue2rgb(st,at,pt){return pt<0&&(pt+=1),pt>1&&(pt-=1),pt<1/6?st+(at-st)*6*pt:pt<1/2?at:pt<2/3?st+(at-st)*6*(2/3-pt):st}let Color$1=class{constructor(at,pt,vt){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(at,pt,vt)}set(at,pt,vt){if(pt===void 0&&vt===void 0){const wt=at;wt&&wt.isColor?this.copy(wt):typeof wt=="number"?this.setHex(wt):typeof wt=="string"&&this.setStyle(wt)}else this.setRGB(at,pt,vt);return this}setScalar(at){return this.r=at,this.g=at,this.b=at,this}setHex(at,pt=SRGBColorSpace$1){return at=Math.floor(at),this.r=(at>>16&255)/255,this.g=(at>>8&255)/255,this.b=(at&255)/255,ColorManagement.toWorkingColorSpace(this,pt),this}setRGB(at,pt,vt,wt=ColorManagement.workingColorSpace){return this.r=at,this.g=pt,this.b=vt,ColorManagement.toWorkingColorSpace(this,wt),this}setHSL(at,pt,vt,wt=ColorManagement.workingColorSpace){if(at=euclideanModulo(at,1),pt=clamp$3(pt,0,1),vt=clamp$3(vt,0,1),pt===0)this.r=this.g=this.b=vt;else{const $t=vt<=.5?vt*(1+pt):vt+pt-vt*pt,Tt=2*vt-$t;this.r=hue2rgb(Tt,$t,at+1/3),this.g=hue2rgb(Tt,$t,at),this.b=hue2rgb(Tt,$t,at-1/3)}return ColorManagement.toWorkingColorSpace(this,wt),this}setStyle(at,pt=SRGBColorSpace$1){function vt($t){$t!==void 0&&parseFloat($t)<1&&console.warn("THREE.Color: Alpha component of "+at+" will be ignored.")}let wt;if(wt=/^(\w+)\(([^\)]*)\)/.exec(at)){let $t;const Tt=wt[1],Lt=wt[2];switch(Tt){case"rgb":case"rgba":if($t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Lt))return vt($t[4]),this.setRGB(Math.min(255,parseInt($t[1],10))/255,Math.min(255,parseInt($t[2],10))/255,Math.min(255,parseInt($t[3],10))/255,pt);if($t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Lt))return vt($t[4]),this.setRGB(Math.min(100,parseInt($t[1],10))/100,Math.min(100,parseInt($t[2],10))/100,Math.min(100,parseInt($t[3],10))/100,pt);break;case"hsl":case"hsla":if($t=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Lt))return vt($t[4]),this.setHSL(parseFloat($t[1])/360,parseFloat($t[2])/100,parseFloat($t[3])/100,pt);break;default:console.warn("THREE.Color: Unknown color model "+at)}}else if(wt=/^\#([A-Fa-f\d]+)$/.exec(at)){const $t=wt[1],Tt=$t.length;if(Tt===3)return this.setRGB(parseInt($t.charAt(0),16)/15,parseInt($t.charAt(1),16)/15,parseInt($t.charAt(2),16)/15,pt);if(Tt===6)return this.setHex(parseInt($t,16),pt);console.warn("THREE.Color: Invalid hex color "+at)}else if(at&&at.length>0)return this.setColorName(at,pt);return this}setColorName(at,pt=SRGBColorSpace$1){const vt=_colorKeywords[at.toLowerCase()];return vt!==void 0?this.setHex(vt,pt):console.warn("THREE.Color: Unknown color "+at),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(at){return this.r=at.r,this.g=at.g,this.b=at.b,this}copySRGBToLinear(at){return this.r=SRGBToLinear(at.r),this.g=SRGBToLinear(at.g),this.b=SRGBToLinear(at.b),this}copyLinearToSRGB(at){return this.r=LinearToSRGB(at.r),this.g=LinearToSRGB(at.g),this.b=LinearToSRGB(at.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(at=SRGBColorSpace$1){return ColorManagement.fromWorkingColorSpace(_color.copy(this),at),Math.round(clamp$3(_color.r*255,0,255))*65536+Math.round(clamp$3(_color.g*255,0,255))*256+Math.round(clamp$3(_color.b*255,0,255))}getHexString(at=SRGBColorSpace$1){return("000000"+this.getHex(at).toString(16)).slice(-6)}getHSL(at,pt=ColorManagement.workingColorSpace){ColorManagement.fromWorkingColorSpace(_color.copy(this),pt);const vt=_color.r,wt=_color.g,$t=_color.b,Tt=Math.max(vt,wt,$t),Lt=Math.min(vt,wt,$t);let Ft,Ct;const Ht=(Lt+Tt)/2;if(Lt===Tt)Ft=0,Ct=0;else{const Gt=Tt-Lt;switch(Ct=Ht<=.5?Gt/(Tt+Lt):Gt/(2-Tt-Lt),Tt){case vt:Ft=(wt-$t)/Gt+(wt<$t?6:0);break;case wt:Ft=($t-vt)/Gt+2;break;case $t:Ft=(vt-wt)/Gt+4;break}Ft/=6}return at.h=Ft,at.s=Ct,at.l=Ht,at}getRGB(at,pt=ColorManagement.workingColorSpace){return ColorManagement.fromWorkingColorSpace(_color.copy(this),pt),at.r=_color.r,at.g=_color.g,at.b=_color.b,at}getStyle(at=SRGBColorSpace$1){ColorManagement.fromWorkingColorSpace(_color.copy(this),at);const pt=_color.r,vt=_color.g,wt=_color.b;return at!==SRGBColorSpace$1?`color(${at} ${pt.toFixed(3)} ${vt.toFixed(3)} ${wt.toFixed(3)})`:`rgb(${Math.round(pt*255)},${Math.round(vt*255)},${Math.round(wt*255)})`}offsetHSL(at,pt,vt){return this.getHSL(_hslA),this.setHSL(_hslA.h+at,_hslA.s+pt,_hslA.l+vt)}add(at){return this.r+=at.r,this.g+=at.g,this.b+=at.b,this}addColors(at,pt){return this.r=at.r+pt.r,this.g=at.g+pt.g,this.b=at.b+pt.b,this}addScalar(at){return this.r+=at,this.g+=at,this.b+=at,this}sub(at){return this.r=Math.max(0,this.r-at.r),this.g=Math.max(0,this.g-at.g),this.b=Math.max(0,this.b-at.b),this}multiply(at){return this.r*=at.r,this.g*=at.g,this.b*=at.b,this}multiplyScalar(at){return this.r*=at,this.g*=at,this.b*=at,this}lerp(at,pt){return this.r+=(at.r-this.r)*pt,this.g+=(at.g-this.g)*pt,this.b+=(at.b-this.b)*pt,this}lerpColors(at,pt,vt){return this.r=at.r+(pt.r-at.r)*vt,this.g=at.g+(pt.g-at.g)*vt,this.b=at.b+(pt.b-at.b)*vt,this}lerpHSL(at,pt){this.getHSL(_hslA),at.getHSL(_hslB);const vt=lerp(_hslA.h,_hslB.h,pt),wt=lerp(_hslA.s,_hslB.s,pt),$t=lerp(_hslA.l,_hslB.l,pt);return this.setHSL(vt,wt,$t),this}setFromVector3(at){return this.r=at.x,this.g=at.y,this.b=at.z,this}applyMatrix3(at){const pt=this.r,vt=this.g,wt=this.b,$t=at.elements;return this.r=$t[0]*pt+$t[3]*vt+$t[6]*wt,this.g=$t[1]*pt+$t[4]*vt+$t[7]*wt,this.b=$t[2]*pt+$t[5]*vt+$t[8]*wt,this}equals(at){return at.r===this.r&&at.g===this.g&&at.b===this.b}fromArray(at,pt=0){return this.r=at[pt],this.g=at[pt+1],this.b=at[pt+2],this}toArray(at=[],pt=0){return at[pt]=this.r,at[pt+1]=this.g,at[pt+2]=this.b,at}fromBufferAttribute(at,pt){return this.r=at.getX(pt),this.g=at.getY(pt),this.b=at.getZ(pt),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}};const _color=new Color$1;Color$1.NAMES=_colorKeywords;let _materialId=0;class Material extends EventDispatcher{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:_materialId++}),this.uuid=generateUUID(),this.name="",this.type="Material",this.blending=NormalBlending,this.side=FrontSide,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=SrcAlphaFactor,this.blendDst=OneMinusSrcAlphaFactor,this.blendEquation=AddEquation,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Color$1(0,0,0),this.blendAlpha=0,this.depthFunc=LessEqualDepth,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=AlwaysStencilFunc,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=KeepStencilOp,this.stencilZFail=KeepStencilOp,this.stencilZPass=KeepStencilOp,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(at){this._alphaTest>0!=at>0&&this.version++,this._alphaTest=at}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(at){if(at!==void 0)for(const pt in at){const vt=at[pt];if(vt===void 0){console.warn(`THREE.Material: parameter '${pt}' has value of undefined.`);continue}const wt=this[pt];if(wt===void 0){console.warn(`THREE.Material: '${pt}' is not a property of THREE.${this.type}.`);continue}wt&&wt.isColor?wt.set(vt):wt&&wt.isVector3&&vt&&vt.isVector3?wt.copy(vt):this[pt]=vt}}toJSON(at){const pt=at===void 0||typeof at=="string";pt&&(at={textures:{},images:{}});const vt={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};vt.uuid=this.uuid,vt.type=this.type,this.name!==""&&(vt.name=this.name),this.color&&this.color.isColor&&(vt.color=this.color.getHex()),this.roughness!==void 0&&(vt.roughness=this.roughness),this.metalness!==void 0&&(vt.metalness=this.metalness),this.sheen!==void 0&&(vt.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(vt.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(vt.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(vt.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(vt.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(vt.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(vt.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(vt.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(vt.shininess=this.shininess),this.clearcoat!==void 0&&(vt.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(vt.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(vt.clearcoatMap=this.clearcoatMap.toJSON(at).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(vt.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(at).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(vt.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(at).uuid,vt.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(vt.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(vt.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(vt.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(vt.iridescenceMap=this.iridescenceMap.toJSON(at).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(vt.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(at).uuid),this.anisotropy!==void 0&&(vt.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(vt.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(vt.anisotropyMap=this.anisotropyMap.toJSON(at).uuid),this.map&&this.map.isTexture&&(vt.map=this.map.toJSON(at).uuid),this.matcap&&this.matcap.isTexture&&(vt.matcap=this.matcap.toJSON(at).uuid),this.alphaMap&&this.alphaMap.isTexture&&(vt.alphaMap=this.alphaMap.toJSON(at).uuid),this.lightMap&&this.lightMap.isTexture&&(vt.lightMap=this.lightMap.toJSON(at).uuid,vt.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(vt.aoMap=this.aoMap.toJSON(at).uuid,vt.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(vt.bumpMap=this.bumpMap.toJSON(at).uuid,vt.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(vt.normalMap=this.normalMap.toJSON(at).uuid,vt.normalMapType=this.normalMapType,vt.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(vt.displacementMap=this.displacementMap.toJSON(at).uuid,vt.displacementScale=this.displacementScale,vt.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(vt.roughnessMap=this.roughnessMap.toJSON(at).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(vt.metalnessMap=this.metalnessMap.toJSON(at).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(vt.emissiveMap=this.emissiveMap.toJSON(at).uuid),this.specularMap&&this.specularMap.isTexture&&(vt.specularMap=this.specularMap.toJSON(at).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(vt.specularIntensityMap=this.specularIntensityMap.toJSON(at).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(vt.specularColorMap=this.specularColorMap.toJSON(at).uuid),this.envMap&&this.envMap.isTexture&&(vt.envMap=this.envMap.toJSON(at).uuid,this.combine!==void 0&&(vt.combine=this.combine)),this.envMapRotation!==void 0&&(vt.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(vt.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(vt.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(vt.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(vt.gradientMap=this.gradientMap.toJSON(at).uuid),this.transmission!==void 0&&(vt.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(vt.transmissionMap=this.transmissionMap.toJSON(at).uuid),this.thickness!==void 0&&(vt.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(vt.thicknessMap=this.thicknessMap.toJSON(at).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(vt.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(vt.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(vt.size=this.size),this.shadowSide!==null&&(vt.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(vt.sizeAttenuation=this.sizeAttenuation),this.blending!==NormalBlending&&(vt.blending=this.blending),this.side!==FrontSide&&(vt.side=this.side),this.vertexColors===!0&&(vt.vertexColors=!0),this.opacity<1&&(vt.opacity=this.opacity),this.transparent===!0&&(vt.transparent=!0),this.blendSrc!==SrcAlphaFactor&&(vt.blendSrc=this.blendSrc),this.blendDst!==OneMinusSrcAlphaFactor&&(vt.blendDst=this.blendDst),this.blendEquation!==AddEquation&&(vt.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(vt.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(vt.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(vt.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(vt.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(vt.blendAlpha=this.blendAlpha),this.depthFunc!==LessEqualDepth&&(vt.depthFunc=this.depthFunc),this.depthTest===!1&&(vt.depthTest=this.depthTest),this.depthWrite===!1&&(vt.depthWrite=this.depthWrite),this.colorWrite===!1&&(vt.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(vt.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==AlwaysStencilFunc&&(vt.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(vt.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(vt.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==KeepStencilOp&&(vt.stencilFail=this.stencilFail),this.stencilZFail!==KeepStencilOp&&(vt.stencilZFail=this.stencilZFail),this.stencilZPass!==KeepStencilOp&&(vt.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(vt.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(vt.rotation=this.rotation),this.polygonOffset===!0&&(vt.polygonOffset=!0),this.polygonOffsetFactor!==0&&(vt.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(vt.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(vt.linewidth=this.linewidth),this.dashSize!==void 0&&(vt.dashSize=this.dashSize),this.gapSize!==void 0&&(vt.gapSize=this.gapSize),this.scale!==void 0&&(vt.scale=this.scale),this.dithering===!0&&(vt.dithering=!0),this.alphaTest>0&&(vt.alphaTest=this.alphaTest),this.alphaHash===!0&&(vt.alphaHash=!0),this.alphaToCoverage===!0&&(vt.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(vt.premultipliedAlpha=!0),this.forceSinglePass===!0&&(vt.forceSinglePass=!0),this.wireframe===!0&&(vt.wireframe=!0),this.wireframeLinewidth>1&&(vt.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(vt.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(vt.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(vt.flatShading=!0),this.visible===!1&&(vt.visible=!1),this.toneMapped===!1&&(vt.toneMapped=!1),this.fog===!1&&(vt.fog=!1),Object.keys(this.userData).length>0&&(vt.userData=this.userData);function wt($t){const Tt=[];for(const Lt in $t){const Ft=$t[Lt];delete Ft.metadata,Tt.push(Ft)}return Tt}if(pt){const $t=wt(at.textures),Tt=wt(at.images);$t.length>0&&(vt.textures=$t),Tt.length>0&&(vt.images=Tt)}return vt}clone(){return new this.constructor().copy(this)}copy(at){this.name=at.name,this.blending=at.blending,this.side=at.side,this.vertexColors=at.vertexColors,this.opacity=at.opacity,this.transparent=at.transparent,this.blendSrc=at.blendSrc,this.blendDst=at.blendDst,this.blendEquation=at.blendEquation,this.blendSrcAlpha=at.blendSrcAlpha,this.blendDstAlpha=at.blendDstAlpha,this.blendEquationAlpha=at.blendEquationAlpha,this.blendColor.copy(at.blendColor),this.blendAlpha=at.blendAlpha,this.depthFunc=at.depthFunc,this.depthTest=at.depthTest,this.depthWrite=at.depthWrite,this.stencilWriteMask=at.stencilWriteMask,this.stencilFunc=at.stencilFunc,this.stencilRef=at.stencilRef,this.stencilFuncMask=at.stencilFuncMask,this.stencilFail=at.stencilFail,this.stencilZFail=at.stencilZFail,this.stencilZPass=at.stencilZPass,this.stencilWrite=at.stencilWrite;const pt=at.clippingPlanes;let vt=null;if(pt!==null){const wt=pt.length;vt=new Array(wt);for(let $t=0;$t!==wt;++$t)vt[$t]=pt[$t].clone()}return this.clippingPlanes=vt,this.clipIntersection=at.clipIntersection,this.clipShadows=at.clipShadows,this.shadowSide=at.shadowSide,this.colorWrite=at.colorWrite,this.precision=at.precision,this.polygonOffset=at.polygonOffset,this.polygonOffsetFactor=at.polygonOffsetFactor,this.polygonOffsetUnits=at.polygonOffsetUnits,this.dithering=at.dithering,this.alphaTest=at.alphaTest,this.alphaHash=at.alphaHash,this.alphaToCoverage=at.alphaToCoverage,this.premultipliedAlpha=at.premultipliedAlpha,this.forceSinglePass=at.forceSinglePass,this.visible=at.visible,this.toneMapped=at.toneMapped,this.userData=JSON.parse(JSON.stringify(at.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(at){at===!0&&this.version++}}class MeshBasicMaterial extends Material{constructor(at){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Color$1(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(at)}copy(at){return super.copy(at),this.color.copy(at.color),this.map=at.map,this.lightMap=at.lightMap,this.lightMapIntensity=at.lightMapIntensity,this.aoMap=at.aoMap,this.aoMapIntensity=at.aoMapIntensity,this.specularMap=at.specularMap,this.alphaMap=at.alphaMap,this.envMap=at.envMap,this.envMapRotation.copy(at.envMapRotation),this.combine=at.combine,this.reflectivity=at.reflectivity,this.refractionRatio=at.refractionRatio,this.wireframe=at.wireframe,this.wireframeLinewidth=at.wireframeLinewidth,this.wireframeLinecap=at.wireframeLinecap,this.wireframeLinejoin=at.wireframeLinejoin,this.fog=at.fog,this}}const _tables=_generateTables();function _generateTables(){const st=new ArrayBuffer(4),at=new Float32Array(st),pt=new Uint32Array(st),vt=new Uint32Array(512),wt=new Uint32Array(512);for(let Ft=0;Ft<256;++Ft){const Ct=Ft-127;Ct<-27?(vt[Ft]=0,vt[Ft|256]=32768,wt[Ft]=24,wt[Ft|256]=24):Ct<-14?(vt[Ft]=1024>>-Ct-14,vt[Ft|256]=1024>>-Ct-14|32768,wt[Ft]=-Ct-1,wt[Ft|256]=-Ct-1):Ct<=15?(vt[Ft]=Ct+15<<10,vt[Ft|256]=Ct+15<<10|32768,wt[Ft]=13,wt[Ft|256]=13):Ct<128?(vt[Ft]=31744,vt[Ft|256]=64512,wt[Ft]=24,wt[Ft|256]=24):(vt[Ft]=31744,vt[Ft|256]=64512,wt[Ft]=13,wt[Ft|256]=13)}const $t=new Uint32Array(2048),Tt=new Uint32Array(64),Lt=new Uint32Array(64);for(let Ft=1;Ft<1024;++Ft){let Ct=Ft<<13,Ht=0;for(;!(Ct&8388608);)Ct<<=1,Ht-=8388608;Ct&=-8388609,Ht+=947912704,$t[Ft]=Ct|Ht}for(let Ft=1024;Ft<2048;++Ft)$t[Ft]=939524096+(Ft-1024<<13);for(let Ft=1;Ft<31;++Ft)Tt[Ft]=Ft<<23;Tt[31]=1199570944,Tt[32]=2147483648;for(let Ft=33;Ft<63;++Ft)Tt[Ft]=2147483648+(Ft-32<<23);Tt[63]=3347054592;for(let Ft=1;Ft<64;++Ft)Ft!==32&&(Lt[Ft]=1024);return{floatView:at,uint32View:pt,baseTable:vt,shiftTable:wt,mantissaTable:$t,exponentTable:Tt,offsetTable:Lt}}function toHalfFloat(st){Math.abs(st)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),st=clamp$3(st,-65504,65504),_tables.floatView[0]=st;const at=_tables.uint32View[0],pt=at>>23&511;return _tables.baseTable[pt]+((at&8388607)>>_tables.shiftTable[pt])}function fromHalfFloat(st){const at=st>>10;return _tables.uint32View[0]=_tables.mantissaTable[_tables.offsetTable[at]+(st&1023)]+_tables.exponentTable[at],_tables.floatView[0]}const DataUtils={toHalfFloat,fromHalfFloat},_vector$9=new Vector3,_vector2$1=new Vector2;class BufferAttribute{constructor(at,pt,vt=!1){if(Array.isArray(at))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=at,this.itemSize=pt,this.count=at!==void 0?at.length/pt:0,this.normalized=vt,this.usage=StaticDrawUsage,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=FloatType,this.version=0}onUploadCallback(){}set needsUpdate(at){at===!0&&this.version++}get updateRange(){return warnOnce("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(at){return this.usage=at,this}addUpdateRange(at,pt){this.updateRanges.push({start:at,count:pt})}clearUpdateRanges(){this.updateRanges.length=0}copy(at){return this.name=at.name,this.array=new at.array.constructor(at.array),this.itemSize=at.itemSize,this.count=at.count,this.normalized=at.normalized,this.usage=at.usage,this.gpuType=at.gpuType,this}copyAt(at,pt,vt){at*=this.itemSize,vt*=pt.itemSize;for(let wt=0,$t=this.itemSize;wt<$t;wt++)this.array[at+wt]=pt.array[vt+wt];return this}copyArray(at){return this.array.set(at),this}applyMatrix3(at){if(this.itemSize===2)for(let pt=0,vt=this.count;pt<vt;pt++)_vector2$1.fromBufferAttribute(this,pt),_vector2$1.applyMatrix3(at),this.setXY(pt,_vector2$1.x,_vector2$1.y);else if(this.itemSize===3)for(let pt=0,vt=this.count;pt<vt;pt++)_vector$9.fromBufferAttribute(this,pt),_vector$9.applyMatrix3(at),this.setXYZ(pt,_vector$9.x,_vector$9.y,_vector$9.z);return this}applyMatrix4(at){for(let pt=0,vt=this.count;pt<vt;pt++)_vector$9.fromBufferAttribute(this,pt),_vector$9.applyMatrix4(at),this.setXYZ(pt,_vector$9.x,_vector$9.y,_vector$9.z);return this}applyNormalMatrix(at){for(let pt=0,vt=this.count;pt<vt;pt++)_vector$9.fromBufferAttribute(this,pt),_vector$9.applyNormalMatrix(at),this.setXYZ(pt,_vector$9.x,_vector$9.y,_vector$9.z);return this}transformDirection(at){for(let pt=0,vt=this.count;pt<vt;pt++)_vector$9.fromBufferAttribute(this,pt),_vector$9.transformDirection(at),this.setXYZ(pt,_vector$9.x,_vector$9.y,_vector$9.z);return this}set(at,pt=0){return this.array.set(at,pt),this}getComponent(at,pt){let vt=this.array[at*this.itemSize+pt];return this.normalized&&(vt=denormalize(vt,this.array)),vt}setComponent(at,pt,vt){return this.normalized&&(vt=normalize$5(vt,this.array)),this.array[at*this.itemSize+pt]=vt,this}getX(at){let pt=this.array[at*this.itemSize];return this.normalized&&(pt=denormalize(pt,this.array)),pt}setX(at,pt){return this.normalized&&(pt=normalize$5(pt,this.array)),this.array[at*this.itemSize]=pt,this}getY(at){let pt=this.array[at*this.itemSize+1];return this.normalized&&(pt=denormalize(pt,this.array)),pt}setY(at,pt){return this.normalized&&(pt=normalize$5(pt,this.array)),this.array[at*this.itemSize+1]=pt,this}getZ(at){let pt=this.array[at*this.itemSize+2];return this.normalized&&(pt=denormalize(pt,this.array)),pt}setZ(at,pt){return this.normalized&&(pt=normalize$5(pt,this.array)),this.array[at*this.itemSize+2]=pt,this}getW(at){let pt=this.array[at*this.itemSize+3];return this.normalized&&(pt=denormalize(pt,this.array)),pt}setW(at,pt){return this.normalized&&(pt=normalize$5(pt,this.array)),this.array[at*this.itemSize+3]=pt,this}setXY(at,pt,vt){return at*=this.itemSize,this.normalized&&(pt=normalize$5(pt,this.array),vt=normalize$5(vt,this.array)),this.array[at+0]=pt,this.array[at+1]=vt,this}setXYZ(at,pt,vt,wt){return at*=this.itemSize,this.normalized&&(pt=normalize$5(pt,this.array),vt=normalize$5(vt,this.array),wt=normalize$5(wt,this.array)),this.array[at+0]=pt,this.array[at+1]=vt,this.array[at+2]=wt,this}setXYZW(at,pt,vt,wt,$t){return at*=this.itemSize,this.normalized&&(pt=normalize$5(pt,this.array),vt=normalize$5(vt,this.array),wt=normalize$5(wt,this.array),$t=normalize$5($t,this.array)),this.array[at+0]=pt,this.array[at+1]=vt,this.array[at+2]=wt,this.array[at+3]=$t,this}onUpload(at){return this.onUploadCallback=at,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const at={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(at.name=this.name),this.usage!==StaticDrawUsage&&(at.usage=this.usage),at}}class Int8BufferAttribute extends BufferAttribute{constructor(at,pt,vt){super(new Int8Array(at),pt,vt)}}class Uint8BufferAttribute extends BufferAttribute{constructor(at,pt,vt){super(new Uint8Array(at),pt,vt)}}class Uint8ClampedBufferAttribute extends BufferAttribute{constructor(at,pt,vt){super(new Uint8ClampedArray(at),pt,vt)}}class Int16BufferAttribute extends BufferAttribute{constructor(at,pt,vt){super(new Int16Array(at),pt,vt)}}class Uint16BufferAttribute extends BufferAttribute{constructor(at,pt,vt){super(new Uint16Array(at),pt,vt)}}class Int32BufferAttribute extends BufferAttribute{constructor(at,pt,vt){super(new Int32Array(at),pt,vt)}}class Uint32BufferAttribute extends BufferAttribute{constructor(at,pt,vt){super(new Uint32Array(at),pt,vt)}}class Float16BufferAttribute extends BufferAttribute{constructor(at,pt,vt){super(new Uint16Array(at),pt,vt),this.isFloat16BufferAttribute=!0}getX(at){let pt=fromHalfFloat(this.array[at*this.itemSize]);return this.normalized&&(pt=denormalize(pt,this.array)),pt}setX(at,pt){return this.normalized&&(pt=normalize$5(pt,this.array)),this.array[at*this.itemSize]=toHalfFloat(pt),this}getY(at){let pt=fromHalfFloat(this.array[at*this.itemSize+1]);return this.normalized&&(pt=denormalize(pt,this.array)),pt}setY(at,pt){return this.normalized&&(pt=normalize$5(pt,this.array)),this.array[at*this.itemSize+1]=toHalfFloat(pt),this}getZ(at){let pt=fromHalfFloat(this.array[at*this.itemSize+2]);return this.normalized&&(pt=denormalize(pt,this.array)),pt}setZ(at,pt){return this.normalized&&(pt=normalize$5(pt,this.array)),this.array[at*this.itemSize+2]=toHalfFloat(pt),this}getW(at){let pt=fromHalfFloat(this.array[at*this.itemSize+3]);return this.normalized&&(pt=denormalize(pt,this.array)),pt}setW(at,pt){return this.normalized&&(pt=normalize$5(pt,this.array)),this.array[at*this.itemSize+3]=toHalfFloat(pt),this}setXY(at,pt,vt){return at*=this.itemSize,this.normalized&&(pt=normalize$5(pt,this.array),vt=normalize$5(vt,this.array)),this.array[at+0]=toHalfFloat(pt),this.array[at+1]=toHalfFloat(vt),this}setXYZ(at,pt,vt,wt){return at*=this.itemSize,this.normalized&&(pt=normalize$5(pt,this.array),vt=normalize$5(vt,this.array),wt=normalize$5(wt,this.array)),this.array[at+0]=toHalfFloat(pt),this.array[at+1]=toHalfFloat(vt),this.array[at+2]=toHalfFloat(wt),this}setXYZW(at,pt,vt,wt,$t){return at*=this.itemSize,this.normalized&&(pt=normalize$5(pt,this.array),vt=normalize$5(vt,this.array),wt=normalize$5(wt,this.array),$t=normalize$5($t,this.array)),this.array[at+0]=toHalfFloat(pt),this.array[at+1]=toHalfFloat(vt),this.array[at+2]=toHalfFloat(wt),this.array[at+3]=toHalfFloat($t),this}}class Float32BufferAttribute extends BufferAttribute{constructor(at,pt,vt){super(new Float32Array(at),pt,vt)}}let _id$2=0;const _m1$2=new Matrix4,_obj=new Object3D,_offset=new Vector3,_box$2=new Box3,_boxMorphTargets=new Box3,_vector$8=new Vector3;class BufferGeometry extends EventDispatcher{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:_id$2++}),this.uuid=generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(at){return Array.isArray(at)?this.index=new(arrayNeedsUint32(at)?Uint32BufferAttribute:Uint16BufferAttribute)(at,1):this.index=at,this}getAttribute(at){return this.attributes[at]}setAttribute(at,pt){return this.attributes[at]=pt,this}deleteAttribute(at){return delete this.attributes[at],this}hasAttribute(at){return this.attributes[at]!==void 0}addGroup(at,pt,vt=0){this.groups.push({start:at,count:pt,materialIndex:vt})}clearGroups(){this.groups=[]}setDrawRange(at,pt){this.drawRange.start=at,this.drawRange.count=pt}applyMatrix4(at){const pt=this.attributes.position;pt!==void 0&&(pt.applyMatrix4(at),pt.needsUpdate=!0);const vt=this.attributes.normal;if(vt!==void 0){const $t=new Matrix3().getNormalMatrix(at);vt.applyNormalMatrix($t),vt.needsUpdate=!0}const wt=this.attributes.tangent;return wt!==void 0&&(wt.transformDirection(at),wt.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(at){return _m1$2.makeRotationFromQuaternion(at),this.applyMatrix4(_m1$2),this}rotateX(at){return _m1$2.makeRotationX(at),this.applyMatrix4(_m1$2),this}rotateY(at){return _m1$2.makeRotationY(at),this.applyMatrix4(_m1$2),this}rotateZ(at){return _m1$2.makeRotationZ(at),this.applyMatrix4(_m1$2),this}translate(at,pt,vt){return _m1$2.makeTranslation(at,pt,vt),this.applyMatrix4(_m1$2),this}scale(at,pt,vt){return _m1$2.makeScale(at,pt,vt),this.applyMatrix4(_m1$2),this}lookAt(at){return _obj.lookAt(at),_obj.updateMatrix(),this.applyMatrix4(_obj.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(_offset).negate(),this.translate(_offset.x,_offset.y,_offset.z),this}setFromPoints(at){const pt=[];for(let vt=0,wt=at.length;vt<wt;vt++){const $t=at[vt];pt.push($t.x,$t.y,$t.z||0)}return this.setAttribute("position",new Float32BufferAttribute(pt,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Box3);const at=this.attributes.position,pt=this.morphAttributes.position;if(at&&at.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new Vector3(-1/0,-1/0,-1/0),new Vector3(1/0,1/0,1/0));return}if(at!==void 0){if(this.boundingBox.setFromBufferAttribute(at),pt)for(let vt=0,wt=pt.length;vt<wt;vt++){const $t=pt[vt];_box$2.setFromBufferAttribute($t),this.morphTargetsRelative?(_vector$8.addVectors(this.boundingBox.min,_box$2.min),this.boundingBox.expandByPoint(_vector$8),_vector$8.addVectors(this.boundingBox.max,_box$2.max),this.boundingBox.expandByPoint(_vector$8)):(this.boundingBox.expandByPoint(_box$2.min),this.boundingBox.expandByPoint(_box$2.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Sphere);const at=this.attributes.position,pt=this.morphAttributes.position;if(at&&at.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new Vector3,1/0);return}if(at){const vt=this.boundingSphere.center;if(_box$2.setFromBufferAttribute(at),pt)for(let $t=0,Tt=pt.length;$t<Tt;$t++){const Lt=pt[$t];_boxMorphTargets.setFromBufferAttribute(Lt),this.morphTargetsRelative?(_vector$8.addVectors(_box$2.min,_boxMorphTargets.min),_box$2.expandByPoint(_vector$8),_vector$8.addVectors(_box$2.max,_boxMorphTargets.max),_box$2.expandByPoint(_vector$8)):(_box$2.expandByPoint(_boxMorphTargets.min),_box$2.expandByPoint(_boxMorphTargets.max))}_box$2.getCenter(vt);let wt=0;for(let $t=0,Tt=at.count;$t<Tt;$t++)_vector$8.fromBufferAttribute(at,$t),wt=Math.max(wt,vt.distanceToSquared(_vector$8));if(pt)for(let $t=0,Tt=pt.length;$t<Tt;$t++){const Lt=pt[$t],Ft=this.morphTargetsRelative;for(let Ct=0,Ht=Lt.count;Ct<Ht;Ct++)_vector$8.fromBufferAttribute(Lt,Ct),Ft&&(_offset.fromBufferAttribute(at,Ct),_vector$8.add(_offset)),wt=Math.max(wt,vt.distanceToSquared(_vector$8))}this.boundingSphere.radius=Math.sqrt(wt),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const at=this.index,pt=this.attributes;if(at===null||pt.position===void 0||pt.normal===void 0||pt.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const vt=pt.position,wt=pt.normal,$t=pt.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new BufferAttribute(new Float32Array(4*vt.count),4));const Tt=this.getAttribute("tangent"),Lt=[],Ft=[];for(let Bo=0;Bo<vt.count;Bo++)Lt[Bo]=new Vector3,Ft[Bo]=new Vector3;const Ct=new Vector3,Ht=new Vector3,Gt=new Vector3,jt=new Vector2,qt=new Vector2,Kt=new Vector2,An=new Vector3,Sn=new Vector3;function wn(Bo,Xo,Kr){Ct.fromBufferAttribute(vt,Bo),Ht.fromBufferAttribute(vt,Xo),Gt.fromBufferAttribute(vt,Kr),jt.fromBufferAttribute($t,Bo),qt.fromBufferAttribute($t,Xo),Kt.fromBufferAttribute($t,Kr),Ht.sub(Ct),Gt.sub(Ct),qt.sub(jt),Kt.sub(jt);const ko=1/(qt.x*Kt.y-Kt.x*qt.y);isFinite(ko)&&(An.copy(Ht).multiplyScalar(Kt.y).addScaledVector(Gt,-qt.y).multiplyScalar(ko),Sn.copy(Gt).multiplyScalar(qt.x).addScaledVector(Ht,-Kt.x).multiplyScalar(ko),Lt[Bo].add(An),Lt[Xo].add(An),Lt[Kr].add(An),Ft[Bo].add(Sn),Ft[Xo].add(Sn),Ft[Kr].add(Sn))}let In=this.groups;In.length===0&&(In=[{start:0,count:at.count}]);for(let Bo=0,Xo=In.length;Bo<Xo;++Bo){const Kr=In[Bo],ko=Kr.start,f0=Kr.count;for(let x0=ko,l0=ko+f0;x0<l0;x0+=3)wn(at.getX(x0+0),at.getX(x0+1),at.getX(x0+2))}const tr=new Vector3,rr=new Vector3,Hr=new Vector3,qr=new Vector3;function Zr(Bo){Hr.fromBufferAttribute(wt,Bo),qr.copy(Hr);const Xo=Lt[Bo];tr.copy(Xo),tr.sub(Hr.multiplyScalar(Hr.dot(Xo))).normalize(),rr.crossVectors(qr,Xo);const ko=rr.dot(Ft[Bo])<0?-1:1;Tt.setXYZW(Bo,tr.x,tr.y,tr.z,ko)}for(let Bo=0,Xo=In.length;Bo<Xo;++Bo){const Kr=In[Bo],ko=Kr.start,f0=Kr.count;for(let x0=ko,l0=ko+f0;x0<l0;x0+=3)Zr(at.getX(x0+0)),Zr(at.getX(x0+1)),Zr(at.getX(x0+2))}}computeVertexNormals(){const at=this.index,pt=this.getAttribute("position");if(pt!==void 0){let vt=this.getAttribute("normal");if(vt===void 0)vt=new BufferAttribute(new Float32Array(pt.count*3),3),this.setAttribute("normal",vt);else for(let jt=0,qt=vt.count;jt<qt;jt++)vt.setXYZ(jt,0,0,0);const wt=new Vector3,$t=new Vector3,Tt=new Vector3,Lt=new Vector3,Ft=new Vector3,Ct=new Vector3,Ht=new Vector3,Gt=new Vector3;if(at)for(let jt=0,qt=at.count;jt<qt;jt+=3){const Kt=at.getX(jt+0),An=at.getX(jt+1),Sn=at.getX(jt+2);wt.fromBufferAttribute(pt,Kt),$t.fromBufferAttribute(pt,An),Tt.fromBufferAttribute(pt,Sn),Ht.subVectors(Tt,$t),Gt.subVectors(wt,$t),Ht.cross(Gt),Lt.fromBufferAttribute(vt,Kt),Ft.fromBufferAttribute(vt,An),Ct.fromBufferAttribute(vt,Sn),Lt.add(Ht),Ft.add(Ht),Ct.add(Ht),vt.setXYZ(Kt,Lt.x,Lt.y,Lt.z),vt.setXYZ(An,Ft.x,Ft.y,Ft.z),vt.setXYZ(Sn,Ct.x,Ct.y,Ct.z)}else for(let jt=0,qt=pt.count;jt<qt;jt+=3)wt.fromBufferAttribute(pt,jt+0),$t.fromBufferAttribute(pt,jt+1),Tt.fromBufferAttribute(pt,jt+2),Ht.subVectors(Tt,$t),Gt.subVectors(wt,$t),Ht.cross(Gt),vt.setXYZ(jt+0,Ht.x,Ht.y,Ht.z),vt.setXYZ(jt+1,Ht.x,Ht.y,Ht.z),vt.setXYZ(jt+2,Ht.x,Ht.y,Ht.z);this.normalizeNormals(),vt.needsUpdate=!0}}normalizeNormals(){const at=this.attributes.normal;for(let pt=0,vt=at.count;pt<vt;pt++)_vector$8.fromBufferAttribute(at,pt),_vector$8.normalize(),at.setXYZ(pt,_vector$8.x,_vector$8.y,_vector$8.z)}toNonIndexed(){function at(Lt,Ft){const Ct=Lt.array,Ht=Lt.itemSize,Gt=Lt.normalized,jt=new Ct.constructor(Ft.length*Ht);let qt=0,Kt=0;for(let An=0,Sn=Ft.length;An<Sn;An++){Lt.isInterleavedBufferAttribute?qt=Ft[An]*Lt.data.stride+Lt.offset:qt=Ft[An]*Ht;for(let wn=0;wn<Ht;wn++)jt[Kt++]=Ct[qt++]}return new BufferAttribute(jt,Ht,Gt)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const pt=new BufferGeometry,vt=this.index.array,wt=this.attributes;for(const Lt in wt){const Ft=wt[Lt],Ct=at(Ft,vt);pt.setAttribute(Lt,Ct)}const $t=this.morphAttributes;for(const Lt in $t){const Ft=[],Ct=$t[Lt];for(let Ht=0,Gt=Ct.length;Ht<Gt;Ht++){const jt=Ct[Ht],qt=at(jt,vt);Ft.push(qt)}pt.morphAttributes[Lt]=Ft}pt.morphTargetsRelative=this.morphTargetsRelative;const Tt=this.groups;for(let Lt=0,Ft=Tt.length;Lt<Ft;Lt++){const Ct=Tt[Lt];pt.addGroup(Ct.start,Ct.count,Ct.materialIndex)}return pt}toJSON(){const at={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(at.uuid=this.uuid,at.type=this.type,this.name!==""&&(at.name=this.name),Object.keys(this.userData).length>0&&(at.userData=this.userData),this.parameters!==void 0){const Ft=this.parameters;for(const Ct in Ft)Ft[Ct]!==void 0&&(at[Ct]=Ft[Ct]);return at}at.data={attributes:{}};const pt=this.index;pt!==null&&(at.data.index={type:pt.array.constructor.name,array:Array.prototype.slice.call(pt.array)});const vt=this.attributes;for(const Ft in vt){const Ct=vt[Ft];at.data.attributes[Ft]=Ct.toJSON(at.data)}const wt={};let $t=!1;for(const Ft in this.morphAttributes){const Ct=this.morphAttributes[Ft],Ht=[];for(let Gt=0,jt=Ct.length;Gt<jt;Gt++){const qt=Ct[Gt];Ht.push(qt.toJSON(at.data))}Ht.length>0&&(wt[Ft]=Ht,$t=!0)}$t&&(at.data.morphAttributes=wt,at.data.morphTargetsRelative=this.morphTargetsRelative);const Tt=this.groups;Tt.length>0&&(at.data.groups=JSON.parse(JSON.stringify(Tt)));const Lt=this.boundingSphere;return Lt!==null&&(at.data.boundingSphere={center:Lt.center.toArray(),radius:Lt.radius}),at}clone(){return new this.constructor().copy(this)}copy(at){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const pt={};this.name=at.name;const vt=at.index;vt!==null&&this.setIndex(vt.clone(pt));const wt=at.attributes;for(const Ct in wt){const Ht=wt[Ct];this.setAttribute(Ct,Ht.clone(pt))}const $t=at.morphAttributes;for(const Ct in $t){const Ht=[],Gt=$t[Ct];for(let jt=0,qt=Gt.length;jt<qt;jt++)Ht.push(Gt[jt].clone(pt));this.morphAttributes[Ct]=Ht}this.morphTargetsRelative=at.morphTargetsRelative;const Tt=at.groups;for(let Ct=0,Ht=Tt.length;Ct<Ht;Ct++){const Gt=Tt[Ct];this.addGroup(Gt.start,Gt.count,Gt.materialIndex)}const Lt=at.boundingBox;Lt!==null&&(this.boundingBox=Lt.clone());const Ft=at.boundingSphere;return Ft!==null&&(this.boundingSphere=Ft.clone()),this.drawRange.start=at.drawRange.start,this.drawRange.count=at.drawRange.count,this.userData=at.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const _inverseMatrix$3=new Matrix4,_ray$3=new Ray,_sphere$6=new Sphere,_sphereHitAt=new Vector3,_vA$1=new Vector3,_vB$1=new Vector3,_vC$1=new Vector3,_tempA=new Vector3,_morphA=new Vector3,_uvA$1=new Vector2,_uvB$1=new Vector2,_uvC$1=new Vector2,_normalA=new Vector3,_normalB=new Vector3,_normalC=new Vector3,_intersectionPoint=new Vector3,_intersectionPointWorld=new Vector3;class Mesh extends Object3D{constructor(at=new BufferGeometry,pt=new MeshBasicMaterial){super(),this.isMesh=!0,this.type="Mesh",this.geometry=at,this.material=pt,this.updateMorphTargets()}copy(at,pt){return super.copy(at,pt),at.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=at.morphTargetInfluences.slice()),at.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},at.morphTargetDictionary)),this.material=Array.isArray(at.material)?at.material.slice():at.material,this.geometry=at.geometry,this}updateMorphTargets(){const pt=this.geometry.morphAttributes,vt=Object.keys(pt);if(vt.length>0){const wt=pt[vt[0]];if(wt!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let $t=0,Tt=wt.length;$t<Tt;$t++){const Lt=wt[$t].name||String($t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[Lt]=$t}}}}getVertexPosition(at,pt){const vt=this.geometry,wt=vt.attributes.position,$t=vt.morphAttributes.position,Tt=vt.morphTargetsRelative;pt.fromBufferAttribute(wt,at);const Lt=this.morphTargetInfluences;if($t&&Lt){_morphA.set(0,0,0);for(let Ft=0,Ct=$t.length;Ft<Ct;Ft++){const Ht=Lt[Ft],Gt=$t[Ft];Ht!==0&&(_tempA.fromBufferAttribute(Gt,at),Tt?_morphA.addScaledVector(_tempA,Ht):_morphA.addScaledVector(_tempA.sub(pt),Ht))}pt.add(_morphA)}return pt}raycast(at,pt){const vt=this.geometry,wt=this.material,$t=this.matrixWorld;wt!==void 0&&(vt.boundingSphere===null&&vt.computeBoundingSphere(),_sphere$6.copy(vt.boundingSphere),_sphere$6.applyMatrix4($t),_ray$3.copy(at.ray).recast(at.near),!(_sphere$6.containsPoint(_ray$3.origin)===!1&&(_ray$3.intersectSphere(_sphere$6,_sphereHitAt)===null||_ray$3.origin.distanceToSquared(_sphereHitAt)>(at.far-at.near)**2))&&(_inverseMatrix$3.copy($t).invert(),_ray$3.copy(at.ray).applyMatrix4(_inverseMatrix$3),!(vt.boundingBox!==null&&_ray$3.intersectsBox(vt.boundingBox)===!1)&&this._computeIntersections(at,pt,_ray$3)))}_computeIntersections(at,pt,vt){let wt;const $t=this.geometry,Tt=this.material,Lt=$t.index,Ft=$t.attributes.position,Ct=$t.attributes.uv,Ht=$t.attributes.uv1,Gt=$t.attributes.normal,jt=$t.groups,qt=$t.drawRange;if(Lt!==null)if(Array.isArray(Tt))for(let Kt=0,An=jt.length;Kt<An;Kt++){const Sn=jt[Kt],wn=Tt[Sn.materialIndex],In=Math.max(Sn.start,qt.start),tr=Math.min(Lt.count,Math.min(Sn.start+Sn.count,qt.start+qt.count));for(let rr=In,Hr=tr;rr<Hr;rr+=3){const qr=Lt.getX(rr),Zr=Lt.getX(rr+1),Bo=Lt.getX(rr+2);wt=checkGeometryIntersection(this,wn,at,vt,Ct,Ht,Gt,qr,Zr,Bo),wt&&(wt.faceIndex=Math.floor(rr/3),wt.face.materialIndex=Sn.materialIndex,pt.push(wt))}}else{const Kt=Math.max(0,qt.start),An=Math.min(Lt.count,qt.start+qt.count);for(let Sn=Kt,wn=An;Sn<wn;Sn+=3){const In=Lt.getX(Sn),tr=Lt.getX(Sn+1),rr=Lt.getX(Sn+2);wt=checkGeometryIntersection(this,Tt,at,vt,Ct,Ht,Gt,In,tr,rr),wt&&(wt.faceIndex=Math.floor(Sn/3),pt.push(wt))}}else if(Ft!==void 0)if(Array.isArray(Tt))for(let Kt=0,An=jt.length;Kt<An;Kt++){const Sn=jt[Kt],wn=Tt[Sn.materialIndex],In=Math.max(Sn.start,qt.start),tr=Math.min(Ft.count,Math.min(Sn.start+Sn.count,qt.start+qt.count));for(let rr=In,Hr=tr;rr<Hr;rr+=3){const qr=rr,Zr=rr+1,Bo=rr+2;wt=checkGeometryIntersection(this,wn,at,vt,Ct,Ht,Gt,qr,Zr,Bo),wt&&(wt.faceIndex=Math.floor(rr/3),wt.face.materialIndex=Sn.materialIndex,pt.push(wt))}}else{const Kt=Math.max(0,qt.start),An=Math.min(Ft.count,qt.start+qt.count);for(let Sn=Kt,wn=An;Sn<wn;Sn+=3){const In=Sn,tr=Sn+1,rr=Sn+2;wt=checkGeometryIntersection(this,Tt,at,vt,Ct,Ht,Gt,In,tr,rr),wt&&(wt.faceIndex=Math.floor(Sn/3),pt.push(wt))}}}}function checkIntersection(st,at,pt,vt,wt,$t,Tt,Lt){let Ft;if(at.side===BackSide?Ft=vt.intersectTriangle(Tt,$t,wt,!0,Lt):Ft=vt.intersectTriangle(wt,$t,Tt,at.side===FrontSide,Lt),Ft===null)return null;_intersectionPointWorld.copy(Lt),_intersectionPointWorld.applyMatrix4(st.matrixWorld);const Ct=pt.ray.origin.distanceTo(_intersectionPointWorld);return Ct<pt.near||Ct>pt.far?null:{distance:Ct,point:_intersectionPointWorld.clone(),object:st}}function checkGeometryIntersection(st,at,pt,vt,wt,$t,Tt,Lt,Ft,Ct){st.getVertexPosition(Lt,_vA$1),st.getVertexPosition(Ft,_vB$1),st.getVertexPosition(Ct,_vC$1);const Ht=checkIntersection(st,at,pt,vt,_vA$1,_vB$1,_vC$1,_intersectionPoint);if(Ht){wt&&(_uvA$1.fromBufferAttribute(wt,Lt),_uvB$1.fromBufferAttribute(wt,Ft),_uvC$1.fromBufferAttribute(wt,Ct),Ht.uv=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2)),$t&&(_uvA$1.fromBufferAttribute($t,Lt),_uvB$1.fromBufferAttribute($t,Ft),_uvC$1.fromBufferAttribute($t,Ct),Ht.uv1=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2)),Tt&&(_normalA.fromBufferAttribute(Tt,Lt),_normalB.fromBufferAttribute(Tt,Ft),_normalC.fromBufferAttribute(Tt,Ct),Ht.normal=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_normalA,_normalB,_normalC,new Vector3),Ht.normal.dot(vt.direction)>0&&Ht.normal.multiplyScalar(-1));const Gt={a:Lt,b:Ft,c:Ct,normal:new Vector3,materialIndex:0};Triangle.getNormal(_vA$1,_vB$1,_vC$1,Gt.normal),Ht.face=Gt}return Ht}class BoxGeometry extends BufferGeometry{constructor(at=1,pt=1,vt=1,wt=1,$t=1,Tt=1){super(),this.type="BoxGeometry",this.parameters={width:at,height:pt,depth:vt,widthSegments:wt,heightSegments:$t,depthSegments:Tt};const Lt=this;wt=Math.floor(wt),$t=Math.floor($t),Tt=Math.floor(Tt);const Ft=[],Ct=[],Ht=[],Gt=[];let jt=0,qt=0;Kt("z","y","x",-1,-1,vt,pt,at,Tt,$t,0),Kt("z","y","x",1,-1,vt,pt,-at,Tt,$t,1),Kt("x","z","y",1,1,at,vt,pt,wt,Tt,2),Kt("x","z","y",1,-1,at,vt,-pt,wt,Tt,3),Kt("x","y","z",1,-1,at,pt,vt,wt,$t,4),Kt("x","y","z",-1,-1,at,pt,-vt,wt,$t,5),this.setIndex(Ft),this.setAttribute("position",new Float32BufferAttribute(Ct,3)),this.setAttribute("normal",new Float32BufferAttribute(Ht,3)),this.setAttribute("uv",new Float32BufferAttribute(Gt,2));function Kt(An,Sn,wn,In,tr,rr,Hr,qr,Zr,Bo,Xo){const Kr=rr/Zr,ko=Hr/Bo,f0=rr/2,x0=Hr/2,l0=qr/2,T0=Zr+1,t0=Bo+1;let E0=0,n0=0;const m0=new Vector3;for(let h0=0;h0<t0;h0++){const a0=h0*ko-x0;for(let P0=0;P0<T0;P0++){const V0=P0*Kr-f0;m0[An]=V0*In,m0[Sn]=a0*tr,m0[wn]=l0,Ct.push(m0.x,m0.y,m0.z),m0[An]=0,m0[Sn]=0,m0[wn]=qr>0?1:-1,Ht.push(m0.x,m0.y,m0.z),Gt.push(P0/Zr),Gt.push(1-h0/Bo),E0+=1}}for(let h0=0;h0<Bo;h0++)for(let a0=0;a0<Zr;a0++){const P0=jt+a0+T0*h0,V0=jt+a0+T0*(h0+1),B0=jt+(a0+1)+T0*(h0+1),W0=jt+(a0+1)+T0*h0;Ft.push(P0,V0,W0),Ft.push(V0,B0,W0),n0+=6}Lt.addGroup(qt,n0,Xo),qt+=n0,jt+=E0}}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}static fromJSON(at){return new BoxGeometry(at.width,at.height,at.depth,at.widthSegments,at.heightSegments,at.depthSegments)}}function cloneUniforms(st){const at={};for(const pt in st){at[pt]={};for(const vt in st[pt]){const wt=st[pt][vt];wt&&(wt.isColor||wt.isMatrix3||wt.isMatrix4||wt.isVector2||wt.isVector3||wt.isVector4||wt.isTexture||wt.isQuaternion)?wt.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),at[pt][vt]=null):at[pt][vt]=wt.clone():Array.isArray(wt)?at[pt][vt]=wt.slice():at[pt][vt]=wt}}return at}function mergeUniforms(st){const at={};for(let pt=0;pt<st.length;pt++){const vt=cloneUniforms(st[pt]);for(const wt in vt)at[wt]=vt[wt]}return at}function cloneUniformsGroups(st){const at=[];for(let pt=0;pt<st.length;pt++)at.push(st[pt].clone());return at}function getUnlitUniformColorSpace(st){return st.getRenderTarget()===null?st.outputColorSpace:ColorManagement.workingColorSpace}const UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};var default_vertex=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,default_fragment=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ShaderMaterial extends Material{constructor(at){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=default_vertex,this.fragmentShader=default_fragment,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1,clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,at!==void 0&&this.setValues(at)}copy(at){return super.copy(at),this.fragmentShader=at.fragmentShader,this.vertexShader=at.vertexShader,this.uniforms=cloneUniforms(at.uniforms),this.uniformsGroups=cloneUniformsGroups(at.uniformsGroups),this.defines=Object.assign({},at.defines),this.wireframe=at.wireframe,this.wireframeLinewidth=at.wireframeLinewidth,this.fog=at.fog,this.lights=at.lights,this.clipping=at.clipping,this.extensions=Object.assign({},at.extensions),this.glslVersion=at.glslVersion,this}toJSON(at){const pt=super.toJSON(at);pt.glslVersion=this.glslVersion,pt.uniforms={};for(const wt in this.uniforms){const Tt=this.uniforms[wt].value;Tt&&Tt.isTexture?pt.uniforms[wt]={type:"t",value:Tt.toJSON(at).uuid}:Tt&&Tt.isColor?pt.uniforms[wt]={type:"c",value:Tt.getHex()}:Tt&&Tt.isVector2?pt.uniforms[wt]={type:"v2",value:Tt.toArray()}:Tt&&Tt.isVector3?pt.uniforms[wt]={type:"v3",value:Tt.toArray()}:Tt&&Tt.isVector4?pt.uniforms[wt]={type:"v4",value:Tt.toArray()}:Tt&&Tt.isMatrix3?pt.uniforms[wt]={type:"m3",value:Tt.toArray()}:Tt&&Tt.isMatrix4?pt.uniforms[wt]={type:"m4",value:Tt.toArray()}:pt.uniforms[wt]={value:Tt}}Object.keys(this.defines).length>0&&(pt.defines=this.defines),pt.vertexShader=this.vertexShader,pt.fragmentShader=this.fragmentShader,pt.lights=this.lights,pt.clipping=this.clipping;const vt={};for(const wt in this.extensions)this.extensions[wt]===!0&&(vt[wt]=!0);return Object.keys(vt).length>0&&(pt.extensions=vt),pt}}class Camera extends Object3D{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Matrix4,this.projectionMatrix=new Matrix4,this.projectionMatrixInverse=new Matrix4,this.coordinateSystem=WebGLCoordinateSystem}copy(at,pt){return super.copy(at,pt),this.matrixWorldInverse.copy(at.matrixWorldInverse),this.projectionMatrix.copy(at.projectionMatrix),this.projectionMatrixInverse.copy(at.projectionMatrixInverse),this.coordinateSystem=at.coordinateSystem,this}getWorldDirection(at){return super.getWorldDirection(at).negate()}updateMatrixWorld(at){super.updateMatrixWorld(at),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(at,pt){super.updateWorldMatrix(at,pt),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const _v3$1=new Vector3,_minTarget=new Vector2,_maxTarget=new Vector2;class PerspectiveCamera extends Camera{constructor(at=50,pt=1,vt=.1,wt=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=at,this.zoom=1,this.near=vt,this.far=wt,this.focus=10,this.aspect=pt,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(at,pt){return super.copy(at,pt),this.fov=at.fov,this.zoom=at.zoom,this.near=at.near,this.far=at.far,this.focus=at.focus,this.aspect=at.aspect,this.view=at.view===null?null:Object.assign({},at.view),this.filmGauge=at.filmGauge,this.filmOffset=at.filmOffset,this}setFocalLength(at){const pt=.5*this.getFilmHeight()/at;this.fov=RAD2DEG*2*Math.atan(pt),this.updateProjectionMatrix()}getFocalLength(){const at=Math.tan(DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/at}getEffectiveFOV(){return RAD2DEG*2*Math.atan(Math.tan(DEG2RAD*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(at,pt,vt){_v3$1.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),pt.set(_v3$1.x,_v3$1.y).multiplyScalar(-at/_v3$1.z),_v3$1.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),vt.set(_v3$1.x,_v3$1.y).multiplyScalar(-at/_v3$1.z)}getViewSize(at,pt){return this.getViewBounds(at,_minTarget,_maxTarget),pt.subVectors(_maxTarget,_minTarget)}setViewOffset(at,pt,vt,wt,$t,Tt){this.aspect=at/pt,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=at,this.view.fullHeight=pt,this.view.offsetX=vt,this.view.offsetY=wt,this.view.width=$t,this.view.height=Tt,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const at=this.near;let pt=at*Math.tan(DEG2RAD*.5*this.fov)/this.zoom,vt=2*pt,wt=this.aspect*vt,$t=-.5*wt;const Tt=this.view;if(this.view!==null&&this.view.enabled){const Ft=Tt.fullWidth,Ct=Tt.fullHeight;$t+=Tt.offsetX*wt/Ft,pt-=Tt.offsetY*vt/Ct,wt*=Tt.width/Ft,vt*=Tt.height/Ct}const Lt=this.filmOffset;Lt!==0&&($t+=at*Lt/this.getFilmWidth()),this.projectionMatrix.makePerspective($t,$t+wt,pt,pt-vt,at,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(at){const pt=super.toJSON(at);return pt.object.fov=this.fov,pt.object.zoom=this.zoom,pt.object.near=this.near,pt.object.far=this.far,pt.object.focus=this.focus,pt.object.aspect=this.aspect,this.view!==null&&(pt.object.view=Object.assign({},this.view)),pt.object.filmGauge=this.filmGauge,pt.object.filmOffset=this.filmOffset,pt}}const fov=-90,aspect=1;class CubeCamera extends Object3D{constructor(at,pt,vt){super(),this.type="CubeCamera",this.renderTarget=vt,this.coordinateSystem=null,this.activeMipmapLevel=0;const wt=new PerspectiveCamera(fov,aspect,at,pt);wt.layers=this.layers,this.add(wt);const $t=new PerspectiveCamera(fov,aspect,at,pt);$t.layers=this.layers,this.add($t);const Tt=new PerspectiveCamera(fov,aspect,at,pt);Tt.layers=this.layers,this.add(Tt);const Lt=new PerspectiveCamera(fov,aspect,at,pt);Lt.layers=this.layers,this.add(Lt);const Ft=new PerspectiveCamera(fov,aspect,at,pt);Ft.layers=this.layers,this.add(Ft);const Ct=new PerspectiveCamera(fov,aspect,at,pt);Ct.layers=this.layers,this.add(Ct)}updateCoordinateSystem(){const at=this.coordinateSystem,pt=this.children.concat(),[vt,wt,$t,Tt,Lt,Ft]=pt;for(const Ct of pt)this.remove(Ct);if(at===WebGLCoordinateSystem)vt.up.set(0,1,0),vt.lookAt(1,0,0),wt.up.set(0,1,0),wt.lookAt(-1,0,0),$t.up.set(0,0,-1),$t.lookAt(0,1,0),Tt.up.set(0,0,1),Tt.lookAt(0,-1,0),Lt.up.set(0,1,0),Lt.lookAt(0,0,1),Ft.up.set(0,1,0),Ft.lookAt(0,0,-1);else if(at===WebGPUCoordinateSystem)vt.up.set(0,-1,0),vt.lookAt(-1,0,0),wt.up.set(0,-1,0),wt.lookAt(1,0,0),$t.up.set(0,0,1),$t.lookAt(0,1,0),Tt.up.set(0,0,-1),Tt.lookAt(0,-1,0),Lt.up.set(0,-1,0),Lt.lookAt(0,0,1),Ft.up.set(0,-1,0),Ft.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+at);for(const Ct of pt)this.add(Ct),Ct.updateMatrixWorld()}update(at,pt){this.parent===null&&this.updateMatrixWorld();const{renderTarget:vt,activeMipmapLevel:wt}=this;this.coordinateSystem!==at.coordinateSystem&&(this.coordinateSystem=at.coordinateSystem,this.updateCoordinateSystem());const[$t,Tt,Lt,Ft,Ct,Ht]=this.children,Gt=at.getRenderTarget(),jt=at.getActiveCubeFace(),qt=at.getActiveMipmapLevel(),Kt=at.xr.enabled;at.xr.enabled=!1;const An=vt.texture.generateMipmaps;vt.texture.generateMipmaps=!1,at.setRenderTarget(vt,0,wt),at.render(pt,$t),at.setRenderTarget(vt,1,wt),at.render(pt,Tt),at.setRenderTarget(vt,2,wt),at.render(pt,Lt),at.setRenderTarget(vt,3,wt),at.render(pt,Ft),at.setRenderTarget(vt,4,wt),at.render(pt,Ct),vt.texture.generateMipmaps=An,at.setRenderTarget(vt,5,wt),at.render(pt,Ht),at.setRenderTarget(Gt,jt,qt),at.xr.enabled=Kt,vt.texture.needsPMREMUpdate=!0}}class CubeTexture extends Texture{constructor(at,pt,vt,wt,$t,Tt,Lt,Ft,Ct,Ht){at=at!==void 0?at:[],pt=pt!==void 0?pt:CubeReflectionMapping,super(at,pt,vt,wt,$t,Tt,Lt,Ft,Ct,Ht),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(at){this.image=at}}class WebGLCubeRenderTarget extends WebGLRenderTarget{constructor(at=1,pt={}){super(at,at,pt),this.isWebGLCubeRenderTarget=!0;const vt={width:at,height:at,depth:1},wt=[vt,vt,vt,vt,vt,vt];this.texture=new CubeTexture(wt,pt.mapping,pt.wrapS,pt.wrapT,pt.magFilter,pt.minFilter,pt.format,pt.type,pt.anisotropy,pt.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=pt.generateMipmaps!==void 0?pt.generateMipmaps:!1,this.texture.minFilter=pt.minFilter!==void 0?pt.minFilter:LinearFilter}fromEquirectangularTexture(at,pt){this.texture.type=pt.type,this.texture.colorSpace=pt.colorSpace,this.texture.generateMipmaps=pt.generateMipmaps,this.texture.minFilter=pt.minFilter,this.texture.magFilter=pt.magFilter;const vt={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},wt=new BoxGeometry(5,5,5),$t=new ShaderMaterial({name:"CubemapFromEquirect",uniforms:cloneUniforms(vt.uniforms),vertexShader:vt.vertexShader,fragmentShader:vt.fragmentShader,side:BackSide,blending:NoBlending});$t.uniforms.tEquirect.value=pt;const Tt=new Mesh(wt,$t),Lt=pt.minFilter;return pt.minFilter===LinearMipmapLinearFilter&&(pt.minFilter=LinearFilter),new CubeCamera(1,10,this).update(at,Tt),pt.minFilter=Lt,Tt.geometry.dispose(),Tt.material.dispose(),this}clear(at,pt,vt,wt){const $t=at.getRenderTarget();for(let Tt=0;Tt<6;Tt++)at.setRenderTarget(this,Tt),at.clear(pt,vt,wt);at.setRenderTarget($t)}}const _vector1=new Vector3,_vector2=new Vector3,_normalMatrix=new Matrix3;class Plane{constructor(at=new Vector3(1,0,0),pt=0){this.isPlane=!0,this.normal=at,this.constant=pt}set(at,pt){return this.normal.copy(at),this.constant=pt,this}setComponents(at,pt,vt,wt){return this.normal.set(at,pt,vt),this.constant=wt,this}setFromNormalAndCoplanarPoint(at,pt){return this.normal.copy(at),this.constant=-pt.dot(this.normal),this}setFromCoplanarPoints(at,pt,vt){const wt=_vector1.subVectors(vt,pt).cross(_vector2.subVectors(at,pt)).normalize();return this.setFromNormalAndCoplanarPoint(wt,at),this}copy(at){return this.normal.copy(at.normal),this.constant=at.constant,this}normalize(){const at=1/this.normal.length();return this.normal.multiplyScalar(at),this.constant*=at,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(at){return this.normal.dot(at)+this.constant}distanceToSphere(at){return this.distanceToPoint(at.center)-at.radius}projectPoint(at,pt){return pt.copy(at).addScaledVector(this.normal,-this.distanceToPoint(at))}intersectLine(at,pt){const vt=at.delta(_vector1),wt=this.normal.dot(vt);if(wt===0)return this.distanceToPoint(at.start)===0?pt.copy(at.start):null;const $t=-(at.start.dot(this.normal)+this.constant)/wt;return $t<0||$t>1?null:pt.copy(at.start).addScaledVector(vt,$t)}intersectsLine(at){const pt=this.distanceToPoint(at.start),vt=this.distanceToPoint(at.end);return pt<0&&vt>0||vt<0&&pt>0}intersectsBox(at){return at.intersectsPlane(this)}intersectsSphere(at){return at.intersectsPlane(this)}coplanarPoint(at){return at.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(at,pt){const vt=pt||_normalMatrix.getNormalMatrix(at),wt=this.coplanarPoint(_vector1).applyMatrix4(at),$t=this.normal.applyMatrix3(vt).normalize();return this.constant=-wt.dot($t),this}translate(at){return this.constant-=at.dot(this.normal),this}equals(at){return at.normal.equals(this.normal)&&at.constant===this.constant}clone(){return new this.constructor().copy(this)}}const _sphere$5=new Sphere,_vector$7=new Vector3;class Frustum{constructor(at=new Plane,pt=new Plane,vt=new Plane,wt=new Plane,$t=new Plane,Tt=new Plane){this.planes=[at,pt,vt,wt,$t,Tt]}set(at,pt,vt,wt,$t,Tt){const Lt=this.planes;return Lt[0].copy(at),Lt[1].copy(pt),Lt[2].copy(vt),Lt[3].copy(wt),Lt[4].copy($t),Lt[5].copy(Tt),this}copy(at){const pt=this.planes;for(let vt=0;vt<6;vt++)pt[vt].copy(at.planes[vt]);return this}setFromProjectionMatrix(at,pt=WebGLCoordinateSystem){const vt=this.planes,wt=at.elements,$t=wt[0],Tt=wt[1],Lt=wt[2],Ft=wt[3],Ct=wt[4],Ht=wt[5],Gt=wt[6],jt=wt[7],qt=wt[8],Kt=wt[9],An=wt[10],Sn=wt[11],wn=wt[12],In=wt[13],tr=wt[14],rr=wt[15];if(vt[0].setComponents(Ft-$t,jt-Ct,Sn-qt,rr-wn).normalize(),vt[1].setComponents(Ft+$t,jt+Ct,Sn+qt,rr+wn).normalize(),vt[2].setComponents(Ft+Tt,jt+Ht,Sn+Kt,rr+In).normalize(),vt[3].setComponents(Ft-Tt,jt-Ht,Sn-Kt,rr-In).normalize(),vt[4].setComponents(Ft-Lt,jt-Gt,Sn-An,rr-tr).normalize(),pt===WebGLCoordinateSystem)vt[5].setComponents(Ft+Lt,jt+Gt,Sn+An,rr+tr).normalize();else if(pt===WebGPUCoordinateSystem)vt[5].setComponents(Lt,Gt,An,tr).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+pt);return this}intersectsObject(at){if(at.boundingSphere!==void 0)at.boundingSphere===null&&at.computeBoundingSphere(),_sphere$5.copy(at.boundingSphere).applyMatrix4(at.matrixWorld);else{const pt=at.geometry;pt.boundingSphere===null&&pt.computeBoundingSphere(),_sphere$5.copy(pt.boundingSphere).applyMatrix4(at.matrixWorld)}return this.intersectsSphere(_sphere$5)}intersectsSprite(at){return _sphere$5.center.set(0,0,0),_sphere$5.radius=.7071067811865476,_sphere$5.applyMatrix4(at.matrixWorld),this.intersectsSphere(_sphere$5)}intersectsSphere(at){const pt=this.planes,vt=at.center,wt=-at.radius;for(let $t=0;$t<6;$t++)if(pt[$t].distanceToPoint(vt)<wt)return!1;return!0}intersectsBox(at){const pt=this.planes;for(let vt=0;vt<6;vt++){const wt=pt[vt];if(_vector$7.x=wt.normal.x>0?at.max.x:at.min.x,_vector$7.y=wt.normal.y>0?at.max.y:at.min.y,_vector$7.z=wt.normal.z>0?at.max.z:at.min.z,wt.distanceToPoint(_vector$7)<0)return!1}return!0}containsPoint(at){const pt=this.planes;for(let vt=0;vt<6;vt++)if(pt[vt].distanceToPoint(at)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function WebGLAnimation(){let st=null,at=!1,pt=null,vt=null;function wt($t,Tt){pt($t,Tt),vt=st.requestAnimationFrame(wt)}return{start:function(){at!==!0&&pt!==null&&(vt=st.requestAnimationFrame(wt),at=!0)},stop:function(){st.cancelAnimationFrame(vt),at=!1},setAnimationLoop:function($t){pt=$t},setContext:function($t){st=$t}}}function WebGLAttributes(st,at){const pt=at.isWebGL2,vt=new WeakMap;function wt(Ct,Ht){const Gt=Ct.array,jt=Ct.usage,qt=Gt.byteLength,Kt=st.createBuffer();st.bindBuffer(Ht,Kt),st.bufferData(Ht,Gt,jt),Ct.onUploadCallback();let An;if(Gt instanceof Float32Array)An=st.FLOAT;else if(Gt instanceof Uint16Array)if(Ct.isFloat16BufferAttribute)if(pt)An=st.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else An=st.UNSIGNED_SHORT;else if(Gt instanceof Int16Array)An=st.SHORT;else if(Gt instanceof Uint32Array)An=st.UNSIGNED_INT;else if(Gt instanceof Int32Array)An=st.INT;else if(Gt instanceof Int8Array)An=st.BYTE;else if(Gt instanceof Uint8Array)An=st.UNSIGNED_BYTE;else if(Gt instanceof Uint8ClampedArray)An=st.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+Gt);return{buffer:Kt,type:An,bytesPerElement:Gt.BYTES_PER_ELEMENT,version:Ct.version,size:qt}}function $t(Ct,Ht,Gt){const jt=Ht.array,qt=Ht._updateRange,Kt=Ht.updateRanges;if(st.bindBuffer(Gt,Ct),qt.count===-1&&Kt.length===0&&st.bufferSubData(Gt,0,jt),Kt.length!==0){for(let An=0,Sn=Kt.length;An<Sn;An++){const wn=Kt[An];pt?st.bufferSubData(Gt,wn.start*jt.BYTES_PER_ELEMENT,jt,wn.start,wn.count):st.bufferSubData(Gt,wn.start*jt.BYTES_PER_ELEMENT,jt.subarray(wn.start,wn.start+wn.count))}Ht.clearUpdateRanges()}qt.count!==-1&&(pt?st.bufferSubData(Gt,qt.offset*jt.BYTES_PER_ELEMENT,jt,qt.offset,qt.count):st.bufferSubData(Gt,qt.offset*jt.BYTES_PER_ELEMENT,jt.subarray(qt.offset,qt.offset+qt.count)),qt.count=-1),Ht.onUploadCallback()}function Tt(Ct){return Ct.isInterleavedBufferAttribute&&(Ct=Ct.data),vt.get(Ct)}function Lt(Ct){Ct.isInterleavedBufferAttribute&&(Ct=Ct.data);const Ht=vt.get(Ct);Ht&&(st.deleteBuffer(Ht.buffer),vt.delete(Ct))}function Ft(Ct,Ht){if(Ct.isGLBufferAttribute){const jt=vt.get(Ct);(!jt||jt.version<Ct.version)&&vt.set(Ct,{buffer:Ct.buffer,type:Ct.type,bytesPerElement:Ct.elementSize,version:Ct.version});return}Ct.isInterleavedBufferAttribute&&(Ct=Ct.data);const Gt=vt.get(Ct);if(Gt===void 0)vt.set(Ct,wt(Ct,Ht));else if(Gt.version<Ct.version){if(Gt.size!==Ct.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");$t(Gt.buffer,Ct,Ht),Gt.version=Ct.version}}return{get:Tt,remove:Lt,update:Ft}}class PlaneGeometry extends BufferGeometry{constructor(at=1,pt=1,vt=1,wt=1){super(),this.type="PlaneGeometry",this.parameters={width:at,height:pt,widthSegments:vt,heightSegments:wt};const $t=at/2,Tt=pt/2,Lt=Math.floor(vt),Ft=Math.floor(wt),Ct=Lt+1,Ht=Ft+1,Gt=at/Lt,jt=pt/Ft,qt=[],Kt=[],An=[],Sn=[];for(let wn=0;wn<Ht;wn++){const In=wn*jt-Tt;for(let tr=0;tr<Ct;tr++){const rr=tr*Gt-$t;Kt.push(rr,-In,0),An.push(0,0,1),Sn.push(tr/Lt),Sn.push(1-wn/Ft)}}for(let wn=0;wn<Ft;wn++)for(let In=0;In<Lt;In++){const tr=In+Ct*wn,rr=In+Ct*(wn+1),Hr=In+1+Ct*(wn+1),qr=In+1+Ct*wn;qt.push(tr,rr,qr),qt.push(rr,Hr,qr)}this.setIndex(qt),this.setAttribute("position",new Float32BufferAttribute(Kt,3)),this.setAttribute("normal",new Float32BufferAttribute(An,3)),this.setAttribute("uv",new Float32BufferAttribute(Sn,2))}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}static fromJSON(at){return new PlaneGeometry(at.width,at.height,at.widthSegments,at.heightSegments)}}var alphahash_fragment=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,alphahash_pars_fragment=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,alphamap_fragment=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,alphamap_pars_fragment=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,alphatest_fragment=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,alphatest_pars_fragment=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,aomap_fragment=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,aomap_pars_fragment=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,batching_pars_vertex=`#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,batching_vertex=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,begin_vertex=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,beginnormal_vertex=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bsdfs=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,iridescence_fragment=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,bumpmap_pars_fragment=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,clipping_planes_fragment=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,clipping_planes_pars_fragment=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,clipping_planes_pars_vertex=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,clipping_planes_vertex=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,color_fragment=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,color_pars_fragment=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,color_pars_vertex=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,color_vertex=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,common=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,cube_uv_reflection_fragment=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,defaultnormal_vertex=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,displacementmap_pars_vertex=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,displacementmap_vertex=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,emissivemap_fragment=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,emissivemap_pars_fragment=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,colorspace_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,envmap_fragment=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,envmap_common_pars_fragment=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,envmap_pars_fragment=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,envmap_pars_vertex=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,envmap_vertex=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fog_vertex=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,fog_pars_vertex=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,fog_fragment=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fog_pars_fragment=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gradientmap_pars_fragment=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,lightmap_fragment=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,lightmap_pars_fragment=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,lights_lambert_fragment=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,lights_lambert_pars_fragment=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,lights_pars_begin=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,envmap_physical_pars_fragment=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,lights_toon_fragment=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lights_toon_pars_fragment=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,lights_phong_fragment=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lights_phong_pars_fragment=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,lights_physical_fragment=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,lights_physical_pars_fragment=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lights_fragment_begin=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lights_fragment_maps=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,lights_fragment_end=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,logdepthbuf_fragment=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,logdepthbuf_pars_fragment=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_pars_vertex=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,logdepthbuf_vertex=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,map_fragment=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,map_pars_fragment=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,map_particle_fragment=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,map_particle_pars_fragment=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,metalnessmap_fragment=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,metalnessmap_pars_fragment=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,morphinstance_vertex=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,morphcolor_vertex=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,morphnormal_vertex=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,morphtarget_pars_vertex=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,morphtarget_vertex=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,normal_fragment_begin=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,normal_fragment_maps=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,normal_pars_fragment=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_pars_vertex=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_vertex=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,normalmap_pars_fragment=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,clearcoat_normal_fragment_begin=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,clearcoat_normal_fragment_maps=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,clearcoat_pars_fragment=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,iridescence_pars_fragment=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,opaque_fragment=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,packing=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,premultiplied_alpha_fragment=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,project_vertex=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,dithering_fragment=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,dithering_pars_fragment=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,roughnessmap_fragment=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,roughnessmap_pars_fragment=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,shadowmap_pars_fragment=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,shadowmap_pars_vertex=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,shadowmap_vertex=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,shadowmask_pars_fragment=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,skinbase_vertex=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,skinning_pars_vertex=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,skinning_vertex=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,skinnormal_vertex=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,specularmap_fragment=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,specularmap_pars_fragment=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tonemapping_fragment=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tonemapping_pars_fragment=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	float startCompression = 0.8 - 0.04;
	float desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min(color.r, min(color.g, color.b));
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max(color.r, max(color.g, color.b));
	if (peak < startCompression) return color;
	float d = 1. - startCompression;
	float newPeak = 1. - d * d / (peak + d - startCompression);
	color *= newPeak / peak;
	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
	return mix(color, vec3(1, 1, 1), g);
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,transmission_fragment=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,transmission_pars_fragment=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,uv_pars_fragment=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uv_pars_vertex=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uv_vertex=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,worldpos_vertex=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const vertex$h=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,fragment$h=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$g=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fragment$g=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$f=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fragment$f=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$e=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,fragment$e=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,vertex$d=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,fragment$d=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,vertex$c=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,fragment$c=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$b=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fragment$b=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vertex$a=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,fragment$a=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$9=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$9=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$8=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,fragment$8=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$7=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,fragment$7=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,vertex$6=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$6=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$5=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,fragment$5=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$4=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$4=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$3=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,fragment$3=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vertex$2=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$2=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,vertex$1=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fragment$1=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,ShaderChunk={alphahash_fragment,alphahash_pars_fragment,alphamap_fragment,alphamap_pars_fragment,alphatest_fragment,alphatest_pars_fragment,aomap_fragment,aomap_pars_fragment,batching_pars_vertex,batching_vertex,begin_vertex,beginnormal_vertex,bsdfs,iridescence_fragment,bumpmap_pars_fragment,clipping_planes_fragment,clipping_planes_pars_fragment,clipping_planes_pars_vertex,clipping_planes_vertex,color_fragment,color_pars_fragment,color_pars_vertex,color_vertex,common,cube_uv_reflection_fragment,defaultnormal_vertex,displacementmap_pars_vertex,displacementmap_vertex,emissivemap_fragment,emissivemap_pars_fragment,colorspace_fragment,colorspace_pars_fragment,envmap_fragment,envmap_common_pars_fragment,envmap_pars_fragment,envmap_pars_vertex,envmap_physical_pars_fragment,envmap_vertex,fog_vertex,fog_pars_vertex,fog_fragment,fog_pars_fragment,gradientmap_pars_fragment,lightmap_fragment,lightmap_pars_fragment,lights_lambert_fragment,lights_lambert_pars_fragment,lights_pars_begin,lights_toon_fragment,lights_toon_pars_fragment,lights_phong_fragment,lights_phong_pars_fragment,lights_physical_fragment,lights_physical_pars_fragment,lights_fragment_begin,lights_fragment_maps,lights_fragment_end,logdepthbuf_fragment,logdepthbuf_pars_fragment,logdepthbuf_pars_vertex,logdepthbuf_vertex,map_fragment,map_pars_fragment,map_particle_fragment,map_particle_pars_fragment,metalnessmap_fragment,metalnessmap_pars_fragment,morphinstance_vertex,morphcolor_vertex,morphnormal_vertex,morphtarget_pars_vertex,morphtarget_vertex,normal_fragment_begin,normal_fragment_maps,normal_pars_fragment,normal_pars_vertex,normal_vertex,normalmap_pars_fragment,clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps,clearcoat_pars_fragment,iridescence_pars_fragment,opaque_fragment,packing,premultiplied_alpha_fragment,project_vertex,dithering_fragment,dithering_pars_fragment,roughnessmap_fragment,roughnessmap_pars_fragment,shadowmap_pars_fragment,shadowmap_pars_vertex,shadowmap_vertex,shadowmask_pars_fragment,skinbase_vertex,skinning_pars_vertex,skinning_vertex,skinnormal_vertex,specularmap_fragment,specularmap_pars_fragment,tonemapping_fragment,tonemapping_pars_fragment,transmission_fragment,transmission_pars_fragment,uv_pars_fragment,uv_pars_vertex,uv_vertex,worldpos_vertex,background_vert:vertex$h,background_frag:fragment$h,backgroundCube_vert:vertex$g,backgroundCube_frag:fragment$g,cube_vert:vertex$f,cube_frag:fragment$f,depth_vert:vertex$e,depth_frag:fragment$e,distanceRGBA_vert:vertex$d,distanceRGBA_frag:fragment$d,equirect_vert:vertex$c,equirect_frag:fragment$c,linedashed_vert:vertex$b,linedashed_frag:fragment$b,meshbasic_vert:vertex$a,meshbasic_frag:fragment$a,meshlambert_vert:vertex$9,meshlambert_frag:fragment$9,meshmatcap_vert:vertex$8,meshmatcap_frag:fragment$8,meshnormal_vert:vertex$7,meshnormal_frag:fragment$7,meshphong_vert:vertex$6,meshphong_frag:fragment$6,meshphysical_vert:vertex$5,meshphysical_frag:fragment$5,meshtoon_vert:vertex$4,meshtoon_frag:fragment$4,points_vert:vertex$3,points_frag:fragment$3,shadow_vert:vertex$2,shadow_frag:fragment$2,sprite_vert:vertex$1,sprite_frag:fragment$1},UniformsLib={common:{diffuse:{value:new Color$1(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Matrix3},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Matrix3}},envmap:{envMap:{value:null},envMapRotation:{value:new Matrix3},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Matrix3}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Matrix3}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Matrix3},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Matrix3},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Matrix3},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Matrix3}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Matrix3}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Matrix3}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Color$1(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Color$1(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0},uvTransform:{value:new Matrix3}},sprite:{diffuse:{value:new Color$1(16777215)},opacity:{value:1},center:{value:new Vector2(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Matrix3},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0}}},ShaderLib={basic:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color$1(0)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color$1(0)},specular:{value:new Color$1(1118481)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color$1(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color$1(0)}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:mergeUniforms([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1}}]),vertexShader:ShaderChunk.meshnormal_vert,fragmentShader:ShaderChunk.meshnormal_frag},sprite:{uniforms:mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Matrix3}},vertexShader:ShaderChunk.backgroundCube_vert,fragmentShader:ShaderChunk.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:new Vector3},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:new Color$1(0)},opacity:{value:1}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Matrix3},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Matrix3},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Matrix3},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Matrix3},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Matrix3},sheen:{value:0},sheenColor:{value:new Color$1(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Matrix3},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Matrix3},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Matrix3},transmissionSamplerSize:{value:new Vector2},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Matrix3},attenuationDistance:{value:0},attenuationColor:{value:new Color$1(0)},specularColor:{value:new Color$1(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Matrix3},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Matrix3},anisotropyVector:{value:new Vector2},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Matrix3}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};const _rgb={r:0,b:0,g:0},_e1$1=new Euler,_m1$1=new Matrix4;function WebGLBackground(st,at,pt,vt,wt,$t,Tt){const Lt=new Color$1(0);let Ft=$t===!0?0:1,Ct,Ht,Gt=null,jt=0,qt=null;function Kt(Sn,wn){let In=!1,tr=wn.isScene===!0?wn.background:null;tr&&tr.isTexture&&(tr=(wn.backgroundBlurriness>0?pt:at).get(tr)),tr===null?An(Lt,Ft):tr&&tr.isColor&&(An(tr,1),In=!0);const rr=st.xr.getEnvironmentBlendMode();rr==="additive"?vt.buffers.color.setClear(0,0,0,1,Tt):rr==="alpha-blend"&&vt.buffers.color.setClear(0,0,0,0,Tt),(st.autoClear||In)&&st.clear(st.autoClearColor,st.autoClearDepth,st.autoClearStencil),tr&&(tr.isCubeTexture||tr.mapping===CubeUVReflectionMapping)?(Ht===void 0&&(Ht=new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({name:"BackgroundCubeMaterial",uniforms:cloneUniforms(ShaderLib.backgroundCube.uniforms),vertexShader:ShaderLib.backgroundCube.vertexShader,fragmentShader:ShaderLib.backgroundCube.fragmentShader,side:BackSide,depthTest:!1,depthWrite:!1,fog:!1})),Ht.geometry.deleteAttribute("normal"),Ht.geometry.deleteAttribute("uv"),Ht.onBeforeRender=function(Hr,qr,Zr){this.matrixWorld.copyPosition(Zr.matrixWorld)},Object.defineProperty(Ht.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),wt.update(Ht)),_e1$1.copy(wn.backgroundRotation),_e1$1.x*=-1,_e1$1.y*=-1,_e1$1.z*=-1,tr.isCubeTexture&&tr.isRenderTargetTexture===!1&&(_e1$1.y*=-1,_e1$1.z*=-1),Ht.material.uniforms.envMap.value=tr,Ht.material.uniforms.flipEnvMap.value=tr.isCubeTexture&&tr.isRenderTargetTexture===!1?-1:1,Ht.material.uniforms.backgroundBlurriness.value=wn.backgroundBlurriness,Ht.material.uniforms.backgroundIntensity.value=wn.backgroundIntensity,Ht.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1)),Ht.material.toneMapped=ColorManagement.getTransfer(tr.colorSpace)!==SRGBTransfer,(Gt!==tr||jt!==tr.version||qt!==st.toneMapping)&&(Ht.material.needsUpdate=!0,Gt=tr,jt=tr.version,qt=st.toneMapping),Ht.layers.enableAll(),Sn.unshift(Ht,Ht.geometry,Ht.material,0,0,null)):tr&&tr.isTexture&&(Ct===void 0&&(Ct=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:"BackgroundMaterial",uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:FrontSide,depthTest:!1,depthWrite:!1,fog:!1})),Ct.geometry.deleteAttribute("normal"),Object.defineProperty(Ct.material,"map",{get:function(){return this.uniforms.t2D.value}}),wt.update(Ct)),Ct.material.uniforms.t2D.value=tr,Ct.material.uniforms.backgroundIntensity.value=wn.backgroundIntensity,Ct.material.toneMapped=ColorManagement.getTransfer(tr.colorSpace)!==SRGBTransfer,tr.matrixAutoUpdate===!0&&tr.updateMatrix(),Ct.material.uniforms.uvTransform.value.copy(tr.matrix),(Gt!==tr||jt!==tr.version||qt!==st.toneMapping)&&(Ct.material.needsUpdate=!0,Gt=tr,jt=tr.version,qt=st.toneMapping),Ct.layers.enableAll(),Sn.unshift(Ct,Ct.geometry,Ct.material,0,0,null))}function An(Sn,wn){Sn.getRGB(_rgb,getUnlitUniformColorSpace(st)),vt.buffers.color.setClear(_rgb.r,_rgb.g,_rgb.b,wn,Tt)}return{getClearColor:function(){return Lt},setClearColor:function(Sn,wn=1){Lt.set(Sn),Ft=wn,An(Lt,Ft)},getClearAlpha:function(){return Ft},setClearAlpha:function(Sn){Ft=Sn,An(Lt,Ft)},render:Kt}}function WebGLBindingStates(st,at,pt,vt){const wt=st.getParameter(st.MAX_VERTEX_ATTRIBS),$t=vt.isWebGL2?null:at.get("OES_vertex_array_object"),Tt=vt.isWebGL2||$t!==null,Lt={},Ft=Sn(null);let Ct=Ft,Ht=!1;function Gt(l0,T0,t0,E0,n0){let m0=!1;if(Tt){const h0=An(E0,t0,T0);Ct!==h0&&(Ct=h0,qt(Ct.object)),m0=wn(l0,E0,t0,n0),m0&&In(l0,E0,t0,n0)}else{const h0=T0.wireframe===!0;(Ct.geometry!==E0.id||Ct.program!==t0.id||Ct.wireframe!==h0)&&(Ct.geometry=E0.id,Ct.program=t0.id,Ct.wireframe=h0,m0=!0)}n0!==null&&pt.update(n0,st.ELEMENT_ARRAY_BUFFER),(m0||Ht)&&(Ht=!1,Bo(l0,T0,t0,E0),n0!==null&&st.bindBuffer(st.ELEMENT_ARRAY_BUFFER,pt.get(n0).buffer))}function jt(){return vt.isWebGL2?st.createVertexArray():$t.createVertexArrayOES()}function qt(l0){return vt.isWebGL2?st.bindVertexArray(l0):$t.bindVertexArrayOES(l0)}function Kt(l0){return vt.isWebGL2?st.deleteVertexArray(l0):$t.deleteVertexArrayOES(l0)}function An(l0,T0,t0){const E0=t0.wireframe===!0;let n0=Lt[l0.id];n0===void 0&&(n0={},Lt[l0.id]=n0);let m0=n0[T0.id];m0===void 0&&(m0={},n0[T0.id]=m0);let h0=m0[E0];return h0===void 0&&(h0=Sn(jt()),m0[E0]=h0),h0}function Sn(l0){const T0=[],t0=[],E0=[];for(let n0=0;n0<wt;n0++)T0[n0]=0,t0[n0]=0,E0[n0]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:T0,enabledAttributes:t0,attributeDivisors:E0,object:l0,attributes:{},index:null}}function wn(l0,T0,t0,E0){const n0=Ct.attributes,m0=T0.attributes;let h0=0;const a0=t0.getAttributes();for(const P0 in a0)if(a0[P0].location>=0){const B0=n0[P0];let W0=m0[P0];if(W0===void 0&&(P0==="instanceMatrix"&&l0.instanceMatrix&&(W0=l0.instanceMatrix),P0==="instanceColor"&&l0.instanceColor&&(W0=l0.instanceColor)),B0===void 0||B0.attribute!==W0||W0&&B0.data!==W0.data)return!0;h0++}return Ct.attributesNum!==h0||Ct.index!==E0}function In(l0,T0,t0,E0){const n0={},m0=T0.attributes;let h0=0;const a0=t0.getAttributes();for(const P0 in a0)if(a0[P0].location>=0){let B0=m0[P0];B0===void 0&&(P0==="instanceMatrix"&&l0.instanceMatrix&&(B0=l0.instanceMatrix),P0==="instanceColor"&&l0.instanceColor&&(B0=l0.instanceColor));const W0={};W0.attribute=B0,B0&&B0.data&&(W0.data=B0.data),n0[P0]=W0,h0++}Ct.attributes=n0,Ct.attributesNum=h0,Ct.index=E0}function tr(){const l0=Ct.newAttributes;for(let T0=0,t0=l0.length;T0<t0;T0++)l0[T0]=0}function rr(l0){Hr(l0,0)}function Hr(l0,T0){const t0=Ct.newAttributes,E0=Ct.enabledAttributes,n0=Ct.attributeDivisors;t0[l0]=1,E0[l0]===0&&(st.enableVertexAttribArray(l0),E0[l0]=1),n0[l0]!==T0&&((vt.isWebGL2?st:at.get("ANGLE_instanced_arrays"))[vt.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](l0,T0),n0[l0]=T0)}function qr(){const l0=Ct.newAttributes,T0=Ct.enabledAttributes;for(let t0=0,E0=T0.length;t0<E0;t0++)T0[t0]!==l0[t0]&&(st.disableVertexAttribArray(t0),T0[t0]=0)}function Zr(l0,T0,t0,E0,n0,m0,h0){h0===!0?st.vertexAttribIPointer(l0,T0,t0,n0,m0):st.vertexAttribPointer(l0,T0,t0,E0,n0,m0)}function Bo(l0,T0,t0,E0){if(vt.isWebGL2===!1&&(l0.isInstancedMesh||E0.isInstancedBufferGeometry)&&at.get("ANGLE_instanced_arrays")===null)return;tr();const n0=E0.attributes,m0=t0.getAttributes(),h0=T0.defaultAttributeValues;for(const a0 in m0){const P0=m0[a0];if(P0.location>=0){let V0=n0[a0];if(V0===void 0&&(a0==="instanceMatrix"&&l0.instanceMatrix&&(V0=l0.instanceMatrix),a0==="instanceColor"&&l0.instanceColor&&(V0=l0.instanceColor)),V0!==void 0){const B0=V0.normalized,W0=V0.itemSize,K0=pt.get(V0);if(K0===void 0)continue;const Ty=K0.buffer,$y=K0.type,My=K0.bytesPerElement,Wy=vt.isWebGL2===!0&&($y===st.INT||$y===st.UNSIGNED_INT||V0.gpuType===IntType);if(V0.isInterleavedBufferAttribute){const Ey=V0.data,_0=Ey.stride,ay=V0.offset;if(Ey.isInstancedInterleavedBuffer){for(let J0=0;J0<P0.locationSize;J0++)Hr(P0.location+J0,Ey.meshPerAttribute);l0.isInstancedMesh!==!0&&E0._maxInstanceCount===void 0&&(E0._maxInstanceCount=Ey.meshPerAttribute*Ey.count)}else for(let J0=0;J0<P0.locationSize;J0++)rr(P0.location+J0);st.bindBuffer(st.ARRAY_BUFFER,Ty);for(let J0=0;J0<P0.locationSize;J0++)Zr(P0.location+J0,W0/P0.locationSize,$y,B0,_0*My,(ay+W0/P0.locationSize*J0)*My,Wy)}else{if(V0.isInstancedBufferAttribute){for(let Ey=0;Ey<P0.locationSize;Ey++)Hr(P0.location+Ey,V0.meshPerAttribute);l0.isInstancedMesh!==!0&&E0._maxInstanceCount===void 0&&(E0._maxInstanceCount=V0.meshPerAttribute*V0.count)}else for(let Ey=0;Ey<P0.locationSize;Ey++)rr(P0.location+Ey);st.bindBuffer(st.ARRAY_BUFFER,Ty);for(let Ey=0;Ey<P0.locationSize;Ey++)Zr(P0.location+Ey,W0/P0.locationSize,$y,B0,W0*My,W0/P0.locationSize*Ey*My,Wy)}}else if(h0!==void 0){const B0=h0[a0];if(B0!==void 0)switch(B0.length){case 2:st.vertexAttrib2fv(P0.location,B0);break;case 3:st.vertexAttrib3fv(P0.location,B0);break;case 4:st.vertexAttrib4fv(P0.location,B0);break;default:st.vertexAttrib1fv(P0.location,B0)}}}}qr()}function Xo(){f0();for(const l0 in Lt){const T0=Lt[l0];for(const t0 in T0){const E0=T0[t0];for(const n0 in E0)Kt(E0[n0].object),delete E0[n0];delete T0[t0]}delete Lt[l0]}}function Kr(l0){if(Lt[l0.id]===void 0)return;const T0=Lt[l0.id];for(const t0 in T0){const E0=T0[t0];for(const n0 in E0)Kt(E0[n0].object),delete E0[n0];delete T0[t0]}delete Lt[l0.id]}function ko(l0){for(const T0 in Lt){const t0=Lt[T0];if(t0[l0.id]===void 0)continue;const E0=t0[l0.id];for(const n0 in E0)Kt(E0[n0].object),delete E0[n0];delete t0[l0.id]}}function f0(){x0(),Ht=!0,Ct!==Ft&&(Ct=Ft,qt(Ct.object))}function x0(){Ft.geometry=null,Ft.program=null,Ft.wireframe=!1}return{setup:Gt,reset:f0,resetDefaultState:x0,dispose:Xo,releaseStatesOfGeometry:Kr,releaseStatesOfProgram:ko,initAttributes:tr,enableAttribute:rr,disableUnusedAttributes:qr}}function WebGLBufferRenderer(st,at,pt,vt){const wt=vt.isWebGL2;let $t;function Tt(Ht){$t=Ht}function Lt(Ht,Gt){st.drawArrays($t,Ht,Gt),pt.update(Gt,$t,1)}function Ft(Ht,Gt,jt){if(jt===0)return;let qt,Kt;if(wt)qt=st,Kt="drawArraysInstanced";else if(qt=at.get("ANGLE_instanced_arrays"),Kt="drawArraysInstancedANGLE",qt===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}qt[Kt]($t,Ht,Gt,jt),pt.update(Gt,$t,jt)}function Ct(Ht,Gt,jt){if(jt===0)return;const qt=at.get("WEBGL_multi_draw");if(qt===null)for(let Kt=0;Kt<jt;Kt++)this.render(Ht[Kt],Gt[Kt]);else{qt.multiDrawArraysWEBGL($t,Ht,0,Gt,0,jt);let Kt=0;for(let An=0;An<jt;An++)Kt+=Gt[An];pt.update(Kt,$t,1)}}this.setMode=Tt,this.render=Lt,this.renderInstances=Ft,this.renderMultiDraw=Ct}function WebGLCapabilities(st,at,pt){let vt;function wt(){if(vt!==void 0)return vt;if(at.has("EXT_texture_filter_anisotropic")===!0){const Zr=at.get("EXT_texture_filter_anisotropic");vt=st.getParameter(Zr.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else vt=0;return vt}function $t(Zr){if(Zr==="highp"){if(st.getShaderPrecisionFormat(st.VERTEX_SHADER,st.HIGH_FLOAT).precision>0&&st.getShaderPrecisionFormat(st.FRAGMENT_SHADER,st.HIGH_FLOAT).precision>0)return"highp";Zr="mediump"}return Zr==="mediump"&&st.getShaderPrecisionFormat(st.VERTEX_SHADER,st.MEDIUM_FLOAT).precision>0&&st.getShaderPrecisionFormat(st.FRAGMENT_SHADER,st.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const Tt=typeof WebGL2RenderingContext<"u"&&st.constructor.name==="WebGL2RenderingContext";let Lt=pt.precision!==void 0?pt.precision:"highp";const Ft=$t(Lt);Ft!==Lt&&(console.warn("THREE.WebGLRenderer:",Lt,"not supported, using",Ft,"instead."),Lt=Ft);const Ct=Tt||at.has("WEBGL_draw_buffers"),Ht=pt.logarithmicDepthBuffer===!0,Gt=st.getParameter(st.MAX_TEXTURE_IMAGE_UNITS),jt=st.getParameter(st.MAX_VERTEX_TEXTURE_IMAGE_UNITS),qt=st.getParameter(st.MAX_TEXTURE_SIZE),Kt=st.getParameter(st.MAX_CUBE_MAP_TEXTURE_SIZE),An=st.getParameter(st.MAX_VERTEX_ATTRIBS),Sn=st.getParameter(st.MAX_VERTEX_UNIFORM_VECTORS),wn=st.getParameter(st.MAX_VARYING_VECTORS),In=st.getParameter(st.MAX_FRAGMENT_UNIFORM_VECTORS),tr=jt>0,rr=Tt||at.has("OES_texture_float"),Hr=tr&&rr,qr=Tt?st.getParameter(st.MAX_SAMPLES):0;return{isWebGL2:Tt,drawBuffers:Ct,getMaxAnisotropy:wt,getMaxPrecision:$t,precision:Lt,logarithmicDepthBuffer:Ht,maxTextures:Gt,maxVertexTextures:jt,maxTextureSize:qt,maxCubemapSize:Kt,maxAttributes:An,maxVertexUniforms:Sn,maxVaryings:wn,maxFragmentUniforms:In,vertexTextures:tr,floatFragmentTextures:rr,floatVertexTextures:Hr,maxSamples:qr}}function WebGLClipping(st){const at=this;let pt=null,vt=0,wt=!1,$t=!1;const Tt=new Plane,Lt=new Matrix3,Ft={value:null,needsUpdate:!1};this.uniform=Ft,this.numPlanes=0,this.numIntersection=0,this.init=function(Gt,jt){const qt=Gt.length!==0||jt||vt!==0||wt;return wt=jt,vt=Gt.length,qt},this.beginShadows=function(){$t=!0,Ht(null)},this.endShadows=function(){$t=!1},this.setGlobalState=function(Gt,jt){pt=Ht(Gt,jt,0)},this.setState=function(Gt,jt,qt){const Kt=Gt.clippingPlanes,An=Gt.clipIntersection,Sn=Gt.clipShadows,wn=st.get(Gt);if(!wt||Kt===null||Kt.length===0||$t&&!Sn)$t?Ht(null):Ct();else{const In=$t?0:vt,tr=In*4;let rr=wn.clippingState||null;Ft.value=rr,rr=Ht(Kt,jt,tr,qt);for(let Hr=0;Hr!==tr;++Hr)rr[Hr]=pt[Hr];wn.clippingState=rr,this.numIntersection=An?this.numPlanes:0,this.numPlanes+=In}};function Ct(){Ft.value!==pt&&(Ft.value=pt,Ft.needsUpdate=vt>0),at.numPlanes=vt,at.numIntersection=0}function Ht(Gt,jt,qt,Kt){const An=Gt!==null?Gt.length:0;let Sn=null;if(An!==0){if(Sn=Ft.value,Kt!==!0||Sn===null){const wn=qt+An*4,In=jt.matrixWorldInverse;Lt.getNormalMatrix(In),(Sn===null||Sn.length<wn)&&(Sn=new Float32Array(wn));for(let tr=0,rr=qt;tr!==An;++tr,rr+=4)Tt.copy(Gt[tr]).applyMatrix4(In,Lt),Tt.normal.toArray(Sn,rr),Sn[rr+3]=Tt.constant}Ft.value=Sn,Ft.needsUpdate=!0}return at.numPlanes=An,at.numIntersection=0,Sn}}function WebGLCubeMaps(st){let at=new WeakMap;function pt(Tt,Lt){return Lt===EquirectangularReflectionMapping?Tt.mapping=CubeReflectionMapping:Lt===EquirectangularRefractionMapping&&(Tt.mapping=CubeRefractionMapping),Tt}function vt(Tt){if(Tt&&Tt.isTexture){const Lt=Tt.mapping;if(Lt===EquirectangularReflectionMapping||Lt===EquirectangularRefractionMapping)if(at.has(Tt)){const Ft=at.get(Tt).texture;return pt(Ft,Tt.mapping)}else{const Ft=Tt.image;if(Ft&&Ft.height>0){const Ct=new WebGLCubeRenderTarget(Ft.height);return Ct.fromEquirectangularTexture(st,Tt),at.set(Tt,Ct),Tt.addEventListener("dispose",wt),pt(Ct.texture,Tt.mapping)}else return null}}return Tt}function wt(Tt){const Lt=Tt.target;Lt.removeEventListener("dispose",wt);const Ft=at.get(Lt);Ft!==void 0&&(at.delete(Lt),Ft.dispose())}function $t(){at=new WeakMap}return{get:vt,dispose:$t}}class OrthographicCamera extends Camera{constructor(at=-1,pt=1,vt=1,wt=-1,$t=.1,Tt=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=at,this.right=pt,this.top=vt,this.bottom=wt,this.near=$t,this.far=Tt,this.updateProjectionMatrix()}copy(at,pt){return super.copy(at,pt),this.left=at.left,this.right=at.right,this.top=at.top,this.bottom=at.bottom,this.near=at.near,this.far=at.far,this.zoom=at.zoom,this.view=at.view===null?null:Object.assign({},at.view),this}setViewOffset(at,pt,vt,wt,$t,Tt){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=at,this.view.fullHeight=pt,this.view.offsetX=vt,this.view.offsetY=wt,this.view.width=$t,this.view.height=Tt,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const at=(this.right-this.left)/(2*this.zoom),pt=(this.top-this.bottom)/(2*this.zoom),vt=(this.right+this.left)/2,wt=(this.top+this.bottom)/2;let $t=vt-at,Tt=vt+at,Lt=wt+pt,Ft=wt-pt;if(this.view!==null&&this.view.enabled){const Ct=(this.right-this.left)/this.view.fullWidth/this.zoom,Ht=(this.top-this.bottom)/this.view.fullHeight/this.zoom;$t+=Ct*this.view.offsetX,Tt=$t+Ct*this.view.width,Lt-=Ht*this.view.offsetY,Ft=Lt-Ht*this.view.height}this.projectionMatrix.makeOrthographic($t,Tt,Lt,Ft,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(at){const pt=super.toJSON(at);return pt.object.zoom=this.zoom,pt.object.left=this.left,pt.object.right=this.right,pt.object.top=this.top,pt.object.bottom=this.bottom,pt.object.near=this.near,pt.object.far=this.far,this.view!==null&&(pt.object.view=Object.assign({},this.view)),pt}}const LOD_MIN=4,EXTRA_LOD_SIGMA=[.125,.215,.35,.446,.526,.582],MAX_SAMPLES=20,_flatCamera=new OrthographicCamera,_clearColor=new Color$1;let _oldTarget=null,_oldActiveCubeFace=0,_oldActiveMipmapLevel=0;const PHI=(1+Math.sqrt(5))/2,INV_PHI=1/PHI,_axisDirections=[new Vector3(1,1,1),new Vector3(-1,1,1),new Vector3(1,1,-1),new Vector3(-1,1,-1),new Vector3(0,PHI,INV_PHI),new Vector3(0,PHI,-INV_PHI),new Vector3(INV_PHI,0,PHI),new Vector3(-INV_PHI,0,PHI),new Vector3(PHI,INV_PHI,0),new Vector3(-PHI,INV_PHI,0)];class PMREMGenerator{constructor(at){this._renderer=at,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(at,pt=0,vt=.1,wt=100){_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel(),this._setSize(256);const $t=this._allocateTargets();return $t.depthBuffer=!0,this._sceneToCubeUV(at,vt,wt,$t),pt>0&&this._blur($t,0,0,pt),this._applyPMREM($t),this._cleanup($t),$t}fromEquirectangular(at,pt=null){return this._fromTexture(at,pt)}fromCubemap(at,pt=null){return this._fromTexture(at,pt)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=_getCubemapMaterial(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=_getEquirectMaterial(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(at){this._lodMax=Math.floor(Math.log2(at)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let at=0;at<this._lodPlanes.length;at++)this._lodPlanes[at].dispose()}_cleanup(at){this._renderer.setRenderTarget(_oldTarget,_oldActiveCubeFace,_oldActiveMipmapLevel),at.scissorTest=!1,_setViewport(at,0,0,at.width,at.height)}_fromTexture(at,pt){at.mapping===CubeReflectionMapping||at.mapping===CubeRefractionMapping?this._setSize(at.image.length===0?16:at.image[0].width||at.image[0].image.width):this._setSize(at.image.width/4),_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel();const vt=pt||this._allocateTargets();return this._textureToCubeUV(at,vt),this._applyPMREM(vt),this._cleanup(vt),vt}_allocateTargets(){const at=3*Math.max(this._cubeSize,112),pt=4*this._cubeSize,vt={magFilter:LinearFilter,minFilter:LinearFilter,generateMipmaps:!1,type:HalfFloatType,format:RGBAFormat,colorSpace:LinearSRGBColorSpace$1,depthBuffer:!1},wt=_createRenderTarget(at,pt,vt);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==at||this._pingPongRenderTarget.height!==pt){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=_createRenderTarget(at,pt,vt);const{_lodMax:$t}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=_createPlanes($t)),this._blurMaterial=_getBlurShader($t,at,pt)}return wt}_compileMaterial(at){const pt=new Mesh(this._lodPlanes[0],at);this._renderer.compile(pt,_flatCamera)}_sceneToCubeUV(at,pt,vt,wt){const Lt=new PerspectiveCamera(90,1,pt,vt),Ft=[1,-1,1,1,1,1],Ct=[1,1,1,-1,-1,-1],Ht=this._renderer,Gt=Ht.autoClear,jt=Ht.toneMapping;Ht.getClearColor(_clearColor),Ht.toneMapping=NoToneMapping,Ht.autoClear=!1;const qt=new MeshBasicMaterial({name:"PMREM.Background",side:BackSide,depthWrite:!1,depthTest:!1}),Kt=new Mesh(new BoxGeometry,qt);let An=!1;const Sn=at.background;Sn?Sn.isColor&&(qt.color.copy(Sn),at.background=null,An=!0):(qt.color.copy(_clearColor),An=!0);for(let wn=0;wn<6;wn++){const In=wn%3;In===0?(Lt.up.set(0,Ft[wn],0),Lt.lookAt(Ct[wn],0,0)):In===1?(Lt.up.set(0,0,Ft[wn]),Lt.lookAt(0,Ct[wn],0)):(Lt.up.set(0,Ft[wn],0),Lt.lookAt(0,0,Ct[wn]));const tr=this._cubeSize;_setViewport(wt,In*tr,wn>2?tr:0,tr,tr),Ht.setRenderTarget(wt),An&&Ht.render(Kt,Lt),Ht.render(at,Lt)}Kt.geometry.dispose(),Kt.material.dispose(),Ht.toneMapping=jt,Ht.autoClear=Gt,at.background=Sn}_textureToCubeUV(at,pt){const vt=this._renderer,wt=at.mapping===CubeReflectionMapping||at.mapping===CubeRefractionMapping;wt?(this._cubemapMaterial===null&&(this._cubemapMaterial=_getCubemapMaterial()),this._cubemapMaterial.uniforms.flipEnvMap.value=at.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=_getEquirectMaterial());const $t=wt?this._cubemapMaterial:this._equirectMaterial,Tt=new Mesh(this._lodPlanes[0],$t),Lt=$t.uniforms;Lt.envMap.value=at;const Ft=this._cubeSize;_setViewport(pt,0,0,3*Ft,2*Ft),vt.setRenderTarget(pt),vt.render(Tt,_flatCamera)}_applyPMREM(at){const pt=this._renderer,vt=pt.autoClear;pt.autoClear=!1;for(let wt=1;wt<this._lodPlanes.length;wt++){const $t=Math.sqrt(this._sigmas[wt]*this._sigmas[wt]-this._sigmas[wt-1]*this._sigmas[wt-1]),Tt=_axisDirections[(wt-1)%_axisDirections.length];this._blur(at,wt-1,wt,$t,Tt)}pt.autoClear=vt}_blur(at,pt,vt,wt,$t){const Tt=this._pingPongRenderTarget;this._halfBlur(at,Tt,pt,vt,wt,"latitudinal",$t),this._halfBlur(Tt,at,vt,vt,wt,"longitudinal",$t)}_halfBlur(at,pt,vt,wt,$t,Tt,Lt){const Ft=this._renderer,Ct=this._blurMaterial;Tt!=="latitudinal"&&Tt!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const Ht=3,Gt=new Mesh(this._lodPlanes[wt],Ct),jt=Ct.uniforms,qt=this._sizeLods[vt]-1,Kt=isFinite($t)?Math.PI/(2*qt):2*Math.PI/(2*MAX_SAMPLES-1),An=$t/Kt,Sn=isFinite($t)?1+Math.floor(Ht*An):MAX_SAMPLES;Sn>MAX_SAMPLES&&console.warn(`sigmaRadians, ${$t}, is too large and will clip, as it requested ${Sn} samples when the maximum is set to ${MAX_SAMPLES}`);const wn=[];let In=0;for(let Zr=0;Zr<MAX_SAMPLES;++Zr){const Bo=Zr/An,Xo=Math.exp(-Bo*Bo/2);wn.push(Xo),Zr===0?In+=Xo:Zr<Sn&&(In+=2*Xo)}for(let Zr=0;Zr<wn.length;Zr++)wn[Zr]=wn[Zr]/In;jt.envMap.value=at.texture,jt.samples.value=Sn,jt.weights.value=wn,jt.latitudinal.value=Tt==="latitudinal",Lt&&(jt.poleAxis.value=Lt);const{_lodMax:tr}=this;jt.dTheta.value=Kt,jt.mipInt.value=tr-vt;const rr=this._sizeLods[wt],Hr=3*rr*(wt>tr-LOD_MIN?wt-tr+LOD_MIN:0),qr=4*(this._cubeSize-rr);_setViewport(pt,Hr,qr,3*rr,2*rr),Ft.setRenderTarget(pt),Ft.render(Gt,_flatCamera)}}function _createPlanes(st){const at=[],pt=[],vt=[];let wt=st;const $t=st-LOD_MIN+1+EXTRA_LOD_SIGMA.length;for(let Tt=0;Tt<$t;Tt++){const Lt=Math.pow(2,wt);pt.push(Lt);let Ft=1/Lt;Tt>st-LOD_MIN?Ft=EXTRA_LOD_SIGMA[Tt-st+LOD_MIN-1]:Tt===0&&(Ft=0),vt.push(Ft);const Ct=1/(Lt-2),Ht=-Ct,Gt=1+Ct,jt=[Ht,Ht,Gt,Ht,Gt,Gt,Ht,Ht,Gt,Gt,Ht,Gt],qt=6,Kt=6,An=3,Sn=2,wn=1,In=new Float32Array(An*Kt*qt),tr=new Float32Array(Sn*Kt*qt),rr=new Float32Array(wn*Kt*qt);for(let qr=0;qr<qt;qr++){const Zr=qr%3*2/3-1,Bo=qr>2?0:-1,Xo=[Zr,Bo,0,Zr+2/3,Bo,0,Zr+2/3,Bo+1,0,Zr,Bo,0,Zr+2/3,Bo+1,0,Zr,Bo+1,0];In.set(Xo,An*Kt*qr),tr.set(jt,Sn*Kt*qr);const Kr=[qr,qr,qr,qr,qr,qr];rr.set(Kr,wn*Kt*qr)}const Hr=new BufferGeometry;Hr.setAttribute("position",new BufferAttribute(In,An)),Hr.setAttribute("uv",new BufferAttribute(tr,Sn)),Hr.setAttribute("faceIndex",new BufferAttribute(rr,wn)),at.push(Hr),wt>LOD_MIN&&wt--}return{lodPlanes:at,sizeLods:pt,sigmas:vt}}function _createRenderTarget(st,at,pt){const vt=new WebGLRenderTarget(st,at,pt);return vt.texture.mapping=CubeUVReflectionMapping,vt.texture.name="PMREM.cubeUv",vt.scissorTest=!0,vt}function _setViewport(st,at,pt,vt,wt){st.viewport.set(at,pt,vt,wt),st.scissor.set(at,pt,vt,wt)}function _getBlurShader(st,at,pt){const vt=new Float32Array(MAX_SAMPLES),wt=new Vector3(0,1,0);return new ShaderMaterial({name:"SphericalGaussianBlur",defines:{n:MAX_SAMPLES,CUBEUV_TEXEL_WIDTH:1/at,CUBEUV_TEXEL_HEIGHT:1/pt,CUBEUV_MAX_MIP:`${st}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:vt},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:wt}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getEquirectMaterial(){return new ShaderMaterial({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getCubemapMaterial(){return new ShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getCommonVertexShader(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function WebGLCubeUVMaps(st){let at=new WeakMap,pt=null;function vt(Lt){if(Lt&&Lt.isTexture){const Ft=Lt.mapping,Ct=Ft===EquirectangularReflectionMapping||Ft===EquirectangularRefractionMapping,Ht=Ft===CubeReflectionMapping||Ft===CubeRefractionMapping;if(Ct||Ht)if(Lt.isRenderTargetTexture&&Lt.needsPMREMUpdate===!0){Lt.needsPMREMUpdate=!1;let Gt=at.get(Lt);return pt===null&&(pt=new PMREMGenerator(st)),Gt=Ct?pt.fromEquirectangular(Lt,Gt):pt.fromCubemap(Lt,Gt),at.set(Lt,Gt),Gt.texture}else{if(at.has(Lt))return at.get(Lt).texture;{const Gt=Lt.image;if(Ct&&Gt&&Gt.height>0||Ht&&Gt&&wt(Gt)){pt===null&&(pt=new PMREMGenerator(st));const jt=Ct?pt.fromEquirectangular(Lt):pt.fromCubemap(Lt);return at.set(Lt,jt),Lt.addEventListener("dispose",$t),jt.texture}else return null}}}return Lt}function wt(Lt){let Ft=0;const Ct=6;for(let Ht=0;Ht<Ct;Ht++)Lt[Ht]!==void 0&&Ft++;return Ft===Ct}function $t(Lt){const Ft=Lt.target;Ft.removeEventListener("dispose",$t);const Ct=at.get(Ft);Ct!==void 0&&(at.delete(Ft),Ct.dispose())}function Tt(){at=new WeakMap,pt!==null&&(pt.dispose(),pt=null)}return{get:vt,dispose:Tt}}function WebGLExtensions(st){const at={};function pt(vt){if(at[vt]!==void 0)return at[vt];let wt;switch(vt){case"WEBGL_depth_texture":wt=st.getExtension("WEBGL_depth_texture")||st.getExtension("MOZ_WEBGL_depth_texture")||st.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":wt=st.getExtension("EXT_texture_filter_anisotropic")||st.getExtension("MOZ_EXT_texture_filter_anisotropic")||st.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":wt=st.getExtension("WEBGL_compressed_texture_s3tc")||st.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||st.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":wt=st.getExtension("WEBGL_compressed_texture_pvrtc")||st.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:wt=st.getExtension(vt)}return at[vt]=wt,wt}return{has:function(vt){return pt(vt)!==null},init:function(vt){vt.isWebGL2?(pt("EXT_color_buffer_float"),pt("WEBGL_clip_cull_distance")):(pt("WEBGL_depth_texture"),pt("OES_texture_float"),pt("OES_texture_half_float"),pt("OES_texture_half_float_linear"),pt("OES_standard_derivatives"),pt("OES_element_index_uint"),pt("OES_vertex_array_object"),pt("ANGLE_instanced_arrays")),pt("OES_texture_float_linear"),pt("EXT_color_buffer_half_float"),pt("WEBGL_multisampled_render_to_texture")},get:function(vt){const wt=pt(vt);return wt===null&&console.warn("THREE.WebGLRenderer: "+vt+" extension not supported."),wt}}}function WebGLGeometries(st,at,pt,vt){const wt={},$t=new WeakMap;function Tt(Gt){const jt=Gt.target;jt.index!==null&&at.remove(jt.index);for(const Kt in jt.attributes)at.remove(jt.attributes[Kt]);for(const Kt in jt.morphAttributes){const An=jt.morphAttributes[Kt];for(let Sn=0,wn=An.length;Sn<wn;Sn++)at.remove(An[Sn])}jt.removeEventListener("dispose",Tt),delete wt[jt.id];const qt=$t.get(jt);qt&&(at.remove(qt),$t.delete(jt)),vt.releaseStatesOfGeometry(jt),jt.isInstancedBufferGeometry===!0&&delete jt._maxInstanceCount,pt.memory.geometries--}function Lt(Gt,jt){return wt[jt.id]===!0||(jt.addEventListener("dispose",Tt),wt[jt.id]=!0,pt.memory.geometries++),jt}function Ft(Gt){const jt=Gt.attributes;for(const Kt in jt)at.update(jt[Kt],st.ARRAY_BUFFER);const qt=Gt.morphAttributes;for(const Kt in qt){const An=qt[Kt];for(let Sn=0,wn=An.length;Sn<wn;Sn++)at.update(An[Sn],st.ARRAY_BUFFER)}}function Ct(Gt){const jt=[],qt=Gt.index,Kt=Gt.attributes.position;let An=0;if(qt!==null){const In=qt.array;An=qt.version;for(let tr=0,rr=In.length;tr<rr;tr+=3){const Hr=In[tr+0],qr=In[tr+1],Zr=In[tr+2];jt.push(Hr,qr,qr,Zr,Zr,Hr)}}else if(Kt!==void 0){const In=Kt.array;An=Kt.version;for(let tr=0,rr=In.length/3-1;tr<rr;tr+=3){const Hr=tr+0,qr=tr+1,Zr=tr+2;jt.push(Hr,qr,qr,Zr,Zr,Hr)}}else return;const Sn=new(arrayNeedsUint32(jt)?Uint32BufferAttribute:Uint16BufferAttribute)(jt,1);Sn.version=An;const wn=$t.get(Gt);wn&&at.remove(wn),$t.set(Gt,Sn)}function Ht(Gt){const jt=$t.get(Gt);if(jt){const qt=Gt.index;qt!==null&&jt.version<qt.version&&Ct(Gt)}else Ct(Gt);return $t.get(Gt)}return{get:Lt,update:Ft,getWireframeAttribute:Ht}}function WebGLIndexedBufferRenderer(st,at,pt,vt){const wt=vt.isWebGL2;let $t;function Tt(qt){$t=qt}let Lt,Ft;function Ct(qt){Lt=qt.type,Ft=qt.bytesPerElement}function Ht(qt,Kt){st.drawElements($t,Kt,Lt,qt*Ft),pt.update(Kt,$t,1)}function Gt(qt,Kt,An){if(An===0)return;let Sn,wn;if(wt)Sn=st,wn="drawElementsInstanced";else if(Sn=at.get("ANGLE_instanced_arrays"),wn="drawElementsInstancedANGLE",Sn===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}Sn[wn]($t,Kt,Lt,qt*Ft,An),pt.update(Kt,$t,An)}function jt(qt,Kt,An){if(An===0)return;const Sn=at.get("WEBGL_multi_draw");if(Sn===null)for(let wn=0;wn<An;wn++)this.render(qt[wn]/Ft,Kt[wn]);else{Sn.multiDrawElementsWEBGL($t,Kt,0,Lt,qt,0,An);let wn=0;for(let In=0;In<An;In++)wn+=Kt[In];pt.update(wn,$t,1)}}this.setMode=Tt,this.setIndex=Ct,this.render=Ht,this.renderInstances=Gt,this.renderMultiDraw=jt}function WebGLInfo(st){const at={geometries:0,textures:0},pt={frame:0,calls:0,triangles:0,points:0,lines:0};function vt($t,Tt,Lt){switch(pt.calls++,Tt){case st.TRIANGLES:pt.triangles+=Lt*($t/3);break;case st.LINES:pt.lines+=Lt*($t/2);break;case st.LINE_STRIP:pt.lines+=Lt*($t-1);break;case st.LINE_LOOP:pt.lines+=Lt*$t;break;case st.POINTS:pt.points+=Lt*$t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",Tt);break}}function wt(){pt.calls=0,pt.triangles=0,pt.points=0,pt.lines=0}return{memory:at,render:pt,programs:null,autoReset:!0,reset:wt,update:vt}}function numericalSort(st,at){return st[0]-at[0]}function absNumericalSort(st,at){return Math.abs(at[1])-Math.abs(st[1])}function WebGLMorphtargets(st,at,pt){const vt={},wt=new Float32Array(8),$t=new WeakMap,Tt=new Vector4,Lt=[];for(let Ct=0;Ct<8;Ct++)Lt[Ct]=[Ct,0];function Ft(Ct,Ht,Gt){const jt=Ct.morphTargetInfluences;if(at.isWebGL2===!0){const Kt=Ht.morphAttributes.position||Ht.morphAttributes.normal||Ht.morphAttributes.color,An=Kt!==void 0?Kt.length:0;let Sn=$t.get(Ht);if(Sn===void 0||Sn.count!==An){let x0=function(){ko.dispose(),$t.delete(Ht),Ht.removeEventListener("dispose",x0)};var qt=x0;Sn!==void 0&&Sn.texture.dispose();const wn=Ht.morphAttributes.position!==void 0,In=Ht.morphAttributes.normal!==void 0,tr=Ht.morphAttributes.color!==void 0,rr=Ht.morphAttributes.position||[],Hr=Ht.morphAttributes.normal||[],qr=Ht.morphAttributes.color||[];let Zr=0;wn===!0&&(Zr=1),In===!0&&(Zr=2),tr===!0&&(Zr=3);let Bo=Ht.attributes.position.count*Zr,Xo=1;Bo>at.maxTextureSize&&(Xo=Math.ceil(Bo/at.maxTextureSize),Bo=at.maxTextureSize);const Kr=new Float32Array(Bo*Xo*4*An),ko=new DataArrayTexture(Kr,Bo,Xo,An);ko.type=FloatType,ko.needsUpdate=!0;const f0=Zr*4;for(let l0=0;l0<An;l0++){const T0=rr[l0],t0=Hr[l0],E0=qr[l0],n0=Bo*Xo*4*l0;for(let m0=0;m0<T0.count;m0++){const h0=m0*f0;wn===!0&&(Tt.fromBufferAttribute(T0,m0),Kr[n0+h0+0]=Tt.x,Kr[n0+h0+1]=Tt.y,Kr[n0+h0+2]=Tt.z,Kr[n0+h0+3]=0),In===!0&&(Tt.fromBufferAttribute(t0,m0),Kr[n0+h0+4]=Tt.x,Kr[n0+h0+5]=Tt.y,Kr[n0+h0+6]=Tt.z,Kr[n0+h0+7]=0),tr===!0&&(Tt.fromBufferAttribute(E0,m0),Kr[n0+h0+8]=Tt.x,Kr[n0+h0+9]=Tt.y,Kr[n0+h0+10]=Tt.z,Kr[n0+h0+11]=E0.itemSize===4?Tt.w:1)}}Sn={count:An,texture:ko,size:new Vector2(Bo,Xo)},$t.set(Ht,Sn),Ht.addEventListener("dispose",x0)}if(Ct.isInstancedMesh===!0&&Ct.morphTexture!==null)Gt.getUniforms().setValue(st,"morphTexture",Ct.morphTexture,pt);else{let wn=0;for(let tr=0;tr<jt.length;tr++)wn+=jt[tr];const In=Ht.morphTargetsRelative?1:1-wn;Gt.getUniforms().setValue(st,"morphTargetBaseInfluence",In),Gt.getUniforms().setValue(st,"morphTargetInfluences",jt)}Gt.getUniforms().setValue(st,"morphTargetsTexture",Sn.texture,pt),Gt.getUniforms().setValue(st,"morphTargetsTextureSize",Sn.size)}else{const Kt=jt===void 0?0:jt.length;let An=vt[Ht.id];if(An===void 0||An.length!==Kt){An=[];for(let rr=0;rr<Kt;rr++)An[rr]=[rr,0];vt[Ht.id]=An}for(let rr=0;rr<Kt;rr++){const Hr=An[rr];Hr[0]=rr,Hr[1]=jt[rr]}An.sort(absNumericalSort);for(let rr=0;rr<8;rr++)rr<Kt&&An[rr][1]?(Lt[rr][0]=An[rr][0],Lt[rr][1]=An[rr][1]):(Lt[rr][0]=Number.MAX_SAFE_INTEGER,Lt[rr][1]=0);Lt.sort(numericalSort);const Sn=Ht.morphAttributes.position,wn=Ht.morphAttributes.normal;let In=0;for(let rr=0;rr<8;rr++){const Hr=Lt[rr],qr=Hr[0],Zr=Hr[1];qr!==Number.MAX_SAFE_INTEGER&&Zr?(Sn&&Ht.getAttribute("morphTarget"+rr)!==Sn[qr]&&Ht.setAttribute("morphTarget"+rr,Sn[qr]),wn&&Ht.getAttribute("morphNormal"+rr)!==wn[qr]&&Ht.setAttribute("morphNormal"+rr,wn[qr]),wt[rr]=Zr,In+=Zr):(Sn&&Ht.hasAttribute("morphTarget"+rr)===!0&&Ht.deleteAttribute("morphTarget"+rr),wn&&Ht.hasAttribute("morphNormal"+rr)===!0&&Ht.deleteAttribute("morphNormal"+rr),wt[rr]=0)}const tr=Ht.morphTargetsRelative?1:1-In;Gt.getUniforms().setValue(st,"morphTargetBaseInfluence",tr),Gt.getUniforms().setValue(st,"morphTargetInfluences",wt)}}return{update:Ft}}function WebGLObjects(st,at,pt,vt){let wt=new WeakMap;function $t(Ft){const Ct=vt.render.frame,Ht=Ft.geometry,Gt=at.get(Ft,Ht);if(wt.get(Gt)!==Ct&&(at.update(Gt),wt.set(Gt,Ct)),Ft.isInstancedMesh&&(Ft.hasEventListener("dispose",Lt)===!1&&Ft.addEventListener("dispose",Lt),wt.get(Ft)!==Ct&&(pt.update(Ft.instanceMatrix,st.ARRAY_BUFFER),Ft.instanceColor!==null&&pt.update(Ft.instanceColor,st.ARRAY_BUFFER),wt.set(Ft,Ct))),Ft.isSkinnedMesh){const jt=Ft.skeleton;wt.get(jt)!==Ct&&(jt.update(),wt.set(jt,Ct))}return Gt}function Tt(){wt=new WeakMap}function Lt(Ft){const Ct=Ft.target;Ct.removeEventListener("dispose",Lt),pt.remove(Ct.instanceMatrix),Ct.instanceColor!==null&&pt.remove(Ct.instanceColor)}return{update:$t,dispose:Tt}}class DepthTexture extends Texture{constructor(at,pt,vt,wt,$t,Tt,Lt,Ft,Ct,Ht){if(Ht=Ht!==void 0?Ht:DepthFormat,Ht!==DepthFormat&&Ht!==DepthStencilFormat)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");vt===void 0&&Ht===DepthFormat&&(vt=UnsignedIntType),vt===void 0&&Ht===DepthStencilFormat&&(vt=UnsignedInt248Type),super(null,wt,$t,Tt,Lt,Ft,Ht,vt,Ct),this.isDepthTexture=!0,this.image={width:at,height:pt},this.magFilter=Lt!==void 0?Lt:NearestFilter,this.minFilter=Ft!==void 0?Ft:NearestFilter,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(at){return super.copy(at),this.compareFunction=at.compareFunction,this}toJSON(at){const pt=super.toJSON(at);return this.compareFunction!==null&&(pt.compareFunction=this.compareFunction),pt}}const emptyTexture=new Texture,emptyShadowTexture=new DepthTexture(1,1);emptyShadowTexture.compareFunction=LessEqualCompare;const emptyArrayTexture=new DataArrayTexture,empty3dTexture=new Data3DTexture,emptyCubeTexture=new CubeTexture,arrayCacheF32=[],arrayCacheI32=[],mat4array=new Float32Array(16),mat3array=new Float32Array(9),mat2array=new Float32Array(4);function flatten$1(st,at,pt){const vt=st[0];if(vt<=0||vt>0)return st;const wt=at*pt;let $t=arrayCacheF32[wt];if($t===void 0&&($t=new Float32Array(wt),arrayCacheF32[wt]=$t),at!==0){vt.toArray($t,0);for(let Tt=1,Lt=0;Tt!==at;++Tt)Lt+=pt,st[Tt].toArray($t,Lt)}return $t}function arraysEqual(st,at){if(st.length!==at.length)return!1;for(let pt=0,vt=st.length;pt<vt;pt++)if(st[pt]!==at[pt])return!1;return!0}function copyArray(st,at){for(let pt=0,vt=at.length;pt<vt;pt++)st[pt]=at[pt]}function allocTexUnits(st,at){let pt=arrayCacheI32[at];pt===void 0&&(pt=new Int32Array(at),arrayCacheI32[at]=pt);for(let vt=0;vt!==at;++vt)pt[vt]=st.allocateTextureUnit();return pt}function setValueV1f(st,at){const pt=this.cache;pt[0]!==at&&(st.uniform1f(this.addr,at),pt[0]=at)}function setValueV2f(st,at){const pt=this.cache;if(at.x!==void 0)(pt[0]!==at.x||pt[1]!==at.y)&&(st.uniform2f(this.addr,at.x,at.y),pt[0]=at.x,pt[1]=at.y);else{if(arraysEqual(pt,at))return;st.uniform2fv(this.addr,at),copyArray(pt,at)}}function setValueV3f(st,at){const pt=this.cache;if(at.x!==void 0)(pt[0]!==at.x||pt[1]!==at.y||pt[2]!==at.z)&&(st.uniform3f(this.addr,at.x,at.y,at.z),pt[0]=at.x,pt[1]=at.y,pt[2]=at.z);else if(at.r!==void 0)(pt[0]!==at.r||pt[1]!==at.g||pt[2]!==at.b)&&(st.uniform3f(this.addr,at.r,at.g,at.b),pt[0]=at.r,pt[1]=at.g,pt[2]=at.b);else{if(arraysEqual(pt,at))return;st.uniform3fv(this.addr,at),copyArray(pt,at)}}function setValueV4f(st,at){const pt=this.cache;if(at.x!==void 0)(pt[0]!==at.x||pt[1]!==at.y||pt[2]!==at.z||pt[3]!==at.w)&&(st.uniform4f(this.addr,at.x,at.y,at.z,at.w),pt[0]=at.x,pt[1]=at.y,pt[2]=at.z,pt[3]=at.w);else{if(arraysEqual(pt,at))return;st.uniform4fv(this.addr,at),copyArray(pt,at)}}function setValueM2(st,at){const pt=this.cache,vt=at.elements;if(vt===void 0){if(arraysEqual(pt,at))return;st.uniformMatrix2fv(this.addr,!1,at),copyArray(pt,at)}else{if(arraysEqual(pt,vt))return;mat2array.set(vt),st.uniformMatrix2fv(this.addr,!1,mat2array),copyArray(pt,vt)}}function setValueM3(st,at){const pt=this.cache,vt=at.elements;if(vt===void 0){if(arraysEqual(pt,at))return;st.uniformMatrix3fv(this.addr,!1,at),copyArray(pt,at)}else{if(arraysEqual(pt,vt))return;mat3array.set(vt),st.uniformMatrix3fv(this.addr,!1,mat3array),copyArray(pt,vt)}}function setValueM4(st,at){const pt=this.cache,vt=at.elements;if(vt===void 0){if(arraysEqual(pt,at))return;st.uniformMatrix4fv(this.addr,!1,at),copyArray(pt,at)}else{if(arraysEqual(pt,vt))return;mat4array.set(vt),st.uniformMatrix4fv(this.addr,!1,mat4array),copyArray(pt,vt)}}function setValueV1i(st,at){const pt=this.cache;pt[0]!==at&&(st.uniform1i(this.addr,at),pt[0]=at)}function setValueV2i(st,at){const pt=this.cache;if(at.x!==void 0)(pt[0]!==at.x||pt[1]!==at.y)&&(st.uniform2i(this.addr,at.x,at.y),pt[0]=at.x,pt[1]=at.y);else{if(arraysEqual(pt,at))return;st.uniform2iv(this.addr,at),copyArray(pt,at)}}function setValueV3i(st,at){const pt=this.cache;if(at.x!==void 0)(pt[0]!==at.x||pt[1]!==at.y||pt[2]!==at.z)&&(st.uniform3i(this.addr,at.x,at.y,at.z),pt[0]=at.x,pt[1]=at.y,pt[2]=at.z);else{if(arraysEqual(pt,at))return;st.uniform3iv(this.addr,at),copyArray(pt,at)}}function setValueV4i(st,at){const pt=this.cache;if(at.x!==void 0)(pt[0]!==at.x||pt[1]!==at.y||pt[2]!==at.z||pt[3]!==at.w)&&(st.uniform4i(this.addr,at.x,at.y,at.z,at.w),pt[0]=at.x,pt[1]=at.y,pt[2]=at.z,pt[3]=at.w);else{if(arraysEqual(pt,at))return;st.uniform4iv(this.addr,at),copyArray(pt,at)}}function setValueV1ui(st,at){const pt=this.cache;pt[0]!==at&&(st.uniform1ui(this.addr,at),pt[0]=at)}function setValueV2ui(st,at){const pt=this.cache;if(at.x!==void 0)(pt[0]!==at.x||pt[1]!==at.y)&&(st.uniform2ui(this.addr,at.x,at.y),pt[0]=at.x,pt[1]=at.y);else{if(arraysEqual(pt,at))return;st.uniform2uiv(this.addr,at),copyArray(pt,at)}}function setValueV3ui(st,at){const pt=this.cache;if(at.x!==void 0)(pt[0]!==at.x||pt[1]!==at.y||pt[2]!==at.z)&&(st.uniform3ui(this.addr,at.x,at.y,at.z),pt[0]=at.x,pt[1]=at.y,pt[2]=at.z);else{if(arraysEqual(pt,at))return;st.uniform3uiv(this.addr,at),copyArray(pt,at)}}function setValueV4ui(st,at){const pt=this.cache;if(at.x!==void 0)(pt[0]!==at.x||pt[1]!==at.y||pt[2]!==at.z||pt[3]!==at.w)&&(st.uniform4ui(this.addr,at.x,at.y,at.z,at.w),pt[0]=at.x,pt[1]=at.y,pt[2]=at.z,pt[3]=at.w);else{if(arraysEqual(pt,at))return;st.uniform4uiv(this.addr,at),copyArray(pt,at)}}function setValueT1(st,at,pt){const vt=this.cache,wt=pt.allocateTextureUnit();vt[0]!==wt&&(st.uniform1i(this.addr,wt),vt[0]=wt);const $t=this.type===st.SAMPLER_2D_SHADOW?emptyShadowTexture:emptyTexture;pt.setTexture2D(at||$t,wt)}function setValueT3D1(st,at,pt){const vt=this.cache,wt=pt.allocateTextureUnit();vt[0]!==wt&&(st.uniform1i(this.addr,wt),vt[0]=wt),pt.setTexture3D(at||empty3dTexture,wt)}function setValueT6(st,at,pt){const vt=this.cache,wt=pt.allocateTextureUnit();vt[0]!==wt&&(st.uniform1i(this.addr,wt),vt[0]=wt),pt.setTextureCube(at||emptyCubeTexture,wt)}function setValueT2DArray1(st,at,pt){const vt=this.cache,wt=pt.allocateTextureUnit();vt[0]!==wt&&(st.uniform1i(this.addr,wt),vt[0]=wt),pt.setTexture2DArray(at||emptyArrayTexture,wt)}function getSingularSetter(st){switch(st){case 5126:return setValueV1f;case 35664:return setValueV2f;case 35665:return setValueV3f;case 35666:return setValueV4f;case 35674:return setValueM2;case 35675:return setValueM3;case 35676:return setValueM4;case 5124:case 35670:return setValueV1i;case 35667:case 35671:return setValueV2i;case 35668:case 35672:return setValueV3i;case 35669:case 35673:return setValueV4i;case 5125:return setValueV1ui;case 36294:return setValueV2ui;case 36295:return setValueV3ui;case 36296:return setValueV4ui;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1;case 35679:case 36299:case 36307:return setValueT3D1;case 35680:case 36300:case 36308:case 36293:return setValueT6;case 36289:case 36303:case 36311:case 36292:return setValueT2DArray1}}function setValueV1fArray(st,at){st.uniform1fv(this.addr,at)}function setValueV2fArray(st,at){const pt=flatten$1(at,this.size,2);st.uniform2fv(this.addr,pt)}function setValueV3fArray(st,at){const pt=flatten$1(at,this.size,3);st.uniform3fv(this.addr,pt)}function setValueV4fArray(st,at){const pt=flatten$1(at,this.size,4);st.uniform4fv(this.addr,pt)}function setValueM2Array(st,at){const pt=flatten$1(at,this.size,4);st.uniformMatrix2fv(this.addr,!1,pt)}function setValueM3Array(st,at){const pt=flatten$1(at,this.size,9);st.uniformMatrix3fv(this.addr,!1,pt)}function setValueM4Array(st,at){const pt=flatten$1(at,this.size,16);st.uniformMatrix4fv(this.addr,!1,pt)}function setValueV1iArray(st,at){st.uniform1iv(this.addr,at)}function setValueV2iArray(st,at){st.uniform2iv(this.addr,at)}function setValueV3iArray(st,at){st.uniform3iv(this.addr,at)}function setValueV4iArray(st,at){st.uniform4iv(this.addr,at)}function setValueV1uiArray(st,at){st.uniform1uiv(this.addr,at)}function setValueV2uiArray(st,at){st.uniform2uiv(this.addr,at)}function setValueV3uiArray(st,at){st.uniform3uiv(this.addr,at)}function setValueV4uiArray(st,at){st.uniform4uiv(this.addr,at)}function setValueT1Array(st,at,pt){const vt=this.cache,wt=at.length,$t=allocTexUnits(pt,wt);arraysEqual(vt,$t)||(st.uniform1iv(this.addr,$t),copyArray(vt,$t));for(let Tt=0;Tt!==wt;++Tt)pt.setTexture2D(at[Tt]||emptyTexture,$t[Tt])}function setValueT3DArray(st,at,pt){const vt=this.cache,wt=at.length,$t=allocTexUnits(pt,wt);arraysEqual(vt,$t)||(st.uniform1iv(this.addr,$t),copyArray(vt,$t));for(let Tt=0;Tt!==wt;++Tt)pt.setTexture3D(at[Tt]||empty3dTexture,$t[Tt])}function setValueT6Array(st,at,pt){const vt=this.cache,wt=at.length,$t=allocTexUnits(pt,wt);arraysEqual(vt,$t)||(st.uniform1iv(this.addr,$t),copyArray(vt,$t));for(let Tt=0;Tt!==wt;++Tt)pt.setTextureCube(at[Tt]||emptyCubeTexture,$t[Tt])}function setValueT2DArrayArray(st,at,pt){const vt=this.cache,wt=at.length,$t=allocTexUnits(pt,wt);arraysEqual(vt,$t)||(st.uniform1iv(this.addr,$t),copyArray(vt,$t));for(let Tt=0;Tt!==wt;++Tt)pt.setTexture2DArray(at[Tt]||emptyArrayTexture,$t[Tt])}function getPureArraySetter(st){switch(st){case 5126:return setValueV1fArray;case 35664:return setValueV2fArray;case 35665:return setValueV3fArray;case 35666:return setValueV4fArray;case 35674:return setValueM2Array;case 35675:return setValueM3Array;case 35676:return setValueM4Array;case 5124:case 35670:return setValueV1iArray;case 35667:case 35671:return setValueV2iArray;case 35668:case 35672:return setValueV3iArray;case 35669:case 35673:return setValueV4iArray;case 5125:return setValueV1uiArray;case 36294:return setValueV2uiArray;case 36295:return setValueV3uiArray;case 36296:return setValueV4uiArray;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1Array;case 35679:case 36299:case 36307:return setValueT3DArray;case 35680:case 36300:case 36308:case 36293:return setValueT6Array;case 36289:case 36303:case 36311:case 36292:return setValueT2DArrayArray}}class SingleUniform{constructor(at,pt,vt){this.id=at,this.addr=vt,this.cache=[],this.type=pt.type,this.setValue=getSingularSetter(pt.type)}}class PureArrayUniform{constructor(at,pt,vt){this.id=at,this.addr=vt,this.cache=[],this.type=pt.type,this.size=pt.size,this.setValue=getPureArraySetter(pt.type)}}class StructuredUniform{constructor(at){this.id=at,this.seq=[],this.map={}}setValue(at,pt,vt){const wt=this.seq;for(let $t=0,Tt=wt.length;$t!==Tt;++$t){const Lt=wt[$t];Lt.setValue(at,pt[Lt.id],vt)}}}const RePathPart=/(\w+)(\])?(\[|\.)?/g;function addUniform(st,at){st.seq.push(at),st.map[at.id]=at}function parseUniform(st,at,pt){const vt=st.name,wt=vt.length;for(RePathPart.lastIndex=0;;){const $t=RePathPart.exec(vt),Tt=RePathPart.lastIndex;let Lt=$t[1];const Ft=$t[2]==="]",Ct=$t[3];if(Ft&&(Lt=Lt|0),Ct===void 0||Ct==="["&&Tt+2===wt){addUniform(pt,Ct===void 0?new SingleUniform(Lt,st,at):new PureArrayUniform(Lt,st,at));break}else{let Gt=pt.map[Lt];Gt===void 0&&(Gt=new StructuredUniform(Lt),addUniform(pt,Gt)),pt=Gt}}}class WebGLUniforms{constructor(at,pt){this.seq=[],this.map={};const vt=at.getProgramParameter(pt,at.ACTIVE_UNIFORMS);for(let wt=0;wt<vt;++wt){const $t=at.getActiveUniform(pt,wt),Tt=at.getUniformLocation(pt,$t.name);parseUniform($t,Tt,this)}}setValue(at,pt,vt,wt){const $t=this.map[pt];$t!==void 0&&$t.setValue(at,vt,wt)}setOptional(at,pt,vt){const wt=pt[vt];wt!==void 0&&this.setValue(at,vt,wt)}static upload(at,pt,vt,wt){for(let $t=0,Tt=pt.length;$t!==Tt;++$t){const Lt=pt[$t],Ft=vt[Lt.id];Ft.needsUpdate!==!1&&Lt.setValue(at,Ft.value,wt)}}static seqWithValue(at,pt){const vt=[];for(let wt=0,$t=at.length;wt!==$t;++wt){const Tt=at[wt];Tt.id in pt&&vt.push(Tt)}return vt}}function WebGLShader(st,at,pt){const vt=st.createShader(at);return st.shaderSource(vt,pt),st.compileShader(vt),vt}const COMPLETION_STATUS_KHR=37297;let programIdCount=0;function handleSource(st,at){const pt=st.split(`
`),vt=[],wt=Math.max(at-6,0),$t=Math.min(at+6,pt.length);for(let Tt=wt;Tt<$t;Tt++){const Lt=Tt+1;vt.push(`${Lt===at?">":" "} ${Lt}: ${pt[Tt]}`)}return vt.join(`
`)}function getEncodingComponents(st){const at=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),pt=ColorManagement.getPrimaries(st);let vt;switch(at===pt?vt="":at===P3Primaries&&pt===Rec709Primaries?vt="LinearDisplayP3ToLinearSRGB":at===Rec709Primaries&&pt===P3Primaries&&(vt="LinearSRGBToLinearDisplayP3"),st){case LinearSRGBColorSpace$1:case LinearDisplayP3ColorSpace:return[vt,"LinearTransferOETF"];case SRGBColorSpace$1:case DisplayP3ColorSpace:return[vt,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",st),[vt,"LinearTransferOETF"]}}function getShaderErrors(st,at,pt){const vt=st.getShaderParameter(at,st.COMPILE_STATUS),wt=st.getShaderInfoLog(at).trim();if(vt&&wt==="")return"";const $t=/ERROR: 0:(\d+)/.exec(wt);if($t){const Tt=parseInt($t[1]);return pt.toUpperCase()+`

`+wt+`

`+handleSource(st.getShaderSource(at),Tt)}else return wt}function getTexelEncodingFunction(st,at){const pt=getEncodingComponents(at);return`vec4 ${st}( vec4 value ) { return ${pt[0]}( ${pt[1]}( value ) ); }`}function getToneMappingFunction(st,at){let pt;switch(at){case LinearToneMapping:pt="Linear";break;case ReinhardToneMapping:pt="Reinhard";break;case CineonToneMapping:pt="OptimizedCineon";break;case ACESFilmicToneMapping:pt="ACESFilmic";break;case AgXToneMapping:pt="AgX";break;case NeutralToneMapping:pt="Neutral";break;case CustomToneMapping:pt="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",at),pt="Linear"}return"vec3 "+st+"( vec3 color ) { return "+pt+"ToneMapping( color ); }"}function generateExtensions(st){return[st.extensionDerivatives||st.envMapCubeUVHeight||st.bumpMap||st.normalMapTangentSpace||st.clearcoatNormalMap||st.flatShading||st.alphaToCoverage||st.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(st.extensionFragDepth||st.logarithmicDepthBuffer)&&st.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",st.extensionDrawBuffers&&st.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(st.extensionShaderTextureLOD||st.envMap||st.transmission)&&st.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(filterEmptyLine).join(`
`)}function generateVertexExtensions(st){return[st.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",st.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(filterEmptyLine).join(`
`)}function generateDefines(st){const at=[];for(const pt in st){const vt=st[pt];vt!==!1&&at.push("#define "+pt+" "+vt)}return at.join(`
`)}function fetchAttributeLocations(st,at){const pt={},vt=st.getProgramParameter(at,st.ACTIVE_ATTRIBUTES);for(let wt=0;wt<vt;wt++){const $t=st.getActiveAttrib(at,wt),Tt=$t.name;let Lt=1;$t.type===st.FLOAT_MAT2&&(Lt=2),$t.type===st.FLOAT_MAT3&&(Lt=3),$t.type===st.FLOAT_MAT4&&(Lt=4),pt[Tt]={type:$t.type,location:st.getAttribLocation(at,Tt),locationSize:Lt}}return pt}function filterEmptyLine(st){return st!==""}function replaceLightNums(st,at){const pt=at.numSpotLightShadows+at.numSpotLightMaps-at.numSpotLightShadowsWithMaps;return st.replace(/NUM_DIR_LIGHTS/g,at.numDirLights).replace(/NUM_SPOT_LIGHTS/g,at.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,at.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,pt).replace(/NUM_RECT_AREA_LIGHTS/g,at.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,at.numPointLights).replace(/NUM_HEMI_LIGHTS/g,at.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,at.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,at.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,at.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,at.numPointLightShadows)}function replaceClippingPlaneNums(st,at){return st.replace(/NUM_CLIPPING_PLANES/g,at.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,at.numClippingPlanes-at.numClipIntersection)}const includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(st){return st.replace(includePattern,includeReplacer)}const shaderChunkMap=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function includeReplacer(st,at){let pt=ShaderChunk[at];if(pt===void 0){const vt=shaderChunkMap.get(at);if(vt!==void 0)pt=ShaderChunk[vt],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',at,vt);else throw new Error("Can not resolve #include <"+at+">")}return resolveIncludes(pt)}const unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(st){return st.replace(unrollLoopPattern,loopReplacer)}function loopReplacer(st,at,pt,vt){let wt="";for(let $t=parseInt(at);$t<parseInt(pt);$t++)wt+=vt.replace(/\[\s*i\s*\]/g,"[ "+$t+" ]").replace(/UNROLLED_LOOP_INDEX/g,$t);return wt}function generatePrecision(st){let at=`precision ${st.precision} float;
	precision ${st.precision} int;
	precision ${st.precision} sampler2D;
	precision ${st.precision} samplerCube;
	`;return st.isWebGL2&&(at+=`precision ${st.precision} sampler3D;
		precision ${st.precision} sampler2DArray;
		precision ${st.precision} sampler2DShadow;
		precision ${st.precision} samplerCubeShadow;
		precision ${st.precision} sampler2DArrayShadow;
		precision ${st.precision} isampler2D;
		precision ${st.precision} isampler3D;
		precision ${st.precision} isamplerCube;
		precision ${st.precision} isampler2DArray;
		precision ${st.precision} usampler2D;
		precision ${st.precision} usampler3D;
		precision ${st.precision} usamplerCube;
		precision ${st.precision} usampler2DArray;
		`),st.precision==="highp"?at+=`
#define HIGH_PRECISION`:st.precision==="mediump"?at+=`
#define MEDIUM_PRECISION`:st.precision==="lowp"&&(at+=`
#define LOW_PRECISION`),at}function generateShadowMapTypeDefine(st){let at="SHADOWMAP_TYPE_BASIC";return st.shadowMapType===PCFShadowMap?at="SHADOWMAP_TYPE_PCF":st.shadowMapType===PCFSoftShadowMap?at="SHADOWMAP_TYPE_PCF_SOFT":st.shadowMapType===VSMShadowMap&&(at="SHADOWMAP_TYPE_VSM"),at}function generateEnvMapTypeDefine(st){let at="ENVMAP_TYPE_CUBE";if(st.envMap)switch(st.envMapMode){case CubeReflectionMapping:case CubeRefractionMapping:at="ENVMAP_TYPE_CUBE";break;case CubeUVReflectionMapping:at="ENVMAP_TYPE_CUBE_UV";break}return at}function generateEnvMapModeDefine(st){let at="ENVMAP_MODE_REFLECTION";if(st.envMap)switch(st.envMapMode){case CubeRefractionMapping:at="ENVMAP_MODE_REFRACTION";break}return at}function generateEnvMapBlendingDefine(st){let at="ENVMAP_BLENDING_NONE";if(st.envMap)switch(st.combine){case MultiplyOperation:at="ENVMAP_BLENDING_MULTIPLY";break;case MixOperation:at="ENVMAP_BLENDING_MIX";break;case AddOperation:at="ENVMAP_BLENDING_ADD";break}return at}function generateCubeUVSize(st){const at=st.envMapCubeUVHeight;if(at===null)return null;const pt=Math.log2(at)-2,vt=1/at;return{texelWidth:1/(3*Math.max(Math.pow(2,pt),7*16)),texelHeight:vt,maxMip:pt}}function WebGLProgram(st,at,pt,vt){const wt=st.getContext(),$t=pt.defines;let Tt=pt.vertexShader,Lt=pt.fragmentShader;const Ft=generateShadowMapTypeDefine(pt),Ct=generateEnvMapTypeDefine(pt),Ht=generateEnvMapModeDefine(pt),Gt=generateEnvMapBlendingDefine(pt),jt=generateCubeUVSize(pt),qt=pt.isWebGL2?"":generateExtensions(pt),Kt=generateVertexExtensions(pt),An=generateDefines($t),Sn=wt.createProgram();let wn,In,tr=pt.glslVersion?"#version "+pt.glslVersion+`
`:"";pt.isRawShaderMaterial?(wn=["#define SHADER_TYPE "+pt.shaderType,"#define SHADER_NAME "+pt.shaderName,An].filter(filterEmptyLine).join(`
`),wn.length>0&&(wn+=`
`),In=[qt,"#define SHADER_TYPE "+pt.shaderType,"#define SHADER_NAME "+pt.shaderName,An].filter(filterEmptyLine).join(`
`),In.length>0&&(In+=`
`)):(wn=[generatePrecision(pt),"#define SHADER_TYPE "+pt.shaderType,"#define SHADER_NAME "+pt.shaderName,An,pt.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",pt.batching?"#define USE_BATCHING":"",pt.instancing?"#define USE_INSTANCING":"",pt.instancingColor?"#define USE_INSTANCING_COLOR":"",pt.instancingMorph?"#define USE_INSTANCING_MORPH":"",pt.useFog&&pt.fog?"#define USE_FOG":"",pt.useFog&&pt.fogExp2?"#define FOG_EXP2":"",pt.map?"#define USE_MAP":"",pt.envMap?"#define USE_ENVMAP":"",pt.envMap?"#define "+Ht:"",pt.lightMap?"#define USE_LIGHTMAP":"",pt.aoMap?"#define USE_AOMAP":"",pt.bumpMap?"#define USE_BUMPMAP":"",pt.normalMap?"#define USE_NORMALMAP":"",pt.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",pt.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",pt.displacementMap?"#define USE_DISPLACEMENTMAP":"",pt.emissiveMap?"#define USE_EMISSIVEMAP":"",pt.anisotropy?"#define USE_ANISOTROPY":"",pt.anisotropyMap?"#define USE_ANISOTROPYMAP":"",pt.clearcoatMap?"#define USE_CLEARCOATMAP":"",pt.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",pt.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",pt.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",pt.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",pt.specularMap?"#define USE_SPECULARMAP":"",pt.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",pt.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",pt.roughnessMap?"#define USE_ROUGHNESSMAP":"",pt.metalnessMap?"#define USE_METALNESSMAP":"",pt.alphaMap?"#define USE_ALPHAMAP":"",pt.alphaHash?"#define USE_ALPHAHASH":"",pt.transmission?"#define USE_TRANSMISSION":"",pt.transmissionMap?"#define USE_TRANSMISSIONMAP":"",pt.thicknessMap?"#define USE_THICKNESSMAP":"",pt.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",pt.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",pt.mapUv?"#define MAP_UV "+pt.mapUv:"",pt.alphaMapUv?"#define ALPHAMAP_UV "+pt.alphaMapUv:"",pt.lightMapUv?"#define LIGHTMAP_UV "+pt.lightMapUv:"",pt.aoMapUv?"#define AOMAP_UV "+pt.aoMapUv:"",pt.emissiveMapUv?"#define EMISSIVEMAP_UV "+pt.emissiveMapUv:"",pt.bumpMapUv?"#define BUMPMAP_UV "+pt.bumpMapUv:"",pt.normalMapUv?"#define NORMALMAP_UV "+pt.normalMapUv:"",pt.displacementMapUv?"#define DISPLACEMENTMAP_UV "+pt.displacementMapUv:"",pt.metalnessMapUv?"#define METALNESSMAP_UV "+pt.metalnessMapUv:"",pt.roughnessMapUv?"#define ROUGHNESSMAP_UV "+pt.roughnessMapUv:"",pt.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+pt.anisotropyMapUv:"",pt.clearcoatMapUv?"#define CLEARCOATMAP_UV "+pt.clearcoatMapUv:"",pt.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+pt.clearcoatNormalMapUv:"",pt.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+pt.clearcoatRoughnessMapUv:"",pt.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+pt.iridescenceMapUv:"",pt.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+pt.iridescenceThicknessMapUv:"",pt.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+pt.sheenColorMapUv:"",pt.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+pt.sheenRoughnessMapUv:"",pt.specularMapUv?"#define SPECULARMAP_UV "+pt.specularMapUv:"",pt.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+pt.specularColorMapUv:"",pt.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+pt.specularIntensityMapUv:"",pt.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+pt.transmissionMapUv:"",pt.thicknessMapUv?"#define THICKNESSMAP_UV "+pt.thicknessMapUv:"",pt.vertexTangents&&pt.flatShading===!1?"#define USE_TANGENT":"",pt.vertexColors?"#define USE_COLOR":"",pt.vertexAlphas?"#define USE_COLOR_ALPHA":"",pt.vertexUv1s?"#define USE_UV1":"",pt.vertexUv2s?"#define USE_UV2":"",pt.vertexUv3s?"#define USE_UV3":"",pt.pointsUvs?"#define USE_POINTS_UV":"",pt.flatShading?"#define FLAT_SHADED":"",pt.skinning?"#define USE_SKINNING":"",pt.morphTargets?"#define USE_MORPHTARGETS":"",pt.morphNormals&&pt.flatShading===!1?"#define USE_MORPHNORMALS":"",pt.morphColors&&pt.isWebGL2?"#define USE_MORPHCOLORS":"",pt.morphTargetsCount>0&&pt.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",pt.morphTargetsCount>0&&pt.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+pt.morphTextureStride:"",pt.morphTargetsCount>0&&pt.isWebGL2?"#define MORPHTARGETS_COUNT "+pt.morphTargetsCount:"",pt.doubleSided?"#define DOUBLE_SIDED":"",pt.flipSided?"#define FLIP_SIDED":"",pt.shadowMapEnabled?"#define USE_SHADOWMAP":"",pt.shadowMapEnabled?"#define "+Ft:"",pt.sizeAttenuation?"#define USE_SIZEATTENUATION":"",pt.numLightProbes>0?"#define USE_LIGHT_PROBES":"",pt.useLegacyLights?"#define LEGACY_LIGHTS":"",pt.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",pt.logarithmicDepthBuffer&&pt.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(filterEmptyLine).join(`
`),In=[qt,generatePrecision(pt),"#define SHADER_TYPE "+pt.shaderType,"#define SHADER_NAME "+pt.shaderName,An,pt.useFog&&pt.fog?"#define USE_FOG":"",pt.useFog&&pt.fogExp2?"#define FOG_EXP2":"",pt.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",pt.map?"#define USE_MAP":"",pt.matcap?"#define USE_MATCAP":"",pt.envMap?"#define USE_ENVMAP":"",pt.envMap?"#define "+Ct:"",pt.envMap?"#define "+Ht:"",pt.envMap?"#define "+Gt:"",jt?"#define CUBEUV_TEXEL_WIDTH "+jt.texelWidth:"",jt?"#define CUBEUV_TEXEL_HEIGHT "+jt.texelHeight:"",jt?"#define CUBEUV_MAX_MIP "+jt.maxMip+".0":"",pt.lightMap?"#define USE_LIGHTMAP":"",pt.aoMap?"#define USE_AOMAP":"",pt.bumpMap?"#define USE_BUMPMAP":"",pt.normalMap?"#define USE_NORMALMAP":"",pt.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",pt.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",pt.emissiveMap?"#define USE_EMISSIVEMAP":"",pt.anisotropy?"#define USE_ANISOTROPY":"",pt.anisotropyMap?"#define USE_ANISOTROPYMAP":"",pt.clearcoat?"#define USE_CLEARCOAT":"",pt.clearcoatMap?"#define USE_CLEARCOATMAP":"",pt.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",pt.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",pt.iridescence?"#define USE_IRIDESCENCE":"",pt.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",pt.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",pt.specularMap?"#define USE_SPECULARMAP":"",pt.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",pt.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",pt.roughnessMap?"#define USE_ROUGHNESSMAP":"",pt.metalnessMap?"#define USE_METALNESSMAP":"",pt.alphaMap?"#define USE_ALPHAMAP":"",pt.alphaTest?"#define USE_ALPHATEST":"",pt.alphaHash?"#define USE_ALPHAHASH":"",pt.sheen?"#define USE_SHEEN":"",pt.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",pt.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",pt.transmission?"#define USE_TRANSMISSION":"",pt.transmissionMap?"#define USE_TRANSMISSIONMAP":"",pt.thicknessMap?"#define USE_THICKNESSMAP":"",pt.vertexTangents&&pt.flatShading===!1?"#define USE_TANGENT":"",pt.vertexColors||pt.instancingColor?"#define USE_COLOR":"",pt.vertexAlphas?"#define USE_COLOR_ALPHA":"",pt.vertexUv1s?"#define USE_UV1":"",pt.vertexUv2s?"#define USE_UV2":"",pt.vertexUv3s?"#define USE_UV3":"",pt.pointsUvs?"#define USE_POINTS_UV":"",pt.gradientMap?"#define USE_GRADIENTMAP":"",pt.flatShading?"#define FLAT_SHADED":"",pt.doubleSided?"#define DOUBLE_SIDED":"",pt.flipSided?"#define FLIP_SIDED":"",pt.shadowMapEnabled?"#define USE_SHADOWMAP":"",pt.shadowMapEnabled?"#define "+Ft:"",pt.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",pt.numLightProbes>0?"#define USE_LIGHT_PROBES":"",pt.useLegacyLights?"#define LEGACY_LIGHTS":"",pt.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",pt.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",pt.logarithmicDepthBuffer&&pt.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",pt.toneMapping!==NoToneMapping?"#define TONE_MAPPING":"",pt.toneMapping!==NoToneMapping?ShaderChunk.tonemapping_pars_fragment:"",pt.toneMapping!==NoToneMapping?getToneMappingFunction("toneMapping",pt.toneMapping):"",pt.dithering?"#define DITHERING":"",pt.opaque?"#define OPAQUE":"",ShaderChunk.colorspace_pars_fragment,getTexelEncodingFunction("linearToOutputTexel",pt.outputColorSpace),pt.useDepthPacking?"#define DEPTH_PACKING "+pt.depthPacking:"",`
`].filter(filterEmptyLine).join(`
`)),Tt=resolveIncludes(Tt),Tt=replaceLightNums(Tt,pt),Tt=replaceClippingPlaneNums(Tt,pt),Lt=resolveIncludes(Lt),Lt=replaceLightNums(Lt,pt),Lt=replaceClippingPlaneNums(Lt,pt),Tt=unrollLoops(Tt),Lt=unrollLoops(Lt),pt.isWebGL2&&pt.isRawShaderMaterial!==!0&&(tr=`#version 300 es
`,wn=[Kt,"precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+wn,In=["precision mediump sampler2DArray;","#define varying in",pt.glslVersion===GLSL3?"":"layout(location = 0) out highp vec4 pc_fragColor;",pt.glslVersion===GLSL3?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+In);const rr=tr+wn+Tt,Hr=tr+In+Lt,qr=WebGLShader(wt,wt.VERTEX_SHADER,rr),Zr=WebGLShader(wt,wt.FRAGMENT_SHADER,Hr);wt.attachShader(Sn,qr),wt.attachShader(Sn,Zr),pt.index0AttributeName!==void 0?wt.bindAttribLocation(Sn,0,pt.index0AttributeName):pt.morphTargets===!0&&wt.bindAttribLocation(Sn,0,"position"),wt.linkProgram(Sn);function Bo(f0){if(st.debug.checkShaderErrors){const x0=wt.getProgramInfoLog(Sn).trim(),l0=wt.getShaderInfoLog(qr).trim(),T0=wt.getShaderInfoLog(Zr).trim();let t0=!0,E0=!0;if(wt.getProgramParameter(Sn,wt.LINK_STATUS)===!1)if(t0=!1,typeof st.debug.onShaderError=="function")st.debug.onShaderError(wt,Sn,qr,Zr);else{const n0=getShaderErrors(wt,qr,"vertex"),m0=getShaderErrors(wt,Zr,"fragment");console.error("THREE.WebGLProgram: Shader Error "+wt.getError()+" - VALIDATE_STATUS "+wt.getProgramParameter(Sn,wt.VALIDATE_STATUS)+`

Material Name: `+f0.name+`
Material Type: `+f0.type+`

Program Info Log: `+x0+`
`+n0+`
`+m0)}else x0!==""?console.warn("THREE.WebGLProgram: Program Info Log:",x0):(l0===""||T0==="")&&(E0=!1);E0&&(f0.diagnostics={runnable:t0,programLog:x0,vertexShader:{log:l0,prefix:wn},fragmentShader:{log:T0,prefix:In}})}wt.deleteShader(qr),wt.deleteShader(Zr),Xo=new WebGLUniforms(wt,Sn),Kr=fetchAttributeLocations(wt,Sn)}let Xo;this.getUniforms=function(){return Xo===void 0&&Bo(this),Xo};let Kr;this.getAttributes=function(){return Kr===void 0&&Bo(this),Kr};let ko=pt.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return ko===!1&&(ko=wt.getProgramParameter(Sn,COMPLETION_STATUS_KHR)),ko},this.destroy=function(){vt.releaseStatesOfProgram(this),wt.deleteProgram(Sn),this.program=void 0},this.type=pt.shaderType,this.name=pt.shaderName,this.id=programIdCount++,this.cacheKey=at,this.usedTimes=1,this.program=Sn,this.vertexShader=qr,this.fragmentShader=Zr,this}let _id$1=0;class WebGLShaderCache{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(at){const pt=at.vertexShader,vt=at.fragmentShader,wt=this._getShaderStage(pt),$t=this._getShaderStage(vt),Tt=this._getShaderCacheForMaterial(at);return Tt.has(wt)===!1&&(Tt.add(wt),wt.usedTimes++),Tt.has($t)===!1&&(Tt.add($t),$t.usedTimes++),this}remove(at){const pt=this.materialCache.get(at);for(const vt of pt)vt.usedTimes--,vt.usedTimes===0&&this.shaderCache.delete(vt.code);return this.materialCache.delete(at),this}getVertexShaderID(at){return this._getShaderStage(at.vertexShader).id}getFragmentShaderID(at){return this._getShaderStage(at.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(at){const pt=this.materialCache;let vt=pt.get(at);return vt===void 0&&(vt=new Set,pt.set(at,vt)),vt}_getShaderStage(at){const pt=this.shaderCache;let vt=pt.get(at);return vt===void 0&&(vt=new WebGLShaderStage(at),pt.set(at,vt)),vt}}class WebGLShaderStage{constructor(at){this.id=_id$1++,this.code=at,this.usedTimes=0}}function WebGLPrograms(st,at,pt,vt,wt,$t,Tt){const Lt=new Layers,Ft=new WebGLShaderCache,Ct=new Set,Ht=[],Gt=wt.isWebGL2,jt=wt.logarithmicDepthBuffer,qt=wt.vertexTextures;let Kt=wt.precision;const An={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function Sn(Kr){return Ct.add(Kr),Kr===0?"uv":`uv${Kr}`}function wn(Kr,ko,f0,x0,l0){const T0=x0.fog,t0=l0.geometry,E0=Kr.isMeshStandardMaterial?x0.environment:null,n0=(Kr.isMeshStandardMaterial?pt:at).get(Kr.envMap||E0),m0=n0&&n0.mapping===CubeUVReflectionMapping?n0.image.height:null,h0=An[Kr.type];Kr.precision!==null&&(Kt=wt.getMaxPrecision(Kr.precision),Kt!==Kr.precision&&console.warn("THREE.WebGLProgram.getParameters:",Kr.precision,"not supported, using",Kt,"instead."));const a0=t0.morphAttributes.position||t0.morphAttributes.normal||t0.morphAttributes.color,P0=a0!==void 0?a0.length:0;let V0=0;t0.morphAttributes.position!==void 0&&(V0=1),t0.morphAttributes.normal!==void 0&&(V0=2),t0.morphAttributes.color!==void 0&&(V0=3);let B0,W0,K0,Ty;if(h0){const vv=ShaderLib[h0];B0=vv.vertexShader,W0=vv.fragmentShader}else B0=Kr.vertexShader,W0=Kr.fragmentShader,Ft.update(Kr),K0=Ft.getVertexShaderID(Kr),Ty=Ft.getFragmentShaderID(Kr);const $y=st.getRenderTarget(),My=l0.isInstancedMesh===!0,Wy=l0.isBatchedMesh===!0,Ey=!!Kr.map,_0=!!Kr.matcap,ay=!!n0,J0=!!Kr.aoMap,yy=!!Kr.lightMap,uy=!!Kr.bumpMap,Dy=!!Kr.normalMap,Fy=!!Kr.displacementMap,qy=!!Kr.emissiveMap,rv=!!Kr.metalnessMap,y0=!!Kr.roughnessMap,r0=Kr.anisotropy>0,M0=Kr.clearcoat>0,G0=Kr.iridescence>0,sy=Kr.sheen>0,dy=Kr.transmission>0,Vy=r0&&!!Kr.anisotropyMap,Xy=M0&&!!Kr.clearcoatMap,hy=M0&&!!Kr.clearcoatNormalMap,Ly=M0&&!!Kr.clearcoatRoughnessMap,Py=G0&&!!Kr.iridescenceMap,Sy=G0&&!!Kr.iridescenceThicknessMap,Ev=sy&&!!Kr.sheenColorMap,Qy=sy&&!!Kr.sheenRoughnessMap,cy=!!Kr.specularMap,C0=!!Kr.specularColorMap,U0=!!Kr.specularIntensityMap,xy=dy&&!!Kr.transmissionMap,o0=dy&&!!Kr.thicknessMap,v0=!!Kr.gradientMap,i0=!!Kr.alphaMap,k0=Kr.alphaTest>0,$0=!!Kr.alphaHash,ty=!!Kr.extensions;let my=NoToneMapping;Kr.toneMapped&&($y===null||$y.isXRRenderTarget===!0)&&(my=st.toneMapping);const ev={isWebGL2:Gt,shaderID:h0,shaderType:Kr.type,shaderName:Kr.name,vertexShader:B0,fragmentShader:W0,defines:Kr.defines,customVertexShaderID:K0,customFragmentShaderID:Ty,isRawShaderMaterial:Kr.isRawShaderMaterial===!0,glslVersion:Kr.glslVersion,precision:Kt,batching:Wy,instancing:My,instancingColor:My&&l0.instanceColor!==null,instancingMorph:My&&l0.morphTexture!==null,supportsVertexTextures:qt,outputColorSpace:$y===null?st.outputColorSpace:$y.isXRRenderTarget===!0?$y.texture.colorSpace:LinearSRGBColorSpace$1,alphaToCoverage:!!Kr.alphaToCoverage,map:Ey,matcap:_0,envMap:ay,envMapMode:ay&&n0.mapping,envMapCubeUVHeight:m0,aoMap:J0,lightMap:yy,bumpMap:uy,normalMap:Dy,displacementMap:qt&&Fy,emissiveMap:qy,normalMapObjectSpace:Dy&&Kr.normalMapType===ObjectSpaceNormalMap,normalMapTangentSpace:Dy&&Kr.normalMapType===TangentSpaceNormalMap,metalnessMap:rv,roughnessMap:y0,anisotropy:r0,anisotropyMap:Vy,clearcoat:M0,clearcoatMap:Xy,clearcoatNormalMap:hy,clearcoatRoughnessMap:Ly,iridescence:G0,iridescenceMap:Py,iridescenceThicknessMap:Sy,sheen:sy,sheenColorMap:Ev,sheenRoughnessMap:Qy,specularMap:cy,specularColorMap:C0,specularIntensityMap:U0,transmission:dy,transmissionMap:xy,thicknessMap:o0,gradientMap:v0,opaque:Kr.transparent===!1&&Kr.blending===NormalBlending&&Kr.alphaToCoverage===!1,alphaMap:i0,alphaTest:k0,alphaHash:$0,combine:Kr.combine,mapUv:Ey&&Sn(Kr.map.channel),aoMapUv:J0&&Sn(Kr.aoMap.channel),lightMapUv:yy&&Sn(Kr.lightMap.channel),bumpMapUv:uy&&Sn(Kr.bumpMap.channel),normalMapUv:Dy&&Sn(Kr.normalMap.channel),displacementMapUv:Fy&&Sn(Kr.displacementMap.channel),emissiveMapUv:qy&&Sn(Kr.emissiveMap.channel),metalnessMapUv:rv&&Sn(Kr.metalnessMap.channel),roughnessMapUv:y0&&Sn(Kr.roughnessMap.channel),anisotropyMapUv:Vy&&Sn(Kr.anisotropyMap.channel),clearcoatMapUv:Xy&&Sn(Kr.clearcoatMap.channel),clearcoatNormalMapUv:hy&&Sn(Kr.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:Ly&&Sn(Kr.clearcoatRoughnessMap.channel),iridescenceMapUv:Py&&Sn(Kr.iridescenceMap.channel),iridescenceThicknessMapUv:Sy&&Sn(Kr.iridescenceThicknessMap.channel),sheenColorMapUv:Ev&&Sn(Kr.sheenColorMap.channel),sheenRoughnessMapUv:Qy&&Sn(Kr.sheenRoughnessMap.channel),specularMapUv:cy&&Sn(Kr.specularMap.channel),specularColorMapUv:C0&&Sn(Kr.specularColorMap.channel),specularIntensityMapUv:U0&&Sn(Kr.specularIntensityMap.channel),transmissionMapUv:xy&&Sn(Kr.transmissionMap.channel),thicknessMapUv:o0&&Sn(Kr.thicknessMap.channel),alphaMapUv:i0&&Sn(Kr.alphaMap.channel),vertexTangents:!!t0.attributes.tangent&&(Dy||r0),vertexColors:Kr.vertexColors,vertexAlphas:Kr.vertexColors===!0&&!!t0.attributes.color&&t0.attributes.color.itemSize===4,pointsUvs:l0.isPoints===!0&&!!t0.attributes.uv&&(Ey||i0),fog:!!T0,useFog:Kr.fog===!0,fogExp2:!!T0&&T0.isFogExp2,flatShading:Kr.flatShading===!0,sizeAttenuation:Kr.sizeAttenuation===!0,logarithmicDepthBuffer:jt,skinning:l0.isSkinnedMesh===!0,morphTargets:t0.morphAttributes.position!==void 0,morphNormals:t0.morphAttributes.normal!==void 0,morphColors:t0.morphAttributes.color!==void 0,morphTargetsCount:P0,morphTextureStride:V0,numDirLights:ko.directional.length,numPointLights:ko.point.length,numSpotLights:ko.spot.length,numSpotLightMaps:ko.spotLightMap.length,numRectAreaLights:ko.rectArea.length,numHemiLights:ko.hemi.length,numDirLightShadows:ko.directionalShadowMap.length,numPointLightShadows:ko.pointShadowMap.length,numSpotLightShadows:ko.spotShadowMap.length,numSpotLightShadowsWithMaps:ko.numSpotLightShadowsWithMaps,numLightProbes:ko.numLightProbes,numClippingPlanes:Tt.numPlanes,numClipIntersection:Tt.numIntersection,dithering:Kr.dithering,shadowMapEnabled:st.shadowMap.enabled&&f0.length>0,shadowMapType:st.shadowMap.type,toneMapping:my,useLegacyLights:st._useLegacyLights,decodeVideoTexture:Ey&&Kr.map.isVideoTexture===!0&&ColorManagement.getTransfer(Kr.map.colorSpace)===SRGBTransfer,premultipliedAlpha:Kr.premultipliedAlpha,doubleSided:Kr.side===DoubleSide,flipSided:Kr.side===BackSide,useDepthPacking:Kr.depthPacking>=0,depthPacking:Kr.depthPacking||0,index0AttributeName:Kr.index0AttributeName,extensionDerivatives:ty&&Kr.extensions.derivatives===!0,extensionFragDepth:ty&&Kr.extensions.fragDepth===!0,extensionDrawBuffers:ty&&Kr.extensions.drawBuffers===!0,extensionShaderTextureLOD:ty&&Kr.extensions.shaderTextureLOD===!0,extensionClipCullDistance:ty&&Kr.extensions.clipCullDistance===!0&&vt.has("WEBGL_clip_cull_distance"),extensionMultiDraw:ty&&Kr.extensions.multiDraw===!0&&vt.has("WEBGL_multi_draw"),rendererExtensionFragDepth:Gt||vt.has("EXT_frag_depth"),rendererExtensionDrawBuffers:Gt||vt.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:Gt||vt.has("EXT_shader_texture_lod"),rendererExtensionParallelShaderCompile:vt.has("KHR_parallel_shader_compile"),customProgramCacheKey:Kr.customProgramCacheKey()};return ev.vertexUv1s=Ct.has(1),ev.vertexUv2s=Ct.has(2),ev.vertexUv3s=Ct.has(3),Ct.clear(),ev}function In(Kr){const ko=[];if(Kr.shaderID?ko.push(Kr.shaderID):(ko.push(Kr.customVertexShaderID),ko.push(Kr.customFragmentShaderID)),Kr.defines!==void 0)for(const f0 in Kr.defines)ko.push(f0),ko.push(Kr.defines[f0]);return Kr.isRawShaderMaterial===!1&&(tr(ko,Kr),rr(ko,Kr),ko.push(st.outputColorSpace)),ko.push(Kr.customProgramCacheKey),ko.join()}function tr(Kr,ko){Kr.push(ko.precision),Kr.push(ko.outputColorSpace),Kr.push(ko.envMapMode),Kr.push(ko.envMapCubeUVHeight),Kr.push(ko.mapUv),Kr.push(ko.alphaMapUv),Kr.push(ko.lightMapUv),Kr.push(ko.aoMapUv),Kr.push(ko.bumpMapUv),Kr.push(ko.normalMapUv),Kr.push(ko.displacementMapUv),Kr.push(ko.emissiveMapUv),Kr.push(ko.metalnessMapUv),Kr.push(ko.roughnessMapUv),Kr.push(ko.anisotropyMapUv),Kr.push(ko.clearcoatMapUv),Kr.push(ko.clearcoatNormalMapUv),Kr.push(ko.clearcoatRoughnessMapUv),Kr.push(ko.iridescenceMapUv),Kr.push(ko.iridescenceThicknessMapUv),Kr.push(ko.sheenColorMapUv),Kr.push(ko.sheenRoughnessMapUv),Kr.push(ko.specularMapUv),Kr.push(ko.specularColorMapUv),Kr.push(ko.specularIntensityMapUv),Kr.push(ko.transmissionMapUv),Kr.push(ko.thicknessMapUv),Kr.push(ko.combine),Kr.push(ko.fogExp2),Kr.push(ko.sizeAttenuation),Kr.push(ko.morphTargetsCount),Kr.push(ko.morphAttributeCount),Kr.push(ko.numDirLights),Kr.push(ko.numPointLights),Kr.push(ko.numSpotLights),Kr.push(ko.numSpotLightMaps),Kr.push(ko.numHemiLights),Kr.push(ko.numRectAreaLights),Kr.push(ko.numDirLightShadows),Kr.push(ko.numPointLightShadows),Kr.push(ko.numSpotLightShadows),Kr.push(ko.numSpotLightShadowsWithMaps),Kr.push(ko.numLightProbes),Kr.push(ko.shadowMapType),Kr.push(ko.toneMapping),Kr.push(ko.numClippingPlanes),Kr.push(ko.numClipIntersection),Kr.push(ko.depthPacking)}function rr(Kr,ko){Lt.disableAll(),ko.isWebGL2&&Lt.enable(0),ko.supportsVertexTextures&&Lt.enable(1),ko.instancing&&Lt.enable(2),ko.instancingColor&&Lt.enable(3),ko.instancingMorph&&Lt.enable(4),ko.matcap&&Lt.enable(5),ko.envMap&&Lt.enable(6),ko.normalMapObjectSpace&&Lt.enable(7),ko.normalMapTangentSpace&&Lt.enable(8),ko.clearcoat&&Lt.enable(9),ko.iridescence&&Lt.enable(10),ko.alphaTest&&Lt.enable(11),ko.vertexColors&&Lt.enable(12),ko.vertexAlphas&&Lt.enable(13),ko.vertexUv1s&&Lt.enable(14),ko.vertexUv2s&&Lt.enable(15),ko.vertexUv3s&&Lt.enable(16),ko.vertexTangents&&Lt.enable(17),ko.anisotropy&&Lt.enable(18),ko.alphaHash&&Lt.enable(19),ko.batching&&Lt.enable(20),Kr.push(Lt.mask),Lt.disableAll(),ko.fog&&Lt.enable(0),ko.useFog&&Lt.enable(1),ko.flatShading&&Lt.enable(2),ko.logarithmicDepthBuffer&&Lt.enable(3),ko.skinning&&Lt.enable(4),ko.morphTargets&&Lt.enable(5),ko.morphNormals&&Lt.enable(6),ko.morphColors&&Lt.enable(7),ko.premultipliedAlpha&&Lt.enable(8),ko.shadowMapEnabled&&Lt.enable(9),ko.useLegacyLights&&Lt.enable(10),ko.doubleSided&&Lt.enable(11),ko.flipSided&&Lt.enable(12),ko.useDepthPacking&&Lt.enable(13),ko.dithering&&Lt.enable(14),ko.transmission&&Lt.enable(15),ko.sheen&&Lt.enable(16),ko.opaque&&Lt.enable(17),ko.pointsUvs&&Lt.enable(18),ko.decodeVideoTexture&&Lt.enable(19),ko.alphaToCoverage&&Lt.enable(20),Kr.push(Lt.mask)}function Hr(Kr){const ko=An[Kr.type];let f0;if(ko){const x0=ShaderLib[ko];f0=UniformsUtils.clone(x0.uniforms)}else f0=Kr.uniforms;return f0}function qr(Kr,ko){let f0;for(let x0=0,l0=Ht.length;x0<l0;x0++){const T0=Ht[x0];if(T0.cacheKey===ko){f0=T0,++f0.usedTimes;break}}return f0===void 0&&(f0=new WebGLProgram(st,ko,Kr,$t),Ht.push(f0)),f0}function Zr(Kr){if(--Kr.usedTimes===0){const ko=Ht.indexOf(Kr);Ht[ko]=Ht[Ht.length-1],Ht.pop(),Kr.destroy()}}function Bo(Kr){Ft.remove(Kr)}function Xo(){Ft.dispose()}return{getParameters:wn,getProgramCacheKey:In,getUniforms:Hr,acquireProgram:qr,releaseProgram:Zr,releaseShaderCache:Bo,programs:Ht,dispose:Xo}}function WebGLProperties(){let st=new WeakMap;function at($t){let Tt=st.get($t);return Tt===void 0&&(Tt={},st.set($t,Tt)),Tt}function pt($t){st.delete($t)}function vt($t,Tt,Lt){st.get($t)[Tt]=Lt}function wt(){st=new WeakMap}return{get:at,remove:pt,update:vt,dispose:wt}}function painterSortStable(st,at){return st.groupOrder!==at.groupOrder?st.groupOrder-at.groupOrder:st.renderOrder!==at.renderOrder?st.renderOrder-at.renderOrder:st.material.id!==at.material.id?st.material.id-at.material.id:st.z!==at.z?st.z-at.z:st.id-at.id}function reversePainterSortStable(st,at){return st.groupOrder!==at.groupOrder?st.groupOrder-at.groupOrder:st.renderOrder!==at.renderOrder?st.renderOrder-at.renderOrder:st.z!==at.z?at.z-st.z:st.id-at.id}function WebGLRenderList(){const st=[];let at=0;const pt=[],vt=[],wt=[];function $t(){at=0,pt.length=0,vt.length=0,wt.length=0}function Tt(Gt,jt,qt,Kt,An,Sn){let wn=st[at];return wn===void 0?(wn={id:Gt.id,object:Gt,geometry:jt,material:qt,groupOrder:Kt,renderOrder:Gt.renderOrder,z:An,group:Sn},st[at]=wn):(wn.id=Gt.id,wn.object=Gt,wn.geometry=jt,wn.material=qt,wn.groupOrder=Kt,wn.renderOrder=Gt.renderOrder,wn.z=An,wn.group=Sn),at++,wn}function Lt(Gt,jt,qt,Kt,An,Sn){const wn=Tt(Gt,jt,qt,Kt,An,Sn);qt.transmission>0?vt.push(wn):qt.transparent===!0?wt.push(wn):pt.push(wn)}function Ft(Gt,jt,qt,Kt,An,Sn){const wn=Tt(Gt,jt,qt,Kt,An,Sn);qt.transmission>0?vt.unshift(wn):qt.transparent===!0?wt.unshift(wn):pt.unshift(wn)}function Ct(Gt,jt){pt.length>1&&pt.sort(Gt||painterSortStable),vt.length>1&&vt.sort(jt||reversePainterSortStable),wt.length>1&&wt.sort(jt||reversePainterSortStable)}function Ht(){for(let Gt=at,jt=st.length;Gt<jt;Gt++){const qt=st[Gt];if(qt.id===null)break;qt.id=null,qt.object=null,qt.geometry=null,qt.material=null,qt.group=null}}return{opaque:pt,transmissive:vt,transparent:wt,init:$t,push:Lt,unshift:Ft,finish:Ht,sort:Ct}}function WebGLRenderLists(){let st=new WeakMap;function at(vt,wt){const $t=st.get(vt);let Tt;return $t===void 0?(Tt=new WebGLRenderList,st.set(vt,[Tt])):wt>=$t.length?(Tt=new WebGLRenderList,$t.push(Tt)):Tt=$t[wt],Tt}function pt(){st=new WeakMap}return{get:at,dispose:pt}}function UniformsCache(){const st={};return{get:function(at){if(st[at.id]!==void 0)return st[at.id];let pt;switch(at.type){case"DirectionalLight":pt={direction:new Vector3,color:new Color$1};break;case"SpotLight":pt={position:new Vector3,direction:new Vector3,color:new Color$1,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":pt={position:new Vector3,color:new Color$1,distance:0,decay:0};break;case"HemisphereLight":pt={direction:new Vector3,skyColor:new Color$1,groundColor:new Color$1};break;case"RectAreaLight":pt={color:new Color$1,position:new Vector3,halfWidth:new Vector3,halfHeight:new Vector3};break}return st[at.id]=pt,pt}}}function ShadowUniformsCache(){const st={};return{get:function(at){if(st[at.id]!==void 0)return st[at.id];let pt;switch(at.type){case"DirectionalLight":pt={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"SpotLight":pt={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"PointLight":pt={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2,shadowCameraNear:1,shadowCameraFar:1e3};break}return st[at.id]=pt,pt}}}let nextVersion=0;function shadowCastingAndTexturingLightsFirst(st,at){return(at.castShadow?2:0)-(st.castShadow?2:0)+(at.map?1:0)-(st.map?1:0)}function WebGLLights(st,at){const pt=new UniformsCache,vt=ShadowUniformsCache(),wt={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let Ht=0;Ht<9;Ht++)wt.probe.push(new Vector3);const $t=new Vector3,Tt=new Matrix4,Lt=new Matrix4;function Ft(Ht,Gt){let jt=0,qt=0,Kt=0;for(let f0=0;f0<9;f0++)wt.probe[f0].set(0,0,0);let An=0,Sn=0,wn=0,In=0,tr=0,rr=0,Hr=0,qr=0,Zr=0,Bo=0,Xo=0;Ht.sort(shadowCastingAndTexturingLightsFirst);const Kr=Gt===!0?Math.PI:1;for(let f0=0,x0=Ht.length;f0<x0;f0++){const l0=Ht[f0],T0=l0.color,t0=l0.intensity,E0=l0.distance,n0=l0.shadow&&l0.shadow.map?l0.shadow.map.texture:null;if(l0.isAmbientLight)jt+=T0.r*t0*Kr,qt+=T0.g*t0*Kr,Kt+=T0.b*t0*Kr;else if(l0.isLightProbe){for(let m0=0;m0<9;m0++)wt.probe[m0].addScaledVector(l0.sh.coefficients[m0],t0);Xo++}else if(l0.isDirectionalLight){const m0=pt.get(l0);if(m0.color.copy(l0.color).multiplyScalar(l0.intensity*Kr),l0.castShadow){const h0=l0.shadow,a0=vt.get(l0);a0.shadowBias=h0.bias,a0.shadowNormalBias=h0.normalBias,a0.shadowRadius=h0.radius,a0.shadowMapSize=h0.mapSize,wt.directionalShadow[An]=a0,wt.directionalShadowMap[An]=n0,wt.directionalShadowMatrix[An]=l0.shadow.matrix,rr++}wt.directional[An]=m0,An++}else if(l0.isSpotLight){const m0=pt.get(l0);m0.position.setFromMatrixPosition(l0.matrixWorld),m0.color.copy(T0).multiplyScalar(t0*Kr),m0.distance=E0,m0.coneCos=Math.cos(l0.angle),m0.penumbraCos=Math.cos(l0.angle*(1-l0.penumbra)),m0.decay=l0.decay,wt.spot[wn]=m0;const h0=l0.shadow;if(l0.map&&(wt.spotLightMap[Zr]=l0.map,Zr++,h0.updateMatrices(l0),l0.castShadow&&Bo++),wt.spotLightMatrix[wn]=h0.matrix,l0.castShadow){const a0=vt.get(l0);a0.shadowBias=h0.bias,a0.shadowNormalBias=h0.normalBias,a0.shadowRadius=h0.radius,a0.shadowMapSize=h0.mapSize,wt.spotShadow[wn]=a0,wt.spotShadowMap[wn]=n0,qr++}wn++}else if(l0.isRectAreaLight){const m0=pt.get(l0);m0.color.copy(T0).multiplyScalar(t0),m0.halfWidth.set(l0.width*.5,0,0),m0.halfHeight.set(0,l0.height*.5,0),wt.rectArea[In]=m0,In++}else if(l0.isPointLight){const m0=pt.get(l0);if(m0.color.copy(l0.color).multiplyScalar(l0.intensity*Kr),m0.distance=l0.distance,m0.decay=l0.decay,l0.castShadow){const h0=l0.shadow,a0=vt.get(l0);a0.shadowBias=h0.bias,a0.shadowNormalBias=h0.normalBias,a0.shadowRadius=h0.radius,a0.shadowMapSize=h0.mapSize,a0.shadowCameraNear=h0.camera.near,a0.shadowCameraFar=h0.camera.far,wt.pointShadow[Sn]=a0,wt.pointShadowMap[Sn]=n0,wt.pointShadowMatrix[Sn]=l0.shadow.matrix,Hr++}wt.point[Sn]=m0,Sn++}else if(l0.isHemisphereLight){const m0=pt.get(l0);m0.skyColor.copy(l0.color).multiplyScalar(t0*Kr),m0.groundColor.copy(l0.groundColor).multiplyScalar(t0*Kr),wt.hemi[tr]=m0,tr++}}In>0&&(at.isWebGL2?st.has("OES_texture_float_linear")===!0?(wt.rectAreaLTC1=UniformsLib.LTC_FLOAT_1,wt.rectAreaLTC2=UniformsLib.LTC_FLOAT_2):(wt.rectAreaLTC1=UniformsLib.LTC_HALF_1,wt.rectAreaLTC2=UniformsLib.LTC_HALF_2):st.has("OES_texture_float_linear")===!0?(wt.rectAreaLTC1=UniformsLib.LTC_FLOAT_1,wt.rectAreaLTC2=UniformsLib.LTC_FLOAT_2):st.has("OES_texture_half_float_linear")===!0?(wt.rectAreaLTC1=UniformsLib.LTC_HALF_1,wt.rectAreaLTC2=UniformsLib.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),wt.ambient[0]=jt,wt.ambient[1]=qt,wt.ambient[2]=Kt;const ko=wt.hash;(ko.directionalLength!==An||ko.pointLength!==Sn||ko.spotLength!==wn||ko.rectAreaLength!==In||ko.hemiLength!==tr||ko.numDirectionalShadows!==rr||ko.numPointShadows!==Hr||ko.numSpotShadows!==qr||ko.numSpotMaps!==Zr||ko.numLightProbes!==Xo)&&(wt.directional.length=An,wt.spot.length=wn,wt.rectArea.length=In,wt.point.length=Sn,wt.hemi.length=tr,wt.directionalShadow.length=rr,wt.directionalShadowMap.length=rr,wt.pointShadow.length=Hr,wt.pointShadowMap.length=Hr,wt.spotShadow.length=qr,wt.spotShadowMap.length=qr,wt.directionalShadowMatrix.length=rr,wt.pointShadowMatrix.length=Hr,wt.spotLightMatrix.length=qr+Zr-Bo,wt.spotLightMap.length=Zr,wt.numSpotLightShadowsWithMaps=Bo,wt.numLightProbes=Xo,ko.directionalLength=An,ko.pointLength=Sn,ko.spotLength=wn,ko.rectAreaLength=In,ko.hemiLength=tr,ko.numDirectionalShadows=rr,ko.numPointShadows=Hr,ko.numSpotShadows=qr,ko.numSpotMaps=Zr,ko.numLightProbes=Xo,wt.version=nextVersion++)}function Ct(Ht,Gt){let jt=0,qt=0,Kt=0,An=0,Sn=0;const wn=Gt.matrixWorldInverse;for(let In=0,tr=Ht.length;In<tr;In++){const rr=Ht[In];if(rr.isDirectionalLight){const Hr=wt.directional[jt];Hr.direction.setFromMatrixPosition(rr.matrixWorld),$t.setFromMatrixPosition(rr.target.matrixWorld),Hr.direction.sub($t),Hr.direction.transformDirection(wn),jt++}else if(rr.isSpotLight){const Hr=wt.spot[Kt];Hr.position.setFromMatrixPosition(rr.matrixWorld),Hr.position.applyMatrix4(wn),Hr.direction.setFromMatrixPosition(rr.matrixWorld),$t.setFromMatrixPosition(rr.target.matrixWorld),Hr.direction.sub($t),Hr.direction.transformDirection(wn),Kt++}else if(rr.isRectAreaLight){const Hr=wt.rectArea[An];Hr.position.setFromMatrixPosition(rr.matrixWorld),Hr.position.applyMatrix4(wn),Lt.identity(),Tt.copy(rr.matrixWorld),Tt.premultiply(wn),Lt.extractRotation(Tt),Hr.halfWidth.set(rr.width*.5,0,0),Hr.halfHeight.set(0,rr.height*.5,0),Hr.halfWidth.applyMatrix4(Lt),Hr.halfHeight.applyMatrix4(Lt),An++}else if(rr.isPointLight){const Hr=wt.point[qt];Hr.position.setFromMatrixPosition(rr.matrixWorld),Hr.position.applyMatrix4(wn),qt++}else if(rr.isHemisphereLight){const Hr=wt.hemi[Sn];Hr.direction.setFromMatrixPosition(rr.matrixWorld),Hr.direction.transformDirection(wn),Sn++}}}return{setup:Ft,setupView:Ct,state:wt}}function WebGLRenderState(st,at){const pt=new WebGLLights(st,at),vt=[],wt=[];function $t(){vt.length=0,wt.length=0}function Tt(Gt){vt.push(Gt)}function Lt(Gt){wt.push(Gt)}function Ft(Gt){pt.setup(vt,Gt)}function Ct(Gt){pt.setupView(vt,Gt)}return{init:$t,state:{lightsArray:vt,shadowsArray:wt,lights:pt},setupLights:Ft,setupLightsView:Ct,pushLight:Tt,pushShadow:Lt}}function WebGLRenderStates(st,at){let pt=new WeakMap;function vt($t,Tt=0){const Lt=pt.get($t);let Ft;return Lt===void 0?(Ft=new WebGLRenderState(st,at),pt.set($t,[Ft])):Tt>=Lt.length?(Ft=new WebGLRenderState(st,at),Lt.push(Ft)):Ft=Lt[Tt],Ft}function wt(){pt=new WeakMap}return{get:vt,dispose:wt}}class MeshDepthMaterial extends Material{constructor(at){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=BasicDepthPacking,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(at)}copy(at){return super.copy(at),this.depthPacking=at.depthPacking,this.map=at.map,this.alphaMap=at.alphaMap,this.displacementMap=at.displacementMap,this.displacementScale=at.displacementScale,this.displacementBias=at.displacementBias,this.wireframe=at.wireframe,this.wireframeLinewidth=at.wireframeLinewidth,this}}class MeshDistanceMaterial extends Material{constructor(at){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(at)}copy(at){return super.copy(at),this.map=at.map,this.alphaMap=at.alphaMap,this.displacementMap=at.displacementMap,this.displacementScale=at.displacementScale,this.displacementBias=at.displacementBias,this}}const vertex=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,fragment=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function WebGLShadowMap(st,at,pt){let vt=new Frustum;const wt=new Vector2,$t=new Vector2,Tt=new Vector4,Lt=new MeshDepthMaterial({depthPacking:RGBADepthPacking}),Ft=new MeshDistanceMaterial,Ct={},Ht=pt.maxTextureSize,Gt={[FrontSide]:BackSide,[BackSide]:FrontSide,[DoubleSide]:DoubleSide},jt=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2},radius:{value:4}},vertexShader:vertex,fragmentShader:fragment}),qt=jt.clone();qt.defines.HORIZONTAL_PASS=1;const Kt=new BufferGeometry;Kt.setAttribute("position",new BufferAttribute(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const An=new Mesh(Kt,jt),Sn=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=PCFShadowMap;let wn=this.type;this.render=function(qr,Zr,Bo){if(Sn.enabled===!1||Sn.autoUpdate===!1&&Sn.needsUpdate===!1||qr.length===0)return;const Xo=st.getRenderTarget(),Kr=st.getActiveCubeFace(),ko=st.getActiveMipmapLevel(),f0=st.state;f0.setBlending(NoBlending),f0.buffers.color.setClear(1,1,1,1),f0.buffers.depth.setTest(!0),f0.setScissorTest(!1);const x0=wn!==VSMShadowMap&&this.type===VSMShadowMap,l0=wn===VSMShadowMap&&this.type!==VSMShadowMap;for(let T0=0,t0=qr.length;T0<t0;T0++){const E0=qr[T0],n0=E0.shadow;if(n0===void 0){console.warn("THREE.WebGLShadowMap:",E0,"has no shadow.");continue}if(n0.autoUpdate===!1&&n0.needsUpdate===!1)continue;wt.copy(n0.mapSize);const m0=n0.getFrameExtents();if(wt.multiply(m0),$t.copy(n0.mapSize),(wt.x>Ht||wt.y>Ht)&&(wt.x>Ht&&($t.x=Math.floor(Ht/m0.x),wt.x=$t.x*m0.x,n0.mapSize.x=$t.x),wt.y>Ht&&($t.y=Math.floor(Ht/m0.y),wt.y=$t.y*m0.y,n0.mapSize.y=$t.y)),n0.map===null||x0===!0||l0===!0){const a0=this.type!==VSMShadowMap?{minFilter:NearestFilter,magFilter:NearestFilter}:{};n0.map!==null&&n0.map.dispose(),n0.map=new WebGLRenderTarget(wt.x,wt.y,a0),n0.map.texture.name=E0.name+".shadowMap",n0.camera.updateProjectionMatrix()}st.setRenderTarget(n0.map),st.clear();const h0=n0.getViewportCount();for(let a0=0;a0<h0;a0++){const P0=n0.getViewport(a0);Tt.set($t.x*P0.x,$t.y*P0.y,$t.x*P0.z,$t.y*P0.w),f0.viewport(Tt),n0.updateMatrices(E0,a0),vt=n0.getFrustum(),rr(Zr,Bo,n0.camera,E0,this.type)}n0.isPointLightShadow!==!0&&this.type===VSMShadowMap&&In(n0,Bo),n0.needsUpdate=!1}wn=this.type,Sn.needsUpdate=!1,st.setRenderTarget(Xo,Kr,ko)};function In(qr,Zr){const Bo=at.update(An);jt.defines.VSM_SAMPLES!==qr.blurSamples&&(jt.defines.VSM_SAMPLES=qr.blurSamples,qt.defines.VSM_SAMPLES=qr.blurSamples,jt.needsUpdate=!0,qt.needsUpdate=!0),qr.mapPass===null&&(qr.mapPass=new WebGLRenderTarget(wt.x,wt.y)),jt.uniforms.shadow_pass.value=qr.map.texture,jt.uniforms.resolution.value=qr.mapSize,jt.uniforms.radius.value=qr.radius,st.setRenderTarget(qr.mapPass),st.clear(),st.renderBufferDirect(Zr,null,Bo,jt,An,null),qt.uniforms.shadow_pass.value=qr.mapPass.texture,qt.uniforms.resolution.value=qr.mapSize,qt.uniforms.radius.value=qr.radius,st.setRenderTarget(qr.map),st.clear(),st.renderBufferDirect(Zr,null,Bo,qt,An,null)}function tr(qr,Zr,Bo,Xo){let Kr=null;const ko=Bo.isPointLight===!0?qr.customDistanceMaterial:qr.customDepthMaterial;if(ko!==void 0)Kr=ko;else if(Kr=Bo.isPointLight===!0?Ft:Lt,st.localClippingEnabled&&Zr.clipShadows===!0&&Array.isArray(Zr.clippingPlanes)&&Zr.clippingPlanes.length!==0||Zr.displacementMap&&Zr.displacementScale!==0||Zr.alphaMap&&Zr.alphaTest>0||Zr.map&&Zr.alphaTest>0){const f0=Kr.uuid,x0=Zr.uuid;let l0=Ct[f0];l0===void 0&&(l0={},Ct[f0]=l0);let T0=l0[x0];T0===void 0&&(T0=Kr.clone(),l0[x0]=T0,Zr.addEventListener("dispose",Hr)),Kr=T0}if(Kr.visible=Zr.visible,Kr.wireframe=Zr.wireframe,Xo===VSMShadowMap?Kr.side=Zr.shadowSide!==null?Zr.shadowSide:Zr.side:Kr.side=Zr.shadowSide!==null?Zr.shadowSide:Gt[Zr.side],Kr.alphaMap=Zr.alphaMap,Kr.alphaTest=Zr.alphaTest,Kr.map=Zr.map,Kr.clipShadows=Zr.clipShadows,Kr.clippingPlanes=Zr.clippingPlanes,Kr.clipIntersection=Zr.clipIntersection,Kr.displacementMap=Zr.displacementMap,Kr.displacementScale=Zr.displacementScale,Kr.displacementBias=Zr.displacementBias,Kr.wireframeLinewidth=Zr.wireframeLinewidth,Kr.linewidth=Zr.linewidth,Bo.isPointLight===!0&&Kr.isMeshDistanceMaterial===!0){const f0=st.properties.get(Kr);f0.light=Bo}return Kr}function rr(qr,Zr,Bo,Xo,Kr){if(qr.visible===!1)return;if(qr.layers.test(Zr.layers)&&(qr.isMesh||qr.isLine||qr.isPoints)&&(qr.castShadow||qr.receiveShadow&&Kr===VSMShadowMap)&&(!qr.frustumCulled||vt.intersectsObject(qr))){qr.modelViewMatrix.multiplyMatrices(Bo.matrixWorldInverse,qr.matrixWorld);const x0=at.update(qr),l0=qr.material;if(Array.isArray(l0)){const T0=x0.groups;for(let t0=0,E0=T0.length;t0<E0;t0++){const n0=T0[t0],m0=l0[n0.materialIndex];if(m0&&m0.visible){const h0=tr(qr,m0,Xo,Kr);qr.onBeforeShadow(st,qr,Zr,Bo,x0,h0,n0),st.renderBufferDirect(Bo,null,x0,h0,qr,n0),qr.onAfterShadow(st,qr,Zr,Bo,x0,h0,n0)}}}else if(l0.visible){const T0=tr(qr,l0,Xo,Kr);qr.onBeforeShadow(st,qr,Zr,Bo,x0,T0,null),st.renderBufferDirect(Bo,null,x0,T0,qr,null),qr.onAfterShadow(st,qr,Zr,Bo,x0,T0,null)}}const f0=qr.children;for(let x0=0,l0=f0.length;x0<l0;x0++)rr(f0[x0],Zr,Bo,Xo,Kr)}function Hr(qr){qr.target.removeEventListener("dispose",Hr);for(const Bo in Ct){const Xo=Ct[Bo],Kr=qr.target.uuid;Kr in Xo&&(Xo[Kr].dispose(),delete Xo[Kr])}}}function WebGLState(st,at,pt){const vt=pt.isWebGL2;function wt(){let i0=!1;const k0=new Vector4;let $0=null;const ty=new Vector4(0,0,0,0);return{setMask:function(my){$0!==my&&!i0&&(st.colorMask(my,my,my,my),$0=my)},setLocked:function(my){i0=my},setClear:function(my,ev,vv,Tv,Rv){Rv===!0&&(my*=Tv,ev*=Tv,vv*=Tv),k0.set(my,ev,vv,Tv),ty.equals(k0)===!1&&(st.clearColor(my,ev,vv,Tv),ty.copy(k0))},reset:function(){i0=!1,$0=null,ty.set(-1,0,0,0)}}}function $t(){let i0=!1,k0=null,$0=null,ty=null;return{setTest:function(my){my?My(st.DEPTH_TEST):Wy(st.DEPTH_TEST)},setMask:function(my){k0!==my&&!i0&&(st.depthMask(my),k0=my)},setFunc:function(my){if($0!==my){switch(my){case NeverDepth:st.depthFunc(st.NEVER);break;case AlwaysDepth:st.depthFunc(st.ALWAYS);break;case LessDepth:st.depthFunc(st.LESS);break;case LessEqualDepth:st.depthFunc(st.LEQUAL);break;case EqualDepth:st.depthFunc(st.EQUAL);break;case GreaterEqualDepth:st.depthFunc(st.GEQUAL);break;case GreaterDepth:st.depthFunc(st.GREATER);break;case NotEqualDepth:st.depthFunc(st.NOTEQUAL);break;default:st.depthFunc(st.LEQUAL)}$0=my}},setLocked:function(my){i0=my},setClear:function(my){ty!==my&&(st.clearDepth(my),ty=my)},reset:function(){i0=!1,k0=null,$0=null,ty=null}}}function Tt(){let i0=!1,k0=null,$0=null,ty=null,my=null,ev=null,vv=null,Tv=null,Rv=null;return{setTest:function(Lv){i0||(Lv?My(st.STENCIL_TEST):Wy(st.STENCIL_TEST))},setMask:function(Lv){k0!==Lv&&!i0&&(st.stencilMask(Lv),k0=Lv)},setFunc:function(Lv,Yv,X0){($0!==Lv||ty!==Yv||my!==X0)&&(st.stencilFunc(Lv,Yv,X0),$0=Lv,ty=Yv,my=X0)},setOp:function(Lv,Yv,X0){(ev!==Lv||vv!==Yv||Tv!==X0)&&(st.stencilOp(Lv,Yv,X0),ev=Lv,vv=Yv,Tv=X0)},setLocked:function(Lv){i0=Lv},setClear:function(Lv){Rv!==Lv&&(st.clearStencil(Lv),Rv=Lv)},reset:function(){i0=!1,k0=null,$0=null,ty=null,my=null,ev=null,vv=null,Tv=null,Rv=null}}}const Lt=new wt,Ft=new $t,Ct=new Tt,Ht=new WeakMap,Gt=new WeakMap;let jt={},qt={},Kt=new WeakMap,An=[],Sn=null,wn=!1,In=null,tr=null,rr=null,Hr=null,qr=null,Zr=null,Bo=null,Xo=new Color$1(0,0,0),Kr=0,ko=!1,f0=null,x0=null,l0=null,T0=null,t0=null;const E0=st.getParameter(st.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let n0=!1,m0=0;const h0=st.getParameter(st.VERSION);h0.indexOf("WebGL")!==-1?(m0=parseFloat(/^WebGL (\d)/.exec(h0)[1]),n0=m0>=1):h0.indexOf("OpenGL ES")!==-1&&(m0=parseFloat(/^OpenGL ES (\d)/.exec(h0)[1]),n0=m0>=2);let a0=null,P0={};const V0=st.getParameter(st.SCISSOR_BOX),B0=st.getParameter(st.VIEWPORT),W0=new Vector4().fromArray(V0),K0=new Vector4().fromArray(B0);function Ty(i0,k0,$0,ty){const my=new Uint8Array(4),ev=st.createTexture();st.bindTexture(i0,ev),st.texParameteri(i0,st.TEXTURE_MIN_FILTER,st.NEAREST),st.texParameteri(i0,st.TEXTURE_MAG_FILTER,st.NEAREST);for(let vv=0;vv<$0;vv++)vt&&(i0===st.TEXTURE_3D||i0===st.TEXTURE_2D_ARRAY)?st.texImage3D(k0,0,st.RGBA,1,1,ty,0,st.RGBA,st.UNSIGNED_BYTE,my):st.texImage2D(k0+vv,0,st.RGBA,1,1,0,st.RGBA,st.UNSIGNED_BYTE,my);return ev}const $y={};$y[st.TEXTURE_2D]=Ty(st.TEXTURE_2D,st.TEXTURE_2D,1),$y[st.TEXTURE_CUBE_MAP]=Ty(st.TEXTURE_CUBE_MAP,st.TEXTURE_CUBE_MAP_POSITIVE_X,6),vt&&($y[st.TEXTURE_2D_ARRAY]=Ty(st.TEXTURE_2D_ARRAY,st.TEXTURE_2D_ARRAY,1,1),$y[st.TEXTURE_3D]=Ty(st.TEXTURE_3D,st.TEXTURE_3D,1,1)),Lt.setClear(0,0,0,1),Ft.setClear(1),Ct.setClear(0),My(st.DEPTH_TEST),Ft.setFunc(LessEqualDepth),Fy(!1),qy(CullFaceBack),My(st.CULL_FACE),uy(NoBlending);function My(i0){jt[i0]!==!0&&(st.enable(i0),jt[i0]=!0)}function Wy(i0){jt[i0]!==!1&&(st.disable(i0),jt[i0]=!1)}function Ey(i0,k0){return qt[i0]!==k0?(st.bindFramebuffer(i0,k0),qt[i0]=k0,vt&&(i0===st.DRAW_FRAMEBUFFER&&(qt[st.FRAMEBUFFER]=k0),i0===st.FRAMEBUFFER&&(qt[st.DRAW_FRAMEBUFFER]=k0)),!0):!1}function _0(i0,k0){let $0=An,ty=!1;if(i0){$0=Kt.get(k0),$0===void 0&&($0=[],Kt.set(k0,$0));const my=i0.textures;if($0.length!==my.length||$0[0]!==st.COLOR_ATTACHMENT0){for(let ev=0,vv=my.length;ev<vv;ev++)$0[ev]=st.COLOR_ATTACHMENT0+ev;$0.length=my.length,ty=!0}}else $0[0]!==st.BACK&&($0[0]=st.BACK,ty=!0);if(ty)if(pt.isWebGL2)st.drawBuffers($0);else if(at.has("WEBGL_draw_buffers")===!0)at.get("WEBGL_draw_buffers").drawBuffersWEBGL($0);else throw new Error("THREE.WebGLState: Usage of gl.drawBuffers() require WebGL2 or WEBGL_draw_buffers extension")}function ay(i0){return Sn!==i0?(st.useProgram(i0),Sn=i0,!0):!1}const J0={[AddEquation]:st.FUNC_ADD,[SubtractEquation]:st.FUNC_SUBTRACT,[ReverseSubtractEquation]:st.FUNC_REVERSE_SUBTRACT};if(vt)J0[MinEquation]=st.MIN,J0[MaxEquation]=st.MAX;else{const i0=at.get("EXT_blend_minmax");i0!==null&&(J0[MinEquation]=i0.MIN_EXT,J0[MaxEquation]=i0.MAX_EXT)}const yy={[ZeroFactor]:st.ZERO,[OneFactor]:st.ONE,[SrcColorFactor]:st.SRC_COLOR,[SrcAlphaFactor]:st.SRC_ALPHA,[SrcAlphaSaturateFactor]:st.SRC_ALPHA_SATURATE,[DstColorFactor]:st.DST_COLOR,[DstAlphaFactor]:st.DST_ALPHA,[OneMinusSrcColorFactor]:st.ONE_MINUS_SRC_COLOR,[OneMinusSrcAlphaFactor]:st.ONE_MINUS_SRC_ALPHA,[OneMinusDstColorFactor]:st.ONE_MINUS_DST_COLOR,[OneMinusDstAlphaFactor]:st.ONE_MINUS_DST_ALPHA,[ConstantColorFactor]:st.CONSTANT_COLOR,[OneMinusConstantColorFactor]:st.ONE_MINUS_CONSTANT_COLOR,[ConstantAlphaFactor]:st.CONSTANT_ALPHA,[OneMinusConstantAlphaFactor]:st.ONE_MINUS_CONSTANT_ALPHA};function uy(i0,k0,$0,ty,my,ev,vv,Tv,Rv,Lv){if(i0===NoBlending){wn===!0&&(Wy(st.BLEND),wn=!1);return}if(wn===!1&&(My(st.BLEND),wn=!0),i0!==CustomBlending){if(i0!==In||Lv!==ko){if((tr!==AddEquation||qr!==AddEquation)&&(st.blendEquation(st.FUNC_ADD),tr=AddEquation,qr=AddEquation),Lv)switch(i0){case NormalBlending:st.blendFuncSeparate(st.ONE,st.ONE_MINUS_SRC_ALPHA,st.ONE,st.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:st.blendFunc(st.ONE,st.ONE);break;case SubtractiveBlending:st.blendFuncSeparate(st.ZERO,st.ONE_MINUS_SRC_COLOR,st.ZERO,st.ONE);break;case MultiplyBlending:st.blendFuncSeparate(st.ZERO,st.SRC_COLOR,st.ZERO,st.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",i0);break}else switch(i0){case NormalBlending:st.blendFuncSeparate(st.SRC_ALPHA,st.ONE_MINUS_SRC_ALPHA,st.ONE,st.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:st.blendFunc(st.SRC_ALPHA,st.ONE);break;case SubtractiveBlending:st.blendFuncSeparate(st.ZERO,st.ONE_MINUS_SRC_COLOR,st.ZERO,st.ONE);break;case MultiplyBlending:st.blendFunc(st.ZERO,st.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",i0);break}rr=null,Hr=null,Zr=null,Bo=null,Xo.set(0,0,0),Kr=0,In=i0,ko=Lv}return}my=my||k0,ev=ev||$0,vv=vv||ty,(k0!==tr||my!==qr)&&(st.blendEquationSeparate(J0[k0],J0[my]),tr=k0,qr=my),($0!==rr||ty!==Hr||ev!==Zr||vv!==Bo)&&(st.blendFuncSeparate(yy[$0],yy[ty],yy[ev],yy[vv]),rr=$0,Hr=ty,Zr=ev,Bo=vv),(Tv.equals(Xo)===!1||Rv!==Kr)&&(st.blendColor(Tv.r,Tv.g,Tv.b,Rv),Xo.copy(Tv),Kr=Rv),In=i0,ko=!1}function Dy(i0,k0){i0.side===DoubleSide?Wy(st.CULL_FACE):My(st.CULL_FACE);let $0=i0.side===BackSide;k0&&($0=!$0),Fy($0),i0.blending===NormalBlending&&i0.transparent===!1?uy(NoBlending):uy(i0.blending,i0.blendEquation,i0.blendSrc,i0.blendDst,i0.blendEquationAlpha,i0.blendSrcAlpha,i0.blendDstAlpha,i0.blendColor,i0.blendAlpha,i0.premultipliedAlpha),Ft.setFunc(i0.depthFunc),Ft.setTest(i0.depthTest),Ft.setMask(i0.depthWrite),Lt.setMask(i0.colorWrite);const ty=i0.stencilWrite;Ct.setTest(ty),ty&&(Ct.setMask(i0.stencilWriteMask),Ct.setFunc(i0.stencilFunc,i0.stencilRef,i0.stencilFuncMask),Ct.setOp(i0.stencilFail,i0.stencilZFail,i0.stencilZPass)),y0(i0.polygonOffset,i0.polygonOffsetFactor,i0.polygonOffsetUnits),i0.alphaToCoverage===!0?My(st.SAMPLE_ALPHA_TO_COVERAGE):Wy(st.SAMPLE_ALPHA_TO_COVERAGE)}function Fy(i0){f0!==i0&&(i0?st.frontFace(st.CW):st.frontFace(st.CCW),f0=i0)}function qy(i0){i0!==CullFaceNone?(My(st.CULL_FACE),i0!==x0&&(i0===CullFaceBack?st.cullFace(st.BACK):i0===CullFaceFront?st.cullFace(st.FRONT):st.cullFace(st.FRONT_AND_BACK))):Wy(st.CULL_FACE),x0=i0}function rv(i0){i0!==l0&&(n0&&st.lineWidth(i0),l0=i0)}function y0(i0,k0,$0){i0?(My(st.POLYGON_OFFSET_FILL),(T0!==k0||t0!==$0)&&(st.polygonOffset(k0,$0),T0=k0,t0=$0)):Wy(st.POLYGON_OFFSET_FILL)}function r0(i0){i0?My(st.SCISSOR_TEST):Wy(st.SCISSOR_TEST)}function M0(i0){i0===void 0&&(i0=st.TEXTURE0+E0-1),a0!==i0&&(st.activeTexture(i0),a0=i0)}function G0(i0,k0,$0){$0===void 0&&(a0===null?$0=st.TEXTURE0+E0-1:$0=a0);let ty=P0[$0];ty===void 0&&(ty={type:void 0,texture:void 0},P0[$0]=ty),(ty.type!==i0||ty.texture!==k0)&&(a0!==$0&&(st.activeTexture($0),a0=$0),st.bindTexture(i0,k0||$y[i0]),ty.type=i0,ty.texture=k0)}function sy(){const i0=P0[a0];i0!==void 0&&i0.type!==void 0&&(st.bindTexture(i0.type,null),i0.type=void 0,i0.texture=void 0)}function dy(){try{st.compressedTexImage2D.apply(st,arguments)}catch(i0){console.error("THREE.WebGLState:",i0)}}function Vy(){try{st.compressedTexImage3D.apply(st,arguments)}catch(i0){console.error("THREE.WebGLState:",i0)}}function Xy(){try{st.texSubImage2D.apply(st,arguments)}catch(i0){console.error("THREE.WebGLState:",i0)}}function hy(){try{st.texSubImage3D.apply(st,arguments)}catch(i0){console.error("THREE.WebGLState:",i0)}}function Ly(){try{st.compressedTexSubImage2D.apply(st,arguments)}catch(i0){console.error("THREE.WebGLState:",i0)}}function Py(){try{st.compressedTexSubImage3D.apply(st,arguments)}catch(i0){console.error("THREE.WebGLState:",i0)}}function Sy(){try{st.texStorage2D.apply(st,arguments)}catch(i0){console.error("THREE.WebGLState:",i0)}}function Ev(){try{st.texStorage3D.apply(st,arguments)}catch(i0){console.error("THREE.WebGLState:",i0)}}function Qy(){try{st.texImage2D.apply(st,arguments)}catch(i0){console.error("THREE.WebGLState:",i0)}}function cy(){try{st.texImage3D.apply(st,arguments)}catch(i0){console.error("THREE.WebGLState:",i0)}}function C0(i0){W0.equals(i0)===!1&&(st.scissor(i0.x,i0.y,i0.z,i0.w),W0.copy(i0))}function U0(i0){K0.equals(i0)===!1&&(st.viewport(i0.x,i0.y,i0.z,i0.w),K0.copy(i0))}function xy(i0,k0){let $0=Gt.get(k0);$0===void 0&&($0=new WeakMap,Gt.set(k0,$0));let ty=$0.get(i0);ty===void 0&&(ty=st.getUniformBlockIndex(k0,i0.name),$0.set(i0,ty))}function o0(i0,k0){const ty=Gt.get(k0).get(i0);Ht.get(k0)!==ty&&(st.uniformBlockBinding(k0,ty,i0.__bindingPointIndex),Ht.set(k0,ty))}function v0(){st.disable(st.BLEND),st.disable(st.CULL_FACE),st.disable(st.DEPTH_TEST),st.disable(st.POLYGON_OFFSET_FILL),st.disable(st.SCISSOR_TEST),st.disable(st.STENCIL_TEST),st.disable(st.SAMPLE_ALPHA_TO_COVERAGE),st.blendEquation(st.FUNC_ADD),st.blendFunc(st.ONE,st.ZERO),st.blendFuncSeparate(st.ONE,st.ZERO,st.ONE,st.ZERO),st.blendColor(0,0,0,0),st.colorMask(!0,!0,!0,!0),st.clearColor(0,0,0,0),st.depthMask(!0),st.depthFunc(st.LESS),st.clearDepth(1),st.stencilMask(4294967295),st.stencilFunc(st.ALWAYS,0,4294967295),st.stencilOp(st.KEEP,st.KEEP,st.KEEP),st.clearStencil(0),st.cullFace(st.BACK),st.frontFace(st.CCW),st.polygonOffset(0,0),st.activeTexture(st.TEXTURE0),st.bindFramebuffer(st.FRAMEBUFFER,null),vt===!0&&(st.bindFramebuffer(st.DRAW_FRAMEBUFFER,null),st.bindFramebuffer(st.READ_FRAMEBUFFER,null)),st.useProgram(null),st.lineWidth(1),st.scissor(0,0,st.canvas.width,st.canvas.height),st.viewport(0,0,st.canvas.width,st.canvas.height),jt={},a0=null,P0={},qt={},Kt=new WeakMap,An=[],Sn=null,wn=!1,In=null,tr=null,rr=null,Hr=null,qr=null,Zr=null,Bo=null,Xo=new Color$1(0,0,0),Kr=0,ko=!1,f0=null,x0=null,l0=null,T0=null,t0=null,W0.set(0,0,st.canvas.width,st.canvas.height),K0.set(0,0,st.canvas.width,st.canvas.height),Lt.reset(),Ft.reset(),Ct.reset()}return{buffers:{color:Lt,depth:Ft,stencil:Ct},enable:My,disable:Wy,bindFramebuffer:Ey,drawBuffers:_0,useProgram:ay,setBlending:uy,setMaterial:Dy,setFlipSided:Fy,setCullFace:qy,setLineWidth:rv,setPolygonOffset:y0,setScissorTest:r0,activeTexture:M0,bindTexture:G0,unbindTexture:sy,compressedTexImage2D:dy,compressedTexImage3D:Vy,texImage2D:Qy,texImage3D:cy,updateUBOMapping:xy,uniformBlockBinding:o0,texStorage2D:Sy,texStorage3D:Ev,texSubImage2D:Xy,texSubImage3D:hy,compressedTexSubImage2D:Ly,compressedTexSubImage3D:Py,scissor:C0,viewport:U0,reset:v0}}function WebGLTextures(st,at,pt,vt,wt,$t,Tt){const Lt=wt.isWebGL2,Ft=at.has("WEBGL_multisampled_render_to_texture")?at.get("WEBGL_multisampled_render_to_texture"):null,Ct=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),Ht=new Vector2,Gt=new WeakMap;let jt;const qt=new WeakMap;let Kt=!1;try{Kt=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function An(y0,r0){return Kt?new OffscreenCanvas(y0,r0):createElementNS("canvas")}function Sn(y0,r0,M0,G0){let sy=1;const dy=rv(y0);if((dy.width>G0||dy.height>G0)&&(sy=G0/Math.max(dy.width,dy.height)),sy<1||r0===!0)if(typeof HTMLImageElement<"u"&&y0 instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&y0 instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&y0 instanceof ImageBitmap||typeof VideoFrame<"u"&&y0 instanceof VideoFrame){const Vy=r0?floorPowerOfTwo:Math.floor,Xy=Vy(sy*dy.width),hy=Vy(sy*dy.height);jt===void 0&&(jt=An(Xy,hy));const Ly=M0?An(Xy,hy):jt;return Ly.width=Xy,Ly.height=hy,Ly.getContext("2d").drawImage(y0,0,0,Xy,hy),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+dy.width+"x"+dy.height+") to ("+Xy+"x"+hy+")."),Ly}else return"data"in y0&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+dy.width+"x"+dy.height+")."),y0;return y0}function wn(y0){const r0=rv(y0);return isPowerOfTwo(r0.width)&&isPowerOfTwo(r0.height)}function In(y0){return Lt?!1:y0.wrapS!==ClampToEdgeWrapping||y0.wrapT!==ClampToEdgeWrapping||y0.minFilter!==NearestFilter&&y0.minFilter!==LinearFilter}function tr(y0,r0){return y0.generateMipmaps&&r0&&y0.minFilter!==NearestFilter&&y0.minFilter!==LinearFilter}function rr(y0){st.generateMipmap(y0)}function Hr(y0,r0,M0,G0,sy=!1){if(Lt===!1)return r0;if(y0!==null){if(st[y0]!==void 0)return st[y0];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+y0+"'")}let dy=r0;if(r0===st.RED&&(M0===st.FLOAT&&(dy=st.R32F),M0===st.HALF_FLOAT&&(dy=st.R16F),M0===st.UNSIGNED_BYTE&&(dy=st.R8)),r0===st.RED_INTEGER&&(M0===st.UNSIGNED_BYTE&&(dy=st.R8UI),M0===st.UNSIGNED_SHORT&&(dy=st.R16UI),M0===st.UNSIGNED_INT&&(dy=st.R32UI),M0===st.BYTE&&(dy=st.R8I),M0===st.SHORT&&(dy=st.R16I),M0===st.INT&&(dy=st.R32I)),r0===st.RG&&(M0===st.FLOAT&&(dy=st.RG32F),M0===st.HALF_FLOAT&&(dy=st.RG16F),M0===st.UNSIGNED_BYTE&&(dy=st.RG8)),r0===st.RG_INTEGER&&(M0===st.UNSIGNED_BYTE&&(dy=st.RG8UI),M0===st.UNSIGNED_SHORT&&(dy=st.RG16UI),M0===st.UNSIGNED_INT&&(dy=st.RG32UI),M0===st.BYTE&&(dy=st.RG8I),M0===st.SHORT&&(dy=st.RG16I),M0===st.INT&&(dy=st.RG32I)),r0===st.RGBA){const Vy=sy?LinearTransfer:ColorManagement.getTransfer(G0);M0===st.FLOAT&&(dy=st.RGBA32F),M0===st.HALF_FLOAT&&(dy=st.RGBA16F),M0===st.UNSIGNED_BYTE&&(dy=Vy===SRGBTransfer?st.SRGB8_ALPHA8:st.RGBA8),M0===st.UNSIGNED_SHORT_4_4_4_4&&(dy=st.RGBA4),M0===st.UNSIGNED_SHORT_5_5_5_1&&(dy=st.RGB5_A1)}return(dy===st.R16F||dy===st.R32F||dy===st.RG16F||dy===st.RG32F||dy===st.RGBA16F||dy===st.RGBA32F)&&at.get("EXT_color_buffer_float"),dy}function qr(y0,r0,M0){return tr(y0,M0)===!0||y0.isFramebufferTexture&&y0.minFilter!==NearestFilter&&y0.minFilter!==LinearFilter?Math.log2(Math.max(r0.width,r0.height))+1:y0.mipmaps!==void 0&&y0.mipmaps.length>0?y0.mipmaps.length:y0.isCompressedTexture&&Array.isArray(y0.image)?r0.mipmaps.length:1}function Zr(y0){return y0===NearestFilter||y0===NearestMipmapNearestFilter||y0===NearestMipmapLinearFilter?st.NEAREST:st.LINEAR}function Bo(y0){const r0=y0.target;r0.removeEventListener("dispose",Bo),Kr(r0),r0.isVideoTexture&&Gt.delete(r0)}function Xo(y0){const r0=y0.target;r0.removeEventListener("dispose",Xo),f0(r0)}function Kr(y0){const r0=vt.get(y0);if(r0.__webglInit===void 0)return;const M0=y0.source,G0=qt.get(M0);if(G0){const sy=G0[r0.__cacheKey];sy.usedTimes--,sy.usedTimes===0&&ko(y0),Object.keys(G0).length===0&&qt.delete(M0)}vt.remove(y0)}function ko(y0){const r0=vt.get(y0);st.deleteTexture(r0.__webglTexture);const M0=y0.source,G0=qt.get(M0);delete G0[r0.__cacheKey],Tt.memory.textures--}function f0(y0){const r0=vt.get(y0);if(y0.depthTexture&&y0.depthTexture.dispose(),y0.isWebGLCubeRenderTarget)for(let G0=0;G0<6;G0++){if(Array.isArray(r0.__webglFramebuffer[G0]))for(let sy=0;sy<r0.__webglFramebuffer[G0].length;sy++)st.deleteFramebuffer(r0.__webglFramebuffer[G0][sy]);else st.deleteFramebuffer(r0.__webglFramebuffer[G0]);r0.__webglDepthbuffer&&st.deleteRenderbuffer(r0.__webglDepthbuffer[G0])}else{if(Array.isArray(r0.__webglFramebuffer))for(let G0=0;G0<r0.__webglFramebuffer.length;G0++)st.deleteFramebuffer(r0.__webglFramebuffer[G0]);else st.deleteFramebuffer(r0.__webglFramebuffer);if(r0.__webglDepthbuffer&&st.deleteRenderbuffer(r0.__webglDepthbuffer),r0.__webglMultisampledFramebuffer&&st.deleteFramebuffer(r0.__webglMultisampledFramebuffer),r0.__webglColorRenderbuffer)for(let G0=0;G0<r0.__webglColorRenderbuffer.length;G0++)r0.__webglColorRenderbuffer[G0]&&st.deleteRenderbuffer(r0.__webglColorRenderbuffer[G0]);r0.__webglDepthRenderbuffer&&st.deleteRenderbuffer(r0.__webglDepthRenderbuffer)}const M0=y0.textures;for(let G0=0,sy=M0.length;G0<sy;G0++){const dy=vt.get(M0[G0]);dy.__webglTexture&&(st.deleteTexture(dy.__webglTexture),Tt.memory.textures--),vt.remove(M0[G0])}vt.remove(y0)}let x0=0;function l0(){x0=0}function T0(){const y0=x0;return y0>=wt.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+y0+" texture units while this GPU supports only "+wt.maxTextures),x0+=1,y0}function t0(y0){const r0=[];return r0.push(y0.wrapS),r0.push(y0.wrapT),r0.push(y0.wrapR||0),r0.push(y0.magFilter),r0.push(y0.minFilter),r0.push(y0.anisotropy),r0.push(y0.internalFormat),r0.push(y0.format),r0.push(y0.type),r0.push(y0.generateMipmaps),r0.push(y0.premultiplyAlpha),r0.push(y0.flipY),r0.push(y0.unpackAlignment),r0.push(y0.colorSpace),r0.join()}function E0(y0,r0){const M0=vt.get(y0);if(y0.isVideoTexture&&Fy(y0),y0.isRenderTargetTexture===!1&&y0.version>0&&M0.__version!==y0.version){const G0=y0.image;if(G0===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(G0.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{K0(M0,y0,r0);return}}pt.bindTexture(st.TEXTURE_2D,M0.__webglTexture,st.TEXTURE0+r0)}function n0(y0,r0){const M0=vt.get(y0);if(y0.version>0&&M0.__version!==y0.version){K0(M0,y0,r0);return}pt.bindTexture(st.TEXTURE_2D_ARRAY,M0.__webglTexture,st.TEXTURE0+r0)}function m0(y0,r0){const M0=vt.get(y0);if(y0.version>0&&M0.__version!==y0.version){K0(M0,y0,r0);return}pt.bindTexture(st.TEXTURE_3D,M0.__webglTexture,st.TEXTURE0+r0)}function h0(y0,r0){const M0=vt.get(y0);if(y0.version>0&&M0.__version!==y0.version){Ty(M0,y0,r0);return}pt.bindTexture(st.TEXTURE_CUBE_MAP,M0.__webglTexture,st.TEXTURE0+r0)}const a0={[RepeatWrapping]:st.REPEAT,[ClampToEdgeWrapping]:st.CLAMP_TO_EDGE,[MirroredRepeatWrapping]:st.MIRRORED_REPEAT},P0={[NearestFilter]:st.NEAREST,[NearestMipmapNearestFilter]:st.NEAREST_MIPMAP_NEAREST,[NearestMipmapLinearFilter]:st.NEAREST_MIPMAP_LINEAR,[LinearFilter]:st.LINEAR,[LinearMipmapNearestFilter]:st.LINEAR_MIPMAP_NEAREST,[LinearMipmapLinearFilter]:st.LINEAR_MIPMAP_LINEAR},V0={[NeverCompare]:st.NEVER,[AlwaysCompare]:st.ALWAYS,[LessCompare]:st.LESS,[LessEqualCompare]:st.LEQUAL,[EqualCompare]:st.EQUAL,[GreaterEqualCompare]:st.GEQUAL,[GreaterCompare]:st.GREATER,[NotEqualCompare]:st.NOTEQUAL};function B0(y0,r0,M0){if(r0.type===FloatType&&at.has("OES_texture_float_linear")===!1&&(r0.magFilter===LinearFilter||r0.magFilter===LinearMipmapNearestFilter||r0.magFilter===NearestMipmapLinearFilter||r0.magFilter===LinearMipmapLinearFilter||r0.minFilter===LinearFilter||r0.minFilter===LinearMipmapNearestFilter||r0.minFilter===NearestMipmapLinearFilter||r0.minFilter===LinearMipmapLinearFilter)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),M0?(st.texParameteri(y0,st.TEXTURE_WRAP_S,a0[r0.wrapS]),st.texParameteri(y0,st.TEXTURE_WRAP_T,a0[r0.wrapT]),(y0===st.TEXTURE_3D||y0===st.TEXTURE_2D_ARRAY)&&st.texParameteri(y0,st.TEXTURE_WRAP_R,a0[r0.wrapR]),st.texParameteri(y0,st.TEXTURE_MAG_FILTER,P0[r0.magFilter]),st.texParameteri(y0,st.TEXTURE_MIN_FILTER,P0[r0.minFilter])):(st.texParameteri(y0,st.TEXTURE_WRAP_S,st.CLAMP_TO_EDGE),st.texParameteri(y0,st.TEXTURE_WRAP_T,st.CLAMP_TO_EDGE),(y0===st.TEXTURE_3D||y0===st.TEXTURE_2D_ARRAY)&&st.texParameteri(y0,st.TEXTURE_WRAP_R,st.CLAMP_TO_EDGE),(r0.wrapS!==ClampToEdgeWrapping||r0.wrapT!==ClampToEdgeWrapping)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),st.texParameteri(y0,st.TEXTURE_MAG_FILTER,Zr(r0.magFilter)),st.texParameteri(y0,st.TEXTURE_MIN_FILTER,Zr(r0.minFilter)),r0.minFilter!==NearestFilter&&r0.minFilter!==LinearFilter&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),r0.compareFunction&&(st.texParameteri(y0,st.TEXTURE_COMPARE_MODE,st.COMPARE_REF_TO_TEXTURE),st.texParameteri(y0,st.TEXTURE_COMPARE_FUNC,V0[r0.compareFunction])),at.has("EXT_texture_filter_anisotropic")===!0){if(r0.magFilter===NearestFilter||r0.minFilter!==NearestMipmapLinearFilter&&r0.minFilter!==LinearMipmapLinearFilter||r0.type===FloatType&&at.has("OES_texture_float_linear")===!1||Lt===!1&&r0.type===HalfFloatType&&at.has("OES_texture_half_float_linear")===!1)return;if(r0.anisotropy>1||vt.get(r0).__currentAnisotropy){const G0=at.get("EXT_texture_filter_anisotropic");st.texParameterf(y0,G0.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(r0.anisotropy,wt.getMaxAnisotropy())),vt.get(r0).__currentAnisotropy=r0.anisotropy}}}function W0(y0,r0){let M0=!1;y0.__webglInit===void 0&&(y0.__webglInit=!0,r0.addEventListener("dispose",Bo));const G0=r0.source;let sy=qt.get(G0);sy===void 0&&(sy={},qt.set(G0,sy));const dy=t0(r0);if(dy!==y0.__cacheKey){sy[dy]===void 0&&(sy[dy]={texture:st.createTexture(),usedTimes:0},Tt.memory.textures++,M0=!0),sy[dy].usedTimes++;const Vy=sy[y0.__cacheKey];Vy!==void 0&&(sy[y0.__cacheKey].usedTimes--,Vy.usedTimes===0&&ko(r0)),y0.__cacheKey=dy,y0.__webglTexture=sy[dy].texture}return M0}function K0(y0,r0,M0){let G0=st.TEXTURE_2D;(r0.isDataArrayTexture||r0.isCompressedArrayTexture)&&(G0=st.TEXTURE_2D_ARRAY),r0.isData3DTexture&&(G0=st.TEXTURE_3D);const sy=W0(y0,r0),dy=r0.source;pt.bindTexture(G0,y0.__webglTexture,st.TEXTURE0+M0);const Vy=vt.get(dy);if(dy.version!==Vy.__version||sy===!0){pt.activeTexture(st.TEXTURE0+M0);const Xy=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),hy=r0.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(r0.colorSpace),Ly=r0.colorSpace===NoColorSpace||Xy===hy?st.NONE:st.BROWSER_DEFAULT_WEBGL;st.pixelStorei(st.UNPACK_FLIP_Y_WEBGL,r0.flipY),st.pixelStorei(st.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r0.premultiplyAlpha),st.pixelStorei(st.UNPACK_ALIGNMENT,r0.unpackAlignment),st.pixelStorei(st.UNPACK_COLORSPACE_CONVERSION_WEBGL,Ly);const Py=In(r0)&&wn(r0.image)===!1;let Sy=Sn(r0.image,Py,!1,wt.maxTextureSize);Sy=qy(r0,Sy);const Ev=wn(Sy)||Lt,Qy=$t.convert(r0.format,r0.colorSpace);let cy=$t.convert(r0.type),C0=Hr(r0.internalFormat,Qy,cy,r0.colorSpace,r0.isVideoTexture);B0(G0,r0,Ev);let U0;const xy=r0.mipmaps,o0=Lt&&r0.isVideoTexture!==!0&&C0!==RGB_ETC1_Format,v0=Vy.__version===void 0||sy===!0,i0=dy.dataReady,k0=qr(r0,Sy,Ev);if(r0.isDepthTexture)C0=st.DEPTH_COMPONENT,Lt?r0.type===FloatType?C0=st.DEPTH_COMPONENT32F:r0.type===UnsignedIntType?C0=st.DEPTH_COMPONENT24:r0.type===UnsignedInt248Type?C0=st.DEPTH24_STENCIL8:C0=st.DEPTH_COMPONENT16:r0.type===FloatType&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),r0.format===DepthFormat&&C0===st.DEPTH_COMPONENT&&r0.type!==UnsignedShortType&&r0.type!==UnsignedIntType&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),r0.type=UnsignedIntType,cy=$t.convert(r0.type)),r0.format===DepthStencilFormat&&C0===st.DEPTH_COMPONENT&&(C0=st.DEPTH_STENCIL,r0.type!==UnsignedInt248Type&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),r0.type=UnsignedInt248Type,cy=$t.convert(r0.type))),v0&&(o0?pt.texStorage2D(st.TEXTURE_2D,1,C0,Sy.width,Sy.height):pt.texImage2D(st.TEXTURE_2D,0,C0,Sy.width,Sy.height,0,Qy,cy,null));else if(r0.isDataTexture)if(xy.length>0&&Ev){o0&&v0&&pt.texStorage2D(st.TEXTURE_2D,k0,C0,xy[0].width,xy[0].height);for(let $0=0,ty=xy.length;$0<ty;$0++)U0=xy[$0],o0?i0&&pt.texSubImage2D(st.TEXTURE_2D,$0,0,0,U0.width,U0.height,Qy,cy,U0.data):pt.texImage2D(st.TEXTURE_2D,$0,C0,U0.width,U0.height,0,Qy,cy,U0.data);r0.generateMipmaps=!1}else o0?(v0&&pt.texStorage2D(st.TEXTURE_2D,k0,C0,Sy.width,Sy.height),i0&&pt.texSubImage2D(st.TEXTURE_2D,0,0,0,Sy.width,Sy.height,Qy,cy,Sy.data)):pt.texImage2D(st.TEXTURE_2D,0,C0,Sy.width,Sy.height,0,Qy,cy,Sy.data);else if(r0.isCompressedTexture)if(r0.isCompressedArrayTexture){o0&&v0&&pt.texStorage3D(st.TEXTURE_2D_ARRAY,k0,C0,xy[0].width,xy[0].height,Sy.depth);for(let $0=0,ty=xy.length;$0<ty;$0++)U0=xy[$0],r0.format!==RGBAFormat?Qy!==null?o0?i0&&pt.compressedTexSubImage3D(st.TEXTURE_2D_ARRAY,$0,0,0,0,U0.width,U0.height,Sy.depth,Qy,U0.data,0,0):pt.compressedTexImage3D(st.TEXTURE_2D_ARRAY,$0,C0,U0.width,U0.height,Sy.depth,0,U0.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):o0?i0&&pt.texSubImage3D(st.TEXTURE_2D_ARRAY,$0,0,0,0,U0.width,U0.height,Sy.depth,Qy,cy,U0.data):pt.texImage3D(st.TEXTURE_2D_ARRAY,$0,C0,U0.width,U0.height,Sy.depth,0,Qy,cy,U0.data)}else{o0&&v0&&pt.texStorage2D(st.TEXTURE_2D,k0,C0,xy[0].width,xy[0].height);for(let $0=0,ty=xy.length;$0<ty;$0++)U0=xy[$0],r0.format!==RGBAFormat?Qy!==null?o0?i0&&pt.compressedTexSubImage2D(st.TEXTURE_2D,$0,0,0,U0.width,U0.height,Qy,U0.data):pt.compressedTexImage2D(st.TEXTURE_2D,$0,C0,U0.width,U0.height,0,U0.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):o0?i0&&pt.texSubImage2D(st.TEXTURE_2D,$0,0,0,U0.width,U0.height,Qy,cy,U0.data):pt.texImage2D(st.TEXTURE_2D,$0,C0,U0.width,U0.height,0,Qy,cy,U0.data)}else if(r0.isDataArrayTexture)o0?(v0&&pt.texStorage3D(st.TEXTURE_2D_ARRAY,k0,C0,Sy.width,Sy.height,Sy.depth),i0&&pt.texSubImage3D(st.TEXTURE_2D_ARRAY,0,0,0,0,Sy.width,Sy.height,Sy.depth,Qy,cy,Sy.data)):pt.texImage3D(st.TEXTURE_2D_ARRAY,0,C0,Sy.width,Sy.height,Sy.depth,0,Qy,cy,Sy.data);else if(r0.isData3DTexture)o0?(v0&&pt.texStorage3D(st.TEXTURE_3D,k0,C0,Sy.width,Sy.height,Sy.depth),i0&&pt.texSubImage3D(st.TEXTURE_3D,0,0,0,0,Sy.width,Sy.height,Sy.depth,Qy,cy,Sy.data)):pt.texImage3D(st.TEXTURE_3D,0,C0,Sy.width,Sy.height,Sy.depth,0,Qy,cy,Sy.data);else if(r0.isFramebufferTexture){if(v0)if(o0)pt.texStorage2D(st.TEXTURE_2D,k0,C0,Sy.width,Sy.height);else{let $0=Sy.width,ty=Sy.height;for(let my=0;my<k0;my++)pt.texImage2D(st.TEXTURE_2D,my,C0,$0,ty,0,Qy,cy,null),$0>>=1,ty>>=1}}else if(xy.length>0&&Ev){if(o0&&v0){const $0=rv(xy[0]);pt.texStorage2D(st.TEXTURE_2D,k0,C0,$0.width,$0.height)}for(let $0=0,ty=xy.length;$0<ty;$0++)U0=xy[$0],o0?i0&&pt.texSubImage2D(st.TEXTURE_2D,$0,0,0,Qy,cy,U0):pt.texImage2D(st.TEXTURE_2D,$0,C0,Qy,cy,U0);r0.generateMipmaps=!1}else if(o0){if(v0){const $0=rv(Sy);pt.texStorage2D(st.TEXTURE_2D,k0,C0,$0.width,$0.height)}i0&&pt.texSubImage2D(st.TEXTURE_2D,0,0,0,Qy,cy,Sy)}else pt.texImage2D(st.TEXTURE_2D,0,C0,Qy,cy,Sy);tr(r0,Ev)&&rr(G0),Vy.__version=dy.version,r0.onUpdate&&r0.onUpdate(r0)}y0.__version=r0.version}function Ty(y0,r0,M0){if(r0.image.length!==6)return;const G0=W0(y0,r0),sy=r0.source;pt.bindTexture(st.TEXTURE_CUBE_MAP,y0.__webglTexture,st.TEXTURE0+M0);const dy=vt.get(sy);if(sy.version!==dy.__version||G0===!0){pt.activeTexture(st.TEXTURE0+M0);const Vy=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),Xy=r0.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(r0.colorSpace),hy=r0.colorSpace===NoColorSpace||Vy===Xy?st.NONE:st.BROWSER_DEFAULT_WEBGL;st.pixelStorei(st.UNPACK_FLIP_Y_WEBGL,r0.flipY),st.pixelStorei(st.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r0.premultiplyAlpha),st.pixelStorei(st.UNPACK_ALIGNMENT,r0.unpackAlignment),st.pixelStorei(st.UNPACK_COLORSPACE_CONVERSION_WEBGL,hy);const Ly=r0.isCompressedTexture||r0.image[0].isCompressedTexture,Py=r0.image[0]&&r0.image[0].isDataTexture,Sy=[];for(let $0=0;$0<6;$0++)!Ly&&!Py?Sy[$0]=Sn(r0.image[$0],!1,!0,wt.maxCubemapSize):Sy[$0]=Py?r0.image[$0].image:r0.image[$0],Sy[$0]=qy(r0,Sy[$0]);const Ev=Sy[0],Qy=wn(Ev)||Lt,cy=$t.convert(r0.format,r0.colorSpace),C0=$t.convert(r0.type),U0=Hr(r0.internalFormat,cy,C0,r0.colorSpace),xy=Lt&&r0.isVideoTexture!==!0,o0=dy.__version===void 0||G0===!0,v0=sy.dataReady;let i0=qr(r0,Ev,Qy);B0(st.TEXTURE_CUBE_MAP,r0,Qy);let k0;if(Ly){xy&&o0&&pt.texStorage2D(st.TEXTURE_CUBE_MAP,i0,U0,Ev.width,Ev.height);for(let $0=0;$0<6;$0++){k0=Sy[$0].mipmaps;for(let ty=0;ty<k0.length;ty++){const my=k0[ty];r0.format!==RGBAFormat?cy!==null?xy?v0&&pt.compressedTexSubImage2D(st.TEXTURE_CUBE_MAP_POSITIVE_X+$0,ty,0,0,my.width,my.height,cy,my.data):pt.compressedTexImage2D(st.TEXTURE_CUBE_MAP_POSITIVE_X+$0,ty,U0,my.width,my.height,0,my.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):xy?v0&&pt.texSubImage2D(st.TEXTURE_CUBE_MAP_POSITIVE_X+$0,ty,0,0,my.width,my.height,cy,C0,my.data):pt.texImage2D(st.TEXTURE_CUBE_MAP_POSITIVE_X+$0,ty,U0,my.width,my.height,0,cy,C0,my.data)}}}else{if(k0=r0.mipmaps,xy&&o0){k0.length>0&&i0++;const $0=rv(Sy[0]);pt.texStorage2D(st.TEXTURE_CUBE_MAP,i0,U0,$0.width,$0.height)}for(let $0=0;$0<6;$0++)if(Py){xy?v0&&pt.texSubImage2D(st.TEXTURE_CUBE_MAP_POSITIVE_X+$0,0,0,0,Sy[$0].width,Sy[$0].height,cy,C0,Sy[$0].data):pt.texImage2D(st.TEXTURE_CUBE_MAP_POSITIVE_X+$0,0,U0,Sy[$0].width,Sy[$0].height,0,cy,C0,Sy[$0].data);for(let ty=0;ty<k0.length;ty++){const ev=k0[ty].image[$0].image;xy?v0&&pt.texSubImage2D(st.TEXTURE_CUBE_MAP_POSITIVE_X+$0,ty+1,0,0,ev.width,ev.height,cy,C0,ev.data):pt.texImage2D(st.TEXTURE_CUBE_MAP_POSITIVE_X+$0,ty+1,U0,ev.width,ev.height,0,cy,C0,ev.data)}}else{xy?v0&&pt.texSubImage2D(st.TEXTURE_CUBE_MAP_POSITIVE_X+$0,0,0,0,cy,C0,Sy[$0]):pt.texImage2D(st.TEXTURE_CUBE_MAP_POSITIVE_X+$0,0,U0,cy,C0,Sy[$0]);for(let ty=0;ty<k0.length;ty++){const my=k0[ty];xy?v0&&pt.texSubImage2D(st.TEXTURE_CUBE_MAP_POSITIVE_X+$0,ty+1,0,0,cy,C0,my.image[$0]):pt.texImage2D(st.TEXTURE_CUBE_MAP_POSITIVE_X+$0,ty+1,U0,cy,C0,my.image[$0])}}}tr(r0,Qy)&&rr(st.TEXTURE_CUBE_MAP),dy.__version=sy.version,r0.onUpdate&&r0.onUpdate(r0)}y0.__version=r0.version}function $y(y0,r0,M0,G0,sy,dy){const Vy=$t.convert(M0.format,M0.colorSpace),Xy=$t.convert(M0.type),hy=Hr(M0.internalFormat,Vy,Xy,M0.colorSpace);if(!vt.get(r0).__hasExternalTextures){const Py=Math.max(1,r0.width>>dy),Sy=Math.max(1,r0.height>>dy);sy===st.TEXTURE_3D||sy===st.TEXTURE_2D_ARRAY?pt.texImage3D(sy,dy,hy,Py,Sy,r0.depth,0,Vy,Xy,null):pt.texImage2D(sy,dy,hy,Py,Sy,0,Vy,Xy,null)}pt.bindFramebuffer(st.FRAMEBUFFER,y0),Dy(r0)?Ft.framebufferTexture2DMultisampleEXT(st.FRAMEBUFFER,G0,sy,vt.get(M0).__webglTexture,0,uy(r0)):(sy===st.TEXTURE_2D||sy>=st.TEXTURE_CUBE_MAP_POSITIVE_X&&sy<=st.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&st.framebufferTexture2D(st.FRAMEBUFFER,G0,sy,vt.get(M0).__webglTexture,dy),pt.bindFramebuffer(st.FRAMEBUFFER,null)}function My(y0,r0,M0){if(st.bindRenderbuffer(st.RENDERBUFFER,y0),r0.depthBuffer&&!r0.stencilBuffer){let G0=Lt===!0?st.DEPTH_COMPONENT24:st.DEPTH_COMPONENT16;if(M0||Dy(r0)){const sy=r0.depthTexture;sy&&sy.isDepthTexture&&(sy.type===FloatType?G0=st.DEPTH_COMPONENT32F:sy.type===UnsignedIntType&&(G0=st.DEPTH_COMPONENT24));const dy=uy(r0);Dy(r0)?Ft.renderbufferStorageMultisampleEXT(st.RENDERBUFFER,dy,G0,r0.width,r0.height):st.renderbufferStorageMultisample(st.RENDERBUFFER,dy,G0,r0.width,r0.height)}else st.renderbufferStorage(st.RENDERBUFFER,G0,r0.width,r0.height);st.framebufferRenderbuffer(st.FRAMEBUFFER,st.DEPTH_ATTACHMENT,st.RENDERBUFFER,y0)}else if(r0.depthBuffer&&r0.stencilBuffer){const G0=uy(r0);M0&&Dy(r0)===!1?st.renderbufferStorageMultisample(st.RENDERBUFFER,G0,st.DEPTH24_STENCIL8,r0.width,r0.height):Dy(r0)?Ft.renderbufferStorageMultisampleEXT(st.RENDERBUFFER,G0,st.DEPTH24_STENCIL8,r0.width,r0.height):st.renderbufferStorage(st.RENDERBUFFER,st.DEPTH_STENCIL,r0.width,r0.height),st.framebufferRenderbuffer(st.FRAMEBUFFER,st.DEPTH_STENCIL_ATTACHMENT,st.RENDERBUFFER,y0)}else{const G0=r0.textures;for(let sy=0;sy<G0.length;sy++){const dy=G0[sy],Vy=$t.convert(dy.format,dy.colorSpace),Xy=$t.convert(dy.type),hy=Hr(dy.internalFormat,Vy,Xy,dy.colorSpace),Ly=uy(r0);M0&&Dy(r0)===!1?st.renderbufferStorageMultisample(st.RENDERBUFFER,Ly,hy,r0.width,r0.height):Dy(r0)?Ft.renderbufferStorageMultisampleEXT(st.RENDERBUFFER,Ly,hy,r0.width,r0.height):st.renderbufferStorage(st.RENDERBUFFER,hy,r0.width,r0.height)}}st.bindRenderbuffer(st.RENDERBUFFER,null)}function Wy(y0,r0){if(r0&&r0.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(pt.bindFramebuffer(st.FRAMEBUFFER,y0),!(r0.depthTexture&&r0.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!vt.get(r0.depthTexture).__webglTexture||r0.depthTexture.image.width!==r0.width||r0.depthTexture.image.height!==r0.height)&&(r0.depthTexture.image.width=r0.width,r0.depthTexture.image.height=r0.height,r0.depthTexture.needsUpdate=!0),E0(r0.depthTexture,0);const G0=vt.get(r0.depthTexture).__webglTexture,sy=uy(r0);if(r0.depthTexture.format===DepthFormat)Dy(r0)?Ft.framebufferTexture2DMultisampleEXT(st.FRAMEBUFFER,st.DEPTH_ATTACHMENT,st.TEXTURE_2D,G0,0,sy):st.framebufferTexture2D(st.FRAMEBUFFER,st.DEPTH_ATTACHMENT,st.TEXTURE_2D,G0,0);else if(r0.depthTexture.format===DepthStencilFormat)Dy(r0)?Ft.framebufferTexture2DMultisampleEXT(st.FRAMEBUFFER,st.DEPTH_STENCIL_ATTACHMENT,st.TEXTURE_2D,G0,0,sy):st.framebufferTexture2D(st.FRAMEBUFFER,st.DEPTH_STENCIL_ATTACHMENT,st.TEXTURE_2D,G0,0);else throw new Error("Unknown depthTexture format")}function Ey(y0){const r0=vt.get(y0),M0=y0.isWebGLCubeRenderTarget===!0;if(y0.depthTexture&&!r0.__autoAllocateDepthBuffer){if(M0)throw new Error("target.depthTexture not supported in Cube render targets");Wy(r0.__webglFramebuffer,y0)}else if(M0){r0.__webglDepthbuffer=[];for(let G0=0;G0<6;G0++)pt.bindFramebuffer(st.FRAMEBUFFER,r0.__webglFramebuffer[G0]),r0.__webglDepthbuffer[G0]=st.createRenderbuffer(),My(r0.__webglDepthbuffer[G0],y0,!1)}else pt.bindFramebuffer(st.FRAMEBUFFER,r0.__webglFramebuffer),r0.__webglDepthbuffer=st.createRenderbuffer(),My(r0.__webglDepthbuffer,y0,!1);pt.bindFramebuffer(st.FRAMEBUFFER,null)}function _0(y0,r0,M0){const G0=vt.get(y0);r0!==void 0&&$y(G0.__webglFramebuffer,y0,y0.texture,st.COLOR_ATTACHMENT0,st.TEXTURE_2D,0),M0!==void 0&&Ey(y0)}function ay(y0){const r0=y0.texture,M0=vt.get(y0),G0=vt.get(r0);y0.addEventListener("dispose",Xo);const sy=y0.textures,dy=y0.isWebGLCubeRenderTarget===!0,Vy=sy.length>1,Xy=wn(y0)||Lt;if(Vy||(G0.__webglTexture===void 0&&(G0.__webglTexture=st.createTexture()),G0.__version=r0.version,Tt.memory.textures++),dy){M0.__webglFramebuffer=[];for(let hy=0;hy<6;hy++)if(Lt&&r0.mipmaps&&r0.mipmaps.length>0){M0.__webglFramebuffer[hy]=[];for(let Ly=0;Ly<r0.mipmaps.length;Ly++)M0.__webglFramebuffer[hy][Ly]=st.createFramebuffer()}else M0.__webglFramebuffer[hy]=st.createFramebuffer()}else{if(Lt&&r0.mipmaps&&r0.mipmaps.length>0){M0.__webglFramebuffer=[];for(let hy=0;hy<r0.mipmaps.length;hy++)M0.__webglFramebuffer[hy]=st.createFramebuffer()}else M0.__webglFramebuffer=st.createFramebuffer();if(Vy)if(wt.drawBuffers)for(let hy=0,Ly=sy.length;hy<Ly;hy++){const Py=vt.get(sy[hy]);Py.__webglTexture===void 0&&(Py.__webglTexture=st.createTexture(),Tt.memory.textures++)}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(Lt&&y0.samples>0&&Dy(y0)===!1){M0.__webglMultisampledFramebuffer=st.createFramebuffer(),M0.__webglColorRenderbuffer=[],pt.bindFramebuffer(st.FRAMEBUFFER,M0.__webglMultisampledFramebuffer);for(let hy=0;hy<sy.length;hy++){const Ly=sy[hy];M0.__webglColorRenderbuffer[hy]=st.createRenderbuffer(),st.bindRenderbuffer(st.RENDERBUFFER,M0.__webglColorRenderbuffer[hy]);const Py=$t.convert(Ly.format,Ly.colorSpace),Sy=$t.convert(Ly.type),Ev=Hr(Ly.internalFormat,Py,Sy,Ly.colorSpace,y0.isXRRenderTarget===!0),Qy=uy(y0);st.renderbufferStorageMultisample(st.RENDERBUFFER,Qy,Ev,y0.width,y0.height),st.framebufferRenderbuffer(st.FRAMEBUFFER,st.COLOR_ATTACHMENT0+hy,st.RENDERBUFFER,M0.__webglColorRenderbuffer[hy])}st.bindRenderbuffer(st.RENDERBUFFER,null),y0.depthBuffer&&(M0.__webglDepthRenderbuffer=st.createRenderbuffer(),My(M0.__webglDepthRenderbuffer,y0,!0)),pt.bindFramebuffer(st.FRAMEBUFFER,null)}}if(dy){pt.bindTexture(st.TEXTURE_CUBE_MAP,G0.__webglTexture),B0(st.TEXTURE_CUBE_MAP,r0,Xy);for(let hy=0;hy<6;hy++)if(Lt&&r0.mipmaps&&r0.mipmaps.length>0)for(let Ly=0;Ly<r0.mipmaps.length;Ly++)$y(M0.__webglFramebuffer[hy][Ly],y0,r0,st.COLOR_ATTACHMENT0,st.TEXTURE_CUBE_MAP_POSITIVE_X+hy,Ly);else $y(M0.__webglFramebuffer[hy],y0,r0,st.COLOR_ATTACHMENT0,st.TEXTURE_CUBE_MAP_POSITIVE_X+hy,0);tr(r0,Xy)&&rr(st.TEXTURE_CUBE_MAP),pt.unbindTexture()}else if(Vy){for(let hy=0,Ly=sy.length;hy<Ly;hy++){const Py=sy[hy],Sy=vt.get(Py);pt.bindTexture(st.TEXTURE_2D,Sy.__webglTexture),B0(st.TEXTURE_2D,Py,Xy),$y(M0.__webglFramebuffer,y0,Py,st.COLOR_ATTACHMENT0+hy,st.TEXTURE_2D,0),tr(Py,Xy)&&rr(st.TEXTURE_2D)}pt.unbindTexture()}else{let hy=st.TEXTURE_2D;if((y0.isWebGL3DRenderTarget||y0.isWebGLArrayRenderTarget)&&(Lt?hy=y0.isWebGL3DRenderTarget?st.TEXTURE_3D:st.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),pt.bindTexture(hy,G0.__webglTexture),B0(hy,r0,Xy),Lt&&r0.mipmaps&&r0.mipmaps.length>0)for(let Ly=0;Ly<r0.mipmaps.length;Ly++)$y(M0.__webglFramebuffer[Ly],y0,r0,st.COLOR_ATTACHMENT0,hy,Ly);else $y(M0.__webglFramebuffer,y0,r0,st.COLOR_ATTACHMENT0,hy,0);tr(r0,Xy)&&rr(hy),pt.unbindTexture()}y0.depthBuffer&&Ey(y0)}function J0(y0){const r0=wn(y0)||Lt,M0=y0.textures;for(let G0=0,sy=M0.length;G0<sy;G0++){const dy=M0[G0];if(tr(dy,r0)){const Vy=y0.isWebGLCubeRenderTarget?st.TEXTURE_CUBE_MAP:st.TEXTURE_2D,Xy=vt.get(dy).__webglTexture;pt.bindTexture(Vy,Xy),rr(Vy),pt.unbindTexture()}}}function yy(y0){if(Lt&&y0.samples>0&&Dy(y0)===!1){const r0=y0.textures,M0=y0.width,G0=y0.height;let sy=st.COLOR_BUFFER_BIT;const dy=[],Vy=y0.stencilBuffer?st.DEPTH_STENCIL_ATTACHMENT:st.DEPTH_ATTACHMENT,Xy=vt.get(y0),hy=r0.length>1;if(hy)for(let Ly=0;Ly<r0.length;Ly++)pt.bindFramebuffer(st.FRAMEBUFFER,Xy.__webglMultisampledFramebuffer),st.framebufferRenderbuffer(st.FRAMEBUFFER,st.COLOR_ATTACHMENT0+Ly,st.RENDERBUFFER,null),pt.bindFramebuffer(st.FRAMEBUFFER,Xy.__webglFramebuffer),st.framebufferTexture2D(st.DRAW_FRAMEBUFFER,st.COLOR_ATTACHMENT0+Ly,st.TEXTURE_2D,null,0);pt.bindFramebuffer(st.READ_FRAMEBUFFER,Xy.__webglMultisampledFramebuffer),pt.bindFramebuffer(st.DRAW_FRAMEBUFFER,Xy.__webglFramebuffer);for(let Ly=0;Ly<r0.length;Ly++){dy.push(st.COLOR_ATTACHMENT0+Ly),y0.depthBuffer&&dy.push(Vy);const Py=Xy.__ignoreDepthValues!==void 0?Xy.__ignoreDepthValues:!1;if(Py===!1&&(y0.depthBuffer&&(sy|=st.DEPTH_BUFFER_BIT),y0.stencilBuffer&&(sy|=st.STENCIL_BUFFER_BIT)),hy&&st.framebufferRenderbuffer(st.READ_FRAMEBUFFER,st.COLOR_ATTACHMENT0,st.RENDERBUFFER,Xy.__webglColorRenderbuffer[Ly]),Py===!0&&(st.invalidateFramebuffer(st.READ_FRAMEBUFFER,[Vy]),st.invalidateFramebuffer(st.DRAW_FRAMEBUFFER,[Vy])),hy){const Sy=vt.get(r0[Ly]).__webglTexture;st.framebufferTexture2D(st.DRAW_FRAMEBUFFER,st.COLOR_ATTACHMENT0,st.TEXTURE_2D,Sy,0)}st.blitFramebuffer(0,0,M0,G0,0,0,M0,G0,sy,st.NEAREST),Ct&&st.invalidateFramebuffer(st.READ_FRAMEBUFFER,dy)}if(pt.bindFramebuffer(st.READ_FRAMEBUFFER,null),pt.bindFramebuffer(st.DRAW_FRAMEBUFFER,null),hy)for(let Ly=0;Ly<r0.length;Ly++){pt.bindFramebuffer(st.FRAMEBUFFER,Xy.__webglMultisampledFramebuffer),st.framebufferRenderbuffer(st.FRAMEBUFFER,st.COLOR_ATTACHMENT0+Ly,st.RENDERBUFFER,Xy.__webglColorRenderbuffer[Ly]);const Py=vt.get(r0[Ly]).__webglTexture;pt.bindFramebuffer(st.FRAMEBUFFER,Xy.__webglFramebuffer),st.framebufferTexture2D(st.DRAW_FRAMEBUFFER,st.COLOR_ATTACHMENT0+Ly,st.TEXTURE_2D,Py,0)}pt.bindFramebuffer(st.DRAW_FRAMEBUFFER,Xy.__webglMultisampledFramebuffer)}}function uy(y0){return Math.min(wt.maxSamples,y0.samples)}function Dy(y0){const r0=vt.get(y0);return Lt&&y0.samples>0&&at.has("WEBGL_multisampled_render_to_texture")===!0&&r0.__useRenderToTexture!==!1}function Fy(y0){const r0=Tt.render.frame;Gt.get(y0)!==r0&&(Gt.set(y0,r0),y0.update())}function qy(y0,r0){const M0=y0.colorSpace,G0=y0.format,sy=y0.type;return y0.isCompressedTexture===!0||y0.isVideoTexture===!0||y0.format===_SRGBAFormat||M0!==LinearSRGBColorSpace$1&&M0!==NoColorSpace&&(ColorManagement.getTransfer(M0)===SRGBTransfer?Lt===!1?at.has("EXT_sRGB")===!0&&G0===RGBAFormat?(y0.format=_SRGBAFormat,y0.minFilter=LinearFilter,y0.generateMipmaps=!1):r0=ImageUtils.sRGBToLinear(r0):(G0!==RGBAFormat||sy!==UnsignedByteType)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",M0)),r0}function rv(y0){return typeof HTMLImageElement<"u"&&y0 instanceof HTMLImageElement?(Ht.width=y0.naturalWidth||y0.width,Ht.height=y0.naturalHeight||y0.height):typeof VideoFrame<"u"&&y0 instanceof VideoFrame?(Ht.width=y0.displayWidth,Ht.height=y0.displayHeight):(Ht.width=y0.width,Ht.height=y0.height),Ht}this.allocateTextureUnit=T0,this.resetTextureUnits=l0,this.setTexture2D=E0,this.setTexture2DArray=n0,this.setTexture3D=m0,this.setTextureCube=h0,this.rebindTextures=_0,this.setupRenderTarget=ay,this.updateRenderTargetMipmap=J0,this.updateMultisampleRenderTarget=yy,this.setupDepthRenderbuffer=Ey,this.setupFrameBufferTexture=$y,this.useMultisampledRTT=Dy}function WebGLUtils(st,at,pt){const vt=pt.isWebGL2;function wt($t,Tt=NoColorSpace){let Lt;const Ft=ColorManagement.getTransfer(Tt);if($t===UnsignedByteType)return st.UNSIGNED_BYTE;if($t===UnsignedShort4444Type)return st.UNSIGNED_SHORT_4_4_4_4;if($t===UnsignedShort5551Type)return st.UNSIGNED_SHORT_5_5_5_1;if($t===ByteType)return st.BYTE;if($t===ShortType)return st.SHORT;if($t===UnsignedShortType)return st.UNSIGNED_SHORT;if($t===IntType)return st.INT;if($t===UnsignedIntType)return st.UNSIGNED_INT;if($t===FloatType)return st.FLOAT;if($t===HalfFloatType)return vt?st.HALF_FLOAT:(Lt=at.get("OES_texture_half_float"),Lt!==null?Lt.HALF_FLOAT_OES:null);if($t===AlphaFormat)return st.ALPHA;if($t===RGBAFormat)return st.RGBA;if($t===LuminanceFormat)return st.LUMINANCE;if($t===LuminanceAlphaFormat)return st.LUMINANCE_ALPHA;if($t===DepthFormat)return st.DEPTH_COMPONENT;if($t===DepthStencilFormat)return st.DEPTH_STENCIL;if($t===_SRGBAFormat)return Lt=at.get("EXT_sRGB"),Lt!==null?Lt.SRGB_ALPHA_EXT:null;if($t===RedFormat)return st.RED;if($t===RedIntegerFormat)return st.RED_INTEGER;if($t===RGFormat)return st.RG;if($t===RGIntegerFormat)return st.RG_INTEGER;if($t===RGBAIntegerFormat)return st.RGBA_INTEGER;if($t===RGB_S3TC_DXT1_Format||$t===RGBA_S3TC_DXT1_Format||$t===RGBA_S3TC_DXT3_Format||$t===RGBA_S3TC_DXT5_Format)if(Ft===SRGBTransfer)if(Lt=at.get("WEBGL_compressed_texture_s3tc_srgb"),Lt!==null){if($t===RGB_S3TC_DXT1_Format)return Lt.COMPRESSED_SRGB_S3TC_DXT1_EXT;if($t===RGBA_S3TC_DXT1_Format)return Lt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if($t===RGBA_S3TC_DXT3_Format)return Lt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if($t===RGBA_S3TC_DXT5_Format)return Lt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(Lt=at.get("WEBGL_compressed_texture_s3tc"),Lt!==null){if($t===RGB_S3TC_DXT1_Format)return Lt.COMPRESSED_RGB_S3TC_DXT1_EXT;if($t===RGBA_S3TC_DXT1_Format)return Lt.COMPRESSED_RGBA_S3TC_DXT1_EXT;if($t===RGBA_S3TC_DXT3_Format)return Lt.COMPRESSED_RGBA_S3TC_DXT3_EXT;if($t===RGBA_S3TC_DXT5_Format)return Lt.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if($t===RGB_PVRTC_4BPPV1_Format||$t===RGB_PVRTC_2BPPV1_Format||$t===RGBA_PVRTC_4BPPV1_Format||$t===RGBA_PVRTC_2BPPV1_Format)if(Lt=at.get("WEBGL_compressed_texture_pvrtc"),Lt!==null){if($t===RGB_PVRTC_4BPPV1_Format)return Lt.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if($t===RGB_PVRTC_2BPPV1_Format)return Lt.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if($t===RGBA_PVRTC_4BPPV1_Format)return Lt.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if($t===RGBA_PVRTC_2BPPV1_Format)return Lt.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if($t===RGB_ETC1_Format)return Lt=at.get("WEBGL_compressed_texture_etc1"),Lt!==null?Lt.COMPRESSED_RGB_ETC1_WEBGL:null;if($t===RGB_ETC2_Format||$t===RGBA_ETC2_EAC_Format)if(Lt=at.get("WEBGL_compressed_texture_etc"),Lt!==null){if($t===RGB_ETC2_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ETC2:Lt.COMPRESSED_RGB8_ETC2;if($t===RGBA_ETC2_EAC_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:Lt.COMPRESSED_RGBA8_ETC2_EAC}else return null;if($t===RGBA_ASTC_4x4_Format||$t===RGBA_ASTC_5x4_Format||$t===RGBA_ASTC_5x5_Format||$t===RGBA_ASTC_6x5_Format||$t===RGBA_ASTC_6x6_Format||$t===RGBA_ASTC_8x5_Format||$t===RGBA_ASTC_8x6_Format||$t===RGBA_ASTC_8x8_Format||$t===RGBA_ASTC_10x5_Format||$t===RGBA_ASTC_10x6_Format||$t===RGBA_ASTC_10x8_Format||$t===RGBA_ASTC_10x10_Format||$t===RGBA_ASTC_12x10_Format||$t===RGBA_ASTC_12x12_Format)if(Lt=at.get("WEBGL_compressed_texture_astc"),Lt!==null){if($t===RGBA_ASTC_4x4_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:Lt.COMPRESSED_RGBA_ASTC_4x4_KHR;if($t===RGBA_ASTC_5x4_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:Lt.COMPRESSED_RGBA_ASTC_5x4_KHR;if($t===RGBA_ASTC_5x5_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:Lt.COMPRESSED_RGBA_ASTC_5x5_KHR;if($t===RGBA_ASTC_6x5_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:Lt.COMPRESSED_RGBA_ASTC_6x5_KHR;if($t===RGBA_ASTC_6x6_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:Lt.COMPRESSED_RGBA_ASTC_6x6_KHR;if($t===RGBA_ASTC_8x5_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:Lt.COMPRESSED_RGBA_ASTC_8x5_KHR;if($t===RGBA_ASTC_8x6_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:Lt.COMPRESSED_RGBA_ASTC_8x6_KHR;if($t===RGBA_ASTC_8x8_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:Lt.COMPRESSED_RGBA_ASTC_8x8_KHR;if($t===RGBA_ASTC_10x5_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:Lt.COMPRESSED_RGBA_ASTC_10x5_KHR;if($t===RGBA_ASTC_10x6_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:Lt.COMPRESSED_RGBA_ASTC_10x6_KHR;if($t===RGBA_ASTC_10x8_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:Lt.COMPRESSED_RGBA_ASTC_10x8_KHR;if($t===RGBA_ASTC_10x10_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:Lt.COMPRESSED_RGBA_ASTC_10x10_KHR;if($t===RGBA_ASTC_12x10_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:Lt.COMPRESSED_RGBA_ASTC_12x10_KHR;if($t===RGBA_ASTC_12x12_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:Lt.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if($t===RGBA_BPTC_Format||$t===RGB_BPTC_SIGNED_Format||$t===RGB_BPTC_UNSIGNED_Format)if(Lt=at.get("EXT_texture_compression_bptc"),Lt!==null){if($t===RGBA_BPTC_Format)return Ft===SRGBTransfer?Lt.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:Lt.COMPRESSED_RGBA_BPTC_UNORM_EXT;if($t===RGB_BPTC_SIGNED_Format)return Lt.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if($t===RGB_BPTC_UNSIGNED_Format)return Lt.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if($t===RED_RGTC1_Format||$t===SIGNED_RED_RGTC1_Format||$t===RED_GREEN_RGTC2_Format||$t===SIGNED_RED_GREEN_RGTC2_Format)if(Lt=at.get("EXT_texture_compression_rgtc"),Lt!==null){if($t===RGBA_BPTC_Format)return Lt.COMPRESSED_RED_RGTC1_EXT;if($t===SIGNED_RED_RGTC1_Format)return Lt.COMPRESSED_SIGNED_RED_RGTC1_EXT;if($t===RED_GREEN_RGTC2_Format)return Lt.COMPRESSED_RED_GREEN_RGTC2_EXT;if($t===SIGNED_RED_GREEN_RGTC2_Format)return Lt.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return $t===UnsignedInt248Type?vt?st.UNSIGNED_INT_24_8:(Lt=at.get("WEBGL_depth_texture"),Lt!==null?Lt.UNSIGNED_INT_24_8_WEBGL:null):st[$t]!==void 0?st[$t]:null}return{convert:wt}}class ArrayCamera extends PerspectiveCamera{constructor(at=[]){super(),this.isArrayCamera=!0,this.cameras=at}}class Group extends Object3D{constructor(){super(),this.isGroup=!0,this.type="Group"}}const _moveEvent={type:"move"};class WebXRController{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Group,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Group,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Vector3,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Vector3),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Group,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Vector3,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Vector3),this._grip}dispatchEvent(at){return this._targetRay!==null&&this._targetRay.dispatchEvent(at),this._grip!==null&&this._grip.dispatchEvent(at),this._hand!==null&&this._hand.dispatchEvent(at),this}connect(at){if(at&&at.hand){const pt=this._hand;if(pt)for(const vt of at.hand.values())this._getHandJoint(pt,vt)}return this.dispatchEvent({type:"connected",data:at}),this}disconnect(at){return this.dispatchEvent({type:"disconnected",data:at}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(at,pt,vt){let wt=null,$t=null,Tt=null;const Lt=this._targetRay,Ft=this._grip,Ct=this._hand;if(at&&pt.session.visibilityState!=="visible-blurred"){if(Ct&&at.hand){Tt=!0;for(const An of at.hand.values()){const Sn=pt.getJointPose(An,vt),wn=this._getHandJoint(Ct,An);Sn!==null&&(wn.matrix.fromArray(Sn.transform.matrix),wn.matrix.decompose(wn.position,wn.rotation,wn.scale),wn.matrixWorldNeedsUpdate=!0,wn.jointRadius=Sn.radius),wn.visible=Sn!==null}const Ht=Ct.joints["index-finger-tip"],Gt=Ct.joints["thumb-tip"],jt=Ht.position.distanceTo(Gt.position),qt=.02,Kt=.005;Ct.inputState.pinching&&jt>qt+Kt?(Ct.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:at.handedness,target:this})):!Ct.inputState.pinching&&jt<=qt-Kt&&(Ct.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:at.handedness,target:this}))}else Ft!==null&&at.gripSpace&&($t=pt.getPose(at.gripSpace,vt),$t!==null&&(Ft.matrix.fromArray($t.transform.matrix),Ft.matrix.decompose(Ft.position,Ft.rotation,Ft.scale),Ft.matrixWorldNeedsUpdate=!0,$t.linearVelocity?(Ft.hasLinearVelocity=!0,Ft.linearVelocity.copy($t.linearVelocity)):Ft.hasLinearVelocity=!1,$t.angularVelocity?(Ft.hasAngularVelocity=!0,Ft.angularVelocity.copy($t.angularVelocity)):Ft.hasAngularVelocity=!1));Lt!==null&&(wt=pt.getPose(at.targetRaySpace,vt),wt===null&&$t!==null&&(wt=$t),wt!==null&&(Lt.matrix.fromArray(wt.transform.matrix),Lt.matrix.decompose(Lt.position,Lt.rotation,Lt.scale),Lt.matrixWorldNeedsUpdate=!0,wt.linearVelocity?(Lt.hasLinearVelocity=!0,Lt.linearVelocity.copy(wt.linearVelocity)):Lt.hasLinearVelocity=!1,wt.angularVelocity?(Lt.hasAngularVelocity=!0,Lt.angularVelocity.copy(wt.angularVelocity)):Lt.hasAngularVelocity=!1,this.dispatchEvent(_moveEvent)))}return Lt!==null&&(Lt.visible=wt!==null),Ft!==null&&(Ft.visible=$t!==null),Ct!==null&&(Ct.visible=Tt!==null),this}_getHandJoint(at,pt){if(at.joints[pt.jointName]===void 0){const vt=new Group;vt.matrixAutoUpdate=!1,vt.visible=!1,at.joints[pt.jointName]=vt,at.add(vt)}return at.joints[pt.jointName]}}const _occlusion_vertex=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,_occlusion_fragment=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class WebXRDepthSensing{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(at,pt,vt){if(this.texture===null){const wt=new Texture,$t=at.properties.get(wt);$t.__webglTexture=pt.texture,(pt.depthNear!=vt.depthNear||pt.depthFar!=vt.depthFar)&&(this.depthNear=pt.depthNear,this.depthFar=pt.depthFar),this.texture=wt}}render(at,pt){if(this.texture!==null){if(this.mesh===null){const vt=pt.cameras[0].viewport,wt=new ShaderMaterial({extensions:{fragDepth:!0},vertexShader:_occlusion_vertex,fragmentShader:_occlusion_fragment,uniforms:{depthColor:{value:this.texture},depthWidth:{value:vt.z},depthHeight:{value:vt.w}}});this.mesh=new Mesh(new PlaneGeometry(20,20),wt)}at.render(this.mesh,pt)}}reset(){this.texture=null,this.mesh=null}}class WebXRManager extends EventDispatcher{constructor(at,pt){super();const vt=this;let wt=null,$t=1,Tt=null,Lt="local-floor",Ft=1,Ct=null,Ht=null,Gt=null,jt=null,qt=null,Kt=null;const An=new WebXRDepthSensing,Sn=pt.getContextAttributes();let wn=null,In=null;const tr=[],rr=[],Hr=new Vector2;let qr=null;const Zr=new PerspectiveCamera;Zr.layers.enable(1),Zr.viewport=new Vector4;const Bo=new PerspectiveCamera;Bo.layers.enable(2),Bo.viewport=new Vector4;const Xo=[Zr,Bo],Kr=new ArrayCamera;Kr.layers.enable(1),Kr.layers.enable(2);let ko=null,f0=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(B0){let W0=tr[B0];return W0===void 0&&(W0=new WebXRController,tr[B0]=W0),W0.getTargetRaySpace()},this.getControllerGrip=function(B0){let W0=tr[B0];return W0===void 0&&(W0=new WebXRController,tr[B0]=W0),W0.getGripSpace()},this.getHand=function(B0){let W0=tr[B0];return W0===void 0&&(W0=new WebXRController,tr[B0]=W0),W0.getHandSpace()};function x0(B0){const W0=rr.indexOf(B0.inputSource);if(W0===-1)return;const K0=tr[W0];K0!==void 0&&(K0.update(B0.inputSource,B0.frame,Ct||Tt),K0.dispatchEvent({type:B0.type,data:B0.inputSource}))}function l0(){wt.removeEventListener("select",x0),wt.removeEventListener("selectstart",x0),wt.removeEventListener("selectend",x0),wt.removeEventListener("squeeze",x0),wt.removeEventListener("squeezestart",x0),wt.removeEventListener("squeezeend",x0),wt.removeEventListener("end",l0),wt.removeEventListener("inputsourceschange",T0);for(let B0=0;B0<tr.length;B0++){const W0=rr[B0];W0!==null&&(rr[B0]=null,tr[B0].disconnect(W0))}ko=null,f0=null,An.reset(),at.setRenderTarget(wn),qt=null,jt=null,Gt=null,wt=null,In=null,V0.stop(),vt.isPresenting=!1,at.setPixelRatio(qr),at.setSize(Hr.width,Hr.height,!1),vt.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(B0){$t=B0,vt.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(B0){Lt=B0,vt.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return Ct||Tt},this.setReferenceSpace=function(B0){Ct=B0},this.getBaseLayer=function(){return jt!==null?jt:qt},this.getBinding=function(){return Gt},this.getFrame=function(){return Kt},this.getSession=function(){return wt},this.setSession=async function(B0){if(wt=B0,wt!==null){if(wn=at.getRenderTarget(),wt.addEventListener("select",x0),wt.addEventListener("selectstart",x0),wt.addEventListener("selectend",x0),wt.addEventListener("squeeze",x0),wt.addEventListener("squeezestart",x0),wt.addEventListener("squeezeend",x0),wt.addEventListener("end",l0),wt.addEventListener("inputsourceschange",T0),Sn.xrCompatible!==!0&&await pt.makeXRCompatible(),qr=at.getPixelRatio(),at.getSize(Hr),wt.renderState.layers===void 0||at.capabilities.isWebGL2===!1){const W0={antialias:wt.renderState.layers===void 0?Sn.antialias:!0,alpha:!0,depth:Sn.depth,stencil:Sn.stencil,framebufferScaleFactor:$t};qt=new XRWebGLLayer(wt,pt,W0),wt.updateRenderState({baseLayer:qt}),at.setPixelRatio(1),at.setSize(qt.framebufferWidth,qt.framebufferHeight,!1),In=new WebGLRenderTarget(qt.framebufferWidth,qt.framebufferHeight,{format:RGBAFormat,type:UnsignedByteType,colorSpace:at.outputColorSpace,stencilBuffer:Sn.stencil})}else{let W0=null,K0=null,Ty=null;Sn.depth&&(Ty=Sn.stencil?pt.DEPTH24_STENCIL8:pt.DEPTH_COMPONENT24,W0=Sn.stencil?DepthStencilFormat:DepthFormat,K0=Sn.stencil?UnsignedInt248Type:UnsignedIntType);const $y={colorFormat:pt.RGBA8,depthFormat:Ty,scaleFactor:$t};Gt=new XRWebGLBinding(wt,pt),jt=Gt.createProjectionLayer($y),wt.updateRenderState({layers:[jt]}),at.setPixelRatio(1),at.setSize(jt.textureWidth,jt.textureHeight,!1),In=new WebGLRenderTarget(jt.textureWidth,jt.textureHeight,{format:RGBAFormat,type:UnsignedByteType,depthTexture:new DepthTexture(jt.textureWidth,jt.textureHeight,K0,void 0,void 0,void 0,void 0,void 0,void 0,W0),stencilBuffer:Sn.stencil,colorSpace:at.outputColorSpace,samples:Sn.antialias?4:0});const My=at.properties.get(In);My.__ignoreDepthValues=jt.ignoreDepthValues}In.isXRRenderTarget=!0,this.setFoveation(Ft),Ct=null,Tt=await wt.requestReferenceSpace(Lt),V0.setContext(wt),V0.start(),vt.isPresenting=!0,vt.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(wt!==null)return wt.environmentBlendMode};function T0(B0){for(let W0=0;W0<B0.removed.length;W0++){const K0=B0.removed[W0],Ty=rr.indexOf(K0);Ty>=0&&(rr[Ty]=null,tr[Ty].disconnect(K0))}for(let W0=0;W0<B0.added.length;W0++){const K0=B0.added[W0];let Ty=rr.indexOf(K0);if(Ty===-1){for(let My=0;My<tr.length;My++)if(My>=rr.length){rr.push(K0),Ty=My;break}else if(rr[My]===null){rr[My]=K0,Ty=My;break}if(Ty===-1)break}const $y=tr[Ty];$y&&$y.connect(K0)}}const t0=new Vector3,E0=new Vector3;function n0(B0,W0,K0){t0.setFromMatrixPosition(W0.matrixWorld),E0.setFromMatrixPosition(K0.matrixWorld);const Ty=t0.distanceTo(E0),$y=W0.projectionMatrix.elements,My=K0.projectionMatrix.elements,Wy=$y[14]/($y[10]-1),Ey=$y[14]/($y[10]+1),_0=($y[9]+1)/$y[5],ay=($y[9]-1)/$y[5],J0=($y[8]-1)/$y[0],yy=(My[8]+1)/My[0],uy=Wy*J0,Dy=Wy*yy,Fy=Ty/(-J0+yy),qy=Fy*-J0;W0.matrixWorld.decompose(B0.position,B0.quaternion,B0.scale),B0.translateX(qy),B0.translateZ(Fy),B0.matrixWorld.compose(B0.position,B0.quaternion,B0.scale),B0.matrixWorldInverse.copy(B0.matrixWorld).invert();const rv=Wy+Fy,y0=Ey+Fy,r0=uy-qy,M0=Dy+(Ty-qy),G0=_0*Ey/y0*rv,sy=ay*Ey/y0*rv;B0.projectionMatrix.makePerspective(r0,M0,G0,sy,rv,y0),B0.projectionMatrixInverse.copy(B0.projectionMatrix).invert()}function m0(B0,W0){W0===null?B0.matrixWorld.copy(B0.matrix):B0.matrixWorld.multiplyMatrices(W0.matrixWorld,B0.matrix),B0.matrixWorldInverse.copy(B0.matrixWorld).invert()}this.updateCamera=function(B0){if(wt===null)return;An.texture!==null&&(B0.near=An.depthNear,B0.far=An.depthFar),Kr.near=Bo.near=Zr.near=B0.near,Kr.far=Bo.far=Zr.far=B0.far,(ko!==Kr.near||f0!==Kr.far)&&(wt.updateRenderState({depthNear:Kr.near,depthFar:Kr.far}),ko=Kr.near,f0=Kr.far,Zr.near=ko,Zr.far=f0,Bo.near=ko,Bo.far=f0,Zr.updateProjectionMatrix(),Bo.updateProjectionMatrix(),B0.updateProjectionMatrix());const W0=B0.parent,K0=Kr.cameras;m0(Kr,W0);for(let Ty=0;Ty<K0.length;Ty++)m0(K0[Ty],W0);K0.length===2?n0(Kr,Zr,Bo):Kr.projectionMatrix.copy(Zr.projectionMatrix),h0(B0,Kr,W0)};function h0(B0,W0,K0){K0===null?B0.matrix.copy(W0.matrixWorld):(B0.matrix.copy(K0.matrixWorld),B0.matrix.invert(),B0.matrix.multiply(W0.matrixWorld)),B0.matrix.decompose(B0.position,B0.quaternion,B0.scale),B0.updateMatrixWorld(!0),B0.projectionMatrix.copy(W0.projectionMatrix),B0.projectionMatrixInverse.copy(W0.projectionMatrixInverse),B0.isPerspectiveCamera&&(B0.fov=RAD2DEG*2*Math.atan(1/B0.projectionMatrix.elements[5]),B0.zoom=1)}this.getCamera=function(){return Kr},this.getFoveation=function(){if(!(jt===null&&qt===null))return Ft},this.setFoveation=function(B0){Ft=B0,jt!==null&&(jt.fixedFoveation=B0),qt!==null&&qt.fixedFoveation!==void 0&&(qt.fixedFoveation=B0)},this.hasDepthSensing=function(){return An.texture!==null};let a0=null;function P0(B0,W0){if(Ht=W0.getViewerPose(Ct||Tt),Kt=W0,Ht!==null){const K0=Ht.views;qt!==null&&(at.setRenderTargetFramebuffer(In,qt.framebuffer),at.setRenderTarget(In));let Ty=!1;K0.length!==Kr.cameras.length&&(Kr.cameras.length=0,Ty=!0);for(let My=0;My<K0.length;My++){const Wy=K0[My];let Ey=null;if(qt!==null)Ey=qt.getViewport(Wy);else{const ay=Gt.getViewSubImage(jt,Wy);Ey=ay.viewport,My===0&&(at.setRenderTargetTextures(In,ay.colorTexture,jt.ignoreDepthValues?void 0:ay.depthStencilTexture),at.setRenderTarget(In))}let _0=Xo[My];_0===void 0&&(_0=new PerspectiveCamera,_0.layers.enable(My),_0.viewport=new Vector4,Xo[My]=_0),_0.matrix.fromArray(Wy.transform.matrix),_0.matrix.decompose(_0.position,_0.quaternion,_0.scale),_0.projectionMatrix.fromArray(Wy.projectionMatrix),_0.projectionMatrixInverse.copy(_0.projectionMatrix).invert(),_0.viewport.set(Ey.x,Ey.y,Ey.width,Ey.height),My===0&&(Kr.matrix.copy(_0.matrix),Kr.matrix.decompose(Kr.position,Kr.quaternion,Kr.scale)),Ty===!0&&Kr.cameras.push(_0)}const $y=wt.enabledFeatures;if($y&&$y.includes("depth-sensing")){const My=Gt.getDepthInformation(K0[0]);My&&My.isValid&&My.texture&&An.init(at,My,wt.renderState)}}for(let K0=0;K0<tr.length;K0++){const Ty=rr[K0],$y=tr[K0];Ty!==null&&$y!==void 0&&$y.update(Ty,W0,Ct||Tt)}An.render(at,Kr),a0&&a0(B0,W0),W0.detectedPlanes&&vt.dispatchEvent({type:"planesdetected",data:W0}),Kt=null}const V0=new WebGLAnimation;V0.setAnimationLoop(P0),this.setAnimationLoop=function(B0){a0=B0},this.dispose=function(){}}}const _e1=new Euler,_m1=new Matrix4;function WebGLMaterials(st,at){function pt(Sn,wn){Sn.matrixAutoUpdate===!0&&Sn.updateMatrix(),wn.value.copy(Sn.matrix)}function vt(Sn,wn){wn.color.getRGB(Sn.fogColor.value,getUnlitUniformColorSpace(st)),wn.isFog?(Sn.fogNear.value=wn.near,Sn.fogFar.value=wn.far):wn.isFogExp2&&(Sn.fogDensity.value=wn.density)}function wt(Sn,wn,In,tr,rr){wn.isMeshBasicMaterial||wn.isMeshLambertMaterial?$t(Sn,wn):wn.isMeshToonMaterial?($t(Sn,wn),Gt(Sn,wn)):wn.isMeshPhongMaterial?($t(Sn,wn),Ht(Sn,wn)):wn.isMeshStandardMaterial?($t(Sn,wn),jt(Sn,wn),wn.isMeshPhysicalMaterial&&qt(Sn,wn,rr)):wn.isMeshMatcapMaterial?($t(Sn,wn),Kt(Sn,wn)):wn.isMeshDepthMaterial?$t(Sn,wn):wn.isMeshDistanceMaterial?($t(Sn,wn),An(Sn,wn)):wn.isMeshNormalMaterial?$t(Sn,wn):wn.isLineBasicMaterial?(Tt(Sn,wn),wn.isLineDashedMaterial&&Lt(Sn,wn)):wn.isPointsMaterial?Ft(Sn,wn,In,tr):wn.isSpriteMaterial?Ct(Sn,wn):wn.isShadowMaterial?(Sn.color.value.copy(wn.color),Sn.opacity.value=wn.opacity):wn.isShaderMaterial&&(wn.uniformsNeedUpdate=!1)}function $t(Sn,wn){Sn.opacity.value=wn.opacity,wn.color&&Sn.diffuse.value.copy(wn.color),wn.emissive&&Sn.emissive.value.copy(wn.emissive).multiplyScalar(wn.emissiveIntensity),wn.map&&(Sn.map.value=wn.map,pt(wn.map,Sn.mapTransform)),wn.alphaMap&&(Sn.alphaMap.value=wn.alphaMap,pt(wn.alphaMap,Sn.alphaMapTransform)),wn.bumpMap&&(Sn.bumpMap.value=wn.bumpMap,pt(wn.bumpMap,Sn.bumpMapTransform),Sn.bumpScale.value=wn.bumpScale,wn.side===BackSide&&(Sn.bumpScale.value*=-1)),wn.normalMap&&(Sn.normalMap.value=wn.normalMap,pt(wn.normalMap,Sn.normalMapTransform),Sn.normalScale.value.copy(wn.normalScale),wn.side===BackSide&&Sn.normalScale.value.negate()),wn.displacementMap&&(Sn.displacementMap.value=wn.displacementMap,pt(wn.displacementMap,Sn.displacementMapTransform),Sn.displacementScale.value=wn.displacementScale,Sn.displacementBias.value=wn.displacementBias),wn.emissiveMap&&(Sn.emissiveMap.value=wn.emissiveMap,pt(wn.emissiveMap,Sn.emissiveMapTransform)),wn.specularMap&&(Sn.specularMap.value=wn.specularMap,pt(wn.specularMap,Sn.specularMapTransform)),wn.alphaTest>0&&(Sn.alphaTest.value=wn.alphaTest);const In=at.get(wn),tr=In.envMap,rr=In.envMapRotation;if(tr&&(Sn.envMap.value=tr,_e1.copy(rr),_e1.x*=-1,_e1.y*=-1,_e1.z*=-1,tr.isCubeTexture&&tr.isRenderTargetTexture===!1&&(_e1.y*=-1,_e1.z*=-1),Sn.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1)),Sn.flipEnvMap.value=tr.isCubeTexture&&tr.isRenderTargetTexture===!1?-1:1,Sn.reflectivity.value=wn.reflectivity,Sn.ior.value=wn.ior,Sn.refractionRatio.value=wn.refractionRatio),wn.lightMap){Sn.lightMap.value=wn.lightMap;const Hr=st._useLegacyLights===!0?Math.PI:1;Sn.lightMapIntensity.value=wn.lightMapIntensity*Hr,pt(wn.lightMap,Sn.lightMapTransform)}wn.aoMap&&(Sn.aoMap.value=wn.aoMap,Sn.aoMapIntensity.value=wn.aoMapIntensity,pt(wn.aoMap,Sn.aoMapTransform))}function Tt(Sn,wn){Sn.diffuse.value.copy(wn.color),Sn.opacity.value=wn.opacity,wn.map&&(Sn.map.value=wn.map,pt(wn.map,Sn.mapTransform))}function Lt(Sn,wn){Sn.dashSize.value=wn.dashSize,Sn.totalSize.value=wn.dashSize+wn.gapSize,Sn.scale.value=wn.scale}function Ft(Sn,wn,In,tr){Sn.diffuse.value.copy(wn.color),Sn.opacity.value=wn.opacity,Sn.size.value=wn.size*In,Sn.scale.value=tr*.5,wn.map&&(Sn.map.value=wn.map,pt(wn.map,Sn.uvTransform)),wn.alphaMap&&(Sn.alphaMap.value=wn.alphaMap,pt(wn.alphaMap,Sn.alphaMapTransform)),wn.alphaTest>0&&(Sn.alphaTest.value=wn.alphaTest)}function Ct(Sn,wn){Sn.diffuse.value.copy(wn.color),Sn.opacity.value=wn.opacity,Sn.rotation.value=wn.rotation,wn.map&&(Sn.map.value=wn.map,pt(wn.map,Sn.mapTransform)),wn.alphaMap&&(Sn.alphaMap.value=wn.alphaMap,pt(wn.alphaMap,Sn.alphaMapTransform)),wn.alphaTest>0&&(Sn.alphaTest.value=wn.alphaTest)}function Ht(Sn,wn){Sn.specular.value.copy(wn.specular),Sn.shininess.value=Math.max(wn.shininess,1e-4)}function Gt(Sn,wn){wn.gradientMap&&(Sn.gradientMap.value=wn.gradientMap)}function jt(Sn,wn){Sn.metalness.value=wn.metalness,wn.metalnessMap&&(Sn.metalnessMap.value=wn.metalnessMap,pt(wn.metalnessMap,Sn.metalnessMapTransform)),Sn.roughness.value=wn.roughness,wn.roughnessMap&&(Sn.roughnessMap.value=wn.roughnessMap,pt(wn.roughnessMap,Sn.roughnessMapTransform)),at.get(wn).envMap&&(Sn.envMapIntensity.value=wn.envMapIntensity)}function qt(Sn,wn,In){Sn.ior.value=wn.ior,wn.sheen>0&&(Sn.sheenColor.value.copy(wn.sheenColor).multiplyScalar(wn.sheen),Sn.sheenRoughness.value=wn.sheenRoughness,wn.sheenColorMap&&(Sn.sheenColorMap.value=wn.sheenColorMap,pt(wn.sheenColorMap,Sn.sheenColorMapTransform)),wn.sheenRoughnessMap&&(Sn.sheenRoughnessMap.value=wn.sheenRoughnessMap,pt(wn.sheenRoughnessMap,Sn.sheenRoughnessMapTransform))),wn.clearcoat>0&&(Sn.clearcoat.value=wn.clearcoat,Sn.clearcoatRoughness.value=wn.clearcoatRoughness,wn.clearcoatMap&&(Sn.clearcoatMap.value=wn.clearcoatMap,pt(wn.clearcoatMap,Sn.clearcoatMapTransform)),wn.clearcoatRoughnessMap&&(Sn.clearcoatRoughnessMap.value=wn.clearcoatRoughnessMap,pt(wn.clearcoatRoughnessMap,Sn.clearcoatRoughnessMapTransform)),wn.clearcoatNormalMap&&(Sn.clearcoatNormalMap.value=wn.clearcoatNormalMap,pt(wn.clearcoatNormalMap,Sn.clearcoatNormalMapTransform),Sn.clearcoatNormalScale.value.copy(wn.clearcoatNormalScale),wn.side===BackSide&&Sn.clearcoatNormalScale.value.negate())),wn.iridescence>0&&(Sn.iridescence.value=wn.iridescence,Sn.iridescenceIOR.value=wn.iridescenceIOR,Sn.iridescenceThicknessMinimum.value=wn.iridescenceThicknessRange[0],Sn.iridescenceThicknessMaximum.value=wn.iridescenceThicknessRange[1],wn.iridescenceMap&&(Sn.iridescenceMap.value=wn.iridescenceMap,pt(wn.iridescenceMap,Sn.iridescenceMapTransform)),wn.iridescenceThicknessMap&&(Sn.iridescenceThicknessMap.value=wn.iridescenceThicknessMap,pt(wn.iridescenceThicknessMap,Sn.iridescenceThicknessMapTransform))),wn.transmission>0&&(Sn.transmission.value=wn.transmission,Sn.transmissionSamplerMap.value=In.texture,Sn.transmissionSamplerSize.value.set(In.width,In.height),wn.transmissionMap&&(Sn.transmissionMap.value=wn.transmissionMap,pt(wn.transmissionMap,Sn.transmissionMapTransform)),Sn.thickness.value=wn.thickness,wn.thicknessMap&&(Sn.thicknessMap.value=wn.thicknessMap,pt(wn.thicknessMap,Sn.thicknessMapTransform)),Sn.attenuationDistance.value=wn.attenuationDistance,Sn.attenuationColor.value.copy(wn.attenuationColor)),wn.anisotropy>0&&(Sn.anisotropyVector.value.set(wn.anisotropy*Math.cos(wn.anisotropyRotation),wn.anisotropy*Math.sin(wn.anisotropyRotation)),wn.anisotropyMap&&(Sn.anisotropyMap.value=wn.anisotropyMap,pt(wn.anisotropyMap,Sn.anisotropyMapTransform))),Sn.specularIntensity.value=wn.specularIntensity,Sn.specularColor.value.copy(wn.specularColor),wn.specularColorMap&&(Sn.specularColorMap.value=wn.specularColorMap,pt(wn.specularColorMap,Sn.specularColorMapTransform)),wn.specularIntensityMap&&(Sn.specularIntensityMap.value=wn.specularIntensityMap,pt(wn.specularIntensityMap,Sn.specularIntensityMapTransform))}function Kt(Sn,wn){wn.matcap&&(Sn.matcap.value=wn.matcap)}function An(Sn,wn){const In=at.get(wn).light;Sn.referencePosition.value.setFromMatrixPosition(In.matrixWorld),Sn.nearDistance.value=In.shadow.camera.near,Sn.farDistance.value=In.shadow.camera.far}return{refreshFogUniforms:vt,refreshMaterialUniforms:wt}}function WebGLUniformsGroups(st,at,pt,vt){let wt={},$t={},Tt=[];const Lt=pt.isWebGL2?st.getParameter(st.MAX_UNIFORM_BUFFER_BINDINGS):0;function Ft(In,tr){const rr=tr.program;vt.uniformBlockBinding(In,rr)}function Ct(In,tr){let rr=wt[In.id];rr===void 0&&(Kt(In),rr=Ht(In),wt[In.id]=rr,In.addEventListener("dispose",Sn));const Hr=tr.program;vt.updateUBOMapping(In,Hr);const qr=at.render.frame;$t[In.id]!==qr&&(jt(In),$t[In.id]=qr)}function Ht(In){const tr=Gt();In.__bindingPointIndex=tr;const rr=st.createBuffer(),Hr=In.__size,qr=In.usage;return st.bindBuffer(st.UNIFORM_BUFFER,rr),st.bufferData(st.UNIFORM_BUFFER,Hr,qr),st.bindBuffer(st.UNIFORM_BUFFER,null),st.bindBufferBase(st.UNIFORM_BUFFER,tr,rr),rr}function Gt(){for(let In=0;In<Lt;In++)if(Tt.indexOf(In)===-1)return Tt.push(In),In;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function jt(In){const tr=wt[In.id],rr=In.uniforms,Hr=In.__cache;st.bindBuffer(st.UNIFORM_BUFFER,tr);for(let qr=0,Zr=rr.length;qr<Zr;qr++){const Bo=Array.isArray(rr[qr])?rr[qr]:[rr[qr]];for(let Xo=0,Kr=Bo.length;Xo<Kr;Xo++){const ko=Bo[Xo];if(qt(ko,qr,Xo,Hr)===!0){const f0=ko.__offset,x0=Array.isArray(ko.value)?ko.value:[ko.value];let l0=0;for(let T0=0;T0<x0.length;T0++){const t0=x0[T0],E0=An(t0);typeof t0=="number"||typeof t0=="boolean"?(ko.__data[0]=t0,st.bufferSubData(st.UNIFORM_BUFFER,f0+l0,ko.__data)):t0.isMatrix3?(ko.__data[0]=t0.elements[0],ko.__data[1]=t0.elements[1],ko.__data[2]=t0.elements[2],ko.__data[3]=0,ko.__data[4]=t0.elements[3],ko.__data[5]=t0.elements[4],ko.__data[6]=t0.elements[5],ko.__data[7]=0,ko.__data[8]=t0.elements[6],ko.__data[9]=t0.elements[7],ko.__data[10]=t0.elements[8],ko.__data[11]=0):(t0.toArray(ko.__data,l0),l0+=E0.storage/Float32Array.BYTES_PER_ELEMENT)}st.bufferSubData(st.UNIFORM_BUFFER,f0,ko.__data)}}}st.bindBuffer(st.UNIFORM_BUFFER,null)}function qt(In,tr,rr,Hr){const qr=In.value,Zr=tr+"_"+rr;if(Hr[Zr]===void 0)return typeof qr=="number"||typeof qr=="boolean"?Hr[Zr]=qr:Hr[Zr]=qr.clone(),!0;{const Bo=Hr[Zr];if(typeof qr=="number"||typeof qr=="boolean"){if(Bo!==qr)return Hr[Zr]=qr,!0}else if(Bo.equals(qr)===!1)return Bo.copy(qr),!0}return!1}function Kt(In){const tr=In.uniforms;let rr=0;const Hr=16;for(let Zr=0,Bo=tr.length;Zr<Bo;Zr++){const Xo=Array.isArray(tr[Zr])?tr[Zr]:[tr[Zr]];for(let Kr=0,ko=Xo.length;Kr<ko;Kr++){const f0=Xo[Kr],x0=Array.isArray(f0.value)?f0.value:[f0.value];for(let l0=0,T0=x0.length;l0<T0;l0++){const t0=x0[l0],E0=An(t0),n0=rr%Hr;n0!==0&&Hr-n0<E0.boundary&&(rr+=Hr-n0),f0.__data=new Float32Array(E0.storage/Float32Array.BYTES_PER_ELEMENT),f0.__offset=rr,rr+=E0.storage}}}const qr=rr%Hr;return qr>0&&(rr+=Hr-qr),In.__size=rr,In.__cache={},this}function An(In){const tr={boundary:0,storage:0};return typeof In=="number"||typeof In=="boolean"?(tr.boundary=4,tr.storage=4):In.isVector2?(tr.boundary=8,tr.storage=8):In.isVector3||In.isColor?(tr.boundary=16,tr.storage=12):In.isVector4?(tr.boundary=16,tr.storage=16):In.isMatrix3?(tr.boundary=48,tr.storage=48):In.isMatrix4?(tr.boundary=64,tr.storage=64):In.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",In),tr}function Sn(In){const tr=In.target;tr.removeEventListener("dispose",Sn);const rr=Tt.indexOf(tr.__bindingPointIndex);Tt.splice(rr,1),st.deleteBuffer(wt[tr.id]),delete wt[tr.id],delete $t[tr.id]}function wn(){for(const In in wt)st.deleteBuffer(wt[In]);Tt=[],wt={},$t={}}return{bind:Ft,update:Ct,dispose:wn}}class WebGLRenderer{constructor(at={}){const{canvas:pt=createCanvasElement(),context:vt=null,depth:wt=!0,stencil:$t=!0,alpha:Tt=!1,antialias:Lt=!1,premultipliedAlpha:Ft=!0,preserveDrawingBuffer:Ct=!1,powerPreference:Ht="default",failIfMajorPerformanceCaveat:Gt=!1}=at;this.isWebGLRenderer=!0;let jt;vt!==null?jt=vt.getContextAttributes().alpha:jt=Tt;const qt=new Uint32Array(4),Kt=new Int32Array(4);let An=null,Sn=null;const wn=[],In=[];this.domElement=pt,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=SRGBColorSpace$1,this._useLegacyLights=!1,this.toneMapping=NoToneMapping,this.toneMappingExposure=1;const tr=this;let rr=!1,Hr=0,qr=0,Zr=null,Bo=-1,Xo=null;const Kr=new Vector4,ko=new Vector4;let f0=null;const x0=new Color$1(0);let l0=0,T0=pt.width,t0=pt.height,E0=1,n0=null,m0=null;const h0=new Vector4(0,0,T0,t0),a0=new Vector4(0,0,T0,t0);let P0=!1;const V0=new Frustum;let B0=!1,W0=!1,K0=null;const Ty=new Matrix4,$y=new Vector2,My=new Vector3,Wy={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Ey(){return Zr===null?E0:1}let _0=vt;function ay(Go,g0){for(let b0=0;b0<Go.length;b0++){const I0=Go[b0],A0=pt.getContext(I0,g0);if(A0!==null)return A0}return null}try{const Go={alpha:!0,depth:wt,stencil:$t,antialias:Lt,premultipliedAlpha:Ft,preserveDrawingBuffer:Ct,powerPreference:Ht,failIfMajorPerformanceCaveat:Gt};if("setAttribute"in pt&&pt.setAttribute("data-engine",`three.js r${REVISION}`),pt.addEventListener("webglcontextlost",v0,!1),pt.addEventListener("webglcontextrestored",i0,!1),pt.addEventListener("webglcontextcreationerror",k0,!1),_0===null){const g0=["webgl2","webgl","experimental-webgl"];if(tr.isWebGL1Renderer===!0&&g0.shift(),_0=ay(g0,Go),_0===null)throw ay(g0)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}typeof WebGLRenderingContext<"u"&&_0 instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),_0.getShaderPrecisionFormat===void 0&&(_0.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Go){throw console.error("THREE.WebGLRenderer: "+Go.message),Go}let J0,yy,uy,Dy,Fy,qy,rv,y0,r0,M0,G0,sy,dy,Vy,Xy,hy,Ly,Py,Sy,Ev,Qy,cy,C0,U0;function xy(){J0=new WebGLExtensions(_0),yy=new WebGLCapabilities(_0,J0,at),J0.init(yy),cy=new WebGLUtils(_0,J0,yy),uy=new WebGLState(_0,J0,yy),Dy=new WebGLInfo(_0),Fy=new WebGLProperties,qy=new WebGLTextures(_0,J0,uy,Fy,yy,cy,Dy),rv=new WebGLCubeMaps(tr),y0=new WebGLCubeUVMaps(tr),r0=new WebGLAttributes(_0,yy),C0=new WebGLBindingStates(_0,J0,r0,yy),M0=new WebGLGeometries(_0,r0,Dy,C0),G0=new WebGLObjects(_0,M0,r0,Dy),Sy=new WebGLMorphtargets(_0,yy,qy),hy=new WebGLClipping(Fy),sy=new WebGLPrograms(tr,rv,y0,J0,yy,C0,hy),dy=new WebGLMaterials(tr,Fy),Vy=new WebGLRenderLists,Xy=new WebGLRenderStates(J0,yy),Py=new WebGLBackground(tr,rv,y0,uy,G0,jt,Ft),Ly=new WebGLShadowMap(tr,G0,yy),U0=new WebGLUniformsGroups(_0,Dy,yy,uy),Ev=new WebGLBufferRenderer(_0,J0,Dy,yy),Qy=new WebGLIndexedBufferRenderer(_0,J0,Dy,yy),Dy.programs=sy.programs,tr.capabilities=yy,tr.extensions=J0,tr.properties=Fy,tr.renderLists=Vy,tr.shadowMap=Ly,tr.state=uy,tr.info=Dy}xy();const o0=new WebXRManager(tr,_0);this.xr=o0,this.getContext=function(){return _0},this.getContextAttributes=function(){return _0.getContextAttributes()},this.forceContextLoss=function(){const Go=J0.get("WEBGL_lose_context");Go&&Go.loseContext()},this.forceContextRestore=function(){const Go=J0.get("WEBGL_lose_context");Go&&Go.restoreContext()},this.getPixelRatio=function(){return E0},this.setPixelRatio=function(Go){Go!==void 0&&(E0=Go,this.setSize(T0,t0,!1))},this.getSize=function(Go){return Go.set(T0,t0)},this.setSize=function(Go,g0,b0=!0){if(o0.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}T0=Go,t0=g0,pt.width=Math.floor(Go*E0),pt.height=Math.floor(g0*E0),b0===!0&&(pt.style.width=Go+"px",pt.style.height=g0+"px"),this.setViewport(0,0,Go,g0)},this.getDrawingBufferSize=function(Go){return Go.set(T0*E0,t0*E0).floor()},this.setDrawingBufferSize=function(Go,g0,b0){T0=Go,t0=g0,E0=b0,pt.width=Math.floor(Go*b0),pt.height=Math.floor(g0*b0),this.setViewport(0,0,Go,g0)},this.getCurrentViewport=function(Go){return Go.copy(Kr)},this.getViewport=function(Go){return Go.copy(h0)},this.setViewport=function(Go,g0,b0,I0){Go.isVector4?h0.set(Go.x,Go.y,Go.z,Go.w):h0.set(Go,g0,b0,I0),uy.viewport(Kr.copy(h0).multiplyScalar(E0).round())},this.getScissor=function(Go){return Go.copy(a0)},this.setScissor=function(Go,g0,b0,I0){Go.isVector4?a0.set(Go.x,Go.y,Go.z,Go.w):a0.set(Go,g0,b0,I0),uy.scissor(ko.copy(a0).multiplyScalar(E0).round())},this.getScissorTest=function(){return P0},this.setScissorTest=function(Go){uy.setScissorTest(P0=Go)},this.setOpaqueSort=function(Go){n0=Go},this.setTransparentSort=function(Go){m0=Go},this.getClearColor=function(Go){return Go.copy(Py.getClearColor())},this.setClearColor=function(){Py.setClearColor.apply(Py,arguments)},this.getClearAlpha=function(){return Py.getClearAlpha()},this.setClearAlpha=function(){Py.setClearAlpha.apply(Py,arguments)},this.clear=function(Go=!0,g0=!0,b0=!0){let I0=0;if(Go){let A0=!1;if(Zr!==null){const Y0=Zr.texture.format;A0=Y0===RGBAIntegerFormat||Y0===RGIntegerFormat||Y0===RedIntegerFormat}if(A0){const Y0=Zr.texture.type,ey=Y0===UnsignedByteType||Y0===UnsignedIntType||Y0===UnsignedShortType||Y0===UnsignedInt248Type||Y0===UnsignedShort4444Type||Y0===UnsignedShort5551Type,ny=Py.getClearColor(),ry=Py.getClearAlpha(),Ky=ny.r,wy=ny.g,Ry=ny.b;ey?(qt[0]=Ky,qt[1]=wy,qt[2]=Ry,qt[3]=ry,_0.clearBufferuiv(_0.COLOR,0,qt)):(Kt[0]=Ky,Kt[1]=wy,Kt[2]=Ry,Kt[3]=ry,_0.clearBufferiv(_0.COLOR,0,Kt))}else I0|=_0.COLOR_BUFFER_BIT}g0&&(I0|=_0.DEPTH_BUFFER_BIT),b0&&(I0|=_0.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),_0.clear(I0)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){pt.removeEventListener("webglcontextlost",v0,!1),pt.removeEventListener("webglcontextrestored",i0,!1),pt.removeEventListener("webglcontextcreationerror",k0,!1),Vy.dispose(),Xy.dispose(),Fy.dispose(),rv.dispose(),y0.dispose(),G0.dispose(),C0.dispose(),U0.dispose(),sy.dispose(),o0.dispose(),o0.removeEventListener("sessionstart",Rv),o0.removeEventListener("sessionend",Lv),K0&&(K0.dispose(),K0=null),Yv.stop()};function v0(Go){Go.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),rr=!0}function i0(){console.log("THREE.WebGLRenderer: Context Restored."),rr=!1;const Go=Dy.autoReset,g0=Ly.enabled,b0=Ly.autoUpdate,I0=Ly.needsUpdate,A0=Ly.type;xy(),Dy.autoReset=Go,Ly.enabled=g0,Ly.autoUpdate=b0,Ly.needsUpdate=I0,Ly.type=A0}function k0(Go){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",Go.statusMessage)}function $0(Go){const g0=Go.target;g0.removeEventListener("dispose",$0),ty(g0)}function ty(Go){my(Go),Fy.remove(Go)}function my(Go){const g0=Fy.get(Go).programs;g0!==void 0&&(g0.forEach(function(b0){sy.releaseProgram(b0)}),Go.isShaderMaterial&&sy.releaseShaderCache(Go))}this.renderBufferDirect=function(Go,g0,b0,I0,A0,Y0){g0===null&&(g0=Wy);const ey=A0.isMesh&&A0.matrixWorld.determinant()<0,ny=Qo(Go,g0,b0,I0,A0);uy.setMaterial(I0,ey);let ry=b0.index,Ky=1;if(I0.wireframe===!0){if(ry=M0.getWireframeAttribute(b0),ry===void 0)return;Ky=2}const wy=b0.drawRange,Ry=b0.attributes.position;let Hy=wy.start*Ky,uv=(wy.start+wy.count)*Ky;Y0!==null&&(Hy=Math.max(Hy,Y0.start*Ky),uv=Math.min(uv,(Y0.start+Y0.count)*Ky)),ry!==null?(Hy=Math.max(Hy,0),uv=Math.min(uv,ry.count)):Ry!=null&&(Hy=Math.max(Hy,0),uv=Math.min(uv,Ry.count));const dv=uv-Hy;if(dv<0||dv===1/0)return;C0.setup(A0,I0,ny,b0,ry);let pv,Zy=Ev;if(ry!==null&&(pv=r0.get(ry),Zy=Qy,Zy.setIndex(pv)),A0.isMesh)I0.wireframe===!0?(uy.setLineWidth(I0.wireframeLinewidth*Ey()),Zy.setMode(_0.LINES)):Zy.setMode(_0.TRIANGLES);else if(A0.isLine){let By=I0.linewidth;By===void 0&&(By=1),uy.setLineWidth(By*Ey()),A0.isLineSegments?Zy.setMode(_0.LINES):A0.isLineLoop?Zy.setMode(_0.LINE_LOOP):Zy.setMode(_0.LINE_STRIP)}else A0.isPoints?Zy.setMode(_0.POINTS):A0.isSprite&&Zy.setMode(_0.TRIANGLES);if(A0.isBatchedMesh)Zy.renderMultiDraw(A0._multiDrawStarts,A0._multiDrawCounts,A0._multiDrawCount);else if(A0.isInstancedMesh)Zy.renderInstances(Hy,dv,A0.count);else if(b0.isInstancedBufferGeometry){const By=b0._maxInstanceCount!==void 0?b0._maxInstanceCount:1/0,bv=Math.min(b0.instanceCount,By);Zy.renderInstances(Hy,dv,bv)}else Zy.render(Hy,dv)};function ev(Go,g0,b0){Go.transparent===!0&&Go.side===DoubleSide&&Go.forceSinglePass===!1?(Go.side=BackSide,Go.needsUpdate=!0,_v(Go,g0,b0),Go.side=FrontSide,Go.needsUpdate=!0,_v(Go,g0,b0),Go.side=DoubleSide):_v(Go,g0,b0)}this.compile=function(Go,g0,b0=null){b0===null&&(b0=Go),Sn=Xy.get(b0),Sn.init(),In.push(Sn),b0.traverseVisible(function(A0){A0.isLight&&A0.layers.test(g0.layers)&&(Sn.pushLight(A0),A0.castShadow&&Sn.pushShadow(A0))}),Go!==b0&&Go.traverseVisible(function(A0){A0.isLight&&A0.layers.test(g0.layers)&&(Sn.pushLight(A0),A0.castShadow&&Sn.pushShadow(A0))}),Sn.setupLights(tr._useLegacyLights);const I0=new Set;return Go.traverse(function(A0){const Y0=A0.material;if(Y0)if(Array.isArray(Y0))for(let ey=0;ey<Y0.length;ey++){const ny=Y0[ey];ev(ny,b0,A0),I0.add(ny)}else ev(Y0,b0,A0),I0.add(Y0)}),In.pop(),Sn=null,I0},this.compileAsync=function(Go,g0,b0=null){const I0=this.compile(Go,g0,b0);return new Promise(A0=>{function Y0(){if(I0.forEach(function(ey){Fy.get(ey).currentProgram.isReady()&&I0.delete(ey)}),I0.size===0){A0(Go);return}setTimeout(Y0,10)}J0.get("KHR_parallel_shader_compile")!==null?Y0():setTimeout(Y0,10)})};let vv=null;function Tv(Go){vv&&vv(Go)}function Rv(){Yv.stop()}function Lv(){Yv.start()}const Yv=new WebGLAnimation;Yv.setAnimationLoop(Tv),typeof self<"u"&&Yv.setContext(self),this.setAnimationLoop=function(Go){vv=Go,o0.setAnimationLoop(Go),Go===null?Yv.stop():Yv.start()},o0.addEventListener("sessionstart",Rv),o0.addEventListener("sessionend",Lv),this.render=function(Go,g0){if(g0!==void 0&&g0.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(rr===!0)return;Go.matrixWorldAutoUpdate===!0&&Go.updateMatrixWorld(),g0.parent===null&&g0.matrixWorldAutoUpdate===!0&&g0.updateMatrixWorld(),o0.enabled===!0&&o0.isPresenting===!0&&(o0.cameraAutoUpdate===!0&&o0.updateCamera(g0),g0=o0.getCamera()),Go.isScene===!0&&Go.onBeforeRender(tr,Go,g0,Zr),Sn=Xy.get(Go,In.length),Sn.init(),In.push(Sn),Ty.multiplyMatrices(g0.projectionMatrix,g0.matrixWorldInverse),V0.setFromProjectionMatrix(Ty),W0=this.localClippingEnabled,B0=hy.init(this.clippingPlanes,W0),An=Vy.get(Go,wn.length),An.init(),wn.push(An),X0(Go,g0,0,tr.sortObjects),An.finish(),tr.sortObjects===!0&&An.sort(n0,m0),this.info.render.frame++,B0===!0&&hy.beginShadows();const b0=Sn.state.shadowsArray;if(Ly.render(b0,Go,g0),B0===!0&&hy.endShadows(),this.info.autoReset===!0&&this.info.reset(),(o0.enabled===!1||o0.isPresenting===!1||o0.hasDepthSensing()===!1)&&Py.render(An,Go),Sn.setupLights(tr._useLegacyLights),g0.isArrayCamera){const I0=g0.cameras;for(let A0=0,Y0=I0.length;A0<Y0;A0++){const ey=I0[A0];Pv(An,Go,ey,ey.viewport)}}else Pv(An,Go,g0);Zr!==null&&(qy.updateMultisampleRenderTarget(Zr),qy.updateRenderTargetMipmap(Zr)),Go.isScene===!0&&Go.onAfterRender(tr,Go,g0),C0.resetDefaultState(),Bo=-1,Xo=null,In.pop(),In.length>0?Sn=In[In.length-1]:Sn=null,wn.pop(),wn.length>0?An=wn[wn.length-1]:An=null};function X0(Go,g0,b0,I0){if(Go.visible===!1)return;if(Go.layers.test(g0.layers)){if(Go.isGroup)b0=Go.renderOrder;else if(Go.isLOD)Go.autoUpdate===!0&&Go.update(g0);else if(Go.isLight)Sn.pushLight(Go),Go.castShadow&&Sn.pushShadow(Go);else if(Go.isSprite){if(!Go.frustumCulled||V0.intersectsSprite(Go)){I0&&My.setFromMatrixPosition(Go.matrixWorld).applyMatrix4(Ty);const ey=G0.update(Go),ny=Go.material;ny.visible&&An.push(Go,ey,ny,b0,My.z,null)}}else if((Go.isMesh||Go.isLine||Go.isPoints)&&(!Go.frustumCulled||V0.intersectsObject(Go))){const ey=G0.update(Go),ny=Go.material;if(I0&&(Go.boundingSphere!==void 0?(Go.boundingSphere===null&&Go.computeBoundingSphere(),My.copy(Go.boundingSphere.center)):(ey.boundingSphere===null&&ey.computeBoundingSphere(),My.copy(ey.boundingSphere.center)),My.applyMatrix4(Go.matrixWorld).applyMatrix4(Ty)),Array.isArray(ny)){const ry=ey.groups;for(let Ky=0,wy=ry.length;Ky<wy;Ky++){const Ry=ry[Ky],Hy=ny[Ry.materialIndex];Hy&&Hy.visible&&An.push(Go,ey,Hy,b0,My.z,Ry)}}else ny.visible&&An.push(Go,ey,ny,b0,My.z,null)}}const Y0=Go.children;for(let ey=0,ny=Y0.length;ey<ny;ey++)X0(Y0[ey],g0,b0,I0)}function Pv(Go,g0,b0,I0){const A0=Go.opaque,Y0=Go.transmissive,ey=Go.transparent;Sn.setupLightsView(b0),B0===!0&&hy.setGlobalState(tr.clippingPlanes,b0),Y0.length>0&&Fv(A0,Y0,g0,b0),I0&&uy.viewport(Kr.copy(I0)),A0.length>0&&Jv(A0,g0,b0),Y0.length>0&&Jv(Y0,g0,b0),ey.length>0&&Jv(ey,g0,b0),uy.buffers.depth.setTest(!0),uy.buffers.depth.setMask(!0),uy.buffers.color.setMask(!0),uy.setPolygonOffset(!1)}function Fv(Go,g0,b0,I0){if((b0.isScene===!0?b0.overrideMaterial:null)!==null)return;const Y0=yy.isWebGL2;K0===null&&(K0=new WebGLRenderTarget(1,1,{generateMipmaps:!0,type:J0.has("EXT_color_buffer_half_float")?HalfFloatType:UnsignedByteType,minFilter:LinearMipmapLinearFilter,samples:Y0?4:0})),tr.getDrawingBufferSize($y),Y0?K0.setSize($y.x,$y.y):K0.setSize(floorPowerOfTwo($y.x),floorPowerOfTwo($y.y));const ey=tr.getRenderTarget();tr.setRenderTarget(K0),tr.getClearColor(x0),l0=tr.getClearAlpha(),l0<1&&tr.setClearColor(16777215,.5),tr.clear();const ny=tr.toneMapping;tr.toneMapping=NoToneMapping,Jv(Go,b0,I0),qy.updateMultisampleRenderTarget(K0),qy.updateRenderTargetMipmap(K0);let ry=!1;for(let Ky=0,wy=g0.length;Ky<wy;Ky++){const Ry=g0[Ky],Hy=Ry.object,uv=Ry.geometry,dv=Ry.material,pv=Ry.group;if(dv.side===DoubleSide&&Hy.layers.test(I0.layers)){const Zy=dv.side;dv.side=BackSide,dv.needsUpdate=!0,g1(Hy,b0,I0,uv,dv,pv),dv.side=Zy,dv.needsUpdate=!0,ry=!0}}ry===!0&&(qy.updateMultisampleRenderTarget(K0),qy.updateRenderTargetMipmap(K0)),tr.setRenderTarget(ey),tr.setClearColor(x0,l0),tr.toneMapping=ny}function Jv(Go,g0,b0){const I0=g0.isScene===!0?g0.overrideMaterial:null;for(let A0=0,Y0=Go.length;A0<Y0;A0++){const ey=Go[A0],ny=ey.object,ry=ey.geometry,Ky=I0===null?ey.material:I0,wy=ey.group;ny.layers.test(b0.layers)&&g1(ny,g0,b0,ry,Ky,wy)}}function g1(Go,g0,b0,I0,A0,Y0){Go.onBeforeRender(tr,g0,b0,I0,A0,Y0),Go.modelViewMatrix.multiplyMatrices(b0.matrixWorldInverse,Go.matrixWorld),Go.normalMatrix.getNormalMatrix(Go.modelViewMatrix),A0.onBeforeRender(tr,g0,b0,I0,Go,Y0),A0.transparent===!0&&A0.side===DoubleSide&&A0.forceSinglePass===!1?(A0.side=BackSide,A0.needsUpdate=!0,tr.renderBufferDirect(b0,g0,I0,A0,Go,Y0),A0.side=FrontSide,A0.needsUpdate=!0,tr.renderBufferDirect(b0,g0,I0,A0,Go,Y0),A0.side=DoubleSide):tr.renderBufferDirect(b0,g0,I0,A0,Go,Y0),Go.onAfterRender(tr,g0,b0,I0,A0,Y0)}function _v(Go,g0,b0){g0.isScene!==!0&&(g0=Wy);const I0=Fy.get(Go),A0=Sn.state.lights,Y0=Sn.state.shadowsArray,ey=A0.state.version,ny=sy.getParameters(Go,A0.state,Y0,g0,b0),ry=sy.getProgramCacheKey(ny);let Ky=I0.programs;I0.environment=Go.isMeshStandardMaterial?g0.environment:null,I0.fog=g0.fog,I0.envMap=(Go.isMeshStandardMaterial?y0:rv).get(Go.envMap||I0.environment),I0.envMapRotation=I0.environment!==null&&Go.envMap===null?g0.environmentRotation:Go.envMapRotation,Ky===void 0&&(Go.addEventListener("dispose",$0),Ky=new Map,I0.programs=Ky);let wy=Ky.get(ry);if(wy!==void 0){if(I0.currentProgram===wy&&I0.lightsStateVersion===ey)return c_(Go,ny),wy}else ny.uniforms=sy.getUniforms(Go),Go.onBuild(b0,ny,tr),Go.onBeforeCompile(ny,tr),wy=sy.acquireProgram(ny,ry),Ky.set(ry,wy),I0.uniforms=ny.uniforms;const Ry=I0.uniforms;return(!Go.isShaderMaterial&&!Go.isRawShaderMaterial||Go.clipping===!0)&&(Ry.clippingPlanes=hy.uniform),c_(Go,ny),I0.needsLights=D0(Go),I0.lightsStateVersion=ey,I0.needsLights&&(Ry.ambientLightColor.value=A0.state.ambient,Ry.lightProbe.value=A0.state.probe,Ry.directionalLights.value=A0.state.directional,Ry.directionalLightShadows.value=A0.state.directionalShadow,Ry.spotLights.value=A0.state.spot,Ry.spotLightShadows.value=A0.state.spotShadow,Ry.rectAreaLights.value=A0.state.rectArea,Ry.ltc_1.value=A0.state.rectAreaLTC1,Ry.ltc_2.value=A0.state.rectAreaLTC2,Ry.pointLights.value=A0.state.point,Ry.pointLightShadows.value=A0.state.pointShadow,Ry.hemisphereLights.value=A0.state.hemi,Ry.directionalShadowMap.value=A0.state.directionalShadowMap,Ry.directionalShadowMatrix.value=A0.state.directionalShadowMatrix,Ry.spotShadowMap.value=A0.state.spotShadowMap,Ry.spotLightMatrix.value=A0.state.spotLightMatrix,Ry.spotLightMap.value=A0.state.spotLightMap,Ry.pointShadowMap.value=A0.state.pointShadowMap,Ry.pointShadowMatrix.value=A0.state.pointShadowMatrix),I0.currentProgram=wy,I0.uniformsList=null,wy}function Y1(Go){if(Go.uniformsList===null){const g0=Go.currentProgram.getUniforms();Go.uniformsList=WebGLUniforms.seqWithValue(g0.seq,Go.uniforms)}return Go.uniformsList}function c_(Go,g0){const b0=Fy.get(Go);b0.outputColorSpace=g0.outputColorSpace,b0.batching=g0.batching,b0.instancing=g0.instancing,b0.instancingColor=g0.instancingColor,b0.instancingMorph=g0.instancingMorph,b0.skinning=g0.skinning,b0.morphTargets=g0.morphTargets,b0.morphNormals=g0.morphNormals,b0.morphColors=g0.morphColors,b0.morphTargetsCount=g0.morphTargetsCount,b0.numClippingPlanes=g0.numClippingPlanes,b0.numIntersection=g0.numClipIntersection,b0.vertexAlphas=g0.vertexAlphas,b0.vertexTangents=g0.vertexTangents,b0.toneMapping=g0.toneMapping}function Qo(Go,g0,b0,I0,A0){g0.isScene!==!0&&(g0=Wy),qy.resetTextureUnits();const Y0=g0.fog,ey=I0.isMeshStandardMaterial?g0.environment:null,ny=Zr===null?tr.outputColorSpace:Zr.isXRRenderTarget===!0?Zr.texture.colorSpace:LinearSRGBColorSpace$1,ry=(I0.isMeshStandardMaterial?y0:rv).get(I0.envMap||ey),Ky=I0.vertexColors===!0&&!!b0.attributes.color&&b0.attributes.color.itemSize===4,wy=!!b0.attributes.tangent&&(!!I0.normalMap||I0.anisotropy>0),Ry=!!b0.morphAttributes.position,Hy=!!b0.morphAttributes.normal,uv=!!b0.morphAttributes.color;let dv=NoToneMapping;I0.toneMapped&&(Zr===null||Zr.isXRRenderTarget===!0)&&(dv=tr.toneMapping);const pv=b0.morphAttributes.position||b0.morphAttributes.normal||b0.morphAttributes.color,Zy=pv!==void 0?pv.length:0,By=Fy.get(I0),bv=Sn.state.lights;if(B0===!0&&(W0===!0||Go!==Xo)){const Av=Go===Xo&&I0.id===Bo;hy.setState(I0,Go,Av)}let fv=!1;I0.version===By.__version?(By.needsLights&&By.lightsStateVersion!==bv.state.version||By.outputColorSpace!==ny||A0.isBatchedMesh&&By.batching===!1||!A0.isBatchedMesh&&By.batching===!0||A0.isInstancedMesh&&By.instancing===!1||!A0.isInstancedMesh&&By.instancing===!0||A0.isSkinnedMesh&&By.skinning===!1||!A0.isSkinnedMesh&&By.skinning===!0||A0.isInstancedMesh&&By.instancingColor===!0&&A0.instanceColor===null||A0.isInstancedMesh&&By.instancingColor===!1&&A0.instanceColor!==null||A0.isInstancedMesh&&By.instancingMorph===!0&&A0.morphTexture===null||A0.isInstancedMesh&&By.instancingMorph===!1&&A0.morphTexture!==null||By.envMap!==ry||I0.fog===!0&&By.fog!==Y0||By.numClippingPlanes!==void 0&&(By.numClippingPlanes!==hy.numPlanes||By.numIntersection!==hy.numIntersection)||By.vertexAlphas!==Ky||By.vertexTangents!==wy||By.morphTargets!==Ry||By.morphNormals!==Hy||By.morphColors!==uv||By.toneMapping!==dv||yy.isWebGL2===!0&&By.morphTargetsCount!==Zy)&&(fv=!0):(fv=!0,By.__version=I0.version);let xv=By.currentProgram;fv===!0&&(xv=_v(I0,g0,A0));let t1=!1,u1=!1,c1=!1;const Gv=xv.getUniforms(),Ov=By.uniforms;if(uy.useProgram(xv.program)&&(t1=!0,u1=!0,c1=!0),I0.id!==Bo&&(Bo=I0.id,u1=!0),t1||Xo!==Go){Gv.setValue(_0,"projectionMatrix",Go.projectionMatrix),Gv.setValue(_0,"viewMatrix",Go.matrixWorldInverse);const Av=Gv.map.cameraPosition;Av!==void 0&&Av.setValue(_0,My.setFromMatrixPosition(Go.matrixWorld)),yy.logarithmicDepthBuffer&&Gv.setValue(_0,"logDepthBufFC",2/(Math.log(Go.far+1)/Math.LN2)),(I0.isMeshPhongMaterial||I0.isMeshToonMaterial||I0.isMeshLambertMaterial||I0.isMeshBasicMaterial||I0.isMeshStandardMaterial||I0.isShaderMaterial)&&Gv.setValue(_0,"isOrthographic",Go.isOrthographicCamera===!0),Xo!==Go&&(Xo=Go,u1=!0,c1=!0)}if(A0.isSkinnedMesh){Gv.setOptional(_0,A0,"bindMatrix"),Gv.setOptional(_0,A0,"bindMatrixInverse");const Av=A0.skeleton;Av&&(yy.floatVertexTextures?(Av.boneTexture===null&&Av.computeBoneTexture(),Gv.setValue(_0,"boneTexture",Av.boneTexture,qy)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}A0.isBatchedMesh&&(Gv.setOptional(_0,A0,"batchingTexture"),Gv.setValue(_0,"batchingTexture",A0._matricesTexture,qy));const jy=b0.morphAttributes;if((jy.position!==void 0||jy.normal!==void 0||jy.color!==void 0&&yy.isWebGL2===!0)&&Sy.update(A0,b0,xv),(u1||By.receiveShadow!==A0.receiveShadow)&&(By.receiveShadow=A0.receiveShadow,Gv.setValue(_0,"receiveShadow",A0.receiveShadow)),I0.isMeshGouraudMaterial&&I0.envMap!==null&&(Ov.envMap.value=ry,Ov.flipEnvMap.value=ry.isCubeTexture&&ry.isRenderTargetTexture===!1?-1:1),u1&&(Gv.setValue(_0,"toneMappingExposure",tr.toneMappingExposure),By.needsLights&&c0(Ov,c1),Y0&&I0.fog===!0&&dy.refreshFogUniforms(Ov,Y0),dy.refreshMaterialUniforms(Ov,I0,E0,t0,K0),WebGLUniforms.upload(_0,Y1(By),Ov,qy)),I0.isShaderMaterial&&I0.uniformsNeedUpdate===!0&&(WebGLUniforms.upload(_0,Y1(By),Ov,qy),I0.uniformsNeedUpdate=!1),I0.isSpriteMaterial&&Gv.setValue(_0,"center",A0.center),Gv.setValue(_0,"modelViewMatrix",A0.modelViewMatrix),Gv.setValue(_0,"normalMatrix",A0.normalMatrix),Gv.setValue(_0,"modelMatrix",A0.matrixWorld),I0.isShaderMaterial||I0.isRawShaderMaterial){const Av=I0.uniformsGroups;for(let zy=0,n1=Av.length;zy<n1;zy++)if(yy.isWebGL2){const m1=Av[zy];U0.update(m1,xv),U0.bind(m1,xv)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return xv}function c0(Go,g0){Go.ambientLightColor.needsUpdate=g0,Go.lightProbe.needsUpdate=g0,Go.directionalLights.needsUpdate=g0,Go.directionalLightShadows.needsUpdate=g0,Go.pointLights.needsUpdate=g0,Go.pointLightShadows.needsUpdate=g0,Go.spotLights.needsUpdate=g0,Go.spotLightShadows.needsUpdate=g0,Go.rectAreaLights.needsUpdate=g0,Go.hemisphereLights.needsUpdate=g0}function D0(Go){return Go.isMeshLambertMaterial||Go.isMeshToonMaterial||Go.isMeshPhongMaterial||Go.isMeshStandardMaterial||Go.isShadowMaterial||Go.isShaderMaterial&&Go.lights===!0}this.getActiveCubeFace=function(){return Hr},this.getActiveMipmapLevel=function(){return qr},this.getRenderTarget=function(){return Zr},this.setRenderTargetTextures=function(Go,g0,b0){Fy.get(Go.texture).__webglTexture=g0,Fy.get(Go.depthTexture).__webglTexture=b0;const I0=Fy.get(Go);I0.__hasExternalTextures=!0,I0.__autoAllocateDepthBuffer=b0===void 0,I0.__autoAllocateDepthBuffer||J0.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),I0.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(Go,g0){const b0=Fy.get(Go);b0.__webglFramebuffer=g0,b0.__useDefaultFramebuffer=g0===void 0},this.setRenderTarget=function(Go,g0=0,b0=0){Zr=Go,Hr=g0,qr=b0;let I0=!0,A0=null,Y0=!1,ey=!1;if(Go){const ry=Fy.get(Go);ry.__useDefaultFramebuffer!==void 0?(uy.bindFramebuffer(_0.FRAMEBUFFER,null),I0=!1):ry.__webglFramebuffer===void 0?qy.setupRenderTarget(Go):ry.__hasExternalTextures&&qy.rebindTextures(Go,Fy.get(Go.texture).__webglTexture,Fy.get(Go.depthTexture).__webglTexture);const Ky=Go.texture;(Ky.isData3DTexture||Ky.isDataArrayTexture||Ky.isCompressedArrayTexture)&&(ey=!0);const wy=Fy.get(Go).__webglFramebuffer;Go.isWebGLCubeRenderTarget?(Array.isArray(wy[g0])?A0=wy[g0][b0]:A0=wy[g0],Y0=!0):yy.isWebGL2&&Go.samples>0&&qy.useMultisampledRTT(Go)===!1?A0=Fy.get(Go).__webglMultisampledFramebuffer:Array.isArray(wy)?A0=wy[b0]:A0=wy,Kr.copy(Go.viewport),ko.copy(Go.scissor),f0=Go.scissorTest}else Kr.copy(h0).multiplyScalar(E0).floor(),ko.copy(a0).multiplyScalar(E0).floor(),f0=P0;if(uy.bindFramebuffer(_0.FRAMEBUFFER,A0)&&yy.drawBuffers&&I0&&uy.drawBuffers(Go,A0),uy.viewport(Kr),uy.scissor(ko),uy.setScissorTest(f0),Y0){const ry=Fy.get(Go.texture);_0.framebufferTexture2D(_0.FRAMEBUFFER,_0.COLOR_ATTACHMENT0,_0.TEXTURE_CUBE_MAP_POSITIVE_X+g0,ry.__webglTexture,b0)}else if(ey){const ry=Fy.get(Go.texture),Ky=g0||0;_0.framebufferTextureLayer(_0.FRAMEBUFFER,_0.COLOR_ATTACHMENT0,ry.__webglTexture,b0||0,Ky)}Bo=-1},this.readRenderTargetPixels=function(Go,g0,b0,I0,A0,Y0,ey){if(!(Go&&Go.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let ny=Fy.get(Go).__webglFramebuffer;if(Go.isWebGLCubeRenderTarget&&ey!==void 0&&(ny=ny[ey]),ny){uy.bindFramebuffer(_0.FRAMEBUFFER,ny);try{const ry=Go.texture,Ky=ry.format,wy=ry.type;if(Ky!==RGBAFormat&&cy.convert(Ky)!==_0.getParameter(_0.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Ry=wy===HalfFloatType&&(J0.has("EXT_color_buffer_half_float")||yy.isWebGL2&&J0.has("EXT_color_buffer_float"));if(wy!==UnsignedByteType&&cy.convert(wy)!==_0.getParameter(_0.IMPLEMENTATION_COLOR_READ_TYPE)&&!(wy===FloatType&&(yy.isWebGL2||J0.has("OES_texture_float")||J0.has("WEBGL_color_buffer_float")))&&!Ry){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}g0>=0&&g0<=Go.width-I0&&b0>=0&&b0<=Go.height-A0&&_0.readPixels(g0,b0,I0,A0,cy.convert(Ky),cy.convert(wy),Y0)}finally{const ry=Zr!==null?Fy.get(Zr).__webglFramebuffer:null;uy.bindFramebuffer(_0.FRAMEBUFFER,ry)}}},this.copyFramebufferToTexture=function(Go,g0,b0=0){const I0=Math.pow(2,-b0),A0=Math.floor(g0.image.width*I0),Y0=Math.floor(g0.image.height*I0);qy.setTexture2D(g0,0),_0.copyTexSubImage2D(_0.TEXTURE_2D,b0,0,0,Go.x,Go.y,A0,Y0),uy.unbindTexture()},this.copyTextureToTexture=function(Go,g0,b0,I0=0){const A0=g0.image.width,Y0=g0.image.height,ey=cy.convert(b0.format),ny=cy.convert(b0.type);qy.setTexture2D(b0,0),_0.pixelStorei(_0.UNPACK_FLIP_Y_WEBGL,b0.flipY),_0.pixelStorei(_0.UNPACK_PREMULTIPLY_ALPHA_WEBGL,b0.premultiplyAlpha),_0.pixelStorei(_0.UNPACK_ALIGNMENT,b0.unpackAlignment),g0.isDataTexture?_0.texSubImage2D(_0.TEXTURE_2D,I0,Go.x,Go.y,A0,Y0,ey,ny,g0.image.data):g0.isCompressedTexture?_0.compressedTexSubImage2D(_0.TEXTURE_2D,I0,Go.x,Go.y,g0.mipmaps[0].width,g0.mipmaps[0].height,ey,g0.mipmaps[0].data):_0.texSubImage2D(_0.TEXTURE_2D,I0,Go.x,Go.y,ey,ny,g0.image),I0===0&&b0.generateMipmaps&&_0.generateMipmap(_0.TEXTURE_2D),uy.unbindTexture()},this.copyTextureToTexture3D=function(Go,g0,b0,I0,A0=0){if(tr.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const Y0=Math.round(Go.max.x-Go.min.x),ey=Math.round(Go.max.y-Go.min.y),ny=Go.max.z-Go.min.z+1,ry=cy.convert(I0.format),Ky=cy.convert(I0.type);let wy;if(I0.isData3DTexture)qy.setTexture3D(I0,0),wy=_0.TEXTURE_3D;else if(I0.isDataArrayTexture||I0.isCompressedArrayTexture)qy.setTexture2DArray(I0,0),wy=_0.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}_0.pixelStorei(_0.UNPACK_FLIP_Y_WEBGL,I0.flipY),_0.pixelStorei(_0.UNPACK_PREMULTIPLY_ALPHA_WEBGL,I0.premultiplyAlpha),_0.pixelStorei(_0.UNPACK_ALIGNMENT,I0.unpackAlignment);const Ry=_0.getParameter(_0.UNPACK_ROW_LENGTH),Hy=_0.getParameter(_0.UNPACK_IMAGE_HEIGHT),uv=_0.getParameter(_0.UNPACK_SKIP_PIXELS),dv=_0.getParameter(_0.UNPACK_SKIP_ROWS),pv=_0.getParameter(_0.UNPACK_SKIP_IMAGES),Zy=b0.isCompressedTexture?b0.mipmaps[A0]:b0.image;_0.pixelStorei(_0.UNPACK_ROW_LENGTH,Zy.width),_0.pixelStorei(_0.UNPACK_IMAGE_HEIGHT,Zy.height),_0.pixelStorei(_0.UNPACK_SKIP_PIXELS,Go.min.x),_0.pixelStorei(_0.UNPACK_SKIP_ROWS,Go.min.y),_0.pixelStorei(_0.UNPACK_SKIP_IMAGES,Go.min.z),b0.isDataTexture||b0.isData3DTexture?_0.texSubImage3D(wy,A0,g0.x,g0.y,g0.z,Y0,ey,ny,ry,Ky,Zy.data):I0.isCompressedArrayTexture?_0.compressedTexSubImage3D(wy,A0,g0.x,g0.y,g0.z,Y0,ey,ny,ry,Zy.data):_0.texSubImage3D(wy,A0,g0.x,g0.y,g0.z,Y0,ey,ny,ry,Ky,Zy),_0.pixelStorei(_0.UNPACK_ROW_LENGTH,Ry),_0.pixelStorei(_0.UNPACK_IMAGE_HEIGHT,Hy),_0.pixelStorei(_0.UNPACK_SKIP_PIXELS,uv),_0.pixelStorei(_0.UNPACK_SKIP_ROWS,dv),_0.pixelStorei(_0.UNPACK_SKIP_IMAGES,pv),A0===0&&I0.generateMipmaps&&_0.generateMipmap(wy),uy.unbindTexture()},this.initTexture=function(Go){Go.isCubeTexture?qy.setTextureCube(Go,0):Go.isData3DTexture?qy.setTexture3D(Go,0):Go.isDataArrayTexture||Go.isCompressedArrayTexture?qy.setTexture2DArray(Go,0):qy.setTexture2D(Go,0),uy.unbindTexture()},this.resetState=function(){Hr=0,qr=0,Zr=null,uy.reset(),C0.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return WebGLCoordinateSystem}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(at){this._outputColorSpace=at;const pt=this.getContext();pt.drawingBufferColorSpace=at===DisplayP3ColorSpace?"display-p3":"srgb",pt.unpackColorSpace=ColorManagement.workingColorSpace===LinearDisplayP3ColorSpace?"display-p3":"srgb"}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(at){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=at}}class WebGL1Renderer extends WebGLRenderer{}WebGL1Renderer.prototype.isWebGL1Renderer=!0;class FogExp2{constructor(at,pt=25e-5){this.isFogExp2=!0,this.name="",this.color=new Color$1(at),this.density=pt}clone(){return new FogExp2(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class Fog{constructor(at,pt=1,vt=1e3){this.isFog=!0,this.name="",this.color=new Color$1(at),this.near=pt,this.far=vt}clone(){return new Fog(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class Scene extends Object3D{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Euler,this.environmentRotation=new Euler,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(at,pt){return super.copy(at,pt),at.background!==null&&(this.background=at.background.clone()),at.environment!==null&&(this.environment=at.environment.clone()),at.fog!==null&&(this.fog=at.fog.clone()),this.backgroundBlurriness=at.backgroundBlurriness,this.backgroundIntensity=at.backgroundIntensity,this.backgroundRotation.copy(at.backgroundRotation),this.environmentRotation.copy(at.environmentRotation),at.overrideMaterial!==null&&(this.overrideMaterial=at.overrideMaterial.clone()),this.matrixAutoUpdate=at.matrixAutoUpdate,this}toJSON(at){const pt=super.toJSON(at);return this.fog!==null&&(pt.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(pt.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(pt.object.backgroundIntensity=this.backgroundIntensity),pt.object.backgroundRotation=this.backgroundRotation.toArray(),pt.object.environmentRotation=this.environmentRotation.toArray(),pt}}class InterleavedBuffer{constructor(at,pt){this.isInterleavedBuffer=!0,this.array=at,this.stride=pt,this.count=at!==void 0?at.length/pt:0,this.usage=StaticDrawUsage,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=generateUUID()}onUploadCallback(){}set needsUpdate(at){at===!0&&this.version++}get updateRange(){return warnOnce("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(at){return this.usage=at,this}addUpdateRange(at,pt){this.updateRanges.push({start:at,count:pt})}clearUpdateRanges(){this.updateRanges.length=0}copy(at){return this.array=new at.array.constructor(at.array),this.count=at.count,this.stride=at.stride,this.usage=at.usage,this}copyAt(at,pt,vt){at*=this.stride,vt*=pt.stride;for(let wt=0,$t=this.stride;wt<$t;wt++)this.array[at+wt]=pt.array[vt+wt];return this}set(at,pt=0){return this.array.set(at,pt),this}clone(at){at.arrayBuffers===void 0&&(at.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=generateUUID()),at.arrayBuffers[this.array.buffer._uuid]===void 0&&(at.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const pt=new this.array.constructor(at.arrayBuffers[this.array.buffer._uuid]),vt=new this.constructor(pt,this.stride);return vt.setUsage(this.usage),vt}onUpload(at){return this.onUploadCallback=at,this}toJSON(at){return at.arrayBuffers===void 0&&(at.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=generateUUID()),at.arrayBuffers[this.array.buffer._uuid]===void 0&&(at.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const _vector$6=new Vector3;class InterleavedBufferAttribute{constructor(at,pt,vt,wt=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=at,this.itemSize=pt,this.offset=vt,this.normalized=wt}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(at){this.data.needsUpdate=at}applyMatrix4(at){for(let pt=0,vt=this.data.count;pt<vt;pt++)_vector$6.fromBufferAttribute(this,pt),_vector$6.applyMatrix4(at),this.setXYZ(pt,_vector$6.x,_vector$6.y,_vector$6.z);return this}applyNormalMatrix(at){for(let pt=0,vt=this.count;pt<vt;pt++)_vector$6.fromBufferAttribute(this,pt),_vector$6.applyNormalMatrix(at),this.setXYZ(pt,_vector$6.x,_vector$6.y,_vector$6.z);return this}transformDirection(at){for(let pt=0,vt=this.count;pt<vt;pt++)_vector$6.fromBufferAttribute(this,pt),_vector$6.transformDirection(at),this.setXYZ(pt,_vector$6.x,_vector$6.y,_vector$6.z);return this}getComponent(at,pt){let vt=this.array[at*this.data.stride+this.offset+pt];return this.normalized&&(vt=denormalize(vt,this.array)),vt}setComponent(at,pt,vt){return this.normalized&&(vt=normalize$5(vt,this.array)),this.data.array[at*this.data.stride+this.offset+pt]=vt,this}setX(at,pt){return this.normalized&&(pt=normalize$5(pt,this.array)),this.data.array[at*this.data.stride+this.offset]=pt,this}setY(at,pt){return this.normalized&&(pt=normalize$5(pt,this.array)),this.data.array[at*this.data.stride+this.offset+1]=pt,this}setZ(at,pt){return this.normalized&&(pt=normalize$5(pt,this.array)),this.data.array[at*this.data.stride+this.offset+2]=pt,this}setW(at,pt){return this.normalized&&(pt=normalize$5(pt,this.array)),this.data.array[at*this.data.stride+this.offset+3]=pt,this}getX(at){let pt=this.data.array[at*this.data.stride+this.offset];return this.normalized&&(pt=denormalize(pt,this.array)),pt}getY(at){let pt=this.data.array[at*this.data.stride+this.offset+1];return this.normalized&&(pt=denormalize(pt,this.array)),pt}getZ(at){let pt=this.data.array[at*this.data.stride+this.offset+2];return this.normalized&&(pt=denormalize(pt,this.array)),pt}getW(at){let pt=this.data.array[at*this.data.stride+this.offset+3];return this.normalized&&(pt=denormalize(pt,this.array)),pt}setXY(at,pt,vt){return at=at*this.data.stride+this.offset,this.normalized&&(pt=normalize$5(pt,this.array),vt=normalize$5(vt,this.array)),this.data.array[at+0]=pt,this.data.array[at+1]=vt,this}setXYZ(at,pt,vt,wt){return at=at*this.data.stride+this.offset,this.normalized&&(pt=normalize$5(pt,this.array),vt=normalize$5(vt,this.array),wt=normalize$5(wt,this.array)),this.data.array[at+0]=pt,this.data.array[at+1]=vt,this.data.array[at+2]=wt,this}setXYZW(at,pt,vt,wt,$t){return at=at*this.data.stride+this.offset,this.normalized&&(pt=normalize$5(pt,this.array),vt=normalize$5(vt,this.array),wt=normalize$5(wt,this.array),$t=normalize$5($t,this.array)),this.data.array[at+0]=pt,this.data.array[at+1]=vt,this.data.array[at+2]=wt,this.data.array[at+3]=$t,this}clone(at){if(at===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const pt=[];for(let vt=0;vt<this.count;vt++){const wt=vt*this.data.stride+this.offset;for(let $t=0;$t<this.itemSize;$t++)pt.push(this.data.array[wt+$t])}return new BufferAttribute(new this.array.constructor(pt),this.itemSize,this.normalized)}else return at.interleavedBuffers===void 0&&(at.interleavedBuffers={}),at.interleavedBuffers[this.data.uuid]===void 0&&(at.interleavedBuffers[this.data.uuid]=this.data.clone(at)),new InterleavedBufferAttribute(at.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(at){if(at===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const pt=[];for(let vt=0;vt<this.count;vt++){const wt=vt*this.data.stride+this.offset;for(let $t=0;$t<this.itemSize;$t++)pt.push(this.data.array[wt+$t])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:pt,normalized:this.normalized}}else return at.interleavedBuffers===void 0&&(at.interleavedBuffers={}),at.interleavedBuffers[this.data.uuid]===void 0&&(at.interleavedBuffers[this.data.uuid]=this.data.toJSON(at)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class SpriteMaterial extends Material{constructor(at){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Color$1(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(at)}copy(at){return super.copy(at),this.color.copy(at.color),this.map=at.map,this.alphaMap=at.alphaMap,this.rotation=at.rotation,this.sizeAttenuation=at.sizeAttenuation,this.fog=at.fog,this}}let _geometry;const _intersectPoint=new Vector3,_worldScale=new Vector3,_mvPosition=new Vector3,_alignedPosition=new Vector2,_rotatedPosition=new Vector2,_viewWorldMatrix=new Matrix4,_vA=new Vector3,_vB=new Vector3,_vC=new Vector3,_uvA=new Vector2,_uvB=new Vector2,_uvC=new Vector2;class Sprite extends Object3D{constructor(at=new SpriteMaterial){if(super(),this.isSprite=!0,this.type="Sprite",_geometry===void 0){_geometry=new BufferGeometry;const pt=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),vt=new InterleavedBuffer(pt,5);_geometry.setIndex([0,1,2,0,2,3]),_geometry.setAttribute("position",new InterleavedBufferAttribute(vt,3,0,!1)),_geometry.setAttribute("uv",new InterleavedBufferAttribute(vt,2,3,!1))}this.geometry=_geometry,this.material=at,this.center=new Vector2(.5,.5)}raycast(at,pt){at.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),_worldScale.setFromMatrixScale(this.matrixWorld),_viewWorldMatrix.copy(at.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(at.camera.matrixWorldInverse,this.matrixWorld),_mvPosition.setFromMatrixPosition(this.modelViewMatrix),at.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&_worldScale.multiplyScalar(-_mvPosition.z);const vt=this.material.rotation;let wt,$t;vt!==0&&($t=Math.cos(vt),wt=Math.sin(vt));const Tt=this.center;transformVertex(_vA.set(-.5,-.5,0),_mvPosition,Tt,_worldScale,wt,$t),transformVertex(_vB.set(.5,-.5,0),_mvPosition,Tt,_worldScale,wt,$t),transformVertex(_vC.set(.5,.5,0),_mvPosition,Tt,_worldScale,wt,$t),_uvA.set(0,0),_uvB.set(1,0),_uvC.set(1,1);let Lt=at.ray.intersectTriangle(_vA,_vB,_vC,!1,_intersectPoint);if(Lt===null&&(transformVertex(_vB.set(-.5,.5,0),_mvPosition,Tt,_worldScale,wt,$t),_uvB.set(0,1),Lt=at.ray.intersectTriangle(_vA,_vC,_vB,!1,_intersectPoint),Lt===null))return;const Ft=at.ray.origin.distanceTo(_intersectPoint);Ft<at.near||Ft>at.far||pt.push({distance:Ft,point:_intersectPoint.clone(),uv:Triangle.getInterpolation(_intersectPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new Vector2),face:null,object:this})}copy(at,pt){return super.copy(at,pt),at.center!==void 0&&this.center.copy(at.center),this.material=at.material,this}}function transformVertex(st,at,pt,vt,wt,$t){_alignedPosition.subVectors(st,pt).addScalar(.5).multiply(vt),wt!==void 0?(_rotatedPosition.x=$t*_alignedPosition.x-wt*_alignedPosition.y,_rotatedPosition.y=wt*_alignedPosition.x+$t*_alignedPosition.y):_rotatedPosition.copy(_alignedPosition),st.copy(at),st.x+=_rotatedPosition.x,st.y+=_rotatedPosition.y,st.applyMatrix4(_viewWorldMatrix)}const _v1$2=new Vector3,_v2$1=new Vector3;class LOD extends Object3D{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(at){super.copy(at,!1);const pt=at.levels;for(let vt=0,wt=pt.length;vt<wt;vt++){const $t=pt[vt];this.addLevel($t.object.clone(),$t.distance,$t.hysteresis)}return this.autoUpdate=at.autoUpdate,this}addLevel(at,pt=0,vt=0){pt=Math.abs(pt);const wt=this.levels;let $t;for($t=0;$t<wt.length&&!(pt<wt[$t].distance);$t++);return wt.splice($t,0,{distance:pt,hysteresis:vt,object:at}),this.add(at),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(at){const pt=this.levels;if(pt.length>0){let vt,wt;for(vt=1,wt=pt.length;vt<wt;vt++){let $t=pt[vt].distance;if(pt[vt].object.visible&&($t-=$t*pt[vt].hysteresis),at<$t)break}return pt[vt-1].object}return null}raycast(at,pt){if(this.levels.length>0){_v1$2.setFromMatrixPosition(this.matrixWorld);const wt=at.ray.origin.distanceTo(_v1$2);this.getObjectForDistance(wt).raycast(at,pt)}}update(at){const pt=this.levels;if(pt.length>1){_v1$2.setFromMatrixPosition(at.matrixWorld),_v2$1.setFromMatrixPosition(this.matrixWorld);const vt=_v1$2.distanceTo(_v2$1)/at.zoom;pt[0].object.visible=!0;let wt,$t;for(wt=1,$t=pt.length;wt<$t;wt++){let Tt=pt[wt].distance;if(pt[wt].object.visible&&(Tt-=Tt*pt[wt].hysteresis),vt>=Tt)pt[wt-1].object.visible=!1,pt[wt].object.visible=!0;else break}for(this._currentLevel=wt-1;wt<$t;wt++)pt[wt].object.visible=!1}}toJSON(at){const pt=super.toJSON(at);this.autoUpdate===!1&&(pt.object.autoUpdate=!1),pt.object.levels=[];const vt=this.levels;for(let wt=0,$t=vt.length;wt<$t;wt++){const Tt=vt[wt];pt.object.levels.push({object:Tt.object.uuid,distance:Tt.distance,hysteresis:Tt.hysteresis})}return pt}}const _basePosition=new Vector3,_skinIndex=new Vector4,_skinWeight=new Vector4,_vector3=new Vector3,_matrix4=new Matrix4,_vertex=new Vector3,_sphere$4=new Sphere,_inverseMatrix$2=new Matrix4,_ray$2=new Ray;class SkinnedMesh extends Mesh{constructor(at,pt){super(at,pt),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=AttachedBindMode,this.bindMatrix=new Matrix4,this.bindMatrixInverse=new Matrix4,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const at=this.geometry;this.boundingBox===null&&(this.boundingBox=new Box3),this.boundingBox.makeEmpty();const pt=at.getAttribute("position");for(let vt=0;vt<pt.count;vt++)this.getVertexPosition(vt,_vertex),this.boundingBox.expandByPoint(_vertex)}computeBoundingSphere(){const at=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Sphere),this.boundingSphere.makeEmpty();const pt=at.getAttribute("position");for(let vt=0;vt<pt.count;vt++)this.getVertexPosition(vt,_vertex),this.boundingSphere.expandByPoint(_vertex)}copy(at,pt){return super.copy(at,pt),this.bindMode=at.bindMode,this.bindMatrix.copy(at.bindMatrix),this.bindMatrixInverse.copy(at.bindMatrixInverse),this.skeleton=at.skeleton,at.boundingBox!==null&&(this.boundingBox=at.boundingBox.clone()),at.boundingSphere!==null&&(this.boundingSphere=at.boundingSphere.clone()),this}raycast(at,pt){const vt=this.material,wt=this.matrixWorld;vt!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_sphere$4.copy(this.boundingSphere),_sphere$4.applyMatrix4(wt),at.ray.intersectsSphere(_sphere$4)!==!1&&(_inverseMatrix$2.copy(wt).invert(),_ray$2.copy(at.ray).applyMatrix4(_inverseMatrix$2),!(this.boundingBox!==null&&_ray$2.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(at,pt,_ray$2)))}getVertexPosition(at,pt){return super.getVertexPosition(at,pt),this.applyBoneTransform(at,pt),pt}bind(at,pt){this.skeleton=at,pt===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),pt=this.matrixWorld),this.bindMatrix.copy(pt),this.bindMatrixInverse.copy(pt).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const at=new Vector4,pt=this.geometry.attributes.skinWeight;for(let vt=0,wt=pt.count;vt<wt;vt++){at.fromBufferAttribute(pt,vt);const $t=1/at.manhattanLength();$t!==1/0?at.multiplyScalar($t):at.set(1,0,0,0),pt.setXYZW(vt,at.x,at.y,at.z,at.w)}}updateMatrixWorld(at){super.updateMatrixWorld(at),this.bindMode===AttachedBindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===DetachedBindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(at,pt){const vt=this.skeleton,wt=this.geometry;_skinIndex.fromBufferAttribute(wt.attributes.skinIndex,at),_skinWeight.fromBufferAttribute(wt.attributes.skinWeight,at),_basePosition.copy(pt).applyMatrix4(this.bindMatrix),pt.set(0,0,0);for(let $t=0;$t<4;$t++){const Tt=_skinWeight.getComponent($t);if(Tt!==0){const Lt=_skinIndex.getComponent($t);_matrix4.multiplyMatrices(vt.bones[Lt].matrixWorld,vt.boneInverses[Lt]),pt.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4),Tt)}}return pt.applyMatrix4(this.bindMatrixInverse)}}class Bone extends Object3D{constructor(){super(),this.isBone=!0,this.type="Bone"}}class DataTexture extends Texture{constructor(at=null,pt=1,vt=1,wt,$t,Tt,Lt,Ft,Ct=NearestFilter,Ht=NearestFilter,Gt,jt){super(null,Tt,Lt,Ft,Ct,Ht,wt,$t,Gt,jt),this.isDataTexture=!0,this.image={data:at,width:pt,height:vt},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const _offsetMatrix=new Matrix4,_identityMatrix$1=new Matrix4;class Skeleton{constructor(at=[],pt=[]){this.uuid=generateUUID(),this.bones=at.slice(0),this.boneInverses=pt,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const at=this.bones,pt=this.boneInverses;if(this.boneMatrices=new Float32Array(at.length*16),pt.length===0)this.calculateInverses();else if(at.length!==pt.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let vt=0,wt=this.bones.length;vt<wt;vt++)this.boneInverses.push(new Matrix4)}}calculateInverses(){this.boneInverses.length=0;for(let at=0,pt=this.bones.length;at<pt;at++){const vt=new Matrix4;this.bones[at]&&vt.copy(this.bones[at].matrixWorld).invert(),this.boneInverses.push(vt)}}pose(){for(let at=0,pt=this.bones.length;at<pt;at++){const vt=this.bones[at];vt&&vt.matrixWorld.copy(this.boneInverses[at]).invert()}for(let at=0,pt=this.bones.length;at<pt;at++){const vt=this.bones[at];vt&&(vt.parent&&vt.parent.isBone?(vt.matrix.copy(vt.parent.matrixWorld).invert(),vt.matrix.multiply(vt.matrixWorld)):vt.matrix.copy(vt.matrixWorld),vt.matrix.decompose(vt.position,vt.quaternion,vt.scale))}}update(){const at=this.bones,pt=this.boneInverses,vt=this.boneMatrices,wt=this.boneTexture;for(let $t=0,Tt=at.length;$t<Tt;$t++){const Lt=at[$t]?at[$t].matrixWorld:_identityMatrix$1;_offsetMatrix.multiplyMatrices(Lt,pt[$t]),_offsetMatrix.toArray(vt,$t*16)}wt!==null&&(wt.needsUpdate=!0)}clone(){return new Skeleton(this.bones,this.boneInverses)}computeBoneTexture(){let at=Math.sqrt(this.bones.length*4);at=Math.ceil(at/4)*4,at=Math.max(at,4);const pt=new Float32Array(at*at*4);pt.set(this.boneMatrices);const vt=new DataTexture(pt,at,at,RGBAFormat,FloatType);return vt.needsUpdate=!0,this.boneMatrices=pt,this.boneTexture=vt,this}getBoneByName(at){for(let pt=0,vt=this.bones.length;pt<vt;pt++){const wt=this.bones[pt];if(wt.name===at)return wt}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(at,pt){this.uuid=at.uuid;for(let vt=0,wt=at.bones.length;vt<wt;vt++){const $t=at.bones[vt];let Tt=pt[$t];Tt===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",$t),Tt=new Bone),this.bones.push(Tt),this.boneInverses.push(new Matrix4().fromArray(at.boneInverses[vt]))}return this.init(),this}toJSON(){const at={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};at.uuid=this.uuid;const pt=this.bones,vt=this.boneInverses;for(let wt=0,$t=pt.length;wt<$t;wt++){const Tt=pt[wt];at.bones.push(Tt.uuid);const Lt=vt[wt];at.boneInverses.push(Lt.toArray())}return at}}class InstancedBufferAttribute extends BufferAttribute{constructor(at,pt,vt,wt=1){super(at,pt,vt),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=wt}copy(at){return super.copy(at),this.meshPerAttribute=at.meshPerAttribute,this}toJSON(){const at=super.toJSON();return at.meshPerAttribute=this.meshPerAttribute,at.isInstancedBufferAttribute=!0,at}}const _instanceLocalMatrix=new Matrix4,_instanceWorldMatrix=new Matrix4,_instanceIntersects=[],_box3=new Box3,_identity=new Matrix4,_mesh$1=new Mesh,_sphere$3=new Sphere;class InstancedMesh extends Mesh{constructor(at,pt,vt){super(at,pt),this.isInstancedMesh=!0,this.instanceMatrix=new InstancedBufferAttribute(new Float32Array(vt*16),16),this.instanceColor=null,this.morphTexture=null,this.count=vt,this.boundingBox=null,this.boundingSphere=null;for(let wt=0;wt<vt;wt++)this.setMatrixAt(wt,_identity)}computeBoundingBox(){const at=this.geometry,pt=this.count;this.boundingBox===null&&(this.boundingBox=new Box3),at.boundingBox===null&&at.computeBoundingBox(),this.boundingBox.makeEmpty();for(let vt=0;vt<pt;vt++)this.getMatrixAt(vt,_instanceLocalMatrix),_box3.copy(at.boundingBox).applyMatrix4(_instanceLocalMatrix),this.boundingBox.union(_box3)}computeBoundingSphere(){const at=this.geometry,pt=this.count;this.boundingSphere===null&&(this.boundingSphere=new Sphere),at.boundingSphere===null&&at.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let vt=0;vt<pt;vt++)this.getMatrixAt(vt,_instanceLocalMatrix),_sphere$3.copy(at.boundingSphere).applyMatrix4(_instanceLocalMatrix),this.boundingSphere.union(_sphere$3)}copy(at,pt){return super.copy(at,pt),this.instanceMatrix.copy(at.instanceMatrix),at.instanceColor!==null&&(this.instanceColor=at.instanceColor.clone()),this.count=at.count,at.boundingBox!==null&&(this.boundingBox=at.boundingBox.clone()),at.boundingSphere!==null&&(this.boundingSphere=at.boundingSphere.clone()),this}getColorAt(at,pt){pt.fromArray(this.instanceColor.array,at*3)}getMatrixAt(at,pt){pt.fromArray(this.instanceMatrix.array,at*16)}getMorphAt(at,pt){const vt=pt.morphTargetInfluences,wt=this.morphTexture.source.data.data,$t=vt.length+1,Tt=at*$t+1;for(let Lt=0;Lt<vt.length;Lt++)vt[Lt]=wt[Tt+Lt]}raycast(at,pt){const vt=this.matrixWorld,wt=this.count;if(_mesh$1.geometry=this.geometry,_mesh$1.material=this.material,_mesh$1.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_sphere$3.copy(this.boundingSphere),_sphere$3.applyMatrix4(vt),at.ray.intersectsSphere(_sphere$3)!==!1))for(let $t=0;$t<wt;$t++){this.getMatrixAt($t,_instanceLocalMatrix),_instanceWorldMatrix.multiplyMatrices(vt,_instanceLocalMatrix),_mesh$1.matrixWorld=_instanceWorldMatrix,_mesh$1.raycast(at,_instanceIntersects);for(let Tt=0,Lt=_instanceIntersects.length;Tt<Lt;Tt++){const Ft=_instanceIntersects[Tt];Ft.instanceId=$t,Ft.object=this,pt.push(Ft)}_instanceIntersects.length=0}}setColorAt(at,pt){this.instanceColor===null&&(this.instanceColor=new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count*3),3)),pt.toArray(this.instanceColor.array,at*3)}setMatrixAt(at,pt){pt.toArray(this.instanceMatrix.array,at*16)}setMorphAt(at,pt){const vt=pt.morphTargetInfluences,wt=vt.length+1;this.morphTexture===null&&(this.morphTexture=new DataTexture(new Float32Array(wt*this.count),wt,this.count,RedFormat,FloatType));const $t=this.morphTexture.source.data.data;let Tt=0;for(let Ct=0;Ct<vt.length;Ct++)Tt+=vt[Ct];const Lt=this.geometry.morphTargetsRelative?1:1-Tt,Ft=wt*at;$t[Ft]=Lt,$t.set(vt,Ft+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}function sortOpaque(st,at){return st.z-at.z}function sortTransparent(st,at){return at.z-st.z}class MultiDrawRenderList{constructor(){this.index=0,this.pool=[],this.list=[]}push(at,pt){const vt=this.pool,wt=this.list;this.index>=vt.length&&vt.push({start:-1,count:-1,z:-1});const $t=vt[this.index];wt.push($t),this.index++,$t.start=at.start,$t.count=at.count,$t.z=pt}reset(){this.list.length=0,this.index=0}}const ID_ATTR_NAME="batchId",_matrix$1=new Matrix4,_invMatrixWorld=new Matrix4,_identityMatrix$2=new Matrix4,_projScreenMatrix$2=new Matrix4,_frustum=new Frustum,_box$1=new Box3,_sphere$2=new Sphere,_vector$5=new Vector3,_renderList=new MultiDrawRenderList,_mesh=new Mesh,_batchIntersects=[];function copyAttributeData(st,at,pt=0){const vt=at.itemSize;if(st.isInterleavedBufferAttribute||st.array.constructor!==at.array.constructor){const wt=st.count;for(let $t=0;$t<wt;$t++)for(let Tt=0;Tt<vt;Tt++)at.setComponent($t+pt,Tt,st.getComponent($t,Tt))}else at.array.set(st.array,pt*vt);at.needsUpdate=!0}class BatchedMesh extends Mesh{get maxGeometryCount(){return this._maxGeometryCount}constructor(at,pt,vt=pt*2,wt){super(new BufferGeometry,wt),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._drawRanges=[],this._reservedRanges=[],this._visibility=[],this._active=[],this._bounds=[],this._maxGeometryCount=at,this._maxVertexCount=pt,this._maxIndexCount=vt,this._geometryInitialized=!1,this._geometryCount=0,this._multiDrawCounts=new Int32Array(at),this._multiDrawStarts=new Int32Array(at),this._multiDrawCount=0,this._visibilityChanged=!0,this._matricesTexture=null,this._initMatricesTexture()}_initMatricesTexture(){let at=Math.sqrt(this._maxGeometryCount*4);at=Math.ceil(at/4)*4,at=Math.max(at,4);const pt=new Float32Array(at*at*4),vt=new DataTexture(pt,at,at,RGBAFormat,FloatType);this._matricesTexture=vt}_initializeGeometry(at){const pt=this.geometry,vt=this._maxVertexCount,wt=this._maxGeometryCount,$t=this._maxIndexCount;if(this._geometryInitialized===!1){for(const Lt in at.attributes){const Ft=at.getAttribute(Lt),{array:Ct,itemSize:Ht,normalized:Gt}=Ft,jt=new Ct.constructor(vt*Ht),qt=new Ft.constructor(jt,Ht,Gt);qt.setUsage(Ft.usage),pt.setAttribute(Lt,qt)}if(at.getIndex()!==null){const Lt=vt>65536?new Uint32Array($t):new Uint16Array($t);pt.setIndex(new BufferAttribute(Lt,1))}const Tt=wt>65536?new Uint32Array(vt):new Uint16Array(vt);pt.setAttribute(ID_ATTR_NAME,new BufferAttribute(Tt,1)),this._geometryInitialized=!0}}_validateGeometry(at){if(at.getAttribute(ID_ATTR_NAME))throw new Error(`BatchedMesh: Geometry cannot use attribute "${ID_ATTR_NAME}"`);const pt=this.geometry;if(!!at.getIndex()!=!!pt.getIndex())throw new Error('BatchedMesh: All geometries must consistently have "index".');for(const vt in pt.attributes){if(vt===ID_ATTR_NAME)continue;if(!at.hasAttribute(vt))throw new Error(`BatchedMesh: Added geometry missing "${vt}". All geometries must have consistent attributes.`);const wt=at.getAttribute(vt),$t=pt.getAttribute(vt);if(wt.itemSize!==$t.itemSize||wt.normalized!==$t.normalized)throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}setCustomSort(at){return this.customSort=at,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Box3);const at=this._geometryCount,pt=this.boundingBox,vt=this._active;pt.makeEmpty();for(let wt=0;wt<at;wt++)vt[wt]!==!1&&(this.getMatrixAt(wt,_matrix$1),this.getBoundingBoxAt(wt,_box$1).applyMatrix4(_matrix$1),pt.union(_box$1))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Sphere);const at=this._geometryCount,pt=this.boundingSphere,vt=this._active;pt.makeEmpty();for(let wt=0;wt<at;wt++)vt[wt]!==!1&&(this.getMatrixAt(wt,_matrix$1),this.getBoundingSphereAt(wt,_sphere$2).applyMatrix4(_matrix$1),pt.union(_sphere$2))}addGeometry(at,pt=-1,vt=-1){if(this._initializeGeometry(at),this._validateGeometry(at),this._geometryCount>=this._maxGeometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");const wt={vertexStart:-1,vertexCount:-1,indexStart:-1,indexCount:-1};let $t=null;const Tt=this._reservedRanges,Lt=this._drawRanges,Ft=this._bounds;this._geometryCount!==0&&($t=Tt[Tt.length-1]),pt===-1?wt.vertexCount=at.getAttribute("position").count:wt.vertexCount=pt,$t===null?wt.vertexStart=0:wt.vertexStart=$t.vertexStart+$t.vertexCount;const Ct=at.getIndex(),Ht=Ct!==null;if(Ht&&(vt===-1?wt.indexCount=Ct.count:wt.indexCount=vt,$t===null?wt.indexStart=0:wt.indexStart=$t.indexStart+$t.indexCount),wt.indexStart!==-1&&wt.indexStart+wt.indexCount>this._maxIndexCount||wt.vertexStart+wt.vertexCount>this._maxVertexCount)throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");const Gt=this._visibility,jt=this._active,qt=this._matricesTexture,Kt=this._matricesTexture.image.data;Gt.push(!0),jt.push(!0);const An=this._geometryCount;this._geometryCount++,_identityMatrix$2.toArray(Kt,An*16),qt.needsUpdate=!0,Tt.push(wt),Lt.push({start:Ht?wt.indexStart:wt.vertexStart,count:-1}),Ft.push({boxInitialized:!1,box:new Box3,sphereInitialized:!1,sphere:new Sphere});const Sn=this.geometry.getAttribute(ID_ATTR_NAME);for(let wn=0;wn<wt.vertexCount;wn++)Sn.setX(wt.vertexStart+wn,An);return Sn.needsUpdate=!0,this.setGeometryAt(An,at),An}setGeometryAt(at,pt){if(at>=this._geometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");this._validateGeometry(pt);const vt=this.geometry,wt=vt.getIndex()!==null,$t=vt.getIndex(),Tt=pt.getIndex(),Lt=this._reservedRanges[at];if(wt&&Tt.count>Lt.indexCount||pt.attributes.position.count>Lt.vertexCount)throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");const Ft=Lt.vertexStart,Ct=Lt.vertexCount;for(const qt in vt.attributes){if(qt===ID_ATTR_NAME)continue;const Kt=pt.getAttribute(qt),An=vt.getAttribute(qt);copyAttributeData(Kt,An,Ft);const Sn=Kt.itemSize;for(let wn=Kt.count,In=Ct;wn<In;wn++){const tr=Ft+wn;for(let rr=0;rr<Sn;rr++)An.setComponent(tr,rr,0)}An.needsUpdate=!0}if(wt){const qt=Lt.indexStart;for(let Kt=0;Kt<Tt.count;Kt++)$t.setX(qt+Kt,Ft+Tt.getX(Kt));for(let Kt=Tt.count,An=Lt.indexCount;Kt<An;Kt++)$t.setX(qt+Kt,Ft);$t.needsUpdate=!0}const Ht=this._bounds[at];pt.boundingBox!==null?(Ht.box.copy(pt.boundingBox),Ht.boxInitialized=!0):Ht.boxInitialized=!1,pt.boundingSphere!==null?(Ht.sphere.copy(pt.boundingSphere),Ht.sphereInitialized=!0):Ht.sphereInitialized=!1;const Gt=this._drawRanges[at],jt=pt.getAttribute("position");return Gt.count=wt?Tt.count:jt.count,this._visibilityChanged=!0,at}deleteGeometry(at){const pt=this._active;return at>=pt.length||pt[at]===!1?this:(pt[at]=!1,this._visibilityChanged=!0,this)}getBoundingBoxAt(at,pt){if(this._active[at]===!1)return null;const wt=this._bounds[at],$t=wt.box,Tt=this.geometry;if(wt.boxInitialized===!1){$t.makeEmpty();const Lt=Tt.index,Ft=Tt.attributes.position,Ct=this._drawRanges[at];for(let Ht=Ct.start,Gt=Ct.start+Ct.count;Ht<Gt;Ht++){let jt=Ht;Lt&&(jt=Lt.getX(jt)),$t.expandByPoint(_vector$5.fromBufferAttribute(Ft,jt))}wt.boxInitialized=!0}return pt.copy($t),pt}getBoundingSphereAt(at,pt){if(this._active[at]===!1)return null;const wt=this._bounds[at],$t=wt.sphere,Tt=this.geometry;if(wt.sphereInitialized===!1){$t.makeEmpty(),this.getBoundingBoxAt(at,_box$1),_box$1.getCenter($t.center);const Lt=Tt.index,Ft=Tt.attributes.position,Ct=this._drawRanges[at];let Ht=0;for(let Gt=Ct.start,jt=Ct.start+Ct.count;Gt<jt;Gt++){let qt=Gt;Lt&&(qt=Lt.getX(qt)),_vector$5.fromBufferAttribute(Ft,qt),Ht=Math.max(Ht,$t.center.distanceToSquared(_vector$5))}$t.radius=Math.sqrt(Ht),wt.sphereInitialized=!0}return pt.copy($t),pt}setMatrixAt(at,pt){const vt=this._active,wt=this._matricesTexture,$t=this._matricesTexture.image.data,Tt=this._geometryCount;return at>=Tt||vt[at]===!1?this:(pt.toArray($t,at*16),wt.needsUpdate=!0,this)}getMatrixAt(at,pt){const vt=this._active,wt=this._matricesTexture.image.data,$t=this._geometryCount;return at>=$t||vt[at]===!1?null:pt.fromArray(wt,at*16)}setVisibleAt(at,pt){const vt=this._visibility,wt=this._active,$t=this._geometryCount;return at>=$t||wt[at]===!1||vt[at]===pt?this:(vt[at]=pt,this._visibilityChanged=!0,this)}getVisibleAt(at){const pt=this._visibility,vt=this._active,wt=this._geometryCount;return at>=wt||vt[at]===!1?!1:pt[at]}raycast(at,pt){const vt=this._visibility,wt=this._active,$t=this._drawRanges,Tt=this._geometryCount,Lt=this.matrixWorld,Ft=this.geometry;_mesh.material=this.material,_mesh.geometry.index=Ft.index,_mesh.geometry.attributes=Ft.attributes,_mesh.geometry.boundingBox===null&&(_mesh.geometry.boundingBox=new Box3),_mesh.geometry.boundingSphere===null&&(_mesh.geometry.boundingSphere=new Sphere);for(let Ct=0;Ct<Tt;Ct++){if(!vt[Ct]||!wt[Ct])continue;const Ht=$t[Ct];_mesh.geometry.setDrawRange(Ht.start,Ht.count),this.getMatrixAt(Ct,_mesh.matrixWorld).premultiply(Lt),this.getBoundingBoxAt(Ct,_mesh.geometry.boundingBox),this.getBoundingSphereAt(Ct,_mesh.geometry.boundingSphere),_mesh.raycast(at,_batchIntersects);for(let Gt=0,jt=_batchIntersects.length;Gt<jt;Gt++){const qt=_batchIntersects[Gt];qt.object=this,qt.batchId=Ct,pt.push(qt)}_batchIntersects.length=0}_mesh.material=null,_mesh.geometry.index=null,_mesh.geometry.attributes={},_mesh.geometry.setDrawRange(0,1/0)}copy(at){return super.copy(at),this.geometry=at.geometry.clone(),this.perObjectFrustumCulled=at.perObjectFrustumCulled,this.sortObjects=at.sortObjects,this.boundingBox=at.boundingBox!==null?at.boundingBox.clone():null,this.boundingSphere=at.boundingSphere!==null?at.boundingSphere.clone():null,this._drawRanges=at._drawRanges.map(pt=>({...pt})),this._reservedRanges=at._reservedRanges.map(pt=>({...pt})),this._visibility=at._visibility.slice(),this._active=at._active.slice(),this._bounds=at._bounds.map(pt=>({boxInitialized:pt.boxInitialized,box:pt.box.clone(),sphereInitialized:pt.sphereInitialized,sphere:pt.sphere.clone()})),this._maxGeometryCount=at._maxGeometryCount,this._maxVertexCount=at._maxVertexCount,this._maxIndexCount=at._maxIndexCount,this._geometryInitialized=at._geometryInitialized,this._geometryCount=at._geometryCount,this._multiDrawCounts=at._multiDrawCounts.slice(),this._multiDrawStarts=at._multiDrawStarts.slice(),this._matricesTexture=at._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.slice(),this}dispose(){return this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this}onBeforeRender(at,pt,vt,wt,$t){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const Tt=wt.getIndex(),Lt=Tt===null?1:Tt.array.BYTES_PER_ELEMENT,Ft=this._active,Ct=this._visibility,Ht=this._multiDrawStarts,Gt=this._multiDrawCounts,jt=this._drawRanges,qt=this.perObjectFrustumCulled;qt&&(_projScreenMatrix$2.multiplyMatrices(vt.projectionMatrix,vt.matrixWorldInverse).multiply(this.matrixWorld),_frustum.setFromProjectionMatrix(_projScreenMatrix$2,at.coordinateSystem));let Kt=0;if(this.sortObjects){_invMatrixWorld.copy(this.matrixWorld).invert(),_vector$5.setFromMatrixPosition(vt.matrixWorld).applyMatrix4(_invMatrixWorld);for(let wn=0,In=Ct.length;wn<In;wn++)if(Ct[wn]&&Ft[wn]){this.getMatrixAt(wn,_matrix$1),this.getBoundingSphereAt(wn,_sphere$2).applyMatrix4(_matrix$1);let tr=!1;if(qt&&(tr=!_frustum.intersectsSphere(_sphere$2)),!tr){const rr=_vector$5.distanceTo(_sphere$2.center);_renderList.push(jt[wn],rr)}}const An=_renderList.list,Sn=this.customSort;Sn===null?An.sort($t.transparent?sortTransparent:sortOpaque):Sn.call(this,An,vt);for(let wn=0,In=An.length;wn<In;wn++){const tr=An[wn];Ht[Kt]=tr.start*Lt,Gt[Kt]=tr.count,Kt++}_renderList.reset()}else for(let An=0,Sn=Ct.length;An<Sn;An++)if(Ct[An]&&Ft[An]){let wn=!1;if(qt&&(this.getMatrixAt(An,_matrix$1),this.getBoundingSphereAt(An,_sphere$2).applyMatrix4(_matrix$1),wn=!_frustum.intersectsSphere(_sphere$2)),!wn){const In=jt[An];Ht[Kt]=In.start*Lt,Gt[Kt]=In.count,Kt++}}this._multiDrawCount=Kt,this._visibilityChanged=!1}onBeforeShadow(at,pt,vt,wt,$t,Tt){this.onBeforeRender(at,null,wt,$t,Tt)}}class LineBasicMaterial extends Material{constructor(at){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Color$1(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(at)}copy(at){return super.copy(at),this.color.copy(at.color),this.map=at.map,this.linewidth=at.linewidth,this.linecap=at.linecap,this.linejoin=at.linejoin,this.fog=at.fog,this}}const _start$1=new Vector3,_end$1=new Vector3,_inverseMatrix$1=new Matrix4,_ray$1=new Ray,_sphere$1=new Sphere;class Line extends Object3D{constructor(at=new BufferGeometry,pt=new LineBasicMaterial){super(),this.isLine=!0,this.type="Line",this.geometry=at,this.material=pt,this.updateMorphTargets()}copy(at,pt){return super.copy(at,pt),this.material=Array.isArray(at.material)?at.material.slice():at.material,this.geometry=at.geometry,this}computeLineDistances(){const at=this.geometry;if(at.index===null){const pt=at.attributes.position,vt=[0];for(let wt=1,$t=pt.count;wt<$t;wt++)_start$1.fromBufferAttribute(pt,wt-1),_end$1.fromBufferAttribute(pt,wt),vt[wt]=vt[wt-1],vt[wt]+=_start$1.distanceTo(_end$1);at.setAttribute("lineDistance",new Float32BufferAttribute(vt,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(at,pt){const vt=this.geometry,wt=this.matrixWorld,$t=at.params.Line.threshold,Tt=vt.drawRange;if(vt.boundingSphere===null&&vt.computeBoundingSphere(),_sphere$1.copy(vt.boundingSphere),_sphere$1.applyMatrix4(wt),_sphere$1.radius+=$t,at.ray.intersectsSphere(_sphere$1)===!1)return;_inverseMatrix$1.copy(wt).invert(),_ray$1.copy(at.ray).applyMatrix4(_inverseMatrix$1);const Lt=$t/((this.scale.x+this.scale.y+this.scale.z)/3),Ft=Lt*Lt,Ct=new Vector3,Ht=new Vector3,Gt=new Vector3,jt=new Vector3,qt=this.isLineSegments?2:1,Kt=vt.index,Sn=vt.attributes.position;if(Kt!==null){const wn=Math.max(0,Tt.start),In=Math.min(Kt.count,Tt.start+Tt.count);for(let tr=wn,rr=In-1;tr<rr;tr+=qt){const Hr=Kt.getX(tr),qr=Kt.getX(tr+1);if(Ct.fromBufferAttribute(Sn,Hr),Ht.fromBufferAttribute(Sn,qr),_ray$1.distanceSqToSegment(Ct,Ht,jt,Gt)>Ft)continue;jt.applyMatrix4(this.matrixWorld);const Bo=at.ray.origin.distanceTo(jt);Bo<at.near||Bo>at.far||pt.push({distance:Bo,point:Gt.clone().applyMatrix4(this.matrixWorld),index:tr,face:null,faceIndex:null,object:this})}}else{const wn=Math.max(0,Tt.start),In=Math.min(Sn.count,Tt.start+Tt.count);for(let tr=wn,rr=In-1;tr<rr;tr+=qt){if(Ct.fromBufferAttribute(Sn,tr),Ht.fromBufferAttribute(Sn,tr+1),_ray$1.distanceSqToSegment(Ct,Ht,jt,Gt)>Ft)continue;jt.applyMatrix4(this.matrixWorld);const qr=at.ray.origin.distanceTo(jt);qr<at.near||qr>at.far||pt.push({distance:qr,point:Gt.clone().applyMatrix4(this.matrixWorld),index:tr,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const pt=this.geometry.morphAttributes,vt=Object.keys(pt);if(vt.length>0){const wt=pt[vt[0]];if(wt!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let $t=0,Tt=wt.length;$t<Tt;$t++){const Lt=wt[$t].name||String($t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[Lt]=$t}}}}}const _start=new Vector3,_end=new Vector3;class LineSegments extends Line{constructor(at,pt){super(at,pt),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const at=this.geometry;if(at.index===null){const pt=at.attributes.position,vt=[];for(let wt=0,$t=pt.count;wt<$t;wt+=2)_start.fromBufferAttribute(pt,wt),_end.fromBufferAttribute(pt,wt+1),vt[wt]=wt===0?0:vt[wt-1],vt[wt+1]=vt[wt]+_start.distanceTo(_end);at.setAttribute("lineDistance",new Float32BufferAttribute(vt,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class LineLoop extends Line{constructor(at,pt){super(at,pt),this.isLineLoop=!0,this.type="LineLoop"}}class PointsMaterial extends Material{constructor(at){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Color$1(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(at)}copy(at){return super.copy(at),this.color.copy(at.color),this.map=at.map,this.alphaMap=at.alphaMap,this.size=at.size,this.sizeAttenuation=at.sizeAttenuation,this.fog=at.fog,this}}const _inverseMatrix=new Matrix4,_ray$4=new Ray,_sphere=new Sphere,_position$2=new Vector3;class Points extends Object3D{constructor(at=new BufferGeometry,pt=new PointsMaterial){super(),this.isPoints=!0,this.type="Points",this.geometry=at,this.material=pt,this.updateMorphTargets()}copy(at,pt){return super.copy(at,pt),this.material=Array.isArray(at.material)?at.material.slice():at.material,this.geometry=at.geometry,this}raycast(at,pt){const vt=this.geometry,wt=this.matrixWorld,$t=at.params.Points.threshold,Tt=vt.drawRange;if(vt.boundingSphere===null&&vt.computeBoundingSphere(),_sphere.copy(vt.boundingSphere),_sphere.applyMatrix4(wt),_sphere.radius+=$t,at.ray.intersectsSphere(_sphere)===!1)return;_inverseMatrix.copy(wt).invert(),_ray$4.copy(at.ray).applyMatrix4(_inverseMatrix);const Lt=$t/((this.scale.x+this.scale.y+this.scale.z)/3),Ft=Lt*Lt,Ct=vt.index,Gt=vt.attributes.position;if(Ct!==null){const jt=Math.max(0,Tt.start),qt=Math.min(Ct.count,Tt.start+Tt.count);for(let Kt=jt,An=qt;Kt<An;Kt++){const Sn=Ct.getX(Kt);_position$2.fromBufferAttribute(Gt,Sn),testPoint(_position$2,Sn,Ft,wt,at,pt,this)}}else{const jt=Math.max(0,Tt.start),qt=Math.min(Gt.count,Tt.start+Tt.count);for(let Kt=jt,An=qt;Kt<An;Kt++)_position$2.fromBufferAttribute(Gt,Kt),testPoint(_position$2,Kt,Ft,wt,at,pt,this)}}updateMorphTargets(){const pt=this.geometry.morphAttributes,vt=Object.keys(pt);if(vt.length>0){const wt=pt[vt[0]];if(wt!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let $t=0,Tt=wt.length;$t<Tt;$t++){const Lt=wt[$t].name||String($t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[Lt]=$t}}}}}function testPoint(st,at,pt,vt,wt,$t,Tt){const Lt=_ray$4.distanceSqToPoint(st);if(Lt<pt){const Ft=new Vector3;_ray$4.closestPointToPoint(st,Ft),Ft.applyMatrix4(vt);const Ct=wt.ray.origin.distanceTo(Ft);if(Ct<wt.near||Ct>wt.far)return;$t.push({distance:Ct,distanceToRay:Math.sqrt(Lt),point:Ft,index:at,face:null,object:Tt})}}class VideoTexture extends Texture{constructor(at,pt,vt,wt,$t,Tt,Lt,Ft,Ct){super(at,pt,vt,wt,$t,Tt,Lt,Ft,Ct),this.isVideoTexture=!0,this.minFilter=Tt!==void 0?Tt:LinearFilter,this.magFilter=$t!==void 0?$t:LinearFilter,this.generateMipmaps=!1;const Ht=this;function Gt(){Ht.needsUpdate=!0,at.requestVideoFrameCallback(Gt)}"requestVideoFrameCallback"in at&&at.requestVideoFrameCallback(Gt)}clone(){return new this.constructor(this.image).copy(this)}update(){const at=this.image;"requestVideoFrameCallback"in at===!1&&at.readyState>=at.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class FramebufferTexture extends Texture{constructor(at,pt){super({width:at,height:pt}),this.isFramebufferTexture=!0,this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.generateMipmaps=!1,this.needsUpdate=!0}}class CompressedTexture extends Texture{constructor(at,pt,vt,wt,$t,Tt,Lt,Ft,Ct,Ht,Gt,jt){super(null,Tt,Lt,Ft,Ct,Ht,wt,$t,Gt,jt),this.isCompressedTexture=!0,this.image={width:pt,height:vt},this.mipmaps=at,this.flipY=!1,this.generateMipmaps=!1}}class CompressedArrayTexture extends CompressedTexture{constructor(at,pt,vt,wt,$t,Tt){super(at,pt,vt,$t,Tt),this.isCompressedArrayTexture=!0,this.image.depth=wt,this.wrapR=ClampToEdgeWrapping}}class CompressedCubeTexture extends CompressedTexture{constructor(at,pt,vt){super(void 0,at[0].width,at[0].height,pt,vt,CubeReflectionMapping),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=at}}class CanvasTexture extends Texture{constructor(at,pt,vt,wt,$t,Tt,Lt,Ft,Ct){super(at,pt,vt,wt,$t,Tt,Lt,Ft,Ct),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Curve{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(at,pt){const vt=this.getUtoTmapping(at);return this.getPoint(vt,pt)}getPoints(at=5){const pt=[];for(let vt=0;vt<=at;vt++)pt.push(this.getPoint(vt/at));return pt}getSpacedPoints(at=5){const pt=[];for(let vt=0;vt<=at;vt++)pt.push(this.getPointAt(vt/at));return pt}getLength(){const at=this.getLengths();return at[at.length-1]}getLengths(at=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===at+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const pt=[];let vt,wt=this.getPoint(0),$t=0;pt.push(0);for(let Tt=1;Tt<=at;Tt++)vt=this.getPoint(Tt/at),$t+=vt.distanceTo(wt),pt.push($t),wt=vt;return this.cacheArcLengths=pt,pt}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(at,pt){const vt=this.getLengths();let wt=0;const $t=vt.length;let Tt;pt?Tt=pt:Tt=at*vt[$t-1];let Lt=0,Ft=$t-1,Ct;for(;Lt<=Ft;)if(wt=Math.floor(Lt+(Ft-Lt)/2),Ct=vt[wt]-Tt,Ct<0)Lt=wt+1;else if(Ct>0)Ft=wt-1;else{Ft=wt;break}if(wt=Ft,vt[wt]===Tt)return wt/($t-1);const Ht=vt[wt],jt=vt[wt+1]-Ht,qt=(Tt-Ht)/jt;return(wt+qt)/($t-1)}getTangent(at,pt){let wt=at-1e-4,$t=at+1e-4;wt<0&&(wt=0),$t>1&&($t=1);const Tt=this.getPoint(wt),Lt=this.getPoint($t),Ft=pt||(Tt.isVector2?new Vector2:new Vector3);return Ft.copy(Lt).sub(Tt).normalize(),Ft}getTangentAt(at,pt){const vt=this.getUtoTmapping(at);return this.getTangent(vt,pt)}computeFrenetFrames(at,pt){const vt=new Vector3,wt=[],$t=[],Tt=[],Lt=new Vector3,Ft=new Matrix4;for(let qt=0;qt<=at;qt++){const Kt=qt/at;wt[qt]=this.getTangentAt(Kt,new Vector3)}$t[0]=new Vector3,Tt[0]=new Vector3;let Ct=Number.MAX_VALUE;const Ht=Math.abs(wt[0].x),Gt=Math.abs(wt[0].y),jt=Math.abs(wt[0].z);Ht<=Ct&&(Ct=Ht,vt.set(1,0,0)),Gt<=Ct&&(Ct=Gt,vt.set(0,1,0)),jt<=Ct&&vt.set(0,0,1),Lt.crossVectors(wt[0],vt).normalize(),$t[0].crossVectors(wt[0],Lt),Tt[0].crossVectors(wt[0],$t[0]);for(let qt=1;qt<=at;qt++){if($t[qt]=$t[qt-1].clone(),Tt[qt]=Tt[qt-1].clone(),Lt.crossVectors(wt[qt-1],wt[qt]),Lt.length()>Number.EPSILON){Lt.normalize();const Kt=Math.acos(clamp$3(wt[qt-1].dot(wt[qt]),-1,1));$t[qt].applyMatrix4(Ft.makeRotationAxis(Lt,Kt))}Tt[qt].crossVectors(wt[qt],$t[qt])}if(pt===!0){let qt=Math.acos(clamp$3($t[0].dot($t[at]),-1,1));qt/=at,wt[0].dot(Lt.crossVectors($t[0],$t[at]))>0&&(qt=-qt);for(let Kt=1;Kt<=at;Kt++)$t[Kt].applyMatrix4(Ft.makeRotationAxis(wt[Kt],qt*Kt)),Tt[Kt].crossVectors(wt[Kt],$t[Kt])}return{tangents:wt,normals:$t,binormals:Tt}}clone(){return new this.constructor().copy(this)}copy(at){return this.arcLengthDivisions=at.arcLengthDivisions,this}toJSON(){const at={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return at.arcLengthDivisions=this.arcLengthDivisions,at.type=this.type,at}fromJSON(at){return this.arcLengthDivisions=at.arcLengthDivisions,this}}class EllipseCurve extends Curve{constructor(at=0,pt=0,vt=1,wt=1,$t=0,Tt=Math.PI*2,Lt=!1,Ft=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=at,this.aY=pt,this.xRadius=vt,this.yRadius=wt,this.aStartAngle=$t,this.aEndAngle=Tt,this.aClockwise=Lt,this.aRotation=Ft}getPoint(at,pt=new Vector2){const vt=pt,wt=Math.PI*2;let $t=this.aEndAngle-this.aStartAngle;const Tt=Math.abs($t)<Number.EPSILON;for(;$t<0;)$t+=wt;for(;$t>wt;)$t-=wt;$t<Number.EPSILON&&(Tt?$t=0:$t=wt),this.aClockwise===!0&&!Tt&&($t===wt?$t=-wt:$t=$t-wt);const Lt=this.aStartAngle+at*$t;let Ft=this.aX+this.xRadius*Math.cos(Lt),Ct=this.aY+this.yRadius*Math.sin(Lt);if(this.aRotation!==0){const Ht=Math.cos(this.aRotation),Gt=Math.sin(this.aRotation),jt=Ft-this.aX,qt=Ct-this.aY;Ft=jt*Ht-qt*Gt+this.aX,Ct=jt*Gt+qt*Ht+this.aY}return vt.set(Ft,Ct)}copy(at){return super.copy(at),this.aX=at.aX,this.aY=at.aY,this.xRadius=at.xRadius,this.yRadius=at.yRadius,this.aStartAngle=at.aStartAngle,this.aEndAngle=at.aEndAngle,this.aClockwise=at.aClockwise,this.aRotation=at.aRotation,this}toJSON(){const at=super.toJSON();return at.aX=this.aX,at.aY=this.aY,at.xRadius=this.xRadius,at.yRadius=this.yRadius,at.aStartAngle=this.aStartAngle,at.aEndAngle=this.aEndAngle,at.aClockwise=this.aClockwise,at.aRotation=this.aRotation,at}fromJSON(at){return super.fromJSON(at),this.aX=at.aX,this.aY=at.aY,this.xRadius=at.xRadius,this.yRadius=at.yRadius,this.aStartAngle=at.aStartAngle,this.aEndAngle=at.aEndAngle,this.aClockwise=at.aClockwise,this.aRotation=at.aRotation,this}}class ArcCurve extends EllipseCurve{constructor(at,pt,vt,wt,$t,Tt){super(at,pt,vt,vt,wt,$t,Tt),this.isArcCurve=!0,this.type="ArcCurve"}}function CubicPoly(){let st=0,at=0,pt=0,vt=0;function wt($t,Tt,Lt,Ft){st=$t,at=Lt,pt=-3*$t+3*Tt-2*Lt-Ft,vt=2*$t-2*Tt+Lt+Ft}return{initCatmullRom:function($t,Tt,Lt,Ft,Ct){wt(Tt,Lt,Ct*(Lt-$t),Ct*(Ft-Tt))},initNonuniformCatmullRom:function($t,Tt,Lt,Ft,Ct,Ht,Gt){let jt=(Tt-$t)/Ct-(Lt-$t)/(Ct+Ht)+(Lt-Tt)/Ht,qt=(Lt-Tt)/Ht-(Ft-Tt)/(Ht+Gt)+(Ft-Lt)/Gt;jt*=Ht,qt*=Ht,wt(Tt,Lt,jt,qt)},calc:function($t){const Tt=$t*$t,Lt=Tt*$t;return st+at*$t+pt*Tt+vt*Lt}}}const tmp=new Vector3,px=new CubicPoly,py=new CubicPoly,pz=new CubicPoly;class CatmullRomCurve3 extends Curve{constructor(at=[],pt=!1,vt="centripetal",wt=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=at,this.closed=pt,this.curveType=vt,this.tension=wt}getPoint(at,pt=new Vector3){const vt=pt,wt=this.points,$t=wt.length,Tt=($t-(this.closed?0:1))*at;let Lt=Math.floor(Tt),Ft=Tt-Lt;this.closed?Lt+=Lt>0?0:(Math.floor(Math.abs(Lt)/$t)+1)*$t:Ft===0&&Lt===$t-1&&(Lt=$t-2,Ft=1);let Ct,Ht;this.closed||Lt>0?Ct=wt[(Lt-1)%$t]:(tmp.subVectors(wt[0],wt[1]).add(wt[0]),Ct=tmp);const Gt=wt[Lt%$t],jt=wt[(Lt+1)%$t];if(this.closed||Lt+2<$t?Ht=wt[(Lt+2)%$t]:(tmp.subVectors(wt[$t-1],wt[$t-2]).add(wt[$t-1]),Ht=tmp),this.curveType==="centripetal"||this.curveType==="chordal"){const qt=this.curveType==="chordal"?.5:.25;let Kt=Math.pow(Ct.distanceToSquared(Gt),qt),An=Math.pow(Gt.distanceToSquared(jt),qt),Sn=Math.pow(jt.distanceToSquared(Ht),qt);An<1e-4&&(An=1),Kt<1e-4&&(Kt=An),Sn<1e-4&&(Sn=An),px.initNonuniformCatmullRom(Ct.x,Gt.x,jt.x,Ht.x,Kt,An,Sn),py.initNonuniformCatmullRom(Ct.y,Gt.y,jt.y,Ht.y,Kt,An,Sn),pz.initNonuniformCatmullRom(Ct.z,Gt.z,jt.z,Ht.z,Kt,An,Sn)}else this.curveType==="catmullrom"&&(px.initCatmullRom(Ct.x,Gt.x,jt.x,Ht.x,this.tension),py.initCatmullRom(Ct.y,Gt.y,jt.y,Ht.y,this.tension),pz.initCatmullRom(Ct.z,Gt.z,jt.z,Ht.z,this.tension));return vt.set(px.calc(Ft),py.calc(Ft),pz.calc(Ft)),vt}copy(at){super.copy(at),this.points=[];for(let pt=0,vt=at.points.length;pt<vt;pt++){const wt=at.points[pt];this.points.push(wt.clone())}return this.closed=at.closed,this.curveType=at.curveType,this.tension=at.tension,this}toJSON(){const at=super.toJSON();at.points=[];for(let pt=0,vt=this.points.length;pt<vt;pt++){const wt=this.points[pt];at.points.push(wt.toArray())}return at.closed=this.closed,at.curveType=this.curveType,at.tension=this.tension,at}fromJSON(at){super.fromJSON(at),this.points=[];for(let pt=0,vt=at.points.length;pt<vt;pt++){const wt=at.points[pt];this.points.push(new Vector3().fromArray(wt))}return this.closed=at.closed,this.curveType=at.curveType,this.tension=at.tension,this}}function CatmullRom(st,at,pt,vt,wt){const $t=(vt-at)*.5,Tt=(wt-pt)*.5,Lt=st*st,Ft=st*Lt;return(2*pt-2*vt+$t+Tt)*Ft+(-3*pt+3*vt-2*$t-Tt)*Lt+$t*st+pt}function QuadraticBezierP0(st,at){const pt=1-st;return pt*pt*at}function QuadraticBezierP1(st,at){return 2*(1-st)*st*at}function QuadraticBezierP2(st,at){return st*st*at}function QuadraticBezier(st,at,pt,vt){return QuadraticBezierP0(st,at)+QuadraticBezierP1(st,pt)+QuadraticBezierP2(st,vt)}function CubicBezierP0(st,at){const pt=1-st;return pt*pt*pt*at}function CubicBezierP1(st,at){const pt=1-st;return 3*pt*pt*st*at}function CubicBezierP2(st,at){return 3*(1-st)*st*st*at}function CubicBezierP3(st,at){return st*st*st*at}function CubicBezier(st,at,pt,vt,wt){return CubicBezierP0(st,at)+CubicBezierP1(st,pt)+CubicBezierP2(st,vt)+CubicBezierP3(st,wt)}class CubicBezierCurve extends Curve{constructor(at=new Vector2,pt=new Vector2,vt=new Vector2,wt=new Vector2){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=at,this.v1=pt,this.v2=vt,this.v3=wt}getPoint(at,pt=new Vector2){const vt=pt,wt=this.v0,$t=this.v1,Tt=this.v2,Lt=this.v3;return vt.set(CubicBezier(at,wt.x,$t.x,Tt.x,Lt.x),CubicBezier(at,wt.y,$t.y,Tt.y,Lt.y)),vt}copy(at){return super.copy(at),this.v0.copy(at.v0),this.v1.copy(at.v1),this.v2.copy(at.v2),this.v3.copy(at.v3),this}toJSON(){const at=super.toJSON();return at.v0=this.v0.toArray(),at.v1=this.v1.toArray(),at.v2=this.v2.toArray(),at.v3=this.v3.toArray(),at}fromJSON(at){return super.fromJSON(at),this.v0.fromArray(at.v0),this.v1.fromArray(at.v1),this.v2.fromArray(at.v2),this.v3.fromArray(at.v3),this}}class CubicBezierCurve3 extends Curve{constructor(at=new Vector3,pt=new Vector3,vt=new Vector3,wt=new Vector3){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=at,this.v1=pt,this.v2=vt,this.v3=wt}getPoint(at,pt=new Vector3){const vt=pt,wt=this.v0,$t=this.v1,Tt=this.v2,Lt=this.v3;return vt.set(CubicBezier(at,wt.x,$t.x,Tt.x,Lt.x),CubicBezier(at,wt.y,$t.y,Tt.y,Lt.y),CubicBezier(at,wt.z,$t.z,Tt.z,Lt.z)),vt}copy(at){return super.copy(at),this.v0.copy(at.v0),this.v1.copy(at.v1),this.v2.copy(at.v2),this.v3.copy(at.v3),this}toJSON(){const at=super.toJSON();return at.v0=this.v0.toArray(),at.v1=this.v1.toArray(),at.v2=this.v2.toArray(),at.v3=this.v3.toArray(),at}fromJSON(at){return super.fromJSON(at),this.v0.fromArray(at.v0),this.v1.fromArray(at.v1),this.v2.fromArray(at.v2),this.v3.fromArray(at.v3),this}}class LineCurve extends Curve{constructor(at=new Vector2,pt=new Vector2){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=at,this.v2=pt}getPoint(at,pt=new Vector2){const vt=pt;return at===1?vt.copy(this.v2):(vt.copy(this.v2).sub(this.v1),vt.multiplyScalar(at).add(this.v1)),vt}getPointAt(at,pt){return this.getPoint(at,pt)}getTangent(at,pt=new Vector2){return pt.subVectors(this.v2,this.v1).normalize()}getTangentAt(at,pt){return this.getTangent(at,pt)}copy(at){return super.copy(at),this.v1.copy(at.v1),this.v2.copy(at.v2),this}toJSON(){const at=super.toJSON();return at.v1=this.v1.toArray(),at.v2=this.v2.toArray(),at}fromJSON(at){return super.fromJSON(at),this.v1.fromArray(at.v1),this.v2.fromArray(at.v2),this}}class LineCurve3 extends Curve{constructor(at=new Vector3,pt=new Vector3){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=at,this.v2=pt}getPoint(at,pt=new Vector3){const vt=pt;return at===1?vt.copy(this.v2):(vt.copy(this.v2).sub(this.v1),vt.multiplyScalar(at).add(this.v1)),vt}getPointAt(at,pt){return this.getPoint(at,pt)}getTangent(at,pt=new Vector3){return pt.subVectors(this.v2,this.v1).normalize()}getTangentAt(at,pt){return this.getTangent(at,pt)}copy(at){return super.copy(at),this.v1.copy(at.v1),this.v2.copy(at.v2),this}toJSON(){const at=super.toJSON();return at.v1=this.v1.toArray(),at.v2=this.v2.toArray(),at}fromJSON(at){return super.fromJSON(at),this.v1.fromArray(at.v1),this.v2.fromArray(at.v2),this}}class QuadraticBezierCurve extends Curve{constructor(at=new Vector2,pt=new Vector2,vt=new Vector2){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=at,this.v1=pt,this.v2=vt}getPoint(at,pt=new Vector2){const vt=pt,wt=this.v0,$t=this.v1,Tt=this.v2;return vt.set(QuadraticBezier(at,wt.x,$t.x,Tt.x),QuadraticBezier(at,wt.y,$t.y,Tt.y)),vt}copy(at){return super.copy(at),this.v0.copy(at.v0),this.v1.copy(at.v1),this.v2.copy(at.v2),this}toJSON(){const at=super.toJSON();return at.v0=this.v0.toArray(),at.v1=this.v1.toArray(),at.v2=this.v2.toArray(),at}fromJSON(at){return super.fromJSON(at),this.v0.fromArray(at.v0),this.v1.fromArray(at.v1),this.v2.fromArray(at.v2),this}}class QuadraticBezierCurve3 extends Curve{constructor(at=new Vector3,pt=new Vector3,vt=new Vector3){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=at,this.v1=pt,this.v2=vt}getPoint(at,pt=new Vector3){const vt=pt,wt=this.v0,$t=this.v1,Tt=this.v2;return vt.set(QuadraticBezier(at,wt.x,$t.x,Tt.x),QuadraticBezier(at,wt.y,$t.y,Tt.y),QuadraticBezier(at,wt.z,$t.z,Tt.z)),vt}copy(at){return super.copy(at),this.v0.copy(at.v0),this.v1.copy(at.v1),this.v2.copy(at.v2),this}toJSON(){const at=super.toJSON();return at.v0=this.v0.toArray(),at.v1=this.v1.toArray(),at.v2=this.v2.toArray(),at}fromJSON(at){return super.fromJSON(at),this.v0.fromArray(at.v0),this.v1.fromArray(at.v1),this.v2.fromArray(at.v2),this}}class SplineCurve extends Curve{constructor(at=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=at}getPoint(at,pt=new Vector2){const vt=pt,wt=this.points,$t=(wt.length-1)*at,Tt=Math.floor($t),Lt=$t-Tt,Ft=wt[Tt===0?Tt:Tt-1],Ct=wt[Tt],Ht=wt[Tt>wt.length-2?wt.length-1:Tt+1],Gt=wt[Tt>wt.length-3?wt.length-1:Tt+2];return vt.set(CatmullRom(Lt,Ft.x,Ct.x,Ht.x,Gt.x),CatmullRom(Lt,Ft.y,Ct.y,Ht.y,Gt.y)),vt}copy(at){super.copy(at),this.points=[];for(let pt=0,vt=at.points.length;pt<vt;pt++){const wt=at.points[pt];this.points.push(wt.clone())}return this}toJSON(){const at=super.toJSON();at.points=[];for(let pt=0,vt=this.points.length;pt<vt;pt++){const wt=this.points[pt];at.points.push(wt.toArray())}return at}fromJSON(at){super.fromJSON(at),this.points=[];for(let pt=0,vt=at.points.length;pt<vt;pt++){const wt=at.points[pt];this.points.push(new Vector2().fromArray(wt))}return this}}var Curves=Object.freeze({__proto__:null,ArcCurve,CatmullRomCurve3,CubicBezierCurve,CubicBezierCurve3,EllipseCurve,LineCurve,LineCurve3,QuadraticBezierCurve,QuadraticBezierCurve3,SplineCurve});class CurvePath extends Curve{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(at){this.curves.push(at)}closePath(){const at=this.curves[0].getPoint(0),pt=this.curves[this.curves.length-1].getPoint(1);if(!at.equals(pt)){const vt=at.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new Curves[vt](pt,at))}return this}getPoint(at,pt){const vt=at*this.getLength(),wt=this.getCurveLengths();let $t=0;for(;$t<wt.length;){if(wt[$t]>=vt){const Tt=wt[$t]-vt,Lt=this.curves[$t],Ft=Lt.getLength(),Ct=Ft===0?0:1-Tt/Ft;return Lt.getPointAt(Ct,pt)}$t++}return null}getLength(){const at=this.getCurveLengths();return at[at.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const at=[];let pt=0;for(let vt=0,wt=this.curves.length;vt<wt;vt++)pt+=this.curves[vt].getLength(),at.push(pt);return this.cacheLengths=at,at}getSpacedPoints(at=40){const pt=[];for(let vt=0;vt<=at;vt++)pt.push(this.getPoint(vt/at));return this.autoClose&&pt.push(pt[0]),pt}getPoints(at=12){const pt=[];let vt;for(let wt=0,$t=this.curves;wt<$t.length;wt++){const Tt=$t[wt],Lt=Tt.isEllipseCurve?at*2:Tt.isLineCurve||Tt.isLineCurve3?1:Tt.isSplineCurve?at*Tt.points.length:at,Ft=Tt.getPoints(Lt);for(let Ct=0;Ct<Ft.length;Ct++){const Ht=Ft[Ct];vt&&vt.equals(Ht)||(pt.push(Ht),vt=Ht)}}return this.autoClose&&pt.length>1&&!pt[pt.length-1].equals(pt[0])&&pt.push(pt[0]),pt}copy(at){super.copy(at),this.curves=[];for(let pt=0,vt=at.curves.length;pt<vt;pt++){const wt=at.curves[pt];this.curves.push(wt.clone())}return this.autoClose=at.autoClose,this}toJSON(){const at=super.toJSON();at.autoClose=this.autoClose,at.curves=[];for(let pt=0,vt=this.curves.length;pt<vt;pt++){const wt=this.curves[pt];at.curves.push(wt.toJSON())}return at}fromJSON(at){super.fromJSON(at),this.autoClose=at.autoClose,this.curves=[];for(let pt=0,vt=at.curves.length;pt<vt;pt++){const wt=at.curves[pt];this.curves.push(new Curves[wt.type]().fromJSON(wt))}return this}}class Path extends CurvePath{constructor(at){super(),this.type="Path",this.currentPoint=new Vector2,at&&this.setFromPoints(at)}setFromPoints(at){this.moveTo(at[0].x,at[0].y);for(let pt=1,vt=at.length;pt<vt;pt++)this.lineTo(at[pt].x,at[pt].y);return this}moveTo(at,pt){return this.currentPoint.set(at,pt),this}lineTo(at,pt){const vt=new LineCurve(this.currentPoint.clone(),new Vector2(at,pt));return this.curves.push(vt),this.currentPoint.set(at,pt),this}quadraticCurveTo(at,pt,vt,wt){const $t=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(at,pt),new Vector2(vt,wt));return this.curves.push($t),this.currentPoint.set(vt,wt),this}bezierCurveTo(at,pt,vt,wt,$t,Tt){const Lt=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(at,pt),new Vector2(vt,wt),new Vector2($t,Tt));return this.curves.push(Lt),this.currentPoint.set($t,Tt),this}splineThru(at){const pt=[this.currentPoint.clone()].concat(at),vt=new SplineCurve(pt);return this.curves.push(vt),this.currentPoint.copy(at[at.length-1]),this}arc(at,pt,vt,wt,$t,Tt){const Lt=this.currentPoint.x,Ft=this.currentPoint.y;return this.absarc(at+Lt,pt+Ft,vt,wt,$t,Tt),this}absarc(at,pt,vt,wt,$t,Tt){return this.absellipse(at,pt,vt,vt,wt,$t,Tt),this}ellipse(at,pt,vt,wt,$t,Tt,Lt,Ft){const Ct=this.currentPoint.x,Ht=this.currentPoint.y;return this.absellipse(at+Ct,pt+Ht,vt,wt,$t,Tt,Lt,Ft),this}absellipse(at,pt,vt,wt,$t,Tt,Lt,Ft){const Ct=new EllipseCurve(at,pt,vt,wt,$t,Tt,Lt,Ft);if(this.curves.length>0){const Gt=Ct.getPoint(0);Gt.equals(this.currentPoint)||this.lineTo(Gt.x,Gt.y)}this.curves.push(Ct);const Ht=Ct.getPoint(1);return this.currentPoint.copy(Ht),this}copy(at){return super.copy(at),this.currentPoint.copy(at.currentPoint),this}toJSON(){const at=super.toJSON();return at.currentPoint=this.currentPoint.toArray(),at}fromJSON(at){return super.fromJSON(at),this.currentPoint.fromArray(at.currentPoint),this}}class LatheGeometry extends BufferGeometry{constructor(at=[new Vector2(0,-.5),new Vector2(.5,0),new Vector2(0,.5)],pt=12,vt=0,wt=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:at,segments:pt,phiStart:vt,phiLength:wt},pt=Math.floor(pt),wt=clamp$3(wt,0,Math.PI*2);const $t=[],Tt=[],Lt=[],Ft=[],Ct=[],Ht=1/pt,Gt=new Vector3,jt=new Vector2,qt=new Vector3,Kt=new Vector3,An=new Vector3;let Sn=0,wn=0;for(let In=0;In<=at.length-1;In++)switch(In){case 0:Sn=at[In+1].x-at[In].x,wn=at[In+1].y-at[In].y,qt.x=wn*1,qt.y=-Sn,qt.z=wn*0,An.copy(qt),qt.normalize(),Ft.push(qt.x,qt.y,qt.z);break;case at.length-1:Ft.push(An.x,An.y,An.z);break;default:Sn=at[In+1].x-at[In].x,wn=at[In+1].y-at[In].y,qt.x=wn*1,qt.y=-Sn,qt.z=wn*0,Kt.copy(qt),qt.x+=An.x,qt.y+=An.y,qt.z+=An.z,qt.normalize(),Ft.push(qt.x,qt.y,qt.z),An.copy(Kt)}for(let In=0;In<=pt;In++){const tr=vt+In*Ht*wt,rr=Math.sin(tr),Hr=Math.cos(tr);for(let qr=0;qr<=at.length-1;qr++){Gt.x=at[qr].x*rr,Gt.y=at[qr].y,Gt.z=at[qr].x*Hr,Tt.push(Gt.x,Gt.y,Gt.z),jt.x=In/pt,jt.y=qr/(at.length-1),Lt.push(jt.x,jt.y);const Zr=Ft[3*qr+0]*rr,Bo=Ft[3*qr+1],Xo=Ft[3*qr+0]*Hr;Ct.push(Zr,Bo,Xo)}}for(let In=0;In<pt;In++)for(let tr=0;tr<at.length-1;tr++){const rr=tr+In*at.length,Hr=rr,qr=rr+at.length,Zr=rr+at.length+1,Bo=rr+1;$t.push(Hr,qr,Bo),$t.push(Zr,Bo,qr)}this.setIndex($t),this.setAttribute("position",new Float32BufferAttribute(Tt,3)),this.setAttribute("uv",new Float32BufferAttribute(Lt,2)),this.setAttribute("normal",new Float32BufferAttribute(Ct,3))}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}static fromJSON(at){return new LatheGeometry(at.points,at.segments,at.phiStart,at.phiLength)}}class CapsuleGeometry extends LatheGeometry{constructor(at=1,pt=1,vt=4,wt=8){const $t=new Path;$t.absarc(0,-pt/2,at,Math.PI*1.5,0),$t.absarc(0,pt/2,at,0,Math.PI*.5),super($t.getPoints(vt),wt),this.type="CapsuleGeometry",this.parameters={radius:at,length:pt,capSegments:vt,radialSegments:wt}}static fromJSON(at){return new CapsuleGeometry(at.radius,at.length,at.capSegments,at.radialSegments)}}class CircleGeometry extends BufferGeometry{constructor(at=1,pt=32,vt=0,wt=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:at,segments:pt,thetaStart:vt,thetaLength:wt},pt=Math.max(3,pt);const $t=[],Tt=[],Lt=[],Ft=[],Ct=new Vector3,Ht=new Vector2;Tt.push(0,0,0),Lt.push(0,0,1),Ft.push(.5,.5);for(let Gt=0,jt=3;Gt<=pt;Gt++,jt+=3){const qt=vt+Gt/pt*wt;Ct.x=at*Math.cos(qt),Ct.y=at*Math.sin(qt),Tt.push(Ct.x,Ct.y,Ct.z),Lt.push(0,0,1),Ht.x=(Tt[jt]/at+1)/2,Ht.y=(Tt[jt+1]/at+1)/2,Ft.push(Ht.x,Ht.y)}for(let Gt=1;Gt<=pt;Gt++)$t.push(Gt,Gt+1,0);this.setIndex($t),this.setAttribute("position",new Float32BufferAttribute(Tt,3)),this.setAttribute("normal",new Float32BufferAttribute(Lt,3)),this.setAttribute("uv",new Float32BufferAttribute(Ft,2))}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}static fromJSON(at){return new CircleGeometry(at.radius,at.segments,at.thetaStart,at.thetaLength)}}class CylinderGeometry extends BufferGeometry{constructor(at=1,pt=1,vt=1,wt=32,$t=1,Tt=!1,Lt=0,Ft=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:at,radiusBottom:pt,height:vt,radialSegments:wt,heightSegments:$t,openEnded:Tt,thetaStart:Lt,thetaLength:Ft};const Ct=this;wt=Math.floor(wt),$t=Math.floor($t);const Ht=[],Gt=[],jt=[],qt=[];let Kt=0;const An=[],Sn=vt/2;let wn=0;In(),Tt===!1&&(at>0&&tr(!0),pt>0&&tr(!1)),this.setIndex(Ht),this.setAttribute("position",new Float32BufferAttribute(Gt,3)),this.setAttribute("normal",new Float32BufferAttribute(jt,3)),this.setAttribute("uv",new Float32BufferAttribute(qt,2));function In(){const rr=new Vector3,Hr=new Vector3;let qr=0;const Zr=(pt-at)/vt;for(let Bo=0;Bo<=$t;Bo++){const Xo=[],Kr=Bo/$t,ko=Kr*(pt-at)+at;for(let f0=0;f0<=wt;f0++){const x0=f0/wt,l0=x0*Ft+Lt,T0=Math.sin(l0),t0=Math.cos(l0);Hr.x=ko*T0,Hr.y=-Kr*vt+Sn,Hr.z=ko*t0,Gt.push(Hr.x,Hr.y,Hr.z),rr.set(T0,Zr,t0).normalize(),jt.push(rr.x,rr.y,rr.z),qt.push(x0,1-Kr),Xo.push(Kt++)}An.push(Xo)}for(let Bo=0;Bo<wt;Bo++)for(let Xo=0;Xo<$t;Xo++){const Kr=An[Xo][Bo],ko=An[Xo+1][Bo],f0=An[Xo+1][Bo+1],x0=An[Xo][Bo+1];Ht.push(Kr,ko,x0),Ht.push(ko,f0,x0),qr+=6}Ct.addGroup(wn,qr,0),wn+=qr}function tr(rr){const Hr=Kt,qr=new Vector2,Zr=new Vector3;let Bo=0;const Xo=rr===!0?at:pt,Kr=rr===!0?1:-1;for(let f0=1;f0<=wt;f0++)Gt.push(0,Sn*Kr,0),jt.push(0,Kr,0),qt.push(.5,.5),Kt++;const ko=Kt;for(let f0=0;f0<=wt;f0++){const l0=f0/wt*Ft+Lt,T0=Math.cos(l0),t0=Math.sin(l0);Zr.x=Xo*t0,Zr.y=Sn*Kr,Zr.z=Xo*T0,Gt.push(Zr.x,Zr.y,Zr.z),jt.push(0,Kr,0),qr.x=T0*.5+.5,qr.y=t0*.5*Kr+.5,qt.push(qr.x,qr.y),Kt++}for(let f0=0;f0<wt;f0++){const x0=Hr+f0,l0=ko+f0;rr===!0?Ht.push(l0,l0+1,x0):Ht.push(l0+1,l0,x0),Bo+=3}Ct.addGroup(wn,Bo,rr===!0?1:2),wn+=Bo}}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}static fromJSON(at){return new CylinderGeometry(at.radiusTop,at.radiusBottom,at.height,at.radialSegments,at.heightSegments,at.openEnded,at.thetaStart,at.thetaLength)}}class ConeGeometry extends CylinderGeometry{constructor(at=1,pt=1,vt=32,wt=1,$t=!1,Tt=0,Lt=Math.PI*2){super(0,at,pt,vt,wt,$t,Tt,Lt),this.type="ConeGeometry",this.parameters={radius:at,height:pt,radialSegments:vt,heightSegments:wt,openEnded:$t,thetaStart:Tt,thetaLength:Lt}}static fromJSON(at){return new ConeGeometry(at.radius,at.height,at.radialSegments,at.heightSegments,at.openEnded,at.thetaStart,at.thetaLength)}}class PolyhedronGeometry extends BufferGeometry{constructor(at=[],pt=[],vt=1,wt=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:at,indices:pt,radius:vt,detail:wt};const $t=[],Tt=[];Lt(wt),Ct(vt),Ht(),this.setAttribute("position",new Float32BufferAttribute($t,3)),this.setAttribute("normal",new Float32BufferAttribute($t.slice(),3)),this.setAttribute("uv",new Float32BufferAttribute(Tt,2)),wt===0?this.computeVertexNormals():this.normalizeNormals();function Lt(In){const tr=new Vector3,rr=new Vector3,Hr=new Vector3;for(let qr=0;qr<pt.length;qr+=3)qt(pt[qr+0],tr),qt(pt[qr+1],rr),qt(pt[qr+2],Hr),Ft(tr,rr,Hr,In)}function Ft(In,tr,rr,Hr){const qr=Hr+1,Zr=[];for(let Bo=0;Bo<=qr;Bo++){Zr[Bo]=[];const Xo=In.clone().lerp(rr,Bo/qr),Kr=tr.clone().lerp(rr,Bo/qr),ko=qr-Bo;for(let f0=0;f0<=ko;f0++)f0===0&&Bo===qr?Zr[Bo][f0]=Xo:Zr[Bo][f0]=Xo.clone().lerp(Kr,f0/ko)}for(let Bo=0;Bo<qr;Bo++)for(let Xo=0;Xo<2*(qr-Bo)-1;Xo++){const Kr=Math.floor(Xo/2);Xo%2===0?(jt(Zr[Bo][Kr+1]),jt(Zr[Bo+1][Kr]),jt(Zr[Bo][Kr])):(jt(Zr[Bo][Kr+1]),jt(Zr[Bo+1][Kr+1]),jt(Zr[Bo+1][Kr]))}}function Ct(In){const tr=new Vector3;for(let rr=0;rr<$t.length;rr+=3)tr.x=$t[rr+0],tr.y=$t[rr+1],tr.z=$t[rr+2],tr.normalize().multiplyScalar(In),$t[rr+0]=tr.x,$t[rr+1]=tr.y,$t[rr+2]=tr.z}function Ht(){const In=new Vector3;for(let tr=0;tr<$t.length;tr+=3){In.x=$t[tr+0],In.y=$t[tr+1],In.z=$t[tr+2];const rr=Sn(In)/2/Math.PI+.5,Hr=wn(In)/Math.PI+.5;Tt.push(rr,1-Hr)}Kt(),Gt()}function Gt(){for(let In=0;In<Tt.length;In+=6){const tr=Tt[In+0],rr=Tt[In+2],Hr=Tt[In+4],qr=Math.max(tr,rr,Hr),Zr=Math.min(tr,rr,Hr);qr>.9&&Zr<.1&&(tr<.2&&(Tt[In+0]+=1),rr<.2&&(Tt[In+2]+=1),Hr<.2&&(Tt[In+4]+=1))}}function jt(In){$t.push(In.x,In.y,In.z)}function qt(In,tr){const rr=In*3;tr.x=at[rr+0],tr.y=at[rr+1],tr.z=at[rr+2]}function Kt(){const In=new Vector3,tr=new Vector3,rr=new Vector3,Hr=new Vector3,qr=new Vector2,Zr=new Vector2,Bo=new Vector2;for(let Xo=0,Kr=0;Xo<$t.length;Xo+=9,Kr+=6){In.set($t[Xo+0],$t[Xo+1],$t[Xo+2]),tr.set($t[Xo+3],$t[Xo+4],$t[Xo+5]),rr.set($t[Xo+6],$t[Xo+7],$t[Xo+8]),qr.set(Tt[Kr+0],Tt[Kr+1]),Zr.set(Tt[Kr+2],Tt[Kr+3]),Bo.set(Tt[Kr+4],Tt[Kr+5]),Hr.copy(In).add(tr).add(rr).divideScalar(3);const ko=Sn(Hr);An(qr,Kr+0,In,ko),An(Zr,Kr+2,tr,ko),An(Bo,Kr+4,rr,ko)}}function An(In,tr,rr,Hr){Hr<0&&In.x===1&&(Tt[tr]=In.x-1),rr.x===0&&rr.z===0&&(Tt[tr]=Hr/2/Math.PI+.5)}function Sn(In){return Math.atan2(In.z,-In.x)}function wn(In){return Math.atan2(-In.y,Math.sqrt(In.x*In.x+In.z*In.z))}}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}static fromJSON(at){return new PolyhedronGeometry(at.vertices,at.indices,at.radius,at.details)}}class DodecahedronGeometry extends PolyhedronGeometry{constructor(at=1,pt=0){const vt=(1+Math.sqrt(5))/2,wt=1/vt,$t=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-wt,-vt,0,-wt,vt,0,wt,-vt,0,wt,vt,-wt,-vt,0,-wt,vt,0,wt,-vt,0,wt,vt,0,-vt,0,-wt,vt,0,-wt,-vt,0,wt,vt,0,wt],Tt=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super($t,Tt,at,pt),this.type="DodecahedronGeometry",this.parameters={radius:at,detail:pt}}static fromJSON(at){return new DodecahedronGeometry(at.radius,at.detail)}}const _v0=new Vector3,_v1$1=new Vector3,_normal=new Vector3,_triangle=new Triangle;class EdgesGeometry extends BufferGeometry{constructor(at=null,pt=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:at,thresholdAngle:pt},at!==null){const wt=Math.pow(10,4),$t=Math.cos(DEG2RAD*pt),Tt=at.getIndex(),Lt=at.getAttribute("position"),Ft=Tt?Tt.count:Lt.count,Ct=[0,0,0],Ht=["a","b","c"],Gt=new Array(3),jt={},qt=[];for(let Kt=0;Kt<Ft;Kt+=3){Tt?(Ct[0]=Tt.getX(Kt),Ct[1]=Tt.getX(Kt+1),Ct[2]=Tt.getX(Kt+2)):(Ct[0]=Kt,Ct[1]=Kt+1,Ct[2]=Kt+2);const{a:An,b:Sn,c:wn}=_triangle;if(An.fromBufferAttribute(Lt,Ct[0]),Sn.fromBufferAttribute(Lt,Ct[1]),wn.fromBufferAttribute(Lt,Ct[2]),_triangle.getNormal(_normal),Gt[0]=`${Math.round(An.x*wt)},${Math.round(An.y*wt)},${Math.round(An.z*wt)}`,Gt[1]=`${Math.round(Sn.x*wt)},${Math.round(Sn.y*wt)},${Math.round(Sn.z*wt)}`,Gt[2]=`${Math.round(wn.x*wt)},${Math.round(wn.y*wt)},${Math.round(wn.z*wt)}`,!(Gt[0]===Gt[1]||Gt[1]===Gt[2]||Gt[2]===Gt[0]))for(let In=0;In<3;In++){const tr=(In+1)%3,rr=Gt[In],Hr=Gt[tr],qr=_triangle[Ht[In]],Zr=_triangle[Ht[tr]],Bo=`${rr}_${Hr}`,Xo=`${Hr}_${rr}`;Xo in jt&&jt[Xo]?(_normal.dot(jt[Xo].normal)<=$t&&(qt.push(qr.x,qr.y,qr.z),qt.push(Zr.x,Zr.y,Zr.z)),jt[Xo]=null):Bo in jt||(jt[Bo]={index0:Ct[In],index1:Ct[tr],normal:_normal.clone()})}}for(const Kt in jt)if(jt[Kt]){const{index0:An,index1:Sn}=jt[Kt];_v0.fromBufferAttribute(Lt,An),_v1$1.fromBufferAttribute(Lt,Sn),qt.push(_v0.x,_v0.y,_v0.z),qt.push(_v1$1.x,_v1$1.y,_v1$1.z)}this.setAttribute("position",new Float32BufferAttribute(qt,3))}}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}}class Shape extends Path{constructor(at){super(at),this.uuid=generateUUID(),this.type="Shape",this.holes=[]}getPointsHoles(at){const pt=[];for(let vt=0,wt=this.holes.length;vt<wt;vt++)pt[vt]=this.holes[vt].getPoints(at);return pt}extractPoints(at){return{shape:this.getPoints(at),holes:this.getPointsHoles(at)}}copy(at){super.copy(at),this.holes=[];for(let pt=0,vt=at.holes.length;pt<vt;pt++){const wt=at.holes[pt];this.holes.push(wt.clone())}return this}toJSON(){const at=super.toJSON();at.uuid=this.uuid,at.holes=[];for(let pt=0,vt=this.holes.length;pt<vt;pt++){const wt=this.holes[pt];at.holes.push(wt.toJSON())}return at}fromJSON(at){super.fromJSON(at),this.uuid=at.uuid,this.holes=[];for(let pt=0,vt=at.holes.length;pt<vt;pt++){const wt=at.holes[pt];this.holes.push(new Path().fromJSON(wt))}return this}}const Earcut={triangulate:function(st,at,pt=2){const vt=at&&at.length,wt=vt?at[0]*pt:st.length;let $t=linkedList(st,0,wt,pt,!0);const Tt=[];if(!$t||$t.next===$t.prev)return Tt;let Lt,Ft,Ct,Ht,Gt,jt,qt;if(vt&&($t=eliminateHoles(st,at,$t,pt)),st.length>80*pt){Lt=Ct=st[0],Ft=Ht=st[1];for(let Kt=pt;Kt<wt;Kt+=pt)Gt=st[Kt],jt=st[Kt+1],Gt<Lt&&(Lt=Gt),jt<Ft&&(Ft=jt),Gt>Ct&&(Ct=Gt),jt>Ht&&(Ht=jt);qt=Math.max(Ct-Lt,Ht-Ft),qt=qt!==0?32767/qt:0}return earcutLinked($t,Tt,pt,Lt,Ft,qt,0),Tt}};function linkedList(st,at,pt,vt,wt){let $t,Tt;if(wt===signedArea(st,at,pt,vt)>0)for($t=at;$t<pt;$t+=vt)Tt=insertNode($t,st[$t],st[$t+1],Tt);else for($t=pt-vt;$t>=at;$t-=vt)Tt=insertNode($t,st[$t],st[$t+1],Tt);return Tt&&equals(Tt,Tt.next)&&(removeNode(Tt),Tt=Tt.next),Tt}function filterPoints(st,at){if(!st)return st;at||(at=st);let pt=st,vt;do if(vt=!1,!pt.steiner&&(equals(pt,pt.next)||area(pt.prev,pt,pt.next)===0)){if(removeNode(pt),pt=at=pt.prev,pt===pt.next)break;vt=!0}else pt=pt.next;while(vt||pt!==at);return at}function earcutLinked(st,at,pt,vt,wt,$t,Tt){if(!st)return;!Tt&&$t&&indexCurve(st,vt,wt,$t);let Lt=st,Ft,Ct;for(;st.prev!==st.next;){if(Ft=st.prev,Ct=st.next,$t?isEarHashed(st,vt,wt,$t):isEar(st)){at.push(Ft.i/pt|0),at.push(st.i/pt|0),at.push(Ct.i/pt|0),removeNode(st),st=Ct.next,Lt=Ct.next;continue}if(st=Ct,st===Lt){Tt?Tt===1?(st=cureLocalIntersections(filterPoints(st),at,pt),earcutLinked(st,at,pt,vt,wt,$t,2)):Tt===2&&splitEarcut(st,at,pt,vt,wt,$t):earcutLinked(filterPoints(st),at,pt,vt,wt,$t,1);break}}}function isEar(st){const at=st.prev,pt=st,vt=st.next;if(area(at,pt,vt)>=0)return!1;const wt=at.x,$t=pt.x,Tt=vt.x,Lt=at.y,Ft=pt.y,Ct=vt.y,Ht=wt<$t?wt<Tt?wt:Tt:$t<Tt?$t:Tt,Gt=Lt<Ft?Lt<Ct?Lt:Ct:Ft<Ct?Ft:Ct,jt=wt>$t?wt>Tt?wt:Tt:$t>Tt?$t:Tt,qt=Lt>Ft?Lt>Ct?Lt:Ct:Ft>Ct?Ft:Ct;let Kt=vt.next;for(;Kt!==at;){if(Kt.x>=Ht&&Kt.x<=jt&&Kt.y>=Gt&&Kt.y<=qt&&pointInTriangle(wt,Lt,$t,Ft,Tt,Ct,Kt.x,Kt.y)&&area(Kt.prev,Kt,Kt.next)>=0)return!1;Kt=Kt.next}return!0}function isEarHashed(st,at,pt,vt){const wt=st.prev,$t=st,Tt=st.next;if(area(wt,$t,Tt)>=0)return!1;const Lt=wt.x,Ft=$t.x,Ct=Tt.x,Ht=wt.y,Gt=$t.y,jt=Tt.y,qt=Lt<Ft?Lt<Ct?Lt:Ct:Ft<Ct?Ft:Ct,Kt=Ht<Gt?Ht<jt?Ht:jt:Gt<jt?Gt:jt,An=Lt>Ft?Lt>Ct?Lt:Ct:Ft>Ct?Ft:Ct,Sn=Ht>Gt?Ht>jt?Ht:jt:Gt>jt?Gt:jt,wn=zOrder(qt,Kt,at,pt,vt),In=zOrder(An,Sn,at,pt,vt);let tr=st.prevZ,rr=st.nextZ;for(;tr&&tr.z>=wn&&rr&&rr.z<=In;){if(tr.x>=qt&&tr.x<=An&&tr.y>=Kt&&tr.y<=Sn&&tr!==wt&&tr!==Tt&&pointInTriangle(Lt,Ht,Ft,Gt,Ct,jt,tr.x,tr.y)&&area(tr.prev,tr,tr.next)>=0||(tr=tr.prevZ,rr.x>=qt&&rr.x<=An&&rr.y>=Kt&&rr.y<=Sn&&rr!==wt&&rr!==Tt&&pointInTriangle(Lt,Ht,Ft,Gt,Ct,jt,rr.x,rr.y)&&area(rr.prev,rr,rr.next)>=0))return!1;rr=rr.nextZ}for(;tr&&tr.z>=wn;){if(tr.x>=qt&&tr.x<=An&&tr.y>=Kt&&tr.y<=Sn&&tr!==wt&&tr!==Tt&&pointInTriangle(Lt,Ht,Ft,Gt,Ct,jt,tr.x,tr.y)&&area(tr.prev,tr,tr.next)>=0)return!1;tr=tr.prevZ}for(;rr&&rr.z<=In;){if(rr.x>=qt&&rr.x<=An&&rr.y>=Kt&&rr.y<=Sn&&rr!==wt&&rr!==Tt&&pointInTriangle(Lt,Ht,Ft,Gt,Ct,jt,rr.x,rr.y)&&area(rr.prev,rr,rr.next)>=0)return!1;rr=rr.nextZ}return!0}function cureLocalIntersections(st,at,pt){let vt=st;do{const wt=vt.prev,$t=vt.next.next;!equals(wt,$t)&&intersects(wt,vt,vt.next,$t)&&locallyInside(wt,$t)&&locallyInside($t,wt)&&(at.push(wt.i/pt|0),at.push(vt.i/pt|0),at.push($t.i/pt|0),removeNode(vt),removeNode(vt.next),vt=st=$t),vt=vt.next}while(vt!==st);return filterPoints(vt)}function splitEarcut(st,at,pt,vt,wt,$t){let Tt=st;do{let Lt=Tt.next.next;for(;Lt!==Tt.prev;){if(Tt.i!==Lt.i&&isValidDiagonal(Tt,Lt)){let Ft=splitPolygon(Tt,Lt);Tt=filterPoints(Tt,Tt.next),Ft=filterPoints(Ft,Ft.next),earcutLinked(Tt,at,pt,vt,wt,$t,0),earcutLinked(Ft,at,pt,vt,wt,$t,0);return}Lt=Lt.next}Tt=Tt.next}while(Tt!==st)}function eliminateHoles(st,at,pt,vt){const wt=[];let $t,Tt,Lt,Ft,Ct;for($t=0,Tt=at.length;$t<Tt;$t++)Lt=at[$t]*vt,Ft=$t<Tt-1?at[$t+1]*vt:st.length,Ct=linkedList(st,Lt,Ft,vt,!1),Ct===Ct.next&&(Ct.steiner=!0),wt.push(getLeftmost(Ct));for(wt.sort(compareX),$t=0;$t<wt.length;$t++)pt=eliminateHole(wt[$t],pt);return pt}function compareX(st,at){return st.x-at.x}function eliminateHole(st,at){const pt=findHoleBridge(st,at);if(!pt)return at;const vt=splitPolygon(pt,st);return filterPoints(vt,vt.next),filterPoints(pt,pt.next)}function findHoleBridge(st,at){let pt=at,vt=-1/0,wt;const $t=st.x,Tt=st.y;do{if(Tt<=pt.y&&Tt>=pt.next.y&&pt.next.y!==pt.y){const jt=pt.x+(Tt-pt.y)*(pt.next.x-pt.x)/(pt.next.y-pt.y);if(jt<=$t&&jt>vt&&(vt=jt,wt=pt.x<pt.next.x?pt:pt.next,jt===$t))return wt}pt=pt.next}while(pt!==at);if(!wt)return null;const Lt=wt,Ft=wt.x,Ct=wt.y;let Ht=1/0,Gt;pt=wt;do $t>=pt.x&&pt.x>=Ft&&$t!==pt.x&&pointInTriangle(Tt<Ct?$t:vt,Tt,Ft,Ct,Tt<Ct?vt:$t,Tt,pt.x,pt.y)&&(Gt=Math.abs(Tt-pt.y)/($t-pt.x),locallyInside(pt,st)&&(Gt<Ht||Gt===Ht&&(pt.x>wt.x||pt.x===wt.x&&sectorContainsSector(wt,pt)))&&(wt=pt,Ht=Gt)),pt=pt.next;while(pt!==Lt);return wt}function sectorContainsSector(st,at){return area(st.prev,st,at.prev)<0&&area(at.next,st,st.next)<0}function indexCurve(st,at,pt,vt){let wt=st;do wt.z===0&&(wt.z=zOrder(wt.x,wt.y,at,pt,vt)),wt.prevZ=wt.prev,wt.nextZ=wt.next,wt=wt.next;while(wt!==st);wt.prevZ.nextZ=null,wt.prevZ=null,sortLinked(wt)}function sortLinked(st){let at,pt,vt,wt,$t,Tt,Lt,Ft,Ct=1;do{for(pt=st,st=null,$t=null,Tt=0;pt;){for(Tt++,vt=pt,Lt=0,at=0;at<Ct&&(Lt++,vt=vt.nextZ,!!vt);at++);for(Ft=Ct;Lt>0||Ft>0&&vt;)Lt!==0&&(Ft===0||!vt||pt.z<=vt.z)?(wt=pt,pt=pt.nextZ,Lt--):(wt=vt,vt=vt.nextZ,Ft--),$t?$t.nextZ=wt:st=wt,wt.prevZ=$t,$t=wt;pt=vt}$t.nextZ=null,Ct*=2}while(Tt>1);return st}function zOrder(st,at,pt,vt,wt){return st=(st-pt)*wt|0,at=(at-vt)*wt|0,st=(st|st<<8)&16711935,st=(st|st<<4)&252645135,st=(st|st<<2)&858993459,st=(st|st<<1)&1431655765,at=(at|at<<8)&16711935,at=(at|at<<4)&252645135,at=(at|at<<2)&858993459,at=(at|at<<1)&1431655765,st|at<<1}function getLeftmost(st){let at=st,pt=st;do(at.x<pt.x||at.x===pt.x&&at.y<pt.y)&&(pt=at),at=at.next;while(at!==st);return pt}function pointInTriangle(st,at,pt,vt,wt,$t,Tt,Lt){return(wt-Tt)*(at-Lt)>=(st-Tt)*($t-Lt)&&(st-Tt)*(vt-Lt)>=(pt-Tt)*(at-Lt)&&(pt-Tt)*($t-Lt)>=(wt-Tt)*(vt-Lt)}function isValidDiagonal(st,at){return st.next.i!==at.i&&st.prev.i!==at.i&&!intersectsPolygon(st,at)&&(locallyInside(st,at)&&locallyInside(at,st)&&middleInside(st,at)&&(area(st.prev,st,at.prev)||area(st,at.prev,at))||equals(st,at)&&area(st.prev,st,st.next)>0&&area(at.prev,at,at.next)>0)}function area(st,at,pt){return(at.y-st.y)*(pt.x-at.x)-(at.x-st.x)*(pt.y-at.y)}function equals(st,at){return st.x===at.x&&st.y===at.y}function intersects(st,at,pt,vt){const wt=sign(area(st,at,pt)),$t=sign(area(st,at,vt)),Tt=sign(area(pt,vt,st)),Lt=sign(area(pt,vt,at));return!!(wt!==$t&&Tt!==Lt||wt===0&&onSegment(st,pt,at)||$t===0&&onSegment(st,vt,at)||Tt===0&&onSegment(pt,st,vt)||Lt===0&&onSegment(pt,at,vt))}function onSegment(st,at,pt){return at.x<=Math.max(st.x,pt.x)&&at.x>=Math.min(st.x,pt.x)&&at.y<=Math.max(st.y,pt.y)&&at.y>=Math.min(st.y,pt.y)}function sign(st){return st>0?1:st<0?-1:0}function intersectsPolygon(st,at){let pt=st;do{if(pt.i!==st.i&&pt.next.i!==st.i&&pt.i!==at.i&&pt.next.i!==at.i&&intersects(pt,pt.next,st,at))return!0;pt=pt.next}while(pt!==st);return!1}function locallyInside(st,at){return area(st.prev,st,st.next)<0?area(st,at,st.next)>=0&&area(st,st.prev,at)>=0:area(st,at,st.prev)<0||area(st,st.next,at)<0}function middleInside(st,at){let pt=st,vt=!1;const wt=(st.x+at.x)/2,$t=(st.y+at.y)/2;do pt.y>$t!=pt.next.y>$t&&pt.next.y!==pt.y&&wt<(pt.next.x-pt.x)*($t-pt.y)/(pt.next.y-pt.y)+pt.x&&(vt=!vt),pt=pt.next;while(pt!==st);return vt}function splitPolygon(st,at){const pt=new Node$1(st.i,st.x,st.y),vt=new Node$1(at.i,at.x,at.y),wt=st.next,$t=at.prev;return st.next=at,at.prev=st,pt.next=wt,wt.prev=pt,vt.next=pt,pt.prev=vt,$t.next=vt,vt.prev=$t,vt}function insertNode(st,at,pt,vt){const wt=new Node$1(st,at,pt);return vt?(wt.next=vt.next,wt.prev=vt,vt.next.prev=wt,vt.next=wt):(wt.prev=wt,wt.next=wt),wt}function removeNode(st){st.next.prev=st.prev,st.prev.next=st.next,st.prevZ&&(st.prevZ.nextZ=st.nextZ),st.nextZ&&(st.nextZ.prevZ=st.prevZ)}function Node$1(st,at,pt){this.i=st,this.x=at,this.y=pt,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function signedArea(st,at,pt,vt){let wt=0;for(let $t=at,Tt=pt-vt;$t<pt;$t+=vt)wt+=(st[Tt]-st[$t])*(st[$t+1]+st[Tt+1]),Tt=$t;return wt}class ShapeUtils{static area(at){const pt=at.length;let vt=0;for(let wt=pt-1,$t=0;$t<pt;wt=$t++)vt+=at[wt].x*at[$t].y-at[$t].x*at[wt].y;return vt*.5}static isClockWise(at){return ShapeUtils.area(at)<0}static triangulateShape(at,pt){const vt=[],wt=[],$t=[];removeDupEndPts(at),addContour(vt,at);let Tt=at.length;pt.forEach(removeDupEndPts);for(let Ft=0;Ft<pt.length;Ft++)wt.push(Tt),Tt+=pt[Ft].length,addContour(vt,pt[Ft]);const Lt=Earcut.triangulate(vt,wt);for(let Ft=0;Ft<Lt.length;Ft+=3)$t.push(Lt.slice(Ft,Ft+3));return $t}}function removeDupEndPts(st){const at=st.length;at>2&&st[at-1].equals(st[0])&&st.pop()}function addContour(st,at){for(let pt=0;pt<at.length;pt++)st.push(at[pt].x),st.push(at[pt].y)}class ExtrudeGeometry extends BufferGeometry{constructor(at=new Shape([new Vector2(.5,.5),new Vector2(-.5,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),pt={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:at,options:pt},at=Array.isArray(at)?at:[at];const vt=this,wt=[],$t=[];for(let Lt=0,Ft=at.length;Lt<Ft;Lt++){const Ct=at[Lt];Tt(Ct)}this.setAttribute("position",new Float32BufferAttribute(wt,3)),this.setAttribute("uv",new Float32BufferAttribute($t,2)),this.computeVertexNormals();function Tt(Lt){const Ft=[],Ct=pt.curveSegments!==void 0?pt.curveSegments:12,Ht=pt.steps!==void 0?pt.steps:1,Gt=pt.depth!==void 0?pt.depth:1;let jt=pt.bevelEnabled!==void 0?pt.bevelEnabled:!0,qt=pt.bevelThickness!==void 0?pt.bevelThickness:.2,Kt=pt.bevelSize!==void 0?pt.bevelSize:qt-.1,An=pt.bevelOffset!==void 0?pt.bevelOffset:0,Sn=pt.bevelSegments!==void 0?pt.bevelSegments:3;const wn=pt.extrudePath,In=pt.UVGenerator!==void 0?pt.UVGenerator:WorldUVGenerator;let tr,rr=!1,Hr,qr,Zr,Bo;wn&&(tr=wn.getSpacedPoints(Ht),rr=!0,jt=!1,Hr=wn.computeFrenetFrames(Ht,!1),qr=new Vector3,Zr=new Vector3,Bo=new Vector3),jt||(Sn=0,qt=0,Kt=0,An=0);const Xo=Lt.extractPoints(Ct);let Kr=Xo.shape;const ko=Xo.holes;if(!ShapeUtils.isClockWise(Kr)){Kr=Kr.reverse();for(let _0=0,ay=ko.length;_0<ay;_0++){const J0=ko[_0];ShapeUtils.isClockWise(J0)&&(ko[_0]=J0.reverse())}}const x0=ShapeUtils.triangulateShape(Kr,ko),l0=Kr;for(let _0=0,ay=ko.length;_0<ay;_0++){const J0=ko[_0];Kr=Kr.concat(J0)}function T0(_0,ay,J0){return ay||console.error("THREE.ExtrudeGeometry: vec does not exist"),_0.clone().addScaledVector(ay,J0)}const t0=Kr.length,E0=x0.length;function n0(_0,ay,J0){let yy,uy,Dy;const Fy=_0.x-ay.x,qy=_0.y-ay.y,rv=J0.x-_0.x,y0=J0.y-_0.y,r0=Fy*Fy+qy*qy,M0=Fy*y0-qy*rv;if(Math.abs(M0)>Number.EPSILON){const G0=Math.sqrt(r0),sy=Math.sqrt(rv*rv+y0*y0),dy=ay.x-qy/G0,Vy=ay.y+Fy/G0,Xy=J0.x-y0/sy,hy=J0.y+rv/sy,Ly=((Xy-dy)*y0-(hy-Vy)*rv)/(Fy*y0-qy*rv);yy=dy+Fy*Ly-_0.x,uy=Vy+qy*Ly-_0.y;const Py=yy*yy+uy*uy;if(Py<=2)return new Vector2(yy,uy);Dy=Math.sqrt(Py/2)}else{let G0=!1;Fy>Number.EPSILON?rv>Number.EPSILON&&(G0=!0):Fy<-Number.EPSILON?rv<-Number.EPSILON&&(G0=!0):Math.sign(qy)===Math.sign(y0)&&(G0=!0),G0?(yy=-qy,uy=Fy,Dy=Math.sqrt(r0)):(yy=Fy,uy=qy,Dy=Math.sqrt(r0/2))}return new Vector2(yy/Dy,uy/Dy)}const m0=[];for(let _0=0,ay=l0.length,J0=ay-1,yy=_0+1;_0<ay;_0++,J0++,yy++)J0===ay&&(J0=0),yy===ay&&(yy=0),m0[_0]=n0(l0[_0],l0[J0],l0[yy]);const h0=[];let a0,P0=m0.concat();for(let _0=0,ay=ko.length;_0<ay;_0++){const J0=ko[_0];a0=[];for(let yy=0,uy=J0.length,Dy=uy-1,Fy=yy+1;yy<uy;yy++,Dy++,Fy++)Dy===uy&&(Dy=0),Fy===uy&&(Fy=0),a0[yy]=n0(J0[yy],J0[Dy],J0[Fy]);h0.push(a0),P0=P0.concat(a0)}for(let _0=0;_0<Sn;_0++){const ay=_0/Sn,J0=qt*Math.cos(ay*Math.PI/2),yy=Kt*Math.sin(ay*Math.PI/2)+An;for(let uy=0,Dy=l0.length;uy<Dy;uy++){const Fy=T0(l0[uy],m0[uy],yy);Ty(Fy.x,Fy.y,-J0)}for(let uy=0,Dy=ko.length;uy<Dy;uy++){const Fy=ko[uy];a0=h0[uy];for(let qy=0,rv=Fy.length;qy<rv;qy++){const y0=T0(Fy[qy],a0[qy],yy);Ty(y0.x,y0.y,-J0)}}}const V0=Kt+An;for(let _0=0;_0<t0;_0++){const ay=jt?T0(Kr[_0],P0[_0],V0):Kr[_0];rr?(Zr.copy(Hr.normals[0]).multiplyScalar(ay.x),qr.copy(Hr.binormals[0]).multiplyScalar(ay.y),Bo.copy(tr[0]).add(Zr).add(qr),Ty(Bo.x,Bo.y,Bo.z)):Ty(ay.x,ay.y,0)}for(let _0=1;_0<=Ht;_0++)for(let ay=0;ay<t0;ay++){const J0=jt?T0(Kr[ay],P0[ay],V0):Kr[ay];rr?(Zr.copy(Hr.normals[_0]).multiplyScalar(J0.x),qr.copy(Hr.binormals[_0]).multiplyScalar(J0.y),Bo.copy(tr[_0]).add(Zr).add(qr),Ty(Bo.x,Bo.y,Bo.z)):Ty(J0.x,J0.y,Gt/Ht*_0)}for(let _0=Sn-1;_0>=0;_0--){const ay=_0/Sn,J0=qt*Math.cos(ay*Math.PI/2),yy=Kt*Math.sin(ay*Math.PI/2)+An;for(let uy=0,Dy=l0.length;uy<Dy;uy++){const Fy=T0(l0[uy],m0[uy],yy);Ty(Fy.x,Fy.y,Gt+J0)}for(let uy=0,Dy=ko.length;uy<Dy;uy++){const Fy=ko[uy];a0=h0[uy];for(let qy=0,rv=Fy.length;qy<rv;qy++){const y0=T0(Fy[qy],a0[qy],yy);rr?Ty(y0.x,y0.y+tr[Ht-1].y,tr[Ht-1].x+J0):Ty(y0.x,y0.y,Gt+J0)}}}B0(),W0();function B0(){const _0=wt.length/3;if(jt){let ay=0,J0=t0*ay;for(let yy=0;yy<E0;yy++){const uy=x0[yy];$y(uy[2]+J0,uy[1]+J0,uy[0]+J0)}ay=Ht+Sn*2,J0=t0*ay;for(let yy=0;yy<E0;yy++){const uy=x0[yy];$y(uy[0]+J0,uy[1]+J0,uy[2]+J0)}}else{for(let ay=0;ay<E0;ay++){const J0=x0[ay];$y(J0[2],J0[1],J0[0])}for(let ay=0;ay<E0;ay++){const J0=x0[ay];$y(J0[0]+t0*Ht,J0[1]+t0*Ht,J0[2]+t0*Ht)}}vt.addGroup(_0,wt.length/3-_0,0)}function W0(){const _0=wt.length/3;let ay=0;K0(l0,ay),ay+=l0.length;for(let J0=0,yy=ko.length;J0<yy;J0++){const uy=ko[J0];K0(uy,ay),ay+=uy.length}vt.addGroup(_0,wt.length/3-_0,1)}function K0(_0,ay){let J0=_0.length;for(;--J0>=0;){const yy=J0;let uy=J0-1;uy<0&&(uy=_0.length-1);for(let Dy=0,Fy=Ht+Sn*2;Dy<Fy;Dy++){const qy=t0*Dy,rv=t0*(Dy+1),y0=ay+yy+qy,r0=ay+uy+qy,M0=ay+uy+rv,G0=ay+yy+rv;My(y0,r0,M0,G0)}}}function Ty(_0,ay,J0){Ft.push(_0),Ft.push(ay),Ft.push(J0)}function $y(_0,ay,J0){Wy(_0),Wy(ay),Wy(J0);const yy=wt.length/3,uy=In.generateTopUV(vt,wt,yy-3,yy-2,yy-1);Ey(uy[0]),Ey(uy[1]),Ey(uy[2])}function My(_0,ay,J0,yy){Wy(_0),Wy(ay),Wy(yy),Wy(ay),Wy(J0),Wy(yy);const uy=wt.length/3,Dy=In.generateSideWallUV(vt,wt,uy-6,uy-3,uy-2,uy-1);Ey(Dy[0]),Ey(Dy[1]),Ey(Dy[3]),Ey(Dy[1]),Ey(Dy[2]),Ey(Dy[3])}function Wy(_0){wt.push(Ft[_0*3+0]),wt.push(Ft[_0*3+1]),wt.push(Ft[_0*3+2])}function Ey(_0){$t.push(_0.x),$t.push(_0.y)}}}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}toJSON(){const at=super.toJSON(),pt=this.parameters.shapes,vt=this.parameters.options;return toJSON$1(pt,vt,at)}static fromJSON(at,pt){const vt=[];for(let $t=0,Tt=at.shapes.length;$t<Tt;$t++){const Lt=pt[at.shapes[$t]];vt.push(Lt)}const wt=at.options.extrudePath;return wt!==void 0&&(at.options.extrudePath=new Curves[wt.type]().fromJSON(wt)),new ExtrudeGeometry(vt,at.options)}}const WorldUVGenerator={generateTopUV:function(st,at,pt,vt,wt){const $t=at[pt*3],Tt=at[pt*3+1],Lt=at[vt*3],Ft=at[vt*3+1],Ct=at[wt*3],Ht=at[wt*3+1];return[new Vector2($t,Tt),new Vector2(Lt,Ft),new Vector2(Ct,Ht)]},generateSideWallUV:function(st,at,pt,vt,wt,$t){const Tt=at[pt*3],Lt=at[pt*3+1],Ft=at[pt*3+2],Ct=at[vt*3],Ht=at[vt*3+1],Gt=at[vt*3+2],jt=at[wt*3],qt=at[wt*3+1],Kt=at[wt*3+2],An=at[$t*3],Sn=at[$t*3+1],wn=at[$t*3+2];return Math.abs(Lt-Ht)<Math.abs(Tt-Ct)?[new Vector2(Tt,1-Ft),new Vector2(Ct,1-Gt),new Vector2(jt,1-Kt),new Vector2(An,1-wn)]:[new Vector2(Lt,1-Ft),new Vector2(Ht,1-Gt),new Vector2(qt,1-Kt),new Vector2(Sn,1-wn)]}};function toJSON$1(st,at,pt){if(pt.shapes=[],Array.isArray(st))for(let vt=0,wt=st.length;vt<wt;vt++){const $t=st[vt];pt.shapes.push($t.uuid)}else pt.shapes.push(st.uuid);return pt.options=Object.assign({},at),at.extrudePath!==void 0&&(pt.options.extrudePath=at.extrudePath.toJSON()),pt}class IcosahedronGeometry extends PolyhedronGeometry{constructor(at=1,pt=0){const vt=(1+Math.sqrt(5))/2,wt=[-1,vt,0,1,vt,0,-1,-vt,0,1,-vt,0,0,-1,vt,0,1,vt,0,-1,-vt,0,1,-vt,vt,0,-1,vt,0,1,-vt,0,-1,-vt,0,1],$t=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(wt,$t,at,pt),this.type="IcosahedronGeometry",this.parameters={radius:at,detail:pt}}static fromJSON(at){return new IcosahedronGeometry(at.radius,at.detail)}}class OctahedronGeometry extends PolyhedronGeometry{constructor(at=1,pt=0){const vt=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],wt=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(vt,wt,at,pt),this.type="OctahedronGeometry",this.parameters={radius:at,detail:pt}}static fromJSON(at){return new OctahedronGeometry(at.radius,at.detail)}}class RingGeometry extends BufferGeometry{constructor(at=.5,pt=1,vt=32,wt=1,$t=0,Tt=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:at,outerRadius:pt,thetaSegments:vt,phiSegments:wt,thetaStart:$t,thetaLength:Tt},vt=Math.max(3,vt),wt=Math.max(1,wt);const Lt=[],Ft=[],Ct=[],Ht=[];let Gt=at;const jt=(pt-at)/wt,qt=new Vector3,Kt=new Vector2;for(let An=0;An<=wt;An++){for(let Sn=0;Sn<=vt;Sn++){const wn=$t+Sn/vt*Tt;qt.x=Gt*Math.cos(wn),qt.y=Gt*Math.sin(wn),Ft.push(qt.x,qt.y,qt.z),Ct.push(0,0,1),Kt.x=(qt.x/pt+1)/2,Kt.y=(qt.y/pt+1)/2,Ht.push(Kt.x,Kt.y)}Gt+=jt}for(let An=0;An<wt;An++){const Sn=An*(vt+1);for(let wn=0;wn<vt;wn++){const In=wn+Sn,tr=In,rr=In+vt+1,Hr=In+vt+2,qr=In+1;Lt.push(tr,rr,qr),Lt.push(rr,Hr,qr)}}this.setIndex(Lt),this.setAttribute("position",new Float32BufferAttribute(Ft,3)),this.setAttribute("normal",new Float32BufferAttribute(Ct,3)),this.setAttribute("uv",new Float32BufferAttribute(Ht,2))}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}static fromJSON(at){return new RingGeometry(at.innerRadius,at.outerRadius,at.thetaSegments,at.phiSegments,at.thetaStart,at.thetaLength)}}class ShapeGeometry extends BufferGeometry{constructor(at=new Shape([new Vector2(0,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),pt=12){super(),this.type="ShapeGeometry",this.parameters={shapes:at,curveSegments:pt};const vt=[],wt=[],$t=[],Tt=[];let Lt=0,Ft=0;if(Array.isArray(at)===!1)Ct(at);else for(let Ht=0;Ht<at.length;Ht++)Ct(at[Ht]),this.addGroup(Lt,Ft,Ht),Lt+=Ft,Ft=0;this.setIndex(vt),this.setAttribute("position",new Float32BufferAttribute(wt,3)),this.setAttribute("normal",new Float32BufferAttribute($t,3)),this.setAttribute("uv",new Float32BufferAttribute(Tt,2));function Ct(Ht){const Gt=wt.length/3,jt=Ht.extractPoints(pt);let qt=jt.shape;const Kt=jt.holes;ShapeUtils.isClockWise(qt)===!1&&(qt=qt.reverse());for(let Sn=0,wn=Kt.length;Sn<wn;Sn++){const In=Kt[Sn];ShapeUtils.isClockWise(In)===!0&&(Kt[Sn]=In.reverse())}const An=ShapeUtils.triangulateShape(qt,Kt);for(let Sn=0,wn=Kt.length;Sn<wn;Sn++){const In=Kt[Sn];qt=qt.concat(In)}for(let Sn=0,wn=qt.length;Sn<wn;Sn++){const In=qt[Sn];wt.push(In.x,In.y,0),$t.push(0,0,1),Tt.push(In.x,In.y)}for(let Sn=0,wn=An.length;Sn<wn;Sn++){const In=An[Sn],tr=In[0]+Gt,rr=In[1]+Gt,Hr=In[2]+Gt;vt.push(tr,rr,Hr),Ft+=3}}}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}toJSON(){const at=super.toJSON(),pt=this.parameters.shapes;return toJSON(pt,at)}static fromJSON(at,pt){const vt=[];for(let wt=0,$t=at.shapes.length;wt<$t;wt++){const Tt=pt[at.shapes[wt]];vt.push(Tt)}return new ShapeGeometry(vt,at.curveSegments)}}function toJSON(st,at){if(at.shapes=[],Array.isArray(st))for(let pt=0,vt=st.length;pt<vt;pt++){const wt=st[pt];at.shapes.push(wt.uuid)}else at.shapes.push(st.uuid);return at}class SphereGeometry extends BufferGeometry{constructor(at=1,pt=32,vt=16,wt=0,$t=Math.PI*2,Tt=0,Lt=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:at,widthSegments:pt,heightSegments:vt,phiStart:wt,phiLength:$t,thetaStart:Tt,thetaLength:Lt},pt=Math.max(3,Math.floor(pt)),vt=Math.max(2,Math.floor(vt));const Ft=Math.min(Tt+Lt,Math.PI);let Ct=0;const Ht=[],Gt=new Vector3,jt=new Vector3,qt=[],Kt=[],An=[],Sn=[];for(let wn=0;wn<=vt;wn++){const In=[],tr=wn/vt;let rr=0;wn===0&&Tt===0?rr=.5/pt:wn===vt&&Ft===Math.PI&&(rr=-.5/pt);for(let Hr=0;Hr<=pt;Hr++){const qr=Hr/pt;Gt.x=-at*Math.cos(wt+qr*$t)*Math.sin(Tt+tr*Lt),Gt.y=at*Math.cos(Tt+tr*Lt),Gt.z=at*Math.sin(wt+qr*$t)*Math.sin(Tt+tr*Lt),Kt.push(Gt.x,Gt.y,Gt.z),jt.copy(Gt).normalize(),An.push(jt.x,jt.y,jt.z),Sn.push(qr+rr,1-tr),In.push(Ct++)}Ht.push(In)}for(let wn=0;wn<vt;wn++)for(let In=0;In<pt;In++){const tr=Ht[wn][In+1],rr=Ht[wn][In],Hr=Ht[wn+1][In],qr=Ht[wn+1][In+1];(wn!==0||Tt>0)&&qt.push(tr,rr,qr),(wn!==vt-1||Ft<Math.PI)&&qt.push(rr,Hr,qr)}this.setIndex(qt),this.setAttribute("position",new Float32BufferAttribute(Kt,3)),this.setAttribute("normal",new Float32BufferAttribute(An,3)),this.setAttribute("uv",new Float32BufferAttribute(Sn,2))}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}static fromJSON(at){return new SphereGeometry(at.radius,at.widthSegments,at.heightSegments,at.phiStart,at.phiLength,at.thetaStart,at.thetaLength)}}class TetrahedronGeometry extends PolyhedronGeometry{constructor(at=1,pt=0){const vt=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],wt=[2,1,0,0,3,2,1,3,0,2,3,1];super(vt,wt,at,pt),this.type="TetrahedronGeometry",this.parameters={radius:at,detail:pt}}static fromJSON(at){return new TetrahedronGeometry(at.radius,at.detail)}}class TorusGeometry extends BufferGeometry{constructor(at=1,pt=.4,vt=12,wt=48,$t=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:at,tube:pt,radialSegments:vt,tubularSegments:wt,arc:$t},vt=Math.floor(vt),wt=Math.floor(wt);const Tt=[],Lt=[],Ft=[],Ct=[],Ht=new Vector3,Gt=new Vector3,jt=new Vector3;for(let qt=0;qt<=vt;qt++)for(let Kt=0;Kt<=wt;Kt++){const An=Kt/wt*$t,Sn=qt/vt*Math.PI*2;Gt.x=(at+pt*Math.cos(Sn))*Math.cos(An),Gt.y=(at+pt*Math.cos(Sn))*Math.sin(An),Gt.z=pt*Math.sin(Sn),Lt.push(Gt.x,Gt.y,Gt.z),Ht.x=at*Math.cos(An),Ht.y=at*Math.sin(An),jt.subVectors(Gt,Ht).normalize(),Ft.push(jt.x,jt.y,jt.z),Ct.push(Kt/wt),Ct.push(qt/vt)}for(let qt=1;qt<=vt;qt++)for(let Kt=1;Kt<=wt;Kt++){const An=(wt+1)*qt+Kt-1,Sn=(wt+1)*(qt-1)+Kt-1,wn=(wt+1)*(qt-1)+Kt,In=(wt+1)*qt+Kt;Tt.push(An,Sn,In),Tt.push(Sn,wn,In)}this.setIndex(Tt),this.setAttribute("position",new Float32BufferAttribute(Lt,3)),this.setAttribute("normal",new Float32BufferAttribute(Ft,3)),this.setAttribute("uv",new Float32BufferAttribute(Ct,2))}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}static fromJSON(at){return new TorusGeometry(at.radius,at.tube,at.radialSegments,at.tubularSegments,at.arc)}}class TorusKnotGeometry extends BufferGeometry{constructor(at=1,pt=.4,vt=64,wt=8,$t=2,Tt=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:at,tube:pt,tubularSegments:vt,radialSegments:wt,p:$t,q:Tt},vt=Math.floor(vt),wt=Math.floor(wt);const Lt=[],Ft=[],Ct=[],Ht=[],Gt=new Vector3,jt=new Vector3,qt=new Vector3,Kt=new Vector3,An=new Vector3,Sn=new Vector3,wn=new Vector3;for(let tr=0;tr<=vt;++tr){const rr=tr/vt*$t*Math.PI*2;In(rr,$t,Tt,at,qt),In(rr+.01,$t,Tt,at,Kt),Sn.subVectors(Kt,qt),wn.addVectors(Kt,qt),An.crossVectors(Sn,wn),wn.crossVectors(An,Sn),An.normalize(),wn.normalize();for(let Hr=0;Hr<=wt;++Hr){const qr=Hr/wt*Math.PI*2,Zr=-pt*Math.cos(qr),Bo=pt*Math.sin(qr);Gt.x=qt.x+(Zr*wn.x+Bo*An.x),Gt.y=qt.y+(Zr*wn.y+Bo*An.y),Gt.z=qt.z+(Zr*wn.z+Bo*An.z),Ft.push(Gt.x,Gt.y,Gt.z),jt.subVectors(Gt,qt).normalize(),Ct.push(jt.x,jt.y,jt.z),Ht.push(tr/vt),Ht.push(Hr/wt)}}for(let tr=1;tr<=vt;tr++)for(let rr=1;rr<=wt;rr++){const Hr=(wt+1)*(tr-1)+(rr-1),qr=(wt+1)*tr+(rr-1),Zr=(wt+1)*tr+rr,Bo=(wt+1)*(tr-1)+rr;Lt.push(Hr,qr,Bo),Lt.push(qr,Zr,Bo)}this.setIndex(Lt),this.setAttribute("position",new Float32BufferAttribute(Ft,3)),this.setAttribute("normal",new Float32BufferAttribute(Ct,3)),this.setAttribute("uv",new Float32BufferAttribute(Ht,2));function In(tr,rr,Hr,qr,Zr){const Bo=Math.cos(tr),Xo=Math.sin(tr),Kr=Hr/rr*tr,ko=Math.cos(Kr);Zr.x=qr*(2+ko)*.5*Bo,Zr.y=qr*(2+ko)*Xo*.5,Zr.z=qr*Math.sin(Kr)*.5}}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}static fromJSON(at){return new TorusKnotGeometry(at.radius,at.tube,at.tubularSegments,at.radialSegments,at.p,at.q)}}class TubeGeometry extends BufferGeometry{constructor(at=new QuadraticBezierCurve3(new Vector3(-1,-1,0),new Vector3(-1,1,0),new Vector3(1,1,0)),pt=64,vt=1,wt=8,$t=!1){super(),this.type="TubeGeometry",this.parameters={path:at,tubularSegments:pt,radius:vt,radialSegments:wt,closed:$t};const Tt=at.computeFrenetFrames(pt,$t);this.tangents=Tt.tangents,this.normals=Tt.normals,this.binormals=Tt.binormals;const Lt=new Vector3,Ft=new Vector3,Ct=new Vector2;let Ht=new Vector3;const Gt=[],jt=[],qt=[],Kt=[];An(),this.setIndex(Kt),this.setAttribute("position",new Float32BufferAttribute(Gt,3)),this.setAttribute("normal",new Float32BufferAttribute(jt,3)),this.setAttribute("uv",new Float32BufferAttribute(qt,2));function An(){for(let tr=0;tr<pt;tr++)Sn(tr);Sn($t===!1?pt:0),In(),wn()}function Sn(tr){Ht=at.getPointAt(tr/pt,Ht);const rr=Tt.normals[tr],Hr=Tt.binormals[tr];for(let qr=0;qr<=wt;qr++){const Zr=qr/wt*Math.PI*2,Bo=Math.sin(Zr),Xo=-Math.cos(Zr);Ft.x=Xo*rr.x+Bo*Hr.x,Ft.y=Xo*rr.y+Bo*Hr.y,Ft.z=Xo*rr.z+Bo*Hr.z,Ft.normalize(),jt.push(Ft.x,Ft.y,Ft.z),Lt.x=Ht.x+vt*Ft.x,Lt.y=Ht.y+vt*Ft.y,Lt.z=Ht.z+vt*Ft.z,Gt.push(Lt.x,Lt.y,Lt.z)}}function wn(){for(let tr=1;tr<=pt;tr++)for(let rr=1;rr<=wt;rr++){const Hr=(wt+1)*(tr-1)+(rr-1),qr=(wt+1)*tr+(rr-1),Zr=(wt+1)*tr+rr,Bo=(wt+1)*(tr-1)+rr;Kt.push(Hr,qr,Bo),Kt.push(qr,Zr,Bo)}}function In(){for(let tr=0;tr<=pt;tr++)for(let rr=0;rr<=wt;rr++)Ct.x=tr/pt,Ct.y=rr/wt,qt.push(Ct.x,Ct.y)}}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}toJSON(){const at=super.toJSON();return at.path=this.parameters.path.toJSON(),at}static fromJSON(at){return new TubeGeometry(new Curves[at.path.type]().fromJSON(at.path),at.tubularSegments,at.radius,at.radialSegments,at.closed)}}class WireframeGeometry extends BufferGeometry{constructor(at=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:at},at!==null){const pt=[],vt=new Set,wt=new Vector3,$t=new Vector3;if(at.index!==null){const Tt=at.attributes.position,Lt=at.index;let Ft=at.groups;Ft.length===0&&(Ft=[{start:0,count:Lt.count,materialIndex:0}]);for(let Ct=0,Ht=Ft.length;Ct<Ht;++Ct){const Gt=Ft[Ct],jt=Gt.start,qt=Gt.count;for(let Kt=jt,An=jt+qt;Kt<An;Kt+=3)for(let Sn=0;Sn<3;Sn++){const wn=Lt.getX(Kt+Sn),In=Lt.getX(Kt+(Sn+1)%3);wt.fromBufferAttribute(Tt,wn),$t.fromBufferAttribute(Tt,In),isUniqueEdge(wt,$t,vt)===!0&&(pt.push(wt.x,wt.y,wt.z),pt.push($t.x,$t.y,$t.z))}}}else{const Tt=at.attributes.position;for(let Lt=0,Ft=Tt.count/3;Lt<Ft;Lt++)for(let Ct=0;Ct<3;Ct++){const Ht=3*Lt+Ct,Gt=3*Lt+(Ct+1)%3;wt.fromBufferAttribute(Tt,Ht),$t.fromBufferAttribute(Tt,Gt),isUniqueEdge(wt,$t,vt)===!0&&(pt.push(wt.x,wt.y,wt.z),pt.push($t.x,$t.y,$t.z))}}this.setAttribute("position",new Float32BufferAttribute(pt,3))}}copy(at){return super.copy(at),this.parameters=Object.assign({},at.parameters),this}}function isUniqueEdge(st,at,pt){const vt=`${st.x},${st.y},${st.z}-${at.x},${at.y},${at.z}`,wt=`${at.x},${at.y},${at.z}-${st.x},${st.y},${st.z}`;return pt.has(vt)===!0||pt.has(wt)===!0?!1:(pt.add(vt),pt.add(wt),!0)}var Geometries=Object.freeze({__proto__:null,BoxGeometry,CapsuleGeometry,CircleGeometry,ConeGeometry,CylinderGeometry,DodecahedronGeometry,EdgesGeometry,ExtrudeGeometry,IcosahedronGeometry,LatheGeometry,OctahedronGeometry,PlaneGeometry,PolyhedronGeometry,RingGeometry,ShapeGeometry,SphereGeometry,TetrahedronGeometry,TorusGeometry,TorusKnotGeometry,TubeGeometry,WireframeGeometry});class ShadowMaterial extends Material{constructor(at){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Color$1(0),this.transparent=!0,this.fog=!0,this.setValues(at)}copy(at){return super.copy(at),this.color.copy(at.color),this.fog=at.fog,this}}class RawShaderMaterial extends ShaderMaterial{constructor(at){super(at),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class MeshStandardMaterial extends Material{constructor(at){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Color$1(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color$1(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(at)}copy(at){return super.copy(at),this.defines={STANDARD:""},this.color.copy(at.color),this.roughness=at.roughness,this.metalness=at.metalness,this.map=at.map,this.lightMap=at.lightMap,this.lightMapIntensity=at.lightMapIntensity,this.aoMap=at.aoMap,this.aoMapIntensity=at.aoMapIntensity,this.emissive.copy(at.emissive),this.emissiveMap=at.emissiveMap,this.emissiveIntensity=at.emissiveIntensity,this.bumpMap=at.bumpMap,this.bumpScale=at.bumpScale,this.normalMap=at.normalMap,this.normalMapType=at.normalMapType,this.normalScale.copy(at.normalScale),this.displacementMap=at.displacementMap,this.displacementScale=at.displacementScale,this.displacementBias=at.displacementBias,this.roughnessMap=at.roughnessMap,this.metalnessMap=at.metalnessMap,this.alphaMap=at.alphaMap,this.envMap=at.envMap,this.envMapRotation.copy(at.envMapRotation),this.envMapIntensity=at.envMapIntensity,this.wireframe=at.wireframe,this.wireframeLinewidth=at.wireframeLinewidth,this.wireframeLinecap=at.wireframeLinecap,this.wireframeLinejoin=at.wireframeLinejoin,this.flatShading=at.flatShading,this.fog=at.fog,this}}class MeshPhysicalMaterial extends MeshStandardMaterial{constructor(at){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Vector2(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return clamp$3(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(pt){this.ior=(1+.4*pt)/(1-.4*pt)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Color$1(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Color$1(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Color$1(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(at)}get anisotropy(){return this._anisotropy}set anisotropy(at){this._anisotropy>0!=at>0&&this.version++,this._anisotropy=at}get clearcoat(){return this._clearcoat}set clearcoat(at){this._clearcoat>0!=at>0&&this.version++,this._clearcoat=at}get iridescence(){return this._iridescence}set iridescence(at){this._iridescence>0!=at>0&&this.version++,this._iridescence=at}get sheen(){return this._sheen}set sheen(at){this._sheen>0!=at>0&&this.version++,this._sheen=at}get transmission(){return this._transmission}set transmission(at){this._transmission>0!=at>0&&this.version++,this._transmission=at}copy(at){return super.copy(at),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=at.anisotropy,this.anisotropyRotation=at.anisotropyRotation,this.anisotropyMap=at.anisotropyMap,this.clearcoat=at.clearcoat,this.clearcoatMap=at.clearcoatMap,this.clearcoatRoughness=at.clearcoatRoughness,this.clearcoatRoughnessMap=at.clearcoatRoughnessMap,this.clearcoatNormalMap=at.clearcoatNormalMap,this.clearcoatNormalScale.copy(at.clearcoatNormalScale),this.ior=at.ior,this.iridescence=at.iridescence,this.iridescenceMap=at.iridescenceMap,this.iridescenceIOR=at.iridescenceIOR,this.iridescenceThicknessRange=[...at.iridescenceThicknessRange],this.iridescenceThicknessMap=at.iridescenceThicknessMap,this.sheen=at.sheen,this.sheenColor.copy(at.sheenColor),this.sheenColorMap=at.sheenColorMap,this.sheenRoughness=at.sheenRoughness,this.sheenRoughnessMap=at.sheenRoughnessMap,this.transmission=at.transmission,this.transmissionMap=at.transmissionMap,this.thickness=at.thickness,this.thicknessMap=at.thicknessMap,this.attenuationDistance=at.attenuationDistance,this.attenuationColor.copy(at.attenuationColor),this.specularIntensity=at.specularIntensity,this.specularIntensityMap=at.specularIntensityMap,this.specularColor.copy(at.specularColor),this.specularColorMap=at.specularColorMap,this}}class MeshPhongMaterial extends Material{constructor(at){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Color$1(16777215),this.specular=new Color$1(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color$1(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(at)}copy(at){return super.copy(at),this.color.copy(at.color),this.specular.copy(at.specular),this.shininess=at.shininess,this.map=at.map,this.lightMap=at.lightMap,this.lightMapIntensity=at.lightMapIntensity,this.aoMap=at.aoMap,this.aoMapIntensity=at.aoMapIntensity,this.emissive.copy(at.emissive),this.emissiveMap=at.emissiveMap,this.emissiveIntensity=at.emissiveIntensity,this.bumpMap=at.bumpMap,this.bumpScale=at.bumpScale,this.normalMap=at.normalMap,this.normalMapType=at.normalMapType,this.normalScale.copy(at.normalScale),this.displacementMap=at.displacementMap,this.displacementScale=at.displacementScale,this.displacementBias=at.displacementBias,this.specularMap=at.specularMap,this.alphaMap=at.alphaMap,this.envMap=at.envMap,this.envMapRotation.copy(at.envMapRotation),this.combine=at.combine,this.reflectivity=at.reflectivity,this.refractionRatio=at.refractionRatio,this.wireframe=at.wireframe,this.wireframeLinewidth=at.wireframeLinewidth,this.wireframeLinecap=at.wireframeLinecap,this.wireframeLinejoin=at.wireframeLinejoin,this.flatShading=at.flatShading,this.fog=at.fog,this}}class MeshToonMaterial extends Material{constructor(at){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Color$1(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color$1(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(at)}copy(at){return super.copy(at),this.color.copy(at.color),this.map=at.map,this.gradientMap=at.gradientMap,this.lightMap=at.lightMap,this.lightMapIntensity=at.lightMapIntensity,this.aoMap=at.aoMap,this.aoMapIntensity=at.aoMapIntensity,this.emissive.copy(at.emissive),this.emissiveMap=at.emissiveMap,this.emissiveIntensity=at.emissiveIntensity,this.bumpMap=at.bumpMap,this.bumpScale=at.bumpScale,this.normalMap=at.normalMap,this.normalMapType=at.normalMapType,this.normalScale.copy(at.normalScale),this.displacementMap=at.displacementMap,this.displacementScale=at.displacementScale,this.displacementBias=at.displacementBias,this.alphaMap=at.alphaMap,this.wireframe=at.wireframe,this.wireframeLinewidth=at.wireframeLinewidth,this.wireframeLinecap=at.wireframeLinecap,this.wireframeLinejoin=at.wireframeLinejoin,this.fog=at.fog,this}}class MeshNormalMaterial extends Material{constructor(at){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(at)}copy(at){return super.copy(at),this.bumpMap=at.bumpMap,this.bumpScale=at.bumpScale,this.normalMap=at.normalMap,this.normalMapType=at.normalMapType,this.normalScale.copy(at.normalScale),this.displacementMap=at.displacementMap,this.displacementScale=at.displacementScale,this.displacementBias=at.displacementBias,this.wireframe=at.wireframe,this.wireframeLinewidth=at.wireframeLinewidth,this.flatShading=at.flatShading,this}}class MeshLambertMaterial extends Material{constructor(at){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Color$1(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color$1(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(at)}copy(at){return super.copy(at),this.color.copy(at.color),this.map=at.map,this.lightMap=at.lightMap,this.lightMapIntensity=at.lightMapIntensity,this.aoMap=at.aoMap,this.aoMapIntensity=at.aoMapIntensity,this.emissive.copy(at.emissive),this.emissiveMap=at.emissiveMap,this.emissiveIntensity=at.emissiveIntensity,this.bumpMap=at.bumpMap,this.bumpScale=at.bumpScale,this.normalMap=at.normalMap,this.normalMapType=at.normalMapType,this.normalScale.copy(at.normalScale),this.displacementMap=at.displacementMap,this.displacementScale=at.displacementScale,this.displacementBias=at.displacementBias,this.specularMap=at.specularMap,this.alphaMap=at.alphaMap,this.envMap=at.envMap,this.envMapRotation.copy(at.envMapRotation),this.combine=at.combine,this.reflectivity=at.reflectivity,this.refractionRatio=at.refractionRatio,this.wireframe=at.wireframe,this.wireframeLinewidth=at.wireframeLinewidth,this.wireframeLinecap=at.wireframeLinecap,this.wireframeLinejoin=at.wireframeLinejoin,this.flatShading=at.flatShading,this.fog=at.fog,this}}class MeshMatcapMaterial extends Material{constructor(at){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Color$1(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(at)}copy(at){return super.copy(at),this.defines={MATCAP:""},this.color.copy(at.color),this.matcap=at.matcap,this.map=at.map,this.bumpMap=at.bumpMap,this.bumpScale=at.bumpScale,this.normalMap=at.normalMap,this.normalMapType=at.normalMapType,this.normalScale.copy(at.normalScale),this.displacementMap=at.displacementMap,this.displacementScale=at.displacementScale,this.displacementBias=at.displacementBias,this.alphaMap=at.alphaMap,this.flatShading=at.flatShading,this.fog=at.fog,this}}class LineDashedMaterial extends LineBasicMaterial{constructor(at){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(at)}copy(at){return super.copy(at),this.scale=at.scale,this.dashSize=at.dashSize,this.gapSize=at.gapSize,this}}function convertArray(st,at,pt){return!st||!pt&&st.constructor===at?st:typeof at.BYTES_PER_ELEMENT=="number"?new at(st):Array.prototype.slice.call(st)}function isTypedArray(st){return ArrayBuffer.isView(st)&&!(st instanceof DataView)}function getKeyframeOrder(st){function at(wt,$t){return st[wt]-st[$t]}const pt=st.length,vt=new Array(pt);for(let wt=0;wt!==pt;++wt)vt[wt]=wt;return vt.sort(at),vt}function sortedArray(st,at,pt){const vt=st.length,wt=new st.constructor(vt);for(let $t=0,Tt=0;Tt!==vt;++$t){const Lt=pt[$t]*at;for(let Ft=0;Ft!==at;++Ft)wt[Tt++]=st[Lt+Ft]}return wt}function flattenJSON(st,at,pt,vt){let wt=1,$t=st[0];for(;$t!==void 0&&$t[vt]===void 0;)$t=st[wt++];if($t===void 0)return;let Tt=$t[vt];if(Tt!==void 0)if(Array.isArray(Tt))do Tt=$t[vt],Tt!==void 0&&(at.push($t.time),pt.push.apply(pt,Tt)),$t=st[wt++];while($t!==void 0);else if(Tt.toArray!==void 0)do Tt=$t[vt],Tt!==void 0&&(at.push($t.time),Tt.toArray(pt,pt.length)),$t=st[wt++];while($t!==void 0);else do Tt=$t[vt],Tt!==void 0&&(at.push($t.time),pt.push(Tt)),$t=st[wt++];while($t!==void 0)}function subclip(st,at,pt,vt,wt=30){const $t=st.clone();$t.name=at;const Tt=[];for(let Ft=0;Ft<$t.tracks.length;++Ft){const Ct=$t.tracks[Ft],Ht=Ct.getValueSize(),Gt=[],jt=[];for(let qt=0;qt<Ct.times.length;++qt){const Kt=Ct.times[qt]*wt;if(!(Kt<pt||Kt>=vt)){Gt.push(Ct.times[qt]);for(let An=0;An<Ht;++An)jt.push(Ct.values[qt*Ht+An])}}Gt.length!==0&&(Ct.times=convertArray(Gt,Ct.times.constructor),Ct.values=convertArray(jt,Ct.values.constructor),Tt.push(Ct))}$t.tracks=Tt;let Lt=1/0;for(let Ft=0;Ft<$t.tracks.length;++Ft)Lt>$t.tracks[Ft].times[0]&&(Lt=$t.tracks[Ft].times[0]);for(let Ft=0;Ft<$t.tracks.length;++Ft)$t.tracks[Ft].shift(-1*Lt);return $t.resetDuration(),$t}function makeClipAdditive(st,at=0,pt=st,vt=30){vt<=0&&(vt=30);const wt=pt.tracks.length,$t=at/vt;for(let Tt=0;Tt<wt;++Tt){const Lt=pt.tracks[Tt],Ft=Lt.ValueTypeName;if(Ft==="bool"||Ft==="string")continue;const Ct=st.tracks.find(function(wn){return wn.name===Lt.name&&wn.ValueTypeName===Ft});if(Ct===void 0)continue;let Ht=0;const Gt=Lt.getValueSize();Lt.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(Ht=Gt/3);let jt=0;const qt=Ct.getValueSize();Ct.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(jt=qt/3);const Kt=Lt.times.length-1;let An;if($t<=Lt.times[0]){const wn=Ht,In=Gt-Ht;An=Lt.values.slice(wn,In)}else if($t>=Lt.times[Kt]){const wn=Kt*Gt+Ht,In=wn+Gt-Ht;An=Lt.values.slice(wn,In)}else{const wn=Lt.createInterpolant(),In=Ht,tr=Gt-Ht;wn.evaluate($t),An=wn.resultBuffer.slice(In,tr)}Ft==="quaternion"&&new Quaternion().fromArray(An).normalize().conjugate().toArray(An);const Sn=Ct.times.length;for(let wn=0;wn<Sn;++wn){const In=wn*qt+jt;if(Ft==="quaternion")Quaternion.multiplyQuaternionsFlat(Ct.values,In,An,0,Ct.values,In);else{const tr=qt-jt*2;for(let rr=0;rr<tr;++rr)Ct.values[In+rr]-=An[rr]}}}return st.blendMode=AdditiveAnimationBlendMode,st}const AnimationUtils={convertArray,isTypedArray,getKeyframeOrder,sortedArray,flattenJSON,subclip,makeClipAdditive};class Interpolant{constructor(at,pt,vt,wt){this.parameterPositions=at,this._cachedIndex=0,this.resultBuffer=wt!==void 0?wt:new pt.constructor(vt),this.sampleValues=pt,this.valueSize=vt,this.settings=null,this.DefaultSettings_={}}evaluate(at){const pt=this.parameterPositions;let vt=this._cachedIndex,wt=pt[vt],$t=pt[vt-1];e:{t:{let Tt;n:{r:if(!(at<wt)){for(let Lt=vt+2;;){if(wt===void 0){if(at<$t)break r;return vt=pt.length,this._cachedIndex=vt,this.copySampleValue_(vt-1)}if(vt===Lt)break;if($t=wt,wt=pt[++vt],at<wt)break t}Tt=pt.length;break n}if(!(at>=$t)){const Lt=pt[1];at<Lt&&(vt=2,$t=Lt);for(let Ft=vt-2;;){if($t===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(vt===Ft)break;if(wt=$t,$t=pt[--vt-1],at>=$t)break t}Tt=vt,vt=0;break n}break e}for(;vt<Tt;){const Lt=vt+Tt>>>1;at<pt[Lt]?Tt=Lt:vt=Lt+1}if(wt=pt[vt],$t=pt[vt-1],$t===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(wt===void 0)return vt=pt.length,this._cachedIndex=vt,this.copySampleValue_(vt-1)}this._cachedIndex=vt,this.intervalChanged_(vt,$t,wt)}return this.interpolate_(vt,$t,at,wt)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(at){const pt=this.resultBuffer,vt=this.sampleValues,wt=this.valueSize,$t=at*wt;for(let Tt=0;Tt!==wt;++Tt)pt[Tt]=vt[$t+Tt];return pt}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class CubicInterpolant extends Interpolant{constructor(at,pt,vt,wt){super(at,pt,vt,wt),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding}}intervalChanged_(at,pt,vt){const wt=this.parameterPositions;let $t=at-2,Tt=at+1,Lt=wt[$t],Ft=wt[Tt];if(Lt===void 0)switch(this.getSettings_().endingStart){case ZeroSlopeEnding:$t=at,Lt=2*pt-vt;break;case WrapAroundEnding:$t=wt.length-2,Lt=pt+wt[$t]-wt[$t+1];break;default:$t=at,Lt=vt}if(Ft===void 0)switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:Tt=at,Ft=2*vt-pt;break;case WrapAroundEnding:Tt=1,Ft=vt+wt[1]-wt[0];break;default:Tt=at-1,Ft=pt}const Ct=(vt-pt)*.5,Ht=this.valueSize;this._weightPrev=Ct/(pt-Lt),this._weightNext=Ct/(Ft-vt),this._offsetPrev=$t*Ht,this._offsetNext=Tt*Ht}interpolate_(at,pt,vt,wt){const $t=this.resultBuffer,Tt=this.sampleValues,Lt=this.valueSize,Ft=at*Lt,Ct=Ft-Lt,Ht=this._offsetPrev,Gt=this._offsetNext,jt=this._weightPrev,qt=this._weightNext,Kt=(vt-pt)/(wt-pt),An=Kt*Kt,Sn=An*Kt,wn=-jt*Sn+2*jt*An-jt*Kt,In=(1+jt)*Sn+(-1.5-2*jt)*An+(-.5+jt)*Kt+1,tr=(-1-qt)*Sn+(1.5+qt)*An+.5*Kt,rr=qt*Sn-qt*An;for(let Hr=0;Hr!==Lt;++Hr)$t[Hr]=wn*Tt[Ht+Hr]+In*Tt[Ct+Hr]+tr*Tt[Ft+Hr]+rr*Tt[Gt+Hr];return $t}}class LinearInterpolant extends Interpolant{constructor(at,pt,vt,wt){super(at,pt,vt,wt)}interpolate_(at,pt,vt,wt){const $t=this.resultBuffer,Tt=this.sampleValues,Lt=this.valueSize,Ft=at*Lt,Ct=Ft-Lt,Ht=(vt-pt)/(wt-pt),Gt=1-Ht;for(let jt=0;jt!==Lt;++jt)$t[jt]=Tt[Ct+jt]*Gt+Tt[Ft+jt]*Ht;return $t}}class DiscreteInterpolant extends Interpolant{constructor(at,pt,vt,wt){super(at,pt,vt,wt)}interpolate_(at){return this.copySampleValue_(at-1)}}class KeyframeTrack{constructor(at,pt,vt,wt){if(at===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(pt===void 0||pt.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+at);this.name=at,this.times=convertArray(pt,this.TimeBufferType),this.values=convertArray(vt,this.ValueBufferType),this.setInterpolation(wt||this.DefaultInterpolation)}static toJSON(at){const pt=at.constructor;let vt;if(pt.toJSON!==this.toJSON)vt=pt.toJSON(at);else{vt={name:at.name,times:convertArray(at.times,Array),values:convertArray(at.values,Array)};const wt=at.getInterpolation();wt!==at.DefaultInterpolation&&(vt.interpolation=wt)}return vt.type=at.ValueTypeName,vt}InterpolantFactoryMethodDiscrete(at){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),at)}InterpolantFactoryMethodLinear(at){return new LinearInterpolant(this.times,this.values,this.getValueSize(),at)}InterpolantFactoryMethodSmooth(at){return new CubicInterpolant(this.times,this.values,this.getValueSize(),at)}setInterpolation(at){let pt;switch(at){case InterpolateDiscrete:pt=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:pt=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:pt=this.InterpolantFactoryMethodSmooth;break}if(pt===void 0){const vt="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(at!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(vt);return console.warn("THREE.KeyframeTrack:",vt),this}return this.createInterpolant=pt,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth}}getValueSize(){return this.values.length/this.times.length}shift(at){if(at!==0){const pt=this.times;for(let vt=0,wt=pt.length;vt!==wt;++vt)pt[vt]+=at}return this}scale(at){if(at!==1){const pt=this.times;for(let vt=0,wt=pt.length;vt!==wt;++vt)pt[vt]*=at}return this}trim(at,pt){const vt=this.times,wt=vt.length;let $t=0,Tt=wt-1;for(;$t!==wt&&vt[$t]<at;)++$t;for(;Tt!==-1&&vt[Tt]>pt;)--Tt;if(++Tt,$t!==0||Tt!==wt){$t>=Tt&&(Tt=Math.max(Tt,1),$t=Tt-1);const Lt=this.getValueSize();this.times=vt.slice($t,Tt),this.values=this.values.slice($t*Lt,Tt*Lt)}return this}validate(){let at=!0;const pt=this.getValueSize();pt-Math.floor(pt)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),at=!1);const vt=this.times,wt=this.values,$t=vt.length;$t===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),at=!1);let Tt=null;for(let Lt=0;Lt!==$t;Lt++){const Ft=vt[Lt];if(typeof Ft=="number"&&isNaN(Ft)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,Lt,Ft),at=!1;break}if(Tt!==null&&Tt>Ft){console.error("THREE.KeyframeTrack: Out of order keys.",this,Lt,Ft,Tt),at=!1;break}Tt=Ft}if(wt!==void 0&&isTypedArray(wt))for(let Lt=0,Ft=wt.length;Lt!==Ft;++Lt){const Ct=wt[Lt];if(isNaN(Ct)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,Lt,Ct),at=!1;break}}return at}optimize(){const at=this.times.slice(),pt=this.values.slice(),vt=this.getValueSize(),wt=this.getInterpolation()===InterpolateSmooth,$t=at.length-1;let Tt=1;for(let Lt=1;Lt<$t;++Lt){let Ft=!1;const Ct=at[Lt],Ht=at[Lt+1];if(Ct!==Ht&&(Lt!==1||Ct!==at[0]))if(wt)Ft=!0;else{const Gt=Lt*vt,jt=Gt-vt,qt=Gt+vt;for(let Kt=0;Kt!==vt;++Kt){const An=pt[Gt+Kt];if(An!==pt[jt+Kt]||An!==pt[qt+Kt]){Ft=!0;break}}}if(Ft){if(Lt!==Tt){at[Tt]=at[Lt];const Gt=Lt*vt,jt=Tt*vt;for(let qt=0;qt!==vt;++qt)pt[jt+qt]=pt[Gt+qt]}++Tt}}if($t>0){at[Tt]=at[$t];for(let Lt=$t*vt,Ft=Tt*vt,Ct=0;Ct!==vt;++Ct)pt[Ft+Ct]=pt[Lt+Ct];++Tt}return Tt!==at.length?(this.times=at.slice(0,Tt),this.values=pt.slice(0,Tt*vt)):(this.times=at,this.values=pt),this}clone(){const at=this.times.slice(),pt=this.values.slice(),vt=this.constructor,wt=new vt(this.name,at,pt);return wt.createInterpolant=this.createInterpolant,wt}}KeyframeTrack.prototype.TimeBufferType=Float32Array;KeyframeTrack.prototype.ValueBufferType=Float32Array;KeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;class BooleanKeyframeTrack extends KeyframeTrack{}BooleanKeyframeTrack.prototype.ValueTypeName="bool";BooleanKeyframeTrack.prototype.ValueBufferType=Array;BooleanKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class ColorKeyframeTrack extends KeyframeTrack{}ColorKeyframeTrack.prototype.ValueTypeName="color";class NumberKeyframeTrack extends KeyframeTrack{}NumberKeyframeTrack.prototype.ValueTypeName="number";class QuaternionLinearInterpolant extends Interpolant{constructor(at,pt,vt,wt){super(at,pt,vt,wt)}interpolate_(at,pt,vt,wt){const $t=this.resultBuffer,Tt=this.sampleValues,Lt=this.valueSize,Ft=(vt-pt)/(wt-pt);let Ct=at*Lt;for(let Ht=Ct+Lt;Ct!==Ht;Ct+=4)Quaternion.slerpFlat($t,0,Tt,Ct-Lt,Tt,Ct,Ft);return $t}}class QuaternionKeyframeTrack extends KeyframeTrack{InterpolantFactoryMethodLinear(at){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),at)}}QuaternionKeyframeTrack.prototype.ValueTypeName="quaternion";QuaternionKeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class StringKeyframeTrack extends KeyframeTrack{}StringKeyframeTrack.prototype.ValueTypeName="string";StringKeyframeTrack.prototype.ValueBufferType=Array;StringKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class VectorKeyframeTrack extends KeyframeTrack{}VectorKeyframeTrack.prototype.ValueTypeName="vector";class AnimationClip{constructor(at,pt=-1,vt,wt=NormalAnimationBlendMode){this.name=at,this.tracks=vt,this.duration=pt,this.blendMode=wt,this.uuid=generateUUID(),this.duration<0&&this.resetDuration()}static parse(at){const pt=[],vt=at.tracks,wt=1/(at.fps||1);for(let Tt=0,Lt=vt.length;Tt!==Lt;++Tt)pt.push(parseKeyframeTrack(vt[Tt]).scale(wt));const $t=new this(at.name,at.duration,pt,at.blendMode);return $t.uuid=at.uuid,$t}static toJSON(at){const pt=[],vt=at.tracks,wt={name:at.name,duration:at.duration,tracks:pt,uuid:at.uuid,blendMode:at.blendMode};for(let $t=0,Tt=vt.length;$t!==Tt;++$t)pt.push(KeyframeTrack.toJSON(vt[$t]));return wt}static CreateFromMorphTargetSequence(at,pt,vt,wt){const $t=pt.length,Tt=[];for(let Lt=0;Lt<$t;Lt++){let Ft=[],Ct=[];Ft.push((Lt+$t-1)%$t,Lt,(Lt+1)%$t),Ct.push(0,1,0);const Ht=getKeyframeOrder(Ft);Ft=sortedArray(Ft,1,Ht),Ct=sortedArray(Ct,1,Ht),!wt&&Ft[0]===0&&(Ft.push($t),Ct.push(Ct[0])),Tt.push(new NumberKeyframeTrack(".morphTargetInfluences["+pt[Lt].name+"]",Ft,Ct).scale(1/vt))}return new this(at,-1,Tt)}static findByName(at,pt){let vt=at;if(!Array.isArray(at)){const wt=at;vt=wt.geometry&&wt.geometry.animations||wt.animations}for(let wt=0;wt<vt.length;wt++)if(vt[wt].name===pt)return vt[wt];return null}static CreateClipsFromMorphTargetSequences(at,pt,vt){const wt={},$t=/^([\w-]*?)([\d]+)$/;for(let Lt=0,Ft=at.length;Lt<Ft;Lt++){const Ct=at[Lt],Ht=Ct.name.match($t);if(Ht&&Ht.length>1){const Gt=Ht[1];let jt=wt[Gt];jt||(wt[Gt]=jt=[]),jt.push(Ct)}}const Tt=[];for(const Lt in wt)Tt.push(this.CreateFromMorphTargetSequence(Lt,wt[Lt],pt,vt));return Tt}static parseAnimation(at,pt){if(!at)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const vt=function(Gt,jt,qt,Kt,An){if(qt.length!==0){const Sn=[],wn=[];flattenJSON(qt,Sn,wn,Kt),Sn.length!==0&&An.push(new Gt(jt,Sn,wn))}},wt=[],$t=at.name||"default",Tt=at.fps||30,Lt=at.blendMode;let Ft=at.length||-1;const Ct=at.hierarchy||[];for(let Gt=0;Gt<Ct.length;Gt++){const jt=Ct[Gt].keys;if(!(!jt||jt.length===0))if(jt[0].morphTargets){const qt={};let Kt;for(Kt=0;Kt<jt.length;Kt++)if(jt[Kt].morphTargets)for(let An=0;An<jt[Kt].morphTargets.length;An++)qt[jt[Kt].morphTargets[An]]=-1;for(const An in qt){const Sn=[],wn=[];for(let In=0;In!==jt[Kt].morphTargets.length;++In){const tr=jt[Kt];Sn.push(tr.time),wn.push(tr.morphTarget===An?1:0)}wt.push(new NumberKeyframeTrack(".morphTargetInfluence["+An+"]",Sn,wn))}Ft=qt.length*Tt}else{const qt=".bones["+pt[Gt].name+"]";vt(VectorKeyframeTrack,qt+".position",jt,"pos",wt),vt(QuaternionKeyframeTrack,qt+".quaternion",jt,"rot",wt),vt(VectorKeyframeTrack,qt+".scale",jt,"scl",wt)}}return wt.length===0?null:new this($t,Ft,wt,Lt)}resetDuration(){const at=this.tracks;let pt=0;for(let vt=0,wt=at.length;vt!==wt;++vt){const $t=this.tracks[vt];pt=Math.max(pt,$t.times[$t.times.length-1])}return this.duration=pt,this}trim(){for(let at=0;at<this.tracks.length;at++)this.tracks[at].trim(0,this.duration);return this}validate(){let at=!0;for(let pt=0;pt<this.tracks.length;pt++)at=at&&this.tracks[pt].validate();return at}optimize(){for(let at=0;at<this.tracks.length;at++)this.tracks[at].optimize();return this}clone(){const at=[];for(let pt=0;pt<this.tracks.length;pt++)at.push(this.tracks[pt].clone());return new this.constructor(this.name,this.duration,at,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function getTrackTypeForValueTypeName(st){switch(st.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+st)}function parseKeyframeTrack(st){if(st.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const at=getTrackTypeForValueTypeName(st.type);if(st.times===void 0){const pt=[],vt=[];flattenJSON(st.keys,pt,vt,"value"),st.times=pt,st.values=vt}return at.parse!==void 0?at.parse(st):new at(st.name,st.times,st.values,st.interpolation)}const Cache={enabled:!1,files:{},add:function(st,at){this.enabled!==!1&&(this.files[st]=at)},get:function(st){if(this.enabled!==!1)return this.files[st]},remove:function(st){delete this.files[st]},clear:function(){this.files={}}};class LoadingManager{constructor(at,pt,vt){const wt=this;let $t=!1,Tt=0,Lt=0,Ft;const Ct=[];this.onStart=void 0,this.onLoad=at,this.onProgress=pt,this.onError=vt,this.itemStart=function(Ht){Lt++,$t===!1&&wt.onStart!==void 0&&wt.onStart(Ht,Tt,Lt),$t=!0},this.itemEnd=function(Ht){Tt++,wt.onProgress!==void 0&&wt.onProgress(Ht,Tt,Lt),Tt===Lt&&($t=!1,wt.onLoad!==void 0&&wt.onLoad())},this.itemError=function(Ht){wt.onError!==void 0&&wt.onError(Ht)},this.resolveURL=function(Ht){return Ft?Ft(Ht):Ht},this.setURLModifier=function(Ht){return Ft=Ht,this},this.addHandler=function(Ht,Gt){return Ct.push(Ht,Gt),this},this.removeHandler=function(Ht){const Gt=Ct.indexOf(Ht);return Gt!==-1&&Ct.splice(Gt,2),this},this.getHandler=function(Ht){for(let Gt=0,jt=Ct.length;Gt<jt;Gt+=2){const qt=Ct[Gt],Kt=Ct[Gt+1];if(qt.global&&(qt.lastIndex=0),qt.test(Ht))return Kt}return null}}}const DefaultLoadingManager=new LoadingManager;class Loader{constructor(at){this.manager=at!==void 0?at:DefaultLoadingManager,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(at,pt){const vt=this;return new Promise(function(wt,$t){vt.load(at,wt,pt,$t)})}parse(){}setCrossOrigin(at){return this.crossOrigin=at,this}setWithCredentials(at){return this.withCredentials=at,this}setPath(at){return this.path=at,this}setResourcePath(at){return this.resourcePath=at,this}setRequestHeader(at){return this.requestHeader=at,this}}Loader.DEFAULT_MATERIAL_NAME="__DEFAULT";const loading={};class HttpError extends Error{constructor(at,pt){super(at),this.response=pt}}class FileLoader extends Loader{constructor(at){super(at)}load(at,pt,vt,wt){at===void 0&&(at=""),this.path!==void 0&&(at=this.path+at),at=this.manager.resolveURL(at);const $t=Cache.get(at);if($t!==void 0)return this.manager.itemStart(at),setTimeout(()=>{pt&&pt($t),this.manager.itemEnd(at)},0),$t;if(loading[at]!==void 0){loading[at].push({onLoad:pt,onProgress:vt,onError:wt});return}loading[at]=[],loading[at].push({onLoad:pt,onProgress:vt,onError:wt});const Tt=new Request(at,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),Lt=this.mimeType,Ft=this.responseType;fetch(Tt).then(Ct=>{if(Ct.status===200||Ct.status===0){if(Ct.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||Ct.body===void 0||Ct.body.getReader===void 0)return Ct;const Ht=loading[at],Gt=Ct.body.getReader(),jt=Ct.headers.get("Content-Length")||Ct.headers.get("X-File-Size"),qt=jt?parseInt(jt):0,Kt=qt!==0;let An=0;const Sn=new ReadableStream({start(wn){In();function In(){Gt.read().then(({done:tr,value:rr})=>{if(tr)wn.close();else{An+=rr.byteLength;const Hr=new ProgressEvent("progress",{lengthComputable:Kt,loaded:An,total:qt});for(let qr=0,Zr=Ht.length;qr<Zr;qr++){const Bo=Ht[qr];Bo.onProgress&&Bo.onProgress(Hr)}wn.enqueue(rr),In()}})}}});return new Response(Sn)}else throw new HttpError(`fetch for "${Ct.url}" responded with ${Ct.status}: ${Ct.statusText}`,Ct)}).then(Ct=>{switch(Ft){case"arraybuffer":return Ct.arrayBuffer();case"blob":return Ct.blob();case"document":return Ct.text().then(Ht=>new DOMParser().parseFromString(Ht,Lt));case"json":return Ct.json();default:if(Lt===void 0)return Ct.text();{const Gt=/charset="?([^;"\s]*)"?/i.exec(Lt),jt=Gt&&Gt[1]?Gt[1].toLowerCase():void 0,qt=new TextDecoder(jt);return Ct.arrayBuffer().then(Kt=>qt.decode(Kt))}}}).then(Ct=>{Cache.add(at,Ct);const Ht=loading[at];delete loading[at];for(let Gt=0,jt=Ht.length;Gt<jt;Gt++){const qt=Ht[Gt];qt.onLoad&&qt.onLoad(Ct)}}).catch(Ct=>{const Ht=loading[at];if(Ht===void 0)throw this.manager.itemError(at),Ct;delete loading[at];for(let Gt=0,jt=Ht.length;Gt<jt;Gt++){const qt=Ht[Gt];qt.onError&&qt.onError(Ct)}this.manager.itemError(at)}).finally(()=>{this.manager.itemEnd(at)}),this.manager.itemStart(at)}setResponseType(at){return this.responseType=at,this}setMimeType(at){return this.mimeType=at,this}}class AnimationLoader extends Loader{constructor(at){super(at)}load(at,pt,vt,wt){const $t=this,Tt=new FileLoader(this.manager);Tt.setPath(this.path),Tt.setRequestHeader(this.requestHeader),Tt.setWithCredentials(this.withCredentials),Tt.load(at,function(Lt){try{pt($t.parse(JSON.parse(Lt)))}catch(Ft){wt?wt(Ft):console.error(Ft),$t.manager.itemError(at)}},vt,wt)}parse(at){const pt=[];for(let vt=0;vt<at.length;vt++){const wt=AnimationClip.parse(at[vt]);pt.push(wt)}return pt}}class CompressedTextureLoader extends Loader{constructor(at){super(at)}load(at,pt,vt,wt){const $t=this,Tt=[],Lt=new CompressedTexture,Ft=new FileLoader(this.manager);Ft.setPath(this.path),Ft.setResponseType("arraybuffer"),Ft.setRequestHeader(this.requestHeader),Ft.setWithCredentials($t.withCredentials);let Ct=0;function Ht(Gt){Ft.load(at[Gt],function(jt){const qt=$t.parse(jt,!0);Tt[Gt]={width:qt.width,height:qt.height,format:qt.format,mipmaps:qt.mipmaps},Ct+=1,Ct===6&&(qt.mipmapCount===1&&(Lt.minFilter=LinearFilter),Lt.image=Tt,Lt.format=qt.format,Lt.needsUpdate=!0,pt&&pt(Lt))},vt,wt)}if(Array.isArray(at))for(let Gt=0,jt=at.length;Gt<jt;++Gt)Ht(Gt);else Ft.load(at,function(Gt){const jt=$t.parse(Gt,!0);if(jt.isCubemap){const qt=jt.mipmaps.length/jt.mipmapCount;for(let Kt=0;Kt<qt;Kt++){Tt[Kt]={mipmaps:[]};for(let An=0;An<jt.mipmapCount;An++)Tt[Kt].mipmaps.push(jt.mipmaps[Kt*jt.mipmapCount+An]),Tt[Kt].format=jt.format,Tt[Kt].width=jt.width,Tt[Kt].height=jt.height}Lt.image=Tt}else Lt.image.width=jt.width,Lt.image.height=jt.height,Lt.mipmaps=jt.mipmaps;jt.mipmapCount===1&&(Lt.minFilter=LinearFilter),Lt.format=jt.format,Lt.needsUpdate=!0,pt&&pt(Lt)},vt,wt);return Lt}}class ImageLoader extends Loader{constructor(at){super(at)}load(at,pt,vt,wt){this.path!==void 0&&(at=this.path+at),at=this.manager.resolveURL(at);const $t=this,Tt=Cache.get(at);if(Tt!==void 0)return $t.manager.itemStart(at),setTimeout(function(){pt&&pt(Tt),$t.manager.itemEnd(at)},0),Tt;const Lt=createElementNS("img");function Ft(){Ht(),Cache.add(at,this),pt&&pt(this),$t.manager.itemEnd(at)}function Ct(Gt){Ht(),wt&&wt(Gt),$t.manager.itemError(at),$t.manager.itemEnd(at)}function Ht(){Lt.removeEventListener("load",Ft,!1),Lt.removeEventListener("error",Ct,!1)}return Lt.addEventListener("load",Ft,!1),Lt.addEventListener("error",Ct,!1),at.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(Lt.crossOrigin=this.crossOrigin),$t.manager.itemStart(at),Lt.src=at,Lt}}class CubeTextureLoader extends Loader{constructor(at){super(at)}load(at,pt,vt,wt){const $t=new CubeTexture;$t.colorSpace=SRGBColorSpace$1;const Tt=new ImageLoader(this.manager);Tt.setCrossOrigin(this.crossOrigin),Tt.setPath(this.path);let Lt=0;function Ft(Ct){Tt.load(at[Ct],function(Ht){$t.images[Ct]=Ht,Lt++,Lt===6&&($t.needsUpdate=!0,pt&&pt($t))},void 0,wt)}for(let Ct=0;Ct<at.length;++Ct)Ft(Ct);return $t}}class DataTextureLoader extends Loader{constructor(at){super(at)}load(at,pt,vt,wt){const $t=this,Tt=new DataTexture,Lt=new FileLoader(this.manager);return Lt.setResponseType("arraybuffer"),Lt.setRequestHeader(this.requestHeader),Lt.setPath(this.path),Lt.setWithCredentials($t.withCredentials),Lt.load(at,function(Ft){let Ct;try{Ct=$t.parse(Ft)}catch(Ht){if(wt!==void 0)wt(Ht);else{console.error(Ht);return}}Ct.image!==void 0?Tt.image=Ct.image:Ct.data!==void 0&&(Tt.image.width=Ct.width,Tt.image.height=Ct.height,Tt.image.data=Ct.data),Tt.wrapS=Ct.wrapS!==void 0?Ct.wrapS:ClampToEdgeWrapping,Tt.wrapT=Ct.wrapT!==void 0?Ct.wrapT:ClampToEdgeWrapping,Tt.magFilter=Ct.magFilter!==void 0?Ct.magFilter:LinearFilter,Tt.minFilter=Ct.minFilter!==void 0?Ct.minFilter:LinearFilter,Tt.anisotropy=Ct.anisotropy!==void 0?Ct.anisotropy:1,Ct.colorSpace!==void 0&&(Tt.colorSpace=Ct.colorSpace),Ct.flipY!==void 0&&(Tt.flipY=Ct.flipY),Ct.format!==void 0&&(Tt.format=Ct.format),Ct.type!==void 0&&(Tt.type=Ct.type),Ct.mipmaps!==void 0&&(Tt.mipmaps=Ct.mipmaps,Tt.minFilter=LinearMipmapLinearFilter),Ct.mipmapCount===1&&(Tt.minFilter=LinearFilter),Ct.generateMipmaps!==void 0&&(Tt.generateMipmaps=Ct.generateMipmaps),Tt.needsUpdate=!0,pt&&pt(Tt,Ct)},vt,wt),Tt}}class TextureLoader extends Loader{constructor(at){super(at)}load(at,pt,vt,wt){const $t=new Texture,Tt=new ImageLoader(this.manager);return Tt.setCrossOrigin(this.crossOrigin),Tt.setPath(this.path),Tt.load(at,function(Lt){$t.image=Lt,$t.needsUpdate=!0,pt!==void 0&&pt($t)},vt,wt),$t}}class Light extends Object3D{constructor(at,pt=1){super(),this.isLight=!0,this.type="Light",this.color=new Color$1(at),this.intensity=pt}dispose(){}copy(at,pt){return super.copy(at,pt),this.color.copy(at.color),this.intensity=at.intensity,this}toJSON(at){const pt=super.toJSON(at);return pt.object.color=this.color.getHex(),pt.object.intensity=this.intensity,this.groundColor!==void 0&&(pt.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(pt.object.distance=this.distance),this.angle!==void 0&&(pt.object.angle=this.angle),this.decay!==void 0&&(pt.object.decay=this.decay),this.penumbra!==void 0&&(pt.object.penumbra=this.penumbra),this.shadow!==void 0&&(pt.object.shadow=this.shadow.toJSON()),pt}}class HemisphereLight extends Light{constructor(at,pt,vt){super(at,vt),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Color$1(pt)}copy(at,pt){return super.copy(at,pt),this.groundColor.copy(at.groundColor),this}}const _projScreenMatrix$1=new Matrix4,_lightPositionWorld$1=new Vector3,_lookTarget$1=new Vector3;class LightShadow{constructor(at){this.camera=at,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Vector2(512,512),this.map=null,this.mapPass=null,this.matrix=new Matrix4,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Frustum,this._frameExtents=new Vector2(1,1),this._viewportCount=1,this._viewports=[new Vector4(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(at){const pt=this.camera,vt=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(at.matrixWorld),pt.position.copy(_lightPositionWorld$1),_lookTarget$1.setFromMatrixPosition(at.target.matrixWorld),pt.lookAt(_lookTarget$1),pt.updateMatrixWorld(),_projScreenMatrix$1.multiplyMatrices(pt.projectionMatrix,pt.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix$1),vt.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),vt.multiply(_projScreenMatrix$1)}getViewport(at){return this._viewports[at]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(at){return this.camera=at.camera.clone(),this.bias=at.bias,this.radius=at.radius,this.mapSize.copy(at.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const at={};return this.bias!==0&&(at.bias=this.bias),this.normalBias!==0&&(at.normalBias=this.normalBias),this.radius!==1&&(at.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(at.mapSize=this.mapSize.toArray()),at.camera=this.camera.toJSON(!1).object,delete at.camera.matrix,at}}class SpotLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(at){const pt=this.camera,vt=RAD2DEG*2*at.angle*this.focus,wt=this.mapSize.width/this.mapSize.height,$t=at.distance||pt.far;(vt!==pt.fov||wt!==pt.aspect||$t!==pt.far)&&(pt.fov=vt,pt.aspect=wt,pt.far=$t,pt.updateProjectionMatrix()),super.updateMatrices(at)}copy(at){return super.copy(at),this.focus=at.focus,this}}class SpotLight extends Light{constructor(at,pt,vt=0,wt=Math.PI/3,$t=0,Tt=2){super(at,pt),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.distance=vt,this.angle=wt,this.penumbra=$t,this.decay=Tt,this.map=null,this.shadow=new SpotLightShadow}get power(){return this.intensity*Math.PI}set power(at){this.intensity=at/Math.PI}dispose(){this.shadow.dispose()}copy(at,pt){return super.copy(at,pt),this.distance=at.distance,this.angle=at.angle,this.penumbra=at.penumbra,this.decay=at.decay,this.target=at.target.clone(),this.shadow=at.shadow.clone(),this}}const _projScreenMatrix=new Matrix4,_lightPositionWorld=new Vector3,_lookTarget=new Vector3;class PointLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Vector2(4,2),this._viewportCount=6,this._viewports=[new Vector4(2,1,1,1),new Vector4(0,1,1,1),new Vector4(3,1,1,1),new Vector4(1,1,1,1),new Vector4(3,0,1,1),new Vector4(1,0,1,1)],this._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)],this._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)]}updateMatrices(at,pt=0){const vt=this.camera,wt=this.matrix,$t=at.distance||vt.far;$t!==vt.far&&(vt.far=$t,vt.updateProjectionMatrix()),_lightPositionWorld.setFromMatrixPosition(at.matrixWorld),vt.position.copy(_lightPositionWorld),_lookTarget.copy(vt.position),_lookTarget.add(this._cubeDirections[pt]),vt.up.copy(this._cubeUps[pt]),vt.lookAt(_lookTarget),vt.updateMatrixWorld(),wt.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z),_projScreenMatrix.multiplyMatrices(vt.projectionMatrix,vt.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix)}}class PointLight extends Light{constructor(at,pt,vt=0,wt=2){super(at,pt),this.isPointLight=!0,this.type="PointLight",this.distance=vt,this.decay=wt,this.shadow=new PointLightShadow}get power(){return this.intensity*4*Math.PI}set power(at){this.intensity=at/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(at,pt){return super.copy(at,pt),this.distance=at.distance,this.decay=at.decay,this.shadow=at.shadow.clone(),this}}class DirectionalLightShadow extends LightShadow{constructor(){super(new OrthographicCamera(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class DirectionalLight extends Light{constructor(at,pt){super(at,pt),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.shadow=new DirectionalLightShadow}dispose(){this.shadow.dispose()}copy(at){return super.copy(at),this.target=at.target.clone(),this.shadow=at.shadow.clone(),this}}class AmbientLight extends Light{constructor(at,pt){super(at,pt),this.isAmbientLight=!0,this.type="AmbientLight"}}class RectAreaLight extends Light{constructor(at,pt,vt=10,wt=10){super(at,pt),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=vt,this.height=wt}get power(){return this.intensity*this.width*this.height*Math.PI}set power(at){this.intensity=at/(this.width*this.height*Math.PI)}copy(at){return super.copy(at),this.width=at.width,this.height=at.height,this}toJSON(at){const pt=super.toJSON(at);return pt.object.width=this.width,pt.object.height=this.height,pt}}class SphericalHarmonics3{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let at=0;at<9;at++)this.coefficients.push(new Vector3)}set(at){for(let pt=0;pt<9;pt++)this.coefficients[pt].copy(at[pt]);return this}zero(){for(let at=0;at<9;at++)this.coefficients[at].set(0,0,0);return this}getAt(at,pt){const vt=at.x,wt=at.y,$t=at.z,Tt=this.coefficients;return pt.copy(Tt[0]).multiplyScalar(.282095),pt.addScaledVector(Tt[1],.488603*wt),pt.addScaledVector(Tt[2],.488603*$t),pt.addScaledVector(Tt[3],.488603*vt),pt.addScaledVector(Tt[4],1.092548*(vt*wt)),pt.addScaledVector(Tt[5],1.092548*(wt*$t)),pt.addScaledVector(Tt[6],.315392*(3*$t*$t-1)),pt.addScaledVector(Tt[7],1.092548*(vt*$t)),pt.addScaledVector(Tt[8],.546274*(vt*vt-wt*wt)),pt}getIrradianceAt(at,pt){const vt=at.x,wt=at.y,$t=at.z,Tt=this.coefficients;return pt.copy(Tt[0]).multiplyScalar(.886227),pt.addScaledVector(Tt[1],2*.511664*wt),pt.addScaledVector(Tt[2],2*.511664*$t),pt.addScaledVector(Tt[3],2*.511664*vt),pt.addScaledVector(Tt[4],2*.429043*vt*wt),pt.addScaledVector(Tt[5],2*.429043*wt*$t),pt.addScaledVector(Tt[6],.743125*$t*$t-.247708),pt.addScaledVector(Tt[7],2*.429043*vt*$t),pt.addScaledVector(Tt[8],.429043*(vt*vt-wt*wt)),pt}add(at){for(let pt=0;pt<9;pt++)this.coefficients[pt].add(at.coefficients[pt]);return this}addScaledSH(at,pt){for(let vt=0;vt<9;vt++)this.coefficients[vt].addScaledVector(at.coefficients[vt],pt);return this}scale(at){for(let pt=0;pt<9;pt++)this.coefficients[pt].multiplyScalar(at);return this}lerp(at,pt){for(let vt=0;vt<9;vt++)this.coefficients[vt].lerp(at.coefficients[vt],pt);return this}equals(at){for(let pt=0;pt<9;pt++)if(!this.coefficients[pt].equals(at.coefficients[pt]))return!1;return!0}copy(at){return this.set(at.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(at,pt=0){const vt=this.coefficients;for(let wt=0;wt<9;wt++)vt[wt].fromArray(at,pt+wt*3);return this}toArray(at=[],pt=0){const vt=this.coefficients;for(let wt=0;wt<9;wt++)vt[wt].toArray(at,pt+wt*3);return at}static getBasisAt(at,pt){const vt=at.x,wt=at.y,$t=at.z;pt[0]=.282095,pt[1]=.488603*wt,pt[2]=.488603*$t,pt[3]=.488603*vt,pt[4]=1.092548*vt*wt,pt[5]=1.092548*wt*$t,pt[6]=.315392*(3*$t*$t-1),pt[7]=1.092548*vt*$t,pt[8]=.546274*(vt*vt-wt*wt)}}class LightProbe extends Light{constructor(at=new SphericalHarmonics3,pt=1){super(void 0,pt),this.isLightProbe=!0,this.sh=at}copy(at){return super.copy(at),this.sh.copy(at.sh),this}fromJSON(at){return this.intensity=at.intensity,this.sh.fromArray(at.sh),this}toJSON(at){const pt=super.toJSON(at);return pt.object.sh=this.sh.toArray(),pt}}class MaterialLoader extends Loader{constructor(at){super(at),this.textures={}}load(at,pt,vt,wt){const $t=this,Tt=new FileLoader($t.manager);Tt.setPath($t.path),Tt.setRequestHeader($t.requestHeader),Tt.setWithCredentials($t.withCredentials),Tt.load(at,function(Lt){try{pt($t.parse(JSON.parse(Lt)))}catch(Ft){wt?wt(Ft):console.error(Ft),$t.manager.itemError(at)}},vt,wt)}parse(at){const pt=this.textures;function vt($t){return pt[$t]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",$t),pt[$t]}const wt=MaterialLoader.createMaterialFromType(at.type);if(at.uuid!==void 0&&(wt.uuid=at.uuid),at.name!==void 0&&(wt.name=at.name),at.color!==void 0&&wt.color!==void 0&&wt.color.setHex(at.color),at.roughness!==void 0&&(wt.roughness=at.roughness),at.metalness!==void 0&&(wt.metalness=at.metalness),at.sheen!==void 0&&(wt.sheen=at.sheen),at.sheenColor!==void 0&&(wt.sheenColor=new Color$1().setHex(at.sheenColor)),at.sheenRoughness!==void 0&&(wt.sheenRoughness=at.sheenRoughness),at.emissive!==void 0&&wt.emissive!==void 0&&wt.emissive.setHex(at.emissive),at.specular!==void 0&&wt.specular!==void 0&&wt.specular.setHex(at.specular),at.specularIntensity!==void 0&&(wt.specularIntensity=at.specularIntensity),at.specularColor!==void 0&&wt.specularColor!==void 0&&wt.specularColor.setHex(at.specularColor),at.shininess!==void 0&&(wt.shininess=at.shininess),at.clearcoat!==void 0&&(wt.clearcoat=at.clearcoat),at.clearcoatRoughness!==void 0&&(wt.clearcoatRoughness=at.clearcoatRoughness),at.iridescence!==void 0&&(wt.iridescence=at.iridescence),at.iridescenceIOR!==void 0&&(wt.iridescenceIOR=at.iridescenceIOR),at.iridescenceThicknessRange!==void 0&&(wt.iridescenceThicknessRange=at.iridescenceThicknessRange),at.transmission!==void 0&&(wt.transmission=at.transmission),at.thickness!==void 0&&(wt.thickness=at.thickness),at.attenuationDistance!==void 0&&(wt.attenuationDistance=at.attenuationDistance),at.attenuationColor!==void 0&&wt.attenuationColor!==void 0&&wt.attenuationColor.setHex(at.attenuationColor),at.anisotropy!==void 0&&(wt.anisotropy=at.anisotropy),at.anisotropyRotation!==void 0&&(wt.anisotropyRotation=at.anisotropyRotation),at.fog!==void 0&&(wt.fog=at.fog),at.flatShading!==void 0&&(wt.flatShading=at.flatShading),at.blending!==void 0&&(wt.blending=at.blending),at.combine!==void 0&&(wt.combine=at.combine),at.side!==void 0&&(wt.side=at.side),at.shadowSide!==void 0&&(wt.shadowSide=at.shadowSide),at.opacity!==void 0&&(wt.opacity=at.opacity),at.transparent!==void 0&&(wt.transparent=at.transparent),at.alphaTest!==void 0&&(wt.alphaTest=at.alphaTest),at.alphaHash!==void 0&&(wt.alphaHash=at.alphaHash),at.depthFunc!==void 0&&(wt.depthFunc=at.depthFunc),at.depthTest!==void 0&&(wt.depthTest=at.depthTest),at.depthWrite!==void 0&&(wt.depthWrite=at.depthWrite),at.colorWrite!==void 0&&(wt.colorWrite=at.colorWrite),at.blendSrc!==void 0&&(wt.blendSrc=at.blendSrc),at.blendDst!==void 0&&(wt.blendDst=at.blendDst),at.blendEquation!==void 0&&(wt.blendEquation=at.blendEquation),at.blendSrcAlpha!==void 0&&(wt.blendSrcAlpha=at.blendSrcAlpha),at.blendDstAlpha!==void 0&&(wt.blendDstAlpha=at.blendDstAlpha),at.blendEquationAlpha!==void 0&&(wt.blendEquationAlpha=at.blendEquationAlpha),at.blendColor!==void 0&&wt.blendColor!==void 0&&wt.blendColor.setHex(at.blendColor),at.blendAlpha!==void 0&&(wt.blendAlpha=at.blendAlpha),at.stencilWriteMask!==void 0&&(wt.stencilWriteMask=at.stencilWriteMask),at.stencilFunc!==void 0&&(wt.stencilFunc=at.stencilFunc),at.stencilRef!==void 0&&(wt.stencilRef=at.stencilRef),at.stencilFuncMask!==void 0&&(wt.stencilFuncMask=at.stencilFuncMask),at.stencilFail!==void 0&&(wt.stencilFail=at.stencilFail),at.stencilZFail!==void 0&&(wt.stencilZFail=at.stencilZFail),at.stencilZPass!==void 0&&(wt.stencilZPass=at.stencilZPass),at.stencilWrite!==void 0&&(wt.stencilWrite=at.stencilWrite),at.wireframe!==void 0&&(wt.wireframe=at.wireframe),at.wireframeLinewidth!==void 0&&(wt.wireframeLinewidth=at.wireframeLinewidth),at.wireframeLinecap!==void 0&&(wt.wireframeLinecap=at.wireframeLinecap),at.wireframeLinejoin!==void 0&&(wt.wireframeLinejoin=at.wireframeLinejoin),at.rotation!==void 0&&(wt.rotation=at.rotation),at.linewidth!==void 0&&(wt.linewidth=at.linewidth),at.dashSize!==void 0&&(wt.dashSize=at.dashSize),at.gapSize!==void 0&&(wt.gapSize=at.gapSize),at.scale!==void 0&&(wt.scale=at.scale),at.polygonOffset!==void 0&&(wt.polygonOffset=at.polygonOffset),at.polygonOffsetFactor!==void 0&&(wt.polygonOffsetFactor=at.polygonOffsetFactor),at.polygonOffsetUnits!==void 0&&(wt.polygonOffsetUnits=at.polygonOffsetUnits),at.dithering!==void 0&&(wt.dithering=at.dithering),at.alphaToCoverage!==void 0&&(wt.alphaToCoverage=at.alphaToCoverage),at.premultipliedAlpha!==void 0&&(wt.premultipliedAlpha=at.premultipliedAlpha),at.forceSinglePass!==void 0&&(wt.forceSinglePass=at.forceSinglePass),at.visible!==void 0&&(wt.visible=at.visible),at.toneMapped!==void 0&&(wt.toneMapped=at.toneMapped),at.userData!==void 0&&(wt.userData=at.userData),at.vertexColors!==void 0&&(typeof at.vertexColors=="number"?wt.vertexColors=at.vertexColors>0:wt.vertexColors=at.vertexColors),at.uniforms!==void 0)for(const $t in at.uniforms){const Tt=at.uniforms[$t];switch(wt.uniforms[$t]={},Tt.type){case"t":wt.uniforms[$t].value=vt(Tt.value);break;case"c":wt.uniforms[$t].value=new Color$1().setHex(Tt.value);break;case"v2":wt.uniforms[$t].value=new Vector2().fromArray(Tt.value);break;case"v3":wt.uniforms[$t].value=new Vector3().fromArray(Tt.value);break;case"v4":wt.uniforms[$t].value=new Vector4().fromArray(Tt.value);break;case"m3":wt.uniforms[$t].value=new Matrix3().fromArray(Tt.value);break;case"m4":wt.uniforms[$t].value=new Matrix4().fromArray(Tt.value);break;default:wt.uniforms[$t].value=Tt.value}}if(at.defines!==void 0&&(wt.defines=at.defines),at.vertexShader!==void 0&&(wt.vertexShader=at.vertexShader),at.fragmentShader!==void 0&&(wt.fragmentShader=at.fragmentShader),at.glslVersion!==void 0&&(wt.glslVersion=at.glslVersion),at.extensions!==void 0)for(const $t in at.extensions)wt.extensions[$t]=at.extensions[$t];if(at.lights!==void 0&&(wt.lights=at.lights),at.clipping!==void 0&&(wt.clipping=at.clipping),at.size!==void 0&&(wt.size=at.size),at.sizeAttenuation!==void 0&&(wt.sizeAttenuation=at.sizeAttenuation),at.map!==void 0&&(wt.map=vt(at.map)),at.matcap!==void 0&&(wt.matcap=vt(at.matcap)),at.alphaMap!==void 0&&(wt.alphaMap=vt(at.alphaMap)),at.bumpMap!==void 0&&(wt.bumpMap=vt(at.bumpMap)),at.bumpScale!==void 0&&(wt.bumpScale=at.bumpScale),at.normalMap!==void 0&&(wt.normalMap=vt(at.normalMap)),at.normalMapType!==void 0&&(wt.normalMapType=at.normalMapType),at.normalScale!==void 0){let $t=at.normalScale;Array.isArray($t)===!1&&($t=[$t,$t]),wt.normalScale=new Vector2().fromArray($t)}return at.displacementMap!==void 0&&(wt.displacementMap=vt(at.displacementMap)),at.displacementScale!==void 0&&(wt.displacementScale=at.displacementScale),at.displacementBias!==void 0&&(wt.displacementBias=at.displacementBias),at.roughnessMap!==void 0&&(wt.roughnessMap=vt(at.roughnessMap)),at.metalnessMap!==void 0&&(wt.metalnessMap=vt(at.metalnessMap)),at.emissiveMap!==void 0&&(wt.emissiveMap=vt(at.emissiveMap)),at.emissiveIntensity!==void 0&&(wt.emissiveIntensity=at.emissiveIntensity),at.specularMap!==void 0&&(wt.specularMap=vt(at.specularMap)),at.specularIntensityMap!==void 0&&(wt.specularIntensityMap=vt(at.specularIntensityMap)),at.specularColorMap!==void 0&&(wt.specularColorMap=vt(at.specularColorMap)),at.envMap!==void 0&&(wt.envMap=vt(at.envMap)),at.envMapRotation!==void 0&&wt.envMapRotation.fromArray(at.envMapRotation),at.envMapIntensity!==void 0&&(wt.envMapIntensity=at.envMapIntensity),at.reflectivity!==void 0&&(wt.reflectivity=at.reflectivity),at.refractionRatio!==void 0&&(wt.refractionRatio=at.refractionRatio),at.lightMap!==void 0&&(wt.lightMap=vt(at.lightMap)),at.lightMapIntensity!==void 0&&(wt.lightMapIntensity=at.lightMapIntensity),at.aoMap!==void 0&&(wt.aoMap=vt(at.aoMap)),at.aoMapIntensity!==void 0&&(wt.aoMapIntensity=at.aoMapIntensity),at.gradientMap!==void 0&&(wt.gradientMap=vt(at.gradientMap)),at.clearcoatMap!==void 0&&(wt.clearcoatMap=vt(at.clearcoatMap)),at.clearcoatRoughnessMap!==void 0&&(wt.clearcoatRoughnessMap=vt(at.clearcoatRoughnessMap)),at.clearcoatNormalMap!==void 0&&(wt.clearcoatNormalMap=vt(at.clearcoatNormalMap)),at.clearcoatNormalScale!==void 0&&(wt.clearcoatNormalScale=new Vector2().fromArray(at.clearcoatNormalScale)),at.iridescenceMap!==void 0&&(wt.iridescenceMap=vt(at.iridescenceMap)),at.iridescenceThicknessMap!==void 0&&(wt.iridescenceThicknessMap=vt(at.iridescenceThicknessMap)),at.transmissionMap!==void 0&&(wt.transmissionMap=vt(at.transmissionMap)),at.thicknessMap!==void 0&&(wt.thicknessMap=vt(at.thicknessMap)),at.anisotropyMap!==void 0&&(wt.anisotropyMap=vt(at.anisotropyMap)),at.sheenColorMap!==void 0&&(wt.sheenColorMap=vt(at.sheenColorMap)),at.sheenRoughnessMap!==void 0&&(wt.sheenRoughnessMap=vt(at.sheenRoughnessMap)),wt}setTextures(at){return this.textures=at,this}static createMaterialFromType(at){const pt={ShadowMaterial,SpriteMaterial,RawShaderMaterial,ShaderMaterial,PointsMaterial,MeshPhysicalMaterial,MeshStandardMaterial,MeshPhongMaterial,MeshToonMaterial,MeshNormalMaterial,MeshLambertMaterial,MeshDepthMaterial,MeshDistanceMaterial,MeshBasicMaterial,MeshMatcapMaterial,LineDashedMaterial,LineBasicMaterial,Material};return new pt[at]}}class LoaderUtils{static decodeText(at){if(typeof TextDecoder<"u")return new TextDecoder().decode(at);let pt="";for(let vt=0,wt=at.length;vt<wt;vt++)pt+=String.fromCharCode(at[vt]);try{return decodeURIComponent(escape(pt))}catch{return pt}}static extractUrlBase(at){const pt=at.lastIndexOf("/");return pt===-1?"./":at.slice(0,pt+1)}static resolveURL(at,pt){return typeof at!="string"||at===""?"":(/^https?:\/\//i.test(pt)&&/^\//.test(at)&&(pt=pt.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(at)||/^data:.*,.*$/i.test(at)||/^blob:.*$/i.test(at)?at:pt+at)}}class InstancedBufferGeometry extends BufferGeometry{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(at){return super.copy(at),this.instanceCount=at.instanceCount,this}toJSON(){const at=super.toJSON();return at.instanceCount=this.instanceCount,at.isInstancedBufferGeometry=!0,at}}class BufferGeometryLoader extends Loader{constructor(at){super(at)}load(at,pt,vt,wt){const $t=this,Tt=new FileLoader($t.manager);Tt.setPath($t.path),Tt.setRequestHeader($t.requestHeader),Tt.setWithCredentials($t.withCredentials),Tt.load(at,function(Lt){try{pt($t.parse(JSON.parse(Lt)))}catch(Ft){wt?wt(Ft):console.error(Ft),$t.manager.itemError(at)}},vt,wt)}parse(at){const pt={},vt={};function wt(qt,Kt){if(pt[Kt]!==void 0)return pt[Kt];const Sn=qt.interleavedBuffers[Kt],wn=$t(qt,Sn.buffer),In=getTypedArray(Sn.type,wn),tr=new InterleavedBuffer(In,Sn.stride);return tr.uuid=Sn.uuid,pt[Kt]=tr,tr}function $t(qt,Kt){if(vt[Kt]!==void 0)return vt[Kt];const Sn=qt.arrayBuffers[Kt],wn=new Uint32Array(Sn).buffer;return vt[Kt]=wn,wn}const Tt=at.isInstancedBufferGeometry?new InstancedBufferGeometry:new BufferGeometry,Lt=at.data.index;if(Lt!==void 0){const qt=getTypedArray(Lt.type,Lt.array);Tt.setIndex(new BufferAttribute(qt,1))}const Ft=at.data.attributes;for(const qt in Ft){const Kt=Ft[qt];let An;if(Kt.isInterleavedBufferAttribute){const Sn=wt(at.data,Kt.data);An=new InterleavedBufferAttribute(Sn,Kt.itemSize,Kt.offset,Kt.normalized)}else{const Sn=getTypedArray(Kt.type,Kt.array),wn=Kt.isInstancedBufferAttribute?InstancedBufferAttribute:BufferAttribute;An=new wn(Sn,Kt.itemSize,Kt.normalized)}Kt.name!==void 0&&(An.name=Kt.name),Kt.usage!==void 0&&An.setUsage(Kt.usage),Tt.setAttribute(qt,An)}const Ct=at.data.morphAttributes;if(Ct)for(const qt in Ct){const Kt=Ct[qt],An=[];for(let Sn=0,wn=Kt.length;Sn<wn;Sn++){const In=Kt[Sn];let tr;if(In.isInterleavedBufferAttribute){const rr=wt(at.data,In.data);tr=new InterleavedBufferAttribute(rr,In.itemSize,In.offset,In.normalized)}else{const rr=getTypedArray(In.type,In.array);tr=new BufferAttribute(rr,In.itemSize,In.normalized)}In.name!==void 0&&(tr.name=In.name),An.push(tr)}Tt.morphAttributes[qt]=An}at.data.morphTargetsRelative&&(Tt.morphTargetsRelative=!0);const Gt=at.data.groups||at.data.drawcalls||at.data.offsets;if(Gt!==void 0)for(let qt=0,Kt=Gt.length;qt!==Kt;++qt){const An=Gt[qt];Tt.addGroup(An.start,An.count,An.materialIndex)}const jt=at.data.boundingSphere;if(jt!==void 0){const qt=new Vector3;jt.center!==void 0&&qt.fromArray(jt.center),Tt.boundingSphere=new Sphere(qt,jt.radius)}return at.name&&(Tt.name=at.name),at.userData&&(Tt.userData=at.userData),Tt}}class ObjectLoader extends Loader{constructor(at){super(at)}load(at,pt,vt,wt){const $t=this,Tt=this.path===""?LoaderUtils.extractUrlBase(at):this.path;this.resourcePath=this.resourcePath||Tt;const Lt=new FileLoader(this.manager);Lt.setPath(this.path),Lt.setRequestHeader(this.requestHeader),Lt.setWithCredentials(this.withCredentials),Lt.load(at,function(Ft){let Ct=null;try{Ct=JSON.parse(Ft)}catch(Gt){wt!==void 0&&wt(Gt),console.error("THREE:ObjectLoader: Can't parse "+at+".",Gt.message);return}const Ht=Ct.metadata;if(Ht===void 0||Ht.type===void 0||Ht.type.toLowerCase()==="geometry"){wt!==void 0&&wt(new Error("THREE.ObjectLoader: Can't load "+at)),console.error("THREE.ObjectLoader: Can't load "+at);return}$t.parse(Ct,pt)},vt,wt)}async loadAsync(at,pt){const vt=this,wt=this.path===""?LoaderUtils.extractUrlBase(at):this.path;this.resourcePath=this.resourcePath||wt;const $t=new FileLoader(this.manager);$t.setPath(this.path),$t.setRequestHeader(this.requestHeader),$t.setWithCredentials(this.withCredentials);const Tt=await $t.loadAsync(at,pt),Lt=JSON.parse(Tt),Ft=Lt.metadata;if(Ft===void 0||Ft.type===void 0||Ft.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+at);return await vt.parseAsync(Lt)}parse(at,pt){const vt=this.parseAnimations(at.animations),wt=this.parseShapes(at.shapes),$t=this.parseGeometries(at.geometries,wt),Tt=this.parseImages(at.images,function(){pt!==void 0&&pt(Ct)}),Lt=this.parseTextures(at.textures,Tt),Ft=this.parseMaterials(at.materials,Lt),Ct=this.parseObject(at.object,$t,Ft,Lt,vt),Ht=this.parseSkeletons(at.skeletons,Ct);if(this.bindSkeletons(Ct,Ht),pt!==void 0){let Gt=!1;for(const jt in Tt)if(Tt[jt].data instanceof HTMLImageElement){Gt=!0;break}Gt===!1&&pt(Ct)}return Ct}async parseAsync(at){const pt=this.parseAnimations(at.animations),vt=this.parseShapes(at.shapes),wt=this.parseGeometries(at.geometries,vt),$t=await this.parseImagesAsync(at.images),Tt=this.parseTextures(at.textures,$t),Lt=this.parseMaterials(at.materials,Tt),Ft=this.parseObject(at.object,wt,Lt,Tt,pt),Ct=this.parseSkeletons(at.skeletons,Ft);return this.bindSkeletons(Ft,Ct),Ft}parseShapes(at){const pt={};if(at!==void 0)for(let vt=0,wt=at.length;vt<wt;vt++){const $t=new Shape().fromJSON(at[vt]);pt[$t.uuid]=$t}return pt}parseSkeletons(at,pt){const vt={},wt={};if(pt.traverse(function($t){$t.isBone&&(wt[$t.uuid]=$t)}),at!==void 0)for(let $t=0,Tt=at.length;$t<Tt;$t++){const Lt=new Skeleton().fromJSON(at[$t],wt);vt[Lt.uuid]=Lt}return vt}parseGeometries(at,pt){const vt={};if(at!==void 0){const wt=new BufferGeometryLoader;for(let $t=0,Tt=at.length;$t<Tt;$t++){let Lt;const Ft=at[$t];switch(Ft.type){case"BufferGeometry":case"InstancedBufferGeometry":Lt=wt.parse(Ft);break;default:Ft.type in Geometries?Lt=Geometries[Ft.type].fromJSON(Ft,pt):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${Ft.type}"`)}Lt.uuid=Ft.uuid,Ft.name!==void 0&&(Lt.name=Ft.name),Ft.userData!==void 0&&(Lt.userData=Ft.userData),vt[Ft.uuid]=Lt}}return vt}parseMaterials(at,pt){const vt={},wt={};if(at!==void 0){const $t=new MaterialLoader;$t.setTextures(pt);for(let Tt=0,Lt=at.length;Tt<Lt;Tt++){const Ft=at[Tt];vt[Ft.uuid]===void 0&&(vt[Ft.uuid]=$t.parse(Ft)),wt[Ft.uuid]=vt[Ft.uuid]}}return wt}parseAnimations(at){const pt={};if(at!==void 0)for(let vt=0;vt<at.length;vt++){const wt=at[vt],$t=AnimationClip.parse(wt);pt[$t.uuid]=$t}return pt}parseImages(at,pt){const vt=this,wt={};let $t;function Tt(Ft){return vt.manager.itemStart(Ft),$t.load(Ft,function(){vt.manager.itemEnd(Ft)},void 0,function(){vt.manager.itemError(Ft),vt.manager.itemEnd(Ft)})}function Lt(Ft){if(typeof Ft=="string"){const Ct=Ft,Ht=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(Ct)?Ct:vt.resourcePath+Ct;return Tt(Ht)}else return Ft.data?{data:getTypedArray(Ft.type,Ft.data),width:Ft.width,height:Ft.height}:null}if(at!==void 0&&at.length>0){const Ft=new LoadingManager(pt);$t=new ImageLoader(Ft),$t.setCrossOrigin(this.crossOrigin);for(let Ct=0,Ht=at.length;Ct<Ht;Ct++){const Gt=at[Ct],jt=Gt.url;if(Array.isArray(jt)){const qt=[];for(let Kt=0,An=jt.length;Kt<An;Kt++){const Sn=jt[Kt],wn=Lt(Sn);wn!==null&&(wn instanceof HTMLImageElement?qt.push(wn):qt.push(new DataTexture(wn.data,wn.width,wn.height)))}wt[Gt.uuid]=new Source(qt)}else{const qt=Lt(Gt.url);wt[Gt.uuid]=new Source(qt)}}}return wt}async parseImagesAsync(at){const pt=this,vt={};let wt;async function $t(Tt){if(typeof Tt=="string"){const Lt=Tt,Ft=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(Lt)?Lt:pt.resourcePath+Lt;return await wt.loadAsync(Ft)}else return Tt.data?{data:getTypedArray(Tt.type,Tt.data),width:Tt.width,height:Tt.height}:null}if(at!==void 0&&at.length>0){wt=new ImageLoader(this.manager),wt.setCrossOrigin(this.crossOrigin);for(let Tt=0,Lt=at.length;Tt<Lt;Tt++){const Ft=at[Tt],Ct=Ft.url;if(Array.isArray(Ct)){const Ht=[];for(let Gt=0,jt=Ct.length;Gt<jt;Gt++){const qt=Ct[Gt],Kt=await $t(qt);Kt!==null&&(Kt instanceof HTMLImageElement?Ht.push(Kt):Ht.push(new DataTexture(Kt.data,Kt.width,Kt.height)))}vt[Ft.uuid]=new Source(Ht)}else{const Ht=await $t(Ft.url);vt[Ft.uuid]=new Source(Ht)}}}return vt}parseTextures(at,pt){function vt($t,Tt){return typeof $t=="number"?$t:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",$t),Tt[$t])}const wt={};if(at!==void 0)for(let $t=0,Tt=at.length;$t<Tt;$t++){const Lt=at[$t];Lt.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',Lt.uuid),pt[Lt.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",Lt.image);const Ft=pt[Lt.image],Ct=Ft.data;let Ht;Array.isArray(Ct)?(Ht=new CubeTexture,Ct.length===6&&(Ht.needsUpdate=!0)):(Ct&&Ct.data?Ht=new DataTexture:Ht=new Texture,Ct&&(Ht.needsUpdate=!0)),Ht.source=Ft,Ht.uuid=Lt.uuid,Lt.name!==void 0&&(Ht.name=Lt.name),Lt.mapping!==void 0&&(Ht.mapping=vt(Lt.mapping,TEXTURE_MAPPING)),Lt.channel!==void 0&&(Ht.channel=Lt.channel),Lt.offset!==void 0&&Ht.offset.fromArray(Lt.offset),Lt.repeat!==void 0&&Ht.repeat.fromArray(Lt.repeat),Lt.center!==void 0&&Ht.center.fromArray(Lt.center),Lt.rotation!==void 0&&(Ht.rotation=Lt.rotation),Lt.wrap!==void 0&&(Ht.wrapS=vt(Lt.wrap[0],TEXTURE_WRAPPING),Ht.wrapT=vt(Lt.wrap[1],TEXTURE_WRAPPING)),Lt.format!==void 0&&(Ht.format=Lt.format),Lt.internalFormat!==void 0&&(Ht.internalFormat=Lt.internalFormat),Lt.type!==void 0&&(Ht.type=Lt.type),Lt.colorSpace!==void 0&&(Ht.colorSpace=Lt.colorSpace),Lt.minFilter!==void 0&&(Ht.minFilter=vt(Lt.minFilter,TEXTURE_FILTER)),Lt.magFilter!==void 0&&(Ht.magFilter=vt(Lt.magFilter,TEXTURE_FILTER)),Lt.anisotropy!==void 0&&(Ht.anisotropy=Lt.anisotropy),Lt.flipY!==void 0&&(Ht.flipY=Lt.flipY),Lt.generateMipmaps!==void 0&&(Ht.generateMipmaps=Lt.generateMipmaps),Lt.premultiplyAlpha!==void 0&&(Ht.premultiplyAlpha=Lt.premultiplyAlpha),Lt.unpackAlignment!==void 0&&(Ht.unpackAlignment=Lt.unpackAlignment),Lt.compareFunction!==void 0&&(Ht.compareFunction=Lt.compareFunction),Lt.userData!==void 0&&(Ht.userData=Lt.userData),wt[Lt.uuid]=Ht}return wt}parseObject(at,pt,vt,wt,$t){let Tt;function Lt(jt){return pt[jt]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",jt),pt[jt]}function Ft(jt){if(jt!==void 0){if(Array.isArray(jt)){const qt=[];for(let Kt=0,An=jt.length;Kt<An;Kt++){const Sn=jt[Kt];vt[Sn]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",Sn),qt.push(vt[Sn])}return qt}return vt[jt]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",jt),vt[jt]}}function Ct(jt){return wt[jt]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",jt),wt[jt]}let Ht,Gt;switch(at.type){case"Scene":Tt=new Scene,at.background!==void 0&&(Number.isInteger(at.background)?Tt.background=new Color$1(at.background):Tt.background=Ct(at.background)),at.environment!==void 0&&(Tt.environment=Ct(at.environment)),at.fog!==void 0&&(at.fog.type==="Fog"?Tt.fog=new Fog(at.fog.color,at.fog.near,at.fog.far):at.fog.type==="FogExp2"&&(Tt.fog=new FogExp2(at.fog.color,at.fog.density)),at.fog.name!==""&&(Tt.fog.name=at.fog.name)),at.backgroundBlurriness!==void 0&&(Tt.backgroundBlurriness=at.backgroundBlurriness),at.backgroundIntensity!==void 0&&(Tt.backgroundIntensity=at.backgroundIntensity),at.backgroundRotation!==void 0&&Tt.backgroundRotation.fromArray(at.backgroundRotation),at.environmentRotation!==void 0&&Tt.environmentRotation.fromArray(at.environmentRotation);break;case"PerspectiveCamera":Tt=new PerspectiveCamera(at.fov,at.aspect,at.near,at.far),at.focus!==void 0&&(Tt.focus=at.focus),at.zoom!==void 0&&(Tt.zoom=at.zoom),at.filmGauge!==void 0&&(Tt.filmGauge=at.filmGauge),at.filmOffset!==void 0&&(Tt.filmOffset=at.filmOffset),at.view!==void 0&&(Tt.view=Object.assign({},at.view));break;case"OrthographicCamera":Tt=new OrthographicCamera(at.left,at.right,at.top,at.bottom,at.near,at.far),at.zoom!==void 0&&(Tt.zoom=at.zoom),at.view!==void 0&&(Tt.view=Object.assign({},at.view));break;case"AmbientLight":Tt=new AmbientLight(at.color,at.intensity);break;case"DirectionalLight":Tt=new DirectionalLight(at.color,at.intensity);break;case"PointLight":Tt=new PointLight(at.color,at.intensity,at.distance,at.decay);break;case"RectAreaLight":Tt=new RectAreaLight(at.color,at.intensity,at.width,at.height);break;case"SpotLight":Tt=new SpotLight(at.color,at.intensity,at.distance,at.angle,at.penumbra,at.decay);break;case"HemisphereLight":Tt=new HemisphereLight(at.color,at.groundColor,at.intensity);break;case"LightProbe":Tt=new LightProbe().fromJSON(at);break;case"SkinnedMesh":Ht=Lt(at.geometry),Gt=Ft(at.material),Tt=new SkinnedMesh(Ht,Gt),at.bindMode!==void 0&&(Tt.bindMode=at.bindMode),at.bindMatrix!==void 0&&Tt.bindMatrix.fromArray(at.bindMatrix),at.skeleton!==void 0&&(Tt.skeleton=at.skeleton);break;case"Mesh":Ht=Lt(at.geometry),Gt=Ft(at.material),Tt=new Mesh(Ht,Gt);break;case"InstancedMesh":Ht=Lt(at.geometry),Gt=Ft(at.material);const jt=at.count,qt=at.instanceMatrix,Kt=at.instanceColor;Tt=new InstancedMesh(Ht,Gt,jt),Tt.instanceMatrix=new InstancedBufferAttribute(new Float32Array(qt.array),16),Kt!==void 0&&(Tt.instanceColor=new InstancedBufferAttribute(new Float32Array(Kt.array),Kt.itemSize));break;case"BatchedMesh":Ht=Lt(at.geometry),Gt=Ft(at.material),Tt=new BatchedMesh(at.maxGeometryCount,at.maxVertexCount,at.maxIndexCount,Gt),Tt.geometry=Ht,Tt.perObjectFrustumCulled=at.perObjectFrustumCulled,Tt.sortObjects=at.sortObjects,Tt._drawRanges=at.drawRanges,Tt._reservedRanges=at.reservedRanges,Tt._visibility=at.visibility,Tt._active=at.active,Tt._bounds=at.bounds.map(An=>{const Sn=new Box3;Sn.min.fromArray(An.boxMin),Sn.max.fromArray(An.boxMax);const wn=new Sphere;return wn.radius=An.sphereRadius,wn.center.fromArray(An.sphereCenter),{boxInitialized:An.boxInitialized,box:Sn,sphereInitialized:An.sphereInitialized,sphere:wn}}),Tt._maxGeometryCount=at.maxGeometryCount,Tt._maxVertexCount=at.maxVertexCount,Tt._maxIndexCount=at.maxIndexCount,Tt._geometryInitialized=at.geometryInitialized,Tt._geometryCount=at.geometryCount,Tt._matricesTexture=Ct(at.matricesTexture.uuid);break;case"LOD":Tt=new LOD;break;case"Line":Tt=new Line(Lt(at.geometry),Ft(at.material));break;case"LineLoop":Tt=new LineLoop(Lt(at.geometry),Ft(at.material));break;case"LineSegments":Tt=new LineSegments(Lt(at.geometry),Ft(at.material));break;case"PointCloud":case"Points":Tt=new Points(Lt(at.geometry),Ft(at.material));break;case"Sprite":Tt=new Sprite(Ft(at.material));break;case"Group":Tt=new Group;break;case"Bone":Tt=new Bone;break;default:Tt=new Object3D}if(Tt.uuid=at.uuid,at.name!==void 0&&(Tt.name=at.name),at.matrix!==void 0?(Tt.matrix.fromArray(at.matrix),at.matrixAutoUpdate!==void 0&&(Tt.matrixAutoUpdate=at.matrixAutoUpdate),Tt.matrixAutoUpdate&&Tt.matrix.decompose(Tt.position,Tt.quaternion,Tt.scale)):(at.position!==void 0&&Tt.position.fromArray(at.position),at.rotation!==void 0&&Tt.rotation.fromArray(at.rotation),at.quaternion!==void 0&&Tt.quaternion.fromArray(at.quaternion),at.scale!==void 0&&Tt.scale.fromArray(at.scale)),at.up!==void 0&&Tt.up.fromArray(at.up),at.castShadow!==void 0&&(Tt.castShadow=at.castShadow),at.receiveShadow!==void 0&&(Tt.receiveShadow=at.receiveShadow),at.shadow&&(at.shadow.bias!==void 0&&(Tt.shadow.bias=at.shadow.bias),at.shadow.normalBias!==void 0&&(Tt.shadow.normalBias=at.shadow.normalBias),at.shadow.radius!==void 0&&(Tt.shadow.radius=at.shadow.radius),at.shadow.mapSize!==void 0&&Tt.shadow.mapSize.fromArray(at.shadow.mapSize),at.shadow.camera!==void 0&&(Tt.shadow.camera=this.parseObject(at.shadow.camera))),at.visible!==void 0&&(Tt.visible=at.visible),at.frustumCulled!==void 0&&(Tt.frustumCulled=at.frustumCulled),at.renderOrder!==void 0&&(Tt.renderOrder=at.renderOrder),at.userData!==void 0&&(Tt.userData=at.userData),at.layers!==void 0&&(Tt.layers.mask=at.layers),at.children!==void 0){const jt=at.children;for(let qt=0;qt<jt.length;qt++)Tt.add(this.parseObject(jt[qt],pt,vt,wt,$t))}if(at.animations!==void 0){const jt=at.animations;for(let qt=0;qt<jt.length;qt++){const Kt=jt[qt];Tt.animations.push($t[Kt])}}if(at.type==="LOD"){at.autoUpdate!==void 0&&(Tt.autoUpdate=at.autoUpdate);const jt=at.levels;for(let qt=0;qt<jt.length;qt++){const Kt=jt[qt],An=Tt.getObjectByProperty("uuid",Kt.object);An!==void 0&&Tt.addLevel(An,Kt.distance,Kt.hysteresis)}}return Tt}bindSkeletons(at,pt){Object.keys(pt).length!==0&&at.traverse(function(vt){if(vt.isSkinnedMesh===!0&&vt.skeleton!==void 0){const wt=pt[vt.skeleton];wt===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",vt.skeleton):vt.bind(wt,vt.bindMatrix)}})}}const TEXTURE_MAPPING={UVMapping,CubeReflectionMapping,CubeRefractionMapping,EquirectangularReflectionMapping,EquirectangularRefractionMapping,CubeUVReflectionMapping},TEXTURE_WRAPPING={RepeatWrapping,ClampToEdgeWrapping,MirroredRepeatWrapping},TEXTURE_FILTER={NearestFilter,NearestMipmapNearestFilter,NearestMipmapLinearFilter,LinearFilter,LinearMipmapNearestFilter,LinearMipmapLinearFilter};class ImageBitmapLoader extends Loader{constructor(at){super(at),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(at){return this.options=at,this}load(at,pt,vt,wt){at===void 0&&(at=""),this.path!==void 0&&(at=this.path+at),at=this.manager.resolveURL(at);const $t=this,Tt=Cache.get(at);if(Tt!==void 0){if($t.manager.itemStart(at),Tt.then){Tt.then(Ct=>{pt&&pt(Ct),$t.manager.itemEnd(at)}).catch(Ct=>{wt&&wt(Ct)});return}return setTimeout(function(){pt&&pt(Tt),$t.manager.itemEnd(at)},0),Tt}const Lt={};Lt.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",Lt.headers=this.requestHeader;const Ft=fetch(at,Lt).then(function(Ct){return Ct.blob()}).then(function(Ct){return createImageBitmap(Ct,Object.assign($t.options,{colorSpaceConversion:"none"}))}).then(function(Ct){return Cache.add(at,Ct),pt&&pt(Ct),$t.manager.itemEnd(at),Ct}).catch(function(Ct){wt&&wt(Ct),Cache.remove(at),$t.manager.itemError(at),$t.manager.itemEnd(at)});Cache.add(at,Ft),$t.manager.itemStart(at)}}let _context;class AudioContext{static getContext(){return _context===void 0&&(_context=new(window.AudioContext||window.webkitAudioContext)),_context}static setContext(at){_context=at}}class AudioLoader extends Loader{constructor(at){super(at)}load(at,pt,vt,wt){const $t=this,Tt=new FileLoader(this.manager);Tt.setResponseType("arraybuffer"),Tt.setPath(this.path),Tt.setRequestHeader(this.requestHeader),Tt.setWithCredentials(this.withCredentials),Tt.load(at,function(Ft){try{const Ct=Ft.slice(0);AudioContext.getContext().decodeAudioData(Ct,function(Gt){pt(Gt)}).catch(Lt)}catch(Ct){Lt(Ct)}},vt,wt);function Lt(Ft){wt?wt(Ft):console.error(Ft),$t.manager.itemError(at)}}}const _eyeRight=new Matrix4,_eyeLeft=new Matrix4,_projectionMatrix=new Matrix4;class StereoCamera{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new PerspectiveCamera,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new PerspectiveCamera,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(at){const pt=this._cache;if(pt.focus!==at.focus||pt.fov!==at.fov||pt.aspect!==at.aspect*this.aspect||pt.near!==at.near||pt.far!==at.far||pt.zoom!==at.zoom||pt.eyeSep!==this.eyeSep){pt.focus=at.focus,pt.fov=at.fov,pt.aspect=at.aspect*this.aspect,pt.near=at.near,pt.far=at.far,pt.zoom=at.zoom,pt.eyeSep=this.eyeSep,_projectionMatrix.copy(at.projectionMatrix);const wt=pt.eyeSep/2,$t=wt*pt.near/pt.focus,Tt=pt.near*Math.tan(DEG2RAD*pt.fov*.5)/pt.zoom;let Lt,Ft;_eyeLeft.elements[12]=-wt,_eyeRight.elements[12]=wt,Lt=-Tt*pt.aspect+$t,Ft=Tt*pt.aspect+$t,_projectionMatrix.elements[0]=2*pt.near/(Ft-Lt),_projectionMatrix.elements[8]=(Ft+Lt)/(Ft-Lt),this.cameraL.projectionMatrix.copy(_projectionMatrix),Lt=-Tt*pt.aspect-$t,Ft=Tt*pt.aspect-$t,_projectionMatrix.elements[0]=2*pt.near/(Ft-Lt),_projectionMatrix.elements[8]=(Ft+Lt)/(Ft-Lt),this.cameraR.projectionMatrix.copy(_projectionMatrix)}this.cameraL.matrixWorld.copy(at.matrixWorld).multiply(_eyeLeft),this.cameraR.matrixWorld.copy(at.matrixWorld).multiply(_eyeRight)}}class Clock{constructor(at=!0){this.autoStart=at,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let at=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const pt=now();at=(pt-this.oldTime)/1e3,this.oldTime=pt,this.elapsedTime+=at}return at}}function now(){return(typeof performance>"u"?Date:performance).now()}const _position$1=new Vector3,_quaternion$1=new Quaternion,_scale$1=new Vector3,_orientation$1=new Vector3;class AudioListener extends Object3D{constructor(){super(),this.type="AudioListener",this.context=AudioContext.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Clock}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(at){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=at,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(at){return this.gain.gain.setTargetAtTime(at,this.context.currentTime,.01),this}updateMatrixWorld(at){super.updateMatrixWorld(at);const pt=this.context.listener,vt=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(_position$1,_quaternion$1,_scale$1),_orientation$1.set(0,0,-1).applyQuaternion(_quaternion$1),pt.positionX){const wt=this.context.currentTime+this.timeDelta;pt.positionX.linearRampToValueAtTime(_position$1.x,wt),pt.positionY.linearRampToValueAtTime(_position$1.y,wt),pt.positionZ.linearRampToValueAtTime(_position$1.z,wt),pt.forwardX.linearRampToValueAtTime(_orientation$1.x,wt),pt.forwardY.linearRampToValueAtTime(_orientation$1.y,wt),pt.forwardZ.linearRampToValueAtTime(_orientation$1.z,wt),pt.upX.linearRampToValueAtTime(vt.x,wt),pt.upY.linearRampToValueAtTime(vt.y,wt),pt.upZ.linearRampToValueAtTime(vt.z,wt)}else pt.setPosition(_position$1.x,_position$1.y,_position$1.z),pt.setOrientation(_orientation$1.x,_orientation$1.y,_orientation$1.z,vt.x,vt.y,vt.z)}}class Audio extends Object3D{constructor(at){super(),this.type="Audio",this.listener=at,this.context=at.context,this.gain=this.context.createGain(),this.gain.connect(at.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(at){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=at,this.connect(),this}setMediaElementSource(at){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(at),this.connect(),this}setMediaStreamSource(at){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(at),this.connect(),this}setBuffer(at){return this.buffer=at,this.sourceType="buffer",this.autoplay&&this.play(),this}play(at=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+at;const pt=this.context.createBufferSource();return pt.buffer=this.buffer,pt.loop=this.loop,pt.loopStart=this.loopStart,pt.loopEnd=this.loopEnd,pt.onended=this.onEnded.bind(this),pt.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=pt,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let at=1,pt=this.filters.length;at<pt;at++)this.filters[at-1].connect(this.filters[at]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let at=1,pt=this.filters.length;at<pt;at++)this.filters[at-1].disconnect(this.filters[at]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(at){return at||(at=[]),this._connected===!0?(this.disconnect(),this.filters=at.slice(),this.connect()):this.filters=at.slice(),this}setDetune(at){return this.detune=at,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(at){return this.setFilters(at?[at]:[])}setPlaybackRate(at){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=at,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(at){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=at,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(at){return this.loopStart=at,this}setLoopEnd(at){return this.loopEnd=at,this}getVolume(){return this.gain.gain.value}setVolume(at){return this.gain.gain.setTargetAtTime(at,this.context.currentTime,.01),this}}const _position=new Vector3,_quaternion=new Quaternion,_scale=new Vector3,_orientation=new Vector3;class PositionalAudio extends Audio{constructor(at){super(at),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(at){return this.panner.refDistance=at,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(at){return this.panner.rolloffFactor=at,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(at){return this.panner.distanceModel=at,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(at){return this.panner.maxDistance=at,this}setDirectionalCone(at,pt,vt){return this.panner.coneInnerAngle=at,this.panner.coneOuterAngle=pt,this.panner.coneOuterGain=vt,this}updateMatrixWorld(at){if(super.updateMatrixWorld(at),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(_position,_quaternion,_scale),_orientation.set(0,0,1).applyQuaternion(_quaternion);const pt=this.panner;if(pt.positionX){const vt=this.context.currentTime+this.listener.timeDelta;pt.positionX.linearRampToValueAtTime(_position.x,vt),pt.positionY.linearRampToValueAtTime(_position.y,vt),pt.positionZ.linearRampToValueAtTime(_position.z,vt),pt.orientationX.linearRampToValueAtTime(_orientation.x,vt),pt.orientationY.linearRampToValueAtTime(_orientation.y,vt),pt.orientationZ.linearRampToValueAtTime(_orientation.z,vt)}else pt.setPosition(_position.x,_position.y,_position.z),pt.setOrientation(_orientation.x,_orientation.y,_orientation.z)}}class AudioAnalyser{constructor(at,pt=2048){this.analyser=at.context.createAnalyser(),this.analyser.fftSize=pt,this.data=new Uint8Array(this.analyser.frequencyBinCount),at.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let at=0;const pt=this.getFrequencyData();for(let vt=0;vt<pt.length;vt++)at+=pt[vt];return at/pt.length}}class PropertyMixer{constructor(at,pt,vt){this.binding=at,this.valueSize=vt;let wt,$t,Tt;switch(pt){case"quaternion":wt=this._slerp,$t=this._slerpAdditive,Tt=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(vt*6),this._workIndex=5;break;case"string":case"bool":wt=this._select,$t=this._select,Tt=this._setAdditiveIdentityOther,this.buffer=new Array(vt*5);break;default:wt=this._lerp,$t=this._lerpAdditive,Tt=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(vt*5)}this._mixBufferRegion=wt,this._mixBufferRegionAdditive=$t,this._setIdentity=Tt,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(at,pt){const vt=this.buffer,wt=this.valueSize,$t=at*wt+wt;let Tt=this.cumulativeWeight;if(Tt===0){for(let Lt=0;Lt!==wt;++Lt)vt[$t+Lt]=vt[Lt];Tt=pt}else{Tt+=pt;const Lt=pt/Tt;this._mixBufferRegion(vt,$t,0,Lt,wt)}this.cumulativeWeight=Tt}accumulateAdditive(at){const pt=this.buffer,vt=this.valueSize,wt=vt*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(pt,wt,0,at,vt),this.cumulativeWeightAdditive+=at}apply(at){const pt=this.valueSize,vt=this.buffer,wt=at*pt+pt,$t=this.cumulativeWeight,Tt=this.cumulativeWeightAdditive,Lt=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,$t<1){const Ft=pt*this._origIndex;this._mixBufferRegion(vt,wt,Ft,1-$t,pt)}Tt>0&&this._mixBufferRegionAdditive(vt,wt,this._addIndex*pt,1,pt);for(let Ft=pt,Ct=pt+pt;Ft!==Ct;++Ft)if(vt[Ft]!==vt[Ft+pt]){Lt.setValue(vt,wt);break}}saveOriginalState(){const at=this.binding,pt=this.buffer,vt=this.valueSize,wt=vt*this._origIndex;at.getValue(pt,wt);for(let $t=vt,Tt=wt;$t!==Tt;++$t)pt[$t]=pt[wt+$t%vt];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const at=this.valueSize*3;this.binding.setValue(this.buffer,at)}_setAdditiveIdentityNumeric(){const at=this._addIndex*this.valueSize,pt=at+this.valueSize;for(let vt=at;vt<pt;vt++)this.buffer[vt]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const at=this._origIndex*this.valueSize,pt=this._addIndex*this.valueSize;for(let vt=0;vt<this.valueSize;vt++)this.buffer[pt+vt]=this.buffer[at+vt]}_select(at,pt,vt,wt,$t){if(wt>=.5)for(let Tt=0;Tt!==$t;++Tt)at[pt+Tt]=at[vt+Tt]}_slerp(at,pt,vt,wt){Quaternion.slerpFlat(at,pt,at,pt,at,vt,wt)}_slerpAdditive(at,pt,vt,wt,$t){const Tt=this._workIndex*$t;Quaternion.multiplyQuaternionsFlat(at,Tt,at,pt,at,vt),Quaternion.slerpFlat(at,pt,at,pt,at,Tt,wt)}_lerp(at,pt,vt,wt,$t){const Tt=1-wt;for(let Lt=0;Lt!==$t;++Lt){const Ft=pt+Lt;at[Ft]=at[Ft]*Tt+at[vt+Lt]*wt}}_lerpAdditive(at,pt,vt,wt,$t){for(let Tt=0;Tt!==$t;++Tt){const Lt=pt+Tt;at[Lt]=at[Lt]+at[vt+Tt]*wt}}}const _RESERVED_CHARS_RE="\\[\\]\\.:\\/",_reservedRe=new RegExp("["+_RESERVED_CHARS_RE+"]","g"),_wordChar="[^"+_RESERVED_CHARS_RE+"]",_wordCharOrDot="[^"+_RESERVED_CHARS_RE.replace("\\.","")+"]",_directoryRe=/((?:WC+[\/:])*)/.source.replace("WC",_wordChar),_nodeRe=/(WCOD+)?/.source.replace("WCOD",_wordCharOrDot),_objectRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",_wordChar),_propertyRe=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",_wordChar),_trackRe=new RegExp("^"+_directoryRe+_nodeRe+_objectRe+_propertyRe+"$"),_supportedObjectNames=["material","materials","bones","map"];class Composite{constructor(at,pt,vt){const wt=vt||PropertyBinding.parseTrackName(pt);this._targetGroup=at,this._bindings=at.subscribe_(pt,wt)}getValue(at,pt){this.bind();const vt=this._targetGroup.nCachedObjects_,wt=this._bindings[vt];wt!==void 0&&wt.getValue(at,pt)}setValue(at,pt){const vt=this._bindings;for(let wt=this._targetGroup.nCachedObjects_,$t=vt.length;wt!==$t;++wt)vt[wt].setValue(at,pt)}bind(){const at=this._bindings;for(let pt=this._targetGroup.nCachedObjects_,vt=at.length;pt!==vt;++pt)at[pt].bind()}unbind(){const at=this._bindings;for(let pt=this._targetGroup.nCachedObjects_,vt=at.length;pt!==vt;++pt)at[pt].unbind()}}class PropertyBinding{constructor(at,pt,vt){this.path=pt,this.parsedPath=vt||PropertyBinding.parseTrackName(pt),this.node=PropertyBinding.findNode(at,this.parsedPath.nodeName),this.rootNode=at,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(at,pt,vt){return at&&at.isAnimationObjectGroup?new PropertyBinding.Composite(at,pt,vt):new PropertyBinding(at,pt,vt)}static sanitizeNodeName(at){return at.replace(/\s/g,"_").replace(_reservedRe,"")}static parseTrackName(at){const pt=_trackRe.exec(at);if(pt===null)throw new Error("PropertyBinding: Cannot parse trackName: "+at);const vt={nodeName:pt[2],objectName:pt[3],objectIndex:pt[4],propertyName:pt[5],propertyIndex:pt[6]},wt=vt.nodeName&&vt.nodeName.lastIndexOf(".");if(wt!==void 0&&wt!==-1){const $t=vt.nodeName.substring(wt+1);_supportedObjectNames.indexOf($t)!==-1&&(vt.nodeName=vt.nodeName.substring(0,wt),vt.objectName=$t)}if(vt.propertyName===null||vt.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+at);return vt}static findNode(at,pt){if(pt===void 0||pt===""||pt==="."||pt===-1||pt===at.name||pt===at.uuid)return at;if(at.skeleton){const vt=at.skeleton.getBoneByName(pt);if(vt!==void 0)return vt}if(at.children){const vt=function($t){for(let Tt=0;Tt<$t.length;Tt++){const Lt=$t[Tt];if(Lt.name===pt||Lt.uuid===pt)return Lt;const Ft=vt(Lt.children);if(Ft)return Ft}return null},wt=vt(at.children);if(wt)return wt}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(at,pt){at[pt]=this.targetObject[this.propertyName]}_getValue_array(at,pt){const vt=this.resolvedProperty;for(let wt=0,$t=vt.length;wt!==$t;++wt)at[pt++]=vt[wt]}_getValue_arrayElement(at,pt){at[pt]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(at,pt){this.resolvedProperty.toArray(at,pt)}_setValue_direct(at,pt){this.targetObject[this.propertyName]=at[pt]}_setValue_direct_setNeedsUpdate(at,pt){this.targetObject[this.propertyName]=at[pt],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(at,pt){this.targetObject[this.propertyName]=at[pt],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(at,pt){const vt=this.resolvedProperty;for(let wt=0,$t=vt.length;wt!==$t;++wt)vt[wt]=at[pt++]}_setValue_array_setNeedsUpdate(at,pt){const vt=this.resolvedProperty;for(let wt=0,$t=vt.length;wt!==$t;++wt)vt[wt]=at[pt++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(at,pt){const vt=this.resolvedProperty;for(let wt=0,$t=vt.length;wt!==$t;++wt)vt[wt]=at[pt++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(at,pt){this.resolvedProperty[this.propertyIndex]=at[pt]}_setValue_arrayElement_setNeedsUpdate(at,pt){this.resolvedProperty[this.propertyIndex]=at[pt],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(at,pt){this.resolvedProperty[this.propertyIndex]=at[pt],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(at,pt){this.resolvedProperty.fromArray(at,pt)}_setValue_fromArray_setNeedsUpdate(at,pt){this.resolvedProperty.fromArray(at,pt),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(at,pt){this.resolvedProperty.fromArray(at,pt),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(at,pt){this.bind(),this.getValue(at,pt)}_setValue_unbound(at,pt){this.bind(),this.setValue(at,pt)}bind(){let at=this.node;const pt=this.parsedPath,vt=pt.objectName,wt=pt.propertyName;let $t=pt.propertyIndex;if(at||(at=PropertyBinding.findNode(this.rootNode,pt.nodeName),this.node=at),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!at){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(vt){let Ct=pt.objectIndex;switch(vt){case"materials":if(!at.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!at.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}at=at.material.materials;break;case"bones":if(!at.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}at=at.skeleton.bones;for(let Ht=0;Ht<at.length;Ht++)if(at[Ht].name===Ct){Ct=Ht;break}break;case"map":if("map"in at){at=at.map;break}if(!at.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!at.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}at=at.material.map;break;default:if(at[vt]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}at=at[vt]}if(Ct!==void 0){if(at[Ct]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,at);return}at=at[Ct]}}const Tt=at[wt];if(Tt===void 0){const Ct=pt.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+Ct+"."+wt+" but it wasn't found.",at);return}let Lt=this.Versioning.None;this.targetObject=at,at.needsUpdate!==void 0?Lt=this.Versioning.NeedsUpdate:at.matrixWorldNeedsUpdate!==void 0&&(Lt=this.Versioning.MatrixWorldNeedsUpdate);let Ft=this.BindingType.Direct;if($t!==void 0){if(wt==="morphTargetInfluences"){if(!at.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!at.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}at.morphTargetDictionary[$t]!==void 0&&($t=at.morphTargetDictionary[$t])}Ft=this.BindingType.ArrayElement,this.resolvedProperty=Tt,this.propertyIndex=$t}else Tt.fromArray!==void 0&&Tt.toArray!==void 0?(Ft=this.BindingType.HasFromToArray,this.resolvedProperty=Tt):Array.isArray(Tt)?(Ft=this.BindingType.EntireArray,this.resolvedProperty=Tt):this.propertyName=wt;this.getValue=this.GetterByBindingType[Ft],this.setValue=this.SetterByBindingTypeAndVersioning[Ft][Lt]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}PropertyBinding.Composite=Composite;PropertyBinding.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};PropertyBinding.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};PropertyBinding.prototype.GetterByBindingType=[PropertyBinding.prototype._getValue_direct,PropertyBinding.prototype._getValue_array,PropertyBinding.prototype._getValue_arrayElement,PropertyBinding.prototype._getValue_toArray];PropertyBinding.prototype.SetterByBindingTypeAndVersioning=[[PropertyBinding.prototype._setValue_direct,PropertyBinding.prototype._setValue_direct_setNeedsUpdate,PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_array,PropertyBinding.prototype._setValue_array_setNeedsUpdate,PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_arrayElement,PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_fromArray,PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class AnimationObjectGroup{constructor(){this.isAnimationObjectGroup=!0,this.uuid=generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const at={};this._indicesByUUID=at;for(let vt=0,wt=arguments.length;vt!==wt;++vt)at[arguments[vt].uuid]=vt;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const pt=this;this.stats={objects:{get total(){return pt._objects.length},get inUse(){return this.total-pt.nCachedObjects_}},get bindingsPerObject(){return pt._bindings.length}}}add(){const at=this._objects,pt=this._indicesByUUID,vt=this._paths,wt=this._parsedPaths,$t=this._bindings,Tt=$t.length;let Lt,Ft=at.length,Ct=this.nCachedObjects_;for(let Ht=0,Gt=arguments.length;Ht!==Gt;++Ht){const jt=arguments[Ht],qt=jt.uuid;let Kt=pt[qt];if(Kt===void 0){Kt=Ft++,pt[qt]=Kt,at.push(jt);for(let An=0,Sn=Tt;An!==Sn;++An)$t[An].push(new PropertyBinding(jt,vt[An],wt[An]))}else if(Kt<Ct){Lt=at[Kt];const An=--Ct,Sn=at[An];pt[Sn.uuid]=Kt,at[Kt]=Sn,pt[qt]=An,at[An]=jt;for(let wn=0,In=Tt;wn!==In;++wn){const tr=$t[wn],rr=tr[An];let Hr=tr[Kt];tr[Kt]=rr,Hr===void 0&&(Hr=new PropertyBinding(jt,vt[wn],wt[wn])),tr[An]=Hr}}else at[Kt]!==Lt&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=Ct}remove(){const at=this._objects,pt=this._indicesByUUID,vt=this._bindings,wt=vt.length;let $t=this.nCachedObjects_;for(let Tt=0,Lt=arguments.length;Tt!==Lt;++Tt){const Ft=arguments[Tt],Ct=Ft.uuid,Ht=pt[Ct];if(Ht!==void 0&&Ht>=$t){const Gt=$t++,jt=at[Gt];pt[jt.uuid]=Ht,at[Ht]=jt,pt[Ct]=Gt,at[Gt]=Ft;for(let qt=0,Kt=wt;qt!==Kt;++qt){const An=vt[qt],Sn=An[Gt],wn=An[Ht];An[Ht]=Sn,An[Gt]=wn}}}this.nCachedObjects_=$t}uncache(){const at=this._objects,pt=this._indicesByUUID,vt=this._bindings,wt=vt.length;let $t=this.nCachedObjects_,Tt=at.length;for(let Lt=0,Ft=arguments.length;Lt!==Ft;++Lt){const Ct=arguments[Lt],Ht=Ct.uuid,Gt=pt[Ht];if(Gt!==void 0)if(delete pt[Ht],Gt<$t){const jt=--$t,qt=at[jt],Kt=--Tt,An=at[Kt];pt[qt.uuid]=Gt,at[Gt]=qt,pt[An.uuid]=jt,at[jt]=An,at.pop();for(let Sn=0,wn=wt;Sn!==wn;++Sn){const In=vt[Sn],tr=In[jt],rr=In[Kt];In[Gt]=tr,In[jt]=rr,In.pop()}}else{const jt=--Tt,qt=at[jt];jt>0&&(pt[qt.uuid]=Gt),at[Gt]=qt,at.pop();for(let Kt=0,An=wt;Kt!==An;++Kt){const Sn=vt[Kt];Sn[Gt]=Sn[jt],Sn.pop()}}}this.nCachedObjects_=$t}subscribe_(at,pt){const vt=this._bindingsIndicesByPath;let wt=vt[at];const $t=this._bindings;if(wt!==void 0)return $t[wt];const Tt=this._paths,Lt=this._parsedPaths,Ft=this._objects,Ct=Ft.length,Ht=this.nCachedObjects_,Gt=new Array(Ct);wt=$t.length,vt[at]=wt,Tt.push(at),Lt.push(pt),$t.push(Gt);for(let jt=Ht,qt=Ft.length;jt!==qt;++jt){const Kt=Ft[jt];Gt[jt]=new PropertyBinding(Kt,at,pt)}return Gt}unsubscribe_(at){const pt=this._bindingsIndicesByPath,vt=pt[at];if(vt!==void 0){const wt=this._paths,$t=this._parsedPaths,Tt=this._bindings,Lt=Tt.length-1,Ft=Tt[Lt],Ct=at[Lt];pt[Ct]=vt,Tt[vt]=Ft,Tt.pop(),$t[vt]=$t[Lt],$t.pop(),wt[vt]=wt[Lt],wt.pop()}}}class AnimationAction{constructor(at,pt,vt=null,wt=pt.blendMode){this._mixer=at,this._clip=pt,this._localRoot=vt,this.blendMode=wt;const $t=pt.tracks,Tt=$t.length,Lt=new Array(Tt),Ft={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};for(let Ct=0;Ct!==Tt;++Ct){const Ht=$t[Ct].createInterpolant(null);Lt[Ct]=Ht,Ht.settings=Ft}this._interpolantSettings=Ft,this._interpolants=Lt,this._propertyBindings=new Array(Tt),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=LoopRepeat,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(at){return this._startTime=at,this}setLoop(at,pt){return this.loop=at,this.repetitions=pt,this}setEffectiveWeight(at){return this.weight=at,this._effectiveWeight=this.enabled?at:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(at){return this._scheduleFading(at,0,1)}fadeOut(at){return this._scheduleFading(at,1,0)}crossFadeFrom(at,pt,vt){if(at.fadeOut(pt),this.fadeIn(pt),vt){const wt=this._clip.duration,$t=at._clip.duration,Tt=$t/wt,Lt=wt/$t;at.warp(1,Tt,pt),this.warp(Lt,1,pt)}return this}crossFadeTo(at,pt,vt){return at.crossFadeFrom(this,pt,vt)}stopFading(){const at=this._weightInterpolant;return at!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(at)),this}setEffectiveTimeScale(at){return this.timeScale=at,this._effectiveTimeScale=this.paused?0:at,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(at){return this.timeScale=this._clip.duration/at,this.stopWarping()}syncWith(at){return this.time=at.time,this.timeScale=at.timeScale,this.stopWarping()}halt(at){return this.warp(this._effectiveTimeScale,0,at)}warp(at,pt,vt){const wt=this._mixer,$t=wt.time,Tt=this.timeScale;let Lt=this._timeScaleInterpolant;Lt===null&&(Lt=wt._lendControlInterpolant(),this._timeScaleInterpolant=Lt);const Ft=Lt.parameterPositions,Ct=Lt.sampleValues;return Ft[0]=$t,Ft[1]=$t+vt,Ct[0]=at/Tt,Ct[1]=pt/Tt,this}stopWarping(){const at=this._timeScaleInterpolant;return at!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(at)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(at,pt,vt,wt){if(!this.enabled){this._updateWeight(at);return}const $t=this._startTime;if($t!==null){const Ft=(at-$t)*vt;Ft<0||vt===0?pt=0:(this._startTime=null,pt=vt*Ft)}pt*=this._updateTimeScale(at);const Tt=this._updateTime(pt),Lt=this._updateWeight(at);if(Lt>0){const Ft=this._interpolants,Ct=this._propertyBindings;switch(this.blendMode){case AdditiveAnimationBlendMode:for(let Ht=0,Gt=Ft.length;Ht!==Gt;++Ht)Ft[Ht].evaluate(Tt),Ct[Ht].accumulateAdditive(Lt);break;case NormalAnimationBlendMode:default:for(let Ht=0,Gt=Ft.length;Ht!==Gt;++Ht)Ft[Ht].evaluate(Tt),Ct[Ht].accumulate(wt,Lt)}}}_updateWeight(at){let pt=0;if(this.enabled){pt=this.weight;const vt=this._weightInterpolant;if(vt!==null){const wt=vt.evaluate(at)[0];pt*=wt,at>vt.parameterPositions[1]&&(this.stopFading(),wt===0&&(this.enabled=!1))}}return this._effectiveWeight=pt,pt}_updateTimeScale(at){let pt=0;if(!this.paused){pt=this.timeScale;const vt=this._timeScaleInterpolant;if(vt!==null){const wt=vt.evaluate(at)[0];pt*=wt,at>vt.parameterPositions[1]&&(this.stopWarping(),pt===0?this.paused=!0:this.timeScale=pt)}}return this._effectiveTimeScale=pt,pt}_updateTime(at){const pt=this._clip.duration,vt=this.loop;let wt=this.time+at,$t=this._loopCount;const Tt=vt===LoopPingPong;if(at===0)return $t===-1?wt:Tt&&($t&1)===1?pt-wt:wt;if(vt===LoopOnce){$t===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(wt>=pt)wt=pt;else if(wt<0)wt=0;else{this.time=wt;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=wt,this._mixer.dispatchEvent({type:"finished",action:this,direction:at<0?-1:1})}}else{if($t===-1&&(at>=0?($t=0,this._setEndings(!0,this.repetitions===0,Tt)):this._setEndings(this.repetitions===0,!0,Tt)),wt>=pt||wt<0){const Lt=Math.floor(wt/pt);wt-=pt*Lt,$t+=Math.abs(Lt);const Ft=this.repetitions-$t;if(Ft<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,wt=at>0?pt:0,this.time=wt,this._mixer.dispatchEvent({type:"finished",action:this,direction:at>0?1:-1});else{if(Ft===1){const Ct=at<0;this._setEndings(Ct,!Ct,Tt)}else this._setEndings(!1,!1,Tt);this._loopCount=$t,this.time=wt,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:Lt})}}else this.time=wt;if(Tt&&($t&1)===1)return pt-wt}return wt}_setEndings(at,pt,vt){const wt=this._interpolantSettings;vt?(wt.endingStart=ZeroSlopeEnding,wt.endingEnd=ZeroSlopeEnding):(at?wt.endingStart=this.zeroSlopeAtStart?ZeroSlopeEnding:ZeroCurvatureEnding:wt.endingStart=WrapAroundEnding,pt?wt.endingEnd=this.zeroSlopeAtEnd?ZeroSlopeEnding:ZeroCurvatureEnding:wt.endingEnd=WrapAroundEnding)}_scheduleFading(at,pt,vt){const wt=this._mixer,$t=wt.time;let Tt=this._weightInterpolant;Tt===null&&(Tt=wt._lendControlInterpolant(),this._weightInterpolant=Tt);const Lt=Tt.parameterPositions,Ft=Tt.sampleValues;return Lt[0]=$t,Ft[0]=pt,Lt[1]=$t+at,Ft[1]=vt,this}}const _controlInterpolantsResultBuffer=new Float32Array(1);class AnimationMixer extends EventDispatcher{constructor(at){super(),this._root=at,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(at,pt){const vt=at._localRoot||this._root,wt=at._clip.tracks,$t=wt.length,Tt=at._propertyBindings,Lt=at._interpolants,Ft=vt.uuid,Ct=this._bindingsByRootAndName;let Ht=Ct[Ft];Ht===void 0&&(Ht={},Ct[Ft]=Ht);for(let Gt=0;Gt!==$t;++Gt){const jt=wt[Gt],qt=jt.name;let Kt=Ht[qt];if(Kt!==void 0)++Kt.referenceCount,Tt[Gt]=Kt;else{if(Kt=Tt[Gt],Kt!==void 0){Kt._cacheIndex===null&&(++Kt.referenceCount,this._addInactiveBinding(Kt,Ft,qt));continue}const An=pt&&pt._propertyBindings[Gt].binding.parsedPath;Kt=new PropertyMixer(PropertyBinding.create(vt,qt,An),jt.ValueTypeName,jt.getValueSize()),++Kt.referenceCount,this._addInactiveBinding(Kt,Ft,qt),Tt[Gt]=Kt}Lt[Gt].resultBuffer=Kt.buffer}}_activateAction(at){if(!this._isActiveAction(at)){if(at._cacheIndex===null){const vt=(at._localRoot||this._root).uuid,wt=at._clip.uuid,$t=this._actionsByClip[wt];this._bindAction(at,$t&&$t.knownActions[0]),this._addInactiveAction(at,wt,vt)}const pt=at._propertyBindings;for(let vt=0,wt=pt.length;vt!==wt;++vt){const $t=pt[vt];$t.useCount++===0&&(this._lendBinding($t),$t.saveOriginalState())}this._lendAction(at)}}_deactivateAction(at){if(this._isActiveAction(at)){const pt=at._propertyBindings;for(let vt=0,wt=pt.length;vt!==wt;++vt){const $t=pt[vt];--$t.useCount===0&&($t.restoreOriginalState(),this._takeBackBinding($t))}this._takeBackAction(at)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const at=this;this.stats={actions:{get total(){return at._actions.length},get inUse(){return at._nActiveActions}},bindings:{get total(){return at._bindings.length},get inUse(){return at._nActiveBindings}},controlInterpolants:{get total(){return at._controlInterpolants.length},get inUse(){return at._nActiveControlInterpolants}}}}_isActiveAction(at){const pt=at._cacheIndex;return pt!==null&&pt<this._nActiveActions}_addInactiveAction(at,pt,vt){const wt=this._actions,$t=this._actionsByClip;let Tt=$t[pt];if(Tt===void 0)Tt={knownActions:[at],actionByRoot:{}},at._byClipCacheIndex=0,$t[pt]=Tt;else{const Lt=Tt.knownActions;at._byClipCacheIndex=Lt.length,Lt.push(at)}at._cacheIndex=wt.length,wt.push(at),Tt.actionByRoot[vt]=at}_removeInactiveAction(at){const pt=this._actions,vt=pt[pt.length-1],wt=at._cacheIndex;vt._cacheIndex=wt,pt[wt]=vt,pt.pop(),at._cacheIndex=null;const $t=at._clip.uuid,Tt=this._actionsByClip,Lt=Tt[$t],Ft=Lt.knownActions,Ct=Ft[Ft.length-1],Ht=at._byClipCacheIndex;Ct._byClipCacheIndex=Ht,Ft[Ht]=Ct,Ft.pop(),at._byClipCacheIndex=null;const Gt=Lt.actionByRoot,jt=(at._localRoot||this._root).uuid;delete Gt[jt],Ft.length===0&&delete Tt[$t],this._removeInactiveBindingsForAction(at)}_removeInactiveBindingsForAction(at){const pt=at._propertyBindings;for(let vt=0,wt=pt.length;vt!==wt;++vt){const $t=pt[vt];--$t.referenceCount===0&&this._removeInactiveBinding($t)}}_lendAction(at){const pt=this._actions,vt=at._cacheIndex,wt=this._nActiveActions++,$t=pt[wt];at._cacheIndex=wt,pt[wt]=at,$t._cacheIndex=vt,pt[vt]=$t}_takeBackAction(at){const pt=this._actions,vt=at._cacheIndex,wt=--this._nActiveActions,$t=pt[wt];at._cacheIndex=wt,pt[wt]=at,$t._cacheIndex=vt,pt[vt]=$t}_addInactiveBinding(at,pt,vt){const wt=this._bindingsByRootAndName,$t=this._bindings;let Tt=wt[pt];Tt===void 0&&(Tt={},wt[pt]=Tt),Tt[vt]=at,at._cacheIndex=$t.length,$t.push(at)}_removeInactiveBinding(at){const pt=this._bindings,vt=at.binding,wt=vt.rootNode.uuid,$t=vt.path,Tt=this._bindingsByRootAndName,Lt=Tt[wt],Ft=pt[pt.length-1],Ct=at._cacheIndex;Ft._cacheIndex=Ct,pt[Ct]=Ft,pt.pop(),delete Lt[$t],Object.keys(Lt).length===0&&delete Tt[wt]}_lendBinding(at){const pt=this._bindings,vt=at._cacheIndex,wt=this._nActiveBindings++,$t=pt[wt];at._cacheIndex=wt,pt[wt]=at,$t._cacheIndex=vt,pt[vt]=$t}_takeBackBinding(at){const pt=this._bindings,vt=at._cacheIndex,wt=--this._nActiveBindings,$t=pt[wt];at._cacheIndex=wt,pt[wt]=at,$t._cacheIndex=vt,pt[vt]=$t}_lendControlInterpolant(){const at=this._controlInterpolants,pt=this._nActiveControlInterpolants++;let vt=at[pt];return vt===void 0&&(vt=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,_controlInterpolantsResultBuffer),vt.__cacheIndex=pt,at[pt]=vt),vt}_takeBackControlInterpolant(at){const pt=this._controlInterpolants,vt=at.__cacheIndex,wt=--this._nActiveControlInterpolants,$t=pt[wt];at.__cacheIndex=wt,pt[wt]=at,$t.__cacheIndex=vt,pt[vt]=$t}clipAction(at,pt,vt){const wt=pt||this._root,$t=wt.uuid;let Tt=typeof at=="string"?AnimationClip.findByName(wt,at):at;const Lt=Tt!==null?Tt.uuid:at,Ft=this._actionsByClip[Lt];let Ct=null;if(vt===void 0&&(Tt!==null?vt=Tt.blendMode:vt=NormalAnimationBlendMode),Ft!==void 0){const Gt=Ft.actionByRoot[$t];if(Gt!==void 0&&Gt.blendMode===vt)return Gt;Ct=Ft.knownActions[0],Tt===null&&(Tt=Ct._clip)}if(Tt===null)return null;const Ht=new AnimationAction(this,Tt,pt,vt);return this._bindAction(Ht,Ct),this._addInactiveAction(Ht,Lt,$t),Ht}existingAction(at,pt){const vt=pt||this._root,wt=vt.uuid,$t=typeof at=="string"?AnimationClip.findByName(vt,at):at,Tt=$t?$t.uuid:at,Lt=this._actionsByClip[Tt];return Lt!==void 0&&Lt.actionByRoot[wt]||null}stopAllAction(){const at=this._actions,pt=this._nActiveActions;for(let vt=pt-1;vt>=0;--vt)at[vt].stop();return this}update(at){at*=this.timeScale;const pt=this._actions,vt=this._nActiveActions,wt=this.time+=at,$t=Math.sign(at),Tt=this._accuIndex^=1;for(let Ct=0;Ct!==vt;++Ct)pt[Ct]._update(wt,at,$t,Tt);const Lt=this._bindings,Ft=this._nActiveBindings;for(let Ct=0;Ct!==Ft;++Ct)Lt[Ct].apply(Tt);return this}setTime(at){this.time=0;for(let pt=0;pt<this._actions.length;pt++)this._actions[pt].time=0;return this.update(at)}getRoot(){return this._root}uncacheClip(at){const pt=this._actions,vt=at.uuid,wt=this._actionsByClip,$t=wt[vt];if($t!==void 0){const Tt=$t.knownActions;for(let Lt=0,Ft=Tt.length;Lt!==Ft;++Lt){const Ct=Tt[Lt];this._deactivateAction(Ct);const Ht=Ct._cacheIndex,Gt=pt[pt.length-1];Ct._cacheIndex=null,Ct._byClipCacheIndex=null,Gt._cacheIndex=Ht,pt[Ht]=Gt,pt.pop(),this._removeInactiveBindingsForAction(Ct)}delete wt[vt]}}uncacheRoot(at){const pt=at.uuid,vt=this._actionsByClip;for(const Tt in vt){const Lt=vt[Tt].actionByRoot,Ft=Lt[pt];Ft!==void 0&&(this._deactivateAction(Ft),this._removeInactiveAction(Ft))}const wt=this._bindingsByRootAndName,$t=wt[pt];if($t!==void 0)for(const Tt in $t){const Lt=$t[Tt];Lt.restoreOriginalState(),this._removeInactiveBinding(Lt)}}uncacheAction(at,pt){const vt=this.existingAction(at,pt);vt!==null&&(this._deactivateAction(vt),this._removeInactiveAction(vt))}}class Uniform{constructor(at){this.value=at}clone(){return new Uniform(this.value.clone===void 0?this.value:this.value.clone())}}let _id=0;class UniformsGroup extends EventDispatcher{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:_id++}),this.name="",this.usage=StaticDrawUsage,this.uniforms=[]}add(at){return this.uniforms.push(at),this}remove(at){const pt=this.uniforms.indexOf(at);return pt!==-1&&this.uniforms.splice(pt,1),this}setName(at){return this.name=at,this}setUsage(at){return this.usage=at,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(at){this.name=at.name,this.usage=at.usage;const pt=at.uniforms;this.uniforms.length=0;for(let vt=0,wt=pt.length;vt<wt;vt++){const $t=Array.isArray(pt[vt])?pt[vt]:[pt[vt]];for(let Tt=0;Tt<$t.length;Tt++)this.uniforms.push($t[Tt].clone())}return this}clone(){return new this.constructor().copy(this)}}class InstancedInterleavedBuffer extends InterleavedBuffer{constructor(at,pt,vt=1){super(at,pt),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=vt}copy(at){return super.copy(at),this.meshPerAttribute=at.meshPerAttribute,this}clone(at){const pt=super.clone(at);return pt.meshPerAttribute=this.meshPerAttribute,pt}toJSON(at){const pt=super.toJSON(at);return pt.isInstancedInterleavedBuffer=!0,pt.meshPerAttribute=this.meshPerAttribute,pt}}class GLBufferAttribute{constructor(at,pt,vt,wt,$t){this.isGLBufferAttribute=!0,this.name="",this.buffer=at,this.type=pt,this.itemSize=vt,this.elementSize=wt,this.count=$t,this.version=0}set needsUpdate(at){at===!0&&this.version++}setBuffer(at){return this.buffer=at,this}setType(at,pt){return this.type=at,this.elementSize=pt,this}setItemSize(at){return this.itemSize=at,this}setCount(at){return this.count=at,this}}const _matrix=new Matrix4;class Raycaster{constructor(at,pt,vt=0,wt=1/0){this.ray=new Ray(at,pt),this.near=vt,this.far=wt,this.camera=null,this.layers=new Layers,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(at,pt){this.ray.set(at,pt)}setFromCamera(at,pt){pt.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(pt.matrixWorld),this.ray.direction.set(at.x,at.y,.5).unproject(pt).sub(this.ray.origin).normalize(),this.camera=pt):pt.isOrthographicCamera?(this.ray.origin.set(at.x,at.y,(pt.near+pt.far)/(pt.near-pt.far)).unproject(pt),this.ray.direction.set(0,0,-1).transformDirection(pt.matrixWorld),this.camera=pt):console.error("THREE.Raycaster: Unsupported camera type: "+pt.type)}setFromXRController(at){return _matrix.identity().extractRotation(at.matrixWorld),this.ray.origin.setFromMatrixPosition(at.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(_matrix),this}intersectObject(at,pt=!0,vt=[]){return intersect(at,this,vt,pt),vt.sort(ascSort),vt}intersectObjects(at,pt=!0,vt=[]){for(let wt=0,$t=at.length;wt<$t;wt++)intersect(at[wt],this,vt,pt);return vt.sort(ascSort),vt}}function ascSort(st,at){return st.distance-at.distance}function intersect(st,at,pt,vt){if(st.layers.test(at.layers)&&st.raycast(at,pt),vt===!0){const wt=st.children;for(let $t=0,Tt=wt.length;$t<Tt;$t++)intersect(wt[$t],at,pt,!0)}}class Spherical{constructor(at=1,pt=0,vt=0){return this.radius=at,this.phi=pt,this.theta=vt,this}set(at,pt,vt){return this.radius=at,this.phi=pt,this.theta=vt,this}copy(at){return this.radius=at.radius,this.phi=at.phi,this.theta=at.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(at){return this.setFromCartesianCoords(at.x,at.y,at.z)}setFromCartesianCoords(at,pt,vt){return this.radius=Math.sqrt(at*at+pt*pt+vt*vt),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(at,vt),this.phi=Math.acos(clamp$3(pt/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class Cylindrical{constructor(at=1,pt=0,vt=0){return this.radius=at,this.theta=pt,this.y=vt,this}set(at,pt,vt){return this.radius=at,this.theta=pt,this.y=vt,this}copy(at){return this.radius=at.radius,this.theta=at.theta,this.y=at.y,this}setFromVector3(at){return this.setFromCartesianCoords(at.x,at.y,at.z)}setFromCartesianCoords(at,pt,vt){return this.radius=Math.sqrt(at*at+vt*vt),this.theta=Math.atan2(at,vt),this.y=pt,this}clone(){return new this.constructor().copy(this)}}const _vector$4=new Vector2;class Box2{constructor(at=new Vector2(1/0,1/0),pt=new Vector2(-1/0,-1/0)){this.isBox2=!0,this.min=at,this.max=pt}set(at,pt){return this.min.copy(at),this.max.copy(pt),this}setFromPoints(at){this.makeEmpty();for(let pt=0,vt=at.length;pt<vt;pt++)this.expandByPoint(at[pt]);return this}setFromCenterAndSize(at,pt){const vt=_vector$4.copy(pt).multiplyScalar(.5);return this.min.copy(at).sub(vt),this.max.copy(at).add(vt),this}clone(){return new this.constructor().copy(this)}copy(at){return this.min.copy(at.min),this.max.copy(at.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(at){return this.isEmpty()?at.set(0,0):at.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(at){return this.isEmpty()?at.set(0,0):at.subVectors(this.max,this.min)}expandByPoint(at){return this.min.min(at),this.max.max(at),this}expandByVector(at){return this.min.sub(at),this.max.add(at),this}expandByScalar(at){return this.min.addScalar(-at),this.max.addScalar(at),this}containsPoint(at){return!(at.x<this.min.x||at.x>this.max.x||at.y<this.min.y||at.y>this.max.y)}containsBox(at){return this.min.x<=at.min.x&&at.max.x<=this.max.x&&this.min.y<=at.min.y&&at.max.y<=this.max.y}getParameter(at,pt){return pt.set((at.x-this.min.x)/(this.max.x-this.min.x),(at.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(at){return!(at.max.x<this.min.x||at.min.x>this.max.x||at.max.y<this.min.y||at.min.y>this.max.y)}clampPoint(at,pt){return pt.copy(at).clamp(this.min,this.max)}distanceToPoint(at){return this.clampPoint(at,_vector$4).distanceTo(at)}intersect(at){return this.min.max(at.min),this.max.min(at.max),this.isEmpty()&&this.makeEmpty(),this}union(at){return this.min.min(at.min),this.max.max(at.max),this}translate(at){return this.min.add(at),this.max.add(at),this}equals(at){return at.min.equals(this.min)&&at.max.equals(this.max)}}const _startP=new Vector3,_startEnd=new Vector3;class Line3{constructor(at=new Vector3,pt=new Vector3){this.start=at,this.end=pt}set(at,pt){return this.start.copy(at),this.end.copy(pt),this}copy(at){return this.start.copy(at.start),this.end.copy(at.end),this}getCenter(at){return at.addVectors(this.start,this.end).multiplyScalar(.5)}delta(at){return at.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(at,pt){return this.delta(pt).multiplyScalar(at).add(this.start)}closestPointToPointParameter(at,pt){_startP.subVectors(at,this.start),_startEnd.subVectors(this.end,this.start);const vt=_startEnd.dot(_startEnd);let $t=_startEnd.dot(_startP)/vt;return pt&&($t=clamp$3($t,0,1)),$t}closestPointToPoint(at,pt,vt){const wt=this.closestPointToPointParameter(at,pt);return this.delta(vt).multiplyScalar(wt).add(this.start)}applyMatrix4(at){return this.start.applyMatrix4(at),this.end.applyMatrix4(at),this}equals(at){return at.start.equals(this.start)&&at.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const _vector$3=new Vector3;class SpotLightHelper extends Object3D{constructor(at,pt){super(),this.light=at,this.matrixAutoUpdate=!1,this.color=pt,this.type="SpotLightHelper";const vt=new BufferGeometry,wt=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let Tt=0,Lt=1,Ft=32;Tt<Ft;Tt++,Lt++){const Ct=Tt/Ft*Math.PI*2,Ht=Lt/Ft*Math.PI*2;wt.push(Math.cos(Ct),Math.sin(Ct),1,Math.cos(Ht),Math.sin(Ht),1)}vt.setAttribute("position",new Float32BufferAttribute(wt,3));const $t=new LineBasicMaterial({fog:!1,toneMapped:!1});this.cone=new LineSegments(vt,$t),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const at=this.light.distance?this.light.distance:1e3,pt=at*Math.tan(this.light.angle);this.cone.scale.set(pt,pt,at),_vector$3.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(_vector$3),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const _vector$2=new Vector3,_boneMatrix=new Matrix4,_matrixWorldInv=new Matrix4;class SkeletonHelper extends LineSegments{constructor(at){const pt=getBoneList(at),vt=new BufferGeometry,wt=[],$t=[],Tt=new Color$1(0,0,1),Lt=new Color$1(0,1,0);for(let Ct=0;Ct<pt.length;Ct++){const Ht=pt[Ct];Ht.parent&&Ht.parent.isBone&&(wt.push(0,0,0),wt.push(0,0,0),$t.push(Tt.r,Tt.g,Tt.b),$t.push(Lt.r,Lt.g,Lt.b))}vt.setAttribute("position",new Float32BufferAttribute(wt,3)),vt.setAttribute("color",new Float32BufferAttribute($t,3));const Ft=new LineBasicMaterial({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(vt,Ft),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=at,this.bones=pt,this.matrix=at.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(at){const pt=this.bones,vt=this.geometry,wt=vt.getAttribute("position");_matrixWorldInv.copy(this.root.matrixWorld).invert();for(let $t=0,Tt=0;$t<pt.length;$t++){const Lt=pt[$t];Lt.parent&&Lt.parent.isBone&&(_boneMatrix.multiplyMatrices(_matrixWorldInv,Lt.matrixWorld),_vector$2.setFromMatrixPosition(_boneMatrix),wt.setXYZ(Tt,_vector$2.x,_vector$2.y,_vector$2.z),_boneMatrix.multiplyMatrices(_matrixWorldInv,Lt.parent.matrixWorld),_vector$2.setFromMatrixPosition(_boneMatrix),wt.setXYZ(Tt+1,_vector$2.x,_vector$2.y,_vector$2.z),Tt+=2)}vt.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(at)}dispose(){this.geometry.dispose(),this.material.dispose()}}function getBoneList(st){const at=[];st.isBone===!0&&at.push(st);for(let pt=0;pt<st.children.length;pt++)at.push.apply(at,getBoneList(st.children[pt]));return at}class PointLightHelper extends Mesh{constructor(at,pt,vt){const wt=new SphereGeometry(pt,4,2),$t=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1});super(wt,$t),this.light=at,this.color=vt,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const _vector$1=new Vector3,_color1=new Color$1,_color2=new Color$1;class HemisphereLightHelper extends Object3D{constructor(at,pt,vt){super(),this.light=at,this.matrix=at.matrixWorld,this.matrixAutoUpdate=!1,this.color=vt,this.type="HemisphereLightHelper";const wt=new OctahedronGeometry(pt);wt.rotateY(Math.PI*.5),this.material=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const $t=wt.getAttribute("position"),Tt=new Float32Array($t.count*3);wt.setAttribute("color",new BufferAttribute(Tt,3)),this.add(new Mesh(wt,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const at=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const pt=at.geometry.getAttribute("color");_color1.copy(this.light.color),_color2.copy(this.light.groundColor);for(let vt=0,wt=pt.count;vt<wt;vt++){const $t=vt<wt/2?_color1:_color2;pt.setXYZ(vt,$t.r,$t.g,$t.b)}pt.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),at.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate())}}class GridHelper extends LineSegments{constructor(at=10,pt=10,vt=4473924,wt=8947848){vt=new Color$1(vt),wt=new Color$1(wt);const $t=pt/2,Tt=at/pt,Lt=at/2,Ft=[],Ct=[];for(let jt=0,qt=0,Kt=-Lt;jt<=pt;jt++,Kt+=Tt){Ft.push(-Lt,0,Kt,Lt,0,Kt),Ft.push(Kt,0,-Lt,Kt,0,Lt);const An=jt===$t?vt:wt;An.toArray(Ct,qt),qt+=3,An.toArray(Ct,qt),qt+=3,An.toArray(Ct,qt),qt+=3,An.toArray(Ct,qt),qt+=3}const Ht=new BufferGeometry;Ht.setAttribute("position",new Float32BufferAttribute(Ft,3)),Ht.setAttribute("color",new Float32BufferAttribute(Ct,3));const Gt=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(Ht,Gt),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class PolarGridHelper extends LineSegments{constructor(at=10,pt=16,vt=8,wt=64,$t=4473924,Tt=8947848){$t=new Color$1($t),Tt=new Color$1(Tt);const Lt=[],Ft=[];if(pt>1)for(let Gt=0;Gt<pt;Gt++){const jt=Gt/pt*(Math.PI*2),qt=Math.sin(jt)*at,Kt=Math.cos(jt)*at;Lt.push(0,0,0),Lt.push(qt,0,Kt);const An=Gt&1?$t:Tt;Ft.push(An.r,An.g,An.b),Ft.push(An.r,An.g,An.b)}for(let Gt=0;Gt<vt;Gt++){const jt=Gt&1?$t:Tt,qt=at-at/vt*Gt;for(let Kt=0;Kt<wt;Kt++){let An=Kt/wt*(Math.PI*2),Sn=Math.sin(An)*qt,wn=Math.cos(An)*qt;Lt.push(Sn,0,wn),Ft.push(jt.r,jt.g,jt.b),An=(Kt+1)/wt*(Math.PI*2),Sn=Math.sin(An)*qt,wn=Math.cos(An)*qt,Lt.push(Sn,0,wn),Ft.push(jt.r,jt.g,jt.b)}}const Ct=new BufferGeometry;Ct.setAttribute("position",new Float32BufferAttribute(Lt,3)),Ct.setAttribute("color",new Float32BufferAttribute(Ft,3));const Ht=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(Ct,Ht),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const _v1=new Vector3,_v2=new Vector3,_v3=new Vector3;class DirectionalLightHelper extends Object3D{constructor(at,pt,vt){super(),this.light=at,this.matrix=at.matrixWorld,this.matrixAutoUpdate=!1,this.color=vt,this.type="DirectionalLightHelper",pt===void 0&&(pt=1);let wt=new BufferGeometry;wt.setAttribute("position",new Float32BufferAttribute([-pt,pt,0,pt,pt,0,pt,-pt,0,-pt,-pt,0,-pt,pt,0],3));const $t=new LineBasicMaterial({fog:!1,toneMapped:!1});this.lightPlane=new Line(wt,$t),this.add(this.lightPlane),wt=new BufferGeometry,wt.setAttribute("position",new Float32BufferAttribute([0,0,0,0,0,1],3)),this.targetLine=new Line(wt,$t),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),_v1.setFromMatrixPosition(this.light.matrixWorld),_v2.setFromMatrixPosition(this.light.target.matrixWorld),_v3.subVectors(_v2,_v1),this.lightPlane.lookAt(_v2),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(_v2),this.targetLine.scale.z=_v3.length()}}const _vector=new Vector3,_camera=new Camera;class CameraHelper extends LineSegments{constructor(at){const pt=new BufferGeometry,vt=new LineBasicMaterial({color:16777215,vertexColors:!0,toneMapped:!1}),wt=[],$t=[],Tt={};Lt("n1","n2"),Lt("n2","n4"),Lt("n4","n3"),Lt("n3","n1"),Lt("f1","f2"),Lt("f2","f4"),Lt("f4","f3"),Lt("f3","f1"),Lt("n1","f1"),Lt("n2","f2"),Lt("n3","f3"),Lt("n4","f4"),Lt("p","n1"),Lt("p","n2"),Lt("p","n3"),Lt("p","n4"),Lt("u1","u2"),Lt("u2","u3"),Lt("u3","u1"),Lt("c","t"),Lt("p","c"),Lt("cn1","cn2"),Lt("cn3","cn4"),Lt("cf1","cf2"),Lt("cf3","cf4");function Lt(Kt,An){Ft(Kt),Ft(An)}function Ft(Kt){wt.push(0,0,0),$t.push(0,0,0),Tt[Kt]===void 0&&(Tt[Kt]=[]),Tt[Kt].push(wt.length/3-1)}pt.setAttribute("position",new Float32BufferAttribute(wt,3)),pt.setAttribute("color",new Float32BufferAttribute($t,3)),super(pt,vt),this.type="CameraHelper",this.camera=at,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=at.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=Tt,this.update();const Ct=new Color$1(16755200),Ht=new Color$1(16711680),Gt=new Color$1(43775),jt=new Color$1(16777215),qt=new Color$1(3355443);this.setColors(Ct,Ht,Gt,jt,qt)}setColors(at,pt,vt,wt,$t){const Lt=this.geometry.getAttribute("color");Lt.setXYZ(0,at.r,at.g,at.b),Lt.setXYZ(1,at.r,at.g,at.b),Lt.setXYZ(2,at.r,at.g,at.b),Lt.setXYZ(3,at.r,at.g,at.b),Lt.setXYZ(4,at.r,at.g,at.b),Lt.setXYZ(5,at.r,at.g,at.b),Lt.setXYZ(6,at.r,at.g,at.b),Lt.setXYZ(7,at.r,at.g,at.b),Lt.setXYZ(8,at.r,at.g,at.b),Lt.setXYZ(9,at.r,at.g,at.b),Lt.setXYZ(10,at.r,at.g,at.b),Lt.setXYZ(11,at.r,at.g,at.b),Lt.setXYZ(12,at.r,at.g,at.b),Lt.setXYZ(13,at.r,at.g,at.b),Lt.setXYZ(14,at.r,at.g,at.b),Lt.setXYZ(15,at.r,at.g,at.b),Lt.setXYZ(16,at.r,at.g,at.b),Lt.setXYZ(17,at.r,at.g,at.b),Lt.setXYZ(18,at.r,at.g,at.b),Lt.setXYZ(19,at.r,at.g,at.b),Lt.setXYZ(20,at.r,at.g,at.b),Lt.setXYZ(21,at.r,at.g,at.b),Lt.setXYZ(22,at.r,at.g,at.b),Lt.setXYZ(23,at.r,at.g,at.b),Lt.setXYZ(24,pt.r,pt.g,pt.b),Lt.setXYZ(25,pt.r,pt.g,pt.b),Lt.setXYZ(26,pt.r,pt.g,pt.b),Lt.setXYZ(27,pt.r,pt.g,pt.b),Lt.setXYZ(28,pt.r,pt.g,pt.b),Lt.setXYZ(29,pt.r,pt.g,pt.b),Lt.setXYZ(30,pt.r,pt.g,pt.b),Lt.setXYZ(31,pt.r,pt.g,pt.b),Lt.setXYZ(32,vt.r,vt.g,vt.b),Lt.setXYZ(33,vt.r,vt.g,vt.b),Lt.setXYZ(34,vt.r,vt.g,vt.b),Lt.setXYZ(35,vt.r,vt.g,vt.b),Lt.setXYZ(36,vt.r,vt.g,vt.b),Lt.setXYZ(37,vt.r,vt.g,vt.b),Lt.setXYZ(38,wt.r,wt.g,wt.b),Lt.setXYZ(39,wt.r,wt.g,wt.b),Lt.setXYZ(40,$t.r,$t.g,$t.b),Lt.setXYZ(41,$t.r,$t.g,$t.b),Lt.setXYZ(42,$t.r,$t.g,$t.b),Lt.setXYZ(43,$t.r,$t.g,$t.b),Lt.setXYZ(44,$t.r,$t.g,$t.b),Lt.setXYZ(45,$t.r,$t.g,$t.b),Lt.setXYZ(46,$t.r,$t.g,$t.b),Lt.setXYZ(47,$t.r,$t.g,$t.b),Lt.setXYZ(48,$t.r,$t.g,$t.b),Lt.setXYZ(49,$t.r,$t.g,$t.b),Lt.needsUpdate=!0}update(){const at=this.geometry,pt=this.pointMap,vt=1,wt=1;_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),setPoint("c",pt,at,_camera,0,0,-1),setPoint("t",pt,at,_camera,0,0,1),setPoint("n1",pt,at,_camera,-vt,-wt,-1),setPoint("n2",pt,at,_camera,vt,-wt,-1),setPoint("n3",pt,at,_camera,-vt,wt,-1),setPoint("n4",pt,at,_camera,vt,wt,-1),setPoint("f1",pt,at,_camera,-vt,-wt,1),setPoint("f2",pt,at,_camera,vt,-wt,1),setPoint("f3",pt,at,_camera,-vt,wt,1),setPoint("f4",pt,at,_camera,vt,wt,1),setPoint("u1",pt,at,_camera,vt*.7,wt*1.1,-1),setPoint("u2",pt,at,_camera,-vt*.7,wt*1.1,-1),setPoint("u3",pt,at,_camera,0,wt*2,-1),setPoint("cf1",pt,at,_camera,-vt,0,1),setPoint("cf2",pt,at,_camera,vt,0,1),setPoint("cf3",pt,at,_camera,0,-wt,1),setPoint("cf4",pt,at,_camera,0,wt,1),setPoint("cn1",pt,at,_camera,-vt,0,-1),setPoint("cn2",pt,at,_camera,vt,0,-1),setPoint("cn3",pt,at,_camera,0,-wt,-1),setPoint("cn4",pt,at,_camera,0,wt,-1),at.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function setPoint(st,at,pt,vt,wt,$t,Tt){_vector.set(wt,$t,Tt).unproject(vt);const Lt=at[st];if(Lt!==void 0){const Ft=pt.getAttribute("position");for(let Ct=0,Ht=Lt.length;Ct<Ht;Ct++)Ft.setXYZ(Lt[Ct],_vector.x,_vector.y,_vector.z)}}const _box=new Box3;class BoxHelper extends LineSegments{constructor(at,pt=16776960){const vt=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),wt=new Float32Array(8*3),$t=new BufferGeometry;$t.setIndex(new BufferAttribute(vt,1)),$t.setAttribute("position",new BufferAttribute(wt,3)),super($t,new LineBasicMaterial({color:pt,toneMapped:!1})),this.object=at,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(at){if(at!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&_box.setFromObject(this.object),_box.isEmpty())return;const pt=_box.min,vt=_box.max,wt=this.geometry.attributes.position,$t=wt.array;$t[0]=vt.x,$t[1]=vt.y,$t[2]=vt.z,$t[3]=pt.x,$t[4]=vt.y,$t[5]=vt.z,$t[6]=pt.x,$t[7]=pt.y,$t[8]=vt.z,$t[9]=vt.x,$t[10]=pt.y,$t[11]=vt.z,$t[12]=vt.x,$t[13]=vt.y,$t[14]=pt.z,$t[15]=pt.x,$t[16]=vt.y,$t[17]=pt.z,$t[18]=pt.x,$t[19]=pt.y,$t[20]=pt.z,$t[21]=vt.x,$t[22]=pt.y,$t[23]=pt.z,wt.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(at){return this.object=at,this.update(),this}copy(at,pt){return super.copy(at,pt),this.object=at.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class Box3Helper extends LineSegments{constructor(at,pt=16776960){const vt=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),wt=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],$t=new BufferGeometry;$t.setIndex(new BufferAttribute(vt,1)),$t.setAttribute("position",new Float32BufferAttribute(wt,3)),super($t,new LineBasicMaterial({color:pt,toneMapped:!1})),this.box=at,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(at){const pt=this.box;pt.isEmpty()||(pt.getCenter(this.position),pt.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(at))}dispose(){this.geometry.dispose(),this.material.dispose()}}class PlaneHelper extends Line{constructor(at,pt=1,vt=16776960){const wt=vt,$t=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],Tt=new BufferGeometry;Tt.setAttribute("position",new Float32BufferAttribute($t,3)),Tt.computeBoundingSphere(),super(Tt,new LineBasicMaterial({color:wt,toneMapped:!1})),this.type="PlaneHelper",this.plane=at,this.size=pt;const Lt=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],Ft=new BufferGeometry;Ft.setAttribute("position",new Float32BufferAttribute(Lt,3)),Ft.computeBoundingSphere(),this.add(new Mesh(Ft,new MeshBasicMaterial({color:wt,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(at){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(at)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const _axis=new Vector3;let _lineGeometry,_coneGeometry;class ArrowHelper extends Object3D{constructor(at=new Vector3(0,0,1),pt=new Vector3(0,0,0),vt=1,wt=16776960,$t=vt*.2,Tt=$t*.2){super(),this.type="ArrowHelper",_lineGeometry===void 0&&(_lineGeometry=new BufferGeometry,_lineGeometry.setAttribute("position",new Float32BufferAttribute([0,0,0,0,1,0],3)),_coneGeometry=new CylinderGeometry(0,.5,1,5,1),_coneGeometry.translate(0,-.5,0)),this.position.copy(pt),this.line=new Line(_lineGeometry,new LineBasicMaterial({color:wt,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Mesh(_coneGeometry,new MeshBasicMaterial({color:wt,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(at),this.setLength(vt,$t,Tt)}setDirection(at){if(at.y>.99999)this.quaternion.set(0,0,0,1);else if(at.y<-.99999)this.quaternion.set(1,0,0,0);else{_axis.set(at.z,0,-at.x).normalize();const pt=Math.acos(at.y);this.quaternion.setFromAxisAngle(_axis,pt)}}setLength(at,pt=at*.2,vt=pt*.2){this.line.scale.set(1,Math.max(1e-4,at-pt),1),this.line.updateMatrix(),this.cone.scale.set(vt,pt,vt),this.cone.position.y=at,this.cone.updateMatrix()}setColor(at){this.line.material.color.set(at),this.cone.material.color.set(at)}copy(at){return super.copy(at,!1),this.line.copy(at.line),this.cone.copy(at.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class AxesHelper extends LineSegments{constructor(at=1){const pt=[0,0,0,at,0,0,0,0,0,0,at,0,0,0,0,0,0,at],vt=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],wt=new BufferGeometry;wt.setAttribute("position",new Float32BufferAttribute(pt,3)),wt.setAttribute("color",new Float32BufferAttribute(vt,3));const $t=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(wt,$t),this.type="AxesHelper"}setColors(at,pt,vt){const wt=new Color$1,$t=this.geometry.attributes.color.array;return wt.set(at),wt.toArray($t,0),wt.toArray($t,3),wt.set(pt),wt.toArray($t,6),wt.toArray($t,9),wt.set(vt),wt.toArray($t,12),wt.toArray($t,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class ShapePath{constructor(){this.type="ShapePath",this.color=new Color$1,this.subPaths=[],this.currentPath=null}moveTo(at,pt){return this.currentPath=new Path,this.subPaths.push(this.currentPath),this.currentPath.moveTo(at,pt),this}lineTo(at,pt){return this.currentPath.lineTo(at,pt),this}quadraticCurveTo(at,pt,vt,wt){return this.currentPath.quadraticCurveTo(at,pt,vt,wt),this}bezierCurveTo(at,pt,vt,wt,$t,Tt){return this.currentPath.bezierCurveTo(at,pt,vt,wt,$t,Tt),this}splineThru(at){return this.currentPath.splineThru(at),this}toShapes(at){function pt(wn){const In=[];for(let tr=0,rr=wn.length;tr<rr;tr++){const Hr=wn[tr],qr=new Shape;qr.curves=Hr.curves,In.push(qr)}return In}function vt(wn,In){const tr=In.length;let rr=!1;for(let Hr=tr-1,qr=0;qr<tr;Hr=qr++){let Zr=In[Hr],Bo=In[qr],Xo=Bo.x-Zr.x,Kr=Bo.y-Zr.y;if(Math.abs(Kr)>Number.EPSILON){if(Kr<0&&(Zr=In[qr],Xo=-Xo,Bo=In[Hr],Kr=-Kr),wn.y<Zr.y||wn.y>Bo.y)continue;if(wn.y===Zr.y){if(wn.x===Zr.x)return!0}else{const ko=Kr*(wn.x-Zr.x)-Xo*(wn.y-Zr.y);if(ko===0)return!0;if(ko<0)continue;rr=!rr}}else{if(wn.y!==Zr.y)continue;if(Bo.x<=wn.x&&wn.x<=Zr.x||Zr.x<=wn.x&&wn.x<=Bo.x)return!0}}return rr}const wt=ShapeUtils.isClockWise,$t=this.subPaths;if($t.length===0)return[];let Tt,Lt,Ft;const Ct=[];if($t.length===1)return Lt=$t[0],Ft=new Shape,Ft.curves=Lt.curves,Ct.push(Ft),Ct;let Ht=!wt($t[0].getPoints());Ht=at?!Ht:Ht;const Gt=[],jt=[];let qt=[],Kt=0,An;jt[Kt]=void 0,qt[Kt]=[];for(let wn=0,In=$t.length;wn<In;wn++)Lt=$t[wn],An=Lt.getPoints(),Tt=wt(An),Tt=at?!Tt:Tt,Tt?(!Ht&&jt[Kt]&&Kt++,jt[Kt]={s:new Shape,p:An},jt[Kt].s.curves=Lt.curves,Ht&&Kt++,qt[Kt]=[]):qt[Kt].push({h:Lt,p:An[0]});if(!jt[0])return pt($t);if(jt.length>1){let wn=!1,In=0;for(let tr=0,rr=jt.length;tr<rr;tr++)Gt[tr]=[];for(let tr=0,rr=jt.length;tr<rr;tr++){const Hr=qt[tr];for(let qr=0;qr<Hr.length;qr++){const Zr=Hr[qr];let Bo=!0;for(let Xo=0;Xo<jt.length;Xo++)vt(Zr.p,jt[Xo].p)&&(tr!==Xo&&In++,Bo?(Bo=!1,Gt[Xo].push(Zr)):wn=!0);Bo&&Gt[tr].push(Zr)}}In>0&&wn===!1&&(qt=Gt)}let Sn;for(let wn=0,In=jt.length;wn<In;wn++){Ft=jt[wn].s,Ct.push(Ft),Sn=qt[wn];for(let tr=0,rr=Sn.length;tr<rr;tr++)Ft.holes.push(Sn[tr].h)}return Ct}}class WebGLMultipleRenderTargets extends WebGLRenderTarget{constructor(at=1,pt=1,vt=1,wt={}){console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'),super(at,pt,{...wt,count:vt}),this.isWebGLMultipleRenderTargets=!0}get texture(){return this.textures}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:REVISION}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=REVISION);const THREE=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping,AddEquation,AddOperation,AdditiveAnimationBlendMode,AdditiveBlending,AgXToneMapping,AlphaFormat,AlwaysCompare,AlwaysDepth,AlwaysStencilFunc,AmbientLight,AnimationAction,AnimationClip,AnimationLoader,AnimationMixer,AnimationObjectGroup,AnimationUtils,ArcCurve,ArrayCamera,ArrowHelper,AttachedBindMode,Audio,AudioAnalyser,AudioContext,AudioListener,AudioLoader,AxesHelper,BackSide,BasicDepthPacking,BasicShadowMap,BatchedMesh,Bone,BooleanKeyframeTrack,Box2,Box3,Box3Helper,BoxGeometry,BoxHelper,BufferAttribute,BufferGeometry,BufferGeometryLoader,ByteType,Cache,Camera,CameraHelper,CanvasTexture,CapsuleGeometry,CatmullRomCurve3,CineonToneMapping,CircleGeometry,ClampToEdgeWrapping,Clock,Color:Color$1,ColorKeyframeTrack,ColorManagement,CompressedArrayTexture,CompressedCubeTexture,CompressedTexture,CompressedTextureLoader,ConeGeometry,ConstantAlphaFactor,ConstantColorFactor,CubeCamera,CubeReflectionMapping,CubeRefractionMapping,CubeTexture,CubeTextureLoader,CubeUVReflectionMapping,CubicBezierCurve,CubicBezierCurve3,CubicInterpolant,CullFaceBack,CullFaceFront,CullFaceFrontBack,CullFaceNone,Curve,CurvePath,CustomBlending,CustomToneMapping,CylinderGeometry,Cylindrical,Data3DTexture,DataArrayTexture,DataTexture,DataTextureLoader,DataUtils,DecrementStencilOp,DecrementWrapStencilOp,DefaultLoadingManager,DepthFormat,DepthStencilFormat,DepthTexture,DetachedBindMode,DirectionalLight,DirectionalLightHelper,DiscreteInterpolant,DisplayP3ColorSpace,DodecahedronGeometry,DoubleSide,DstAlphaFactor,DstColorFactor,DynamicCopyUsage,DynamicDrawUsage,DynamicReadUsage,EdgesGeometry,EllipseCurve,EqualCompare,EqualDepth,EqualStencilFunc,EquirectangularReflectionMapping,EquirectangularRefractionMapping,Euler,EventDispatcher,ExtrudeGeometry,FileLoader,Float16BufferAttribute,Float32BufferAttribute,FloatType,Fog,FogExp2,FramebufferTexture,FrontSide,Frustum,GLBufferAttribute,GLSL1,GLSL3,GreaterCompare,GreaterDepth,GreaterEqualCompare,GreaterEqualDepth,GreaterEqualStencilFunc,GreaterStencilFunc,GridHelper,Group,HalfFloatType,HemisphereLight,HemisphereLightHelper,IcosahedronGeometry,ImageBitmapLoader,ImageLoader,ImageUtils,IncrementStencilOp,IncrementWrapStencilOp,InstancedBufferAttribute,InstancedBufferGeometry,InstancedInterleavedBuffer,InstancedMesh,Int16BufferAttribute,Int32BufferAttribute,Int8BufferAttribute,IntType,InterleavedBuffer,InterleavedBufferAttribute,Interpolant,InterpolateDiscrete,InterpolateLinear,InterpolateSmooth,InvertStencilOp,KeepStencilOp,KeyframeTrack,LOD,LatheGeometry,Layers,LessCompare,LessDepth,LessEqualCompare,LessEqualDepth,LessEqualStencilFunc,LessStencilFunc,Light,LightProbe,Line,Line3,LineBasicMaterial,LineCurve,LineCurve3,LineDashedMaterial,LineLoop,LineSegments,LinearDisplayP3ColorSpace,LinearFilter,LinearInterpolant,LinearMipMapLinearFilter,LinearMipMapNearestFilter,LinearMipmapLinearFilter,LinearMipmapNearestFilter,LinearSRGBColorSpace:LinearSRGBColorSpace$1,LinearToneMapping,LinearTransfer,Loader,LoaderUtils,LoadingManager,LoopOnce,LoopPingPong,LoopRepeat,LuminanceAlphaFormat,LuminanceFormat,MOUSE,Material,MaterialLoader,MathUtils,Matrix3,Matrix4,MaxEquation,Mesh,MeshBasicMaterial,MeshDepthMaterial,MeshDistanceMaterial,MeshLambertMaterial,MeshMatcapMaterial,MeshNormalMaterial,MeshPhongMaterial,MeshPhysicalMaterial,MeshStandardMaterial,MeshToonMaterial,MinEquation,MirroredRepeatWrapping,MixOperation,MultiplyBlending,MultiplyOperation,NearestFilter,NearestMipMapLinearFilter,NearestMipMapNearestFilter,NearestMipmapLinearFilter,NearestMipmapNearestFilter,NeutralToneMapping,NeverCompare,NeverDepth,NeverStencilFunc,NoBlending,NoColorSpace,NoToneMapping,NormalAnimationBlendMode,NormalBlending,NotEqualCompare,NotEqualDepth,NotEqualStencilFunc,NumberKeyframeTrack,Object3D,ObjectLoader,ObjectSpaceNormalMap,OctahedronGeometry,OneFactor,OneMinusConstantAlphaFactor,OneMinusConstantColorFactor,OneMinusDstAlphaFactor,OneMinusDstColorFactor,OneMinusSrcAlphaFactor,OneMinusSrcColorFactor,OrthographicCamera,P3Primaries,PCFShadowMap,PCFSoftShadowMap,PMREMGenerator,Path,PerspectiveCamera,Plane,PlaneGeometry,PlaneHelper,PointLight,PointLightHelper,Points,PointsMaterial,PolarGridHelper,PolyhedronGeometry,PositionalAudio,PropertyBinding,PropertyMixer,QuadraticBezierCurve,QuadraticBezierCurve3,Quaternion,QuaternionKeyframeTrack,QuaternionLinearInterpolant,RED_GREEN_RGTC2_Format,RED_RGTC1_Format,REVISION,RGBADepthPacking,RGBAFormat,RGBAIntegerFormat,RGBA_ASTC_10x10_Format,RGBA_ASTC_10x5_Format,RGBA_ASTC_10x6_Format,RGBA_ASTC_10x8_Format,RGBA_ASTC_12x10_Format,RGBA_ASTC_12x12_Format,RGBA_ASTC_4x4_Format,RGBA_ASTC_5x4_Format,RGBA_ASTC_5x5_Format,RGBA_ASTC_6x5_Format,RGBA_ASTC_6x6_Format,RGBA_ASTC_8x5_Format,RGBA_ASTC_8x6_Format,RGBA_ASTC_8x8_Format,RGBA_BPTC_Format,RGBA_ETC2_EAC_Format,RGBA_PVRTC_2BPPV1_Format,RGBA_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT1_Format,RGBA_S3TC_DXT3_Format,RGBA_S3TC_DXT5_Format,RGB_BPTC_SIGNED_Format,RGB_BPTC_UNSIGNED_Format,RGB_ETC1_Format,RGB_ETC2_Format,RGB_PVRTC_2BPPV1_Format,RGB_PVRTC_4BPPV1_Format,RGB_S3TC_DXT1_Format,RGFormat,RGIntegerFormat,RawShaderMaterial,Ray,Raycaster,Rec709Primaries,RectAreaLight,RedFormat,RedIntegerFormat,ReinhardToneMapping,RenderTarget,RepeatWrapping,ReplaceStencilOp,ReverseSubtractEquation,RingGeometry,SIGNED_RED_GREEN_RGTC2_Format,SIGNED_RED_RGTC1_Format,SRGBColorSpace:SRGBColorSpace$1,SRGBTransfer,Scene,ShaderChunk,ShaderLib,ShaderMaterial,ShadowMaterial,Shape,ShapeGeometry,ShapePath,ShapeUtils,ShortType,Skeleton,SkeletonHelper,SkinnedMesh,Source,Sphere,SphereGeometry,Spherical,SphericalHarmonics3,SplineCurve,SpotLight,SpotLightHelper,Sprite,SpriteMaterial,SrcAlphaFactor,SrcAlphaSaturateFactor,SrcColorFactor,StaticCopyUsage,StaticDrawUsage,StaticReadUsage,StereoCamera,StreamCopyUsage,StreamDrawUsage,StreamReadUsage,StringKeyframeTrack,SubtractEquation,SubtractiveBlending,TOUCH,TangentSpaceNormalMap,TetrahedronGeometry,Texture,TextureLoader,TorusGeometry,TorusKnotGeometry,Triangle,TriangleFanDrawMode,TriangleStripDrawMode,TrianglesDrawMode,TubeGeometry,UVMapping,Uint16BufferAttribute,Uint32BufferAttribute,Uint8BufferAttribute,Uint8ClampedBufferAttribute,Uniform,UniformsGroup,UniformsLib,UniformsUtils,UnsignedByteType,UnsignedInt248Type,UnsignedIntType,UnsignedShort4444Type,UnsignedShort5551Type,UnsignedShortType,VSMShadowMap,Vector2,Vector3,Vector4,VectorKeyframeTrack,VideoTexture,WebGL1Renderer,WebGL3DRenderTarget,WebGLArrayRenderTarget,WebGLCoordinateSystem,WebGLCubeRenderTarget,WebGLMultipleRenderTargets,WebGLRenderTarget,WebGLRenderer,WebGLUtils,WebGPUCoordinateSystem,WireframeGeometry,WrapAroundEnding,ZeroCurvatureEnding,ZeroFactor,ZeroSlopeEnding,ZeroStencilOp,_SRGBAFormat,createCanvasElement},Symbol.toStringTag,{value:"Module"}));var constants={exports:{}},reactReconcilerConstants_production_min={};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */reactReconcilerConstants_production_min.ConcurrentRoot=1;reactReconcilerConstants_production_min.ContinuousEventPriority=4;reactReconcilerConstants_production_min.DefaultEventPriority=16;reactReconcilerConstants_production_min.DiscreteEventPriority=1;reactReconcilerConstants_production_min.IdleEventPriority=536870912;reactReconcilerConstants_production_min.LegacyRoot=0;constants.exports=reactReconcilerConstants_production_min;var constantsExports=constants.exports;function createStore$1(st){let at;const pt=new Set,vt=(Ct,Ht)=>{const Gt=typeof Ct=="function"?Ct(at):Ct;if(Gt!==at){const jt=at;at=Ht?Gt:Object.assign({},at,Gt),pt.forEach(qt=>qt(at,jt))}},wt=()=>at,$t=(Ct,Ht=wt,Gt=Object.is)=>{console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");let jt=Ht(at);function qt(){const Kt=Ht(at);if(!Gt(jt,Kt)){const An=jt;Ct(jt=Kt,An)}}return pt.add(qt),()=>pt.delete(qt)},Ft={setState:vt,getState:wt,subscribe:(Ct,Ht,Gt)=>Ht||Gt?$t(Ct,Ht,Gt):(pt.add(Ct),()=>pt.delete(Ct)),destroy:()=>pt.clear()};return at=st(vt,wt,Ft),Ft}const isSSR=typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent),useIsomorphicLayoutEffect$1=isSSR?reactExports.useEffect:reactExports.useLayoutEffect;function create(st){const at=typeof st=="function"?createStore$1(st):st,pt=(vt=at.getState,wt=Object.is)=>{const[,$t]=reactExports.useReducer(Sn=>Sn+1,0),Tt=at.getState(),Lt=reactExports.useRef(Tt),Ft=reactExports.useRef(vt),Ct=reactExports.useRef(wt),Ht=reactExports.useRef(!1),Gt=reactExports.useRef();Gt.current===void 0&&(Gt.current=vt(Tt));let jt,qt=!1;(Lt.current!==Tt||Ft.current!==vt||Ct.current!==wt||Ht.current)&&(jt=vt(Tt),qt=!wt(Gt.current,jt)),useIsomorphicLayoutEffect$1(()=>{qt&&(Gt.current=jt),Lt.current=Tt,Ft.current=vt,Ct.current=wt,Ht.current=!1});const Kt=reactExports.useRef(Tt);useIsomorphicLayoutEffect$1(()=>{const Sn=()=>{try{const In=at.getState(),tr=Ft.current(In);Ct.current(Gt.current,tr)||(Lt.current=In,Gt.current=tr,$t())}catch{Ht.current=!0,$t()}},wn=at.subscribe(Sn);return at.getState()!==Kt.current&&Sn(),wn},[]);const An=qt?jt:Gt.current;return reactExports.useDebugValue(An),An};return Object.assign(pt,at),pt[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");const vt=[pt,at];return{next(){const wt=vt.length<=0;return{value:vt.shift(),done:wt}}}},pt}var reactReconciler={exports:{}},scheduler={exports:{}},scheduler_production_min={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(st){function at(n0,m0){var h0=n0.length;n0.push(m0);e:for(;0<h0;){var a0=h0-1>>>1,P0=n0[a0];if(0<wt(P0,m0))n0[a0]=m0,n0[h0]=P0,h0=a0;else break e}}function pt(n0){return n0.length===0?null:n0[0]}function vt(n0){if(n0.length===0)return null;var m0=n0[0],h0=n0.pop();if(h0!==m0){n0[0]=h0;e:for(var a0=0,P0=n0.length,V0=P0>>>1;a0<V0;){var B0=2*(a0+1)-1,W0=n0[B0],K0=B0+1,Ty=n0[K0];if(0>wt(W0,h0))K0<P0&&0>wt(Ty,W0)?(n0[a0]=Ty,n0[K0]=h0,a0=K0):(n0[a0]=W0,n0[B0]=h0,a0=B0);else if(K0<P0&&0>wt(Ty,h0))n0[a0]=Ty,n0[K0]=h0,a0=K0;else break e}}return m0}function wt(n0,m0){var h0=n0.sortIndex-m0.sortIndex;return h0!==0?h0:n0.id-m0.id}if(typeof performance=="object"&&typeof performance.now=="function"){var $t=performance;st.unstable_now=function(){return $t.now()}}else{var Tt=Date,Lt=Tt.now();st.unstable_now=function(){return Tt.now()-Lt}}var Ft=[],Ct=[],Ht=1,Gt=null,jt=3,qt=!1,Kt=!1,An=!1,Sn=typeof setTimeout=="function"?setTimeout:null,wn=typeof clearTimeout=="function"?clearTimeout:null,In=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function tr(n0){for(var m0=pt(Ct);m0!==null;){if(m0.callback===null)vt(Ct);else if(m0.startTime<=n0)vt(Ct),m0.sortIndex=m0.expirationTime,at(Ft,m0);else break;m0=pt(Ct)}}function rr(n0){if(An=!1,tr(n0),!Kt)if(pt(Ft)!==null)Kt=!0,t0(Hr);else{var m0=pt(Ct);m0!==null&&E0(rr,m0.startTime-n0)}}function Hr(n0,m0){Kt=!1,An&&(An=!1,wn(Bo),Bo=-1),qt=!0;var h0=jt;try{for(tr(m0),Gt=pt(Ft);Gt!==null&&(!(Gt.expirationTime>m0)||n0&&!ko());){var a0=Gt.callback;if(typeof a0=="function"){Gt.callback=null,jt=Gt.priorityLevel;var P0=a0(Gt.expirationTime<=m0);m0=st.unstable_now(),typeof P0=="function"?Gt.callback=P0:Gt===pt(Ft)&&vt(Ft),tr(m0)}else vt(Ft);Gt=pt(Ft)}if(Gt!==null)var V0=!0;else{var B0=pt(Ct);B0!==null&&E0(rr,B0.startTime-m0),V0=!1}return V0}finally{Gt=null,jt=h0,qt=!1}}var qr=!1,Zr=null,Bo=-1,Xo=5,Kr=-1;function ko(){return!(st.unstable_now()-Kr<Xo)}function f0(){if(Zr!==null){var n0=st.unstable_now();Kr=n0;var m0=!0;try{m0=Zr(!0,n0)}finally{m0?x0():(qr=!1,Zr=null)}}else qr=!1}var x0;if(typeof In=="function")x0=function(){In(f0)};else if(typeof MessageChannel<"u"){var l0=new MessageChannel,T0=l0.port2;l0.port1.onmessage=f0,x0=function(){T0.postMessage(null)}}else x0=function(){Sn(f0,0)};function t0(n0){Zr=n0,qr||(qr=!0,x0())}function E0(n0,m0){Bo=Sn(function(){n0(st.unstable_now())},m0)}st.unstable_IdlePriority=5,st.unstable_ImmediatePriority=1,st.unstable_LowPriority=4,st.unstable_NormalPriority=3,st.unstable_Profiling=null,st.unstable_UserBlockingPriority=2,st.unstable_cancelCallback=function(n0){n0.callback=null},st.unstable_continueExecution=function(){Kt||qt||(Kt=!0,t0(Hr))},st.unstable_forceFrameRate=function(n0){0>n0||125<n0?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):Xo=0<n0?Math.floor(1e3/n0):5},st.unstable_getCurrentPriorityLevel=function(){return jt},st.unstable_getFirstCallbackNode=function(){return pt(Ft)},st.unstable_next=function(n0){switch(jt){case 1:case 2:case 3:var m0=3;break;default:m0=jt}var h0=jt;jt=m0;try{return n0()}finally{jt=h0}},st.unstable_pauseExecution=function(){},st.unstable_requestPaint=function(){},st.unstable_runWithPriority=function(n0,m0){switch(n0){case 1:case 2:case 3:case 4:case 5:break;default:n0=3}var h0=jt;jt=n0;try{return m0()}finally{jt=h0}},st.unstable_scheduleCallback=function(n0,m0,h0){var a0=st.unstable_now();switch(typeof h0=="object"&&h0!==null?(h0=h0.delay,h0=typeof h0=="number"&&0<h0?a0+h0:a0):h0=a0,n0){case 1:var P0=-1;break;case 2:P0=250;break;case 5:P0=1073741823;break;case 4:P0=1e4;break;default:P0=5e3}return P0=h0+P0,n0={id:Ht++,callback:m0,priorityLevel:n0,startTime:h0,expirationTime:P0,sortIndex:-1},h0>a0?(n0.sortIndex=h0,at(Ct,n0),pt(Ft)===null&&n0===pt(Ct)&&(An?(wn(Bo),Bo=-1):An=!0,E0(rr,h0-a0))):(n0.sortIndex=P0,at(Ft,n0),Kt||qt||(Kt=!0,t0(Hr))),n0},st.unstable_shouldYield=ko,st.unstable_wrapCallback=function(n0){var m0=jt;return function(){var h0=jt;jt=m0;try{return n0.apply(this,arguments)}finally{jt=h0}}}})(scheduler_production_min);scheduler.exports=scheduler_production_min;var schedulerExports=scheduler.exports;/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var reactReconciler_production_min=function(at){var pt={},vt=reactExports,wt=schedulerExports,$t=Object.assign;function Tt(_n){for(var xn="https://reactjs.org/docs/error-decoder.html?invariant="+_n,nr=1;nr<arguments.length;nr++)xn+="&args[]="+encodeURIComponent(arguments[nr]);return"Minified React error #"+_n+"; visit "+xn+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var Lt=vt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,Ft=Symbol.for("react.element"),Ct=Symbol.for("react.portal"),Ht=Symbol.for("react.fragment"),Gt=Symbol.for("react.strict_mode"),jt=Symbol.for("react.profiler"),qt=Symbol.for("react.provider"),Kt=Symbol.for("react.context"),An=Symbol.for("react.forward_ref"),Sn=Symbol.for("react.suspense"),wn=Symbol.for("react.suspense_list"),In=Symbol.for("react.memo"),tr=Symbol.for("react.lazy"),rr=Symbol.for("react.offscreen"),Hr=Symbol.iterator;function qr(_n){return _n===null||typeof _n!="object"?null:(_n=Hr&&_n[Hr]||_n["@@iterator"],typeof _n=="function"?_n:null)}function Zr(_n){if(_n==null)return null;if(typeof _n=="function")return _n.displayName||_n.name||null;if(typeof _n=="string")return _n;switch(_n){case Ht:return"Fragment";case Ct:return"Portal";case jt:return"Profiler";case Gt:return"StrictMode";case Sn:return"Suspense";case wn:return"SuspenseList"}if(typeof _n=="object")switch(_n.$$typeof){case Kt:return(_n.displayName||"Context")+".Consumer";case qt:return(_n._context.displayName||"Context")+".Provider";case An:var xn=_n.render;return _n=_n.displayName,_n||(_n=xn.displayName||xn.name||"",_n=_n!==""?"ForwardRef("+_n+")":"ForwardRef"),_n;case In:return xn=_n.displayName||null,xn!==null?xn:Zr(_n.type)||"Memo";case tr:xn=_n._payload,_n=_n._init;try{return Zr(_n(xn))}catch{}}return null}function Bo(_n){var xn=_n.type;switch(_n.tag){case 24:return"Cache";case 9:return(xn.displayName||"Context")+".Consumer";case 10:return(xn._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return _n=xn.render,_n=_n.displayName||_n.name||"",xn.displayName||(_n!==""?"ForwardRef("+_n+")":"ForwardRef");case 7:return"Fragment";case 5:return xn;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Zr(xn);case 8:return xn===Gt?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof xn=="function")return xn.displayName||xn.name||null;if(typeof xn=="string")return xn}return null}function Xo(_n){var xn=_n,nr=_n;if(_n.alternate)for(;xn.return;)xn=xn.return;else{_n=xn;do xn=_n,xn.flags&4098&&(nr=xn.return),_n=xn.return;while(_n)}return xn.tag===3?nr:null}function Kr(_n){if(Xo(_n)!==_n)throw Error(Tt(188))}function ko(_n){var xn=_n.alternate;if(!xn){if(xn=Xo(_n),xn===null)throw Error(Tt(188));return xn!==_n?null:_n}for(var nr=_n,Lr=xn;;){var Xr=nr.return;if(Xr===null)break;var Uo=Xr.alternate;if(Uo===null){if(Lr=Xr.return,Lr!==null){nr=Lr;continue}break}if(Xr.child===Uo.child){for(Uo=Xr.child;Uo;){if(Uo===nr)return Kr(Xr),_n;if(Uo===Lr)return Kr(Xr),xn;Uo=Uo.sibling}throw Error(Tt(188))}if(nr.return!==Lr.return)nr=Xr,Lr=Uo;else{for(var S0=!1,z0=Xr.child;z0;){if(z0===nr){S0=!0,nr=Xr,Lr=Uo;break}if(z0===Lr){S0=!0,Lr=Xr,nr=Uo;break}z0=z0.sibling}if(!S0){for(z0=Uo.child;z0;){if(z0===nr){S0=!0,nr=Uo,Lr=Xr;break}if(z0===Lr){S0=!0,Lr=Uo,nr=Xr;break}z0=z0.sibling}if(!S0)throw Error(Tt(189))}}if(nr.alternate!==Lr)throw Error(Tt(190))}if(nr.tag!==3)throw Error(Tt(188));return nr.stateNode.current===nr?_n:xn}function f0(_n){return _n=ko(_n),_n!==null?x0(_n):null}function x0(_n){if(_n.tag===5||_n.tag===6)return _n;for(_n=_n.child;_n!==null;){var xn=x0(_n);if(xn!==null)return xn;_n=_n.sibling}return null}function l0(_n){if(_n.tag===5||_n.tag===6)return _n;for(_n=_n.child;_n!==null;){if(_n.tag!==4){var xn=l0(_n);if(xn!==null)return xn}_n=_n.sibling}return null}var T0=Array.isArray,t0=at.getPublicInstance,E0=at.getRootHostContext,n0=at.getChildHostContext,m0=at.prepareForCommit,h0=at.resetAfterCommit,a0=at.createInstance,P0=at.appendInitialChild,V0=at.finalizeInitialChildren,B0=at.prepareUpdate,W0=at.shouldSetTextContent,K0=at.createTextInstance,Ty=at.scheduleTimeout,$y=at.cancelTimeout,My=at.noTimeout,Wy=at.isPrimaryRenderer,Ey=at.supportsMutation,_0=at.supportsPersistence,ay=at.supportsHydration,J0=at.getInstanceFromNode,yy=at.preparePortalMount,uy=at.getCurrentEventPriority,Dy=at.detachDeletedInstance,Fy=at.supportsMicrotasks,qy=at.scheduleMicrotask,rv=at.supportsTestSelectors,y0=at.findFiberRoot,r0=at.getBoundingRect,M0=at.getTextContent,G0=at.isHiddenSubtree,sy=at.matchAccessibilityRole,dy=at.setFocusIfFocusable,Vy=at.setupIntersectionObserver,Xy=at.appendChild,hy=at.appendChildToContainer,Ly=at.commitTextUpdate,Py=at.commitMount,Sy=at.commitUpdate,Ev=at.insertBefore,Qy=at.insertInContainerBefore,cy=at.removeChild,C0=at.removeChildFromContainer,U0=at.resetTextContent,xy=at.hideInstance,o0=at.hideTextInstance,v0=at.unhideInstance,i0=at.unhideTextInstance,k0=at.clearContainer,$0=at.cloneInstance,ty=at.createContainerChildSet,my=at.appendChildToContainerChildSet,ev=at.finalizeContainerChildren,vv=at.replaceContainerChildren,Tv=at.cloneHiddenInstance,Rv=at.cloneHiddenTextInstance,Lv=at.canHydrateInstance,Yv=at.canHydrateTextInstance,X0=at.canHydrateSuspenseInstance,Pv=at.isSuspenseInstancePending,Fv=at.isSuspenseInstanceFallback,Jv=at.registerSuspenseInstanceRetry,g1=at.getNextHydratableSibling,_v=at.getFirstHydratableChild,Y1=at.getFirstHydratableChildWithinContainer,c_=at.getFirstHydratableChildWithinSuspenseInstance,Qo=at.hydrateInstance,c0=at.hydrateTextInstance,D0=at.hydrateSuspenseInstance,Go=at.getNextHydratableInstanceAfterSuspenseInstance,g0=at.commitHydratedContainer,b0=at.commitHydratedSuspenseInstance,I0=at.clearSuspenseBoundary,A0=at.clearSuspenseBoundaryFromContainer,Y0=at.shouldDeleteUnhydratedTailInstances,ey=at.didNotMatchHydratedContainerTextInstance,ny=at.didNotMatchHydratedTextInstance,ry;function Ky(_n){if(ry===void 0)try{throw Error()}catch(nr){var xn=nr.stack.trim().match(/\n( *(at )?)/);ry=xn&&xn[1]||""}return`
`+ry+_n}var wy=!1;function Ry(_n,xn){if(!_n||wy)return"";wy=!0;var nr=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(xn)if(xn=function(){throw Error()},Object.defineProperty(xn.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(xn,[])}catch(Gy){var Lr=Gy}Reflect.construct(_n,[],xn)}else{try{xn.call()}catch(Gy){Lr=Gy}_n.call(xn.prototype)}else{try{throw Error()}catch(Gy){Lr=Gy}_n()}}catch(Gy){if(Gy&&Lr&&typeof Gy.stack=="string"){for(var Xr=Gy.stack.split(`
`),Uo=Lr.stack.split(`
`),S0=Xr.length-1,z0=Uo.length-1;1<=S0&&0<=z0&&Xr[S0]!==Uo[z0];)z0--;for(;1<=S0&&0<=z0;S0--,z0--)if(Xr[S0]!==Uo[z0]){if(S0!==1||z0!==1)do if(S0--,z0--,0>z0||Xr[S0]!==Uo[z0]){var gy=`
`+Xr[S0].replace(" at new "," at ");return _n.displayName&&gy.includes("<anonymous>")&&(gy=gy.replace("<anonymous>",_n.displayName)),gy}while(1<=S0&&0<=z0);break}}}finally{wy=!1,Error.prepareStackTrace=nr}return(_n=_n?_n.displayName||_n.name:"")?Ky(_n):""}var Hy=Object.prototype.hasOwnProperty,uv=[],dv=-1;function pv(_n){return{current:_n}}function Zy(_n){0>dv||(_n.current=uv[dv],uv[dv]=null,dv--)}function By(_n,xn){dv++,uv[dv]=_n.current,_n.current=xn}var bv={},fv=pv(bv),xv=pv(!1),t1=bv;function u1(_n,xn){var nr=_n.type.contextTypes;if(!nr)return bv;var Lr=_n.stateNode;if(Lr&&Lr.__reactInternalMemoizedUnmaskedChildContext===xn)return Lr.__reactInternalMemoizedMaskedChildContext;var Xr={},Uo;for(Uo in nr)Xr[Uo]=xn[Uo];return Lr&&(_n=_n.stateNode,_n.__reactInternalMemoizedUnmaskedChildContext=xn,_n.__reactInternalMemoizedMaskedChildContext=Xr),Xr}function c1(_n){return _n=_n.childContextTypes,_n!=null}function Gv(){Zy(xv),Zy(fv)}function Ov(_n,xn,nr){if(fv.current!==bv)throw Error(Tt(168));By(fv,xn),By(xv,nr)}function jy(_n,xn,nr){var Lr=_n.stateNode;if(xn=xn.childContextTypes,typeof Lr.getChildContext!="function")return nr;Lr=Lr.getChildContext();for(var Xr in Lr)if(!(Xr in xn))throw Error(Tt(108,Bo(_n)||"Unknown",Xr));return $t({},nr,Lr)}function Av(_n){return _n=(_n=_n.stateNode)&&_n.__reactInternalMemoizedMergedChildContext||bv,t1=fv.current,By(fv,_n),By(xv,xv.current),!0}function zy(_n,xn,nr){var Lr=_n.stateNode;if(!Lr)throw Error(Tt(169));nr?(_n=jy(_n,xn,t1),Lr.__reactInternalMemoizedMergedChildContext=_n,Zy(xv),Zy(fv),By(fv,_n)):Zy(xv),By(xv,nr)}var n1=Math.clz32?Math.clz32:S1,m1=Math.log,i1=Math.LN2;function S1(_n){return _n>>>=0,_n===0?32:31-(m1(_n)/i1|0)|0}var J1=64,d_=4194304;function x1(_n){switch(_n&-_n){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return _n&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return _n&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return _n}}function m_(_n,xn){var nr=_n.pendingLanes;if(nr===0)return 0;var Lr=0,Xr=_n.suspendedLanes,Uo=_n.pingedLanes,S0=nr&268435455;if(S0!==0){var z0=S0&~Xr;z0!==0?Lr=x1(z0):(Uo&=S0,Uo!==0&&(Lr=x1(Uo)))}else S0=nr&~Xr,S0!==0?Lr=x1(S0):Uo!==0&&(Lr=x1(Uo));if(Lr===0)return 0;if(xn!==0&&xn!==Lr&&!(xn&Xr)&&(Xr=Lr&-Lr,Uo=xn&-xn,Xr>=Uo||Xr===16&&(Uo&4194240)!==0))return xn;if(Lr&4&&(Lr|=nr&16),xn=_n.entangledLanes,xn!==0)for(_n=_n.entanglements,xn&=Lr;0<xn;)nr=31-n1(xn),Xr=1<<nr,Lr|=_n[nr],xn&=~Xr;return Lr}function z1(_n,xn){switch(_n){case 1:case 2:case 4:return xn+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return xn+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function j1(_n,xn){for(var nr=_n.suspendedLanes,Lr=_n.pingedLanes,Xr=_n.expirationTimes,Uo=_n.pendingLanes;0<Uo;){var S0=31-n1(Uo),z0=1<<S0,gy=Xr[S0];gy===-1?(!(z0&nr)||z0&Lr)&&(Xr[S0]=z1(z0,xn)):gy<=xn&&(_n.expiredLanes|=z0),Uo&=~z0}}function g_(_n){return _n=_n.pendingLanes&-1073741825,_n!==0?_n:_n&1073741824?1073741824:0}function q1(_n){for(var xn=[],nr=0;31>nr;nr++)xn.push(_n);return xn}function No(_n,xn,nr){_n.pendingLanes|=xn,xn!==536870912&&(_n.suspendedLanes=0,_n.pingedLanes=0),_n=_n.eventTimes,xn=31-n1(xn),_n[xn]=nr}function ir(_n,xn){var nr=_n.pendingLanes&~xn;_n.pendingLanes=xn,_n.suspendedLanes=0,_n.pingedLanes=0,_n.expiredLanes&=xn,_n.mutableReadLanes&=xn,_n.entangledLanes&=xn,xn=_n.entanglements;var Lr=_n.eventTimes;for(_n=_n.expirationTimes;0<nr;){var Xr=31-n1(nr),Uo=1<<Xr;xn[Xr]=0,Lr[Xr]=-1,_n[Xr]=-1,nr&=~Uo}}function jr(_n,xn){var nr=_n.entangledLanes|=xn;for(_n=_n.entanglements;nr;){var Lr=31-n1(nr),Xr=1<<Lr;Xr&xn|_n[Lr]&xn&&(_n[Lr]|=xn),nr&=~Xr}}var Ro=0;function _g(_n){return _n&=-_n,1<_n?4<_n?_n&268435455?16:536870912:4:1}var d0=wt.unstable_scheduleCallback,L0=wt.unstable_cancelCallback,by=wt.unstable_shouldYield,ky=wt.unstable_requestPaint,Oy=wt.unstable_now,Uy=wt.unstable_ImmediatePriority,hv=wt.unstable_UserBlockingPriority,Hv=wt.unstable_NormalPriority,Q0=wt.unstable_IdlePriority,q0=null,Yy=null;function av(_n){if(Yy&&typeof Yy.onCommitFiberRoot=="function")try{Yy.onCommitFiberRoot(q0,_n,void 0,(_n.current.flags&128)===128)}catch{}}function Zv(_n,xn){return _n===xn&&(_n!==0||1/_n===1/xn)||_n!==_n&&xn!==xn}var M1=typeof Object.is=="function"?Object.is:Zv,R_=null,Gx=!1,sw=!1;function Ow(_n){R_===null?R_=[_n]:R_.push(_n)}function Dw(_n){Gx=!0,Ow(_n)}function y_(){if(!sw&&R_!==null){sw=!0;var _n=0,xn=Ro;try{var nr=R_;for(Ro=1;_n<nr.length;_n++){var Lr=nr[_n];do Lr=Lr(!0);while(Lr!==null)}R_=null,Gx=!1}catch(Xr){throw R_!==null&&(R_=R_.slice(_n+1)),d0(Uy,y_),Xr}finally{Ro=xn,sw=!1}}return null}var Bw=Lt.ReactCurrentBatchConfig;function _1(_n,xn){if(M1(_n,xn))return!0;if(typeof _n!="object"||_n===null||typeof xn!="object"||xn===null)return!1;var nr=Object.keys(_n),Lr=Object.keys(xn);if(nr.length!==Lr.length)return!1;for(Lr=0;Lr<nr.length;Lr++){var Xr=nr[Lr];if(!Hy.call(xn,Xr)||!M1(_n[Xr],xn[Xr]))return!1}return!0}function Vx(_n){switch(_n.tag){case 5:return Ky(_n.type);case 16:return Ky("Lazy");case 13:return Ky("Suspense");case 19:return Ky("SuspenseList");case 0:case 2:case 15:return _n=Ry(_n.type,!1),_n;case 11:return _n=Ry(_n.type.render,!1),_n;case 1:return _n=Ry(_n.type,!0),_n;default:return""}}function I1(_n,xn){if(_n&&_n.defaultProps){xn=$t({},xn),_n=_n.defaultProps;for(var nr in _n)xn[nr]===void 0&&(xn[nr]=_n[nr]);return xn}return xn}var wx=pv(null),cx=null,R1=null,Hx=null;function lw(){Hx=R1=cx=null}function uw(_n,xn,nr){Wy?(By(wx,xn._currentValue),xn._currentValue=nr):(By(wx,xn._currentValue2),xn._currentValue2=nr)}function Wx(_n){var xn=wx.current;Zy(wx),Wy?_n._currentValue=xn:_n._currentValue2=xn}function jx(_n,xn,nr){for(;_n!==null;){var Lr=_n.alternate;if((_n.childLanes&xn)!==xn?(_n.childLanes|=xn,Lr!==null&&(Lr.childLanes|=xn)):Lr!==null&&(Lr.childLanes&xn)!==xn&&(Lr.childLanes|=xn),_n===nr)break;_n=_n.return}}function dx(_n,xn){cx=_n,Hx=R1=null,_n=_n.dependencies,_n!==null&&_n.firstContext!==null&&(_n.lanes&xn&&($_=!0),_n.firstContext=null)}function y1(_n){var xn=Wy?_n._currentValue:_n._currentValue2;if(Hx!==_n)if(_n={context:_n,memoizedValue:xn,next:null},R1===null){if(cx===null)throw Error(Tt(308));R1=_n,cx.dependencies={lanes:0,firstContext:_n}}else R1=R1.next=_n;return xn}var x_=null,w1=!1;function $x(_n){_n.updateQueue={baseState:_n.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function kw(_n,xn){_n=_n.updateQueue,xn.updateQueue===_n&&(xn.updateQueue={baseState:_n.baseState,firstBaseUpdate:_n.firstBaseUpdate,lastBaseUpdate:_n.lastBaseUpdate,shared:_n.shared,effects:_n.effects})}function G1(_n,xn){return{eventTime:_n,lane:xn,tag:0,payload:null,callback:null,next:null}}function ov(_n,xn){var nr=_n.updateQueue;nr!==null&&(nr=nr.shared,P1!==null&&_n.mode&1&&!(jv&2)?(_n=nr.interleaved,_n===null?(xn.next=xn,x_===null?x_=[nr]:x_.push(nr)):(xn.next=_n.next,_n.next=xn),nr.interleaved=xn):(_n=nr.pending,_n===null?xn.next=xn:(xn.next=_n.next,_n.next=xn),nr.pending=xn))}function fx(_n,xn,nr){if(xn=xn.updateQueue,xn!==null&&(xn=xn.shared,(nr&4194240)!==0)){var Lr=xn.lanes;Lr&=_n.pendingLanes,nr|=Lr,xn.lanes=nr,jr(_n,nr)}}function f1(_n,xn){var nr=_n.updateQueue,Lr=_n.alternate;if(Lr!==null&&(Lr=Lr.updateQueue,nr===Lr)){var Xr=null,Uo=null;if(nr=nr.firstBaseUpdate,nr!==null){do{var S0={eventTime:nr.eventTime,lane:nr.lane,tag:nr.tag,payload:nr.payload,callback:nr.callback,next:null};Uo===null?Xr=Uo=S0:Uo=Uo.next=S0,nr=nr.next}while(nr!==null);Uo===null?Xr=Uo=xn:Uo=Uo.next=xn}else Xr=Uo=xn;nr={baseState:Lr.baseState,firstBaseUpdate:Xr,lastBaseUpdate:Uo,shared:Lr.shared,effects:Lr.effects},_n.updateQueue=nr;return}_n=nr.lastBaseUpdate,_n===null?nr.firstBaseUpdate=xn:_n.next=xn,nr.lastBaseUpdate=xn}function Q1(_n,xn,nr,Lr){var Xr=_n.updateQueue;w1=!1;var Uo=Xr.firstBaseUpdate,S0=Xr.lastBaseUpdate,z0=Xr.shared.pending;if(z0!==null){Xr.shared.pending=null;var gy=z0,Gy=gy.next;gy.next=null,S0===null?Uo=Gy:S0.next=Gy,S0=gy;var cv=_n.alternate;cv!==null&&(cv=cv.updateQueue,z0=cv.lastBaseUpdate,z0!==S0&&(z0===null?cv.firstBaseUpdate=Gy:z0.next=Gy,cv.lastBaseUpdate=gy))}if(Uo!==null){var Uv=Xr.baseState;S0=0,cv=Gy=gy=null,z0=Uo;do{var $v=z0.lane,p1=z0.eventTime;if((Lr&$v)===$v){cv!==null&&(cv=cv.next={eventTime:p1,lane:0,tag:z0.tag,payload:z0.payload,callback:z0.callback,next:null});e:{var mv=_n,l_=z0;switch($v=xn,p1=nr,l_.tag){case 1:if(mv=l_.payload,typeof mv=="function"){Uv=mv.call(p1,Uv,$v);break e}Uv=mv;break e;case 3:mv.flags=mv.flags&-65537|128;case 0:if(mv=l_.payload,$v=typeof mv=="function"?mv.call(p1,Uv,$v):mv,$v==null)break e;Uv=$t({},Uv,$v);break e;case 2:w1=!0}}z0.callback!==null&&z0.lane!==0&&(_n.flags|=64,$v=Xr.effects,$v===null?Xr.effects=[z0]:$v.push(z0))}else p1={eventTime:p1,lane:$v,tag:z0.tag,payload:z0.payload,callback:z0.callback,next:null},cv===null?(Gy=cv=p1,gy=Uv):cv=cv.next=p1,S0|=$v;if(z0=z0.next,z0===null){if(z0=Xr.shared.pending,z0===null)break;$v=z0,z0=$v.next,$v.next=null,Xr.lastBaseUpdate=$v,Xr.shared.pending=null}}while(!0);if(cv===null&&(gy=Uv),Xr.baseState=gy,Xr.firstBaseUpdate=Gy,Xr.lastBaseUpdate=cv,xn=Xr.shared.interleaved,xn!==null){Xr=xn;do S0|=Xr.lane,Xr=Xr.next;while(Xr!==xn)}else Uo===null&&(Xr.shared.lanes=0);Aw|=S0,_n.lanes=S0,_n.memoizedState=Uv}}function f_(_n,xn,nr){if(_n=xn.effects,xn.effects=null,_n!==null)for(xn=0;xn<_n.length;xn++){var Lr=_n[xn],Xr=Lr.callback;if(Xr!==null){if(Lr.callback=null,Lr=nr,typeof Xr!="function")throw Error(Tt(191,Xr));Xr.call(Lr)}}}var Lw=new vt.Component().refs;function Sx(_n,xn,nr,Lr){xn=_n.memoizedState,nr=nr(Lr,xn),nr=nr==null?xn:$t({},xn,nr),_n.memoizedState=nr,_n.lanes===0&&(_n.updateQueue.baseState=nr)}var Ex={isMounted:function(_n){return(_n=_n._reactInternals)?Xo(_n)===_n:!1},enqueueSetState:function(_n,xn,nr){_n=_n._reactInternals;var Lr=i_(),Xr=ox(_n),Uo=G1(Lr,Xr);Uo.payload=xn,nr!=null&&(Uo.callback=nr),ov(_n,Uo),xn=D_(_n,Xr,Lr),xn!==null&&fx(xn,_n,Xr)},enqueueReplaceState:function(_n,xn,nr){_n=_n._reactInternals;var Lr=i_(),Xr=ox(_n),Uo=G1(Lr,Xr);Uo.tag=1,Uo.payload=xn,nr!=null&&(Uo.callback=nr),ov(_n,Uo),xn=D_(_n,Xr,Lr),xn!==null&&fx(xn,_n,Xr)},enqueueForceUpdate:function(_n,xn){_n=_n._reactInternals;var nr=i_(),Lr=ox(_n),Xr=G1(nr,Lr);Xr.tag=2,xn!=null&&(Xr.callback=xn),ov(_n,Xr),xn=D_(_n,Lr,nr),xn!==null&&fx(xn,_n,Lr)}};function cw(_n,xn,nr,Lr,Xr,Uo,S0){return _n=_n.stateNode,typeof _n.shouldComponentUpdate=="function"?_n.shouldComponentUpdate(Lr,Uo,S0):xn.prototype&&xn.prototype.isPureReactComponent?!_1(nr,Lr)||!_1(Xr,Uo):!0}function Nw(_n,xn,nr){var Lr=!1,Xr=bv,Uo=xn.contextType;return typeof Uo=="object"&&Uo!==null?Uo=y1(Uo):(Xr=c1(xn)?t1:fv.current,Lr=xn.contextTypes,Uo=(Lr=Lr!=null)?u1(_n,Xr):bv),xn=new xn(nr,Uo),_n.memoizedState=xn.state!==null&&xn.state!==void 0?xn.state:null,xn.updater=Ex,_n.stateNode=xn,xn._reactInternals=_n,Lr&&(_n=_n.stateNode,_n.__reactInternalMemoizedUnmaskedChildContext=Xr,_n.__reactInternalMemoizedMaskedChildContext=Uo),xn}function dw(_n,xn,nr,Lr){_n=xn.state,typeof xn.componentWillReceiveProps=="function"&&xn.componentWillReceiveProps(nr,Lr),typeof xn.UNSAFE_componentWillReceiveProps=="function"&&xn.UNSAFE_componentWillReceiveProps(nr,Lr),xn.state!==_n&&Ex.enqueueReplaceState(xn,xn.state,null)}function U_(_n,xn,nr,Lr){var Xr=_n.stateNode;Xr.props=nr,Xr.state=_n.memoizedState,Xr.refs=Lw,$x(_n);var Uo=xn.contextType;typeof Uo=="object"&&Uo!==null?Xr.context=y1(Uo):(Uo=c1(xn)?t1:fv.current,Xr.context=u1(_n,Uo)),Xr.state=_n.memoizedState,Uo=xn.getDerivedStateFromProps,typeof Uo=="function"&&(Sx(_n,xn,Uo,nr),Xr.state=_n.memoizedState),typeof xn.getDerivedStateFromProps=="function"||typeof Xr.getSnapshotBeforeUpdate=="function"||typeof Xr.UNSAFE_componentWillMount!="function"&&typeof Xr.componentWillMount!="function"||(xn=Xr.state,typeof Xr.componentWillMount=="function"&&Xr.componentWillMount(),typeof Xr.UNSAFE_componentWillMount=="function"&&Xr.UNSAFE_componentWillMount(),xn!==Xr.state&&Ex.enqueueReplaceState(Xr,Xr.state,null),Q1(_n,nr,Xr,Lr),Xr.state=_n.memoizedState),typeof Xr.componentDidMount=="function"&&(_n.flags|=4194308)}var p_=[],Y_=0,Tx=null,Ax=0,K1=[],Z1=0,z_=null,G_=1,e_="";function P_(_n,xn){p_[Y_++]=Ax,p_[Y_++]=Tx,Tx=_n,Ax=xn}function Ir(_n,xn,nr){K1[Z1++]=G_,K1[Z1++]=e_,K1[Z1++]=z_,z_=_n;var Lr=G_;_n=e_;var Xr=32-n1(Lr)-1;Lr&=~(1<<Xr),nr+=1;var Uo=32-n1(xn)+Xr;if(30<Uo){var S0=Xr-Xr%5;Uo=(Lr&(1<<S0)-1).toString(32),Lr>>=S0,Xr-=S0,G_=1<<32-n1(xn)+Xr|nr<<Xr|Lr,e_=Uo+_n}else G_=1<<Uo|nr<<Xr|Lr,e_=_n}function Yr(_n){_n.return!==null&&(P_(_n,1),Ir(_n,1,0))}function zo(_n){for(;_n===Tx;)Tx=p_[--Y_],p_[Y_]=null,Ax=p_[--Y_],p_[Y_]=null;for(;_n===z_;)z_=K1[--Z1],K1[Z1]=null,e_=K1[--Z1],K1[Z1]=null,G_=K1[--Z1],K1[Z1]=null}var s0=null,w0=null,O0=!1,fy=!1,Iy=null;function sv(_n,xn){var nr=B_(5,null,null,0);nr.elementType="DELETED",nr.stateNode=xn,nr.return=_n,xn=_n.deletions,xn===null?(_n.deletions=[nr],_n.flags|=16):xn.push(nr)}function Jy(_n,xn){switch(_n.tag){case 5:return xn=Lv(xn,_n.type,_n.pendingProps),xn!==null?(_n.stateNode=xn,s0=_n,w0=_v(xn),!0):!1;case 6:return xn=Yv(xn,_n.pendingProps),xn!==null?(_n.stateNode=xn,s0=_n,w0=null,!0):!1;case 13:if(xn=X0(xn),xn!==null){var nr=z_!==null?{id:G_,overflow:e_}:null;return _n.memoizedState={dehydrated:xn,treeContext:nr,retryLane:1073741824},nr=B_(18,null,null,0),nr.stateNode=xn,nr.return=_n,_n.child=nr,s0=_n,w0=null,!0}return!1;default:return!1}}function wv(_n){return(_n.mode&1)!==0&&(_n.flags&128)===0}function a1(_n){if(O0){var xn=w0;if(xn){var nr=xn;if(!Jy(_n,xn)){if(wv(_n))throw Error(Tt(418));xn=g1(nr);var Lr=s0;xn&&Jy(_n,xn)?sv(Lr,nr):(_n.flags=_n.flags&-4097|2,O0=!1,s0=_n)}}else{if(wv(_n))throw Error(Tt(418));_n.flags=_n.flags&-4097|2,O0=!1,s0=_n}}}function r1(_n){for(_n=_n.return;_n!==null&&_n.tag!==5&&_n.tag!==3&&_n.tag!==13;)_n=_n.return;s0=_n}function iy(_n){if(!ay||_n!==s0)return!1;if(!O0)return r1(_n),O0=!0,!1;if(_n.tag!==3&&(_n.tag!==5||Y0(_n.type)&&!W0(_n.type,_n.memoizedProps))){var xn=w0;if(xn){if(wv(_n)){for(_n=w0;_n;)_n=g1(_n);throw Error(Tt(418))}for(;xn;)sv(_n,xn),xn=g1(xn)}}if(r1(_n),_n.tag===13){if(!ay)throw Error(Tt(316));if(_n=_n.memoizedState,_n=_n!==null?_n.dehydrated:null,!_n)throw Error(Tt(317));w0=Go(_n)}else w0=s0?g1(_n.stateNode):null;return!0}function Mv(){ay&&(w0=s0=null,fy=O0=!1)}function Qv(_n){Iy===null?Iy=[_n]:Iy.push(_n)}function v_(_n,xn,nr){if(_n=nr.ref,_n!==null&&typeof _n!="function"&&typeof _n!="object"){if(nr._owner){if(nr=nr._owner,nr){if(nr.tag!==1)throw Error(Tt(309));var Lr=nr.stateNode}if(!Lr)throw Error(Tt(147,_n));var Xr=Lr,Uo=""+_n;return xn!==null&&xn.ref!==null&&typeof xn.ref=="function"&&xn.ref._stringRef===Uo?xn.ref:(xn=function(S0){var z0=Xr.refs;z0===Lw&&(z0=Xr.refs={}),S0===null?delete z0[Uo]:z0[Uo]=S0},xn._stringRef=Uo,xn)}if(typeof _n!="string")throw Error(Tt(284));if(!nr._owner)throw Error(Tt(290,_n))}return _n}function __(_n,xn){throw _n=Object.prototype.toString.call(xn),Error(Tt(31,_n==="[object Object]"?"object with keys {"+Object.keys(xn).join(", ")+"}":_n))}function Fw(_n){var xn=_n._init;return xn(_n._payload)}function w$(_n){function xn(Z0,H0){if(_n){var ly=Z0.deletions;ly===null?(Z0.deletions=[H0],Z0.flags|=16):ly.push(H0)}}function nr(Z0,H0){if(!_n)return null;for(;H0!==null;)xn(Z0,H0),H0=H0.sibling;return null}function Lr(Z0,H0){for(Z0=new Map;H0!==null;)H0.key!==null?Z0.set(H0.key,H0):Z0.set(H0.index,H0),H0=H0.sibling;return Z0}function Xr(Z0,H0){return Z0=vx(Z0,H0),Z0.index=0,Z0.sibling=null,Z0}function Uo(Z0,H0,ly){return Z0.index=ly,_n?(ly=Z0.alternate,ly!==null?(ly=ly.index,ly<H0?(Z0.flags|=2,H0):ly):(Z0.flags|=2,H0)):(Z0.flags|=1048576,H0)}function S0(Z0){return _n&&Z0.alternate===null&&(Z0.flags|=2),Z0}function z0(Z0,H0,ly,iv){return H0===null||H0.tag!==6?(H0=s_(ly,Z0.mode,iv),H0.return=Z0,H0):(H0=Xr(H0,ly),H0.return=Z0,H0)}function gy(Z0,H0,ly,iv){var gv=ly.type;return gv===Ht?cv(Z0,H0,ly.props.children,iv,ly.key):H0!==null&&(H0.elementType===gv||typeof gv=="object"&&gv!==null&&gv.$$typeof===tr&&Fw(gv)===H0.type)?(iv=Xr(H0,ly.props),iv.ref=v_(Z0,H0,ly),iv.return=Z0,iv):(iv=I2(ly.type,ly.key,ly.props,null,Z0.mode,iv),iv.ref=v_(Z0,H0,ly),iv.return=Z0,iv)}function Gy(Z0,H0,ly,iv){return H0===null||H0.tag!==4||H0.stateNode.containerInfo!==ly.containerInfo||H0.stateNode.implementation!==ly.implementation?(H0=k_(ly,Z0.mode,iv),H0.return=Z0,H0):(H0=Xr(H0,ly.children||[]),H0.return=Z0,H0)}function cv(Z0,H0,ly,iv,gv){return H0===null||H0.tag!==7?(H0=Ux(ly,Z0.mode,iv,gv),H0.return=Z0,H0):(H0=Xr(H0,ly),H0.return=Z0,H0)}function Uv(Z0,H0,ly){if(typeof H0=="string"&&H0!==""||typeof H0=="number")return H0=s_(""+H0,Z0.mode,ly),H0.return=Z0,H0;if(typeof H0=="object"&&H0!==null){switch(H0.$$typeof){case Ft:return ly=I2(H0.type,H0.key,H0.props,null,Z0.mode,ly),ly.ref=v_(Z0,null,H0),ly.return=Z0,ly;case Ct:return H0=k_(H0,Z0.mode,ly),H0.return=Z0,H0;case tr:var iv=H0._init;return Uv(Z0,iv(H0._payload),ly)}if(T0(H0)||qr(H0))return H0=Ux(H0,Z0.mode,ly,null),H0.return=Z0,H0;__(Z0,H0)}return null}function $v(Z0,H0,ly,iv){var gv=H0!==null?H0.key:null;if(typeof ly=="string"&&ly!==""||typeof ly=="number")return gv!==null?null:z0(Z0,H0,""+ly,iv);if(typeof ly=="object"&&ly!==null){switch(ly.$$typeof){case Ft:return ly.key===gv?gy(Z0,H0,ly,iv):null;case Ct:return ly.key===gv?Gy(Z0,H0,ly,iv):null;case tr:return gv=ly._init,$v(Z0,H0,gv(ly._payload),iv)}if(T0(ly)||qr(ly))return gv!==null?null:cv(Z0,H0,ly,iv,null);__(Z0,ly)}return null}function p1(Z0,H0,ly,iv,gv){if(typeof iv=="string"&&iv!==""||typeof iv=="number")return Z0=Z0.get(ly)||null,z0(H0,Z0,""+iv,gv);if(typeof iv=="object"&&iv!==null){switch(iv.$$typeof){case Ft:return Z0=Z0.get(iv.key===null?ly:iv.key)||null,gy(H0,Z0,iv,gv);case Ct:return Z0=Z0.get(iv.key===null?ly:iv.key)||null,Gy(H0,Z0,iv,gv);case tr:var qv=iv._init;return p1(Z0,H0,ly,qv(iv._payload),gv)}if(T0(iv)||qr(iv))return Z0=Z0.get(ly)||null,cv(H0,Z0,iv,gv,null);__(H0,iv)}return null}function mv(Z0,H0,ly,iv){for(var gv=null,qv=null,zv=H0,Kv=H0=0,D1=null;zv!==null&&Kv<ly.length;Kv++){zv.index>Kv?(D1=zv,zv=null):D1=zv.sibling;var s1=$v(Z0,zv,ly[Kv],iv);if(s1===null){zv===null&&(zv=D1);break}_n&&zv&&s1.alternate===null&&xn(Z0,zv),H0=Uo(s1,H0,Kv),qv===null?gv=s1:qv.sibling=s1,qv=s1,zv=D1}if(Kv===ly.length)return nr(Z0,zv),O0&&P_(Z0,Kv),gv;if(zv===null){for(;Kv<ly.length;Kv++)zv=Uv(Z0,ly[Kv],iv),zv!==null&&(H0=Uo(zv,H0,Kv),qv===null?gv=zv:qv.sibling=zv,qv=zv);return O0&&P_(Z0,Kv),gv}for(zv=Lr(Z0,zv);Kv<ly.length;Kv++)D1=p1(zv,Z0,Kv,ly[Kv],iv),D1!==null&&(_n&&D1.alternate!==null&&zv.delete(D1.key===null?Kv:D1.key),H0=Uo(D1,H0,Kv),qv===null?gv=D1:qv.sibling=D1,qv=D1);return _n&&zv.forEach(function(sx){return xn(Z0,sx)}),O0&&P_(Z0,Kv),gv}function l_(Z0,H0,ly,iv){var gv=qr(ly);if(typeof gv!="function")throw Error(Tt(150));if(ly=gv.call(ly),ly==null)throw Error(Tt(151));for(var qv=gv=null,zv=H0,Kv=H0=0,D1=null,s1=ly.next();zv!==null&&!s1.done;Kv++,s1=ly.next()){zv.index>Kv?(D1=zv,zv=null):D1=zv.sibling;var sx=$v(Z0,zv,s1.value,iv);if(sx===null){zv===null&&(zv=D1);break}_n&&zv&&sx.alternate===null&&xn(Z0,zv),H0=Uo(sx,H0,Kv),qv===null?gv=sx:qv.sibling=sx,qv=sx,zv=D1}if(s1.done)return nr(Z0,zv),O0&&P_(Z0,Kv),gv;if(zv===null){for(;!s1.done;Kv++,s1=ly.next())s1=Uv(Z0,s1.value,iv),s1!==null&&(H0=Uo(s1,H0,Kv),qv===null?gv=s1:qv.sibling=s1,qv=s1);return O0&&P_(Z0,Kv),gv}for(zv=Lr(Z0,zv);!s1.done;Kv++,s1=ly.next())s1=p1(zv,Z0,Kv,s1.value,iv),s1!==null&&(_n&&s1.alternate!==null&&zv.delete(s1.key===null?Kv:s1.key),H0=Uo(s1,H0,Kv),qv===null?gv=s1:qv.sibling=s1,qv=s1);return _n&&zv.forEach(function(P2){return xn(Z0,P2)}),O0&&P_(Z0,Kv),gv}function C_(Z0,H0,ly,iv){if(typeof ly=="object"&&ly!==null&&ly.type===Ht&&ly.key===null&&(ly=ly.props.children),typeof ly=="object"&&ly!==null){switch(ly.$$typeof){case Ft:e:{for(var gv=ly.key,qv=H0;qv!==null;){if(qv.key===gv){if(gv=ly.type,gv===Ht){if(qv.tag===7){nr(Z0,qv.sibling),H0=Xr(qv,ly.props.children),H0.return=Z0,Z0=H0;break e}}else if(qv.elementType===gv||typeof gv=="object"&&gv!==null&&gv.$$typeof===tr&&Fw(gv)===qv.type){nr(Z0,qv.sibling),H0=Xr(qv,ly.props),H0.ref=v_(Z0,qv,ly),H0.return=Z0,Z0=H0;break e}nr(Z0,qv);break}else xn(Z0,qv);qv=qv.sibling}ly.type===Ht?(H0=Ux(ly.props.children,Z0.mode,iv,ly.key),H0.return=Z0,Z0=H0):(iv=I2(ly.type,ly.key,ly.props,null,Z0.mode,iv),iv.ref=v_(Z0,H0,ly),iv.return=Z0,Z0=iv)}return S0(Z0);case Ct:e:{for(qv=ly.key;H0!==null;){if(H0.key===qv)if(H0.tag===4&&H0.stateNode.containerInfo===ly.containerInfo&&H0.stateNode.implementation===ly.implementation){nr(Z0,H0.sibling),H0=Xr(H0,ly.children||[]),H0.return=Z0,Z0=H0;break e}else{nr(Z0,H0);break}else xn(Z0,H0);H0=H0.sibling}H0=k_(ly,Z0.mode,iv),H0.return=Z0,Z0=H0}return S0(Z0);case tr:return qv=ly._init,C_(Z0,H0,qv(ly._payload),iv)}if(T0(ly))return mv(Z0,H0,ly,iv);if(qr(ly))return l_(Z0,H0,ly,iv);__(Z0,ly)}return typeof ly=="string"&&ly!==""||typeof ly=="number"?(ly=""+ly,H0!==null&&H0.tag===6?(nr(Z0,H0.sibling),H0=Xr(H0,ly),H0.return=Z0,Z0=H0):(nr(Z0,H0),H0=s_(ly,Z0.mode,iv),H0.return=Z0,Z0=H0),S0(Z0)):nr(Z0,H0)}return C_}var fw=w$(!0),$$=w$(!1),J_={},$1=pv(J_),pw=pv(J_),hw=pv(J_);function Q_(_n){if(_n===J_)throw Error(Tt(174));return _n}function k2(_n,xn){By(hw,xn),By(pw,_n),By($1,J_),_n=E0(xn),Zy($1),By($1,_n)}function mw(){Zy($1),Zy(pw),Zy(hw)}function S$(_n){var xn=Q_(hw.current),nr=Q_($1.current);xn=n0(nr,_n.type,xn),nr!==xn&&(By(pw,_n),By($1,xn))}function ex(_n){pw.current===_n&&(Zy($1),Zy(pw))}var F0=pv(0);function vy(_n){for(var xn=_n;xn!==null;){if(xn.tag===13){var nr=xn.memoizedState;if(nr!==null&&(nr=nr.dehydrated,nr===null||Pv(nr)||Fv(nr)))return xn}else if(xn.tag===19&&xn.memoizedProps.revealOrder!==void 0){if(xn.flags&128)return xn}else if(xn.child!==null){xn.child.return=xn,xn=xn.child;continue}if(xn===_n)break;for(;xn.sibling===null;){if(xn.return===null||xn.return===_n)return null;xn=xn.return}xn.sibling.return=xn.return,xn=xn.sibling}return null}var oy=[];function lv(){for(var _n=0;_n<oy.length;_n++){var xn=oy[_n];Wy?xn._workInProgressVersionPrimary=null:xn._workInProgressVersionSecondary=null}oy.length=0}var Nv=Lt.ReactCurrentDispatcher,Vv=Lt.ReactCurrentBatchConfig,b1=0,Dv=null,V1=null,H1=null,h_=!1,Cx=!1,Uw=0,gw=0;function k1(){throw Error(Tt(321))}function yw(_n,xn){if(xn===null)return!1;for(var nr=0;nr<xn.length&&nr<_n.length;nr++)if(!M1(_n[nr],xn[nr]))return!1;return!0}function d1(_n,xn,nr,Lr,Xr,Uo){if(b1=Uo,Dv=xn,xn.memoizedState=null,xn.updateQueue=null,xn.lanes=0,Nv.current=_n===null||_n.memoizedState===null?Kw:V2,_n=nr(Lr,Xr),Cx){Uo=0;do{if(Cx=!1,Uw=0,25<=Uo)throw Error(Tt(301));Uo+=1,H1=V1=null,xn.updateQueue=null,Nv.current=bw,_n=nr(Lr,Xr)}while(Cx)}if(Nv.current=_w,xn=V1!==null&&V1.next!==null,b1=0,H1=V1=Dv=null,h_=!1,xn)throw Error(Tt(300));return _n}function L2(){var _n=Uw!==0;return Uw=0,_n}function tx(){var _n={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return H1===null?Dv.memoizedState=H1=_n:H1=H1.next=_n,H1}function w_(){if(V1===null){var _n=Dv.alternate;_n=_n!==null?_n.memoizedState:null}else _n=V1.next;var xn=H1===null?Dv.memoizedState:H1.next;if(xn!==null)H1=xn,V1=_n;else{if(_n===null)throw Error(Tt(310));V1=_n,_n={memoizedState:V1.memoizedState,baseState:V1.baseState,baseQueue:V1.baseQueue,queue:V1.queue,next:null},H1===null?Dv.memoizedState=H1=_n:H1=H1.next=_n}return H1}function qx(_n,xn){return typeof xn=="function"?xn(_n):xn}function d2(_n){var xn=w_(),nr=xn.queue;if(nr===null)throw Error(Tt(311));nr.lastRenderedReducer=_n;var Lr=V1,Xr=Lr.baseQueue,Uo=nr.pending;if(Uo!==null){if(Xr!==null){var S0=Xr.next;Xr.next=Uo.next,Uo.next=S0}Lr.baseQueue=Xr=Uo,nr.pending=null}if(Xr!==null){Uo=Xr.next,Lr=Lr.baseState;var z0=S0=null,gy=null,Gy=Uo;do{var cv=Gy.lane;if((b1&cv)===cv)gy!==null&&(gy=gy.next={lane:0,action:Gy.action,hasEagerState:Gy.hasEagerState,eagerState:Gy.eagerState,next:null}),Lr=Gy.hasEagerState?Gy.eagerState:_n(Lr,Gy.action);else{var Uv={lane:cv,action:Gy.action,hasEagerState:Gy.hasEagerState,eagerState:Gy.eagerState,next:null};gy===null?(z0=gy=Uv,S0=Lr):gy=gy.next=Uv,Dv.lanes|=cv,Aw|=cv}Gy=Gy.next}while(Gy!==null&&Gy!==Uo);gy===null?S0=Lr:gy.next=z0,M1(Lr,xn.memoizedState)||($_=!0),xn.memoizedState=Lr,xn.baseState=S0,xn.baseQueue=gy,nr.lastRenderedState=Lr}if(_n=nr.interleaved,_n!==null){Xr=_n;do Uo=Xr.lane,Dv.lanes|=Uo,Aw|=Uo,Xr=Xr.next;while(Xr!==_n)}else Xr===null&&(nr.lanes=0);return[xn.memoizedState,nr.dispatch]}function f2(_n){var xn=w_(),nr=xn.queue;if(nr===null)throw Error(Tt(311));nr.lastRenderedReducer=_n;var Lr=nr.dispatch,Xr=nr.pending,Uo=xn.memoizedState;if(Xr!==null){nr.pending=null;var S0=Xr=Xr.next;do Uo=_n(Uo,S0.action),S0=S0.next;while(S0!==Xr);M1(Uo,xn.memoizedState)||($_=!0),xn.memoizedState=Uo,xn.baseQueue===null&&(xn.baseState=Uo),nr.lastRenderedState=Uo}return[Uo,Lr]}function zw(){}function hx(_n,xn){var nr=Dv,Lr=w_(),Xr=xn(),Uo=!M1(Lr.memoizedState,Xr);if(Uo&&(Lr.memoizedState=Xr,$_=!0),Lr=Lr.queue,Hw(Vw.bind(null,nr,Lr,_n),[_n]),Lr.getSnapshot!==xn||Uo||H1!==null&&H1.memoizedState.tag&1){if(nr.flags|=2048,Mx(9,N2.bind(null,nr,Lr,Xr,xn),void 0,null),P1===null)throw Error(Tt(349));b1&30||Gw(nr,xn,Xr)}return Xr}function Gw(_n,xn,nr){_n.flags|=16384,_n={getSnapshot:xn,value:nr},xn=Dv.updateQueue,xn===null?(xn={lastEffect:null,stores:null},Dv.updateQueue=xn,xn.stores=[_n]):(nr=xn.stores,nr===null?xn.stores=[_n]:nr.push(_n))}function N2(_n,xn,nr,Lr){xn.value=nr,xn.getSnapshot=Lr,F2(xn)&&D_(_n,1,-1)}function Vw(_n,xn,nr){return nr(function(){F2(xn)&&D_(_n,1,-1)})}function F2(_n){var xn=_n.getSnapshot;_n=_n.value;try{var nr=xn();return!M1(_n,nr)}catch{return!0}}function p2(_n){var xn=tx();return typeof _n=="function"&&(_n=_n()),xn.memoizedState=xn.baseState=_n,_n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:qx,lastRenderedState:_n},xn.queue=_n,_n=_n.dispatch=t_.bind(null,Dv,_n),[xn.memoizedState,_n]}function Mx(_n,xn,nr,Lr){return _n={tag:_n,create:xn,destroy:nr,deps:Lr,next:null},xn=Dv.updateQueue,xn===null?(xn={lastEffect:null,stores:null},Dv.updateQueue=xn,xn.lastEffect=_n.next=_n):(nr=xn.lastEffect,nr===null?xn.lastEffect=_n.next=_n:(Lr=nr.next,nr.next=_n,_n.next=Lr,xn.lastEffect=_n)),_n}function U2(){return w_().memoizedState}function Ix(_n,xn,nr,Lr){var Xr=tx();Dv.flags|=_n,Xr.memoizedState=Mx(1|xn,nr,void 0,Lr===void 0?null:Lr)}function nx(_n,xn,nr,Lr){var Xr=w_();Lr=Lr===void 0?null:Lr;var Uo=void 0;if(V1!==null){var S0=V1.memoizedState;if(Uo=S0.destroy,Lr!==null&&yw(Lr,S0.deps)){Xr.memoizedState=Mx(xn,nr,Uo,Lr);return}}Dv.flags|=_n,Xr.memoizedState=Mx(1|xn,nr,Uo,Lr)}function vw(_n,xn){return Ix(8390656,8,_n,xn)}function Hw(_n,xn){return nx(2048,8,_n,xn)}function E$(_n,xn){return nx(4,2,_n,xn)}function T$(_n,xn){return nx(4,4,_n,xn)}function Ww(_n,xn){if(typeof xn=="function")return _n=_n(),xn(_n),function(){xn(null)};if(xn!=null)return _n=_n(),xn.current=_n,function(){xn.current=null}}function jw(_n,xn,nr){return nr=nr!=null?nr.concat([_n]):null,nx(4,4,Ww.bind(null,xn,_n),nr)}function qw(){}function A$(_n,xn){var nr=w_();xn=xn===void 0?null:xn;var Lr=nr.memoizedState;return Lr!==null&&xn!==null&&yw(xn,Lr[1])?Lr[0]:(nr.memoizedState=[_n,xn],_n)}function z2(_n,xn){var nr=w_();xn=xn===void 0?null:xn;var Lr=nr.memoizedState;return Lr!==null&&xn!==null&&yw(xn,Lr[1])?Lr[0]:(_n=_n(),nr.memoizedState=[_n,xn],_n)}function _S(_n,xn){var nr=Ro;Ro=nr!==0&&4>nr?nr:4,_n(!0);var Lr=Vv.transition;Vv.transition={};try{_n(!1),xn()}finally{Ro=nr,Vv.transition=Lr}}function C$(){return w_().memoizedState}function L1(_n,xn,nr){var Lr=ox(_n);nr={lane:Lr,action:nr,hasEagerState:!1,eagerState:null,next:null},M$(_n)?I$(xn,nr):(G2(_n,xn,nr),nr=i_(),_n=D_(_n,Lr,nr),_n!==null&&R$(_n,xn,Lr))}function t_(_n,xn,nr){var Lr=ox(_n),Xr={lane:Lr,action:nr,hasEagerState:!1,eagerState:null,next:null};if(M$(_n))I$(xn,Xr);else{G2(_n,xn,Xr);var Uo=_n.alternate;if(_n.lanes===0&&(Uo===null||Uo.lanes===0)&&(Uo=xn.lastRenderedReducer,Uo!==null))try{var S0=xn.lastRenderedState,z0=Uo(S0,nr);if(Xr.hasEagerState=!0,Xr.eagerState=z0,M1(z0,S0))return}catch{}finally{}nr=i_(),_n=D_(_n,Lr,nr),_n!==null&&R$(_n,xn,Lr)}}function M$(_n){var xn=_n.alternate;return _n===Dv||xn!==null&&xn===Dv}function I$(_n,xn){Cx=h_=!0;var nr=_n.pending;nr===null?xn.next=xn:(xn.next=nr.next,nr.next=xn),_n.pending=xn}function G2(_n,xn,nr){P1!==null&&_n.mode&1&&!(jv&2)?(_n=xn.interleaved,_n===null?(nr.next=nr,x_===null?x_=[xn]:x_.push(xn)):(nr.next=_n.next,_n.next=nr),xn.interleaved=nr):(_n=xn.pending,_n===null?nr.next=nr:(nr.next=_n.next,_n.next=nr),xn.pending=nr)}function R$(_n,xn,nr){if(nr&4194240){var Lr=xn.lanes;Lr&=_n.pendingLanes,nr|=Lr,xn.lanes=nr,jr(_n,nr)}}var _w={readContext:y1,useCallback:k1,useContext:k1,useEffect:k1,useImperativeHandle:k1,useInsertionEffect:k1,useLayoutEffect:k1,useMemo:k1,useReducer:k1,useRef:k1,useState:k1,useDebugValue:k1,useDeferredValue:k1,useTransition:k1,useMutableSource:k1,useSyncExternalStore:k1,useId:k1,unstable_isNewReconciler:!1},Kw={readContext:y1,useCallback:function(_n,xn){return tx().memoizedState=[_n,xn===void 0?null:xn],_n},useContext:y1,useEffect:vw,useImperativeHandle:function(_n,xn,nr){return nr=nr!=null?nr.concat([_n]):null,Ix(4194308,4,Ww.bind(null,xn,_n),nr)},useLayoutEffect:function(_n,xn){return Ix(4194308,4,_n,xn)},useInsertionEffect:function(_n,xn){return Ix(4,2,_n,xn)},useMemo:function(_n,xn){var nr=tx();return xn=xn===void 0?null:xn,_n=_n(),nr.memoizedState=[_n,xn],_n},useReducer:function(_n,xn,nr){var Lr=tx();return xn=nr!==void 0?nr(xn):xn,Lr.memoizedState=Lr.baseState=xn,_n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:_n,lastRenderedState:xn},Lr.queue=_n,_n=_n.dispatch=L1.bind(null,Dv,_n),[Lr.memoizedState,_n]},useRef:function(_n){var xn=tx();return _n={current:_n},xn.memoizedState=_n},useState:p2,useDebugValue:qw,useDeferredValue:function(_n){var xn=p2(_n),nr=xn[0],Lr=xn[1];return vw(function(){var Xr=Vv.transition;Vv.transition={};try{Lr(_n)}finally{Vv.transition=Xr}},[_n]),nr},useTransition:function(){var _n=p2(!1),xn=_n[0];return _n=_S.bind(null,_n[1]),tx().memoizedState=_n,[xn,_n]},useMutableSource:function(){},useSyncExternalStore:function(_n,xn,nr){var Lr=Dv,Xr=tx();if(O0){if(nr===void 0)throw Error(Tt(407));nr=nr()}else{if(nr=xn(),P1===null)throw Error(Tt(349));b1&30||Gw(Lr,xn,nr)}Xr.memoizedState=nr;var Uo={value:nr,getSnapshot:xn};return Xr.queue=Uo,vw(Vw.bind(null,Lr,Uo,_n),[_n]),Lr.flags|=2048,Mx(9,N2.bind(null,Lr,Uo,nr,xn),void 0,null),nr},useId:function(){var _n=tx(),xn=P1.identifierPrefix;if(O0){var nr=e_,Lr=G_;nr=(Lr&~(1<<32-n1(Lr)-1)).toString(32)+nr,xn=":"+xn+"R"+nr,nr=Uw++,0<nr&&(xn+="H"+nr.toString(32)),xn+=":"}else nr=gw++,xn=":"+xn+"r"+nr.toString(32)+":";return _n.memoizedState=xn},unstable_isNewReconciler:!1},V2={readContext:y1,useCallback:A$,useContext:y1,useEffect:Hw,useImperativeHandle:jw,useInsertionEffect:E$,useLayoutEffect:T$,useMemo:z2,useReducer:d2,useRef:U2,useState:function(){return d2(qx)},useDebugValue:qw,useDeferredValue:function(_n){var xn=d2(qx),nr=xn[0],Lr=xn[1];return Hw(function(){var Xr=Vv.transition;Vv.transition={};try{Lr(_n)}finally{Vv.transition=Xr}},[_n]),nr},useTransition:function(){var _n=d2(qx)[0],xn=w_().memoizedState;return[_n,xn]},useMutableSource:zw,useSyncExternalStore:hx,useId:C$,unstable_isNewReconciler:!1},bw={readContext:y1,useCallback:A$,useContext:y1,useEffect:Hw,useImperativeHandle:jw,useInsertionEffect:E$,useLayoutEffect:T$,useMemo:z2,useReducer:f2,useRef:U2,useState:function(){return f2(qx)},useDebugValue:qw,useDeferredValue:function(_n){var xn=f2(qx),nr=xn[0],Lr=xn[1];return Hw(function(){var Xr=Vv.transition;Vv.transition={};try{Lr(_n)}finally{Vv.transition=Xr}},[_n]),nr},useTransition:function(){var _n=f2(qx)[0],xn=w_().memoizedState;return[_n,xn]},useMutableSource:zw,useSyncExternalStore:hx,useId:C$,unstable_isNewReconciler:!1};function Kx(_n,xn){try{var nr="",Lr=xn;do nr+=Vx(Lr),Lr=Lr.return;while(Lr);var Xr=nr}catch(Uo){Xr=`
Error generating stack: `+Uo.message+`
`+Uo.stack}return{value:_n,source:xn,stack:Xr}}function Zx(_n,xn){try{console.error(xn.value)}catch(nr){setTimeout(function(){throw nr})}}var h2=typeof WeakMap=="function"?WeakMap:Map;function Xx(_n,xn,nr){nr=G1(-1,nr),nr.tag=3,nr.payload={element:null};var Lr=xn.value;return nr.callback=function(){n2||(n2=!0,w2=Lr),Zx(_n,xn)},nr}function P$(_n,xn,nr){nr=G1(-1,nr),nr.tag=3;var Lr=_n.type.getDerivedStateFromError;if(typeof Lr=="function"){var Xr=xn.value;nr.payload=function(){return Lr(Xr)},nr.callback=function(){Zx(_n,xn)}}var Uo=_n.stateNode;return Uo!==null&&typeof Uo.componentDidCatch=="function"&&(nr.callback=function(){Zx(_n,xn),typeof Lr!="function"&&(q_===null?q_=new Set([this]):q_.add(this));var S0=xn.stack;this.componentDidCatch(xn.value,{componentStack:S0!==null?S0:""})}),nr}function O$(_n,xn,nr){var Lr=_n.pingCache;if(Lr===null){Lr=_n.pingCache=new h2;var Xr=new Set;Lr.set(xn,Xr)}else Xr=Lr.get(xn),Xr===void 0&&(Xr=new Set,Lr.set(xn,Xr));Xr.has(nr)||(Xr.add(nr),_n=Nx.bind(null,_n,xn,nr),xn.then(_n,_n))}function D$(_n){do{var xn;if((xn=_n.tag===13)&&(xn=_n.memoizedState,xn=xn!==null?xn.dehydrated!==null:!0),xn)return _n;_n=_n.return}while(_n!==null);return null}function B$(_n,xn,nr,Lr,Xr){return _n.mode&1?(_n.flags|=65536,_n.lanes=Xr,_n):(_n===xn?_n.flags|=65536:(_n.flags|=128,nr.flags|=131072,nr.flags&=-52805,nr.tag===1&&(nr.alternate===null?nr.tag=17:(xn=G1(-1,1),xn.tag=2,ov(nr,xn))),nr.lanes|=1),_n)}function rx(_n){_n.flags|=4}function Zw(_n,xn){if(_n!==null&&_n.child===xn.child)return!0;if(xn.flags&16)return!1;for(_n=xn.child;_n!==null;){if(_n.flags&12854||_n.subtreeFlags&12854)return!1;_n=_n.sibling}return!0}var mx,xw,u0,gx;if(Ey)mx=function(_n,xn){for(var nr=xn.child;nr!==null;){if(nr.tag===5||nr.tag===6)P0(_n,nr.stateNode);else if(nr.tag!==4&&nr.child!==null){nr.child.return=nr,nr=nr.child;continue}if(nr===xn)break;for(;nr.sibling===null;){if(nr.return===null||nr.return===xn)return;nr=nr.return}nr.sibling.return=nr.return,nr=nr.sibling}},xw=function(){},u0=function(_n,xn,nr,Lr,Xr){if(_n=_n.memoizedProps,_n!==Lr){var Uo=xn.stateNode,S0=Q_($1.current);nr=B0(Uo,nr,_n,Lr,Xr,S0),(xn.updateQueue=nr)&&rx(xn)}},gx=function(_n,xn,nr,Lr){nr!==Lr&&rx(xn)};else if(_0){mx=function(_n,xn,nr,Lr){for(var Xr=xn.child;Xr!==null;){if(Xr.tag===5){var Uo=Xr.stateNode;nr&&Lr&&(Uo=Tv(Uo,Xr.type,Xr.memoizedProps,Xr)),P0(_n,Uo)}else if(Xr.tag===6)Uo=Xr.stateNode,nr&&Lr&&(Uo=Rv(Uo,Xr.memoizedProps,Xr)),P0(_n,Uo);else if(Xr.tag!==4){if(Xr.tag===22&&Xr.memoizedState!==null)Uo=Xr.child,Uo!==null&&(Uo.return=Xr),mx(_n,Xr,!0,!0);else if(Xr.child!==null){Xr.child.return=Xr,Xr=Xr.child;continue}}if(Xr===xn)break;for(;Xr.sibling===null;){if(Xr.return===null||Xr.return===xn)return;Xr=Xr.return}Xr.sibling.return=Xr.return,Xr=Xr.sibling}};var Xw=function(_n,xn,nr,Lr){for(var Xr=xn.child;Xr!==null;){if(Xr.tag===5){var Uo=Xr.stateNode;nr&&Lr&&(Uo=Tv(Uo,Xr.type,Xr.memoizedProps,Xr)),my(_n,Uo)}else if(Xr.tag===6)Uo=Xr.stateNode,nr&&Lr&&(Uo=Rv(Uo,Xr.memoizedProps,Xr)),my(_n,Uo);else if(Xr.tag!==4){if(Xr.tag===22&&Xr.memoizedState!==null)Uo=Xr.child,Uo!==null&&(Uo.return=Xr),Xw(_n,Xr,!0,!0);else if(Xr.child!==null){Xr.child.return=Xr,Xr=Xr.child;continue}}if(Xr===xn)break;for(;Xr.sibling===null;){if(Xr.return===null||Xr.return===xn)return;Xr=Xr.return}Xr.sibling.return=Xr.return,Xr=Xr.sibling}};xw=function(_n,xn){var nr=xn.stateNode;if(!Zw(_n,xn)){_n=nr.containerInfo;var Lr=ty(_n);Xw(Lr,xn,!1,!1),nr.pendingChildren=Lr,rx(xn),ev(_n,Lr)}},u0=function(_n,xn,nr,Lr,Xr){var Uo=_n.stateNode,S0=_n.memoizedProps;if((_n=Zw(_n,xn))&&S0===Lr)xn.stateNode=Uo;else{var z0=xn.stateNode,gy=Q_($1.current),Gy=null;S0!==Lr&&(Gy=B0(z0,nr,S0,Lr,Xr,gy)),_n&&Gy===null?xn.stateNode=Uo:(Uo=$0(Uo,Gy,nr,S0,Lr,xn,_n,z0),V0(Uo,nr,Lr,Xr,gy)&&rx(xn),xn.stateNode=Uo,_n?rx(xn):mx(Uo,xn,!1,!1))}},gx=function(_n,xn,nr,Lr){nr!==Lr?(_n=Q_(hw.current),nr=Q_($1.current),xn.stateNode=K0(Lr,_n,nr,xn),rx(xn)):xn.stateNode=_n.stateNode}}else xw=function(){},u0=function(){},gx=function(){};function n_(_n,xn){if(!O0)switch(_n.tailMode){case"hidden":xn=_n.tail;for(var nr=null;xn!==null;)xn.alternate!==null&&(nr=xn),xn=xn.sibling;nr===null?_n.tail=null:nr.sibling=null;break;case"collapsed":nr=_n.tail;for(var Lr=null;nr!==null;)nr.alternate!==null&&(Lr=nr),nr=nr.sibling;Lr===null?xn||_n.tail===null?_n.tail=null:_n.tail.sibling=null:Lr.sibling=null}}function Cv(_n){var xn=_n.alternate!==null&&_n.alternate.child===_n.child,nr=0,Lr=0;if(xn)for(var Xr=_n.child;Xr!==null;)nr|=Xr.lanes|Xr.childLanes,Lr|=Xr.subtreeFlags&14680064,Lr|=Xr.flags&14680064,Xr.return=_n,Xr=Xr.sibling;else for(Xr=_n.child;Xr!==null;)nr|=Xr.lanes|Xr.childLanes,Lr|=Xr.subtreeFlags,Lr|=Xr.flags,Xr.return=_n,Xr=Xr.sibling;return _n.subtreeFlags|=Lr,_n.childLanes=nr,xn}function bS(_n,xn,nr){var Lr=xn.pendingProps;switch(zo(xn),xn.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Cv(xn),null;case 1:return c1(xn.type)&&Gv(),Cv(xn),null;case 3:return Lr=xn.stateNode,mw(),Zy(xv),Zy(fv),lv(),Lr.pendingContext&&(Lr.context=Lr.pendingContext,Lr.pendingContext=null),(_n===null||_n.child===null)&&(iy(xn)?rx(xn):_n===null||_n.memoizedState.isDehydrated&&!(xn.flags&256)||(xn.flags|=1024,Iy!==null&&(tw(Iy),Iy=null))),xw(_n,xn),Cv(xn),null;case 5:ex(xn),nr=Q_(hw.current);var Xr=xn.type;if(_n!==null&&xn.stateNode!=null)u0(_n,xn,Xr,Lr,nr),_n.ref!==xn.ref&&(xn.flags|=512,xn.flags|=2097152);else{if(!Lr){if(xn.stateNode===null)throw Error(Tt(166));return Cv(xn),null}if(_n=Q_($1.current),iy(xn)){if(!ay)throw Error(Tt(175));_n=Qo(xn.stateNode,xn.type,xn.memoizedProps,nr,_n,xn,!fy),xn.updateQueue=_n,_n!==null&&rx(xn)}else{var Uo=a0(Xr,Lr,nr,_n,xn);mx(Uo,xn,!1,!1),xn.stateNode=Uo,V0(Uo,Xr,Lr,nr,_n)&&rx(xn)}xn.ref!==null&&(xn.flags|=512,xn.flags|=2097152)}return Cv(xn),null;case 6:if(_n&&xn.stateNode!=null)gx(_n,xn,_n.memoizedProps,Lr);else{if(typeof Lr!="string"&&xn.stateNode===null)throw Error(Tt(166));if(_n=Q_(hw.current),nr=Q_($1.current),iy(xn)){if(!ay)throw Error(Tt(176));if(_n=xn.stateNode,Lr=xn.memoizedProps,(nr=c0(_n,Lr,xn,!fy))&&(Xr=s0,Xr!==null))switch(Uo=(Xr.mode&1)!==0,Xr.tag){case 3:ey(Xr.stateNode.containerInfo,_n,Lr,Uo);break;case 5:ny(Xr.type,Xr.memoizedProps,Xr.stateNode,_n,Lr,Uo)}nr&&rx(xn)}else xn.stateNode=K0(Lr,_n,nr,xn)}return Cv(xn),null;case 13:if(Zy(F0),Lr=xn.memoizedState,O0&&w0!==null&&xn.mode&1&&!(xn.flags&128)){for(_n=w0;_n;)_n=g1(_n);return Mv(),xn.flags|=98560,xn}if(Lr!==null&&Lr.dehydrated!==null){if(Lr=iy(xn),_n===null){if(!Lr)throw Error(Tt(318));if(!ay)throw Error(Tt(344));if(_n=xn.memoizedState,_n=_n!==null?_n.dehydrated:null,!_n)throw Error(Tt(317));D0(_n,xn)}else Mv(),!(xn.flags&128)&&(xn.memoizedState=null),xn.flags|=4;return Cv(xn),null}return Iy!==null&&(tw(Iy),Iy=null),xn.flags&128?(xn.lanes=nr,xn):(Lr=Lr!==null,nr=!1,_n===null?iy(xn):nr=_n.memoizedState!==null,Lr&&!nr&&(xn.child.flags|=8192,xn.mode&1&&(_n===null||F0.current&1?A1===0&&(A1=3):A2())),xn.updateQueue!==null&&(xn.flags|=4),Cv(xn),null);case 4:return mw(),xw(_n,xn),_n===null&&yy(xn.stateNode.containerInfo),Cv(xn),null;case 10:return Wx(xn.type._context),Cv(xn),null;case 17:return c1(xn.type)&&Gv(),Cv(xn),null;case 19:if(Zy(F0),Xr=xn.memoizedState,Xr===null)return Cv(xn),null;if(Lr=(xn.flags&128)!==0,Uo=Xr.rendering,Uo===null)if(Lr)n_(Xr,!1);else{if(A1!==0||_n!==null&&_n.flags&128)for(_n=xn.child;_n!==null;){if(Uo=vy(_n),Uo!==null){for(xn.flags|=128,n_(Xr,!1),_n=Uo.updateQueue,_n!==null&&(xn.updateQueue=_n,xn.flags|=4),xn.subtreeFlags=0,_n=nr,Lr=xn.child;Lr!==null;)nr=Lr,Xr=_n,nr.flags&=14680066,Uo=nr.alternate,Uo===null?(nr.childLanes=0,nr.lanes=Xr,nr.child=null,nr.subtreeFlags=0,nr.memoizedProps=null,nr.memoizedState=null,nr.updateQueue=null,nr.dependencies=null,nr.stateNode=null):(nr.childLanes=Uo.childLanes,nr.lanes=Uo.lanes,nr.child=Uo.child,nr.subtreeFlags=0,nr.deletions=null,nr.memoizedProps=Uo.memoizedProps,nr.memoizedState=Uo.memoizedState,nr.updateQueue=Uo.updateQueue,nr.type=Uo.type,Xr=Uo.dependencies,nr.dependencies=Xr===null?null:{lanes:Xr.lanes,firstContext:Xr.firstContext}),Lr=Lr.sibling;return By(F0,F0.current&1|2),xn.child}_n=_n.sibling}Xr.tail!==null&&Oy()>t2&&(xn.flags|=128,Lr=!0,n_(Xr,!1),xn.lanes=4194304)}else{if(!Lr)if(_n=vy(Uo),_n!==null){if(xn.flags|=128,Lr=!0,_n=_n.updateQueue,_n!==null&&(xn.updateQueue=_n,xn.flags|=4),n_(Xr,!0),Xr.tail===null&&Xr.tailMode==="hidden"&&!Uo.alternate&&!O0)return Cv(xn),null}else 2*Oy()-Xr.renderingStartTime>t2&&nr!==1073741824&&(xn.flags|=128,Lr=!0,n_(Xr,!1),xn.lanes=4194304);Xr.isBackwards?(Uo.sibling=xn.child,xn.child=Uo):(_n=Xr.last,_n!==null?_n.sibling=Uo:xn.child=Uo,Xr.last=Uo)}return Xr.tail!==null?(xn=Xr.tail,Xr.rendering=xn,Xr.tail=xn.sibling,Xr.renderingStartTime=Oy(),xn.sibling=null,_n=F0.current,By(F0,Lr?_n&1|2:_n&1),xn):(Cv(xn),null);case 22:case 23:return o$(),Lr=xn.memoizedState!==null,_n!==null&&_n.memoizedState!==null!==Lr&&(xn.flags|=8192),Lr&&xn.mode&1?T_&1073741824&&(Cv(xn),Ey&&xn.subtreeFlags&6&&(xn.flags|=8192)):Cv(xn),null;case 24:return null;case 25:return null}throw Error(Tt(156,xn.tag))}var xS=Lt.ReactCurrentOwner,$_=!1;function E1(_n,xn,nr,Lr){xn.child=_n===null?$$(xn,null,nr,Lr):fw(xn,_n.child,nr,Lr)}function k$(_n,xn,nr,Lr,Xr){nr=nr.render;var Uo=xn.ref;return dx(xn,Xr),Lr=d1(_n,xn,nr,Lr,Uo,Xr),nr=L2(),_n!==null&&!$_?(xn.updateQueue=_n.updateQueue,xn.flags&=-2053,_n.lanes&=~Xr,N1(_n,xn,Xr)):(O0&&nr&&Yr(xn),xn.flags|=1,E1(_n,xn,Lr,Xr),xn.child)}function L$(_n,xn,nr,Lr,Xr){if(_n===null){var Uo=nr.type;return typeof Uo=="function"&&!d$(Uo)&&Uo.defaultProps===void 0&&nr.compare===null&&nr.defaultProps===void 0?(xn.tag=15,xn.type=Uo,N$(_n,xn,Uo,Lr,Xr)):(_n=I2(nr.type,null,Lr,xn,xn.mode,Xr),_n.ref=xn.ref,_n.return=xn,xn.child=_n)}if(Uo=_n.child,!(_n.lanes&Xr)){var S0=Uo.memoizedProps;if(nr=nr.compare,nr=nr!==null?nr:_1,nr(S0,Lr)&&_n.ref===xn.ref)return N1(_n,xn,Xr)}return xn.flags|=1,_n=vx(Uo,Lr),_n.ref=xn.ref,_n.return=xn,xn.child=_n}function N$(_n,xn,nr,Lr,Xr){if(_n!==null&&_1(_n.memoizedProps,Lr)&&_n.ref===xn.ref)if($_=!1,(_n.lanes&Xr)!==0)_n.flags&131072&&($_=!0);else return xn.lanes=_n.lanes,N1(_n,xn,Xr);return V_(_n,xn,nr,Lr,Xr)}function F$(_n,xn,nr){var Lr=xn.pendingProps,Xr=Lr.children,Uo=_n!==null?_n.memoizedState:null;if(Lr.mode==="hidden")if(!(xn.mode&1))xn.memoizedState={baseLanes:0,cachePool:null},By(Ew,T_),T_|=nr;else if(nr&1073741824)xn.memoizedState={baseLanes:0,cachePool:null},Lr=Uo!==null?Uo.baseLanes:nr,By(Ew,T_),T_|=Lr;else return _n=Uo!==null?Uo.baseLanes|nr:nr,xn.lanes=xn.childLanes=1073741824,xn.memoizedState={baseLanes:_n,cachePool:null},xn.updateQueue=null,By(Ew,T_),T_|=_n,null;else Uo!==null?(Lr=Uo.baseLanes|nr,xn.memoizedState=null):Lr=nr,By(Ew,T_),T_|=Lr;return E1(_n,xn,Xr,nr),xn.child}function U$(_n,xn){var nr=xn.ref;(_n===null&&nr!==null||_n!==null&&_n.ref!==nr)&&(xn.flags|=512,xn.flags|=2097152)}function V_(_n,xn,nr,Lr,Xr){var Uo=c1(nr)?t1:fv.current;return Uo=u1(xn,Uo),dx(xn,Xr),nr=d1(_n,xn,nr,Lr,Uo,Xr),Lr=L2(),_n!==null&&!$_?(xn.updateQueue=_n.updateQueue,xn.flags&=-2053,_n.lanes&=~Xr,N1(_n,xn,Xr)):(O0&&Lr&&Yr(xn),xn.flags|=1,E1(_n,xn,nr,Xr),xn.child)}function z$(_n,xn,nr,Lr,Xr){if(c1(nr)){var Uo=!0;Av(xn)}else Uo=!1;if(dx(xn,Xr),xn.stateNode===null)_n!==null&&(_n.alternate=null,xn.alternate=null,xn.flags|=2),Nw(xn,nr,Lr),U_(xn,nr,Lr,Xr),Lr=!0;else if(_n===null){var S0=xn.stateNode,z0=xn.memoizedProps;S0.props=z0;var gy=S0.context,Gy=nr.contextType;typeof Gy=="object"&&Gy!==null?Gy=y1(Gy):(Gy=c1(nr)?t1:fv.current,Gy=u1(xn,Gy));var cv=nr.getDerivedStateFromProps,Uv=typeof cv=="function"||typeof S0.getSnapshotBeforeUpdate=="function";Uv||typeof S0.UNSAFE_componentWillReceiveProps!="function"&&typeof S0.componentWillReceiveProps!="function"||(z0!==Lr||gy!==Gy)&&dw(xn,S0,Lr,Gy),w1=!1;var $v=xn.memoizedState;S0.state=$v,Q1(xn,Lr,S0,Xr),gy=xn.memoizedState,z0!==Lr||$v!==gy||xv.current||w1?(typeof cv=="function"&&(Sx(xn,nr,cv,Lr),gy=xn.memoizedState),(z0=w1||cw(xn,nr,z0,Lr,$v,gy,Gy))?(Uv||typeof S0.UNSAFE_componentWillMount!="function"&&typeof S0.componentWillMount!="function"||(typeof S0.componentWillMount=="function"&&S0.componentWillMount(),typeof S0.UNSAFE_componentWillMount=="function"&&S0.UNSAFE_componentWillMount()),typeof S0.componentDidMount=="function"&&(xn.flags|=4194308)):(typeof S0.componentDidMount=="function"&&(xn.flags|=4194308),xn.memoizedProps=Lr,xn.memoizedState=gy),S0.props=Lr,S0.state=gy,S0.context=Gy,Lr=z0):(typeof S0.componentDidMount=="function"&&(xn.flags|=4194308),Lr=!1)}else{S0=xn.stateNode,kw(_n,xn),z0=xn.memoizedProps,Gy=xn.type===xn.elementType?z0:I1(xn.type,z0),S0.props=Gy,Uv=xn.pendingProps,$v=S0.context,gy=nr.contextType,typeof gy=="object"&&gy!==null?gy=y1(gy):(gy=c1(nr)?t1:fv.current,gy=u1(xn,gy));var p1=nr.getDerivedStateFromProps;(cv=typeof p1=="function"||typeof S0.getSnapshotBeforeUpdate=="function")||typeof S0.UNSAFE_componentWillReceiveProps!="function"&&typeof S0.componentWillReceiveProps!="function"||(z0!==Uv||$v!==gy)&&dw(xn,S0,Lr,gy),w1=!1,$v=xn.memoizedState,S0.state=$v,Q1(xn,Lr,S0,Xr);var mv=xn.memoizedState;z0!==Uv||$v!==mv||xv.current||w1?(typeof p1=="function"&&(Sx(xn,nr,p1,Lr),mv=xn.memoizedState),(Gy=w1||cw(xn,nr,Gy,Lr,$v,mv,gy)||!1)?(cv||typeof S0.UNSAFE_componentWillUpdate!="function"&&typeof S0.componentWillUpdate!="function"||(typeof S0.componentWillUpdate=="function"&&S0.componentWillUpdate(Lr,mv,gy),typeof S0.UNSAFE_componentWillUpdate=="function"&&S0.UNSAFE_componentWillUpdate(Lr,mv,gy)),typeof S0.componentDidUpdate=="function"&&(xn.flags|=4),typeof S0.getSnapshotBeforeUpdate=="function"&&(xn.flags|=1024)):(typeof S0.componentDidUpdate!="function"||z0===_n.memoizedProps&&$v===_n.memoizedState||(xn.flags|=4),typeof S0.getSnapshotBeforeUpdate!="function"||z0===_n.memoizedProps&&$v===_n.memoizedState||(xn.flags|=1024),xn.memoizedProps=Lr,xn.memoizedState=mv),S0.props=Lr,S0.state=mv,S0.context=gy,Lr=Gy):(typeof S0.componentDidUpdate!="function"||z0===_n.memoizedProps&&$v===_n.memoizedState||(xn.flags|=4),typeof S0.getSnapshotBeforeUpdate!="function"||z0===_n.memoizedProps&&$v===_n.memoizedState||(xn.flags|=1024),Lr=!1)}return H2(_n,xn,nr,Lr,Uo,Xr)}function H2(_n,xn,nr,Lr,Xr,Uo){U$(_n,xn);var S0=(xn.flags&128)!==0;if(!Lr&&!S0)return Xr&&zy(xn,nr,!1),N1(_n,xn,Uo);Lr=xn.stateNode,xS.current=xn;var z0=S0&&typeof nr.getDerivedStateFromError!="function"?null:Lr.render();return xn.flags|=1,_n!==null&&S0?(xn.child=fw(xn,_n.child,null,Uo),xn.child=fw(xn,null,z0,Uo)):E1(_n,xn,z0,Uo),xn.memoizedState=Lr.state,Xr&&zy(xn,nr,!0),xn.child}function G$(_n){var xn=_n.stateNode;xn.pendingContext?Ov(_n,xn.pendingContext,xn.pendingContext!==xn.context):xn.context&&Ov(_n,xn.context,!1),k2(_n,xn.containerInfo)}function V$(_n,xn,nr,Lr,Xr){return Mv(),Qv(Xr),xn.flags|=256,E1(_n,xn,nr,Lr),xn.child}var m2={dehydrated:null,treeContext:null,retryLane:0};function O_(_n){return{baseLanes:_n,cachePool:null}}function H$(_n,xn,nr){var Lr=xn.pendingProps,Xr=F0.current,Uo=!1,S0=(xn.flags&128)!==0,z0;if((z0=S0)||(z0=_n!==null&&_n.memoizedState===null?!1:(Xr&2)!==0),z0?(Uo=!0,xn.flags&=-129):(_n===null||_n.memoizedState!==null)&&(Xr|=1),By(F0,Xr&1),_n===null)return a1(xn),_n=xn.memoizedState,_n!==null&&(_n=_n.dehydrated,_n!==null)?(xn.mode&1?Fv(_n)?xn.lanes=8:xn.lanes=1073741824:xn.lanes=1,null):(Xr=Lr.children,_n=Lr.fallback,Uo?(Lr=xn.mode,Uo=xn.child,Xr={mode:"hidden",children:Xr},!(Lr&1)&&Uo!==null?(Uo.childLanes=0,Uo.pendingProps=Xr):Uo=a2(Xr,Lr,0,null),_n=Ux(_n,Lr,nr,null),Uo.return=xn,_n.return=xn,Uo.sibling=_n,xn.child=Uo,xn.child.memoizedState=O_(nr),xn.memoizedState=m2,_n):W2(xn,Xr));if(Xr=_n.memoizedState,Xr!==null){if(z0=Xr.dehydrated,z0!==null){if(S0)return xn.flags&256?(xn.flags&=-257,g2(_n,xn,nr,Error(Tt(422)))):xn.memoizedState!==null?(xn.child=_n.child,xn.flags|=128,null):(Uo=Lr.fallback,Xr=xn.mode,Lr=a2({mode:"visible",children:Lr.children},Xr,0,null),Uo=Ux(Uo,Xr,nr,null),Uo.flags|=2,Lr.return=xn,Uo.return=xn,Lr.sibling=Uo,xn.child=Lr,xn.mode&1&&fw(xn,_n.child,null,nr),xn.child.memoizedState=O_(nr),xn.memoizedState=m2,Uo);if(!(xn.mode&1))xn=g2(_n,xn,nr,null);else if(Fv(z0))xn=g2(_n,xn,nr,Error(Tt(419)));else if(Lr=(nr&_n.childLanes)!==0,$_||Lr){if(Lr=P1,Lr!==null){switch(nr&-nr){case 4:Uo=2;break;case 16:Uo=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:Uo=32;break;case 536870912:Uo=268435456;break;default:Uo=0}Lr=Uo&(Lr.suspendedLanes|nr)?0:Uo,Lr!==0&&Lr!==Xr.retryLane&&(Xr.retryLane=Lr,D_(_n,Lr,-1))}A2(),xn=g2(_n,xn,nr,Error(Tt(421)))}else Pv(z0)?(xn.flags|=128,xn.child=_n.child,xn=Fx.bind(null,_n),Jv(z0,xn),xn=null):(nr=Xr.treeContext,ay&&(w0=c_(z0),s0=xn,O0=!0,Iy=null,fy=!1,nr!==null&&(K1[Z1++]=G_,K1[Z1++]=e_,K1[Z1++]=z_,G_=nr.id,e_=nr.overflow,z_=xn)),xn=W2(xn,xn.pendingProps.children),xn.flags|=4096);return xn}return Uo?(Lr=j$(_n,xn,Lr.children,Lr.fallback,nr),Uo=xn.child,Xr=_n.child.memoizedState,Uo.memoizedState=Xr===null?O_(nr):{baseLanes:Xr.baseLanes|nr,cachePool:null},Uo.childLanes=_n.childLanes&~nr,xn.memoizedState=m2,Lr):(nr=W$(_n,xn,Lr.children,nr),xn.memoizedState=null,nr)}return Uo?(Lr=j$(_n,xn,Lr.children,Lr.fallback,nr),Uo=xn.child,Xr=_n.child.memoizedState,Uo.memoizedState=Xr===null?O_(nr):{baseLanes:Xr.baseLanes|nr,cachePool:null},Uo.childLanes=_n.childLanes&~nr,xn.memoizedState=m2,Lr):(nr=W$(_n,xn,Lr.children,nr),xn.memoizedState=null,nr)}function W2(_n,xn){return xn=a2({mode:"visible",children:xn},_n.mode,0,null),xn.return=_n,_n.child=xn}function W$(_n,xn,nr,Lr){var Xr=_n.child;return _n=Xr.sibling,nr=vx(Xr,{mode:"visible",children:nr}),!(xn.mode&1)&&(nr.lanes=Lr),nr.return=xn,nr.sibling=null,_n!==null&&(Lr=xn.deletions,Lr===null?(xn.deletions=[_n],xn.flags|=16):Lr.push(_n)),xn.child=nr}function j$(_n,xn,nr,Lr,Xr){var Uo=xn.mode;_n=_n.child;var S0=_n.sibling,z0={mode:"hidden",children:nr};return!(Uo&1)&&xn.child!==_n?(nr=xn.child,nr.childLanes=0,nr.pendingProps=z0,xn.deletions=null):(nr=vx(_n,z0),nr.subtreeFlags=_n.subtreeFlags&14680064),S0!==null?Lr=vx(S0,Lr):(Lr=Ux(Lr,Uo,Xr,null),Lr.flags|=2),Lr.return=xn,nr.return=xn,nr.sibling=Lr,xn.child=nr,Lr}function g2(_n,xn,nr,Lr){return Lr!==null&&Qv(Lr),fw(xn,_n.child,null,nr),_n=W2(xn,xn.pendingProps.children),_n.flags|=2,xn.memoizedState=null,_n}function Rx(_n,xn,nr){_n.lanes|=xn;var Lr=_n.alternate;Lr!==null&&(Lr.lanes|=xn),jx(_n.return,xn,nr)}function j2(_n,xn,nr,Lr,Xr){var Uo=_n.memoizedState;Uo===null?_n.memoizedState={isBackwards:xn,rendering:null,renderingStartTime:0,last:Lr,tail:nr,tailMode:Xr}:(Uo.isBackwards=xn,Uo.rendering=null,Uo.renderingStartTime=0,Uo.last=Lr,Uo.tail=nr,Uo.tailMode=Xr)}function q$(_n,xn,nr){var Lr=xn.pendingProps,Xr=Lr.revealOrder,Uo=Lr.tail;if(E1(_n,xn,Lr.children,nr),Lr=F0.current,Lr&2)Lr=Lr&1|2,xn.flags|=128;else{if(_n!==null&&_n.flags&128)e:for(_n=xn.child;_n!==null;){if(_n.tag===13)_n.memoizedState!==null&&Rx(_n,nr,xn);else if(_n.tag===19)Rx(_n,nr,xn);else if(_n.child!==null){_n.child.return=_n,_n=_n.child;continue}if(_n===xn)break e;for(;_n.sibling===null;){if(_n.return===null||_n.return===xn)break e;_n=_n.return}_n.sibling.return=_n.return,_n=_n.sibling}Lr&=1}if(By(F0,Lr),!(xn.mode&1))xn.memoizedState=null;else switch(Xr){case"forwards":for(nr=xn.child,Xr=null;nr!==null;)_n=nr.alternate,_n!==null&&vy(_n)===null&&(Xr=nr),nr=nr.sibling;nr=Xr,nr===null?(Xr=xn.child,xn.child=null):(Xr=nr.sibling,nr.sibling=null),j2(xn,!1,Xr,nr,Uo);break;case"backwards":for(nr=null,Xr=xn.child,xn.child=null;Xr!==null;){if(_n=Xr.alternate,_n!==null&&vy(_n)===null){xn.child=Xr;break}_n=Xr.sibling,Xr.sibling=nr,nr=Xr,Xr=_n}j2(xn,!0,nr,null,Uo);break;case"together":j2(xn,!1,null,null,void 0);break;default:xn.memoizedState=null}return xn.child}function N1(_n,xn,nr){if(_n!==null&&(xn.dependencies=_n.dependencies),Aw|=xn.lanes,!(nr&xn.childLanes))return null;if(_n!==null&&xn.child!==_n.child)throw Error(Tt(153));if(xn.child!==null){for(_n=xn.child,nr=vx(_n,_n.pendingProps),xn.child=nr,nr.return=xn;_n.sibling!==null;)_n=_n.sibling,nr=nr.sibling=vx(_n,_n.pendingProps),nr.return=xn;nr.sibling=null}return xn.child}function wS(_n,xn,nr){switch(xn.tag){case 3:G$(xn),Mv();break;case 5:S$(xn);break;case 1:c1(xn.type)&&Av(xn);break;case 4:k2(xn,xn.stateNode.containerInfo);break;case 10:uw(xn,xn.type._context,xn.memoizedProps.value);break;case 13:var Lr=xn.memoizedState;if(Lr!==null)return Lr.dehydrated!==null?(By(F0,F0.current&1),xn.flags|=128,null):nr&xn.child.childLanes?H$(_n,xn,nr):(By(F0,F0.current&1),_n=N1(_n,xn,nr),_n!==null?_n.sibling:null);By(F0,F0.current&1);break;case 19:if(Lr=(nr&xn.childLanes)!==0,_n.flags&128){if(Lr)return q$(_n,xn,nr);xn.flags|=128}var Xr=xn.memoizedState;if(Xr!==null&&(Xr.rendering=null,Xr.tail=null,Xr.lastEffect=null),By(F0,F0.current),Lr)break;return null;case 22:case 23:return xn.lanes=0,F$(_n,xn,nr)}return N1(_n,xn,nr)}function $S(_n,xn){switch(zo(xn),xn.tag){case 1:return c1(xn.type)&&Gv(),_n=xn.flags,_n&65536?(xn.flags=_n&-65537|128,xn):null;case 3:return mw(),Zy(xv),Zy(fv),lv(),_n=xn.flags,_n&65536&&!(_n&128)?(xn.flags=_n&-65537|128,xn):null;case 5:return ex(xn),null;case 13:if(Zy(F0),_n=xn.memoizedState,_n!==null&&_n.dehydrated!==null){if(xn.alternate===null)throw Error(Tt(340));Mv()}return _n=xn.flags,_n&65536?(xn.flags=_n&-65537|128,xn):null;case 19:return Zy(F0),null;case 4:return mw(),null;case 10:return Wx(xn.type._context),null;case 22:case 23:return o$(),null;case 24:return null;default:return null}}var y2=!1,Yx=!1,SS=typeof WeakSet=="function"?WeakSet:Set,tv=null;function Yw(_n,xn){var nr=_n.ref;if(nr!==null)if(typeof nr=="function")try{nr(null)}catch(Lr){a_(_n,xn,Lr)}else nr.current=null}function q2(_n,xn,nr){try{nr()}catch(Lr){a_(_n,xn,Lr)}}var K$=!1;function K2(_n,xn){for(m0(_n.containerInfo),tv=xn;tv!==null;)if(_n=tv,xn=_n.child,(_n.subtreeFlags&1028)!==0&&xn!==null)xn.return=_n,tv=xn;else for(;tv!==null;){_n=tv;try{var nr=_n.alternate;if(_n.flags&1024)switch(_n.tag){case 0:case 11:case 15:break;case 1:if(nr!==null){var Lr=nr.memoizedProps,Xr=nr.memoizedState,Uo=_n.stateNode,S0=Uo.getSnapshotBeforeUpdate(_n.elementType===_n.type?Lr:I1(_n.type,Lr),Xr);Uo.__reactInternalSnapshotBeforeUpdate=S0}break;case 3:Ey&&k0(_n.stateNode.containerInfo);break;case 5:case 6:case 4:case 17:break;default:throw Error(Tt(163))}}catch(z0){a_(_n,_n.return,z0)}if(xn=_n.sibling,xn!==null){xn.return=_n.return,tv=xn;break}tv=_n.return}return nr=K$,K$=!1,nr}function H_(_n,xn,nr){var Lr=xn.updateQueue;if(Lr=Lr!==null?Lr.lastEffect:null,Lr!==null){var Xr=Lr=Lr.next;do{if((Xr.tag&_n)===_n){var Uo=Xr.destroy;Xr.destroy=void 0,Uo!==void 0&&q2(xn,nr,Uo)}Xr=Xr.next}while(Xr!==Lr)}}function Px(_n,xn){if(xn=xn.updateQueue,xn=xn!==null?xn.lastEffect:null,xn!==null){var nr=xn=xn.next;do{if((nr.tag&_n)===_n){var Lr=nr.create;nr.destroy=Lr()}nr=nr.next}while(nr!==xn)}}function Z2(_n){var xn=_n.ref;if(xn!==null){var nr=_n.stateNode;switch(_n.tag){case 5:_n=t0(nr);break;default:_n=nr}typeof xn=="function"?xn(_n):xn.current=_n}}function X2(_n,xn,nr){if(Yy&&typeof Yy.onCommitFiberUnmount=="function")try{Yy.onCommitFiberUnmount(q0,xn)}catch{}switch(xn.tag){case 0:case 11:case 14:case 15:if(_n=xn.updateQueue,_n!==null&&(_n=_n.lastEffect,_n!==null)){var Lr=_n=_n.next;do{var Xr=Lr,Uo=Xr.destroy;Xr=Xr.tag,Uo!==void 0&&(Xr&2||Xr&4)&&q2(xn,nr,Uo),Lr=Lr.next}while(Lr!==_n)}break;case 1:if(Yw(xn,nr),_n=xn.stateNode,typeof _n.componentWillUnmount=="function")try{_n.props=xn.memoizedProps,_n.state=xn.memoizedState,_n.componentWillUnmount()}catch(S0){a_(xn,nr,S0)}break;case 5:Yw(xn,nr);break;case 4:Ey?J2(_n,xn,nr):_0&&_0&&(xn=xn.stateNode.containerInfo,nr=ty(xn),vv(xn,nr))}}function Z$(_n,xn,nr){for(var Lr=xn;;)if(X2(_n,Lr,nr),Lr.child===null||Ey&&Lr.tag===4){if(Lr===xn)break;for(;Lr.sibling===null;){if(Lr.return===null||Lr.return===xn)return;Lr=Lr.return}Lr.sibling.return=Lr.return,Lr=Lr.sibling}else Lr.child.return=Lr,Lr=Lr.child}function ix(_n){var xn=_n.alternate;xn!==null&&(_n.alternate=null,ix(xn)),_n.child=null,_n.deletions=null,_n.sibling=null,_n.tag===5&&(xn=_n.stateNode,xn!==null&&Dy(xn)),_n.stateNode=null,_n.return=null,_n.dependencies=null,_n.memoizedProps=null,_n.memoizedState=null,_n.pendingProps=null,_n.stateNode=null,_n.updateQueue=null}function v2(_n){return _n.tag===5||_n.tag===3||_n.tag===4}function Ox(_n){e:for(;;){for(;_n.sibling===null;){if(_n.return===null||v2(_n.return))return null;_n=_n.return}for(_n.sibling.return=_n.return,_n=_n.sibling;_n.tag!==5&&_n.tag!==6&&_n.tag!==18;){if(_n.flags&2||_n.child===null||_n.tag===4)continue e;_n.child.return=_n,_n=_n.child}if(!(_n.flags&2))return _n.stateNode}}function S_(_n){if(Ey){e:{for(var xn=_n.return;xn!==null;){if(v2(xn))break e;xn=xn.return}throw Error(Tt(160))}var nr=xn;switch(nr.tag){case 5:xn=nr.stateNode,nr.flags&32&&(U0(xn),nr.flags&=-33),nr=Ox(_n),_2(_n,nr,xn);break;case 3:case 4:xn=nr.stateNode.containerInfo,nr=Ox(_n),Y2(_n,nr,xn);break;default:throw Error(Tt(161))}}}function Y2(_n,xn,nr){var Lr=_n.tag;if(Lr===5||Lr===6)_n=_n.stateNode,xn?Qy(nr,_n,xn):hy(nr,_n);else if(Lr!==4&&(_n=_n.child,_n!==null))for(Y2(_n,xn,nr),_n=_n.sibling;_n!==null;)Y2(_n,xn,nr),_n=_n.sibling}function _2(_n,xn,nr){var Lr=_n.tag;if(Lr===5||Lr===6)_n=_n.stateNode,xn?Ev(nr,_n,xn):Xy(nr,_n);else if(Lr!==4&&(_n=_n.child,_n!==null))for(_2(_n,xn,nr),_n=_n.sibling;_n!==null;)_2(_n,xn,nr),_n=_n.sibling}function J2(_n,xn,nr){for(var Lr=xn,Xr=!1,Uo,S0;;){if(!Xr){Xr=Lr.return;e:for(;;){if(Xr===null)throw Error(Tt(160));switch(Uo=Xr.stateNode,Xr.tag){case 5:S0=!1;break e;case 3:Uo=Uo.containerInfo,S0=!0;break e;case 4:Uo=Uo.containerInfo,S0=!0;break e}Xr=Xr.return}Xr=!0}if(Lr.tag===5||Lr.tag===6)Z$(_n,Lr,nr),S0?C0(Uo,Lr.stateNode):cy(Uo,Lr.stateNode);else if(Lr.tag===18)S0?A0(Uo,Lr.stateNode):I0(Uo,Lr.stateNode);else if(Lr.tag===4){if(Lr.child!==null){Uo=Lr.stateNode.containerInfo,S0=!0,Lr.child.return=Lr,Lr=Lr.child;continue}}else if(X2(_n,Lr,nr),Lr.child!==null){Lr.child.return=Lr,Lr=Lr.child;continue}if(Lr===xn)break;for(;Lr.sibling===null;){if(Lr.return===null||Lr.return===xn)return;Lr=Lr.return,Lr.tag===4&&(Xr=!1)}Lr.sibling.return=Lr.return,Lr=Lr.sibling}}function Jx(_n,xn){if(Ey){switch(xn.tag){case 0:case 11:case 14:case 15:H_(3,xn,xn.return),Px(3,xn),H_(5,xn,xn.return);return;case 1:return;case 5:var nr=xn.stateNode;if(nr!=null){var Lr=xn.memoizedProps;_n=_n!==null?_n.memoizedProps:Lr;var Xr=xn.type,Uo=xn.updateQueue;xn.updateQueue=null,Uo!==null&&Sy(nr,Uo,Xr,_n,Lr,xn)}return;case 6:if(xn.stateNode===null)throw Error(Tt(162));nr=xn.memoizedProps,Ly(xn.stateNode,_n!==null?_n.memoizedProps:nr,nr);return;case 3:ay&&_n!==null&&_n.memoizedState.isDehydrated&&g0(xn.stateNode.containerInfo);return;case 12:return;case 13:W_(xn);return;case 19:W_(xn);return;case 17:return}throw Error(Tt(163))}switch(xn.tag){case 0:case 11:case 14:case 15:H_(3,xn,xn.return),Px(3,xn),H_(5,xn,xn.return);return;case 12:return;case 13:W_(xn);return;case 19:W_(xn);return;case 3:ay&&_n!==null&&_n.memoizedState.isDehydrated&&g0(xn.stateNode.containerInfo);break;case 22:case 23:return}e:if(_0){switch(xn.tag){case 1:case 5:case 6:break e;case 3:case 4:xn=xn.stateNode,vv(xn.containerInfo,xn.pendingChildren);break e}throw Error(Tt(163))}}function W_(_n){var xn=_n.updateQueue;if(xn!==null){_n.updateQueue=null;var nr=_n.stateNode;nr===null&&(nr=_n.stateNode=new SS),xn.forEach(function(Lr){var Xr=rS.bind(null,_n,Lr);nr.has(Lr)||(nr.add(Lr),Lr.then(Xr,Xr))})}}function X$(_n,xn){for(tv=xn;tv!==null;){xn=tv;var nr=xn.deletions;if(nr!==null)for(var Lr=0;Lr<nr.length;Lr++){var Xr=nr[Lr];try{var Uo=_n;Ey?J2(Uo,Xr,xn):Z$(Uo,Xr,xn);var S0=Xr.alternate;S0!==null&&(S0.return=null),Xr.return=null}catch(gv){a_(Xr,xn,gv)}}if(nr=xn.child,xn.subtreeFlags&12854&&nr!==null)nr.return=xn,tv=nr;else for(;tv!==null;){xn=tv;try{var z0=xn.flags;if(z0&32&&Ey&&U0(xn.stateNode),z0&512){var gy=xn.alternate;if(gy!==null){var Gy=gy.ref;Gy!==null&&(typeof Gy=="function"?Gy(null):Gy.current=null)}}if(z0&8192)switch(xn.tag){case 13:if(xn.memoizedState!==null){var cv=xn.alternate;(cv===null||cv.memoizedState===null)&&(r$=Oy())}break;case 22:var Uv=xn.memoizedState!==null,$v=xn.alternate,p1=$v!==null&&$v.memoizedState!==null;if(nr=xn,Ey){e:if(Lr=nr,Xr=Uv,Uo=null,Ey)for(var mv=Lr;;){if(mv.tag===5){if(Uo===null){Uo=mv;var l_=mv.stateNode;Xr?xy(l_):v0(mv.stateNode,mv.memoizedProps)}}else if(mv.tag===6){if(Uo===null){var C_=mv.stateNode;Xr?o0(C_):i0(C_,mv.memoizedProps)}}else if((mv.tag!==22&&mv.tag!==23||mv.memoizedState===null||mv===Lr)&&mv.child!==null){mv.child.return=mv,mv=mv.child;continue}if(mv===Lr)break;for(;mv.sibling===null;){if(mv.return===null||mv.return===Lr)break e;Uo===mv&&(Uo=null),mv=mv.return}Uo===mv&&(Uo=null),mv.sibling.return=mv.return,mv=mv.sibling}}if(Uv&&!p1&&nr.mode&1){tv=nr;for(var Z0=nr.child;Z0!==null;){for(nr=tv=Z0;tv!==null;){Lr=tv;var H0=Lr.child;switch(Lr.tag){case 0:case 11:case 14:case 15:H_(4,Lr,Lr.return);break;case 1:Yw(Lr,Lr.return);var ly=Lr.stateNode;if(typeof ly.componentWillUnmount=="function"){var iv=Lr.return;try{ly.props=Lr.memoizedProps,ly.state=Lr.memoizedState,ly.componentWillUnmount()}catch(gv){a_(Lr,iv,gv)}}break;case 5:Yw(Lr,Lr.return);break;case 22:if(Lr.memoizedState!==null){Q2(nr);continue}}H0!==null?(H0.return=Lr,tv=H0):Q2(nr)}Z0=Z0.sibling}}}switch(z0&4102){case 2:S_(xn),xn.flags&=-3;break;case 6:S_(xn),xn.flags&=-3,Jx(xn.alternate,xn);break;case 4096:xn.flags&=-4097;break;case 4100:xn.flags&=-4097,Jx(xn.alternate,xn);break;case 4:Jx(xn.alternate,xn)}}catch(gv){a_(xn,xn.return,gv)}if(nr=xn.sibling,nr!==null){nr.return=xn.return,tv=nr;break}tv=xn.return}}}function ES(_n,xn,nr){tv=_n,Jw(_n)}function Jw(_n,xn,nr){for(var Lr=(_n.mode&1)!==0;tv!==null;){var Xr=tv,Uo=Xr.child;if(Xr.tag===22&&Lr){var S0=Xr.memoizedState!==null||y2;if(!S0){var z0=Xr.alternate,gy=z0!==null&&z0.memoizedState!==null||Yx;z0=y2;var Gy=Yx;if(y2=S0,(Yx=gy)&&!Gy)for(tv=Xr;tv!==null;)S0=tv,gy=S0.child,S0.tag===22&&S0.memoizedState!==null?W1(Xr):gy!==null?(gy.return=S0,tv=gy):W1(Xr);for(;Uo!==null;)tv=Uo,Jw(Uo),Uo=Uo.sibling;tv=Xr,y2=z0,Yx=Gy}Y$(_n)}else Xr.subtreeFlags&8772&&Uo!==null?(Uo.return=Xr,tv=Uo):Y$(_n)}}function Y$(_n){for(;tv!==null;){var xn=tv;if(xn.flags&8772){var nr=xn.alternate;try{if(xn.flags&8772)switch(xn.tag){case 0:case 11:case 15:Yx||Px(5,xn);break;case 1:var Lr=xn.stateNode;if(xn.flags&4&&!Yx)if(nr===null)Lr.componentDidMount();else{var Xr=xn.elementType===xn.type?nr.memoizedProps:I1(xn.type,nr.memoizedProps);Lr.componentDidUpdate(Xr,nr.memoizedState,Lr.__reactInternalSnapshotBeforeUpdate)}var Uo=xn.updateQueue;Uo!==null&&f_(xn,Uo,Lr);break;case 3:var S0=xn.updateQueue;if(S0!==null){if(nr=null,xn.child!==null)switch(xn.child.tag){case 5:nr=t0(xn.child.stateNode);break;case 1:nr=xn.child.stateNode}f_(xn,S0,nr)}break;case 5:var z0=xn.stateNode;nr===null&&xn.flags&4&&Py(z0,xn.type,xn.memoizedProps,xn);break;case 6:break;case 4:break;case 12:break;case 13:if(ay&&xn.memoizedState===null){var gy=xn.alternate;if(gy!==null){var Gy=gy.memoizedState;if(Gy!==null){var cv=Gy.dehydrated;cv!==null&&b0(cv)}}}break;case 19:case 17:case 21:case 22:case 23:break;default:throw Error(Tt(163))}Yx||xn.flags&512&&Z2(xn)}catch(Uv){a_(xn,xn.return,Uv)}}if(xn===_n){tv=null;break}if(nr=xn.sibling,nr!==null){nr.return=xn.return,tv=nr;break}tv=xn.return}}function Q2(_n){for(;tv!==null;){var xn=tv;if(xn===_n){tv=null;break}var nr=xn.sibling;if(nr!==null){nr.return=xn.return,tv=nr;break}tv=xn.return}}function W1(_n){for(;tv!==null;){var xn=tv;try{switch(xn.tag){case 0:case 11:case 15:var nr=xn.return;try{Px(4,xn)}catch(gy){a_(xn,nr,gy)}break;case 1:var Lr=xn.stateNode;if(typeof Lr.componentDidMount=="function"){var Xr=xn.return;try{Lr.componentDidMount()}catch(gy){a_(xn,Xr,gy)}}var Uo=xn.return;try{Z2(xn)}catch(gy){a_(xn,Uo,gy)}break;case 5:var S0=xn.return;try{Z2(xn)}catch(gy){a_(xn,S0,gy)}}}catch(gy){a_(xn,xn.return,gy)}if(xn===_n){tv=null;break}var z0=xn.sibling;if(z0!==null){z0.return=xn.return,tv=z0;break}tv=xn.return}}var ww=0,Qw=1,E_=2,$w=3,Qx=4;if(typeof Symbol=="function"&&Symbol.for){var j_=Symbol.for;ww=j_("selector.component"),Qw=j_("selector.has_pseudo_class"),E_=j_("selector.role"),$w=j_("selector.test_id"),Qx=j_("selector.text")}function b2(_n){var xn=J0(_n);if(xn!=null){if(typeof xn.memoizedProps["data-testname"]!="string")throw Error(Tt(364));return xn}if(_n=y0(_n),_n===null)throw Error(Tt(362));return _n.stateNode.current}function X1(_n,xn){switch(xn.$$typeof){case ww:if(_n.type===xn.value)return!0;break;case Qw:e:{xn=xn.value,_n=[_n,0];for(var nr=0;nr<_n.length;){var Lr=_n[nr++],Xr=_n[nr++],Uo=xn[Xr];if(Lr.tag!==5||!G0(Lr)){for(;Uo!=null&&X1(Lr,Uo);)Xr++,Uo=xn[Xr];if(Xr===xn.length){xn=!0;break e}else for(Lr=Lr.child;Lr!==null;)_n.push(Lr,Xr),Lr=Lr.sibling}}xn=!1}return xn;case E_:if(_n.tag===5&&sy(_n.stateNode,xn.value))return!0;break;case Qx:if((_n.tag===5||_n.tag===6)&&(_n=M0(_n),_n!==null&&0<=_n.indexOf(xn.value)))return!0;break;case $w:if(_n.tag===5&&(_n=_n.memoizedProps["data-testname"],typeof _n=="string"&&_n.toLowerCase()===xn.value.toLowerCase()))return!0;break;default:throw Error(Tt(365))}return!1}function e2(_n){switch(_n.$$typeof){case ww:return"<"+(Zr(_n.value)||"Unknown")+">";case Qw:return":has("+(e2(_n)||"")+")";case E_:return'[role="'+_n.value+'"]';case Qx:return'"'+_n.value+'"';case $w:return'[data-testname="'+_n.value+'"]';default:throw Error(Tt(365))}}function J$(_n,xn){var nr=[];_n=[_n,0];for(var Lr=0;Lr<_n.length;){var Xr=_n[Lr++],Uo=_n[Lr++],S0=xn[Uo];if(Xr.tag!==5||!G0(Xr)){for(;S0!=null&&X1(Xr,S0);)Uo++,S0=xn[Uo];if(Uo===xn.length)nr.push(Xr);else for(Xr=Xr.child;Xr!==null;)_n.push(Xr,Uo),Xr=Xr.sibling}}return nr}function e$(_n,xn){if(!rv)throw Error(Tt(363));_n=b2(_n),_n=J$(_n,xn),xn=[],_n=Array.from(_n);for(var nr=0;nr<_n.length;){var Lr=_n[nr++];if(Lr.tag===5)G0(Lr)||xn.push(Lr.stateNode);else for(Lr=Lr.child;Lr!==null;)_n.push(Lr),Lr=Lr.sibling}return xn}var TS=Math.ceil,Sw=Lt.ReactCurrentDispatcher,t$=Lt.ReactCurrentOwner,v1=Lt.ReactCurrentBatchConfig,jv=0,P1=null,O1=null,T1=0,T_=0,Ew=pv(0),A1=0,Tw=null,Aw=0,x2=0,n$=0,Cw=null,r_=null,r$=0,t2=1/0;function ew(){t2=Oy()+500}var n2=!1,w2=null,q_=null,$2=!1,yx=null,r2=0,i2=0,S2=null,E2=-1,Mw=0;function i_(){return jv&6?Oy():E2!==-1?E2:E2=Oy()}function ox(_n){return _n.mode&1?jv&2&&T1!==0?T1&-T1:Bw.transition!==null?(Mw===0&&(_n=J1,J1<<=1,!(J1&4194240)&&(J1=64),Mw=_n),Mw):(_n=Ro,_n!==0?_n:uy()):1}function D_(_n,xn,nr){if(50<i2)throw i2=0,S2=null,Error(Tt(185));var Lr=Iw(_n,xn);return Lr===null?null:(No(Lr,xn,nr),(!(jv&2)||Lr!==P1)&&(Lr===P1&&(!(jv&2)&&(x2|=xn),A1===4&&Dx(Lr,T1)),Sv(Lr,nr),xn===1&&jv===0&&!(_n.mode&1)&&(ew(),Gx&&y_())),Lr)}function Iw(_n,xn){_n.lanes|=xn;var nr=_n.alternate;for(nr!==null&&(nr.lanes|=xn),nr=_n,_n=_n.return;_n!==null;)_n.childLanes|=xn,nr=_n.alternate,nr!==null&&(nr.childLanes|=xn),nr=_n,_n=_n.return;return nr.tag===3?nr.stateNode:null}function Sv(_n,xn){var nr=_n.callbackNode;j1(_n,xn);var Lr=m_(_n,_n===P1?T1:0);if(Lr===0)nr!==null&&L0(nr),_n.callbackNode=null,_n.callbackPriority=0;else if(xn=Lr&-Lr,_n.callbackPriority!==xn){if(nr!=null&&L0(nr),xn===1)_n.tag===0?Dw(tS.bind(null,_n)):Ow(tS.bind(null,_n)),Fy?qy(function(){jv===0&&y_()}):d0(Uy,y_),nr=null;else{switch(_g(Lr)){case 1:nr=Uy;break;case 4:nr=hv;break;case 16:nr=Hv;break;case 536870912:nr=Q0;break;default:nr=Hv}nr=M2(nr,Q$.bind(null,_n))}_n.callbackPriority=xn,_n.callbackNode=nr}}function Q$(_n,xn){if(E2=-1,Mw=0,jv&6)throw Error(Tt(327));var nr=_n.callbackNode;if(Lx()&&_n.callbackNode!==nr)return null;var Lr=m_(_n,_n===P1?T1:0);if(Lr===0)return null;if(Lr&30||Lr&_n.expiredLanes||xn)xn=o_(_n,Lr);else{xn=Lr;var Xr=jv;jv|=2;var Uo=a$();(P1!==_n||T1!==xn)&&(ew(),ax(_n,xn));do try{s$();break}catch(z0){T2(_n,z0)}while(!0);lw(),Sw.current=Uo,jv=Xr,O1!==null?xn=0:(P1=null,T1=0,xn=A1)}if(xn!==0){if(xn===2&&(Xr=g_(_n),Xr!==0&&(Lr=Xr,xn=i$(_n,Xr))),xn===1)throw nr=Tw,ax(_n,0),Dx(_n,Lr),Sv(_n,Oy()),nr;if(xn===6)Dx(_n,Lr);else{if(Xr=_n.current.alternate,!(Lr&30)&&!eS(Xr)&&(xn=o_(_n,Lr),xn===2&&(Uo=g_(_n),Uo!==0&&(Lr=Uo,xn=i$(_n,Uo))),xn===1))throw nr=Tw,ax(_n,0),Dx(_n,Lr),Sv(_n,Oy()),nr;switch(_n.finishedWork=Xr,_n.finishedLanes=Lr,xn){case 0:case 1:throw Error(Tt(345));case 2:kx(_n,r_);break;case 3:if(Dx(_n,Lr),(Lr&130023424)===Lr&&(xn=r$+500-Oy(),10<xn)){if(m_(_n,0)!==0)break;if(Xr=_n.suspendedLanes,(Xr&Lr)!==Lr){i_(),_n.pingedLanes|=_n.suspendedLanes&Xr;break}_n.timeoutHandle=Ty(kx.bind(null,_n,r_),xn);break}kx(_n,r_);break;case 4:if(Dx(_n,Lr),(Lr&4194240)===Lr)break;for(xn=_n.eventTimes,Xr=-1;0<Lr;){var S0=31-n1(Lr);Uo=1<<S0,S0=xn[S0],S0>Xr&&(Xr=S0),Lr&=~Uo}if(Lr=Xr,Lr=Oy()-Lr,Lr=(120>Lr?120:480>Lr?480:1080>Lr?1080:1920>Lr?1920:3e3>Lr?3e3:4320>Lr?4320:1960*TS(Lr/1960))-Lr,10<Lr){_n.timeoutHandle=Ty(kx.bind(null,_n,r_),Lr);break}kx(_n,r_);break;case 5:kx(_n,r_);break;default:throw Error(Tt(329))}}}return Sv(_n,Oy()),_n.callbackNode===nr?Q$.bind(null,_n):null}function i$(_n,xn){var nr=Cw;return _n.current.memoizedState.isDehydrated&&(ax(_n,xn).flags|=256),_n=o_(_n,xn),_n!==2&&(xn=r_,r_=nr,xn!==null&&tw(xn)),_n}function tw(_n){r_===null?r_=_n:r_.push.apply(r_,_n)}function eS(_n){for(var xn=_n;;){if(xn.flags&16384){var nr=xn.updateQueue;if(nr!==null&&(nr=nr.stores,nr!==null))for(var Lr=0;Lr<nr.length;Lr++){var Xr=nr[Lr],Uo=Xr.getSnapshot;Xr=Xr.value;try{if(!M1(Uo(),Xr))return!1}catch{return!1}}}if(nr=xn.child,xn.subtreeFlags&16384&&nr!==null)nr.return=xn,xn=nr;else{if(xn===_n)break;for(;xn.sibling===null;){if(xn.return===null||xn.return===_n)return!0;xn=xn.return}xn.sibling.return=xn.return,xn=xn.sibling}}return!0}function Dx(_n,xn){for(xn&=~n$,xn&=~x2,_n.suspendedLanes|=xn,_n.pingedLanes&=~xn,_n=_n.expirationTimes;0<xn;){var nr=31-n1(xn),Lr=1<<nr;_n[nr]=-1,xn&=~Lr}}function tS(_n){if(jv&6)throw Error(Tt(327));Lx();var xn=m_(_n,0);if(!(xn&1))return Sv(_n,Oy()),null;var nr=o_(_n,xn);if(_n.tag!==0&&nr===2){var Lr=g_(_n);Lr!==0&&(xn=Lr,nr=i$(_n,Lr))}if(nr===1)throw nr=Tw,ax(_n,0),Dx(_n,xn),Sv(_n,Oy()),nr;if(nr===6)throw Error(Tt(345));return _n.finishedWork=_n.current.alternate,_n.finishedLanes=xn,kx(_n,r_),Sv(_n,Oy()),null}function A_(_n){yx!==null&&yx.tag===0&&!(jv&6)&&Lx();var xn=jv;jv|=1;var nr=v1.transition,Lr=Ro;try{if(v1.transition=null,Ro=1,_n)return _n()}finally{Ro=Lr,v1.transition=nr,jv=xn,!(jv&6)&&y_()}}function o$(){T_=Ew.current,Zy(Ew)}function ax(_n,xn){_n.finishedWork=null,_n.finishedLanes=0;var nr=_n.timeoutHandle;if(nr!==My&&(_n.timeoutHandle=My,$y(nr)),O1!==null)for(nr=O1.return;nr!==null;){var Lr=nr;switch(zo(Lr),Lr.tag){case 1:Lr=Lr.type.childContextTypes,Lr!=null&&Gv();break;case 3:mw(),Zy(xv),Zy(fv),lv();break;case 5:ex(Lr);break;case 4:mw();break;case 13:Zy(F0);break;case 19:Zy(F0);break;case 10:Wx(Lr.type._context);break;case 22:case 23:o$()}nr=nr.return}if(P1=_n,O1=_n=vx(_n.current,null),T1=T_=xn,A1=0,Tw=null,n$=x2=Aw=0,r_=Cw=null,x_!==null){for(xn=0;xn<x_.length;xn++)if(nr=x_[xn],Lr=nr.interleaved,Lr!==null){nr.interleaved=null;var Xr=Lr.next,Uo=nr.pending;if(Uo!==null){var S0=Uo.next;Uo.next=Xr,Lr.next=S0}nr.pending=Lr}x_=null}return _n}function T2(_n,xn){do{var nr=O1;try{if(lw(),Nv.current=_w,h_){for(var Lr=Dv.memoizedState;Lr!==null;){var Xr=Lr.queue;Xr!==null&&(Xr.pending=null),Lr=Lr.next}h_=!1}if(b1=0,H1=V1=Dv=null,Cx=!1,Uw=0,t$.current=null,nr===null||nr.return===null){A1=1,Tw=xn,O1=null;break}e:{var Uo=_n,S0=nr.return,z0=nr,gy=xn;if(xn=T1,z0.flags|=32768,gy!==null&&typeof gy=="object"&&typeof gy.then=="function"){var Gy=gy,cv=z0,Uv=cv.tag;if(!(cv.mode&1)&&(Uv===0||Uv===11||Uv===15)){var $v=cv.alternate;$v?(cv.updateQueue=$v.updateQueue,cv.memoizedState=$v.memoizedState,cv.lanes=$v.lanes):(cv.updateQueue=null,cv.memoizedState=null)}var p1=D$(S0);if(p1!==null){p1.flags&=-257,B$(p1,S0,z0,Uo,xn),p1.mode&1&&O$(Uo,Gy,xn),xn=p1,gy=Gy;var mv=xn.updateQueue;if(mv===null){var l_=new Set;l_.add(gy),xn.updateQueue=l_}else mv.add(gy);break e}else{if(!(xn&1)){O$(Uo,Gy,xn),A2();break e}gy=Error(Tt(426))}}else if(O0&&z0.mode&1){var C_=D$(S0);if(C_!==null){!(C_.flags&65536)&&(C_.flags|=256),B$(C_,S0,z0,Uo,xn),Qv(gy);break e}}Uo=gy,A1!==4&&(A1=2),Cw===null?Cw=[Uo]:Cw.push(Uo),gy=Kx(gy,z0),z0=S0;do{switch(z0.tag){case 3:z0.flags|=65536,xn&=-xn,z0.lanes|=xn;var Z0=Xx(z0,gy,xn);f1(z0,Z0);break e;case 1:Uo=gy;var H0=z0.type,ly=z0.stateNode;if(!(z0.flags&128)&&(typeof H0.getDerivedStateFromError=="function"||ly!==null&&typeof ly.componentDidCatch=="function"&&(q_===null||!q_.has(ly)))){z0.flags|=65536,xn&=-xn,z0.lanes|=xn;var iv=P$(z0,Uo,xn);f1(z0,iv);break e}}z0=z0.return}while(z0!==null)}o2(nr)}catch(gv){xn=gv,O1===nr&&nr!==null&&(O1=nr=nr.return);continue}break}while(!0)}function a$(){var _n=Sw.current;return Sw.current=_w,_n===null?_w:_n}function A2(){(A1===0||A1===3||A1===2)&&(A1=4),P1===null||!(Aw&268435455)&&!(x2&268435455)||Dx(P1,T1)}function o_(_n,xn){var nr=jv;jv|=2;var Lr=a$();P1===_n&&T1===xn||ax(_n,xn);do try{Bx();break}catch(Xr){T2(_n,Xr)}while(!0);if(lw(),jv=nr,Sw.current=Lr,O1!==null)throw Error(Tt(261));return P1=null,T1=0,A1}function Bx(){for(;O1!==null;)l$(O1)}function s$(){for(;O1!==null&&!by();)l$(O1)}function l$(_n){var xn=c$(_n.alternate,_n,T_);_n.memoizedProps=_n.pendingProps,xn===null?o2(_n):O1=xn,t$.current=null}function o2(_n){var xn=_n;do{var nr=xn.alternate;if(_n=xn.return,xn.flags&32768){if(nr=$S(nr,xn),nr!==null){nr.flags&=32767,O1=nr;return}if(_n!==null)_n.flags|=32768,_n.subtreeFlags=0,_n.deletions=null;else{A1=6,O1=null;return}}else if(nr=bS(nr,xn,T_),nr!==null){O1=nr;return}if(xn=xn.sibling,xn!==null){O1=xn;return}O1=xn=_n}while(xn!==null);A1===0&&(A1=5)}function kx(_n,xn){var nr=Ro,Lr=v1.transition;try{v1.transition=null,Ro=1,u$(_n,xn,nr)}finally{v1.transition=Lr,Ro=nr}return null}function u$(_n,xn,nr){do Lx();while(yx!==null);if(jv&6)throw Error(Tt(327));var Lr=_n.finishedWork,Xr=_n.finishedLanes;if(Lr===null)return null;if(_n.finishedWork=null,_n.finishedLanes=0,Lr===_n.current)throw Error(Tt(177));_n.callbackNode=null,_n.callbackPriority=0;var Uo=Lr.lanes|Lr.childLanes;if(ir(_n,Uo),_n===P1&&(O1=P1=null,T1=0),!(Lr.subtreeFlags&2064)&&!(Lr.flags&2064)||$2||($2=!0,M2(Hv,function(){return Lx(),null})),Uo=(Lr.flags&15990)!==0,Lr.subtreeFlags&15990||Uo){Uo=v1.transition,v1.transition=null;var S0=Ro;Ro=1;var z0=jv;jv|=4,t$.current=null,K2(_n,Lr),X$(_n,Lr),h0(_n.containerInfo),_n.current=Lr,ES(Lr),ky(),jv=z0,Ro=S0,v1.transition=Uo}else _n.current=Lr;if($2&&($2=!1,yx=_n,r2=Xr),Uo=_n.pendingLanes,Uo===0&&(q_=null),av(Lr.stateNode),Sv(_n,Oy()),xn!==null)for(nr=_n.onRecoverableError,Lr=0;Lr<xn.length;Lr++)nr(xn[Lr]);if(n2)throw n2=!1,_n=w2,w2=null,_n;return r2&1&&_n.tag!==0&&Lx(),Uo=_n.pendingLanes,Uo&1?_n===S2?i2++:(i2=0,S2=_n):i2=0,y_(),null}function Lx(){if(yx!==null){var _n=_g(r2),xn=v1.transition,nr=Ro;try{if(v1.transition=null,Ro=16>_n?16:_n,yx===null)var Lr=!1;else{if(_n=yx,yx=null,r2=0,jv&6)throw Error(Tt(331));var Xr=jv;for(jv|=4,tv=_n.current;tv!==null;){var Uo=tv,S0=Uo.child;if(tv.flags&16){var z0=Uo.deletions;if(z0!==null){for(var gy=0;gy<z0.length;gy++){var Gy=z0[gy];for(tv=Gy;tv!==null;){var cv=tv;switch(cv.tag){case 0:case 11:case 15:H_(8,cv,Uo)}var Uv=cv.child;if(Uv!==null)Uv.return=cv,tv=Uv;else for(;tv!==null;){cv=tv;var $v=cv.sibling,p1=cv.return;if(ix(cv),cv===Gy){tv=null;break}if($v!==null){$v.return=p1,tv=$v;break}tv=p1}}}var mv=Uo.alternate;if(mv!==null){var l_=mv.child;if(l_!==null){mv.child=null;do{var C_=l_.sibling;l_.sibling=null,l_=C_}while(l_!==null)}}tv=Uo}}if(Uo.subtreeFlags&2064&&S0!==null)S0.return=Uo,tv=S0;else e:for(;tv!==null;){if(Uo=tv,Uo.flags&2048)switch(Uo.tag){case 0:case 11:case 15:H_(9,Uo,Uo.return)}var Z0=Uo.sibling;if(Z0!==null){Z0.return=Uo.return,tv=Z0;break e}tv=Uo.return}}var H0=_n.current;for(tv=H0;tv!==null;){S0=tv;var ly=S0.child;if(S0.subtreeFlags&2064&&ly!==null)ly.return=S0,tv=ly;else e:for(S0=H0;tv!==null;){if(z0=tv,z0.flags&2048)try{switch(z0.tag){case 0:case 11:case 15:Px(9,z0)}}catch(gv){a_(z0,z0.return,gv)}if(z0===S0){tv=null;break e}var iv=z0.sibling;if(iv!==null){iv.return=z0.return,tv=iv;break e}tv=z0.return}}if(jv=Xr,y_(),Yy&&typeof Yy.onPostCommitFiberRoot=="function")try{Yy.onPostCommitFiberRoot(q0,_n)}catch{}Lr=!0}return Lr}finally{Ro=nr,v1.transition=xn}}return!1}function C2(_n,xn,nr){xn=Kx(nr,xn),xn=Xx(_n,xn,1),ov(_n,xn),xn=i_(),_n=Iw(_n,1),_n!==null&&(No(_n,1,xn),Sv(_n,xn))}function a_(_n,xn,nr){if(_n.tag===3)C2(_n,_n,nr);else for(;xn!==null;){if(xn.tag===3){C2(xn,_n,nr);break}else if(xn.tag===1){var Lr=xn.stateNode;if(typeof xn.type.getDerivedStateFromError=="function"||typeof Lr.componentDidCatch=="function"&&(q_===null||!q_.has(Lr))){_n=Kx(nr,_n),_n=P$(xn,_n,1),ov(xn,_n),_n=i_(),xn=Iw(xn,1),xn!==null&&(No(xn,1,_n),Sv(xn,_n));break}}xn=xn.return}}function Nx(_n,xn,nr){var Lr=_n.pingCache;Lr!==null&&Lr.delete(xn),xn=i_(),_n.pingedLanes|=_n.suspendedLanes&nr,P1===_n&&(T1&nr)===nr&&(A1===4||A1===3&&(T1&130023424)===T1&&500>Oy()-r$?ax(_n,0):n$|=nr),Sv(_n,xn)}function nS(_n,xn){xn===0&&(_n.mode&1?(xn=d_,d_<<=1,!(d_&130023424)&&(d_=4194304)):xn=1);var nr=i_();_n=Iw(_n,xn),_n!==null&&(No(_n,xn,nr),Sv(_n,nr))}function Fx(_n){var xn=_n.memoizedState,nr=0;xn!==null&&(nr=xn.retryLane),nS(_n,nr)}function rS(_n,xn){var nr=0;switch(_n.tag){case 13:var Lr=_n.stateNode,Xr=_n.memoizedState;Xr!==null&&(nr=Xr.retryLane);break;case 19:Lr=_n.stateNode;break;default:throw Error(Tt(314))}Lr!==null&&Lr.delete(xn),nS(_n,nr)}var c$;c$=function(_n,xn,nr){if(_n!==null)if(_n.memoizedProps!==xn.pendingProps||xv.current)$_=!0;else{if(!(_n.lanes&nr)&&!(xn.flags&128))return $_=!1,wS(_n,xn,nr);$_=!!(_n.flags&131072)}else $_=!1,O0&&xn.flags&1048576&&Ir(xn,Ax,xn.index);switch(xn.lanes=0,xn.tag){case 2:var Lr=xn.type;_n!==null&&(_n.alternate=null,xn.alternate=null,xn.flags|=2),_n=xn.pendingProps;var Xr=u1(xn,fv.current);dx(xn,nr),Xr=d1(null,xn,Lr,_n,Xr,nr);var Uo=L2();return xn.flags|=1,typeof Xr=="object"&&Xr!==null&&typeof Xr.render=="function"&&Xr.$$typeof===void 0?(xn.tag=1,xn.memoizedState=null,xn.updateQueue=null,c1(Lr)?(Uo=!0,Av(xn)):Uo=!1,xn.memoizedState=Xr.state!==null&&Xr.state!==void 0?Xr.state:null,$x(xn),Xr.updater=Ex,xn.stateNode=Xr,Xr._reactInternals=xn,U_(xn,Lr,_n,nr),xn=H2(null,xn,Lr,!0,Uo,nr)):(xn.tag=0,O0&&Uo&&Yr(xn),E1(null,xn,Xr,nr),xn=xn.child),xn;case 16:Lr=xn.elementType;e:{switch(_n!==null&&(_n.alternate=null,xn.alternate=null,xn.flags|=2),_n=xn.pendingProps,Xr=Lr._init,Lr=Xr(Lr._payload),xn.type=Lr,Xr=xn.tag=iS(Lr),_n=I1(Lr,_n),Xr){case 0:xn=V_(null,xn,Lr,_n,nr);break e;case 1:xn=z$(null,xn,Lr,_n,nr);break e;case 11:xn=k$(null,xn,Lr,_n,nr);break e;case 14:xn=L$(null,xn,Lr,I1(Lr.type,_n),nr);break e}throw Error(Tt(306,Lr,""))}return xn;case 0:return Lr=xn.type,Xr=xn.pendingProps,Xr=xn.elementType===Lr?Xr:I1(Lr,Xr),V_(_n,xn,Lr,Xr,nr);case 1:return Lr=xn.type,Xr=xn.pendingProps,Xr=xn.elementType===Lr?Xr:I1(Lr,Xr),z$(_n,xn,Lr,Xr,nr);case 3:e:{if(G$(xn),_n===null)throw Error(Tt(387));Lr=xn.pendingProps,Uo=xn.memoizedState,Xr=Uo.element,kw(_n,xn),Q1(xn,Lr,null,nr);var S0=xn.memoizedState;if(Lr=S0.element,ay&&Uo.isDehydrated)if(Uo={element:Lr,isDehydrated:!1,cache:S0.cache,transitions:S0.transitions},xn.updateQueue.baseState=Uo,xn.memoizedState=Uo,xn.flags&256){Xr=Error(Tt(423)),xn=V$(_n,xn,Lr,nr,Xr);break e}else if(Lr!==Xr){Xr=Error(Tt(424)),xn=V$(_n,xn,Lr,nr,Xr);break e}else for(ay&&(w0=Y1(xn.stateNode.containerInfo),s0=xn,O0=!0,Iy=null,fy=!1),nr=$$(xn,null,Lr,nr),xn.child=nr;nr;)nr.flags=nr.flags&-3|4096,nr=nr.sibling;else{if(Mv(),Lr===Xr){xn=N1(_n,xn,nr);break e}E1(_n,xn,Lr,nr)}xn=xn.child}return xn;case 5:return S$(xn),_n===null&&a1(xn),Lr=xn.type,Xr=xn.pendingProps,Uo=_n!==null?_n.memoizedProps:null,S0=Xr.children,W0(Lr,Xr)?S0=null:Uo!==null&&W0(Lr,Uo)&&(xn.flags|=32),U$(_n,xn),E1(_n,xn,S0,nr),xn.child;case 6:return _n===null&&a1(xn),null;case 13:return H$(_n,xn,nr);case 4:return k2(xn,xn.stateNode.containerInfo),Lr=xn.pendingProps,_n===null?xn.child=fw(xn,null,Lr,nr):E1(_n,xn,Lr,nr),xn.child;case 11:return Lr=xn.type,Xr=xn.pendingProps,Xr=xn.elementType===Lr?Xr:I1(Lr,Xr),k$(_n,xn,Lr,Xr,nr);case 7:return E1(_n,xn,xn.pendingProps,nr),xn.child;case 8:return E1(_n,xn,xn.pendingProps.children,nr),xn.child;case 12:return E1(_n,xn,xn.pendingProps.children,nr),xn.child;case 10:e:{if(Lr=xn.type._context,Xr=xn.pendingProps,Uo=xn.memoizedProps,S0=Xr.value,uw(xn,Lr,S0),Uo!==null)if(M1(Uo.value,S0)){if(Uo.children===Xr.children&&!xv.current){xn=N1(_n,xn,nr);break e}}else for(Uo=xn.child,Uo!==null&&(Uo.return=xn);Uo!==null;){var z0=Uo.dependencies;if(z0!==null){S0=Uo.child;for(var gy=z0.firstContext;gy!==null;){if(gy.context===Lr){if(Uo.tag===1){gy=G1(-1,nr&-nr),gy.tag=2;var Gy=Uo.updateQueue;if(Gy!==null){Gy=Gy.shared;var cv=Gy.pending;cv===null?gy.next=gy:(gy.next=cv.next,cv.next=gy),Gy.pending=gy}}Uo.lanes|=nr,gy=Uo.alternate,gy!==null&&(gy.lanes|=nr),jx(Uo.return,nr,xn),z0.lanes|=nr;break}gy=gy.next}}else if(Uo.tag===10)S0=Uo.type===xn.type?null:Uo.child;else if(Uo.tag===18){if(S0=Uo.return,S0===null)throw Error(Tt(341));S0.lanes|=nr,z0=S0.alternate,z0!==null&&(z0.lanes|=nr),jx(S0,nr,xn),S0=Uo.sibling}else S0=Uo.child;if(S0!==null)S0.return=Uo;else for(S0=Uo;S0!==null;){if(S0===xn){S0=null;break}if(Uo=S0.sibling,Uo!==null){Uo.return=S0.return,S0=Uo;break}S0=S0.return}Uo=S0}E1(_n,xn,Xr.children,nr),xn=xn.child}return xn;case 9:return Xr=xn.type,Lr=xn.pendingProps.children,dx(xn,nr),Xr=y1(Xr),Lr=Lr(Xr),xn.flags|=1,E1(_n,xn,Lr,nr),xn.child;case 14:return Lr=xn.type,Xr=I1(Lr,xn.pendingProps),Xr=I1(Lr.type,Xr),L$(_n,xn,Lr,Xr,nr);case 15:return N$(_n,xn,xn.type,xn.pendingProps,nr);case 17:return Lr=xn.type,Xr=xn.pendingProps,Xr=xn.elementType===Lr?Xr:I1(Lr,Xr),_n!==null&&(_n.alternate=null,xn.alternate=null,xn.flags|=2),xn.tag=1,c1(Lr)?(_n=!0,Av(xn)):_n=!1,dx(xn,nr),Nw(xn,Lr,Xr),U_(xn,Lr,Xr,nr),H2(null,xn,Lr,!0,_n,nr);case 19:return q$(_n,xn,nr);case 22:return F$(_n,xn,nr)}throw Error(Tt(156,xn.tag))};function M2(_n,xn){return d0(_n,xn)}function AS(_n,xn,nr,Lr){this.tag=_n,this.key=nr,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=xn,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=Lr,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function B_(_n,xn,nr,Lr){return new AS(_n,xn,nr,Lr)}function d$(_n){return _n=_n.prototype,!(!_n||!_n.isReactComponent)}function iS(_n){if(typeof _n=="function")return d$(_n)?1:0;if(_n!=null){if(_n=_n.$$typeof,_n===An)return 11;if(_n===In)return 14}return 2}function vx(_n,xn){var nr=_n.alternate;return nr===null?(nr=B_(_n.tag,xn,_n.key,_n.mode),nr.elementType=_n.elementType,nr.type=_n.type,nr.stateNode=_n.stateNode,nr.alternate=_n,_n.alternate=nr):(nr.pendingProps=xn,nr.type=_n.type,nr.flags=0,nr.subtreeFlags=0,nr.deletions=null),nr.flags=_n.flags&14680064,nr.childLanes=_n.childLanes,nr.lanes=_n.lanes,nr.child=_n.child,nr.memoizedProps=_n.memoizedProps,nr.memoizedState=_n.memoizedState,nr.updateQueue=_n.updateQueue,xn=_n.dependencies,nr.dependencies=xn===null?null:{lanes:xn.lanes,firstContext:xn.firstContext},nr.sibling=_n.sibling,nr.index=_n.index,nr.ref=_n.ref,nr}function I2(_n,xn,nr,Lr,Xr,Uo){var S0=2;if(Lr=_n,typeof _n=="function")d$(_n)&&(S0=1);else if(typeof _n=="string")S0=5;else e:switch(_n){case Ht:return Ux(nr.children,Xr,Uo,xn);case Gt:S0=8,Xr|=8;break;case jt:return _n=B_(12,nr,xn,Xr|2),_n.elementType=jt,_n.lanes=Uo,_n;case Sn:return _n=B_(13,nr,xn,Xr),_n.elementType=Sn,_n.lanes=Uo,_n;case wn:return _n=B_(19,nr,xn,Xr),_n.elementType=wn,_n.lanes=Uo,_n;case rr:return a2(nr,Xr,Uo,xn);default:if(typeof _n=="object"&&_n!==null)switch(_n.$$typeof){case qt:S0=10;break e;case Kt:S0=9;break e;case An:S0=11;break e;case In:S0=14;break e;case tr:S0=16,Lr=null;break e}throw Error(Tt(130,_n==null?_n:typeof _n,""))}return xn=B_(S0,nr,xn,Xr),xn.elementType=_n,xn.type=Lr,xn.lanes=Uo,xn}function Ux(_n,xn,nr,Lr){return _n=B_(7,_n,Lr,xn),_n.lanes=nr,_n}function a2(_n,xn,nr,Lr){return _n=B_(22,_n,Lr,xn),_n.elementType=rr,_n.lanes=nr,_n.stateNode={},_n}function s_(_n,xn,nr){return _n=B_(6,_n,null,xn),_n.lanes=nr,_n}function k_(_n,xn,nr){return xn=B_(4,_n.children!==null?_n.children:[],_n.key,xn),xn.lanes=nr,xn.stateNode={containerInfo:_n.containerInfo,pendingChildren:null,implementation:_n.implementation},xn}function CS(_n,xn,nr,Lr,Xr){this.tag=xn,this.containerInfo=_n,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=My,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=q1(0),this.expirationTimes=q1(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=q1(0),this.identifierPrefix=Lr,this.onRecoverableError=Xr,ay&&(this.mutableSourceEagerHydrationData=null)}function oS(_n,xn,nr,Lr,Xr,Uo,S0,z0,gy){return _n=new CS(_n,xn,nr,z0,gy),xn===1?(xn=1,Uo===!0&&(xn|=8)):xn=0,Uo=B_(3,null,null,xn),_n.current=Uo,Uo.stateNode=_n,Uo.memoizedState={element:Lr,isDehydrated:nr,cache:null,transitions:null},$x(Uo),_n}function s2(_n){if(!_n)return bv;_n=_n._reactInternals;e:{if(Xo(_n)!==_n||_n.tag!==1)throw Error(Tt(170));var xn=_n;do{switch(xn.tag){case 3:xn=xn.stateNode.context;break e;case 1:if(c1(xn.type)){xn=xn.stateNode.__reactInternalMemoizedMergedChildContext;break e}}xn=xn.return}while(xn!==null);throw Error(Tt(171))}if(_n.tag===1){var nr=_n.type;if(c1(nr))return jy(_n,nr,xn)}return xn}function nw(_n){var xn=_n._reactInternals;if(xn===void 0)throw typeof _n.render=="function"?Error(Tt(188)):(_n=Object.keys(_n).join(","),Error(Tt(268,_n)));return _n=f0(xn),_n===null?null:_n.stateNode}function f$(_n,xn){if(_n=_n.memoizedState,_n!==null&&_n.dehydrated!==null){var nr=_n.retryLane;_n.retryLane=nr!==0&&nr<xn?nr:xn}}function R2(_n,xn){f$(_n,xn),(_n=_n.alternate)&&f$(_n,xn)}function MS(_n){return _n=f0(_n),_n===null?null:_n.stateNode}function aS(){return null}return pt.attemptContinuousHydration=function(_n){if(_n.tag===13){var xn=i_();D_(_n,134217728,xn),R2(_n,134217728)}},pt.attemptHydrationAtCurrentPriority=function(_n){if(_n.tag===13){var xn=i_(),nr=ox(_n);D_(_n,nr,xn),R2(_n,nr)}},pt.attemptSynchronousHydration=function(_n){switch(_n.tag){case 3:var xn=_n.stateNode;if(xn.current.memoizedState.isDehydrated){var nr=x1(xn.pendingLanes);nr!==0&&(jr(xn,nr|1),Sv(xn,Oy()),!(jv&6)&&(ew(),y_()))}break;case 13:var Lr=i_();A_(function(){return D_(_n,1,Lr)}),R2(_n,1)}},pt.batchedUpdates=function(_n,xn){var nr=jv;jv|=1;try{return _n(xn)}finally{jv=nr,jv===0&&(ew(),Gx&&y_())}},pt.createComponentSelector=function(_n){return{$$typeof:ww,value:_n}},pt.createContainer=function(_n,xn,nr,Lr,Xr,Uo,S0){return oS(_n,xn,!1,null,nr,Lr,Xr,Uo,S0)},pt.createHasPseudoClassSelector=function(_n){return{$$typeof:Qw,value:_n}},pt.createHydrationContainer=function(_n,xn,nr,Lr,Xr,Uo,S0,z0,gy){return _n=oS(nr,Lr,!0,_n,Xr,Uo,S0,z0,gy),_n.context=s2(null),nr=_n.current,Lr=i_(),Xr=ox(nr),Uo=G1(Lr,Xr),Uo.callback=xn??null,ov(nr,Uo),_n.current.lanes=Xr,No(_n,Xr,Lr),Sv(_n,Lr),_n},pt.createPortal=function(_n,xn,nr){var Lr=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:Ct,key:Lr==null?null:""+Lr,children:_n,containerInfo:xn,implementation:nr}},pt.createRoleSelector=function(_n){return{$$typeof:E_,value:_n}},pt.createTestNameSelector=function(_n){return{$$typeof:$w,value:_n}},pt.createTextSelector=function(_n){return{$$typeof:Qx,value:_n}},pt.deferredUpdates=function(_n){var xn=Ro,nr=v1.transition;try{return v1.transition=null,Ro=16,_n()}finally{Ro=xn,v1.transition=nr}},pt.discreteUpdates=function(_n,xn,nr,Lr,Xr){var Uo=Ro,S0=v1.transition;try{return v1.transition=null,Ro=1,_n(xn,nr,Lr,Xr)}finally{Ro=Uo,v1.transition=S0,jv===0&&ew()}},pt.findAllNodes=e$,pt.findBoundingRects=function(_n,xn){if(!rv)throw Error(Tt(363));xn=e$(_n,xn),_n=[];for(var nr=0;nr<xn.length;nr++)_n.push(r0(xn[nr]));for(xn=_n.length-1;0<xn;xn--){nr=_n[xn];for(var Lr=nr.x,Xr=Lr+nr.width,Uo=nr.y,S0=Uo+nr.height,z0=xn-1;0<=z0;z0--)if(xn!==z0){var gy=_n[z0],Gy=gy.x,cv=Gy+gy.width,Uv=gy.y,$v=Uv+gy.height;if(Lr>=Gy&&Uo>=Uv&&Xr<=cv&&S0<=$v){_n.splice(xn,1);break}else if(Lr!==Gy||nr.width!==gy.width||$v<Uo||Uv>S0){if(!(Uo!==Uv||nr.height!==gy.height||cv<Lr||Gy>Xr)){Gy>Lr&&(gy.width+=Gy-Lr,gy.x=Lr),cv<Xr&&(gy.width=Xr-Gy),_n.splice(xn,1);break}}else{Uv>Uo&&(gy.height+=Uv-Uo,gy.y=Uo),$v<S0&&(gy.height=S0-Uv),_n.splice(xn,1);break}}}return _n},pt.findHostInstance=nw,pt.findHostInstanceWithNoPortals=function(_n){return _n=ko(_n),_n=_n!==null?l0(_n):null,_n===null?null:_n.stateNode},pt.findHostInstanceWithWarning=function(_n){return nw(_n)},pt.flushControlled=function(_n){var xn=jv;jv|=1;var nr=v1.transition,Lr=Ro;try{v1.transition=null,Ro=1,_n()}finally{Ro=Lr,v1.transition=nr,jv=xn,jv===0&&(ew(),y_())}},pt.flushPassiveEffects=Lx,pt.flushSync=A_,pt.focusWithin=function(_n,xn){if(!rv)throw Error(Tt(363));for(_n=b2(_n),xn=J$(_n,xn),xn=Array.from(xn),_n=0;_n<xn.length;){var nr=xn[_n++];if(!G0(nr)){if(nr.tag===5&&dy(nr.stateNode))return!0;for(nr=nr.child;nr!==null;)xn.push(nr),nr=nr.sibling}}return!1},pt.getCurrentUpdatePriority=function(){return Ro},pt.getFindAllNodesFailureDescription=function(_n,xn){if(!rv)throw Error(Tt(363));var nr=0,Lr=[];_n=[b2(_n),0];for(var Xr=0;Xr<_n.length;){var Uo=_n[Xr++],S0=_n[Xr++],z0=xn[S0];if((Uo.tag!==5||!G0(Uo))&&(X1(Uo,z0)&&(Lr.push(e2(z0)),S0++,S0>nr&&(nr=S0)),S0<xn.length))for(Uo=Uo.child;Uo!==null;)_n.push(Uo,S0),Uo=Uo.sibling}if(nr<xn.length){for(_n=[];nr<xn.length;nr++)_n.push(e2(xn[nr]));return`findAllNodes was able to match part of the selector:
  `+(Lr.join(" > ")+`

No matching component was found for:
  `)+_n.join(" > ")}return null},pt.getPublicRootInstance=function(_n){if(_n=_n.current,!_n.child)return null;switch(_n.child.tag){case 5:return t0(_n.child.stateNode);default:return _n.child.stateNode}},pt.injectIntoDevTools=function(_n){if(_n={bundleType:_n.bundleType,version:_n.version,rendererPackageName:_n.rendererPackageName,rendererConfig:_n.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Lt.ReactCurrentDispatcher,findHostInstanceByFiber:MS,findFiberByHostInstance:_n.findFiberByHostInstance||aS,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.0.0-fc46dba67-20220329"},typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")_n=!1;else{var xn=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(xn.isDisabled||!xn.supportsFiber)_n=!0;else{try{q0=xn.inject(_n),Yy=xn}catch{}_n=!!xn.checkDCE}}return _n},pt.isAlreadyRendering=function(){return!1},pt.observeVisibleRects=function(_n,xn,nr,Lr){if(!rv)throw Error(Tt(363));_n=e$(_n,xn);var Xr=Vy(_n,nr,Lr).disconnect;return{disconnect:function(){Xr()}}},pt.registerMutableSourceForHydration=function(_n,xn){var nr=xn._getVersion;nr=nr(xn._source),_n.mutableSourceEagerHydrationData==null?_n.mutableSourceEagerHydrationData=[xn,nr]:_n.mutableSourceEagerHydrationData.push(xn,nr)},pt.runWithPriority=function(_n,xn){var nr=Ro;try{return Ro=_n,xn()}finally{Ro=nr}},pt.shouldError=function(){return null},pt.shouldSuspend=function(){return!1},pt.updateContainer=function(_n,xn,nr,Lr){var Xr=xn.current,Uo=i_(),S0=ox(Xr);return nr=s2(nr),xn.context===null?xn.context=nr:xn.pendingContext=nr,xn=G1(Uo,S0),xn.payload={element:_n},Lr=Lr===void 0?null:Lr,Lr!==null&&(xn.callback=Lr),ov(Xr,xn),_n=D_(Xr,S0,Uo),_n!==null&&fx(_n,Xr,S0),S0},pt};reactReconciler.exports=reactReconciler_production_min;var reactReconcilerExports=reactReconciler.exports;const Reconciler=getDefaultExportFromCjs(reactReconcilerExports),isPromise=st=>typeof st=="object"&&typeof st.then=="function",globalCache=[];function shallowEqualArrays(st,at,pt=(vt,wt)=>vt===wt){if(st===at)return!0;if(!st||!at)return!1;const vt=st.length;if(at.length!==vt)return!1;for(let wt=0;wt<vt;wt++)if(!pt(st[wt],at[wt]))return!1;return!0}function query(st,at=null,pt=!1,vt={}){at===null&&(at=[st]);for(const $t of globalCache)if(shallowEqualArrays(at,$t.keys,$t.equal)){if(pt)return;if(Object.prototype.hasOwnProperty.call($t,"error"))throw $t.error;if(Object.prototype.hasOwnProperty.call($t,"response"))return vt.lifespan&&vt.lifespan>0&&($t.timeout&&clearTimeout($t.timeout),$t.timeout=setTimeout($t.remove,vt.lifespan)),$t.response;if(!pt)throw $t.promise}const wt={keys:at,equal:vt.equal,remove:()=>{const $t=globalCache.indexOf(wt);$t!==-1&&globalCache.splice($t,1)},promise:(isPromise(st)?st:st(...at)).then($t=>{wt.response=$t,vt.lifespan&&vt.lifespan>0&&(wt.timeout=setTimeout(wt.remove,vt.lifespan))}).catch($t=>wt.error=$t)};if(globalCache.push(wt),!pt)throw wt.promise}const suspend=(st,at,pt)=>query(st,at,!1,pt),preload=(st,at,pt)=>void query(st,at,!0,pt),clear=st=>{if(st===void 0||st.length===0)globalCache.splice(0,globalCache.length);else{const at=globalCache.find(pt=>shallowEqualArrays(st,pt.keys,pt.equal));at&&at.remove()}},catalogue={},extend$2=st=>void Object.assign(catalogue,st);function createRenderer(st,at){function pt(Ht,{args:Gt=[],attach:jt,...qt},Kt){let An=`${Ht[0].toUpperCase()}${Ht.slice(1)}`,Sn;if(Ht==="primitive"){if(qt.object===void 0)throw new Error("R3F: Primitives without 'object' are invalid!");const wn=qt.object;Sn=prepare(wn,{type:Ht,root:Kt,attach:jt,primitive:!0})}else{const wn=catalogue[An];if(!wn)throw new Error(`R3F: ${An} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(!Array.isArray(Gt))throw new Error("R3F: The args prop must be an array!");Sn=prepare(new wn(...Gt),{type:Ht,root:Kt,attach:jt,memoizedProps:{args:Gt}})}return Sn.__r3f.attach===void 0&&(Sn instanceof BufferGeometry?Sn.__r3f.attach="geometry":Sn instanceof Material&&(Sn.__r3f.attach="material")),An!=="inject"&&applyProps$1(Sn,qt),Sn}function vt(Ht,Gt){let jt=!1;if(Gt){var qt,Kt;(qt=Gt.__r3f)!=null&&qt.attach?attach(Ht,Gt,Gt.__r3f.attach):Gt.isObject3D&&Ht.isObject3D&&(Ht.add(Gt),jt=!0),jt||(Kt=Ht.__r3f)==null||Kt.objects.push(Gt),Gt.__r3f||prepare(Gt,{}),Gt.__r3f.parent=Ht,updateInstance(Gt),invalidateInstance(Gt)}}function wt(Ht,Gt,jt){let qt=!1;if(Gt){var Kt,An;if((Kt=Gt.__r3f)!=null&&Kt.attach)attach(Ht,Gt,Gt.__r3f.attach);else if(Gt.isObject3D&&Ht.isObject3D){Gt.parent=Ht,Gt.dispatchEvent({type:"added"}),Ht.dispatchEvent({type:"childadded",child:Gt});const Sn=Ht.children.filter(In=>In!==Gt),wn=Sn.indexOf(jt);Ht.children=[...Sn.slice(0,wn),Gt,...Sn.slice(wn)],qt=!0}qt||(An=Ht.__r3f)==null||An.objects.push(Gt),Gt.__r3f||prepare(Gt,{}),Gt.__r3f.parent=Ht,updateInstance(Gt),invalidateInstance(Gt)}}function $t(Ht,Gt,jt=!1){Ht&&[...Ht].forEach(qt=>Tt(Gt,qt,jt))}function Tt(Ht,Gt,jt){if(Gt){var qt,Kt,An;if(Gt.__r3f&&(Gt.__r3f.parent=null),(qt=Ht.__r3f)!=null&&qt.objects&&(Ht.__r3f.objects=Ht.__r3f.objects.filter(rr=>rr!==Gt)),(Kt=Gt.__r3f)!=null&&Kt.attach)detach(Ht,Gt,Gt.__r3f.attach);else if(Gt.isObject3D&&Ht.isObject3D){var Sn;Ht.remove(Gt),(Sn=Gt.__r3f)!=null&&Sn.root&&removeInteractivity(findInitialRoot(Gt),Gt)}const In=(An=Gt.__r3f)==null?void 0:An.primitive,tr=!In&&(jt===void 0?Gt.dispose!==null:jt);if(!In){var wn;$t((wn=Gt.__r3f)==null?void 0:wn.objects,Gt,tr),$t(Gt.children,Gt,tr)}if(delete Gt.__r3f,tr&&Gt.dispose&&Gt.type!=="Scene"){const rr=()=>{try{Gt.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT>"u"?schedulerExports.unstable_scheduleCallback(schedulerExports.unstable_IdlePriority,rr):rr()}invalidateInstance(Ht)}}function Lt(Ht,Gt,jt,qt){var Kt;const An=(Kt=Ht.__r3f)==null?void 0:Kt.parent;if(!An)return;const Sn=pt(Gt,jt,Ht.__r3f.root);if(Ht.children){for(const wn of Ht.children)wn.__r3f&&vt(Sn,wn);Ht.children=Ht.children.filter(wn=>!wn.__r3f)}Ht.__r3f.objects.forEach(wn=>vt(Sn,wn)),Ht.__r3f.objects=[],Ht.__r3f.autoRemovedBeforeAppend||Tt(An,Ht),Sn.parent&&(Sn.__r3f.autoRemovedBeforeAppend=!0),vt(An,Sn),Sn.raycast&&Sn.__r3f.eventCount&&findInitialRoot(Sn).getState().internal.interaction.push(Sn),[qt,qt.alternate].forEach(wn=>{wn!==null&&(wn.stateNode=Sn,wn.ref&&(typeof wn.ref=="function"?wn.ref(Sn):wn.ref.current=Sn))})}const Ft=()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");return{reconciler:Reconciler({createInstance:pt,removeChild:Tt,appendChild:vt,appendInitialChild:vt,insertBefore:wt,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:(Ht,Gt)=>{if(!Gt)return;const jt=Ht.getState().scene;jt.__r3f&&(jt.__r3f.root=Ht,vt(jt,Gt))},removeChildFromContainer:(Ht,Gt)=>{Gt&&Tt(Ht.getState().scene,Gt)},insertInContainerBefore:(Ht,Gt,jt)=>{if(!Gt||!jt)return;const qt=Ht.getState().scene;qt.__r3f&&wt(qt,Gt,jt)},getRootHostContext:()=>null,getChildHostContext:Ht=>Ht,finalizeInitialChildren(Ht){var Gt;return!!((Gt=Ht==null?void 0:Ht.__r3f)!=null?Gt:{}).handlers},prepareUpdate(Ht,Gt,jt,qt){var Kt;if(((Kt=Ht==null?void 0:Ht.__r3f)!=null?Kt:{}).primitive&&qt.object&&qt.object!==Ht)return[!0];{const{args:Sn=[],children:wn,...In}=qt,{args:tr=[],children:rr,...Hr}=jt;if(!Array.isArray(Sn))throw new Error("R3F: the args prop must be an array!");if(Sn.some((Zr,Bo)=>Zr!==tr[Bo]))return[!0];const qr=diffProps(Ht,In,Hr,!0);return qr.changes.length?[!1,qr]:null}},commitUpdate(Ht,[Gt,jt],qt,Kt,An,Sn){Gt?Lt(Ht,qt,An,Sn):applyProps$1(Ht,jt)},commitMount(Ht,Gt,jt,qt){var Kt;const An=(Kt=Ht.__r3f)!=null?Kt:{};Ht.raycast&&An.handlers&&An.eventCount&&findInitialRoot(Ht).getState().internal.interaction.push(Ht)},getPublicInstance:Ht=>Ht,prepareForCommit:()=>null,preparePortalMount:Ht=>prepare(Ht.getState().scene),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance(Ht){var Gt;const{attach:jt,parent:qt}=(Gt=Ht.__r3f)!=null?Gt:{};jt&&qt&&detach(qt,Ht,jt),Ht.isObject3D&&(Ht.visible=!1),invalidateInstance(Ht)},unhideInstance(Ht,Gt){var jt;const{attach:qt,parent:Kt}=(jt=Ht.__r3f)!=null?jt:{};qt&&Kt&&attach(Kt,Ht,qt),(Ht.isObject3D&&Gt.visible==null||Gt.visible)&&(Ht.visible=!0),invalidateInstance(Ht)},createTextInstance:Ft,hideTextInstance:Ft,unhideTextInstance:Ft,getCurrentEventPriority:()=>at?at():constantsExports.DefaultEventPriority,beforeActiveInstanceBlur:()=>{},afterActiveInstanceBlur:()=>{},detachDeletedInstance:()=>{},now:typeof performance<"u"&&is$2.fun(performance.now)?performance.now:is$2.fun(Date.now)?Date.now:()=>0,scheduleTimeout:is$2.fun(setTimeout)?setTimeout:void 0,cancelTimeout:is$2.fun(clearTimeout)?clearTimeout:void 0}),applyProps:applyProps$1}}var _window$document,_window$navigator;const hasColorSpace$1=st=>"colorSpace"in st||"outputColorSpace"in st,getColorManagement=()=>{var st;return(st=catalogue.ColorManagement)!=null?st:null},isOrthographicCamera=st=>st&&st.isOrthographicCamera,isRef$1=st=>st&&st.hasOwnProperty("current"),useIsomorphicLayoutEffect=typeof window<"u"&&((_window$document=window.document)!=null&&_window$document.createElement||((_window$navigator=window.navigator)==null?void 0:_window$navigator.product)==="ReactNative")?reactExports.useLayoutEffect:reactExports.useEffect;function useMutableCallback(st){const at=reactExports.useRef(st);return useIsomorphicLayoutEffect(()=>void(at.current=st),[st]),at}function Block({set:st}){return useIsomorphicLayoutEffect(()=>(st(new Promise(()=>null)),()=>st(!1)),[st]),null}class ErrorBoundary extends reactExports.Component{constructor(...at){super(...at),this.state={error:!1}}componentDidCatch(at){this.props.set(at)}render(){return this.state.error?null:this.props.children}}ErrorBoundary.getDerivedStateFromError=()=>({error:!0});const DEFAULT="__default",DEFAULTS=new Map,isDiffSet=st=>st&&!!st.memoized&&!!st.changes;function calculateDpr(st){var at;const pt=typeof window<"u"?(at=window.devicePixelRatio)!=null?at:2:1;return Array.isArray(st)?Math.min(Math.max(st[0],pt),st[1]):st}const getRootState=st=>{var at;return(at=st.__r3f)==null?void 0:at.root.getState()};function findInitialRoot(st){let at=st.__r3f.root;for(;at.getState().previousRoot;)at=at.getState().previousRoot;return at}const is$2={obj:st=>st===Object(st)&&!is$2.arr(st)&&typeof st!="function",fun:st=>typeof st=="function",str:st=>typeof st=="string",num:st=>typeof st=="number",boo:st=>typeof st=="boolean",und:st=>st===void 0,arr:st=>Array.isArray(st),equ(st,at,{arrays:pt="shallow",objects:vt="reference",strict:wt=!0}={}){if(typeof st!=typeof at||!!st!=!!at)return!1;if(is$2.str(st)||is$2.num(st))return st===at;const $t=is$2.obj(st);if($t&&vt==="reference")return st===at;const Tt=is$2.arr(st);if(Tt&&pt==="reference")return st===at;if((Tt||$t)&&st===at)return!0;let Lt;for(Lt in st)if(!(Lt in at))return!1;if($t&&pt==="shallow"&&vt==="shallow"){for(Lt in wt?at:st)if(!is$2.equ(st[Lt],at[Lt],{strict:wt,objects:"reference"}))return!1}else for(Lt in wt?at:st)if(st[Lt]!==at[Lt])return!1;if(is$2.und(Lt)){if(Tt&&st.length===0&&at.length===0||$t&&Object.keys(st).length===0&&Object.keys(at).length===0)return!0;if(st!==at)return!1}return!0}};function buildGraph(st){const at={nodes:{},materials:{}};return st&&st.traverse(pt=>{pt.name&&(at.nodes[pt.name]=pt),pt.material&&!at.materials[pt.material.name]&&(at.materials[pt.material.name]=pt.material)}),at}function dispose(st){st.dispose&&st.type!=="Scene"&&st.dispose();for(const at in st)at.dispose==null||at.dispose(),delete st[at]}function prepare(st,at){const pt=st;return pt.__r3f={type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null,...at},st}function resolve(st,at){let pt=st;if(at.includes("-")){const vt=at.split("-"),wt=vt.pop();return pt=vt.reduce(($t,Tt)=>$t[Tt],st),{target:pt,key:wt}}else return{target:pt,key:at}}const INDEX_REGEX=/-\d+$/;function attach(st,at,pt){if(is$2.str(pt)){if(INDEX_REGEX.test(pt)){const $t=pt.replace(INDEX_REGEX,""),{target:Tt,key:Lt}=resolve(st,$t);Array.isArray(Tt[Lt])||(Tt[Lt]=[])}const{target:vt,key:wt}=resolve(st,pt);at.__r3f.previousAttach=vt[wt],vt[wt]=at}else at.__r3f.previousAttach=pt(st,at)}function detach(st,at,pt){var vt,wt;if(is$2.str(pt)){const{target:$t,key:Tt}=resolve(st,pt),Lt=at.__r3f.previousAttach;Lt===void 0?delete $t[Tt]:$t[Tt]=Lt}else(vt=at.__r3f)==null||vt.previousAttach==null||vt.previousAttach(st,at);(wt=at.__r3f)==null||delete wt.previousAttach}function diffProps(st,{children:at,key:pt,ref:vt,...wt},{children:$t,key:Tt,ref:Lt,...Ft}={},Ct=!1){const Ht=st.__r3f,Gt=Object.entries(wt),jt=[];if(Ct){const Kt=Object.keys(Ft);for(let An=0;An<Kt.length;An++)wt.hasOwnProperty(Kt[An])||Gt.unshift([Kt[An],DEFAULT+"remove"])}Gt.forEach(([Kt,An])=>{var Sn;if((Sn=st.__r3f)!=null&&Sn.primitive&&Kt==="object"||is$2.equ(An,Ft[Kt]))return;if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(Kt))return jt.push([Kt,An,!0,[]]);let wn=[];Kt.includes("-")&&(wn=Kt.split("-")),jt.push([Kt,An,!1,wn]);for(const In in wt){const tr=wt[In];In.startsWith(`${Kt}-`)&&jt.push([In,tr,!1,In.split("-")])}});const qt={...wt};return Ht!=null&&Ht.memoizedProps&&Ht!=null&&Ht.memoizedProps.args&&(qt.args=Ht.memoizedProps.args),Ht!=null&&Ht.memoizedProps&&Ht!=null&&Ht.memoizedProps.attach&&(qt.attach=Ht.memoizedProps.attach),{memoized:qt,changes:jt}}const __DEV__=typeof process<"u"&&!1;function applyProps$1(st,at){var pt;const vt=st.__r3f,wt=vt==null?void 0:vt.root,$t=wt==null||wt.getState==null?void 0:wt.getState(),{memoized:Tt,changes:Lt}=isDiffSet(at)?at:diffProps(st,at),Ft=vt==null?void 0:vt.eventCount;st.__r3f&&(st.__r3f.memoizedProps=Tt);for(let Ht=0;Ht<Lt.length;Ht++){let[Gt,jt,qt,Kt]=Lt[Ht];if(hasColorSpace$1(st)){const In="srgb",tr="srgb-linear";Gt==="encoding"?(Gt="colorSpace",jt=jt===3001?In:tr):Gt==="outputEncoding"&&(Gt="outputColorSpace",jt=jt===3001?In:tr)}let An=st,Sn=An[Gt];if(Kt.length&&(Sn=Kt.reduce((wn,In)=>wn[In],st),!(Sn&&Sn.set))){const[wn,...In]=Kt.reverse();An=In.reverse().reduce((tr,rr)=>tr[rr],st),Gt=wn}if(jt===DEFAULT+"remove")if(An.constructor){let wn=DEFAULTS.get(An.constructor);wn||(wn=new An.constructor,DEFAULTS.set(An.constructor,wn)),jt=wn[Gt]}else jt=0;if(qt&&vt)jt?vt.handlers[Gt]=jt:delete vt.handlers[Gt],vt.eventCount=Object.keys(vt.handlers).length;else if(Sn&&Sn.set&&(Sn.copy||Sn instanceof Layers)){if(Array.isArray(jt))Sn.fromArray?Sn.fromArray(jt):Sn.set(...jt);else if(Sn.copy&&jt&&jt.constructor&&(__DEV__?Sn.constructor.name===jt.constructor.name:Sn.constructor===jt.constructor))Sn.copy(jt);else if(jt!==void 0){const wn=Sn instanceof Color$1;!wn&&Sn.setScalar?Sn.setScalar(jt):Sn instanceof Layers&&jt instanceof Layers?Sn.mask=jt.mask:Sn.set(jt),!getColorManagement()&&$t&&!$t.linear&&wn&&Sn.convertSRGBToLinear()}}else if(An[Gt]=jt,An[Gt]instanceof Texture&&An[Gt].format===RGBAFormat&&An[Gt].type===UnsignedByteType&&$t){const wn=An[Gt];hasColorSpace$1(wn)&&hasColorSpace$1($t.gl)?wn.colorSpace=$t.gl.outputColorSpace:wn.encoding=$t.gl.outputEncoding}invalidateInstance(st)}if(vt&&vt.parent&&st.raycast&&Ft!==vt.eventCount){const Ht=findInitialRoot(st).getState().internal,Gt=Ht.interaction.indexOf(st);Gt>-1&&Ht.interaction.splice(Gt,1),vt.eventCount&&Ht.interaction.push(st)}return!(Lt.length===1&&Lt[0][0]==="onUpdate")&&Lt.length&&(pt=st.__r3f)!=null&&pt.parent&&updateInstance(st),st}function invalidateInstance(st){var at,pt;const vt=(at=st.__r3f)==null||(pt=at.root)==null||pt.getState==null?void 0:pt.getState();vt&&vt.internal.frames===0&&vt.invalidate()}function updateInstance(st){st.onUpdate==null||st.onUpdate(st)}function updateCamera(st,at){st.manual||(isOrthographicCamera(st)?(st.left=at.width/-2,st.right=at.width/2,st.top=at.height/2,st.bottom=at.height/-2):st.aspect=at.width/at.height,st.updateProjectionMatrix(),st.updateMatrixWorld())}function makeId(st){return(st.eventObject||st.object).uuid+"/"+st.index+st.instanceId}function getEventPriority(){var st;const at=typeof self<"u"&&self||typeof window<"u"&&window;if(!at)return constantsExports.DefaultEventPriority;switch((st=at.event)==null?void 0:st.type){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return constantsExports.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return constantsExports.ContinuousEventPriority;default:return constantsExports.DefaultEventPriority}}function releaseInternalPointerCapture(st,at,pt,vt){const wt=pt.get(at);wt&&(pt.delete(at),pt.size===0&&(st.delete(vt),wt.target.releasePointerCapture(vt)))}function removeInteractivity(st,at){const{internal:pt}=st.getState();pt.interaction=pt.interaction.filter(vt=>vt!==at),pt.initialHits=pt.initialHits.filter(vt=>vt!==at),pt.hovered.forEach((vt,wt)=>{(vt.eventObject===at||vt.object===at)&&pt.hovered.delete(wt)}),pt.capturedMap.forEach((vt,wt)=>{releaseInternalPointerCapture(pt.capturedMap,at,vt,wt)})}function createEvents(st){function at(Ft){const{internal:Ct}=st.getState(),Ht=Ft.offsetX-Ct.initialClick[0],Gt=Ft.offsetY-Ct.initialClick[1];return Math.round(Math.sqrt(Ht*Ht+Gt*Gt))}function pt(Ft){return Ft.filter(Ct=>["Move","Over","Enter","Out","Leave"].some(Ht=>{var Gt;return(Gt=Ct.__r3f)==null?void 0:Gt.handlers["onPointer"+Ht]}))}function vt(Ft,Ct){const Ht=st.getState(),Gt=new Set,jt=[],qt=Ct?Ct(Ht.internal.interaction):Ht.internal.interaction;for(let wn=0;wn<qt.length;wn++){const In=getRootState(qt[wn]);In&&(In.raycaster.camera=void 0)}Ht.previousRoot||Ht.events.compute==null||Ht.events.compute(Ft,Ht);function Kt(wn){const In=getRootState(wn);if(!In||!In.events.enabled||In.raycaster.camera===null)return[];if(In.raycaster.camera===void 0){var tr;In.events.compute==null||In.events.compute(Ft,In,(tr=In.previousRoot)==null?void 0:tr.getState()),In.raycaster.camera===void 0&&(In.raycaster.camera=null)}return In.raycaster.camera?In.raycaster.intersectObject(wn,!0):[]}let An=qt.flatMap(Kt).sort((wn,In)=>{const tr=getRootState(wn.object),rr=getRootState(In.object);return!tr||!rr?wn.distance-In.distance:rr.events.priority-tr.events.priority||wn.distance-In.distance}).filter(wn=>{const In=makeId(wn);return Gt.has(In)?!1:(Gt.add(In),!0)});Ht.events.filter&&(An=Ht.events.filter(An,Ht));for(const wn of An){let In=wn.object;for(;In;){var Sn;(Sn=In.__r3f)!=null&&Sn.eventCount&&jt.push({...wn,eventObject:In}),In=In.parent}}if("pointerId"in Ft&&Ht.internal.capturedMap.has(Ft.pointerId))for(let wn of Ht.internal.capturedMap.get(Ft.pointerId).values())Gt.has(makeId(wn.intersection))||jt.push(wn.intersection);return jt}function wt(Ft,Ct,Ht,Gt){const jt=st.getState();if(Ft.length){const qt={stopped:!1};for(const Kt of Ft){const An=getRootState(Kt.object)||jt,{raycaster:Sn,pointer:wn,camera:In,internal:tr}=An,rr=new Vector3(wn.x,wn.y,0).unproject(In),Hr=Kr=>{var ko,f0;return(ko=(f0=tr.capturedMap.get(Kr))==null?void 0:f0.has(Kt.eventObject))!=null?ko:!1},qr=Kr=>{const ko={intersection:Kt,target:Ct.target};tr.capturedMap.has(Kr)?tr.capturedMap.get(Kr).set(Kt.eventObject,ko):tr.capturedMap.set(Kr,new Map([[Kt.eventObject,ko]])),Ct.target.setPointerCapture(Kr)},Zr=Kr=>{const ko=tr.capturedMap.get(Kr);ko&&releaseInternalPointerCapture(tr.capturedMap,Kt.eventObject,ko,Kr)};let Bo={};for(let Kr in Ct){let ko=Ct[Kr];typeof ko!="function"&&(Bo[Kr]=ko)}let Xo={...Kt,...Bo,pointer:wn,intersections:Ft,stopped:qt.stopped,delta:Ht,unprojectedPoint:rr,ray:Sn.ray,camera:In,stopPropagation(){const Kr="pointerId"in Ct&&tr.capturedMap.get(Ct.pointerId);if((!Kr||Kr.has(Kt.eventObject))&&(Xo.stopped=qt.stopped=!0,tr.hovered.size&&Array.from(tr.hovered.values()).find(ko=>ko.eventObject===Kt.eventObject))){const ko=Ft.slice(0,Ft.indexOf(Kt));$t([...ko,Kt])}},target:{hasPointerCapture:Hr,setPointerCapture:qr,releasePointerCapture:Zr},currentTarget:{hasPointerCapture:Hr,setPointerCapture:qr,releasePointerCapture:Zr},nativeEvent:Ct};if(Gt(Xo),qt.stopped===!0)break}}return Ft}function $t(Ft){const{internal:Ct}=st.getState();for(const Ht of Ct.hovered.values())if(!Ft.length||!Ft.find(Gt=>Gt.object===Ht.object&&Gt.index===Ht.index&&Gt.instanceId===Ht.instanceId)){const jt=Ht.eventObject.__r3f,qt=jt==null?void 0:jt.handlers;if(Ct.hovered.delete(makeId(Ht)),jt!=null&&jt.eventCount){const Kt={...Ht,intersections:Ft};qt.onPointerOut==null||qt.onPointerOut(Kt),qt.onPointerLeave==null||qt.onPointerLeave(Kt)}}}function Tt(Ft,Ct){for(let Ht=0;Ht<Ct.length;Ht++){const Gt=Ct[Ht].__r3f;Gt==null||Gt.handlers.onPointerMissed==null||Gt.handlers.onPointerMissed(Ft)}}function Lt(Ft){switch(Ft){case"onPointerLeave":case"onPointerCancel":return()=>$t([]);case"onLostPointerCapture":return Ct=>{const{internal:Ht}=st.getState();"pointerId"in Ct&&Ht.capturedMap.has(Ct.pointerId)&&requestAnimationFrame(()=>{Ht.capturedMap.has(Ct.pointerId)&&(Ht.capturedMap.delete(Ct.pointerId),$t([]))})}}return function(Ht){const{onPointerMissed:Gt,internal:jt}=st.getState();jt.lastEvent.current=Ht;const qt=Ft==="onPointerMove",Kt=Ft==="onClick"||Ft==="onContextMenu"||Ft==="onDoubleClick",Sn=vt(Ht,qt?pt:void 0),wn=Kt?at(Ht):0;Ft==="onPointerDown"&&(jt.initialClick=[Ht.offsetX,Ht.offsetY],jt.initialHits=Sn.map(tr=>tr.eventObject)),Kt&&!Sn.length&&wn<=2&&(Tt(Ht,jt.interaction),Gt&&Gt(Ht)),qt&&$t(Sn);function In(tr){const rr=tr.eventObject,Hr=rr.__r3f,qr=Hr==null?void 0:Hr.handlers;if(Hr!=null&&Hr.eventCount)if(qt){if(qr.onPointerOver||qr.onPointerEnter||qr.onPointerOut||qr.onPointerLeave){const Zr=makeId(tr),Bo=jt.hovered.get(Zr);Bo?Bo.stopped&&tr.stopPropagation():(jt.hovered.set(Zr,tr),qr.onPointerOver==null||qr.onPointerOver(tr),qr.onPointerEnter==null||qr.onPointerEnter(tr))}qr.onPointerMove==null||qr.onPointerMove(tr)}else{const Zr=qr[Ft];Zr?(!Kt||jt.initialHits.includes(rr))&&(Tt(Ht,jt.interaction.filter(Bo=>!jt.initialHits.includes(Bo))),Zr(tr)):Kt&&jt.initialHits.includes(rr)&&Tt(Ht,jt.interaction.filter(Bo=>!jt.initialHits.includes(Bo)))}}wt(Sn,Ht,wn,In)}}return{handlePointer:Lt}}const privateKeys=["set","get","setSize","setFrameloop","setDpr","events","invalidate","advance","size","viewport"],isRenderer=st=>!!(st!=null&&st.render),context=reactExports.createContext(null),createStore=(st,at)=>{const pt=create((Lt,Ft)=>{const Ct=new Vector3,Ht=new Vector3,Gt=new Vector3;function jt(wn=Ft().camera,In=Ht,tr=Ft().size){const{width:rr,height:Hr,top:qr,left:Zr}=tr,Bo=rr/Hr;In instanceof Vector3?Gt.copy(In):Gt.set(...In);const Xo=wn.getWorldPosition(Ct).distanceTo(Gt);if(isOrthographicCamera(wn))return{width:rr/wn.zoom,height:Hr/wn.zoom,top:qr,left:Zr,factor:1,distance:Xo,aspect:Bo};{const Kr=wn.fov*Math.PI/180,ko=2*Math.tan(Kr/2)*Xo,f0=ko*(rr/Hr);return{width:f0,height:ko,top:qr,left:Zr,factor:rr/f0,distance:Xo,aspect:Bo}}}let qt;const Kt=wn=>Lt(In=>({performance:{...In.performance,current:wn}})),An=new Vector2;return{set:Lt,get:Ft,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,scene:null,invalidate:(wn=1)=>st(Ft(),wn),advance:(wn,In)=>at(wn,In,Ft()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new Clock,pointer:An,mouse:An,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const wn=Ft();qt&&clearTimeout(qt),wn.performance.current!==wn.performance.min&&Kt(wn.performance.min),qt=setTimeout(()=>Kt(Ft().performance.max),wn.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:jt},setEvents:wn=>Lt(In=>({...In,events:{...In.events,...wn}})),setSize:(wn,In,tr,rr,Hr)=>{const qr=Ft().camera,Zr={width:wn,height:In,top:rr||0,left:Hr||0,updateStyle:tr};Lt(Bo=>({size:Zr,viewport:{...Bo.viewport,...jt(qr,Ht,Zr)}}))},setDpr:wn=>Lt(In=>{const tr=calculateDpr(wn);return{viewport:{...In.viewport,dpr:tr,initialDpr:In.viewport.initialDpr||tr}}}),setFrameloop:(wn="always")=>{const In=Ft().clock;In.stop(),In.elapsedTime=0,wn!=="never"&&(In.start(),In.elapsedTime=0),Lt(()=>({frameloop:wn}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:reactExports.createRef(),interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:(wn,In,tr)=>{const rr=Ft().internal;return rr.priority=rr.priority+(In>0?1:0),rr.subscribers.push({ref:wn,priority:In,store:tr}),rr.subscribers=rr.subscribers.sort((Hr,qr)=>Hr.priority-qr.priority),()=>{const Hr=Ft().internal;Hr!=null&&Hr.subscribers&&(Hr.priority=Hr.priority-(In>0?1:0),Hr.subscribers=Hr.subscribers.filter(qr=>qr.ref!==wn))}}}}}),vt=pt.getState();let wt=vt.size,$t=vt.viewport.dpr,Tt=vt.camera;return pt.subscribe(()=>{const{camera:Lt,size:Ft,viewport:Ct,gl:Ht,set:Gt}=pt.getState();if(Ft.width!==wt.width||Ft.height!==wt.height||Ct.dpr!==$t){var jt;wt=Ft,$t=Ct.dpr,updateCamera(Lt,Ft),Ht.setPixelRatio(Ct.dpr);const qt=(jt=Ft.updateStyle)!=null?jt:typeof HTMLCanvasElement<"u"&&Ht.domElement instanceof HTMLCanvasElement;Ht.setSize(Ft.width,Ft.height,qt)}Lt!==Tt&&(Tt=Lt,Gt(qt=>({viewport:{...qt.viewport,...qt.viewport.getCurrentViewport(Lt)}})))}),pt.subscribe(Lt=>st(Lt)),pt};let i$4,globalEffects=new Set,globalAfterEffects=new Set,globalTailEffects=new Set;function run(st,at){if(st.size)for(const{callback:pt}of st.values())pt(at)}function flushGlobalEffects(st,at){switch(st){case"before":return run(globalEffects,at);case"after":return run(globalAfterEffects,at);case"tail":return run(globalTailEffects,at)}}let subscribers,subscription;function render$1(st,at,pt){let vt=at.clock.getDelta();for(at.frameloop==="never"&&typeof st=="number"&&(vt=st-at.clock.elapsedTime,at.clock.oldTime=at.clock.elapsedTime,at.clock.elapsedTime=st),subscribers=at.internal.subscribers,i$4=0;i$4<subscribers.length;i$4++)subscription=subscribers[i$4],subscription.ref.current(subscription.store.getState(),vt,pt);return!at.internal.priority&&at.gl.render&&at.gl.render(at.scene,at.camera),at.internal.frames=Math.max(0,at.internal.frames-1),at.frameloop==="always"?1:at.internal.frames}function createLoop(st){let at=!1,pt=!1,vt,wt,$t;function Tt(Ct){wt=requestAnimationFrame(Tt),at=!0,vt=0,flushGlobalEffects("before",Ct),pt=!0;for(const Gt of st.values()){var Ht;$t=Gt.store.getState(),$t.internal.active&&($t.frameloop==="always"||$t.internal.frames>0)&&!((Ht=$t.gl.xr)!=null&&Ht.isPresenting)&&(vt+=render$1(Ct,$t))}if(pt=!1,flushGlobalEffects("after",Ct),vt===0)return flushGlobalEffects("tail",Ct),at=!1,cancelAnimationFrame(wt)}function Lt(Ct,Ht=1){var Gt;if(!Ct)return st.forEach(jt=>Lt(jt.store.getState(),Ht));(Gt=Ct.gl.xr)!=null&&Gt.isPresenting||!Ct.internal.active||Ct.frameloop==="never"||(Ht>1?Ct.internal.frames=Math.min(60,Ct.internal.frames+Ht):pt?Ct.internal.frames=2:Ct.internal.frames=1,at||(at=!0,requestAnimationFrame(Tt)))}function Ft(Ct,Ht=!0,Gt,jt){if(Ht&&flushGlobalEffects("before",Ct),Gt)render$1(Ct,Gt,jt);else for(const qt of st.values())render$1(Ct,qt.store.getState());Ht&&flushGlobalEffects("after",Ct)}return{loop:Tt,invalidate:Lt,advance:Ft}}function useStore(){const st=reactExports.useContext(context);if(!st)throw new Error("R3F: Hooks can only be used within the Canvas component!");return st}function useThree(st=pt=>pt,at){return useStore()(st,at)}function useFrame(st,at=0){const pt=useStore(),vt=pt.getState().internal.subscribe,wt=useMutableCallback(st);return useIsomorphicLayoutEffect(()=>vt(wt,at,pt),[at,vt,pt]),null}const memoizedLoaders=new WeakMap;function loadingFn(st,at){return function(pt,...vt){let wt=memoizedLoaders.get(pt);return wt||(wt=new pt,memoizedLoaders.set(pt,wt)),st&&st(wt),Promise.all(vt.map($t=>new Promise((Tt,Lt)=>wt.load($t,Ft=>{Ft.scene&&Object.assign(Ft,buildGraph(Ft.scene)),Tt(Ft)},at,Ft=>Lt(new Error(`Could not load ${$t}: ${Ft==null?void 0:Ft.message}`))))))}}function useLoader(st,at,pt,vt){const wt=Array.isArray(at)?at:[at],$t=suspend(loadingFn(pt,vt),[st,...wt],{equal:is$2.equ});return Array.isArray(at)?$t:$t[0]}useLoader.preload=function(st,at,pt){const vt=Array.isArray(at)?at:[at];return preload(loadingFn(pt),[st,...vt])};useLoader.clear=function(st,at){const pt=Array.isArray(at)?at:[at];return clear([st,...pt])};const roots=new Map,{invalidate,advance}=createLoop(roots),{reconciler,applyProps}=createRenderer(roots,getEventPriority),shallowLoose={objects:"shallow",strict:!1},createRendererInstance=(st,at)=>{const pt=typeof st=="function"?st(at):st;return isRenderer(pt)?pt:new WebGLRenderer({powerPreference:"high-performance",canvas:at,antialias:!0,alpha:!0,...st})};function computeInitialSize(st,at){const pt=typeof HTMLCanvasElement<"u"&&st instanceof HTMLCanvasElement;if(at){const{width:vt,height:wt,top:$t,left:Tt,updateStyle:Lt=pt}=at;return{width:vt,height:wt,top:$t,left:Tt,updateStyle:Lt}}else if(typeof HTMLCanvasElement<"u"&&st instanceof HTMLCanvasElement&&st.parentElement){const{width:vt,height:wt,top:$t,left:Tt}=st.parentElement.getBoundingClientRect();return{width:vt,height:wt,top:$t,left:Tt,updateStyle:pt}}else if(typeof OffscreenCanvas<"u"&&st instanceof OffscreenCanvas)return{width:st.width,height:st.height,top:0,left:0,updateStyle:pt};return{width:0,height:0,top:0,left:0}}function createRoot(st){const at=roots.get(st),pt=at==null?void 0:at.fiber,vt=at==null?void 0:at.store;at&&console.warn("R3F.createRoot should only be called once!");const wt=typeof reportError=="function"?reportError:console.error,$t=vt||createStore(invalidate,advance),Tt=pt||reconciler.createContainer($t,constantsExports.ConcurrentRoot,null,!1,null,"",wt,null);at||roots.set(st,{fiber:Tt,store:$t});let Lt,Ft=!1,Ct;return{configure(Ht={}){let{gl:Gt,size:jt,scene:qt,events:Kt,onCreated:An,shadows:Sn=!1,linear:wn=!1,flat:In=!1,legacy:tr=!1,orthographic:rr=!1,frameloop:Hr="always",dpr:qr=[1,2],performance:Zr,raycaster:Bo,camera:Xo,onPointerMissed:Kr}=Ht,ko=$t.getState(),f0=ko.gl;ko.gl||ko.set({gl:f0=createRendererInstance(Gt,st)});let x0=ko.raycaster;x0||ko.set({raycaster:x0=new Raycaster});const{params:l0,...T0}=Bo||{};if(is$2.equ(T0,x0,shallowLoose)||applyProps(x0,{...T0}),is$2.equ(l0,x0.params,shallowLoose)||applyProps(x0,{params:{...x0.params,...l0}}),!ko.camera||ko.camera===Ct&&!is$2.equ(Ct,Xo,shallowLoose)){Ct=Xo;const h0=Xo instanceof Camera,a0=h0?Xo:rr?new OrthographicCamera(0,0,0,0,.1,1e3):new PerspectiveCamera(75,0,.1,1e3);h0||(a0.position.z=5,Xo&&(applyProps(a0,Xo),("aspect"in Xo||"left"in Xo||"right"in Xo||"bottom"in Xo||"top"in Xo)&&(a0.manual=!0,a0.updateProjectionMatrix())),!ko.camera&&!(Xo!=null&&Xo.rotation)&&a0.lookAt(0,0,0)),ko.set({camera:a0}),x0.camera=a0}if(!ko.scene){let h0;qt instanceof Scene?h0=qt:(h0=new Scene,qt&&applyProps(h0,qt)),ko.set({scene:prepare(h0)})}if(!ko.xr){var t0;const h0=(V0,B0)=>{const W0=$t.getState();W0.frameloop!=="never"&&advance(V0,!0,W0,B0)},a0=()=>{const V0=$t.getState();V0.gl.xr.enabled=V0.gl.xr.isPresenting,V0.gl.xr.setAnimationLoop(V0.gl.xr.isPresenting?h0:null),V0.gl.xr.isPresenting||invalidate(V0)},P0={connect(){const V0=$t.getState().gl;V0.xr.addEventListener("sessionstart",a0),V0.xr.addEventListener("sessionend",a0)},disconnect(){const V0=$t.getState().gl;V0.xr.removeEventListener("sessionstart",a0),V0.xr.removeEventListener("sessionend",a0)}};typeof((t0=f0.xr)==null?void 0:t0.addEventListener)=="function"&&P0.connect(),ko.set({xr:P0})}if(f0.shadowMap){const h0=f0.shadowMap.enabled,a0=f0.shadowMap.type;if(f0.shadowMap.enabled=!!Sn,is$2.boo(Sn))f0.shadowMap.type=PCFSoftShadowMap;else if(is$2.str(Sn)){var E0;const P0={basic:BasicShadowMap,percentage:PCFShadowMap,soft:PCFSoftShadowMap,variance:VSMShadowMap};f0.shadowMap.type=(E0=P0[Sn])!=null?E0:PCFSoftShadowMap}else is$2.obj(Sn)&&Object.assign(f0.shadowMap,Sn);(h0!==f0.shadowMap.enabled||a0!==f0.shadowMap.type)&&(f0.shadowMap.needsUpdate=!0)}const n0=getColorManagement();n0&&("enabled"in n0?n0.enabled=!tr:"legacyMode"in n0&&(n0.legacyMode=tr)),Ft||applyProps(f0,{outputEncoding:wn?3e3:3001,toneMapping:In?NoToneMapping:ACESFilmicToneMapping}),ko.legacy!==tr&&ko.set(()=>({legacy:tr})),ko.linear!==wn&&ko.set(()=>({linear:wn})),ko.flat!==In&&ko.set(()=>({flat:In})),Gt&&!is$2.fun(Gt)&&!isRenderer(Gt)&&!is$2.equ(Gt,f0,shallowLoose)&&applyProps(f0,Gt),Kt&&!ko.events.handlers&&ko.set({events:Kt($t)});const m0=computeInitialSize(st,jt);return is$2.equ(m0,ko.size,shallowLoose)||ko.setSize(m0.width,m0.height,m0.updateStyle,m0.top,m0.left),qr&&ko.viewport.dpr!==calculateDpr(qr)&&ko.setDpr(qr),ko.frameloop!==Hr&&ko.setFrameloop(Hr),ko.onPointerMissed||ko.set({onPointerMissed:Kr}),Zr&&!is$2.equ(Zr,ko.performance,shallowLoose)&&ko.set(h0=>({performance:{...h0.performance,...Zr}})),Lt=An,Ft=!0,this},render(Ht){return Ft||this.configure(),reconciler.updateContainer(jsxRuntimeExports.jsx(Provider,{store:$t,children:Ht,onCreated:Lt,rootElement:st}),Tt,null,()=>{}),$t},unmount(){unmountComponentAtNode(st)}}}function Provider({store:st,children:at,onCreated:pt,rootElement:vt}){return useIsomorphicLayoutEffect(()=>{const wt=st.getState();wt.set($t=>({internal:{...$t.internal,active:!0}})),pt&&pt(wt),st.getState().events.connected||wt.events.connect==null||wt.events.connect(vt)},[]),jsxRuntimeExports.jsx(context.Provider,{value:st,children:at})}function unmountComponentAtNode(st,at){const pt=roots.get(st),vt=pt==null?void 0:pt.fiber;if(vt){const wt=pt==null?void 0:pt.store.getState();wt&&(wt.internal.active=!1),reconciler.updateContainer(null,vt,null,()=>{wt&&setTimeout(()=>{try{var $t,Tt,Lt,Ft;wt.events.disconnect==null||wt.events.disconnect(),($t=wt.gl)==null||(Tt=$t.renderLists)==null||Tt.dispose==null||Tt.dispose(),(Lt=wt.gl)==null||Lt.forceContextLoss==null||Lt.forceContextLoss(),(Ft=wt.gl)!=null&&Ft.xr&&wt.xr.disconnect(),dispose(wt),roots.delete(st)}catch{}},500)})}}function createPortal(st,at,pt){return jsxRuntimeExports.jsx(Portal$1,{children:st,container:at,state:pt},at.uuid)}function Portal$1({state:st={},children:at,container:pt}){const{events:vt,size:wt,...$t}=st,Tt=useStore(),[Lt]=reactExports.useState(()=>new Raycaster),[Ft]=reactExports.useState(()=>new Vector2),Ct=reactExports.useCallback((Gt,jt)=>{const qt={...Gt};Object.keys(Gt).forEach(An=>{(privateKeys.includes(An)||Gt[An]!==jt[An]&&jt[An])&&delete qt[An]});let Kt;if(jt&&wt){const An=jt.camera;Kt=Gt.viewport.getCurrentViewport(An,new Vector3,wt),An!==Gt.camera&&updateCamera(An,wt)}return{...qt,scene:pt,raycaster:Lt,pointer:Ft,mouse:Ft,previousRoot:Tt,events:{...Gt.events,...jt==null?void 0:jt.events,...vt},size:{...Gt.size,...wt},viewport:{...Gt.viewport,...Kt},...$t}},[st]),[Ht]=reactExports.useState(()=>{const Gt=Tt.getState();return create((qt,Kt)=>({...Gt,scene:pt,raycaster:Lt,pointer:Ft,mouse:Ft,previousRoot:Tt,events:{...Gt.events,...vt},size:{...Gt.size,...wt},...$t,set:qt,get:Kt,setEvents:An=>qt(Sn=>({...Sn,events:{...Sn.events,...An}}))}))});return reactExports.useEffect(()=>{const Gt=Tt.subscribe(jt=>Ht.setState(qt=>Ct(jt,qt)));return()=>{Gt()}},[Ct]),reactExports.useEffect(()=>{Ht.setState(Gt=>Ct(Tt.getState(),Gt))},[Ct]),reactExports.useEffect(()=>()=>{Ht.destroy()},[]),jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment,{children:reconciler.createPortal(jsxRuntimeExports.jsx(context.Provider,{value:Ht,children:at}),Ht,null)})}reconciler.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:reactExports.version});function debounce$1(st,at,pt){var vt,wt,$t,Tt,Lt;at==null&&(at=100);function Ft(){var Ht=Date.now()-Tt;Ht<at&&Ht>=0?vt=setTimeout(Ft,at-Ht):(vt=null,pt||(Lt=st.apply($t,wt),$t=wt=null))}var Ct=function(){$t=this,wt=arguments,Tt=Date.now();var Ht=pt&&!vt;return vt||(vt=setTimeout(Ft,at)),Ht&&(Lt=st.apply($t,wt),$t=wt=null),Lt};return Ct.clear=function(){vt&&(clearTimeout(vt),vt=null)},Ct.flush=function(){vt&&(Lt=st.apply($t,wt),$t=wt=null,clearTimeout(vt),vt=null)},Ct}debounce$1.debounce=debounce$1;var debounce_1=debounce$1;const createDebounce=getDefaultExportFromCjs(debounce_1);function useMeasure(st){let{debounce:at,scroll:pt,polyfill:vt,offsetSize:wt}=st===void 0?{debounce:0,scroll:!1,offsetSize:!1}:st;const $t=vt||(typeof window>"u"?class{}:window.ResizeObserver);if(!$t)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[Tt,Lt]=reactExports.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),Ft=reactExports.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:Tt}),Ct=at?typeof at=="number"?at:at.scroll:null,Ht=at?typeof at=="number"?at:at.resize:null,Gt=reactExports.useRef(!1);reactExports.useEffect(()=>(Gt.current=!0,()=>void(Gt.current=!1)));const[jt,qt,Kt]=reactExports.useMemo(()=>{const In=()=>{if(!Ft.current.element)return;const{left:tr,top:rr,width:Hr,height:qr,bottom:Zr,right:Bo,x:Xo,y:Kr}=Ft.current.element.getBoundingClientRect(),ko={left:tr,top:rr,width:Hr,height:qr,bottom:Zr,right:Bo,x:Xo,y:Kr};Ft.current.element instanceof HTMLElement&&wt&&(ko.height=Ft.current.element.offsetHeight,ko.width=Ft.current.element.offsetWidth),Object.freeze(ko),Gt.current&&!areBoundsEqual(Ft.current.lastBounds,ko)&&Lt(Ft.current.lastBounds=ko)};return[In,Ht?createDebounce(In,Ht):In,Ct?createDebounce(In,Ct):In]},[Lt,wt,Ct,Ht]);function An(){Ft.current.scrollContainers&&(Ft.current.scrollContainers.forEach(In=>In.removeEventListener("scroll",Kt,!0)),Ft.current.scrollContainers=null),Ft.current.resizeObserver&&(Ft.current.resizeObserver.disconnect(),Ft.current.resizeObserver=null)}function Sn(){Ft.current.element&&(Ft.current.resizeObserver=new $t(Kt),Ft.current.resizeObserver.observe(Ft.current.element),pt&&Ft.current.scrollContainers&&Ft.current.scrollContainers.forEach(In=>In.addEventListener("scroll",Kt,{capture:!0,passive:!0})))}const wn=In=>{!In||In===Ft.current.element||(An(),Ft.current.element=In,Ft.current.scrollContainers=findScrollContainers(In),Sn())};return useOnWindowScroll(Kt,!!pt),useOnWindowResize(qt),reactExports.useEffect(()=>{An(),Sn()},[pt,Kt,qt]),reactExports.useEffect(()=>An,[]),[wn,Tt,jt]}function useOnWindowResize(st){reactExports.useEffect(()=>{const at=st;return window.addEventListener("resize",at),()=>void window.removeEventListener("resize",at)},[st])}function useOnWindowScroll(st,at){reactExports.useEffect(()=>{if(at){const pt=st;return window.addEventListener("scroll",pt,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",pt,!0)}},[st,at])}function findScrollContainers(st){const at=[];if(!st||st===document.body)return at;const{overflow:pt,overflowX:vt,overflowY:wt}=window.getComputedStyle(st);return[pt,vt,wt].some($t=>$t==="auto"||$t==="scroll")&&at.push(st),[...at,...findScrollContainers(st.parentElement)]}const keys=["x","y","top","bottom","left","right","width","height"],areBoundsEqual=(st,at)=>keys.every(pt=>st[pt]===at[pt]);var __defProp$3=Object.defineProperty,__defProps=Object.defineProperties,__getOwnPropDescs=Object.getOwnPropertyDescriptors,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp$1=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp$2=(st,at,pt)=>at in st?__defProp$3(st,at,{enumerable:!0,configurable:!0,writable:!0,value:pt}):st[at]=pt,__spreadValues=(st,at)=>{for(var pt in at||(at={}))__hasOwnProp$1.call(at,pt)&&__defNormalProp$2(st,pt,at[pt]);if(__getOwnPropSymbols)for(var pt of __getOwnPropSymbols(at))__propIsEnum.call(at,pt)&&__defNormalProp$2(st,pt,at[pt]);return st},__spreadProps=(st,at)=>__defProps(st,__getOwnPropDescs(at)),_a$2,_b$2;typeof window<"u"&&((_a$2=window.document)!=null&&_a$2.createElement||((_b$2=window.navigator)==null?void 0:_b$2.product)==="ReactNative")?reactExports.useLayoutEffect:reactExports.useEffect;function traverseFiber(st,at,pt){if(!st)return;if(pt(st)===!0)return st;let vt=st.child;for(;vt;){const wt=traverseFiber(vt,at,pt);if(wt)return wt;vt=vt.sibling}}function wrapContext(st){try{return Object.defineProperties(st,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return st}}const error=console.error;console.error=function(){const st=[...arguments].join("");if(st!=null&&st.startsWith("Warning:")&&st.includes("useContext")){console.error=error;return}return error.apply(this,arguments)};const FiberContext=wrapContext(reactExports.createContext(null));class FiberProvider extends reactExports.Component{render(){return reactExports.createElement(FiberContext.Provider,{value:this._reactInternals},this.props.children)}}function useFiber(){const st=reactExports.useContext(FiberContext);if(st===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const at=reactExports.useId();return reactExports.useMemo(()=>{for(const vt of[st,st==null?void 0:st.alternate]){if(!vt)continue;const wt=traverseFiber(vt,!1,$t=>{let Tt=$t.memoizedState;for(;Tt;){if(Tt.memoizedState===at)return!0;Tt=Tt.next}});if(wt)return wt}},[st,at])}function useContextMap(){const st=useFiber(),[at]=reactExports.useState(()=>new Map);at.clear();let pt=st;for(;pt;){if(pt.type&&typeof pt.type=="object"){const wt=pt.type._context===void 0&&pt.type.Provider===pt.type?pt.type:pt.type._context;wt&&wt!==FiberContext&&!at.has(wt)&&at.set(wt,reactExports.useContext(wrapContext(wt)))}pt=pt.return}return at}function useContextBridge(){const st=useContextMap();return reactExports.useMemo(()=>Array.from(st.keys()).reduce((at,pt)=>vt=>reactExports.createElement(at,null,reactExports.createElement(pt.Provider,__spreadProps(__spreadValues({},vt),{value:st.get(pt)}))),at=>reactExports.createElement(FiberProvider,__spreadValues({},at))),[st])}const DOM_EVENTS={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function createPointerEvents(st){const{handlePointer:at}=createEvents(st);return{priority:1,enabled:!0,compute(pt,vt,wt){vt.pointer.set(pt.offsetX/vt.size.width*2-1,-(pt.offsetY/vt.size.height)*2+1),vt.raycaster.setFromCamera(vt.pointer,vt.camera)},connected:void 0,handlers:Object.keys(DOM_EVENTS).reduce((pt,vt)=>({...pt,[vt]:at(vt)}),{}),update:()=>{var pt;const{events:vt,internal:wt}=st.getState();(pt=wt.lastEvent)!=null&&pt.current&&vt.handlers&&vt.handlers.onPointerMove(wt.lastEvent.current)},connect:pt=>{var vt;const{set:wt,events:$t}=st.getState();$t.disconnect==null||$t.disconnect(),wt(Tt=>({events:{...Tt.events,connected:pt}})),Object.entries((vt=$t.handlers)!=null?vt:[]).forEach(([Tt,Lt])=>{const[Ft,Ct]=DOM_EVENTS[Tt];pt.addEventListener(Ft,Lt,{passive:Ct})})},disconnect:()=>{const{set:pt,events:vt}=st.getState();if(vt.connected){var wt;Object.entries((wt=vt.handlers)!=null?wt:[]).forEach(([$t,Tt])=>{if(vt&&vt.connected instanceof HTMLElement){const[Lt]=DOM_EVENTS[$t];vt.connected.removeEventListener(Lt,Tt)}}),pt($t=>({events:{...$t.events,connected:void 0}}))}}}}const CanvasImpl=reactExports.forwardRef(function({children:at,fallback:pt,resize:vt,style:wt,gl:$t,events:Tt=createPointerEvents,eventSource:Lt,eventPrefix:Ft,shadows:Ct,linear:Ht,flat:Gt,legacy:jt,orthographic:qt,frameloop:Kt,dpr:An,performance:Sn,raycaster:wn,camera:In,scene:tr,onPointerMissed:rr,onCreated:Hr,...qr},Zr){reactExports.useMemo(()=>extend$2(THREE),[]);const Bo=useContextBridge(),[Xo,Kr]=useMeasure({scroll:!0,debounce:{scroll:50,resize:0},...vt}),ko=reactExports.useRef(null),f0=reactExports.useRef(null);reactExports.useImperativeHandle(Zr,()=>ko.current);const x0=useMutableCallback(rr),[l0,T0]=reactExports.useState(!1),[t0,E0]=reactExports.useState(!1);if(l0)throw l0;if(t0)throw t0;const n0=reactExports.useRef(null);useIsomorphicLayoutEffect(()=>{const h0=ko.current;Kr.width>0&&Kr.height>0&&h0&&(n0.current||(n0.current=createRoot(h0)),n0.current.configure({gl:$t,events:Tt,shadows:Ct,linear:Ht,flat:Gt,legacy:jt,orthographic:qt,frameloop:Kt,dpr:An,performance:Sn,raycaster:wn,camera:In,scene:tr,size:Kr,onPointerMissed:(...a0)=>x0.current==null?void 0:x0.current(...a0),onCreated:a0=>{a0.events.connect==null||a0.events.connect(Lt?isRef$1(Lt)?Lt.current:Lt:f0.current),Ft&&a0.setEvents({compute:(P0,V0)=>{const B0=P0[Ft+"X"],W0=P0[Ft+"Y"];V0.pointer.set(B0/V0.size.width*2-1,-(W0/V0.size.height)*2+1),V0.raycaster.setFromCamera(V0.pointer,V0.camera)}}),Hr==null||Hr(a0)}}),n0.current.render(jsxRuntimeExports.jsx(Bo,{children:jsxRuntimeExports.jsx(ErrorBoundary,{set:E0,children:jsxRuntimeExports.jsx(reactExports.Suspense,{fallback:jsxRuntimeExports.jsx(Block,{set:T0}),children:at})})})))}),reactExports.useEffect(()=>{const h0=ko.current;if(h0)return()=>unmountComponentAtNode(h0)},[]);const m0=Lt?"none":"auto";return jsxRuntimeExports.jsx("div",{ref:f0,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:m0,...wt},...qr,children:jsxRuntimeExports.jsx("div",{ref:Xo,style:{width:"100%",height:"100%"},children:jsxRuntimeExports.jsx("canvas",{ref:ko,style:{display:"block"},children:pt})})})}),Canvas$1=reactExports.forwardRef(function(at,pt){return jsxRuntimeExports.jsx(FiberProvider,{children:jsxRuntimeExports.jsx(CanvasImpl,{...at,ref:pt})})});function _extends$1(){return _extends$1=Object.assign?Object.assign.bind():function(st){for(var at=1;at<arguments.length;at++){var pt=arguments[at];for(var vt in pt)Object.prototype.hasOwnProperty.call(pt,vt)&&(st[vt]=pt[vt])}return st},_extends$1.apply(this,arguments)}function clamp$2(st,at,pt){return Math.max(at,Math.min(st,pt))}const V$3={toVector(st,at){return st===void 0&&(st=at),Array.isArray(st)?st:[st,st]},add(st,at){return[st[0]+at[0],st[1]+at[1]]},sub(st,at){return[st[0]-at[0],st[1]-at[1]]},addTo(st,at){st[0]+=at[0],st[1]+=at[1]},subTo(st,at){st[0]-=at[0],st[1]-=at[1]}};function rubberband(st,at,pt){return at===0||Math.abs(at)===1/0?Math.pow(st,pt*5):st*at*pt/(at+pt*st)}function rubberbandIfOutOfBounds(st,at,pt,vt=.15){return vt===0?clamp$2(st,at,pt):st<at?-rubberband(at-st,pt-at,vt)+at:st>pt?+rubberband(st-pt,pt-at,vt)+pt:st}function computeRubberband(st,[at,pt],[vt,wt]){const[[$t,Tt],[Lt,Ft]]=st;return[rubberbandIfOutOfBounds(at,$t,Tt,vt),rubberbandIfOutOfBounds(pt,Lt,Ft,wt)]}function _toPrimitive(st,at){if(typeof st!="object"||st===null)return st;var pt=st[Symbol.toPrimitive];if(pt!==void 0){var vt=pt.call(st,at||"default");if(typeof vt!="object")return vt;throw new TypeError("@@toPrimitive must return a primitive value.")}return(at==="string"?String:Number)(st)}function _toPropertyKey(st){var at=_toPrimitive(st,"string");return typeof at=="symbol"?at:String(at)}function _defineProperty$3(st,at,pt){return at=_toPropertyKey(at),at in st?Object.defineProperty(st,at,{value:pt,enumerable:!0,configurable:!0,writable:!0}):st[at]=pt,st}function ownKeys$3(st,at){var pt=Object.keys(st);if(Object.getOwnPropertySymbols){var vt=Object.getOwnPropertySymbols(st);at&&(vt=vt.filter(function(wt){return Object.getOwnPropertyDescriptor(st,wt).enumerable})),pt.push.apply(pt,vt)}return pt}function _objectSpread2$1(st){for(var at=1;at<arguments.length;at++){var pt=arguments[at]!=null?arguments[at]:{};at%2?ownKeys$3(Object(pt),!0).forEach(function(vt){_defineProperty$3(st,vt,pt[vt])}):Object.getOwnPropertyDescriptors?Object.defineProperties(st,Object.getOwnPropertyDescriptors(pt)):ownKeys$3(Object(pt)).forEach(function(vt){Object.defineProperty(st,vt,Object.getOwnPropertyDescriptor(pt,vt))})}return st}const EVENT_TYPE_MAP={pointer:{start:"down",change:"move",end:"up"},mouse:{start:"down",change:"move",end:"up"},touch:{start:"start",change:"move",end:"end"},gesture:{start:"start",change:"change",end:"end"}};function capitalize(st){return st?st[0].toUpperCase()+st.slice(1):""}const actionsWithoutCaptureSupported=["enter","leave"];function hasCapture(st=!1,at){return st&&!actionsWithoutCaptureSupported.includes(at)}function toHandlerProp(st,at="",pt=!1){const vt=EVENT_TYPE_MAP[st],wt=vt&&vt[at]||at;return"on"+capitalize(st)+capitalize(wt)+(hasCapture(pt,wt)?"Capture":"")}const pointerCaptureEvents=["gotpointercapture","lostpointercapture"];function parseProp(st){let at=st.substring(2).toLowerCase();const pt=!!~at.indexOf("passive");pt&&(at=at.replace("passive",""));const vt=pointerCaptureEvents.includes(at)?"capturecapture":"capture",wt=!!~at.indexOf(vt);return wt&&(at=at.replace("capture","")),{device:at,capture:wt,passive:pt}}function toDomEventType(st,at=""){const pt=EVENT_TYPE_MAP[st],vt=pt&&pt[at]||at;return st+vt}function isTouch(st){return"touches"in st}function getPointerType(st){return isTouch(st)?"touch":"pointerType"in st?st.pointerType:"mouse"}function getCurrentTargetTouchList(st){return Array.from(st.touches).filter(at=>{var pt,vt;return at.target===st.currentTarget||((pt=st.currentTarget)===null||pt===void 0||(vt=pt.contains)===null||vt===void 0?void 0:vt.call(pt,at.target))})}function getTouchList(st){return st.type==="touchend"||st.type==="touchcancel"?st.changedTouches:st.targetTouches}function getValueEvent(st){return isTouch(st)?getTouchList(st)[0]:st}function touchIds(st){return getCurrentTargetTouchList(st).map(at=>at.identifier)}function pointerId(st){const at=getValueEvent(st);return isTouch(st)?at.identifier:at.pointerId}function pointerValues(st){const at=getValueEvent(st);return[at.clientX,at.clientY]}function getEventDetails(st){const at={};if("buttons"in st&&(at.buttons=st.buttons),"shiftKey"in st){const{shiftKey:pt,altKey:vt,metaKey:wt,ctrlKey:$t}=st;Object.assign(at,{shiftKey:pt,altKey:vt,metaKey:wt,ctrlKey:$t})}return at}function call(st,...at){return typeof st=="function"?st(...at):st}function noop$1(){}function chain(...st){return st.length===0?noop$1:st.length===1?st[0]:function(){let at;for(const pt of st)at=pt.apply(this,arguments)||at;return at}}function assignDefault(st,at){return Object.assign({},at,st||{})}const BEFORE_LAST_KINEMATICS_DELAY=32;class Engine{constructor(at,pt,vt){this.ctrl=at,this.args=pt,this.key=vt,this.state||(this.state={},this.computeValues([0,0]),this.computeInitial(),this.init&&this.init(),this.reset())}get state(){return this.ctrl.state[this.key]}set state(at){this.ctrl.state[this.key]=at}get shared(){return this.ctrl.state.shared}get eventStore(){return this.ctrl.gestureEventStores[this.key]}get timeoutStore(){return this.ctrl.gestureTimeoutStores[this.key]}get config(){return this.ctrl.config[this.key]}get sharedConfig(){return this.ctrl.config.shared}get handler(){return this.ctrl.handlers[this.key]}reset(){const{state:at,shared:pt,ingKey:vt,args:wt}=this;pt[vt]=at._active=at.active=at._blocked=at._force=!1,at._step=[!1,!1],at.intentional=!1,at._movement=[0,0],at._distance=[0,0],at._direction=[0,0],at._delta=[0,0],at._bounds=[[-1/0,1/0],[-1/0,1/0]],at.args=wt,at.axis=void 0,at.memo=void 0,at.elapsedTime=at.timeDelta=0,at.direction=[0,0],at.distance=[0,0],at.overflow=[0,0],at._movementBound=[!1,!1],at.velocity=[0,0],at.movement=[0,0],at.delta=[0,0],at.timeStamp=0}start(at){const pt=this.state,vt=this.config;pt._active||(this.reset(),this.computeInitial(),pt._active=!0,pt.target=at.target,pt.currentTarget=at.currentTarget,pt.lastOffset=vt.from?call(vt.from,pt):pt.offset,pt.offset=pt.lastOffset,pt.startTime=pt.timeStamp=at.timeStamp)}computeValues(at){const pt=this.state;pt._values=at,pt.values=this.config.transform(at)}computeInitial(){const at=this.state;at._initial=at._values,at.initial=at.values}compute(at){const{state:pt,config:vt,shared:wt}=this;pt.args=this.args;let $t=0;if(at&&(pt.event=at,vt.preventDefault&&at.cancelable&&pt.event.preventDefault(),pt.type=at.type,wt.touches=this.ctrl.pointerIds.size||this.ctrl.touchIds.size,wt.locked=!!document.pointerLockElement,Object.assign(wt,getEventDetails(at)),wt.down=wt.pressed=wt.buttons%2===1||wt.touches>0,$t=at.timeStamp-pt.timeStamp,pt.timeStamp=at.timeStamp,pt.elapsedTime=pt.timeStamp-pt.startTime),pt._active){const qr=pt._delta.map(Math.abs);V$3.addTo(pt._distance,qr)}this.axisIntent&&this.axisIntent(at);const[Tt,Lt]=pt._movement,[Ft,Ct]=vt.threshold,{_step:Ht,values:Gt}=pt;if(vt.hasCustomTransform?(Ht[0]===!1&&(Ht[0]=Math.abs(Tt)>=Ft&&Gt[0]),Ht[1]===!1&&(Ht[1]=Math.abs(Lt)>=Ct&&Gt[1])):(Ht[0]===!1&&(Ht[0]=Math.abs(Tt)>=Ft&&Math.sign(Tt)*Ft),Ht[1]===!1&&(Ht[1]=Math.abs(Lt)>=Ct&&Math.sign(Lt)*Ct)),pt.intentional=Ht[0]!==!1||Ht[1]!==!1,!pt.intentional)return;const jt=[0,0];if(vt.hasCustomTransform){const[qr,Zr]=Gt;jt[0]=Ht[0]!==!1?qr-Ht[0]:0,jt[1]=Ht[1]!==!1?Zr-Ht[1]:0}else jt[0]=Ht[0]!==!1?Tt-Ht[0]:0,jt[1]=Ht[1]!==!1?Lt-Ht[1]:0;this.restrictToAxis&&!pt._blocked&&this.restrictToAxis(jt);const qt=pt.offset,Kt=pt._active&&!pt._blocked||pt.active;Kt&&(pt.first=pt._active&&!pt.active,pt.last=!pt._active&&pt.active,pt.active=wt[this.ingKey]=pt._active,at&&(pt.first&&("bounds"in vt&&(pt._bounds=call(vt.bounds,pt)),this.setup&&this.setup()),pt.movement=jt,this.computeOffset()));const[An,Sn]=pt.offset,[[wn,In],[tr,rr]]=pt._bounds;pt.overflow=[An<wn?-1:An>In?1:0,Sn<tr?-1:Sn>rr?1:0],pt._movementBound[0]=pt.overflow[0]?pt._movementBound[0]===!1?pt._movement[0]:pt._movementBound[0]:!1,pt._movementBound[1]=pt.overflow[1]?pt._movementBound[1]===!1?pt._movement[1]:pt._movementBound[1]:!1;const Hr=pt._active?vt.rubberband||[0,0]:[0,0];if(pt.offset=computeRubberband(pt._bounds,pt.offset,Hr),pt.delta=V$3.sub(pt.offset,qt),this.computeMovement(),Kt&&(!pt.last||$t>BEFORE_LAST_KINEMATICS_DELAY)){pt.delta=V$3.sub(pt.offset,qt);const qr=pt.delta.map(Math.abs);V$3.addTo(pt.distance,qr),pt.direction=pt.delta.map(Math.sign),pt._direction=pt._delta.map(Math.sign),!pt.first&&$t>0&&(pt.velocity=[qr[0]/$t,qr[1]/$t],pt.timeDelta=$t)}}emit(){const at=this.state,pt=this.shared,vt=this.config;if(at._active||this.clean(),(at._blocked||!at.intentional)&&!at._force&&!vt.triggerAllEvents)return;const wt=this.handler(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({},pt),at),{},{[this.aliasKey]:at.values}));wt!==void 0&&(at.memo=wt)}clean(){this.eventStore.clean(),this.timeoutStore.clean()}}function selectAxis([st,at],pt){const vt=Math.abs(st),wt=Math.abs(at);if(vt>wt&&vt>pt)return"x";if(wt>vt&&wt>pt)return"y"}class CoordinatesEngine extends Engine{constructor(...at){super(...at),_defineProperty$3(this,"aliasKey","xy")}reset(){super.reset(),this.state.axis=void 0}init(){this.state.offset=[0,0],this.state.lastOffset=[0,0]}computeOffset(){this.state.offset=V$3.add(this.state.lastOffset,this.state.movement)}computeMovement(){this.state.movement=V$3.sub(this.state.offset,this.state.lastOffset)}axisIntent(at){const pt=this.state,vt=this.config;if(!pt.axis&&at){const wt=typeof vt.axisThreshold=="object"?vt.axisThreshold[getPointerType(at)]:vt.axisThreshold;pt.axis=selectAxis(pt._movement,wt)}pt._blocked=(vt.lockDirection||!!vt.axis)&&!pt.axis||!!vt.axis&&vt.axis!==pt.axis}restrictToAxis(at){if(this.config.axis||this.config.lockDirection)switch(this.state.axis){case"x":at[1]=0;break;case"y":at[0]=0;break}}}const identity=st=>st,DEFAULT_RUBBERBAND=.15,commonConfigResolver={enabled(st=!0){return st},eventOptions(st,at,pt){return _objectSpread2$1(_objectSpread2$1({},pt.shared.eventOptions),st)},preventDefault(st=!1){return st},triggerAllEvents(st=!1){return st},rubberband(st=0){switch(st){case!0:return[DEFAULT_RUBBERBAND,DEFAULT_RUBBERBAND];case!1:return[0,0];default:return V$3.toVector(st)}},from(st){if(typeof st=="function")return st;if(st!=null)return V$3.toVector(st)},transform(st,at,pt){const vt=st||pt.shared.transform;return this.hasCustomTransform=!!vt,vt||identity},threshold(st){return V$3.toVector(st,0)}},DEFAULT_AXIS_THRESHOLD=0,coordinatesConfigResolver=_objectSpread2$1(_objectSpread2$1({},commonConfigResolver),{},{axis(st,at,{axis:pt}){if(this.lockDirection=pt==="lock",!this.lockDirection)return pt},axisThreshold(st=DEFAULT_AXIS_THRESHOLD){return st},bounds(st={}){if(typeof st=="function")return $t=>coordinatesConfigResolver.bounds(st($t));if("current"in st)return()=>st.current;if(typeof HTMLElement=="function"&&st instanceof HTMLElement)return st;const{left:at=-1/0,right:pt=1/0,top:vt=-1/0,bottom:wt=1/0}=st;return[[at,pt],[vt,wt]]}}),KEYS_DELTA_MAP={ArrowRight:(st,at=1)=>[st*at,0],ArrowLeft:(st,at=1)=>[-1*st*at,0],ArrowUp:(st,at=1)=>[0,-1*st*at],ArrowDown:(st,at=1)=>[0,st*at]};class DragEngine extends CoordinatesEngine{constructor(...at){super(...at),_defineProperty$3(this,"ingKey","dragging")}reset(){super.reset();const at=this.state;at._pointerId=void 0,at._pointerActive=!1,at._keyboardActive=!1,at._preventScroll=!1,at._delayed=!1,at.swipe=[0,0],at.tap=!1,at.canceled=!1,at.cancel=this.cancel.bind(this)}setup(){const at=this.state;if(at._bounds instanceof HTMLElement){const pt=at._bounds.getBoundingClientRect(),vt=at.currentTarget.getBoundingClientRect(),wt={left:pt.left-vt.left+at.offset[0],right:pt.right-vt.right+at.offset[0],top:pt.top-vt.top+at.offset[1],bottom:pt.bottom-vt.bottom+at.offset[1]};at._bounds=coordinatesConfigResolver.bounds(wt)}}cancel(){const at=this.state;at.canceled||(at.canceled=!0,at._active=!1,setTimeout(()=>{this.compute(),this.emit()},0))}setActive(){this.state._active=this.state._pointerActive||this.state._keyboardActive}clean(){this.pointerClean(),this.state._pointerActive=!1,this.state._keyboardActive=!1,super.clean()}pointerDown(at){const pt=this.config,vt=this.state;if(at.buttons!=null&&(Array.isArray(pt.pointerButtons)?!pt.pointerButtons.includes(at.buttons):pt.pointerButtons!==-1&&pt.pointerButtons!==at.buttons))return;const wt=this.ctrl.setEventIds(at);pt.pointerCapture&&at.target.setPointerCapture(at.pointerId),!(wt&&wt.size>1&&vt._pointerActive)&&(this.start(at),this.setupPointer(at),vt._pointerId=pointerId(at),vt._pointerActive=!0,this.computeValues(pointerValues(at)),this.computeInitial(),pt.preventScrollAxis&&getPointerType(at)!=="mouse"?(vt._active=!1,this.setupScrollPrevention(at)):pt.delay>0?(this.setupDelayTrigger(at),pt.triggerAllEvents&&(this.compute(at),this.emit())):this.startPointerDrag(at))}startPointerDrag(at){const pt=this.state;pt._active=!0,pt._preventScroll=!0,pt._delayed=!1,this.compute(at),this.emit()}pointerMove(at){const pt=this.state,vt=this.config;if(!pt._pointerActive)return;const wt=pointerId(at);if(pt._pointerId!==void 0&&wt!==pt._pointerId)return;const $t=pointerValues(at);if(document.pointerLockElement===at.target?pt._delta=[at.movementX,at.movementY]:(pt._delta=V$3.sub($t,pt._values),this.computeValues($t)),V$3.addTo(pt._movement,pt._delta),this.compute(at),pt._delayed&&pt.intentional){this.timeoutStore.remove("dragDelay"),pt.active=!1,this.startPointerDrag(at);return}if(vt.preventScrollAxis&&!pt._preventScroll)if(pt.axis)if(pt.axis===vt.preventScrollAxis||vt.preventScrollAxis==="xy"){pt._active=!1,this.clean();return}else{this.timeoutStore.remove("startPointerDrag"),this.startPointerDrag(at);return}else return;this.emit()}pointerUp(at){this.ctrl.setEventIds(at);try{this.config.pointerCapture&&at.target.hasPointerCapture(at.pointerId)&&at.target.releasePointerCapture(at.pointerId)}catch{}const pt=this.state,vt=this.config;if(!pt._active||!pt._pointerActive)return;const wt=pointerId(at);if(pt._pointerId!==void 0&&wt!==pt._pointerId)return;this.state._pointerActive=!1,this.setActive(),this.compute(at);const[$t,Tt]=pt._distance;if(pt.tap=$t<=vt.tapsThreshold&&Tt<=vt.tapsThreshold,pt.tap&&vt.filterTaps)pt._force=!0;else{const[Lt,Ft]=pt._delta,[Ct,Ht]=pt._movement,[Gt,jt]=vt.swipe.velocity,[qt,Kt]=vt.swipe.distance,An=vt.swipe.duration;if(pt.elapsedTime<An){const Sn=Math.abs(Lt/pt.timeDelta),wn=Math.abs(Ft/pt.timeDelta);Sn>Gt&&Math.abs(Ct)>qt&&(pt.swipe[0]=Math.sign(Lt)),wn>jt&&Math.abs(Ht)>Kt&&(pt.swipe[1]=Math.sign(Ft))}}this.emit()}pointerClick(at){!this.state.tap&&at.detail>0&&(at.preventDefault(),at.stopPropagation())}setupPointer(at){const pt=this.config,vt=pt.device;pt.pointerLock&&at.currentTarget.requestPointerLock(),pt.pointerCapture||(this.eventStore.add(this.sharedConfig.window,vt,"change",this.pointerMove.bind(this)),this.eventStore.add(this.sharedConfig.window,vt,"end",this.pointerUp.bind(this)),this.eventStore.add(this.sharedConfig.window,vt,"cancel",this.pointerUp.bind(this)))}pointerClean(){this.config.pointerLock&&document.pointerLockElement===this.state.currentTarget&&document.exitPointerLock()}preventScroll(at){this.state._preventScroll&&at.cancelable&&at.preventDefault()}setupScrollPrevention(at){this.state._preventScroll=!1,persistEvent(at);const pt=this.eventStore.add(this.sharedConfig.window,"touch","change",this.preventScroll.bind(this),{passive:!1});this.eventStore.add(this.sharedConfig.window,"touch","end",pt),this.eventStore.add(this.sharedConfig.window,"touch","cancel",pt),this.timeoutStore.add("startPointerDrag",this.startPointerDrag.bind(this),this.config.preventScrollDelay,at)}setupDelayTrigger(at){this.state._delayed=!0,this.timeoutStore.add("dragDelay",()=>{this.state._step=[0,0],this.startPointerDrag(at)},this.config.delay)}keyDown(at){const pt=KEYS_DELTA_MAP[at.key];if(pt){const vt=this.state,wt=at.shiftKey?10:at.altKey?.1:1;this.start(at),vt._delta=pt(this.config.keyboardDisplacement,wt),vt._keyboardActive=!0,V$3.addTo(vt._movement,vt._delta),this.compute(at),this.emit()}}keyUp(at){at.key in KEYS_DELTA_MAP&&(this.state._keyboardActive=!1,this.setActive(),this.compute(at),this.emit())}bind(at){const pt=this.config.device;at(pt,"start",this.pointerDown.bind(this)),this.config.pointerCapture&&(at(pt,"change",this.pointerMove.bind(this)),at(pt,"end",this.pointerUp.bind(this)),at(pt,"cancel",this.pointerUp.bind(this)),at("lostPointerCapture","",this.pointerUp.bind(this))),this.config.keys&&(at("key","down",this.keyDown.bind(this)),at("key","up",this.keyUp.bind(this))),this.config.filterTaps&&at("click","",this.pointerClick.bind(this),{capture:!0,passive:!1})}}function persistEvent(st){"persist"in st&&typeof st.persist=="function"&&st.persist()}const isBrowser=typeof window<"u"&&window.document&&window.document.createElement;function supportsTouchEvents(){return isBrowser&&"ontouchstart"in window}function isTouchScreen(){return supportsTouchEvents()||isBrowser&&window.navigator.maxTouchPoints>1}function supportsPointerEvents(){return isBrowser&&"onpointerdown"in window}function supportsPointerLock(){return isBrowser&&"exitPointerLock"in window.document}function supportsGestureEvents(){try{return"constructor"in GestureEvent}catch{return!1}}const SUPPORT={isBrowser,gesture:supportsGestureEvents(),touch:supportsTouchEvents(),touchscreen:isTouchScreen(),pointer:supportsPointerEvents(),pointerLock:supportsPointerLock()},DEFAULT_PREVENT_SCROLL_DELAY=250,DEFAULT_DRAG_DELAY=180,DEFAULT_SWIPE_VELOCITY=.5,DEFAULT_SWIPE_DISTANCE=50,DEFAULT_SWIPE_DURATION=250,DEFAULT_KEYBOARD_DISPLACEMENT=10,DEFAULT_DRAG_AXIS_THRESHOLD={mouse:0,touch:0,pen:8},dragConfigResolver=_objectSpread2$1(_objectSpread2$1({},coordinatesConfigResolver),{},{device(st,at,{pointer:{touch:pt=!1,lock:vt=!1,mouse:wt=!1}={}}){return this.pointerLock=vt&&SUPPORT.pointerLock,SUPPORT.touch&&pt?"touch":this.pointerLock?"mouse":SUPPORT.pointer&&!wt?"pointer":SUPPORT.touch?"touch":"mouse"},preventScrollAxis(st,at,{preventScroll:pt}){if(this.preventScrollDelay=typeof pt=="number"?pt:pt||pt===void 0&&st?DEFAULT_PREVENT_SCROLL_DELAY:void 0,!(!SUPPORT.touchscreen||pt===!1))return st||(pt!==void 0?"y":void 0)},pointerCapture(st,at,{pointer:{capture:pt=!0,buttons:vt=1,keys:wt=!0}={}}){return this.pointerButtons=vt,this.keys=wt,!this.pointerLock&&this.device==="pointer"&&pt},threshold(st,at,{filterTaps:pt=!1,tapsThreshold:vt=3,axis:wt=void 0}){const $t=V$3.toVector(st,pt?vt:wt?1:0);return this.filterTaps=pt,this.tapsThreshold=vt,$t},swipe({velocity:st=DEFAULT_SWIPE_VELOCITY,distance:at=DEFAULT_SWIPE_DISTANCE,duration:pt=DEFAULT_SWIPE_DURATION}={}){return{velocity:this.transform(V$3.toVector(st)),distance:this.transform(V$3.toVector(at)),duration:pt}},delay(st=0){switch(st){case!0:return DEFAULT_DRAG_DELAY;case!1:return 0;default:return st}},axisThreshold(st){return st?_objectSpread2$1(_objectSpread2$1({},DEFAULT_DRAG_AXIS_THRESHOLD),st):DEFAULT_DRAG_AXIS_THRESHOLD},keyboardDisplacement(st=DEFAULT_KEYBOARD_DISPLACEMENT){return st}});_objectSpread2$1(_objectSpread2$1({},commonConfigResolver),{},{device(st,at,{shared:pt,pointer:{touch:vt=!1}={}}){if(pt.target&&!SUPPORT.touch&&SUPPORT.gesture)return"gesture";if(SUPPORT.touch&&vt)return"touch";if(SUPPORT.touchscreen){if(SUPPORT.pointer)return"pointer";if(SUPPORT.touch)return"touch"}},bounds(st,at,{scaleBounds:pt={},angleBounds:vt={}}){const wt=Tt=>{const Lt=assignDefault(call(pt,Tt),{min:-1/0,max:1/0});return[Lt.min,Lt.max]},$t=Tt=>{const Lt=assignDefault(call(vt,Tt),{min:-1/0,max:1/0});return[Lt.min,Lt.max]};return typeof pt!="function"&&typeof vt!="function"?[wt(),$t()]:Tt=>[wt(Tt),$t(Tt)]},threshold(st,at,pt){return this.lockDirection=pt.axis==="lock",V$3.toVector(st,this.lockDirection?[.1,3]:0)},modifierKey(st){return st===void 0?"ctrlKey":st},pinchOnWheel(st=!0){return st}});_objectSpread2$1(_objectSpread2$1({},coordinatesConfigResolver),{},{mouseOnly:(st=!0)=>st});_objectSpread2$1(_objectSpread2$1({},coordinatesConfigResolver),{},{mouseOnly:(st=!0)=>st});const EngineMap=new Map,ConfigResolverMap=new Map;function registerAction(st){EngineMap.set(st.key,st.engine),ConfigResolverMap.set(st.key,st.resolver)}const dragAction={key:"drag",engine:DragEngine,resolver:dragConfigResolver};function _objectWithoutPropertiesLoose$2(st,at){if(st==null)return{};var pt={},vt=Object.keys(st),wt,$t;for($t=0;$t<vt.length;$t++)wt=vt[$t],!(at.indexOf(wt)>=0)&&(pt[wt]=st[wt]);return pt}function _objectWithoutProperties$2(st,at){if(st==null)return{};var pt=_objectWithoutPropertiesLoose$2(st,at),vt,wt;if(Object.getOwnPropertySymbols){var $t=Object.getOwnPropertySymbols(st);for(wt=0;wt<$t.length;wt++)vt=$t[wt],!(at.indexOf(vt)>=0)&&Object.prototype.propertyIsEnumerable.call(st,vt)&&(pt[vt]=st[vt])}return pt}const sharedConfigResolver={target(st){if(st)return()=>"current"in st?st.current:st},enabled(st=!0){return st},window(st=SUPPORT.isBrowser?window:void 0){return st},eventOptions({passive:st=!0,capture:at=!1}={}){return{passive:st,capture:at}},transform(st){return st}},_excluded$c=["target","eventOptions","window","enabled","transform"];function resolveWith(st={},at){const pt={};for(const[vt,wt]of Object.entries(at))switch(typeof wt){case"function":pt[vt]=wt.call(pt,st[vt],vt,st);break;case"object":pt[vt]=resolveWith(st[vt],wt);break;case"boolean":wt&&(pt[vt]=st[vt]);break}return pt}function parse$1(st,at,pt={}){const vt=st,{target:wt,eventOptions:$t,window:Tt,enabled:Lt,transform:Ft}=vt,Ct=_objectWithoutProperties$2(vt,_excluded$c);if(pt.shared=resolveWith({target:wt,eventOptions:$t,window:Tt,enabled:Lt,transform:Ft},sharedConfigResolver),at){const Ht=ConfigResolverMap.get(at);pt[at]=resolveWith(_objectSpread2$1({shared:pt.shared},Ct),Ht)}else for(const Ht in Ct){const Gt=ConfigResolverMap.get(Ht);Gt&&(pt[Ht]=resolveWith(_objectSpread2$1({shared:pt.shared},Ct[Ht]),Gt))}return pt}class EventStore{constructor(at,pt){_defineProperty$3(this,"_listeners",new Set),this._ctrl=at,this._gestureKey=pt}add(at,pt,vt,wt,$t){const Tt=this._listeners,Lt=toDomEventType(pt,vt),Ft=this._gestureKey?this._ctrl.config[this._gestureKey].eventOptions:{},Ct=_objectSpread2$1(_objectSpread2$1({},Ft),$t);at.addEventListener(Lt,wt,Ct);const Ht=()=>{at.removeEventListener(Lt,wt,Ct),Tt.delete(Ht)};return Tt.add(Ht),Ht}clean(){this._listeners.forEach(at=>at()),this._listeners.clear()}}class TimeoutStore{constructor(){_defineProperty$3(this,"_timeouts",new Map)}add(at,pt,vt=140,...wt){this.remove(at),this._timeouts.set(at,window.setTimeout(pt,vt,...wt))}remove(at){const pt=this._timeouts.get(at);pt&&window.clearTimeout(pt)}clean(){this._timeouts.forEach(at=>void window.clearTimeout(at)),this._timeouts.clear()}}class Controller{constructor(at){_defineProperty$3(this,"gestures",new Set),_defineProperty$3(this,"_targetEventStore",new EventStore(this)),_defineProperty$3(this,"gestureEventStores",{}),_defineProperty$3(this,"gestureTimeoutStores",{}),_defineProperty$3(this,"handlers",{}),_defineProperty$3(this,"config",{}),_defineProperty$3(this,"pointerIds",new Set),_defineProperty$3(this,"touchIds",new Set),_defineProperty$3(this,"state",{shared:{shiftKey:!1,metaKey:!1,ctrlKey:!1,altKey:!1}}),resolveGestures(this,at)}setEventIds(at){if(isTouch(at))return this.touchIds=new Set(touchIds(at)),this.touchIds;if("pointerId"in at)return at.type==="pointerup"||at.type==="pointercancel"?this.pointerIds.delete(at.pointerId):at.type==="pointerdown"&&this.pointerIds.add(at.pointerId),this.pointerIds}applyHandlers(at,pt){this.handlers=at,this.nativeHandlers=pt}applyConfig(at,pt){this.config=parse$1(at,pt,this.config)}clean(){this._targetEventStore.clean();for(const at of this.gestures)this.gestureEventStores[at].clean(),this.gestureTimeoutStores[at].clean()}effect(){return this.config.shared.target&&this.bind(),()=>this._targetEventStore.clean()}bind(...at){const pt=this.config.shared,vt={};let wt;if(!(pt.target&&(wt=pt.target(),!wt))){if(pt.enabled){for(const Tt of this.gestures){const Lt=this.config[Tt],Ft=bindToProps(vt,Lt.eventOptions,!!wt);if(Lt.enabled){const Ct=EngineMap.get(Tt);new Ct(this,at,Tt).bind(Ft)}}const $t=bindToProps(vt,pt.eventOptions,!!wt);for(const Tt in this.nativeHandlers)$t(Tt,"",Lt=>this.nativeHandlers[Tt](_objectSpread2$1(_objectSpread2$1({},this.state.shared),{},{event:Lt,args:at})),void 0,!0)}for(const $t in vt)vt[$t]=chain(...vt[$t]);if(!wt)return vt;for(const $t in vt){const{device:Tt,capture:Lt,passive:Ft}=parseProp($t);this._targetEventStore.add(wt,Tt,"",vt[$t],{capture:Lt,passive:Ft})}}}}function setupGesture(st,at){st.gestures.add(at),st.gestureEventStores[at]=new EventStore(st,at),st.gestureTimeoutStores[at]=new TimeoutStore}function resolveGestures(st,at){at.drag&&setupGesture(st,"drag"),at.wheel&&setupGesture(st,"wheel"),at.scroll&&setupGesture(st,"scroll"),at.move&&setupGesture(st,"move"),at.pinch&&setupGesture(st,"pinch"),at.hover&&setupGesture(st,"hover")}const bindToProps=(st,at,pt)=>(vt,wt,$t,Tt={},Lt=!1)=>{var Ft,Ct;const Ht=(Ft=Tt.capture)!==null&&Ft!==void 0?Ft:at.capture,Gt=(Ct=Tt.passive)!==null&&Ct!==void 0?Ct:at.passive;let jt=Lt?vt:toHandlerProp(vt,wt,Ht);pt&&Gt&&(jt+="Passive"),st[jt]=st[jt]||[],st[jt].push($t)};function useRecognizers(st,at={},pt,vt){const wt=React.useMemo(()=>new Controller(st),[]);if(wt.applyHandlers(st,vt),wt.applyConfig(at,pt),React.useEffect(wt.effect.bind(wt)),React.useEffect(()=>wt.clean.bind(wt),[]),at.target===void 0)return wt.bind.bind(wt)}function useDrag$1(st,at){return registerAction(dragAction),useRecognizers({drag:st},at||{},"drag")}const subscribeWithSelector=st=>(at,pt,vt)=>{const wt=vt.subscribe;return vt.subscribe=(Tt,Lt,Ft)=>{let Ct=Tt;if(Lt){const Ht=(Ft==null?void 0:Ft.equalityFn)||Object.is;let Gt=Tt(vt.getState());Ct=jt=>{const qt=Tt(jt);if(!Ht(Gt,qt)){const Kt=Gt;Lt(Gt=qt,Kt)}},Ft!=null&&Ft.fireImmediately&&Lt(Gt,Gt)}return wt(Ct)},st(at,pt,vt)};function toTrianglesDrawMode(st,at){if(at===TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),st;if(at===TriangleFanDrawMode||at===TriangleStripDrawMode){let pt=st.getIndex();if(pt===null){const Tt=[],Lt=st.getAttribute("position");if(Lt!==void 0){for(let Ft=0;Ft<Lt.count;Ft++)Tt.push(Ft);st.setIndex(Tt),pt=st.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),st}const vt=pt.count-2,wt=[];if(pt)if(at===TriangleFanDrawMode)for(let Tt=1;Tt<=vt;Tt++)wt.push(pt.getX(0)),wt.push(pt.getX(Tt)),wt.push(pt.getX(Tt+1));else for(let Tt=0;Tt<vt;Tt++)Tt%2===0?(wt.push(pt.getX(Tt)),wt.push(pt.getX(Tt+1)),wt.push(pt.getX(Tt+2))):(wt.push(pt.getX(Tt+2)),wt.push(pt.getX(Tt+1)),wt.push(pt.getX(Tt)));wt.length/3!==vt&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const $t=st.clone();return $t.setIndex(wt),$t.clearGroups(),$t}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",at),st}const version$1=parseInt(REVISION.replace(/\D+/g,""));var u8=Uint8Array,u16=Uint16Array,u32=Uint32Array,fleb=new u8([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),fdeb=new u8([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),clim=new u8([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),freb=function(st,at){for(var pt=new u16(31),vt=0;vt<31;++vt)pt[vt]=at+=1<<st[vt-1];for(var wt=new u32(pt[30]),vt=1;vt<30;++vt)for(var $t=pt[vt];$t<pt[vt+1];++$t)wt[$t]=$t-pt[vt]<<5|vt;return[pt,wt]},_a$1=freb(fleb,2),fl$2=_a$1[0],revfl=_a$1[1];fl$2[28]=258,revfl[258]=28;var _b$1=freb(fdeb,0),fd$2=_b$1[0],rev=new u16(32768);for(var i$3=0;i$3<32768;++i$3){var x$2=(i$3&43690)>>>1|(i$3&21845)<<1;x$2=(x$2&52428)>>>2|(x$2&13107)<<2,x$2=(x$2&61680)>>>4|(x$2&3855)<<4,rev[i$3]=((x$2&65280)>>>8|(x$2&255)<<8)>>>1}var hMap=function(st,at,pt){for(var vt=st.length,wt=0,$t=new u16(at);wt<vt;++wt)++$t[st[wt]-1];var Tt=new u16(at);for(wt=0;wt<at;++wt)Tt[wt]=Tt[wt-1]+$t[wt-1]<<1;var Lt;if(pt){Lt=new u16(1<<at);var Ft=15-at;for(wt=0;wt<vt;++wt)if(st[wt])for(var Ct=wt<<4|st[wt],Ht=at-st[wt],Gt=Tt[st[wt]-1]++<<Ht,jt=Gt|(1<<Ht)-1;Gt<=jt;++Gt)Lt[rev[Gt]>>>Ft]=Ct}else for(Lt=new u16(vt),wt=0;wt<vt;++wt)st[wt]&&(Lt[wt]=rev[Tt[st[wt]-1]++]>>>15-st[wt]);return Lt},flt=new u8(288);for(var i$3=0;i$3<144;++i$3)flt[i$3]=8;for(var i$3=144;i$3<256;++i$3)flt[i$3]=9;for(var i$3=256;i$3<280;++i$3)flt[i$3]=7;for(var i$3=280;i$3<288;++i$3)flt[i$3]=8;var fdt=new u8(32);for(var i$3=0;i$3<32;++i$3)fdt[i$3]=5;var flrm=hMap(flt,9,1),fdrm=hMap(fdt,5,1),max$1=function(st){for(var at=st[0],pt=1;pt<st.length;++pt)st[pt]>at&&(at=st[pt]);return at},bits=function(st,at,pt){var vt=at/8|0;return(st[vt]|st[vt+1]<<8)>>(at&7)&pt},bits16=function(st,at){var pt=at/8|0;return(st[pt]|st[pt+1]<<8|st[pt+2]<<16)>>(at&7)},shft=function(st){return(st/8|0)+(st&7&&1)},slc=function(st,at,pt){(pt==null||pt>st.length)&&(pt=st.length);var vt=new(st instanceof u16?u16:st instanceof u32?u32:u8)(pt-at);return vt.set(st.subarray(at,pt)),vt},inflt=function(st,at,pt){var vt=st.length;if(!vt||pt&&!pt.l&&vt<5)return at||new u8(0);var wt=!at||pt,$t=!pt||pt.i;pt||(pt={}),at||(at=new u8(vt*3));var Tt=function(K0){var Ty=at.length;if(K0>Ty){var $y=new u8(Math.max(Ty*2,K0));$y.set(at),at=$y}},Lt=pt.f||0,Ft=pt.p||0,Ct=pt.b||0,Ht=pt.l,Gt=pt.d,jt=pt.m,qt=pt.n,Kt=vt*8;do{if(!Ht){pt.f=Lt=bits(st,Ft,1);var An=bits(st,Ft+1,3);if(Ft+=3,An)if(An==1)Ht=flrm,Gt=fdrm,jt=9,qt=5;else if(An==2){var tr=bits(st,Ft,31)+257,rr=bits(st,Ft+10,15)+4,Hr=tr+bits(st,Ft+5,31)+1;Ft+=14;for(var qr=new u8(Hr),Zr=new u8(19),Bo=0;Bo<rr;++Bo)Zr[clim[Bo]]=bits(st,Ft+Bo*3,7);Ft+=rr*3;for(var Xo=max$1(Zr),Kr=(1<<Xo)-1,ko=hMap(Zr,Xo,1),Bo=0;Bo<Hr;){var f0=ko[bits(st,Ft,Kr)];Ft+=f0&15;var Sn=f0>>>4;if(Sn<16)qr[Bo++]=Sn;else{var x0=0,l0=0;for(Sn==16?(l0=3+bits(st,Ft,3),Ft+=2,x0=qr[Bo-1]):Sn==17?(l0=3+bits(st,Ft,7),Ft+=3):Sn==18&&(l0=11+bits(st,Ft,127),Ft+=7);l0--;)qr[Bo++]=x0}}var T0=qr.subarray(0,tr),t0=qr.subarray(tr);jt=max$1(T0),qt=max$1(t0),Ht=hMap(T0,jt,1),Gt=hMap(t0,qt,1)}else throw"invalid block type";else{var Sn=shft(Ft)+4,wn=st[Sn-4]|st[Sn-3]<<8,In=Sn+wn;if(In>vt){if($t)throw"unexpected EOF";break}wt&&Tt(Ct+wn),at.set(st.subarray(Sn,In),Ct),pt.b=Ct+=wn,pt.p=Ft=In*8;continue}if(Ft>Kt){if($t)throw"unexpected EOF";break}}wt&&Tt(Ct+131072);for(var E0=(1<<jt)-1,n0=(1<<qt)-1,m0=Ft;;m0=Ft){var x0=Ht[bits16(st,Ft)&E0],h0=x0>>>4;if(Ft+=x0&15,Ft>Kt){if($t)throw"unexpected EOF";break}if(!x0)throw"invalid length/literal";if(h0<256)at[Ct++]=h0;else if(h0==256){m0=Ft,Ht=null;break}else{var a0=h0-254;if(h0>264){var Bo=h0-257,P0=fleb[Bo];a0=bits(st,Ft,(1<<P0)-1)+fl$2[Bo],Ft+=P0}var V0=Gt[bits16(st,Ft)&n0],B0=V0>>>4;if(!V0)throw"invalid distance";Ft+=V0&15;var t0=fd$2[B0];if(B0>3){var P0=fdeb[B0];t0+=bits16(st,Ft)&(1<<P0)-1,Ft+=P0}if(Ft>Kt){if($t)throw"unexpected EOF";break}wt&&Tt(Ct+131072);for(var W0=Ct+a0;Ct<W0;Ct+=4)at[Ct]=at[Ct-t0],at[Ct+1]=at[Ct+1-t0],at[Ct+2]=at[Ct+2-t0],at[Ct+3]=at[Ct+3-t0];Ct=W0}}pt.l=Ht,pt.p=m0,pt.b=Ct,Ht&&(Lt=1,pt.m=jt,pt.d=Gt,pt.n=qt)}while(!Lt);return Ct==at.length?at:slc(at,0,Ct)},et=new u8(0),zlv=function(st){if((st[0]&15)!=8||st[0]>>>4>7||(st[0]<<8|st[1])%31)throw"invalid zlib data";if(st[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function unzlibSync(st,at){return inflt((zlv(st),st.subarray(2,-4)),at)}var td$2=typeof TextDecoder<"u"&&new TextDecoder,tds=0;try{td$2.decode(et,{stream:!0}),tds=1}catch{}var __defProp$2=Object.defineProperty,__defNormalProp$1=(st,at,pt)=>at in st?__defProp$2(st,at,{enumerable:!0,configurable:!0,writable:!0,value:pt}):st[at]=pt,__publicField$1=(st,at,pt)=>(__defNormalProp$1(st,typeof at!="symbol"?at+"":at,pt),pt);const SkyShader={uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new Vector3},up:{value:new Vector3(0,1,0)}},vertexShader:`
      uniform vec3 sunPosition;
      uniform float rayleigh;
      uniform float turbidity;
      uniform float mieCoefficient;
      uniform vec3 up;

      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      // constants for atmospheric scattering
      const float e = 2.71828182845904523536028747135266249775724709369995957;
      const float pi = 3.141592653589793238462643383279502884197169;

      // wavelength of used primaries, according to preetham
      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

      // mie stuff
      // K coefficient for the primaries
      const float v = 4.0;
      const vec3 K = vec3( 0.686, 0.678, 0.666 );
      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

      // earth shadow hack
      // cutoffAngle = pi / 1.95;
      const float cutoffAngle = 1.6110731556870734;
      const float steepness = 1.5;
      const float EE = 1000.0;

      float sunIntensity( float zenithAngleCos ) {
        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
      }

      vec3 totalMie( float T ) {
        float c = ( 0.2 * T ) * 10E-18;
        return 0.434 * c * MieConst;
      }

      void main() {

        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        gl_Position.z = gl_Position.w; // set z to camera.far

        vSunDirection = normalize( sunPosition );

        vSunE = sunIntensity( dot( vSunDirection, up ) );

        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

      // extinction (absorbtion + out scattering)
      // rayleigh coefficients
        vBetaR = totalRayleigh * rayleighCoefficient;

      // mie coefficients
        vBetaM = totalMie( turbidity ) * mieCoefficient;

      }
    `,fragmentShader:`
      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      uniform float mieDirectionalG;
      uniform vec3 up;

      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );

      // constants for atmospheric scattering
      const float pi = 3.141592653589793238462643383279502884197169;

      const float n = 1.0003; // refractive index of air
      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

      // optical length at zenith for molecules
      const float rayleighZenithLength = 8.4E3;
      const float mieZenithLength = 1.25E3;
      // 66 arc seconds -> degrees, and the cosine of that
      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

      // 3.0 / ( 16.0 * pi )
      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
      // 1.0 / ( 4.0 * pi )
      const float ONE_OVER_FOURPI = 0.07957747154594767;

      float rayleighPhase( float cosTheta ) {
        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
      }

      float hgPhase( float cosTheta, float g ) {
        float g2 = pow( g, 2.0 );
        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
      }

      void main() {

        vec3 direction = normalize( vWorldPosition - cameraPos );

      // optical length
      // cutoff angle at 90 to avoid singularity in next formula.
        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
        float sR = rayleighZenithLength * inverse;
        float sM = mieZenithLength * inverse;

      // combined extinction factor
        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

      // in scattering
        float cosTheta = dot( direction, vSunDirection );

        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
        vec3 betaRTheta = vBetaR * rPhase;

        float mPhase = hgPhase( cosTheta, mieDirectionalG );
        vec3 betaMTheta = vBetaM * mPhase;

        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

      // nightsky
        float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
        float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
        vec3 L0 = vec3( 0.1 ) * Fex;

      // composition + solar disc
        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

        gl_FragColor = vec4( retColor, 1.0 );

      #include <tonemapping_fragment>
      #include <${version$1>=154?"colorspace_fragment":"encodings_fragment"}>

      }
    `},material=new ShaderMaterial({name:"SkyShader",fragmentShader:SkyShader.fragmentShader,vertexShader:SkyShader.vertexShader,uniforms:UniformsUtils.clone(SkyShader.uniforms),side:BackSide,depthWrite:!1});let Sky$1=class extends Mesh{constructor(){super(new BoxGeometry(1,1,1),material)}};__publicField$1(Sky$1,"SkyShader",SkyShader);__publicField$1(Sky$1,"material",material);const isCubeTexture=st=>st&&st.isCubeTexture;class GroundProjectedEnv extends Mesh{constructor(at,pt){var vt,wt;const $t=isCubeTexture(at),Lt=((wt=$t?(vt=at.image[0])==null?void 0:vt.width:at.image.width)!=null?wt:1024)/4,Ft=Math.floor(Math.log2(Lt)),Ct=Math.pow(2,Ft),Ht=3*Math.max(Ct,16*7),Gt=4*Ct,jt=[$t?"#define ENVMAP_TYPE_CUBE":"",`#define CUBEUV_TEXEL_WIDTH ${1/Ht}`,`#define CUBEUV_TEXEL_HEIGHT ${1/Gt}`,`#define CUBEUV_MAX_MIP ${Ft}.0`],qt=`
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,Kt=jt.join(`
`)+`
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${parseInt(REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>
        }
        `,An={map:{value:at},height:{value:(pt==null?void 0:pt.height)||15},radius:{value:(pt==null?void 0:pt.radius)||100}},Sn=new IcosahedronGeometry(1,16),wn=new ShaderMaterial({uniforms:An,fragmentShader:Kt,vertexShader:qt,side:DoubleSide});super(Sn,wn)}set radius(at){this.material.uniforms.radius.value=at}get radius(){return this.material.uniforms.radius.value}set height(at){this.material.uniforms.height.value=at}get height(){return this.material.uniforms.height.value}}var __defProp$1=Object.defineProperty,__defNormalProp=(st,at,pt)=>at in st?__defProp$1(st,at,{enumerable:!0,configurable:!0,writable:!0,value:pt}):st[at]=pt,__publicField=(st,at,pt)=>(__defNormalProp(st,typeof at!="symbol"?at+"":at,pt),pt);const _ray=new Ray,_plane=new Plane,TILT_LIMIT=Math.cos(70*(Math.PI/180)),moduloWrapAround=(st,at)=>(st%at+at)%at;let OrbitControls$1=class extends EventDispatcher{constructor(at,pt){super(),__publicField(this,"object"),__publicField(this,"domElement"),__publicField(this,"enabled",!0),__publicField(this,"target",new Vector3),__publicField(this,"minDistance",0),__publicField(this,"maxDistance",1/0),__publicField(this,"minZoom",0),__publicField(this,"maxZoom",1/0),__publicField(this,"minPolarAngle",0),__publicField(this,"maxPolarAngle",Math.PI),__publicField(this,"minAzimuthAngle",-1/0),__publicField(this,"maxAzimuthAngle",1/0),__publicField(this,"enableDamping",!1),__publicField(this,"dampingFactor",.05),__publicField(this,"enableZoom",!0),__publicField(this,"zoomSpeed",1),__publicField(this,"enableRotate",!0),__publicField(this,"rotateSpeed",1),__publicField(this,"enablePan",!0),__publicField(this,"panSpeed",1),__publicField(this,"screenSpacePanning",!0),__publicField(this,"keyPanSpeed",7),__publicField(this,"zoomToCursor",!1),__publicField(this,"autoRotate",!1),__publicField(this,"autoRotateSpeed",2),__publicField(this,"reverseOrbit",!1),__publicField(this,"reverseHorizontalOrbit",!1),__publicField(this,"reverseVerticalOrbit",!1),__publicField(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),__publicField(this,"mouseButtons",{LEFT:MOUSE.ROTATE,MIDDLE:MOUSE.DOLLY,RIGHT:MOUSE.PAN}),__publicField(this,"touches",{ONE:TOUCH.ROTATE,TWO:TOUCH.DOLLY_PAN}),__publicField(this,"target0"),__publicField(this,"position0"),__publicField(this,"zoom0"),__publicField(this,"_domElementKeyEvents",null),__publicField(this,"getPolarAngle"),__publicField(this,"getAzimuthalAngle"),__publicField(this,"setPolarAngle"),__publicField(this,"setAzimuthalAngle"),__publicField(this,"getDistance"),__publicField(this,"listenToKeyEvents"),__publicField(this,"stopListenToKeyEvents"),__publicField(this,"saveState"),__publicField(this,"reset"),__publicField(this,"update"),__publicField(this,"connect"),__publicField(this,"dispose"),this.object=at,this.domElement=pt,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>Ht.phi,this.getAzimuthalAngle=()=>Ht.theta,this.setPolarAngle=C0=>{let U0=moduloWrapAround(C0,2*Math.PI),xy=Ht.phi;xy<0&&(xy+=2*Math.PI),U0<0&&(U0+=2*Math.PI);let o0=Math.abs(U0-xy);2*Math.PI-o0<o0&&(U0<xy?U0+=2*Math.PI:xy+=2*Math.PI),Gt.phi=U0-xy,vt.update()},this.setAzimuthalAngle=C0=>{let U0=moduloWrapAround(C0,2*Math.PI),xy=Ht.theta;xy<0&&(xy+=2*Math.PI),U0<0&&(U0+=2*Math.PI);let o0=Math.abs(U0-xy);2*Math.PI-o0<o0&&(U0<xy?U0+=2*Math.PI:xy+=2*Math.PI),Gt.theta=U0-xy,vt.update()},this.getDistance=()=>vt.object.position.distanceTo(vt.target),this.listenToKeyEvents=C0=>{C0.addEventListener("keydown",Xy),this._domElementKeyEvents=C0},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",Xy),this._domElementKeyEvents=null},this.saveState=()=>{vt.target0.copy(vt.target),vt.position0.copy(vt.object.position),vt.zoom0=vt.object.zoom},this.reset=()=>{vt.target.copy(vt.target0),vt.object.position.copy(vt.position0),vt.object.zoom=vt.zoom0,vt.object.updateProjectionMatrix(),vt.dispatchEvent(wt),vt.update(),Ft=Lt.NONE},this.update=(()=>{const C0=new Vector3,U0=new Vector3(0,1,0),xy=new Quaternion().setFromUnitVectors(at.up,U0),o0=xy.clone().invert(),v0=new Vector3,i0=new Quaternion,k0=2*Math.PI;return function(){const ty=vt.object.position;xy.setFromUnitVectors(at.up,U0),o0.copy(xy).invert(),C0.copy(ty).sub(vt.target),C0.applyQuaternion(xy),Ht.setFromVector3(C0),vt.autoRotate&&Ft===Lt.NONE&&l0(f0()),vt.enableDamping?(Ht.theta+=Gt.theta*vt.dampingFactor,Ht.phi+=Gt.phi*vt.dampingFactor):(Ht.theta+=Gt.theta,Ht.phi+=Gt.phi);let my=vt.minAzimuthAngle,ev=vt.maxAzimuthAngle;isFinite(my)&&isFinite(ev)&&(my<-Math.PI?my+=k0:my>Math.PI&&(my-=k0),ev<-Math.PI?ev+=k0:ev>Math.PI&&(ev-=k0),my<=ev?Ht.theta=Math.max(my,Math.min(ev,Ht.theta)):Ht.theta=Ht.theta>(my+ev)/2?Math.max(my,Ht.theta):Math.min(ev,Ht.theta)),Ht.phi=Math.max(vt.minPolarAngle,Math.min(vt.maxPolarAngle,Ht.phi)),Ht.makeSafe(),vt.enableDamping===!0?vt.target.addScaledVector(qt,vt.dampingFactor):vt.target.add(qt),vt.zoomToCursor&&Xo||vt.object.isOrthographicCamera?Ht.radius=P0(Ht.radius):Ht.radius=P0(Ht.radius*jt),C0.setFromSpherical(Ht),C0.applyQuaternion(o0),ty.copy(vt.target).add(C0),vt.object.matrixAutoUpdate||vt.object.updateMatrix(),vt.object.lookAt(vt.target),vt.enableDamping===!0?(Gt.theta*=1-vt.dampingFactor,Gt.phi*=1-vt.dampingFactor,qt.multiplyScalar(1-vt.dampingFactor)):(Gt.set(0,0,0),qt.set(0,0,0));let vv=!1;if(vt.zoomToCursor&&Xo){let Tv=null;if(vt.object instanceof PerspectiveCamera&&vt.object.isPerspectiveCamera){const Rv=C0.length();Tv=P0(Rv*jt);const Lv=Rv-Tv;vt.object.position.addScaledVector(Zr,Lv),vt.object.updateMatrixWorld()}else if(vt.object.isOrthographicCamera){const Rv=new Vector3(Bo.x,Bo.y,0);Rv.unproject(vt.object),vt.object.zoom=Math.max(vt.minZoom,Math.min(vt.maxZoom,vt.object.zoom/jt)),vt.object.updateProjectionMatrix(),vv=!0;const Lv=new Vector3(Bo.x,Bo.y,0);Lv.unproject(vt.object),vt.object.position.sub(Lv).add(Rv),vt.object.updateMatrixWorld(),Tv=C0.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),vt.zoomToCursor=!1;Tv!==null&&(vt.screenSpacePanning?vt.target.set(0,0,-1).transformDirection(vt.object.matrix).multiplyScalar(Tv).add(vt.object.position):(_ray.origin.copy(vt.object.position),_ray.direction.set(0,0,-1).transformDirection(vt.object.matrix),Math.abs(vt.object.up.dot(_ray.direction))<TILT_LIMIT?at.lookAt(vt.target):(_plane.setFromNormalAndCoplanarPoint(vt.object.up,vt.target),_ray.intersectPlane(_plane,vt.target))))}else vt.object instanceof OrthographicCamera&&vt.object.isOrthographicCamera&&(vv=jt!==1,vv&&(vt.object.zoom=Math.max(vt.minZoom,Math.min(vt.maxZoom,vt.object.zoom/jt)),vt.object.updateProjectionMatrix()));return jt=1,Xo=!1,vv||v0.distanceToSquared(vt.object.position)>Ct||8*(1-i0.dot(vt.object.quaternion))>Ct?(vt.dispatchEvent(wt),v0.copy(vt.object.position),i0.copy(vt.object.quaternion),vv=!1,!0):!1}})(),this.connect=C0=>{C0===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),vt.domElement=C0,vt.domElement.style.touchAction="none",vt.domElement.addEventListener("contextmenu",Py),vt.domElement.addEventListener("pointerdown",y0),vt.domElement.addEventListener("pointercancel",G0),vt.domElement.addEventListener("wheel",Vy)},this.dispose=()=>{var C0,U0,xy,o0,v0,i0;vt.domElement&&(vt.domElement.style.touchAction="auto"),(C0=vt.domElement)==null||C0.removeEventListener("contextmenu",Py),(U0=vt.domElement)==null||U0.removeEventListener("pointerdown",y0),(xy=vt.domElement)==null||xy.removeEventListener("pointercancel",G0),(o0=vt.domElement)==null||o0.removeEventListener("wheel",Vy),(v0=vt.domElement)==null||v0.ownerDocument.removeEventListener("pointermove",r0),(i0=vt.domElement)==null||i0.ownerDocument.removeEventListener("pointerup",M0),vt._domElementKeyEvents!==null&&vt._domElementKeyEvents.removeEventListener("keydown",Xy)};const vt=this,wt={type:"change"},$t={type:"start"},Tt={type:"end"},Lt={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let Ft=Lt.NONE;const Ct=1e-6,Ht=new Spherical,Gt=new Spherical;let jt=1;const qt=new Vector3,Kt=new Vector2,An=new Vector2,Sn=new Vector2,wn=new Vector2,In=new Vector2,tr=new Vector2,rr=new Vector2,Hr=new Vector2,qr=new Vector2,Zr=new Vector3,Bo=new Vector2;let Xo=!1;const Kr=[],ko={};function f0(){return 2*Math.PI/60/60*vt.autoRotateSpeed}function x0(){return Math.pow(.95,vt.zoomSpeed)}function l0(C0){vt.reverseOrbit||vt.reverseHorizontalOrbit?Gt.theta+=C0:Gt.theta-=C0}function T0(C0){vt.reverseOrbit||vt.reverseVerticalOrbit?Gt.phi+=C0:Gt.phi-=C0}const t0=(()=>{const C0=new Vector3;return function(xy,o0){C0.setFromMatrixColumn(o0,0),C0.multiplyScalar(-xy),qt.add(C0)}})(),E0=(()=>{const C0=new Vector3;return function(xy,o0){vt.screenSpacePanning===!0?C0.setFromMatrixColumn(o0,1):(C0.setFromMatrixColumn(o0,0),C0.crossVectors(vt.object.up,C0)),C0.multiplyScalar(xy),qt.add(C0)}})(),n0=(()=>{const C0=new Vector3;return function(xy,o0){const v0=vt.domElement;if(v0&&vt.object instanceof PerspectiveCamera&&vt.object.isPerspectiveCamera){const i0=vt.object.position;C0.copy(i0).sub(vt.target);let k0=C0.length();k0*=Math.tan(vt.object.fov/2*Math.PI/180),t0(2*xy*k0/v0.clientHeight,vt.object.matrix),E0(2*o0*k0/v0.clientHeight,vt.object.matrix)}else v0&&vt.object instanceof OrthographicCamera&&vt.object.isOrthographicCamera?(t0(xy*(vt.object.right-vt.object.left)/vt.object.zoom/v0.clientWidth,vt.object.matrix),E0(o0*(vt.object.top-vt.object.bottom)/vt.object.zoom/v0.clientHeight,vt.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),vt.enablePan=!1)}})();function m0(C0){vt.object instanceof PerspectiveCamera&&vt.object.isPerspectiveCamera||vt.object instanceof OrthographicCamera&&vt.object.isOrthographicCamera?jt/=C0:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),vt.enableZoom=!1)}function h0(C0){vt.object instanceof PerspectiveCamera&&vt.object.isPerspectiveCamera||vt.object instanceof OrthographicCamera&&vt.object.isOrthographicCamera?jt*=C0:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),vt.enableZoom=!1)}function a0(C0){if(!vt.zoomToCursor||!vt.domElement)return;Xo=!0;const U0=vt.domElement.getBoundingClientRect(),xy=C0.clientX-U0.left,o0=C0.clientY-U0.top,v0=U0.width,i0=U0.height;Bo.x=xy/v0*2-1,Bo.y=-(o0/i0)*2+1,Zr.set(Bo.x,Bo.y,1).unproject(vt.object).sub(vt.object.position).normalize()}function P0(C0){return Math.max(vt.minDistance,Math.min(vt.maxDistance,C0))}function V0(C0){Kt.set(C0.clientX,C0.clientY)}function B0(C0){a0(C0),rr.set(C0.clientX,C0.clientY)}function W0(C0){wn.set(C0.clientX,C0.clientY)}function K0(C0){An.set(C0.clientX,C0.clientY),Sn.subVectors(An,Kt).multiplyScalar(vt.rotateSpeed);const U0=vt.domElement;U0&&(l0(2*Math.PI*Sn.x/U0.clientHeight),T0(2*Math.PI*Sn.y/U0.clientHeight)),Kt.copy(An),vt.update()}function Ty(C0){Hr.set(C0.clientX,C0.clientY),qr.subVectors(Hr,rr),qr.y>0?m0(x0()):qr.y<0&&h0(x0()),rr.copy(Hr),vt.update()}function $y(C0){In.set(C0.clientX,C0.clientY),tr.subVectors(In,wn).multiplyScalar(vt.panSpeed),n0(tr.x,tr.y),wn.copy(In),vt.update()}function My(C0){a0(C0),C0.deltaY<0?h0(x0()):C0.deltaY>0&&m0(x0()),vt.update()}function Wy(C0){let U0=!1;switch(C0.code){case vt.keys.UP:n0(0,vt.keyPanSpeed),U0=!0;break;case vt.keys.BOTTOM:n0(0,-vt.keyPanSpeed),U0=!0;break;case vt.keys.LEFT:n0(vt.keyPanSpeed,0),U0=!0;break;case vt.keys.RIGHT:n0(-vt.keyPanSpeed,0),U0=!0;break}U0&&(C0.preventDefault(),vt.update())}function Ey(){if(Kr.length==1)Kt.set(Kr[0].pageX,Kr[0].pageY);else{const C0=.5*(Kr[0].pageX+Kr[1].pageX),U0=.5*(Kr[0].pageY+Kr[1].pageY);Kt.set(C0,U0)}}function _0(){if(Kr.length==1)wn.set(Kr[0].pageX,Kr[0].pageY);else{const C0=.5*(Kr[0].pageX+Kr[1].pageX),U0=.5*(Kr[0].pageY+Kr[1].pageY);wn.set(C0,U0)}}function ay(){const C0=Kr[0].pageX-Kr[1].pageX,U0=Kr[0].pageY-Kr[1].pageY,xy=Math.sqrt(C0*C0+U0*U0);rr.set(0,xy)}function J0(){vt.enableZoom&&ay(),vt.enablePan&&_0()}function yy(){vt.enableZoom&&ay(),vt.enableRotate&&Ey()}function uy(C0){if(Kr.length==1)An.set(C0.pageX,C0.pageY);else{const xy=cy(C0),o0=.5*(C0.pageX+xy.x),v0=.5*(C0.pageY+xy.y);An.set(o0,v0)}Sn.subVectors(An,Kt).multiplyScalar(vt.rotateSpeed);const U0=vt.domElement;U0&&(l0(2*Math.PI*Sn.x/U0.clientHeight),T0(2*Math.PI*Sn.y/U0.clientHeight)),Kt.copy(An)}function Dy(C0){if(Kr.length==1)In.set(C0.pageX,C0.pageY);else{const U0=cy(C0),xy=.5*(C0.pageX+U0.x),o0=.5*(C0.pageY+U0.y);In.set(xy,o0)}tr.subVectors(In,wn).multiplyScalar(vt.panSpeed),n0(tr.x,tr.y),wn.copy(In)}function Fy(C0){const U0=cy(C0),xy=C0.pageX-U0.x,o0=C0.pageY-U0.y,v0=Math.sqrt(xy*xy+o0*o0);Hr.set(0,v0),qr.set(0,Math.pow(Hr.y/rr.y,vt.zoomSpeed)),m0(qr.y),rr.copy(Hr)}function qy(C0){vt.enableZoom&&Fy(C0),vt.enablePan&&Dy(C0)}function rv(C0){vt.enableZoom&&Fy(C0),vt.enableRotate&&uy(C0)}function y0(C0){var U0,xy;vt.enabled!==!1&&(Kr.length===0&&((U0=vt.domElement)==null||U0.ownerDocument.addEventListener("pointermove",r0),(xy=vt.domElement)==null||xy.ownerDocument.addEventListener("pointerup",M0)),Sy(C0),C0.pointerType==="touch"?hy(C0):sy(C0))}function r0(C0){vt.enabled!==!1&&(C0.pointerType==="touch"?Ly(C0):dy(C0))}function M0(C0){var U0,xy,o0;Ev(C0),Kr.length===0&&((U0=vt.domElement)==null||U0.releasePointerCapture(C0.pointerId),(xy=vt.domElement)==null||xy.ownerDocument.removeEventListener("pointermove",r0),(o0=vt.domElement)==null||o0.ownerDocument.removeEventListener("pointerup",M0)),vt.dispatchEvent(Tt),Ft=Lt.NONE}function G0(C0){Ev(C0)}function sy(C0){let U0;switch(C0.button){case 0:U0=vt.mouseButtons.LEFT;break;case 1:U0=vt.mouseButtons.MIDDLE;break;case 2:U0=vt.mouseButtons.RIGHT;break;default:U0=-1}switch(U0){case MOUSE.DOLLY:if(vt.enableZoom===!1)return;B0(C0),Ft=Lt.DOLLY;break;case MOUSE.ROTATE:if(C0.ctrlKey||C0.metaKey||C0.shiftKey){if(vt.enablePan===!1)return;W0(C0),Ft=Lt.PAN}else{if(vt.enableRotate===!1)return;V0(C0),Ft=Lt.ROTATE}break;case MOUSE.PAN:if(C0.ctrlKey||C0.metaKey||C0.shiftKey){if(vt.enableRotate===!1)return;V0(C0),Ft=Lt.ROTATE}else{if(vt.enablePan===!1)return;W0(C0),Ft=Lt.PAN}break;default:Ft=Lt.NONE}Ft!==Lt.NONE&&vt.dispatchEvent($t)}function dy(C0){if(vt.enabled!==!1)switch(Ft){case Lt.ROTATE:if(vt.enableRotate===!1)return;K0(C0);break;case Lt.DOLLY:if(vt.enableZoom===!1)return;Ty(C0);break;case Lt.PAN:if(vt.enablePan===!1)return;$y(C0);break}}function Vy(C0){vt.enabled===!1||vt.enableZoom===!1||Ft!==Lt.NONE&&Ft!==Lt.ROTATE||(C0.preventDefault(),vt.dispatchEvent($t),My(C0),vt.dispatchEvent(Tt))}function Xy(C0){vt.enabled===!1||vt.enablePan===!1||Wy(C0)}function hy(C0){switch(Qy(C0),Kr.length){case 1:switch(vt.touches.ONE){case TOUCH.ROTATE:if(vt.enableRotate===!1)return;Ey(),Ft=Lt.TOUCH_ROTATE;break;case TOUCH.PAN:if(vt.enablePan===!1)return;_0(),Ft=Lt.TOUCH_PAN;break;default:Ft=Lt.NONE}break;case 2:switch(vt.touches.TWO){case TOUCH.DOLLY_PAN:if(vt.enableZoom===!1&&vt.enablePan===!1)return;J0(),Ft=Lt.TOUCH_DOLLY_PAN;break;case TOUCH.DOLLY_ROTATE:if(vt.enableZoom===!1&&vt.enableRotate===!1)return;yy(),Ft=Lt.TOUCH_DOLLY_ROTATE;break;default:Ft=Lt.NONE}break;default:Ft=Lt.NONE}Ft!==Lt.NONE&&vt.dispatchEvent($t)}function Ly(C0){switch(Qy(C0),Ft){case Lt.TOUCH_ROTATE:if(vt.enableRotate===!1)return;uy(C0),vt.update();break;case Lt.TOUCH_PAN:if(vt.enablePan===!1)return;Dy(C0),vt.update();break;case Lt.TOUCH_DOLLY_PAN:if(vt.enableZoom===!1&&vt.enablePan===!1)return;qy(C0),vt.update();break;case Lt.TOUCH_DOLLY_ROTATE:if(vt.enableZoom===!1&&vt.enableRotate===!1)return;rv(C0),vt.update();break;default:Ft=Lt.NONE}}function Py(C0){vt.enabled!==!1&&C0.preventDefault()}function Sy(C0){Kr.push(C0)}function Ev(C0){delete ko[C0.pointerId];for(let U0=0;U0<Kr.length;U0++)if(Kr[U0].pointerId==C0.pointerId){Kr.splice(U0,1);return}}function Qy(C0){let U0=ko[C0.pointerId];U0===void 0&&(U0=new Vector2,ko[C0.pointerId]=U0),U0.set(C0.pageX,C0.pageY)}function cy(C0){const U0=C0.pointerId===Kr[0].pointerId?Kr[1]:Kr[0];return ko[U0.pointerId]}pt!==void 0&&this.connect(pt),this.update()}};const SRGBColorSpace="srgb",LinearSRGBColorSpace="srgb-linear",sRGBEncoding$1=3001,LinearEncoding$1=3e3;class GLTFLoader extends Loader{constructor(at){super(at),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(pt){return new GLTFMaterialsClearcoatExtension(pt)}),this.register(function(pt){return new GLTFMaterialsDispersionExtension(pt)}),this.register(function(pt){return new GLTFTextureBasisUExtension(pt)}),this.register(function(pt){return new GLTFTextureWebPExtension(pt)}),this.register(function(pt){return new GLTFTextureAVIFExtension(pt)}),this.register(function(pt){return new GLTFMaterialsSheenExtension(pt)}),this.register(function(pt){return new GLTFMaterialsTransmissionExtension(pt)}),this.register(function(pt){return new GLTFMaterialsVolumeExtension(pt)}),this.register(function(pt){return new GLTFMaterialsIorExtension(pt)}),this.register(function(pt){return new GLTFMaterialsEmissiveStrengthExtension(pt)}),this.register(function(pt){return new GLTFMaterialsSpecularExtension(pt)}),this.register(function(pt){return new GLTFMaterialsIridescenceExtension(pt)}),this.register(function(pt){return new GLTFMaterialsAnisotropyExtension(pt)}),this.register(function(pt){return new GLTFMaterialsBumpExtension(pt)}),this.register(function(pt){return new GLTFLightsExtension(pt)}),this.register(function(pt){return new GLTFMeshoptCompression(pt)}),this.register(function(pt){return new GLTFMeshGpuInstancing(pt)})}load(at,pt,vt,wt){const $t=this;let Tt;if(this.resourcePath!=="")Tt=this.resourcePath;else if(this.path!==""){const Ct=LoaderUtils.extractUrlBase(at);Tt=LoaderUtils.resolveURL(Ct,this.path)}else Tt=LoaderUtils.extractUrlBase(at);this.manager.itemStart(at);const Lt=function(Ct){wt?wt(Ct):console.error(Ct),$t.manager.itemError(at),$t.manager.itemEnd(at)},Ft=new FileLoader(this.manager);Ft.setPath(this.path),Ft.setResponseType("arraybuffer"),Ft.setRequestHeader(this.requestHeader),Ft.setWithCredentials(this.withCredentials),Ft.load(at,function(Ct){try{$t.parse(Ct,Tt,function(Ht){pt(Ht),$t.manager.itemEnd(at)},Lt)}catch(Ht){Lt(Ht)}},vt,Lt)}setDRACOLoader(at){return this.dracoLoader=at,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(at){return this.ktx2Loader=at,this}setMeshoptDecoder(at){return this.meshoptDecoder=at,this}register(at){return this.pluginCallbacks.indexOf(at)===-1&&this.pluginCallbacks.push(at),this}unregister(at){return this.pluginCallbacks.indexOf(at)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(at),1),this}parse(at,pt,vt,wt){let $t;const Tt={},Lt={};if(typeof at=="string")$t=JSON.parse(at);else if(at instanceof ArrayBuffer)if(LoaderUtils.decodeText(new Uint8Array(at.slice(0,4)))===BINARY_EXTENSION_HEADER_MAGIC){try{Tt[EXTENSIONS.KHR_BINARY_GLTF]=new GLTFBinaryExtension(at)}catch(Ht){wt&&wt(Ht);return}$t=JSON.parse(Tt[EXTENSIONS.KHR_BINARY_GLTF].content)}else $t=JSON.parse(LoaderUtils.decodeText(new Uint8Array(at)));else $t=at;if($t.asset===void 0||$t.asset.version[0]<2){wt&&wt(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const Ft=new GLTFParser($t,{path:pt||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});Ft.fileLoader.setRequestHeader(this.requestHeader);for(let Ct=0;Ct<this.pluginCallbacks.length;Ct++){const Ht=this.pluginCallbacks[Ct](Ft);Ht.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),Lt[Ht.name]=Ht,Tt[Ht.name]=!0}if($t.extensionsUsed)for(let Ct=0;Ct<$t.extensionsUsed.length;++Ct){const Ht=$t.extensionsUsed[Ct],Gt=$t.extensionsRequired||[];switch(Ht){case EXTENSIONS.KHR_MATERIALS_UNLIT:Tt[Ht]=new GLTFMaterialsUnlitExtension;break;case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:Tt[Ht]=new GLTFDracoMeshCompressionExtension($t,this.dracoLoader);break;case EXTENSIONS.KHR_TEXTURE_TRANSFORM:Tt[Ht]=new GLTFTextureTransformExtension;break;case EXTENSIONS.KHR_MESH_QUANTIZATION:Tt[Ht]=new GLTFMeshQuantizationExtension;break;default:Gt.indexOf(Ht)>=0&&Lt[Ht]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+Ht+'".')}}Ft.setExtensions(Tt),Ft.setPlugins(Lt),Ft.parse(vt,wt)}parseAsync(at,pt){const vt=this;return new Promise(function(wt,$t){vt.parse(at,pt,wt,$t)})}}function GLTFRegistry(){let st={};return{get:function(at){return st[at]},add:function(at,pt){st[at]=pt},remove:function(at){delete st[at]},removeAll:function(){st={}}}}const EXTENSIONS={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class GLTFLightsExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const at=this.parser,pt=this.parser.json.nodes||[];for(let vt=0,wt=pt.length;vt<wt;vt++){const $t=pt[vt];$t.extensions&&$t.extensions[this.name]&&$t.extensions[this.name].light!==void 0&&at._addNodeRef(this.cache,$t.extensions[this.name].light)}}_loadLight(at){const pt=this.parser,vt="light:"+at;let wt=pt.cache.get(vt);if(wt)return wt;const $t=pt.json,Ft=(($t.extensions&&$t.extensions[this.name]||{}).lights||[])[at];let Ct;const Ht=new Color$1(16777215);Ft.color!==void 0&&Ht.setRGB(Ft.color[0],Ft.color[1],Ft.color[2],LinearSRGBColorSpace);const Gt=Ft.range!==void 0?Ft.range:0;switch(Ft.type){case"directional":Ct=new DirectionalLight(Ht),Ct.target.position.set(0,0,-1),Ct.add(Ct.target);break;case"point":Ct=new PointLight(Ht),Ct.distance=Gt;break;case"spot":Ct=new SpotLight(Ht),Ct.distance=Gt,Ft.spot=Ft.spot||{},Ft.spot.innerConeAngle=Ft.spot.innerConeAngle!==void 0?Ft.spot.innerConeAngle:0,Ft.spot.outerConeAngle=Ft.spot.outerConeAngle!==void 0?Ft.spot.outerConeAngle:Math.PI/4,Ct.angle=Ft.spot.outerConeAngle,Ct.penumbra=1-Ft.spot.innerConeAngle/Ft.spot.outerConeAngle,Ct.target.position.set(0,0,-1),Ct.add(Ct.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+Ft.type)}return Ct.position.set(0,0,0),Ct.decay=2,assignExtrasToUserData(Ct,Ft),Ft.intensity!==void 0&&(Ct.intensity=Ft.intensity),Ct.name=pt.createUniqueName(Ft.name||"light_"+at),wt=Promise.resolve(Ct),pt.cache.add(vt,wt),wt}getDependency(at,pt){if(at==="light")return this._loadLight(pt)}createNodeAttachment(at){const pt=this,vt=this.parser,$t=vt.json.nodes[at],Lt=($t.extensions&&$t.extensions[this.name]||{}).light;return Lt===void 0?null:this._loadLight(Lt).then(function(Ft){return vt._getNodeRef(pt.cache,Lt,Ft)})}}class GLTFMaterialsUnlitExtension{constructor(){this.name=EXTENSIONS.KHR_MATERIALS_UNLIT}getMaterialType(){return MeshBasicMaterial}extendParams(at,pt,vt){const wt=[];at.color=new Color$1(1,1,1),at.opacity=1;const $t=pt.pbrMetallicRoughness;if($t){if(Array.isArray($t.baseColorFactor)){const Tt=$t.baseColorFactor;at.color.setRGB(Tt[0],Tt[1],Tt[2],LinearSRGBColorSpace),at.opacity=Tt[3]}$t.baseColorTexture!==void 0&&wt.push(vt.assignTexture(at,"map",$t.baseColorTexture,SRGBColorSpace))}return Promise.all(wt)}}class GLTFMaterialsEmissiveStrengthExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(at,pt){const wt=this.parser.json.materials[at];if(!wt.extensions||!wt.extensions[this.name])return Promise.resolve();const $t=wt.extensions[this.name].emissiveStrength;return $t!==void 0&&(pt.emissiveIntensity=$t),Promise.resolve()}}class GLTFMaterialsClearcoatExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.KHR_MATERIALS_CLEARCOAT}getMaterialType(at){const vt=this.parser.json.materials[at];return!vt.extensions||!vt.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(at,pt){const vt=this.parser,wt=vt.json.materials[at];if(!wt.extensions||!wt.extensions[this.name])return Promise.resolve();const $t=[],Tt=wt.extensions[this.name];if(Tt.clearcoatFactor!==void 0&&(pt.clearcoat=Tt.clearcoatFactor),Tt.clearcoatTexture!==void 0&&$t.push(vt.assignTexture(pt,"clearcoatMap",Tt.clearcoatTexture)),Tt.clearcoatRoughnessFactor!==void 0&&(pt.clearcoatRoughness=Tt.clearcoatRoughnessFactor),Tt.clearcoatRoughnessTexture!==void 0&&$t.push(vt.assignTexture(pt,"clearcoatRoughnessMap",Tt.clearcoatRoughnessTexture)),Tt.clearcoatNormalTexture!==void 0&&($t.push(vt.assignTexture(pt,"clearcoatNormalMap",Tt.clearcoatNormalTexture)),Tt.clearcoatNormalTexture.scale!==void 0)){const Lt=Tt.clearcoatNormalTexture.scale;pt.clearcoatNormalScale=new Vector2(Lt,Lt)}return Promise.all($t)}}class GLTFMaterialsDispersionExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.KHR_MATERIALS_DISPERSION}getMaterialType(at){const vt=this.parser.json.materials[at];return!vt.extensions||!vt.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(at,pt){const wt=this.parser.json.materials[at];if(!wt.extensions||!wt.extensions[this.name])return Promise.resolve();const $t=wt.extensions[this.name];return pt.dispersion=$t.dispersion!==void 0?$t.dispersion:0,Promise.resolve()}}class GLTFMaterialsIridescenceExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.KHR_MATERIALS_IRIDESCENCE}getMaterialType(at){const vt=this.parser.json.materials[at];return!vt.extensions||!vt.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(at,pt){const vt=this.parser,wt=vt.json.materials[at];if(!wt.extensions||!wt.extensions[this.name])return Promise.resolve();const $t=[],Tt=wt.extensions[this.name];return Tt.iridescenceFactor!==void 0&&(pt.iridescence=Tt.iridescenceFactor),Tt.iridescenceTexture!==void 0&&$t.push(vt.assignTexture(pt,"iridescenceMap",Tt.iridescenceTexture)),Tt.iridescenceIor!==void 0&&(pt.iridescenceIOR=Tt.iridescenceIor),pt.iridescenceThicknessRange===void 0&&(pt.iridescenceThicknessRange=[100,400]),Tt.iridescenceThicknessMinimum!==void 0&&(pt.iridescenceThicknessRange[0]=Tt.iridescenceThicknessMinimum),Tt.iridescenceThicknessMaximum!==void 0&&(pt.iridescenceThicknessRange[1]=Tt.iridescenceThicknessMaximum),Tt.iridescenceThicknessTexture!==void 0&&$t.push(vt.assignTexture(pt,"iridescenceThicknessMap",Tt.iridescenceThicknessTexture)),Promise.all($t)}}class GLTFMaterialsSheenExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.KHR_MATERIALS_SHEEN}getMaterialType(at){const vt=this.parser.json.materials[at];return!vt.extensions||!vt.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(at,pt){const vt=this.parser,wt=vt.json.materials[at];if(!wt.extensions||!wt.extensions[this.name])return Promise.resolve();const $t=[];pt.sheenColor=new Color$1(0,0,0),pt.sheenRoughness=0,pt.sheen=1;const Tt=wt.extensions[this.name];if(Tt.sheenColorFactor!==void 0){const Lt=Tt.sheenColorFactor;pt.sheenColor.setRGB(Lt[0],Lt[1],Lt[2],LinearSRGBColorSpace)}return Tt.sheenRoughnessFactor!==void 0&&(pt.sheenRoughness=Tt.sheenRoughnessFactor),Tt.sheenColorTexture!==void 0&&$t.push(vt.assignTexture(pt,"sheenColorMap",Tt.sheenColorTexture,SRGBColorSpace)),Tt.sheenRoughnessTexture!==void 0&&$t.push(vt.assignTexture(pt,"sheenRoughnessMap",Tt.sheenRoughnessTexture)),Promise.all($t)}}class GLTFMaterialsTransmissionExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.KHR_MATERIALS_TRANSMISSION}getMaterialType(at){const vt=this.parser.json.materials[at];return!vt.extensions||!vt.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(at,pt){const vt=this.parser,wt=vt.json.materials[at];if(!wt.extensions||!wt.extensions[this.name])return Promise.resolve();const $t=[],Tt=wt.extensions[this.name];return Tt.transmissionFactor!==void 0&&(pt.transmission=Tt.transmissionFactor),Tt.transmissionTexture!==void 0&&$t.push(vt.assignTexture(pt,"transmissionMap",Tt.transmissionTexture)),Promise.all($t)}}class GLTFMaterialsVolumeExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.KHR_MATERIALS_VOLUME}getMaterialType(at){const vt=this.parser.json.materials[at];return!vt.extensions||!vt.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(at,pt){const vt=this.parser,wt=vt.json.materials[at];if(!wt.extensions||!wt.extensions[this.name])return Promise.resolve();const $t=[],Tt=wt.extensions[this.name];pt.thickness=Tt.thicknessFactor!==void 0?Tt.thicknessFactor:0,Tt.thicknessTexture!==void 0&&$t.push(vt.assignTexture(pt,"thicknessMap",Tt.thicknessTexture)),pt.attenuationDistance=Tt.attenuationDistance||1/0;const Lt=Tt.attenuationColor||[1,1,1];return pt.attenuationColor=new Color$1().setRGB(Lt[0],Lt[1],Lt[2],LinearSRGBColorSpace),Promise.all($t)}}class GLTFMaterialsIorExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.KHR_MATERIALS_IOR}getMaterialType(at){const vt=this.parser.json.materials[at];return!vt.extensions||!vt.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(at,pt){const wt=this.parser.json.materials[at];if(!wt.extensions||!wt.extensions[this.name])return Promise.resolve();const $t=wt.extensions[this.name];return pt.ior=$t.ior!==void 0?$t.ior:1.5,Promise.resolve()}}class GLTFMaterialsSpecularExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.KHR_MATERIALS_SPECULAR}getMaterialType(at){const vt=this.parser.json.materials[at];return!vt.extensions||!vt.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(at,pt){const vt=this.parser,wt=vt.json.materials[at];if(!wt.extensions||!wt.extensions[this.name])return Promise.resolve();const $t=[],Tt=wt.extensions[this.name];pt.specularIntensity=Tt.specularFactor!==void 0?Tt.specularFactor:1,Tt.specularTexture!==void 0&&$t.push(vt.assignTexture(pt,"specularIntensityMap",Tt.specularTexture));const Lt=Tt.specularColorFactor||[1,1,1];return pt.specularColor=new Color$1().setRGB(Lt[0],Lt[1],Lt[2],LinearSRGBColorSpace),Tt.specularColorTexture!==void 0&&$t.push(vt.assignTexture(pt,"specularColorMap",Tt.specularColorTexture,SRGBColorSpace)),Promise.all($t)}}class GLTFMaterialsBumpExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.EXT_MATERIALS_BUMP}getMaterialType(at){const vt=this.parser.json.materials[at];return!vt.extensions||!vt.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(at,pt){const vt=this.parser,wt=vt.json.materials[at];if(!wt.extensions||!wt.extensions[this.name])return Promise.resolve();const $t=[],Tt=wt.extensions[this.name];return pt.bumpScale=Tt.bumpFactor!==void 0?Tt.bumpFactor:1,Tt.bumpTexture!==void 0&&$t.push(vt.assignTexture(pt,"bumpMap",Tt.bumpTexture)),Promise.all($t)}}class GLTFMaterialsAnisotropyExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.KHR_MATERIALS_ANISOTROPY}getMaterialType(at){const vt=this.parser.json.materials[at];return!vt.extensions||!vt.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(at,pt){const vt=this.parser,wt=vt.json.materials[at];if(!wt.extensions||!wt.extensions[this.name])return Promise.resolve();const $t=[],Tt=wt.extensions[this.name];return Tt.anisotropyStrength!==void 0&&(pt.anisotropy=Tt.anisotropyStrength),Tt.anisotropyRotation!==void 0&&(pt.anisotropyRotation=Tt.anisotropyRotation),Tt.anisotropyTexture!==void 0&&$t.push(vt.assignTexture(pt,"anisotropyMap",Tt.anisotropyTexture)),Promise.all($t)}}class GLTFTextureBasisUExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.KHR_TEXTURE_BASISU}loadTexture(at){const pt=this.parser,vt=pt.json,wt=vt.textures[at];if(!wt.extensions||!wt.extensions[this.name])return null;const $t=wt.extensions[this.name],Tt=pt.options.ktx2Loader;if(!Tt){if(vt.extensionsRequired&&vt.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return pt.loadTextureImage(at,$t.source,Tt)}}class GLTFTextureWebPExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(at){const pt=this.name,vt=this.parser,wt=vt.json,$t=wt.textures[at];if(!$t.extensions||!$t.extensions[pt])return null;const Tt=$t.extensions[pt],Lt=wt.images[Tt.source];let Ft=vt.textureLoader;if(Lt.uri){const Ct=vt.options.manager.getHandler(Lt.uri);Ct!==null&&(Ft=Ct)}return this.detectSupport().then(function(Ct){if(Ct)return vt.loadTextureImage(at,Tt.source,Ft);if(wt.extensionsRequired&&wt.extensionsRequired.indexOf(pt)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return vt.loadTexture(at)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(at){const pt=new Image;pt.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",pt.onload=pt.onerror=function(){at(pt.height===1)}})),this.isSupported}}class GLTFTextureAVIFExtension{constructor(at){this.parser=at,this.name=EXTENSIONS.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(at){const pt=this.name,vt=this.parser,wt=vt.json,$t=wt.textures[at];if(!$t.extensions||!$t.extensions[pt])return null;const Tt=$t.extensions[pt],Lt=wt.images[Tt.source];let Ft=vt.textureLoader;if(Lt.uri){const Ct=vt.options.manager.getHandler(Lt.uri);Ct!==null&&(Ft=Ct)}return this.detectSupport().then(function(Ct){if(Ct)return vt.loadTextureImage(at,Tt.source,Ft);if(wt.extensionsRequired&&wt.extensionsRequired.indexOf(pt)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return vt.loadTexture(at)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(at){const pt=new Image;pt.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",pt.onload=pt.onerror=function(){at(pt.height===1)}})),this.isSupported}}class GLTFMeshoptCompression{constructor(at){this.name=EXTENSIONS.EXT_MESHOPT_COMPRESSION,this.parser=at}loadBufferView(at){const pt=this.parser.json,vt=pt.bufferViews[at];if(vt.extensions&&vt.extensions[this.name]){const wt=vt.extensions[this.name],$t=this.parser.getDependency("buffer",wt.buffer),Tt=this.parser.options.meshoptDecoder;if(!Tt||!Tt.supported){if(pt.extensionsRequired&&pt.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return $t.then(function(Lt){const Ft=wt.byteOffset||0,Ct=wt.byteLength||0,Ht=wt.count,Gt=wt.byteStride,jt=new Uint8Array(Lt,Ft,Ct);return Tt.decodeGltfBufferAsync?Tt.decodeGltfBufferAsync(Ht,Gt,jt,wt.mode,wt.filter).then(function(qt){return qt.buffer}):Tt.ready.then(function(){const qt=new ArrayBuffer(Ht*Gt);return Tt.decodeGltfBuffer(new Uint8Array(qt),Ht,Gt,jt,wt.mode,wt.filter),qt})})}else return null}}class GLTFMeshGpuInstancing{constructor(at){this.name=EXTENSIONS.EXT_MESH_GPU_INSTANCING,this.parser=at}createNodeMesh(at){const pt=this.parser.json,vt=pt.nodes[at];if(!vt.extensions||!vt.extensions[this.name]||vt.mesh===void 0)return null;const wt=pt.meshes[vt.mesh];for(const Ct of wt.primitives)if(Ct.mode!==WEBGL_CONSTANTS.TRIANGLES&&Ct.mode!==WEBGL_CONSTANTS.TRIANGLE_STRIP&&Ct.mode!==WEBGL_CONSTANTS.TRIANGLE_FAN&&Ct.mode!==void 0)return null;const Tt=vt.extensions[this.name].attributes,Lt=[],Ft={};for(const Ct in Tt)Lt.push(this.parser.getDependency("accessor",Tt[Ct]).then(Ht=>(Ft[Ct]=Ht,Ft[Ct])));return Lt.length<1?null:(Lt.push(this.parser.createNodeMesh(at)),Promise.all(Lt).then(Ct=>{const Ht=Ct.pop(),Gt=Ht.isGroup?Ht.children:[Ht],jt=Ct[0].count,qt=[];for(const Kt of Gt){const An=new Matrix4,Sn=new Vector3,wn=new Quaternion,In=new Vector3(1,1,1),tr=new InstancedMesh(Kt.geometry,Kt.material,jt);for(let rr=0;rr<jt;rr++)Ft.TRANSLATION&&Sn.fromBufferAttribute(Ft.TRANSLATION,rr),Ft.ROTATION&&wn.fromBufferAttribute(Ft.ROTATION,rr),Ft.SCALE&&In.fromBufferAttribute(Ft.SCALE,rr),tr.setMatrixAt(rr,An.compose(Sn,wn,In));for(const rr in Ft)if(rr==="_COLOR_0"){const Hr=Ft[rr];tr.instanceColor=new InstancedBufferAttribute(Hr.array,Hr.itemSize,Hr.normalized)}else rr!=="TRANSLATION"&&rr!=="ROTATION"&&rr!=="SCALE"&&Kt.geometry.setAttribute(rr,Ft[rr]);Object3D.prototype.copy.call(tr,Kt),this.parser.assignFinalMaterial(tr),qt.push(tr)}return Ht.isGroup?(Ht.clear(),Ht.add(...qt),Ht):qt[0]}))}}const BINARY_EXTENSION_HEADER_MAGIC="glTF",BINARY_EXTENSION_HEADER_LENGTH=12,BINARY_EXTENSION_CHUNK_TYPES={JSON:1313821514,BIN:5130562};class GLTFBinaryExtension{constructor(at){this.name=EXTENSIONS.KHR_BINARY_GLTF,this.content=null,this.body=null;const pt=new DataView(at,0,BINARY_EXTENSION_HEADER_LENGTH);if(this.header={magic:LoaderUtils.decodeText(new Uint8Array(at.slice(0,4))),version:pt.getUint32(4,!0),length:pt.getUint32(8,!0)},this.header.magic!==BINARY_EXTENSION_HEADER_MAGIC)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const vt=this.header.length-BINARY_EXTENSION_HEADER_LENGTH,wt=new DataView(at,BINARY_EXTENSION_HEADER_LENGTH);let $t=0;for(;$t<vt;){const Tt=wt.getUint32($t,!0);$t+=4;const Lt=wt.getUint32($t,!0);if($t+=4,Lt===BINARY_EXTENSION_CHUNK_TYPES.JSON){const Ft=new Uint8Array(at,BINARY_EXTENSION_HEADER_LENGTH+$t,Tt);this.content=LoaderUtils.decodeText(Ft)}else if(Lt===BINARY_EXTENSION_CHUNK_TYPES.BIN){const Ft=BINARY_EXTENSION_HEADER_LENGTH+$t;this.body=at.slice(Ft,Ft+Tt)}$t+=Tt}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class GLTFDracoMeshCompressionExtension{constructor(at,pt){if(!pt)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=EXTENSIONS.KHR_DRACO_MESH_COMPRESSION,this.json=at,this.dracoLoader=pt,this.dracoLoader.preload()}decodePrimitive(at,pt){const vt=this.json,wt=this.dracoLoader,$t=at.extensions[this.name].bufferView,Tt=at.extensions[this.name].attributes,Lt={},Ft={},Ct={};for(const Ht in Tt){const Gt=ATTRIBUTES[Ht]||Ht.toLowerCase();Lt[Gt]=Tt[Ht]}for(const Ht in at.attributes){const Gt=ATTRIBUTES[Ht]||Ht.toLowerCase();if(Tt[Ht]!==void 0){const jt=vt.accessors[at.attributes[Ht]],qt=WEBGL_COMPONENT_TYPES[jt.componentType];Ct[Gt]=qt.name,Ft[Gt]=jt.normalized===!0}}return pt.getDependency("bufferView",$t).then(function(Ht){return new Promise(function(Gt,jt){wt.decodeDracoFile(Ht,function(qt){for(const Kt in qt.attributes){const An=qt.attributes[Kt],Sn=Ft[Kt];Sn!==void 0&&(An.normalized=Sn)}Gt(qt)},Lt,Ct,LinearSRGBColorSpace,jt)})})}}class GLTFTextureTransformExtension{constructor(){this.name=EXTENSIONS.KHR_TEXTURE_TRANSFORM}extendTexture(at,pt){return(pt.texCoord===void 0||pt.texCoord===at.channel)&&pt.offset===void 0&&pt.rotation===void 0&&pt.scale===void 0||(at=at.clone(),pt.texCoord!==void 0&&(at.channel=pt.texCoord),pt.offset!==void 0&&at.offset.fromArray(pt.offset),pt.rotation!==void 0&&(at.rotation=pt.rotation),pt.scale!==void 0&&at.repeat.fromArray(pt.scale),at.needsUpdate=!0),at}}class GLTFMeshQuantizationExtension{constructor(){this.name=EXTENSIONS.KHR_MESH_QUANTIZATION}}class GLTFCubicSplineInterpolant extends Interpolant{constructor(at,pt,vt,wt){super(at,pt,vt,wt)}copySampleValue_(at){const pt=this.resultBuffer,vt=this.sampleValues,wt=this.valueSize,$t=at*wt*3+wt;for(let Tt=0;Tt!==wt;Tt++)pt[Tt]=vt[$t+Tt];return pt}interpolate_(at,pt,vt,wt){const $t=this.resultBuffer,Tt=this.sampleValues,Lt=this.valueSize,Ft=Lt*2,Ct=Lt*3,Ht=wt-pt,Gt=(vt-pt)/Ht,jt=Gt*Gt,qt=jt*Gt,Kt=at*Ct,An=Kt-Ct,Sn=-2*qt+3*jt,wn=qt-jt,In=1-Sn,tr=wn-jt+Gt;for(let rr=0;rr!==Lt;rr++){const Hr=Tt[An+rr+Lt],qr=Tt[An+rr+Ft]*Ht,Zr=Tt[Kt+rr+Lt],Bo=Tt[Kt+rr]*Ht;$t[rr]=In*Hr+tr*qr+Sn*Zr+wn*Bo}return $t}}const _q=new Quaternion;class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant{interpolate_(at,pt,vt,wt){const $t=super.interpolate_(at,pt,vt,wt);return _q.fromArray($t).normalize().toArray($t),$t}}const WEBGL_CONSTANTS={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},WEBGL_COMPONENT_TYPES={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},WEBGL_FILTERS={9728:NearestFilter,9729:LinearFilter,9984:NearestMipmapNearestFilter,9985:LinearMipmapNearestFilter,9986:NearestMipmapLinearFilter,9987:LinearMipmapLinearFilter},WEBGL_WRAPPINGS={33071:ClampToEdgeWrapping,33648:MirroredRepeatWrapping,10497:RepeatWrapping},WEBGL_TYPE_SIZES={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ATTRIBUTES={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",...version$1>=152?{TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3"}:{TEXCOORD_0:"uv",TEXCOORD_1:"uv2"},COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},PATH_PROPERTIES={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},INTERPOLATION={CUBICSPLINE:void 0,LINEAR:InterpolateLinear,STEP:InterpolateDiscrete},ALPHA_MODES={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function createDefaultMaterial(st){return st.DefaultMaterial===void 0&&(st.DefaultMaterial=new MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:FrontSide})),st.DefaultMaterial}function addUnknownExtensionsToUserData(st,at,pt){for(const vt in pt.extensions)st[vt]===void 0&&(at.userData.gltfExtensions=at.userData.gltfExtensions||{},at.userData.gltfExtensions[vt]=pt.extensions[vt])}function assignExtrasToUserData(st,at){at.extras!==void 0&&(typeof at.extras=="object"?Object.assign(st.userData,at.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+at.extras))}function addMorphTargets(st,at,pt){let vt=!1,wt=!1,$t=!1;for(let Ct=0,Ht=at.length;Ct<Ht;Ct++){const Gt=at[Ct];if(Gt.POSITION!==void 0&&(vt=!0),Gt.NORMAL!==void 0&&(wt=!0),Gt.COLOR_0!==void 0&&($t=!0),vt&&wt&&$t)break}if(!vt&&!wt&&!$t)return Promise.resolve(st);const Tt=[],Lt=[],Ft=[];for(let Ct=0,Ht=at.length;Ct<Ht;Ct++){const Gt=at[Ct];if(vt){const jt=Gt.POSITION!==void 0?pt.getDependency("accessor",Gt.POSITION):st.attributes.position;Tt.push(jt)}if(wt){const jt=Gt.NORMAL!==void 0?pt.getDependency("accessor",Gt.NORMAL):st.attributes.normal;Lt.push(jt)}if($t){const jt=Gt.COLOR_0!==void 0?pt.getDependency("accessor",Gt.COLOR_0):st.attributes.color;Ft.push(jt)}}return Promise.all([Promise.all(Tt),Promise.all(Lt),Promise.all(Ft)]).then(function(Ct){const Ht=Ct[0],Gt=Ct[1],jt=Ct[2];return vt&&(st.morphAttributes.position=Ht),wt&&(st.morphAttributes.normal=Gt),$t&&(st.morphAttributes.color=jt),st.morphTargetsRelative=!0,st})}function updateMorphTargets(st,at){if(st.updateMorphTargets(),at.weights!==void 0)for(let pt=0,vt=at.weights.length;pt<vt;pt++)st.morphTargetInfluences[pt]=at.weights[pt];if(at.extras&&Array.isArray(at.extras.targetNames)){const pt=at.extras.targetNames;if(st.morphTargetInfluences.length===pt.length){st.morphTargetDictionary={};for(let vt=0,wt=pt.length;vt<wt;vt++)st.morphTargetDictionary[pt[vt]]=vt}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function createPrimitiveKey(st){let at;const pt=st.extensions&&st.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];if(pt?at="draco:"+pt.bufferView+":"+pt.indices+":"+createAttributesKey(pt.attributes):at=st.indices+":"+createAttributesKey(st.attributes)+":"+st.mode,st.targets!==void 0)for(let vt=0,wt=st.targets.length;vt<wt;vt++)at+=":"+createAttributesKey(st.targets[vt]);return at}function createAttributesKey(st){let at="";const pt=Object.keys(st).sort();for(let vt=0,wt=pt.length;vt<wt;vt++)at+=pt[vt]+":"+st[pt[vt]]+";";return at}function getNormalizedComponentScale(st){switch(st){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function getImageURIMimeType(st){return st.search(/\.jpe?g($|\?)/i)>0||st.search(/^data\:image\/jpeg/)===0?"image/jpeg":st.search(/\.webp($|\?)/i)>0||st.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const _identityMatrix=new Matrix4;class GLTFParser{constructor(at={},pt={}){this.json=at,this.extensions={},this.plugins={},this.options=pt,this.cache=new GLTFRegistry,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let vt=!1,wt=!1,$t=-1;typeof navigator<"u"&&typeof navigator.userAgent<"u"&&(vt=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,wt=navigator.userAgent.indexOf("Firefox")>-1,$t=wt?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||vt||wt&&$t<98?this.textureLoader=new TextureLoader(this.options.manager):this.textureLoader=new ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(at){this.extensions=at}setPlugins(at){this.plugins=at}parse(at,pt){const vt=this,wt=this.json,$t=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(Tt){return Tt._markDefs&&Tt._markDefs()}),Promise.all(this._invokeAll(function(Tt){return Tt.beforeRoot&&Tt.beforeRoot()})).then(function(){return Promise.all([vt.getDependencies("scene"),vt.getDependencies("animation"),vt.getDependencies("camera")])}).then(function(Tt){const Lt={scene:Tt[0][wt.scene||0],scenes:Tt[0],animations:Tt[1],cameras:Tt[2],asset:wt.asset,parser:vt,userData:{}};return addUnknownExtensionsToUserData($t,Lt,wt),assignExtrasToUserData(Lt,wt),Promise.all(vt._invokeAll(function(Ft){return Ft.afterRoot&&Ft.afterRoot(Lt)})).then(function(){for(const Ft of Lt.scenes)Ft.updateMatrixWorld();at(Lt)})}).catch(pt)}_markDefs(){const at=this.json.nodes||[],pt=this.json.skins||[],vt=this.json.meshes||[];for(let wt=0,$t=pt.length;wt<$t;wt++){const Tt=pt[wt].joints;for(let Lt=0,Ft=Tt.length;Lt<Ft;Lt++)at[Tt[Lt]].isBone=!0}for(let wt=0,$t=at.length;wt<$t;wt++){const Tt=at[wt];Tt.mesh!==void 0&&(this._addNodeRef(this.meshCache,Tt.mesh),Tt.skin!==void 0&&(vt[Tt.mesh].isSkinnedMesh=!0)),Tt.camera!==void 0&&this._addNodeRef(this.cameraCache,Tt.camera)}}_addNodeRef(at,pt){pt!==void 0&&(at.refs[pt]===void 0&&(at.refs[pt]=at.uses[pt]=0),at.refs[pt]++)}_getNodeRef(at,pt,vt){if(at.refs[pt]<=1)return vt;const wt=vt.clone(),$t=(Tt,Lt)=>{const Ft=this.associations.get(Tt);Ft!=null&&this.associations.set(Lt,Ft);for(const[Ct,Ht]of Tt.children.entries())$t(Ht,Lt.children[Ct])};return $t(vt,wt),wt.name+="_instance_"+at.uses[pt]++,wt}_invokeOne(at){const pt=Object.values(this.plugins);pt.push(this);for(let vt=0;vt<pt.length;vt++){const wt=at(pt[vt]);if(wt)return wt}return null}_invokeAll(at){const pt=Object.values(this.plugins);pt.unshift(this);const vt=[];for(let wt=0;wt<pt.length;wt++){const $t=at(pt[wt]);$t&&vt.push($t)}return vt}getDependency(at,pt){const vt=at+":"+pt;let wt=this.cache.get(vt);if(!wt){switch(at){case"scene":wt=this.loadScene(pt);break;case"node":wt=this._invokeOne(function($t){return $t.loadNode&&$t.loadNode(pt)});break;case"mesh":wt=this._invokeOne(function($t){return $t.loadMesh&&$t.loadMesh(pt)});break;case"accessor":wt=this.loadAccessor(pt);break;case"bufferView":wt=this._invokeOne(function($t){return $t.loadBufferView&&$t.loadBufferView(pt)});break;case"buffer":wt=this.loadBuffer(pt);break;case"material":wt=this._invokeOne(function($t){return $t.loadMaterial&&$t.loadMaterial(pt)});break;case"texture":wt=this._invokeOne(function($t){return $t.loadTexture&&$t.loadTexture(pt)});break;case"skin":wt=this.loadSkin(pt);break;case"animation":wt=this._invokeOne(function($t){return $t.loadAnimation&&$t.loadAnimation(pt)});break;case"camera":wt=this.loadCamera(pt);break;default:if(wt=this._invokeOne(function($t){return $t!=this&&$t.getDependency&&$t.getDependency(at,pt)}),!wt)throw new Error("Unknown type: "+at);break}this.cache.add(vt,wt)}return wt}getDependencies(at){let pt=this.cache.get(at);if(!pt){const vt=this,wt=this.json[at+(at==="mesh"?"es":"s")]||[];pt=Promise.all(wt.map(function($t,Tt){return vt.getDependency(at,Tt)})),this.cache.add(at,pt)}return pt}loadBuffer(at){const pt=this.json.buffers[at],vt=this.fileLoader;if(pt.type&&pt.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+pt.type+" buffer type is not supported.");if(pt.uri===void 0&&at===0)return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);const wt=this.options;return new Promise(function($t,Tt){vt.load(LoaderUtils.resolveURL(pt.uri,wt.path),$t,void 0,function(){Tt(new Error('THREE.GLTFLoader: Failed to load buffer "'+pt.uri+'".'))})})}loadBufferView(at){const pt=this.json.bufferViews[at];return this.getDependency("buffer",pt.buffer).then(function(vt){const wt=pt.byteLength||0,$t=pt.byteOffset||0;return vt.slice($t,$t+wt)})}loadAccessor(at){const pt=this,vt=this.json,wt=this.json.accessors[at];if(wt.bufferView===void 0&&wt.sparse===void 0){const Tt=WEBGL_TYPE_SIZES[wt.type],Lt=WEBGL_COMPONENT_TYPES[wt.componentType],Ft=wt.normalized===!0,Ct=new Lt(wt.count*Tt);return Promise.resolve(new BufferAttribute(Ct,Tt,Ft))}const $t=[];return wt.bufferView!==void 0?$t.push(this.getDependency("bufferView",wt.bufferView)):$t.push(null),wt.sparse!==void 0&&($t.push(this.getDependency("bufferView",wt.sparse.indices.bufferView)),$t.push(this.getDependency("bufferView",wt.sparse.values.bufferView))),Promise.all($t).then(function(Tt){const Lt=Tt[0],Ft=WEBGL_TYPE_SIZES[wt.type],Ct=WEBGL_COMPONENT_TYPES[wt.componentType],Ht=Ct.BYTES_PER_ELEMENT,Gt=Ht*Ft,jt=wt.byteOffset||0,qt=wt.bufferView!==void 0?vt.bufferViews[wt.bufferView].byteStride:void 0,Kt=wt.normalized===!0;let An,Sn;if(qt&&qt!==Gt){const wn=Math.floor(jt/qt),In="InterleavedBuffer:"+wt.bufferView+":"+wt.componentType+":"+wn+":"+wt.count;let tr=pt.cache.get(In);tr||(An=new Ct(Lt,wn*qt,wt.count*qt/Ht),tr=new InterleavedBuffer(An,qt/Ht),pt.cache.add(In,tr)),Sn=new InterleavedBufferAttribute(tr,Ft,jt%qt/Ht,Kt)}else Lt===null?An=new Ct(wt.count*Ft):An=new Ct(Lt,jt,wt.count*Ft),Sn=new BufferAttribute(An,Ft,Kt);if(wt.sparse!==void 0){const wn=WEBGL_TYPE_SIZES.SCALAR,In=WEBGL_COMPONENT_TYPES[wt.sparse.indices.componentType],tr=wt.sparse.indices.byteOffset||0,rr=wt.sparse.values.byteOffset||0,Hr=new In(Tt[1],tr,wt.sparse.count*wn),qr=new Ct(Tt[2],rr,wt.sparse.count*Ft);Lt!==null&&(Sn=new BufferAttribute(Sn.array.slice(),Sn.itemSize,Sn.normalized));for(let Zr=0,Bo=Hr.length;Zr<Bo;Zr++){const Xo=Hr[Zr];if(Sn.setX(Xo,qr[Zr*Ft]),Ft>=2&&Sn.setY(Xo,qr[Zr*Ft+1]),Ft>=3&&Sn.setZ(Xo,qr[Zr*Ft+2]),Ft>=4&&Sn.setW(Xo,qr[Zr*Ft+3]),Ft>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return Sn})}loadTexture(at){const pt=this.json,vt=this.options,$t=pt.textures[at].source,Tt=pt.images[$t];let Lt=this.textureLoader;if(Tt.uri){const Ft=vt.manager.getHandler(Tt.uri);Ft!==null&&(Lt=Ft)}return this.loadTextureImage(at,$t,Lt)}loadTextureImage(at,pt,vt){const wt=this,$t=this.json,Tt=$t.textures[at],Lt=$t.images[pt],Ft=(Lt.uri||Lt.bufferView)+":"+Tt.sampler;if(this.textureCache[Ft])return this.textureCache[Ft];const Ct=this.loadImageSource(pt,vt).then(function(Ht){Ht.flipY=!1,Ht.name=Tt.name||Lt.name||"",Ht.name===""&&typeof Lt.uri=="string"&&Lt.uri.startsWith("data:image/")===!1&&(Ht.name=Lt.uri);const jt=($t.samplers||{})[Tt.sampler]||{};return Ht.magFilter=WEBGL_FILTERS[jt.magFilter]||LinearFilter,Ht.minFilter=WEBGL_FILTERS[jt.minFilter]||LinearMipmapLinearFilter,Ht.wrapS=WEBGL_WRAPPINGS[jt.wrapS]||RepeatWrapping,Ht.wrapT=WEBGL_WRAPPINGS[jt.wrapT]||RepeatWrapping,wt.associations.set(Ht,{textures:at}),Ht}).catch(function(){return null});return this.textureCache[Ft]=Ct,Ct}loadImageSource(at,pt){const vt=this,wt=this.json,$t=this.options;if(this.sourceCache[at]!==void 0)return this.sourceCache[at].then(Gt=>Gt.clone());const Tt=wt.images[at],Lt=self.URL||self.webkitURL;let Ft=Tt.uri||"",Ct=!1;if(Tt.bufferView!==void 0)Ft=vt.getDependency("bufferView",Tt.bufferView).then(function(Gt){Ct=!0;const jt=new Blob([Gt],{type:Tt.mimeType});return Ft=Lt.createObjectURL(jt),Ft});else if(Tt.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+at+" is missing URI and bufferView");const Ht=Promise.resolve(Ft).then(function(Gt){return new Promise(function(jt,qt){let Kt=jt;pt.isImageBitmapLoader===!0&&(Kt=function(An){const Sn=new Texture(An);Sn.needsUpdate=!0,jt(Sn)}),pt.load(LoaderUtils.resolveURL(Gt,$t.path),Kt,void 0,qt)})}).then(function(Gt){return Ct===!0&&Lt.revokeObjectURL(Ft),assignExtrasToUserData(Gt,Tt),Gt.userData.mimeType=Tt.mimeType||getImageURIMimeType(Tt.uri),Gt}).catch(function(Gt){throw console.error("THREE.GLTFLoader: Couldn't load texture",Ft),Gt});return this.sourceCache[at]=Ht,Ht}assignTexture(at,pt,vt,wt){const $t=this;return this.getDependency("texture",vt.index).then(function(Tt){if(!Tt)return null;if(vt.texCoord!==void 0&&vt.texCoord>0&&(Tt=Tt.clone(),Tt.channel=vt.texCoord),$t.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]){const Lt=vt.extensions!==void 0?vt.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]:void 0;if(Lt){const Ft=$t.associations.get(Tt);Tt=$t.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(Tt,Lt),$t.associations.set(Tt,Ft)}}return wt!==void 0&&(typeof wt=="number"&&(wt=wt===sRGBEncoding$1?SRGBColorSpace:LinearSRGBColorSpace),"colorSpace"in Tt?Tt.colorSpace=wt:Tt.encoding=wt===SRGBColorSpace?sRGBEncoding$1:LinearEncoding$1),at[pt]=Tt,Tt})}assignFinalMaterial(at){const pt=at.geometry;let vt=at.material;const wt=pt.attributes.tangent===void 0,$t=pt.attributes.color!==void 0,Tt=pt.attributes.normal===void 0;if(at.isPoints){const Lt="PointsMaterial:"+vt.uuid;let Ft=this.cache.get(Lt);Ft||(Ft=new PointsMaterial,Material.prototype.copy.call(Ft,vt),Ft.color.copy(vt.color),Ft.map=vt.map,Ft.sizeAttenuation=!1,this.cache.add(Lt,Ft)),vt=Ft}else if(at.isLine){const Lt="LineBasicMaterial:"+vt.uuid;let Ft=this.cache.get(Lt);Ft||(Ft=new LineBasicMaterial,Material.prototype.copy.call(Ft,vt),Ft.color.copy(vt.color),Ft.map=vt.map,this.cache.add(Lt,Ft)),vt=Ft}if(wt||$t||Tt){let Lt="ClonedMaterial:"+vt.uuid+":";wt&&(Lt+="derivative-tangents:"),$t&&(Lt+="vertex-colors:"),Tt&&(Lt+="flat-shading:");let Ft=this.cache.get(Lt);Ft||(Ft=vt.clone(),$t&&(Ft.vertexColors=!0),Tt&&(Ft.flatShading=!0),wt&&(Ft.normalScale&&(Ft.normalScale.y*=-1),Ft.clearcoatNormalScale&&(Ft.clearcoatNormalScale.y*=-1)),this.cache.add(Lt,Ft),this.associations.set(Ft,this.associations.get(vt))),vt=Ft}at.material=vt}getMaterialType(){return MeshStandardMaterial}loadMaterial(at){const pt=this,vt=this.json,wt=this.extensions,$t=vt.materials[at];let Tt;const Lt={},Ft=$t.extensions||{},Ct=[];if(Ft[EXTENSIONS.KHR_MATERIALS_UNLIT]){const Gt=wt[EXTENSIONS.KHR_MATERIALS_UNLIT];Tt=Gt.getMaterialType(),Ct.push(Gt.extendParams(Lt,$t,pt))}else{const Gt=$t.pbrMetallicRoughness||{};if(Lt.color=new Color$1(1,1,1),Lt.opacity=1,Array.isArray(Gt.baseColorFactor)){const jt=Gt.baseColorFactor;Lt.color.setRGB(jt[0],jt[1],jt[2],LinearSRGBColorSpace),Lt.opacity=jt[3]}Gt.baseColorTexture!==void 0&&Ct.push(pt.assignTexture(Lt,"map",Gt.baseColorTexture,SRGBColorSpace)),Lt.metalness=Gt.metallicFactor!==void 0?Gt.metallicFactor:1,Lt.roughness=Gt.roughnessFactor!==void 0?Gt.roughnessFactor:1,Gt.metallicRoughnessTexture!==void 0&&(Ct.push(pt.assignTexture(Lt,"metalnessMap",Gt.metallicRoughnessTexture)),Ct.push(pt.assignTexture(Lt,"roughnessMap",Gt.metallicRoughnessTexture))),Tt=this._invokeOne(function(jt){return jt.getMaterialType&&jt.getMaterialType(at)}),Ct.push(Promise.all(this._invokeAll(function(jt){return jt.extendMaterialParams&&jt.extendMaterialParams(at,Lt)})))}$t.doubleSided===!0&&(Lt.side=DoubleSide);const Ht=$t.alphaMode||ALPHA_MODES.OPAQUE;if(Ht===ALPHA_MODES.BLEND?(Lt.transparent=!0,Lt.depthWrite=!1):(Lt.transparent=!1,Ht===ALPHA_MODES.MASK&&(Lt.alphaTest=$t.alphaCutoff!==void 0?$t.alphaCutoff:.5)),$t.normalTexture!==void 0&&Tt!==MeshBasicMaterial&&(Ct.push(pt.assignTexture(Lt,"normalMap",$t.normalTexture)),Lt.normalScale=new Vector2(1,1),$t.normalTexture.scale!==void 0)){const Gt=$t.normalTexture.scale;Lt.normalScale.set(Gt,Gt)}if($t.occlusionTexture!==void 0&&Tt!==MeshBasicMaterial&&(Ct.push(pt.assignTexture(Lt,"aoMap",$t.occlusionTexture)),$t.occlusionTexture.strength!==void 0&&(Lt.aoMapIntensity=$t.occlusionTexture.strength)),$t.emissiveFactor!==void 0&&Tt!==MeshBasicMaterial){const Gt=$t.emissiveFactor;Lt.emissive=new Color$1().setRGB(Gt[0],Gt[1],Gt[2],LinearSRGBColorSpace)}return $t.emissiveTexture!==void 0&&Tt!==MeshBasicMaterial&&Ct.push(pt.assignTexture(Lt,"emissiveMap",$t.emissiveTexture,SRGBColorSpace)),Promise.all(Ct).then(function(){const Gt=new Tt(Lt);return $t.name&&(Gt.name=$t.name),assignExtrasToUserData(Gt,$t),pt.associations.set(Gt,{materials:at}),$t.extensions&&addUnknownExtensionsToUserData(wt,Gt,$t),Gt})}createUniqueName(at){const pt=PropertyBinding.sanitizeNodeName(at||"");return pt in this.nodeNamesUsed?pt+"_"+ ++this.nodeNamesUsed[pt]:(this.nodeNamesUsed[pt]=0,pt)}loadGeometries(at){const pt=this,vt=this.extensions,wt=this.primitiveCache;function $t(Lt){return vt[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(Lt,pt).then(function(Ft){return addPrimitiveAttributes(Ft,Lt,pt)})}const Tt=[];for(let Lt=0,Ft=at.length;Lt<Ft;Lt++){const Ct=at[Lt],Ht=createPrimitiveKey(Ct),Gt=wt[Ht];if(Gt)Tt.push(Gt.promise);else{let jt;Ct.extensions&&Ct.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]?jt=$t(Ct):jt=addPrimitiveAttributes(new BufferGeometry,Ct,pt),wt[Ht]={primitive:Ct,promise:jt},Tt.push(jt)}}return Promise.all(Tt)}loadMesh(at){const pt=this,vt=this.json,wt=this.extensions,$t=vt.meshes[at],Tt=$t.primitives,Lt=[];for(let Ft=0,Ct=Tt.length;Ft<Ct;Ft++){const Ht=Tt[Ft].material===void 0?createDefaultMaterial(this.cache):this.getDependency("material",Tt[Ft].material);Lt.push(Ht)}return Lt.push(pt.loadGeometries(Tt)),Promise.all(Lt).then(function(Ft){const Ct=Ft.slice(0,Ft.length-1),Ht=Ft[Ft.length-1],Gt=[];for(let qt=0,Kt=Ht.length;qt<Kt;qt++){const An=Ht[qt],Sn=Tt[qt];let wn;const In=Ct[qt];if(Sn.mode===WEBGL_CONSTANTS.TRIANGLES||Sn.mode===WEBGL_CONSTANTS.TRIANGLE_STRIP||Sn.mode===WEBGL_CONSTANTS.TRIANGLE_FAN||Sn.mode===void 0)wn=$t.isSkinnedMesh===!0?new SkinnedMesh(An,In):new Mesh(An,In),wn.isSkinnedMesh===!0&&wn.normalizeSkinWeights(),Sn.mode===WEBGL_CONSTANTS.TRIANGLE_STRIP?wn.geometry=toTrianglesDrawMode(wn.geometry,TriangleStripDrawMode):Sn.mode===WEBGL_CONSTANTS.TRIANGLE_FAN&&(wn.geometry=toTrianglesDrawMode(wn.geometry,TriangleFanDrawMode));else if(Sn.mode===WEBGL_CONSTANTS.LINES)wn=new LineSegments(An,In);else if(Sn.mode===WEBGL_CONSTANTS.LINE_STRIP)wn=new Line(An,In);else if(Sn.mode===WEBGL_CONSTANTS.LINE_LOOP)wn=new LineLoop(An,In);else if(Sn.mode===WEBGL_CONSTANTS.POINTS)wn=new Points(An,In);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+Sn.mode);Object.keys(wn.geometry.morphAttributes).length>0&&updateMorphTargets(wn,$t),wn.name=pt.createUniqueName($t.name||"mesh_"+at),assignExtrasToUserData(wn,$t),Sn.extensions&&addUnknownExtensionsToUserData(wt,wn,Sn),pt.assignFinalMaterial(wn),Gt.push(wn)}for(let qt=0,Kt=Gt.length;qt<Kt;qt++)pt.associations.set(Gt[qt],{meshes:at,primitives:qt});if(Gt.length===1)return $t.extensions&&addUnknownExtensionsToUserData(wt,Gt[0],$t),Gt[0];const jt=new Group;$t.extensions&&addUnknownExtensionsToUserData(wt,jt,$t),pt.associations.set(jt,{meshes:at});for(let qt=0,Kt=Gt.length;qt<Kt;qt++)jt.add(Gt[qt]);return jt})}loadCamera(at){let pt;const vt=this.json.cameras[at],wt=vt[vt.type];if(!wt){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return vt.type==="perspective"?pt=new PerspectiveCamera(MathUtils.radToDeg(wt.yfov),wt.aspectRatio||1,wt.znear||1,wt.zfar||2e6):vt.type==="orthographic"&&(pt=new OrthographicCamera(-wt.xmag,wt.xmag,wt.ymag,-wt.ymag,wt.znear,wt.zfar)),vt.name&&(pt.name=this.createUniqueName(vt.name)),assignExtrasToUserData(pt,vt),Promise.resolve(pt)}loadSkin(at){const pt=this.json.skins[at],vt=[];for(let wt=0,$t=pt.joints.length;wt<$t;wt++)vt.push(this._loadNodeShallow(pt.joints[wt]));return pt.inverseBindMatrices!==void 0?vt.push(this.getDependency("accessor",pt.inverseBindMatrices)):vt.push(null),Promise.all(vt).then(function(wt){const $t=wt.pop(),Tt=wt,Lt=[],Ft=[];for(let Ct=0,Ht=Tt.length;Ct<Ht;Ct++){const Gt=Tt[Ct];if(Gt){Lt.push(Gt);const jt=new Matrix4;$t!==null&&jt.fromArray($t.array,Ct*16),Ft.push(jt)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',pt.joints[Ct])}return new Skeleton(Lt,Ft)})}loadAnimation(at){const pt=this.json,vt=this,wt=pt.animations[at],$t=wt.name?wt.name:"animation_"+at,Tt=[],Lt=[],Ft=[],Ct=[],Ht=[];for(let Gt=0,jt=wt.channels.length;Gt<jt;Gt++){const qt=wt.channels[Gt],Kt=wt.samplers[qt.sampler],An=qt.target,Sn=An.node,wn=wt.parameters!==void 0?wt.parameters[Kt.input]:Kt.input,In=wt.parameters!==void 0?wt.parameters[Kt.output]:Kt.output;An.node!==void 0&&(Tt.push(this.getDependency("node",Sn)),Lt.push(this.getDependency("accessor",wn)),Ft.push(this.getDependency("accessor",In)),Ct.push(Kt),Ht.push(An))}return Promise.all([Promise.all(Tt),Promise.all(Lt),Promise.all(Ft),Promise.all(Ct),Promise.all(Ht)]).then(function(Gt){const jt=Gt[0],qt=Gt[1],Kt=Gt[2],An=Gt[3],Sn=Gt[4],wn=[];for(let In=0,tr=jt.length;In<tr;In++){const rr=jt[In],Hr=qt[In],qr=Kt[In],Zr=An[In],Bo=Sn[In];if(rr===void 0)continue;rr.updateMatrix&&rr.updateMatrix();const Xo=vt._createAnimationTracks(rr,Hr,qr,Zr,Bo);if(Xo)for(let Kr=0;Kr<Xo.length;Kr++)wn.push(Xo[Kr])}return new AnimationClip($t,void 0,wn)})}createNodeMesh(at){const pt=this.json,vt=this,wt=pt.nodes[at];return wt.mesh===void 0?null:vt.getDependency("mesh",wt.mesh).then(function($t){const Tt=vt._getNodeRef(vt.meshCache,wt.mesh,$t);return wt.weights!==void 0&&Tt.traverse(function(Lt){if(Lt.isMesh)for(let Ft=0,Ct=wt.weights.length;Ft<Ct;Ft++)Lt.morphTargetInfluences[Ft]=wt.weights[Ft]}),Tt})}loadNode(at){const pt=this.json,vt=this,wt=pt.nodes[at],$t=vt._loadNodeShallow(at),Tt=[],Lt=wt.children||[];for(let Ct=0,Ht=Lt.length;Ct<Ht;Ct++)Tt.push(vt.getDependency("node",Lt[Ct]));const Ft=wt.skin===void 0?Promise.resolve(null):vt.getDependency("skin",wt.skin);return Promise.all([$t,Promise.all(Tt),Ft]).then(function(Ct){const Ht=Ct[0],Gt=Ct[1],jt=Ct[2];jt!==null&&Ht.traverse(function(qt){qt.isSkinnedMesh&&qt.bind(jt,_identityMatrix)});for(let qt=0,Kt=Gt.length;qt<Kt;qt++)Ht.add(Gt[qt]);return Ht})}_loadNodeShallow(at){const pt=this.json,vt=this.extensions,wt=this;if(this.nodeCache[at]!==void 0)return this.nodeCache[at];const $t=pt.nodes[at],Tt=$t.name?wt.createUniqueName($t.name):"",Lt=[],Ft=wt._invokeOne(function(Ct){return Ct.createNodeMesh&&Ct.createNodeMesh(at)});return Ft&&Lt.push(Ft),$t.camera!==void 0&&Lt.push(wt.getDependency("camera",$t.camera).then(function(Ct){return wt._getNodeRef(wt.cameraCache,$t.camera,Ct)})),wt._invokeAll(function(Ct){return Ct.createNodeAttachment&&Ct.createNodeAttachment(at)}).forEach(function(Ct){Lt.push(Ct)}),this.nodeCache[at]=Promise.all(Lt).then(function(Ct){let Ht;if($t.isBone===!0?Ht=new Bone:Ct.length>1?Ht=new Group:Ct.length===1?Ht=Ct[0]:Ht=new Object3D,Ht!==Ct[0])for(let Gt=0,jt=Ct.length;Gt<jt;Gt++)Ht.add(Ct[Gt]);if($t.name&&(Ht.userData.name=$t.name,Ht.name=Tt),assignExtrasToUserData(Ht,$t),$t.extensions&&addUnknownExtensionsToUserData(vt,Ht,$t),$t.matrix!==void 0){const Gt=new Matrix4;Gt.fromArray($t.matrix),Ht.applyMatrix4(Gt)}else $t.translation!==void 0&&Ht.position.fromArray($t.translation),$t.rotation!==void 0&&Ht.quaternion.fromArray($t.rotation),$t.scale!==void 0&&Ht.scale.fromArray($t.scale);return wt.associations.has(Ht)||wt.associations.set(Ht,{}),wt.associations.get(Ht).nodes=at,Ht}),this.nodeCache[at]}loadScene(at){const pt=this.extensions,vt=this.json.scenes[at],wt=this,$t=new Group;vt.name&&($t.name=wt.createUniqueName(vt.name)),assignExtrasToUserData($t,vt),vt.extensions&&addUnknownExtensionsToUserData(pt,$t,vt);const Tt=vt.nodes||[],Lt=[];for(let Ft=0,Ct=Tt.length;Ft<Ct;Ft++)Lt.push(wt.getDependency("node",Tt[Ft]));return Promise.all(Lt).then(function(Ft){for(let Ht=0,Gt=Ft.length;Ht<Gt;Ht++)$t.add(Ft[Ht]);const Ct=Ht=>{const Gt=new Map;for(const[jt,qt]of wt.associations)(jt instanceof Material||jt instanceof Texture)&&Gt.set(jt,qt);return Ht.traverse(jt=>{const qt=wt.associations.get(jt);qt!=null&&Gt.set(jt,qt)}),Gt};return wt.associations=Ct($t),$t})}_createAnimationTracks(at,pt,vt,wt,$t){const Tt=[],Lt=at.name?at.name:at.uuid,Ft=[];PATH_PROPERTIES[$t.path]===PATH_PROPERTIES.weights?at.traverse(function(jt){jt.morphTargetInfluences&&Ft.push(jt.name?jt.name:jt.uuid)}):Ft.push(Lt);let Ct;switch(PATH_PROPERTIES[$t.path]){case PATH_PROPERTIES.weights:Ct=NumberKeyframeTrack;break;case PATH_PROPERTIES.rotation:Ct=QuaternionKeyframeTrack;break;case PATH_PROPERTIES.position:case PATH_PROPERTIES.scale:Ct=VectorKeyframeTrack;break;default:switch(vt.itemSize){case 1:Ct=NumberKeyframeTrack;break;case 2:case 3:default:Ct=VectorKeyframeTrack;break}break}const Ht=wt.interpolation!==void 0?INTERPOLATION[wt.interpolation]:InterpolateLinear,Gt=this._getArrayFromAccessor(vt);for(let jt=0,qt=Ft.length;jt<qt;jt++){const Kt=new Ct(Ft[jt]+"."+PATH_PROPERTIES[$t.path],pt.array,Gt,Ht);wt.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(Kt),Tt.push(Kt)}return Tt}_getArrayFromAccessor(at){let pt=at.array;if(at.normalized){const vt=getNormalizedComponentScale(pt.constructor),wt=new Float32Array(pt.length);for(let $t=0,Tt=pt.length;$t<Tt;$t++)wt[$t]=pt[$t]*vt;pt=wt}return pt}_createCubicSplineTrackInterpolant(at){at.createInterpolant=function(vt){const wt=this instanceof QuaternionKeyframeTrack?GLTFCubicSplineQuaternionInterpolant:GLTFCubicSplineInterpolant;return new wt(this.times,this.values,this.getValueSize()/3,vt)},at.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function computeBounds(st,at,pt){const vt=at.attributes,wt=new Box3;if(vt.POSITION!==void 0){const Lt=pt.json.accessors[vt.POSITION],Ft=Lt.min,Ct=Lt.max;if(Ft!==void 0&&Ct!==void 0){if(wt.set(new Vector3(Ft[0],Ft[1],Ft[2]),new Vector3(Ct[0],Ct[1],Ct[2])),Lt.normalized){const Ht=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[Lt.componentType]);wt.min.multiplyScalar(Ht),wt.max.multiplyScalar(Ht)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const $t=at.targets;if($t!==void 0){const Lt=new Vector3,Ft=new Vector3;for(let Ct=0,Ht=$t.length;Ct<Ht;Ct++){const Gt=$t[Ct];if(Gt.POSITION!==void 0){const jt=pt.json.accessors[Gt.POSITION],qt=jt.min,Kt=jt.max;if(qt!==void 0&&Kt!==void 0){if(Ft.setX(Math.max(Math.abs(qt[0]),Math.abs(Kt[0]))),Ft.setY(Math.max(Math.abs(qt[1]),Math.abs(Kt[1]))),Ft.setZ(Math.max(Math.abs(qt[2]),Math.abs(Kt[2]))),jt.normalized){const An=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[jt.componentType]);Ft.multiplyScalar(An)}Lt.max(Ft)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}wt.expandByVector(Lt)}st.boundingBox=wt;const Tt=new Sphere;wt.getCenter(Tt.center),Tt.radius=wt.min.distanceTo(wt.max)/2,st.boundingSphere=Tt}function addPrimitiveAttributes(st,at,pt){const vt=at.attributes,wt=[];function $t(Tt,Lt){return pt.getDependency("accessor",Tt).then(function(Ft){st.setAttribute(Lt,Ft)})}for(const Tt in vt){const Lt=ATTRIBUTES[Tt]||Tt.toLowerCase();Lt in st.attributes||wt.push($t(vt[Tt],Lt))}if(at.indices!==void 0&&!st.index){const Tt=pt.getDependency("accessor",at.indices).then(function(Lt){st.setIndex(Lt)});wt.push(Tt)}return assignExtrasToUserData(st,at),computeBounds(st,at,pt),Promise.all(wt).then(function(){return at.targets!==void 0?addMorphTargets(st,at.targets,pt):st})}class RGBELoader extends DataTextureLoader{constructor(at){super(at),this.type=HalfFloatType}parse(at){const Tt=function(Bo,Xo){switch(Bo){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(Xo||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(Xo||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(Xo||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(Xo||""))}},Ht=`
`,Gt=function(Bo,Xo,Kr){Xo=Xo||1024;let f0=Bo.pos,x0=-1,l0=0,T0="",t0=String.fromCharCode.apply(null,new Uint16Array(Bo.subarray(f0,f0+128)));for(;0>(x0=t0.indexOf(Ht))&&l0<Xo&&f0<Bo.byteLength;)T0+=t0,l0+=t0.length,f0+=128,t0+=String.fromCharCode.apply(null,new Uint16Array(Bo.subarray(f0,f0+128)));return-1<x0?(Bo.pos+=l0+x0+1,T0+t0.slice(0,x0)):!1},jt=function(Bo){const Xo=/^#\?(\S+)/,Kr=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,ko=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,f0=/^\s*FORMAT=(\S+)\s*$/,x0=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,l0={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let T0,t0;for((Bo.pos>=Bo.byteLength||!(T0=Gt(Bo)))&&Tt(1,"no header found"),(t0=T0.match(Xo))||Tt(3,"bad initial token"),l0.valid|=1,l0.programtype=t0[1],l0.string+=T0+`
`;T0=Gt(Bo),T0!==!1;){if(l0.string+=T0+`
`,T0.charAt(0)==="#"){l0.comments+=T0+`
`;continue}if((t0=T0.match(Kr))&&(l0.gamma=parseFloat(t0[1])),(t0=T0.match(ko))&&(l0.exposure=parseFloat(t0[1])),(t0=T0.match(f0))&&(l0.valid|=2,l0.format=t0[1]),(t0=T0.match(x0))&&(l0.valid|=4,l0.height=parseInt(t0[1],10),l0.width=parseInt(t0[2],10)),l0.valid&2&&l0.valid&4)break}return l0.valid&2||Tt(3,"missing format specifier"),l0.valid&4||Tt(3,"missing image size specifier"),l0},qt=function(Bo,Xo,Kr){const ko=Xo;if(ko<8||ko>32767||Bo[0]!==2||Bo[1]!==2||Bo[2]&128)return new Uint8Array(Bo);ko!==(Bo[2]<<8|Bo[3])&&Tt(3,"wrong scanline width");const f0=new Uint8Array(4*Xo*Kr);f0.length||Tt(4,"unable to allocate buffer space");let x0=0,l0=0;const T0=4*ko,t0=new Uint8Array(4),E0=new Uint8Array(T0);let n0=Kr;for(;n0>0&&l0<Bo.byteLength;){l0+4>Bo.byteLength&&Tt(1),t0[0]=Bo[l0++],t0[1]=Bo[l0++],t0[2]=Bo[l0++],t0[3]=Bo[l0++],(t0[0]!=2||t0[1]!=2||(t0[2]<<8|t0[3])!=ko)&&Tt(3,"bad rgbe scanline format");let m0=0,h0;for(;m0<T0&&l0<Bo.byteLength;){h0=Bo[l0++];const P0=h0>128;if(P0&&(h0-=128),(h0===0||m0+h0>T0)&&Tt(3,"bad scanline data"),P0){const V0=Bo[l0++];for(let B0=0;B0<h0;B0++)E0[m0++]=V0}else E0.set(Bo.subarray(l0,l0+h0),m0),m0+=h0,l0+=h0}const a0=ko;for(let P0=0;P0<a0;P0++){let V0=0;f0[x0]=E0[P0+V0],V0+=ko,f0[x0+1]=E0[P0+V0],V0+=ko,f0[x0+2]=E0[P0+V0],V0+=ko,f0[x0+3]=E0[P0+V0],x0+=4}n0--}return f0},Kt=function(Bo,Xo,Kr,ko){const f0=Bo[Xo+3],x0=Math.pow(2,f0-128)/255;Kr[ko+0]=Bo[Xo+0]*x0,Kr[ko+1]=Bo[Xo+1]*x0,Kr[ko+2]=Bo[Xo+2]*x0,Kr[ko+3]=1},An=function(Bo,Xo,Kr,ko){const f0=Bo[Xo+3],x0=Math.pow(2,f0-128)/255;Kr[ko+0]=DataUtils.toHalfFloat(Math.min(Bo[Xo+0]*x0,65504)),Kr[ko+1]=DataUtils.toHalfFloat(Math.min(Bo[Xo+1]*x0,65504)),Kr[ko+2]=DataUtils.toHalfFloat(Math.min(Bo[Xo+2]*x0,65504)),Kr[ko+3]=DataUtils.toHalfFloat(1)},Sn=new Uint8Array(at);Sn.pos=0;const wn=jt(Sn),In=wn.width,tr=wn.height,rr=qt(Sn.subarray(Sn.pos),In,tr);let Hr,qr,Zr;switch(this.type){case FloatType:Zr=rr.length/4;const Bo=new Float32Array(Zr*4);for(let Kr=0;Kr<Zr;Kr++)Kt(rr,Kr*4,Bo,Kr*4);Hr=Bo,qr=FloatType;break;case HalfFloatType:Zr=rr.length/4;const Xo=new Uint16Array(Zr*4);for(let Kr=0;Kr<Zr;Kr++)An(rr,Kr*4,Xo,Kr*4);Hr=Xo,qr=HalfFloatType;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:In,height:tr,data:Hr,header:wn.string,gamma:wn.gamma,exposure:wn.exposure,type:qr}}setDataType(at){return this.type=at,this}load(at,pt,vt,wt){function $t(Tt,Lt){switch(Tt.type){case FloatType:case HalfFloatType:"colorSpace"in Tt?Tt.colorSpace="srgb-linear":Tt.encoding=3e3,Tt.minFilter=LinearFilter,Tt.magFilter=LinearFilter,Tt.generateMipmaps=!1,Tt.flipY=!0;break}pt&&pt(Tt,Lt)}return super.load(at,$t,vt,wt)}}const hasColorSpace="colorSpace"in new Texture;class EXRLoader extends DataTextureLoader{constructor(at){super(at),this.type=HalfFloatType}parse(at){const Xo=Math.pow(2.7182818,2.2);function Kr(Qo,c0){for(var D0=0,Go=0;Go<65536;++Go)(Go==0||Qo[Go>>3]&1<<(Go&7))&&(c0[D0++]=Go);for(var g0=D0-1;D0<65536;)c0[D0++]=0;return g0}function ko(Qo){for(var c0=0;c0<16384;c0++)Qo[c0]={},Qo[c0].len=0,Qo[c0].lit=0,Qo[c0].p=null}const f0={l:0,c:0,lc:0};function x0(Qo,c0,D0,Go,g0){for(;D0<Qo;)c0=c0<<8|cy(Go,g0),D0+=8;D0-=Qo,f0.l=c0>>D0&(1<<Qo)-1,f0.c=c0,f0.lc=D0}const l0=new Array(59);function T0(Qo){for(var c0=0;c0<=58;++c0)l0[c0]=0;for(var c0=0;c0<65537;++c0)l0[Qo[c0]]+=1;for(var D0=0,c0=58;c0>0;--c0){var Go=D0+l0[c0]>>1;l0[c0]=D0,D0=Go}for(var c0=0;c0<65537;++c0){var g0=Qo[c0];g0>0&&(Qo[c0]=g0|l0[g0]++<<6)}}function t0(Qo,c0,D0,Go,g0,b0,I0){for(var A0=D0,Y0=0,ey=0;g0<=b0;g0++){if(A0.value-D0.value>Go)return!1;x0(6,Y0,ey,Qo,A0);var ny=f0.l;if(Y0=f0.c,ey=f0.lc,I0[g0]=ny,ny==63){if(A0.value-D0.value>Go)throw"Something wrong with hufUnpackEncTable";x0(8,Y0,ey,Qo,A0);var ry=f0.l+6;if(Y0=f0.c,ey=f0.lc,g0+ry>b0+1)throw"Something wrong with hufUnpackEncTable";for(;ry--;)I0[g0++]=0;g0--}else if(ny>=59){var ry=ny-59+2;if(g0+ry>b0+1)throw"Something wrong with hufUnpackEncTable";for(;ry--;)I0[g0++]=0;g0--}}T0(I0)}function E0(Qo){return Qo&63}function n0(Qo){return Qo>>6}function m0(Qo,c0,D0,Go){for(;c0<=D0;c0++){var g0=n0(Qo[c0]),b0=E0(Qo[c0]);if(g0>>b0)throw"Invalid table entry";if(b0>14){var I0=Go[g0>>b0-14];if(I0.len)throw"Invalid table entry";if(I0.lit++,I0.p){var A0=I0.p;I0.p=new Array(I0.lit);for(var Y0=0;Y0<I0.lit-1;++Y0)I0.p[Y0]=A0[Y0]}else I0.p=new Array(1);I0.p[I0.lit-1]=c0}else if(b0)for(var ey=0,Y0=1<<14-b0;Y0>0;Y0--){var I0=Go[(g0<<14-b0)+ey];if(I0.len||I0.p)throw"Invalid table entry";I0.len=b0,I0.lit=c0,ey++}}return!0}const h0={c:0,lc:0};function a0(Qo,c0,D0,Go){Qo=Qo<<8|cy(D0,Go),c0+=8,h0.c=Qo,h0.lc=c0}const P0={c:0,lc:0};function V0(Qo,c0,D0,Go,g0,b0,I0,A0,Y0,ey){if(Qo==c0){Go<8&&(a0(D0,Go,g0,I0),D0=h0.c,Go=h0.lc),Go-=8;var ny=D0>>Go,ny=new Uint8Array([ny])[0];if(Y0.value+ny>ey)return!1;for(var ry=A0[Y0.value-1];ny-- >0;)A0[Y0.value++]=ry}else if(Y0.value<ey)A0[Y0.value++]=Qo;else return!1;P0.c=D0,P0.lc=Go}function B0(Qo){return Qo&65535}function W0(Qo){var c0=B0(Qo);return c0>32767?c0-65536:c0}const K0={a:0,b:0};function Ty(Qo,c0){var D0=W0(Qo),Go=W0(c0),g0=Go,b0=D0+(g0&1)+(g0>>1),I0=b0,A0=b0-g0;K0.a=I0,K0.b=A0}function $y(Qo,c0){var D0=B0(Qo),Go=B0(c0),g0=D0-(Go>>1)&65535,b0=Go+g0-32768&65535;K0.a=b0,K0.b=g0}function My(Qo,c0,D0,Go,g0,b0,I0){for(var A0=I0<16384,Y0=D0>g0?g0:D0,ey=1,ny;ey<=Y0;)ey<<=1;for(ey>>=1,ny=ey,ey>>=1;ey>=1;){for(var ry=0,Ky=ry+b0*(g0-ny),wy=b0*ey,Ry=b0*ny,Hy=Go*ey,uv=Go*ny,dv,pv,Zy,By;ry<=Ky;ry+=Ry){for(var bv=ry,fv=ry+Go*(D0-ny);bv<=fv;bv+=uv){var xv=bv+Hy,t1=bv+wy,u1=t1+Hy;A0?(Ty(Qo[bv+c0],Qo[t1+c0]),dv=K0.a,Zy=K0.b,Ty(Qo[xv+c0],Qo[u1+c0]),pv=K0.a,By=K0.b,Ty(dv,pv),Qo[bv+c0]=K0.a,Qo[xv+c0]=K0.b,Ty(Zy,By),Qo[t1+c0]=K0.a,Qo[u1+c0]=K0.b):($y(Qo[bv+c0],Qo[t1+c0]),dv=K0.a,Zy=K0.b,$y(Qo[xv+c0],Qo[u1+c0]),pv=K0.a,By=K0.b,$y(dv,pv),Qo[bv+c0]=K0.a,Qo[xv+c0]=K0.b,$y(Zy,By),Qo[t1+c0]=K0.a,Qo[u1+c0]=K0.b)}if(D0&ey){var t1=bv+wy;A0?Ty(Qo[bv+c0],Qo[t1+c0]):$y(Qo[bv+c0],Qo[t1+c0]),dv=K0.a,Qo[t1+c0]=K0.b,Qo[bv+c0]=dv}}if(g0&ey)for(var bv=ry,fv=ry+Go*(D0-ny);bv<=fv;bv+=uv){var xv=bv+Hy;A0?Ty(Qo[bv+c0],Qo[xv+c0]):$y(Qo[bv+c0],Qo[xv+c0]),dv=K0.a,Qo[xv+c0]=K0.b,Qo[bv+c0]=dv}ny=ey,ey>>=1}return ry}function Wy(Qo,c0,D0,Go,g0,b0,I0,A0,Y0,ey){for(var ny=0,ry=0,Ky=A0,wy=Math.trunc(g0.value+(b0+7)/8);g0.value<wy;)for(a0(ny,ry,D0,g0),ny=h0.c,ry=h0.lc;ry>=14;){var Ry=ny>>ry-14&16383,Hy=c0[Ry];if(Hy.len)ry-=Hy.len,V0(Hy.lit,I0,ny,ry,D0,Go,g0,Y0,ey,Ky),ny=P0.c,ry=P0.lc;else{if(!Hy.p)throw"hufDecode issues";var uv;for(uv=0;uv<Hy.lit;uv++){for(var dv=E0(Qo[Hy.p[uv]]);ry<dv&&g0.value<wy;)a0(ny,ry,D0,g0),ny=h0.c,ry=h0.lc;if(ry>=dv&&n0(Qo[Hy.p[uv]])==(ny>>ry-dv&(1<<dv)-1)){ry-=dv,V0(Hy.p[uv],I0,ny,ry,D0,Go,g0,Y0,ey,Ky),ny=P0.c,ry=P0.lc;break}}if(uv==Hy.lit)throw"hufDecode issues"}}var pv=8-b0&7;for(ny>>=pv,ry-=pv;ry>0;){var Hy=c0[ny<<14-ry&16383];if(Hy.len)ry-=Hy.len,V0(Hy.lit,I0,ny,ry,D0,Go,g0,Y0,ey,Ky),ny=P0.c,ry=P0.lc;else throw"hufDecode issues"}return!0}function Ey(Qo,c0,D0,Go,g0,b0){var I0={value:0},A0=D0.value,Y0=Qy(c0,D0),ey=Qy(c0,D0);D0.value+=4;var ny=Qy(c0,D0);if(D0.value+=4,Y0<0||Y0>=65537||ey<0||ey>=65537)throw"Something wrong with HUF_ENCSIZE";var ry=new Array(65537),Ky=new Array(16384);ko(Ky);var wy=Go-(D0.value-A0);if(t0(Qo,c0,D0,wy,Y0,ey,ry),ny>8*(Go-(D0.value-A0)))throw"Something wrong with hufUncompress";m0(ry,Y0,ey,Ky),Wy(ry,Ky,Qo,c0,D0,ny,ey,b0,g0,I0)}function _0(Qo,c0,D0){for(var Go=0;Go<D0;++Go)c0[Go]=Qo[c0[Go]]}function ay(Qo){for(var c0=1;c0<Qo.length;c0++){var D0=Qo[c0-1]+Qo[c0]-128;Qo[c0]=D0}}function J0(Qo,c0){for(var D0=0,Go=Math.floor((Qo.length+1)/2),g0=0,b0=Qo.length-1;!(g0>b0||(c0[g0++]=Qo[D0++],g0>b0));)c0[g0++]=Qo[Go++]}function yy(Qo){for(var c0=Qo.byteLength,D0=new Array,Go=0,g0=new DataView(Qo);c0>0;){var b0=g0.getInt8(Go++);if(b0<0){var I0=-b0;c0-=I0+1;for(var A0=0;A0<I0;A0++)D0.push(g0.getUint8(Go++))}else{var I0=b0;c0-=2;for(var Y0=g0.getUint8(Go++),A0=0;A0<I0+1;A0++)D0.push(Y0)}}return D0}function uy(Qo,c0,D0,Go,g0,b0){var xv=new DataView(b0.buffer),I0=D0[Qo.idx[0]].width,A0=D0[Qo.idx[0]].height,Y0=3,ey=Math.floor(I0/8),ny=Math.ceil(I0/8),ry=Math.ceil(A0/8),Ky=I0-(ny-1)*8,wy=A0-(ry-1)*8,Ry={value:0},Hy=new Array(Y0),uv=new Array(Y0),dv=new Array(Y0),pv=new Array(Y0),Zy=new Array(Y0);for(let Ov=0;Ov<Y0;++Ov)Zy[Ov]=c0[Qo.idx[Ov]],Hy[Ov]=Ov<1?0:Hy[Ov-1]+ny*ry,uv[Ov]=new Float32Array(64),dv[Ov]=new Uint16Array(64),pv[Ov]=new Uint16Array(ny*64);for(let Ov=0;Ov<ry;++Ov){var By=8;Ov==ry-1&&(By=wy);var bv=8;for(let Av=0;Av<ny;++Av){Av==ny-1&&(bv=Ky);for(let zy=0;zy<Y0;++zy)dv[zy].fill(0),dv[zy][0]=g0[Hy[zy]++],Dy(Ry,Go,dv[zy]),Fy(dv[zy],uv[zy]),qy(uv[zy]);rv(uv);for(let zy=0;zy<Y0;++zy)y0(uv[zy],pv[zy],Av*64)}let jy=0;for(let Av=0;Av<Y0;++Av){const zy=D0[Qo.idx[Av]].type;for(let n1=8*Ov;n1<8*Ov+By;++n1){jy=Zy[Av][n1];for(let m1=0;m1<ey;++m1){const i1=m1*64+(n1&7)*8;xv.setUint16(jy+0*2*zy,pv[Av][i1+0],!0),xv.setUint16(jy+1*2*zy,pv[Av][i1+1],!0),xv.setUint16(jy+2*2*zy,pv[Av][i1+2],!0),xv.setUint16(jy+3*2*zy,pv[Av][i1+3],!0),xv.setUint16(jy+4*2*zy,pv[Av][i1+4],!0),xv.setUint16(jy+5*2*zy,pv[Av][i1+5],!0),xv.setUint16(jy+6*2*zy,pv[Av][i1+6],!0),xv.setUint16(jy+7*2*zy,pv[Av][i1+7],!0),jy+=8*2*zy}}if(ey!=ny)for(let n1=8*Ov;n1<8*Ov+By;++n1){const m1=Zy[Av][n1]+8*ey*2*zy,i1=ey*64+(n1&7)*8;for(let S1=0;S1<bv;++S1)xv.setUint16(m1+S1*2*zy,pv[Av][i1+S1],!0)}}}for(var fv=new Uint16Array(I0),xv=new DataView(b0.buffer),t1=0;t1<Y0;++t1){D0[Qo.idx[t1]].decoded=!0;var u1=D0[Qo.idx[t1]].type;if(D0[t1].type==2)for(var c1=0;c1<A0;++c1){const Ov=Zy[t1][c1];for(var Gv=0;Gv<I0;++Gv)fv[Gv]=xv.getUint16(Ov+Gv*2*u1,!0);for(var Gv=0;Gv<I0;++Gv)xv.setFloat32(Ov+Gv*2*u1,v0(fv[Gv]),!0)}}}function Dy(Qo,c0,D0){for(var Go,g0=1;g0<64;)Go=c0[Qo.value],Go==65280?g0=64:Go>>8==255?g0+=Go&255:(D0[g0]=Go,g0++),Qo.value++}function Fy(Qo,c0){c0[0]=v0(Qo[0]),c0[1]=v0(Qo[1]),c0[2]=v0(Qo[5]),c0[3]=v0(Qo[6]),c0[4]=v0(Qo[14]),c0[5]=v0(Qo[15]),c0[6]=v0(Qo[27]),c0[7]=v0(Qo[28]),c0[8]=v0(Qo[2]),c0[9]=v0(Qo[4]),c0[10]=v0(Qo[7]),c0[11]=v0(Qo[13]),c0[12]=v0(Qo[16]),c0[13]=v0(Qo[26]),c0[14]=v0(Qo[29]),c0[15]=v0(Qo[42]),c0[16]=v0(Qo[3]),c0[17]=v0(Qo[8]),c0[18]=v0(Qo[12]),c0[19]=v0(Qo[17]),c0[20]=v0(Qo[25]),c0[21]=v0(Qo[30]),c0[22]=v0(Qo[41]),c0[23]=v0(Qo[43]),c0[24]=v0(Qo[9]),c0[25]=v0(Qo[11]),c0[26]=v0(Qo[18]),c0[27]=v0(Qo[24]),c0[28]=v0(Qo[31]),c0[29]=v0(Qo[40]),c0[30]=v0(Qo[44]),c0[31]=v0(Qo[53]),c0[32]=v0(Qo[10]),c0[33]=v0(Qo[19]),c0[34]=v0(Qo[23]),c0[35]=v0(Qo[32]),c0[36]=v0(Qo[39]),c0[37]=v0(Qo[45]),c0[38]=v0(Qo[52]),c0[39]=v0(Qo[54]),c0[40]=v0(Qo[20]),c0[41]=v0(Qo[22]),c0[42]=v0(Qo[33]),c0[43]=v0(Qo[38]),c0[44]=v0(Qo[46]),c0[45]=v0(Qo[51]),c0[46]=v0(Qo[55]),c0[47]=v0(Qo[60]),c0[48]=v0(Qo[21]),c0[49]=v0(Qo[34]),c0[50]=v0(Qo[37]),c0[51]=v0(Qo[47]),c0[52]=v0(Qo[50]),c0[53]=v0(Qo[56]),c0[54]=v0(Qo[59]),c0[55]=v0(Qo[61]),c0[56]=v0(Qo[35]),c0[57]=v0(Qo[36]),c0[58]=v0(Qo[48]),c0[59]=v0(Qo[49]),c0[60]=v0(Qo[57]),c0[61]=v0(Qo[58]),c0[62]=v0(Qo[62]),c0[63]=v0(Qo[63])}function qy(Qo){const c0=.5*Math.cos(.7853975),D0=.5*Math.cos(3.14159/16),Go=.5*Math.cos(3.14159/8),g0=.5*Math.cos(3*3.14159/16),b0=.5*Math.cos(5*3.14159/16),I0=.5*Math.cos(3*3.14159/8),A0=.5*Math.cos(7*3.14159/16);for(var Y0=new Array(4),ey=new Array(4),ny=new Array(4),ry=new Array(4),Ky=0;Ky<8;++Ky){var wy=Ky*8;Y0[0]=Go*Qo[wy+2],Y0[1]=I0*Qo[wy+2],Y0[2]=Go*Qo[wy+6],Y0[3]=I0*Qo[wy+6],ey[0]=D0*Qo[wy+1]+g0*Qo[wy+3]+b0*Qo[wy+5]+A0*Qo[wy+7],ey[1]=g0*Qo[wy+1]-A0*Qo[wy+3]-D0*Qo[wy+5]-b0*Qo[wy+7],ey[2]=b0*Qo[wy+1]-D0*Qo[wy+3]+A0*Qo[wy+5]+g0*Qo[wy+7],ey[3]=A0*Qo[wy+1]-b0*Qo[wy+3]+g0*Qo[wy+5]-D0*Qo[wy+7],ny[0]=c0*(Qo[wy+0]+Qo[wy+4]),ny[3]=c0*(Qo[wy+0]-Qo[wy+4]),ny[1]=Y0[0]+Y0[3],ny[2]=Y0[1]-Y0[2],ry[0]=ny[0]+ny[1],ry[1]=ny[3]+ny[2],ry[2]=ny[3]-ny[2],ry[3]=ny[0]-ny[1],Qo[wy+0]=ry[0]+ey[0],Qo[wy+1]=ry[1]+ey[1],Qo[wy+2]=ry[2]+ey[2],Qo[wy+3]=ry[3]+ey[3],Qo[wy+4]=ry[3]-ey[3],Qo[wy+5]=ry[2]-ey[2],Qo[wy+6]=ry[1]-ey[1],Qo[wy+7]=ry[0]-ey[0]}for(var Ry=0;Ry<8;++Ry)Y0[0]=Go*Qo[16+Ry],Y0[1]=I0*Qo[16+Ry],Y0[2]=Go*Qo[48+Ry],Y0[3]=I0*Qo[48+Ry],ey[0]=D0*Qo[8+Ry]+g0*Qo[24+Ry]+b0*Qo[40+Ry]+A0*Qo[56+Ry],ey[1]=g0*Qo[8+Ry]-A0*Qo[24+Ry]-D0*Qo[40+Ry]-b0*Qo[56+Ry],ey[2]=b0*Qo[8+Ry]-D0*Qo[24+Ry]+A0*Qo[40+Ry]+g0*Qo[56+Ry],ey[3]=A0*Qo[8+Ry]-b0*Qo[24+Ry]+g0*Qo[40+Ry]-D0*Qo[56+Ry],ny[0]=c0*(Qo[Ry]+Qo[32+Ry]),ny[3]=c0*(Qo[Ry]-Qo[32+Ry]),ny[1]=Y0[0]+Y0[3],ny[2]=Y0[1]-Y0[2],ry[0]=ny[0]+ny[1],ry[1]=ny[3]+ny[2],ry[2]=ny[3]-ny[2],ry[3]=ny[0]-ny[1],Qo[0+Ry]=ry[0]+ey[0],Qo[8+Ry]=ry[1]+ey[1],Qo[16+Ry]=ry[2]+ey[2],Qo[24+Ry]=ry[3]+ey[3],Qo[32+Ry]=ry[3]-ey[3],Qo[40+Ry]=ry[2]-ey[2],Qo[48+Ry]=ry[1]-ey[1],Qo[56+Ry]=ry[0]-ey[0]}function rv(Qo){for(var c0=0;c0<64;++c0){var D0=Qo[0][c0],Go=Qo[1][c0],g0=Qo[2][c0];Qo[0][c0]=D0+1.5747*g0,Qo[1][c0]=D0-.1873*Go-.4682*g0,Qo[2][c0]=D0+1.8556*Go}}function y0(Qo,c0,D0){for(var Go=0;Go<64;++Go)c0[D0+Go]=DataUtils.toHalfFloat(r0(Qo[Go]))}function r0(Qo){return Qo<=1?Math.sign(Qo)*Math.pow(Math.abs(Qo),2.2):Math.sign(Qo)*Math.pow(Xo,Math.abs(Qo)-1)}function M0(Qo){return new DataView(Qo.array.buffer,Qo.offset.value,Qo.size)}function G0(Qo){var c0=Qo.viewer.buffer.slice(Qo.offset.value,Qo.offset.value+Qo.size),D0=new Uint8Array(yy(c0)),Go=new Uint8Array(D0.length);return ay(D0),J0(D0,Go),new DataView(Go.buffer)}function sy(Qo){var c0=Qo.array.slice(Qo.offset.value,Qo.offset.value+Qo.size),D0=unzlibSync(c0),Go=new Uint8Array(D0.length);return ay(D0),J0(D0,Go),new DataView(Go.buffer)}function dy(Qo){for(var c0=Qo.viewer,D0={value:Qo.offset.value},Go=new Uint16Array(Qo.width*Qo.scanlineBlockSize*(Qo.channels*Qo.type)),g0=new Uint8Array(8192),b0=0,I0=new Array(Qo.channels),A0=0;A0<Qo.channels;A0++)I0[A0]={},I0[A0].start=b0,I0[A0].end=I0[A0].start,I0[A0].nx=Qo.width,I0[A0].ny=Qo.lines,I0[A0].size=Qo.type,b0+=I0[A0].nx*I0[A0].ny*I0[A0].size;var Y0=i0(c0,D0),ey=i0(c0,D0);if(ey>=8192)throw"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";if(Y0<=ey)for(var A0=0;A0<ey-Y0+1;A0++)g0[A0+Y0]=C0(c0,D0);var ny=new Uint16Array(65536),ry=Kr(g0,ny),Ky=Qy(c0,D0);Ey(Qo.array,c0,D0,Ky,Go,b0);for(var A0=0;A0<Qo.channels;++A0)for(var wy=I0[A0],Ry=0;Ry<I0[A0].size;++Ry)My(Go,wy.start+Ry,wy.nx,wy.size,wy.ny,wy.nx*wy.size,ry);_0(ny,Go,b0);for(var Hy=0,uv=new Uint8Array(Go.buffer.byteLength),dv=0;dv<Qo.lines;dv++)for(var pv=0;pv<Qo.channels;pv++){var wy=I0[pv],Zy=wy.nx*wy.size,By=new Uint8Array(Go.buffer,wy.end*2,Zy*2);uv.set(By,Hy),Hy+=Zy*2,wy.end+=Zy}return new DataView(uv.buffer)}function Vy(Qo){var c0=Qo.array.slice(Qo.offset.value,Qo.offset.value+Qo.size),D0=unzlibSync(c0);const Go=Qo.lines*Qo.channels*Qo.width,g0=Qo.type==1?new Uint16Array(Go):new Uint32Array(Go);let b0=0,I0=0;const A0=new Array(4);for(let Y0=0;Y0<Qo.lines;Y0++)for(let ey=0;ey<Qo.channels;ey++){let ny=0;switch(Qo.type){case 1:A0[0]=b0,A0[1]=A0[0]+Qo.width,b0=A0[1]+Qo.width;for(let ry=0;ry<Qo.width;++ry){const Ky=D0[A0[0]++]<<8|D0[A0[1]++];ny+=Ky,g0[I0]=ny,I0++}break;case 2:A0[0]=b0,A0[1]=A0[0]+Qo.width,A0[2]=A0[1]+Qo.width,b0=A0[2]+Qo.width;for(let ry=0;ry<Qo.width;++ry){const Ky=D0[A0[0]++]<<24|D0[A0[1]++]<<16|D0[A0[2]++]<<8;ny+=Ky,g0[I0]=ny,I0++}break}}return new DataView(g0.buffer)}function Xy(Qo){var c0=Qo.viewer,D0={value:Qo.offset.value},Go=new Uint8Array(Qo.width*Qo.lines*(Qo.channels*Qo.type*2)),g0={version:U0(c0,D0),unknownUncompressedSize:U0(c0,D0),unknownCompressedSize:U0(c0,D0),acCompressedSize:U0(c0,D0),dcCompressedSize:U0(c0,D0),rleCompressedSize:U0(c0,D0),rleUncompressedSize:U0(c0,D0),rleRawSize:U0(c0,D0),totalAcUncompressedCount:U0(c0,D0),totalDcUncompressedCount:U0(c0,D0),acCompression:U0(c0,D0)};if(g0.version<2)throw"EXRLoader.parse: "+g1.compression+" version "+g0.version+" is unsupported";for(var b0=new Array,I0=i0(c0,D0)-2;I0>0;){var A0=hy(c0.buffer,D0),Y0=C0(c0,D0),ey=Y0>>2&3,ny=(Y0>>4)-1,ry=new Int8Array([ny])[0],Ky=C0(c0,D0);b0.push({name:A0,index:ry,type:Ky,compression:ey}),I0-=A0.length+3}for(var wy=g1.channels,Ry=new Array(Qo.channels),Hy=0;Hy<Qo.channels;++Hy){var uv=Ry[Hy]={},dv=wy[Hy];uv.name=dv.name,uv.compression=0,uv.decoded=!1,uv.type=dv.pixelType,uv.pLinear=dv.pLinear,uv.width=Qo.width,uv.height=Qo.lines}for(var pv={idx:new Array(3)},Zy=0;Zy<Qo.channels;++Zy)for(var uv=Ry[Zy],Hy=0;Hy<b0.length;++Hy){var By=b0[Hy];uv.name==By.name&&(uv.compression=By.compression,By.index>=0&&(pv.idx[By.index]=Zy),uv.offset=Zy)}if(g0.acCompressedSize>0)switch(g0.acCompression){case 0:var xv=new Uint16Array(g0.totalAcUncompressedCount);Ey(Qo.array,c0,D0,g0.acCompressedSize,xv,g0.totalAcUncompressedCount);break;case 1:var bv=Qo.array.slice(D0.value,D0.value+g0.totalAcUncompressedCount),fv=unzlibSync(bv),xv=new Uint16Array(fv.buffer);D0.value+=g0.totalAcUncompressedCount;break}if(g0.dcCompressedSize>0){var t1={array:Qo.array,offset:D0,size:g0.dcCompressedSize},u1=new Uint16Array(sy(t1).buffer);D0.value+=g0.dcCompressedSize}if(g0.rleRawSize>0){var bv=Qo.array.slice(D0.value,D0.value+g0.rleCompressedSize),fv=unzlibSync(bv),c1=yy(fv.buffer);D0.value+=g0.rleCompressedSize}for(var Gv=0,Ov=new Array(Ry.length),Hy=0;Hy<Ov.length;++Hy)Ov[Hy]=new Array;for(var jy=0;jy<Qo.lines;++jy)for(var Av=0;Av<Ry.length;++Av)Ov[Av].push(Gv),Gv+=Ry[Av].width*Qo.type*2;uy(pv,Ov,Ry,xv,u1,Go);for(var Hy=0;Hy<Ry.length;++Hy){var uv=Ry[Hy];if(!uv.decoded)switch(uv.compression){case 2:for(var zy=0,n1=0,jy=0;jy<Qo.lines;++jy){for(var m1=Ov[Hy][zy],i1=0;i1<uv.width;++i1){for(var S1=0;S1<2*uv.type;++S1)Go[m1++]=c1[n1+S1*uv.width*uv.height];n1++}zy++}break;case 1:default:throw"EXRLoader.parse: unsupported channel compression"}}return new DataView(Go.buffer)}function hy(Qo,c0){for(var D0=new Uint8Array(Qo),Go=0;D0[c0.value+Go]!=0;)Go+=1;var g0=new TextDecoder().decode(D0.slice(c0.value,c0.value+Go));return c0.value=c0.value+Go+1,g0}function Ly(Qo,c0,D0){var Go=new TextDecoder().decode(new Uint8Array(Qo).slice(c0.value,c0.value+D0));return c0.value=c0.value+D0,Go}function Py(Qo,c0){var D0=Ev(Qo,c0),Go=Qy(Qo,c0);return[D0,Go]}function Sy(Qo,c0){var D0=Qy(Qo,c0),Go=Qy(Qo,c0);return[D0,Go]}function Ev(Qo,c0){var D0=Qo.getInt32(c0.value,!0);return c0.value=c0.value+4,D0}function Qy(Qo,c0){var D0=Qo.getUint32(c0.value,!0);return c0.value=c0.value+4,D0}function cy(Qo,c0){var D0=Qo[c0.value];return c0.value=c0.value+1,D0}function C0(Qo,c0){var D0=Qo.getUint8(c0.value);return c0.value=c0.value+1,D0}const U0=function(Qo,c0){let D0;return"getBigInt64"in DataView.prototype?D0=Number(Qo.getBigInt64(c0.value,!0)):D0=Qo.getUint32(c0.value+4,!0)+Number(Qo.getUint32(c0.value,!0)<<32),c0.value+=8,D0};function xy(Qo,c0){var D0=Qo.getFloat32(c0.value,!0);return c0.value+=4,D0}function o0(Qo,c0){return DataUtils.toHalfFloat(xy(Qo,c0))}function v0(Qo){var c0=(Qo&31744)>>10,D0=Qo&1023;return(Qo>>15?-1:1)*(c0?c0===31?D0?NaN:1/0:Math.pow(2,c0-15)*(1+D0/1024):6103515625e-14*(D0/1024))}function i0(Qo,c0){var D0=Qo.getUint16(c0.value,!0);return c0.value+=2,D0}function k0(Qo,c0){return v0(i0(Qo,c0))}function $0(Qo,c0,D0,Go){for(var g0=D0.value,b0=[];D0.value<g0+Go-1;){var I0=hy(c0,D0),A0=Ev(Qo,D0),Y0=C0(Qo,D0);D0.value+=3;var ey=Ev(Qo,D0),ny=Ev(Qo,D0);b0.push({name:I0,pixelType:A0,pLinear:Y0,xSampling:ey,ySampling:ny})}return D0.value+=1,b0}function ty(Qo,c0){var D0=xy(Qo,c0),Go=xy(Qo,c0),g0=xy(Qo,c0),b0=xy(Qo,c0),I0=xy(Qo,c0),A0=xy(Qo,c0),Y0=xy(Qo,c0),ey=xy(Qo,c0);return{redX:D0,redY:Go,greenX:g0,greenY:b0,blueX:I0,blueY:A0,whiteX:Y0,whiteY:ey}}function my(Qo,c0){var D0=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],Go=C0(Qo,c0);return D0[Go]}function ev(Qo,c0){var D0=Qy(Qo,c0),Go=Qy(Qo,c0),g0=Qy(Qo,c0),b0=Qy(Qo,c0);return{xMin:D0,yMin:Go,xMax:g0,yMax:b0}}function vv(Qo,c0){var D0=["INCREASING_Y"],Go=C0(Qo,c0);return D0[Go]}function Tv(Qo,c0){var D0=xy(Qo,c0),Go=xy(Qo,c0);return[D0,Go]}function Rv(Qo,c0){var D0=xy(Qo,c0),Go=xy(Qo,c0),g0=xy(Qo,c0);return[D0,Go,g0]}function Lv(Qo,c0,D0,Go,g0){if(Go==="string"||Go==="stringvector"||Go==="iccProfile")return Ly(c0,D0,g0);if(Go==="chlist")return $0(Qo,c0,D0,g0);if(Go==="chromaticities")return ty(Qo,D0);if(Go==="compression")return my(Qo,D0);if(Go==="box2i")return ev(Qo,D0);if(Go==="lineOrder")return vv(Qo,D0);if(Go==="float")return xy(Qo,D0);if(Go==="v2f")return Tv(Qo,D0);if(Go==="v3f")return Rv(Qo,D0);if(Go==="int")return Ev(Qo,D0);if(Go==="rational")return Py(Qo,D0);if(Go==="timecode")return Sy(Qo,D0);if(Go==="preview")return D0.value+=g0,"skipped";D0.value+=g0}function Yv(Qo,c0,D0){const Go={};if(Qo.getUint32(0,!0)!=20000630)throw"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";Go.version=Qo.getUint8(4);const g0=Qo.getUint8(5);Go.spec={singleTile:!!(g0&2),longName:!!(g0&4),deepFormat:!!(g0&8),multiPart:!!(g0&16)},D0.value=8;for(var b0=!0;b0;){var I0=hy(c0,D0);if(I0==0)b0=!1;else{var A0=hy(c0,D0),Y0=Qy(Qo,D0),ey=Lv(Qo,c0,D0,A0,Y0);ey===void 0?console.warn(`EXRLoader.parse: skipped unknown header attribute type '${A0}'.`):Go[I0]=ey}}if(g0&-5)throw console.error("EXRHeader:",Go),"THREE.EXRLoader: provided file is currently unsupported.";return Go}function X0(Qo,c0,D0,Go,g0){const b0={size:0,viewer:c0,array:D0,offset:Go,width:Qo.dataWindow.xMax-Qo.dataWindow.xMin+1,height:Qo.dataWindow.yMax-Qo.dataWindow.yMin+1,channels:Qo.channels.length,bytesPerLine:null,lines:null,inputSize:null,type:Qo.channels[0].pixelType,uncompress:null,getter:null,format:null,[hasColorSpace?"colorSpace":"encoding"]:null};switch(Qo.compression){case"NO_COMPRESSION":b0.lines=1,b0.uncompress=M0;break;case"RLE_COMPRESSION":b0.lines=1,b0.uncompress=G0;break;case"ZIPS_COMPRESSION":b0.lines=1,b0.uncompress=sy;break;case"ZIP_COMPRESSION":b0.lines=16,b0.uncompress=sy;break;case"PIZ_COMPRESSION":b0.lines=32,b0.uncompress=dy;break;case"PXR24_COMPRESSION":b0.lines=16,b0.uncompress=Vy;break;case"DWAA_COMPRESSION":b0.lines=32,b0.uncompress=Xy;break;case"DWAB_COMPRESSION":b0.lines=256,b0.uncompress=Xy;break;default:throw"EXRLoader.parse: "+Qo.compression+" is unsupported"}if(b0.scanlineBlockSize=b0.lines,b0.type==1)switch(g0){case FloatType:b0.getter=k0,b0.inputSize=2;break;case HalfFloatType:b0.getter=i0,b0.inputSize=2;break}else if(b0.type==2)switch(g0){case FloatType:b0.getter=xy,b0.inputSize=4;break;case HalfFloatType:b0.getter=o0,b0.inputSize=4}else throw"EXRLoader.parse: unsupported pixelType "+b0.type+" for "+Qo.compression+".";b0.blockCount=(Qo.dataWindow.yMax+1)/b0.scanlineBlockSize;for(var I0=0;I0<b0.blockCount;I0++)U0(c0,Go);b0.outputChannels=b0.channels==3?4:b0.channels;const A0=b0.width*b0.height*b0.outputChannels;switch(g0){case FloatType:b0.byteArray=new Float32Array(A0),b0.channels<b0.outputChannels&&b0.byteArray.fill(1,0,A0);break;case HalfFloatType:b0.byteArray=new Uint16Array(A0),b0.channels<b0.outputChannels&&b0.byteArray.fill(15360,0,A0);break;default:console.error("THREE.EXRLoader: unsupported type: ",g0);break}return b0.bytesPerLine=b0.width*b0.inputSize*b0.channels,b0.outputChannels==4?b0.format=RGBAFormat:b0.format=RedFormat,hasColorSpace?b0.colorSpace="srgb-linear":b0.encoding=3e3,b0}const Pv=new DataView(at),Fv=new Uint8Array(at),Jv={value:0},g1=Yv(Pv,at,Jv),_v=X0(g1,Pv,Fv,Jv,this.type),Y1={value:0},c_={R:0,G:1,B:2,A:3,Y:0};for(let Qo=0;Qo<_v.height/_v.scanlineBlockSize;Qo++){const c0=Qy(Pv,Jv);_v.size=Qy(Pv,Jv),_v.lines=c0+_v.scanlineBlockSize>_v.height?_v.height-c0:_v.scanlineBlockSize;const Go=_v.size<_v.lines*_v.bytesPerLine?_v.uncompress(_v):M0(_v);Jv.value+=_v.size;for(let g0=0;g0<_v.scanlineBlockSize;g0++){const b0=g0+Qo*_v.scanlineBlockSize;if(b0>=_v.height)break;for(let I0=0;I0<_v.channels;I0++){const A0=c_[g1.channels[I0].name];for(let Y0=0;Y0<_v.width;Y0++){Y1.value=(g0*(_v.channels*_v.width)+I0*_v.width+Y0)*_v.inputSize;const ey=(_v.height-1-b0)*(_v.width*_v.outputChannels)+Y0*_v.outputChannels+A0;_v.byteArray[ey]=_v.getter(Go,Y1)}}}}return{header:g1,width:_v.width,height:_v.height,data:_v.byteArray,format:_v.format,[hasColorSpace?"colorSpace":"encoding"]:_v[hasColorSpace?"colorSpace":"encoding"],type:this.type}}setDataType(at){return this.type=at,this}load(at,pt,vt,wt){function $t(Tt,Lt){hasColorSpace?Tt.colorSpace=Lt.colorSpace:Tt.encoding=Lt.encoding,Tt.minFilter=LinearFilter,Tt.magFilter=LinearFilter,Tt.generateMipmaps=!1,Tt.flipY=!1,pt&&pt(Tt,Lt)}return super.load(at,$t,vt,wt)}}const _taskCache=new WeakMap;class DRACOLoader extends Loader{constructor(at){super(at),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(at){return this.decoderPath=at,this}setDecoderConfig(at){return this.decoderConfig=at,this}setWorkerLimit(at){return this.workerLimit=at,this}load(at,pt,vt,wt){const $t=new FileLoader(this.manager);$t.setPath(this.path),$t.setResponseType("arraybuffer"),$t.setRequestHeader(this.requestHeader),$t.setWithCredentials(this.withCredentials),$t.load(at,Tt=>{const Lt={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(Tt,Lt).then(pt).catch(wt)},vt,wt)}decodeDracoFile(at,pt,vt,wt){const $t={attributeIDs:vt||this.defaultAttributeIDs,attributeTypes:wt||this.defaultAttributeTypes,useUniqueIDs:!!vt};this.decodeGeometry(at,$t).then(pt)}decodeGeometry(at,pt){for(const Ft in pt.attributeTypes){const Ct=pt.attributeTypes[Ft];Ct.BYTES_PER_ELEMENT!==void 0&&(pt.attributeTypes[Ft]=Ct.name)}const vt=JSON.stringify(pt);if(_taskCache.has(at)){const Ft=_taskCache.get(at);if(Ft.key===vt)return Ft.promise;if(at.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let wt;const $t=this.workerNextTaskID++,Tt=at.byteLength,Lt=this._getWorker($t,Tt).then(Ft=>(wt=Ft,new Promise((Ct,Ht)=>{wt._callbacks[$t]={resolve:Ct,reject:Ht},wt.postMessage({type:"decode",id:$t,taskConfig:pt,buffer:at},[at])}))).then(Ft=>this._createGeometry(Ft.geometry));return Lt.catch(()=>!0).then(()=>{wt&&$t&&this._releaseTask(wt,$t)}),_taskCache.set(at,{key:vt,promise:Lt}),Lt}_createGeometry(at){const pt=new BufferGeometry;at.index&&pt.setIndex(new BufferAttribute(at.index.array,1));for(let vt=0;vt<at.attributes.length;vt++){const wt=at.attributes[vt],$t=wt.name,Tt=wt.array,Lt=wt.itemSize;pt.setAttribute($t,new BufferAttribute(Tt,Lt))}return pt}_loadLibrary(at,pt){const vt=new FileLoader(this.manager);return vt.setPath(this.decoderPath),vt.setResponseType(pt),vt.setWithCredentials(this.withCredentials),new Promise((wt,$t)=>{vt.load(at,wt,void 0,$t)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const at=typeof WebAssembly!="object"||this.decoderConfig.type==="js",pt=[];return at?pt.push(this._loadLibrary("draco_decoder.js","text")):(pt.push(this._loadLibrary("draco_wasm_wrapper.js","text")),pt.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(pt).then(vt=>{const wt=vt[0];at||(this.decoderConfig.wasmBinary=vt[1]);const $t=DRACOWorker.toString(),Tt=["/* draco decoder */",wt,"","/* worker */",$t.substring($t.indexOf("{")+1,$t.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([Tt]))}),this.decoderPending}_getWorker(at,pt){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const wt=new Worker(this.workerSourceURL);wt._callbacks={},wt._taskCosts={},wt._taskLoad=0,wt.postMessage({type:"init",decoderConfig:this.decoderConfig}),wt.onmessage=function($t){const Tt=$t.data;switch(Tt.type){case"decode":wt._callbacks[Tt.id].resolve(Tt);break;case"error":wt._callbacks[Tt.id].reject(Tt);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+Tt.type+'"')}},this.workerPool.push(wt)}else this.workerPool.sort(function(wt,$t){return wt._taskLoad>$t._taskLoad?-1:1});const vt=this.workerPool[this.workerPool.length-1];return vt._taskCosts[at]=pt,vt._taskLoad+=pt,vt})}_releaseTask(at,pt){at._taskLoad-=at._taskCosts[pt],delete at._callbacks[pt],delete at._taskCosts[pt]}debug(){console.log("Task load: ",this.workerPool.map(at=>at._taskLoad))}dispose(){for(let at=0;at<this.workerPool.length;++at)this.workerPool[at].terminate();return this.workerPool.length=0,this}}function DRACOWorker(){let st,at;onmessage=function(Tt){const Lt=Tt.data;switch(Lt.type){case"init":st=Lt.decoderConfig,at=new Promise(function(Ht){st.onModuleLoaded=function(Gt){Ht({draco:Gt})},DracoDecoderModule(st)});break;case"decode":const Ft=Lt.buffer,Ct=Lt.taskConfig;at.then(Ht=>{const Gt=Ht.draco,jt=new Gt.Decoder,qt=new Gt.DecoderBuffer;qt.Init(new Int8Array(Ft),Ft.byteLength);try{const Kt=pt(Gt,jt,qt,Ct),An=Kt.attributes.map(Sn=>Sn.array.buffer);Kt.index&&An.push(Kt.index.array.buffer),self.postMessage({type:"decode",id:Lt.id,geometry:Kt},An)}catch(Kt){console.error(Kt),self.postMessage({type:"error",id:Lt.id,error:Kt.message})}finally{Gt.destroy(qt),Gt.destroy(jt)}});break}};function pt(Tt,Lt,Ft,Ct){const Ht=Ct.attributeIDs,Gt=Ct.attributeTypes;let jt,qt;const Kt=Lt.GetEncodedGeometryType(Ft);if(Kt===Tt.TRIANGULAR_MESH)jt=new Tt.Mesh,qt=Lt.DecodeBufferToMesh(Ft,jt);else if(Kt===Tt.POINT_CLOUD)jt=new Tt.PointCloud,qt=Lt.DecodeBufferToPointCloud(Ft,jt);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!qt.ok()||jt.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+qt.error_msg());const An={index:null,attributes:[]};for(const Sn in Ht){const wn=self[Gt[Sn]];let In,tr;if(Ct.useUniqueIDs)tr=Ht[Sn],In=Lt.GetAttributeByUniqueId(jt,tr);else{if(tr=Lt.GetAttributeId(jt,Tt[Ht[Sn]]),tr===-1)continue;In=Lt.GetAttribute(jt,tr)}An.attributes.push(wt(Tt,Lt,jt,Sn,wn,In))}return Kt===Tt.TRIANGULAR_MESH&&(An.index=vt(Tt,Lt,jt)),Tt.destroy(jt),An}function vt(Tt,Lt,Ft){const Ht=Ft.num_faces()*3,Gt=Ht*4,jt=Tt._malloc(Gt);Lt.GetTrianglesUInt32Array(Ft,Gt,jt);const qt=new Uint32Array(Tt.HEAPF32.buffer,jt,Ht).slice();return Tt._free(jt),{array:qt,itemSize:1}}function wt(Tt,Lt,Ft,Ct,Ht,Gt){const jt=Gt.num_components(),Kt=Ft.num_points()*jt,An=Kt*Ht.BYTES_PER_ELEMENT,Sn=$t(Tt,Ht),wn=Tt._malloc(An);Lt.GetAttributeDataArrayForAllPoints(Ft,Gt,Sn,An,wn);const In=new Ht(Tt.HEAPF32.buffer,wn,Kt).slice();return Tt._free(wn),{name:Ct,array:In,itemSize:jt}}function $t(Tt,Lt){switch(Lt){case Float32Array:return Tt.DT_FLOAT32;case Int8Array:return Tt.DT_INT8;case Int16Array:return Tt.DT_INT16;case Int32Array:return Tt.DT_INT32;case Uint8Array:return Tt.DT_UINT8;case Uint16Array:return Tt.DT_UINT16;case Uint32Array:return Tt.DT_UINT32}}}let generated;const MeshoptDecoder=()=>{if(generated)return generated;const st="B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",at="B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",pt=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),vt=new Uint8Array([32,0,65,253,3,1,2,34,4,106,6,5,11,8,7,20,13,33,12,16,128,9,116,64,19,113,127,15,10,21,22,14,255,66,24,54,136,107,18,23,192,26,114,118,132,17,77,101,130,144,27,87,131,44,45,74,156,154,70,167]);if(typeof WebAssembly!="object")return{supported:!1};let wt=st;WebAssembly.validate(pt)&&(wt=at);let $t;const Tt=WebAssembly.instantiate(Lt(wt),{}).then(Gt=>{$t=Gt.instance,$t.exports.__wasm_call_ctors()});function Lt(Gt){const jt=new Uint8Array(Gt.length);for(let Kt=0;Kt<Gt.length;++Kt){const An=Gt.charCodeAt(Kt);jt[Kt]=An>96?An-71:An>64?An-65:An>47?An+4:An>46?63:62}let qt=0;for(let Kt=0;Kt<Gt.length;++Kt)jt[qt++]=jt[Kt]<60?vt[jt[Kt]]:(jt[Kt]-60)*64+jt[++Kt];return jt.buffer.slice(0,qt)}function Ft(Gt,jt,qt,Kt,An,Sn){const wn=$t.exports.sbrk,In=qt+3&-4,tr=wn(In*Kt),rr=wn(An.length),Hr=new Uint8Array($t.exports.memory.buffer);Hr.set(An,rr);const qr=Gt(tr,qt,Kt,rr,An.length);if(qr===0&&Sn&&Sn(tr,In,Kt),jt.set(Hr.subarray(tr,tr+qt*Kt)),wn(tr-wn(0)),qr!==0)throw new Error(`Malformed buffer data: ${qr}`)}const Ct={0:"",1:"meshopt_decodeFilterOct",2:"meshopt_decodeFilterQuat",3:"meshopt_decodeFilterExp",NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},Ht={0:"meshopt_decodeVertexBuffer",1:"meshopt_decodeIndexBuffer",2:"meshopt_decodeIndexSequence",ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"};return generated={ready:Tt,supported:!0,decodeVertexBuffer(Gt,jt,qt,Kt,An){Ft($t.exports.meshopt_decodeVertexBuffer,Gt,jt,qt,Kt,$t.exports[Ct[An]])},decodeIndexBuffer(Gt,jt,qt,Kt){Ft($t.exports.meshopt_decodeIndexBuffer,Gt,jt,qt,Kt)},decodeIndexSequence(Gt,jt,qt,Kt){Ft($t.exports.meshopt_decodeIndexSequence,Gt,jt,qt,Kt)},decodeGltfBuffer(Gt,jt,qt,Kt,An,Sn){Ft($t.exports[Ht[An]],Gt,jt,qt,Kt,$t.exports[Ct[Sn]])}},generated};function shallow(st,at){if(Object.is(st,at))return!0;if(typeof st!="object"||st===null||typeof at!="object"||at===null)return!1;const pt=Object.keys(st);if(pt.length!==Object.keys(at).length)return!1;for(let vt=0;vt<pt.length;vt++)if(!Object.prototype.hasOwnProperty.call(at,pt[vt])||!Object.is(st[pt[vt]],at[pt[vt]]))return!1;return!0}const IsObject=st=>st===Object(st)&&!Array.isArray(st)&&typeof st!="function";function useTexture(st,at){const pt=useThree($t=>$t.gl),vt=useLoader(TextureLoader,IsObject(st)?Object.values(st):st);return reactExports.useLayoutEffect(()=>{at==null||at(vt)},[at]),reactExports.useEffect(()=>{if("initTexture"in pt){let $t=[];Array.isArray(vt)?$t=vt:vt instanceof Texture?$t=[vt]:IsObject(vt)&&($t=Object.values(vt)),$t.forEach(Tt=>{Tt instanceof Texture&&pt.initTexture(Tt)})}},[pt,vt]),reactExports.useMemo(()=>{if(IsObject(st)){const $t={};let Tt=0;for(const Lt in st)$t[Lt]=vt[Tt++];return $t}else return vt},[st,vt])}useTexture.preload=st=>useLoader.preload(TextureLoader,st);useTexture.clear=st=>useLoader.clear(TextureLoader,st);const getVersion=()=>parseInt(REVISION.replace(/\D+/g,"")),version=getVersion();let dracoLoader=null,decoderPath="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function extensions(st,at,pt){return vt=>{pt&&pt(vt),st&&(dracoLoader||(dracoLoader=new DRACOLoader),dracoLoader.setDecoderPath(typeof st=="string"?st:decoderPath),vt.setDRACOLoader(dracoLoader)),at&&vt.setMeshoptDecoder(typeof MeshoptDecoder=="function"?MeshoptDecoder():MeshoptDecoder)}}function useGLTF(st,at=!0,pt=!0,vt){return useLoader(GLTFLoader,st,extensions(at,pt,vt))}useGLTF.preload=(st,at=!0,pt=!0,vt)=>useLoader.preload(GLTFLoader,st,extensions(at,pt,vt));useGLTF.clear=st=>useLoader.clear(GLTFLoader,st);useGLTF.setDecoderPath=st=>{decoderPath=st};const OrbitControls=reactExports.forwardRef(({makeDefault:st,camera:at,regress:pt,domElement:vt,enableDamping:wt=!0,keyEvents:$t=!1,onChange:Tt,onStart:Lt,onEnd:Ft,...Ct},Ht)=>{const Gt=useThree(qr=>qr.invalidate),jt=useThree(qr=>qr.camera),qt=useThree(qr=>qr.gl),Kt=useThree(qr=>qr.events),An=useThree(qr=>qr.setEvents),Sn=useThree(qr=>qr.set),wn=useThree(qr=>qr.get),In=useThree(qr=>qr.performance),tr=at||jt,rr=vt||Kt.connected||qt.domElement,Hr=reactExports.useMemo(()=>new OrbitControls$1(tr),[tr]);return useFrame(()=>{Hr.enabled&&Hr.update()},-1),reactExports.useEffect(()=>($t&&Hr.connect($t===!0?rr:$t),Hr.connect(rr),()=>void Hr.dispose()),[$t,rr,pt,Hr,Gt]),reactExports.useEffect(()=>{const qr=Xo=>{Gt(),pt&&In.regress(),Tt&&Tt(Xo)},Zr=Xo=>{Lt&&Lt(Xo)},Bo=Xo=>{Ft&&Ft(Xo)};return Hr.addEventListener("change",qr),Hr.addEventListener("start",Zr),Hr.addEventListener("end",Bo),()=>{Hr.removeEventListener("start",Zr),Hr.removeEventListener("end",Bo),Hr.removeEventListener("change",qr)}},[Tt,Lt,Ft,Hr,Gt,An]),reactExports.useEffect(()=>{if(st){const qr=wn().controls;return Sn({controls:Hr}),()=>Sn({controls:qr})}},[st,Hr]),reactExports.createElement("primitive",_extends$1({ref:Ht,object:Hr,enableDamping:wt},Ct))}),Center=reactExports.forwardRef(function({children:at,disable:pt,disableX:vt,disableY:wt,disableZ:$t,left:Tt,right:Lt,top:Ft,bottom:Ct,front:Ht,back:Gt,onCentered:jt,precise:qt=!0,cacheKey:Kt=0,...An},Sn){const wn=reactExports.useRef(null),In=reactExports.useRef(null),tr=reactExports.useRef(null);return reactExports.useLayoutEffect(()=>{In.current.matrixWorld.identity();const rr=new Box3().setFromObject(tr.current,qt),Hr=new Vector3,qr=new Sphere,Zr=rr.max.x-rr.min.x,Bo=rr.max.y-rr.min.y,Xo=rr.max.z-rr.min.z;rr.getCenter(Hr),rr.getBoundingSphere(qr);const Kr=Ft?Bo/2:Ct?-Bo/2:0,ko=Tt?-Zr/2:Lt?Zr/2:0,f0=Ht?Xo/2:Gt?-Xo/2:0;In.current.position.set(pt||vt?0:-Hr.x+ko,pt||wt?0:-Hr.y+Kr,pt||$t?0:-Hr.z+f0),typeof jt<"u"&&jt({parent:wn.current.parent,container:wn.current,width:Zr,height:Bo,depth:Xo,boundingBox:rr,boundingSphere:qr,center:Hr,verticalAlignment:Kr,horizontalAlignment:ko,depthAlignment:f0})},[Kt,jt,Ft,Tt,Ht,pt,vt,wt,$t,qt,Lt,Ct,Gt]),reactExports.useImperativeHandle(Sn,()=>wn.current,[]),reactExports.createElement("group",_extends$1({ref:wn},An),reactExports.createElement("group",{ref:In},reactExports.createElement("group",{ref:tr},at)))});var propTypes={exports:{}},ReactPropTypesSecret$1="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",ReactPropTypesSecret_1=ReactPropTypesSecret$1,ReactPropTypesSecret=ReactPropTypesSecret_1;function emptyFunction(){}function emptyFunctionWithReset(){}emptyFunctionWithReset.resetWarningCache=emptyFunction;var factoryWithThrowingShims=function(){function st(vt,wt,$t,Tt,Lt,Ft){if(Ft!==ReactPropTypesSecret){var Ct=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw Ct.name="Invariant Violation",Ct}}st.isRequired=st;function at(){return st}var pt={array:st,bigint:st,bool:st,func:st,number:st,object:st,string:st,symbol:st,any:st,arrayOf:at,element:st,elementType:st,instanceOf:at,node:st,objectOf:at,oneOf:at,oneOfType:at,shape:at,exact:at,checkPropTypes:emptyFunctionWithReset,resetWarningCache:emptyFunction};return pt.PropTypes=pt,pt};propTypes.exports=factoryWithThrowingShims();var propTypesExports=propTypes.exports;const PropTypes=getDefaultExportFromCjs(propTypesExports),LinearEncoding=3e3,sRGBEncoding=3001,Float=reactExports.forwardRef(({children:st,enabled:at=!0,speed:pt=1,rotationIntensity:vt=1,floatIntensity:wt=1,floatingRange:$t=[-.1,.1],...Tt},Lt)=>{const Ft=reactExports.useRef(null);reactExports.useImperativeHandle(Lt,()=>Ft.current,[]);const Ct=reactExports.useRef(Math.random()*1e4);return useFrame(Ht=>{var Gt,jt;if(!at||pt===0)return;const qt=Ct.current+Ht.clock.getElapsedTime();Ft.current.rotation.x=Math.cos(qt/4*pt)/8*vt,Ft.current.rotation.y=Math.sin(qt/4*pt)/8*vt,Ft.current.rotation.z=Math.sin(qt/4*pt)/20*vt;let Kt=Math.sin(qt/4*pt)/10;Kt=MathUtils.mapLinear(Kt,-.1,.1,(Gt=$t==null?void 0:$t[0])!==null&&Gt!==void 0?Gt:-.1,(jt=$t==null?void 0:$t[1])!==null&&jt!==void 0?jt:.1),Ft.current.position.y=Kt*wt,Ft.current.updateMatrix()}),reactExports.createElement("group",Tt,reactExports.createElement("group",{ref:Ft,matrixAutoUpdate:!1},st))}),getBufferForType=(st,at,pt)=>{let vt;switch(st){case UnsignedByteType:vt=new Uint8ClampedArray(at*pt*4);break;case HalfFloatType:vt=new Uint16Array(at*pt*4);break;case UnsignedIntType:vt=new Uint32Array(at*pt*4);break;case ByteType:vt=new Int8Array(at*pt*4);break;case ShortType:vt=new Int16Array(at*pt*4);break;case IntType:vt=new Int32Array(at*pt*4);break;case FloatType:vt=new Float32Array(at*pt*4);break;default:throw new Error("Unsupported data type")}return vt};let _canReadPixelsResult;const canReadPixels=(st,at,pt,vt)=>{if(_canReadPixelsResult!==void 0)return _canReadPixelsResult;const wt=new WebGLRenderTarget(1,1,vt);at.setRenderTarget(wt);const $t=new Mesh(new PlaneGeometry,new MeshBasicMaterial({color:16777215}));at.render($t,pt),at.setRenderTarget(null);const Tt=getBufferForType(st,wt.width,wt.height);return at.readRenderTargetPixels(wt,0,0,wt.width,wt.height,Tt),wt.dispose(),$t.geometry.dispose(),$t.material.dispose(),_canReadPixelsResult=Tt[0]!==0,_canReadPixelsResult};class QuadRenderer{constructor(at){var pt,vt,wt,$t,Tt,Lt,Ft,Ct,Ht,Gt,jt,qt,Kt,An,Sn,wn;this._rendererIsDisposable=!1,this._supportsReadPixels=!0,this.render=()=>{this._renderer.setRenderTarget(this._renderTarget);try{this._renderer.render(this._scene,this._camera)}catch(tr){throw this._renderer.setRenderTarget(null),tr}this._renderer.setRenderTarget(null)},this._width=at.width,this._height=at.height,this._type=at.type,this._colorSpace=at.colorSpace;const In={format:RGBAFormat,depthBuffer:!1,stencilBuffer:!1,type:this._type,colorSpace:this._colorSpace,anisotropy:((pt=at.renderTargetOptions)===null||pt===void 0?void 0:pt.anisotropy)!==void 0?(vt=at.renderTargetOptions)===null||vt===void 0?void 0:vt.anisotropy:1,generateMipmaps:((wt=at.renderTargetOptions)===null||wt===void 0?void 0:wt.generateMipmaps)!==void 0?($t=at.renderTargetOptions)===null||$t===void 0?void 0:$t.generateMipmaps:!1,magFilter:((Tt=at.renderTargetOptions)===null||Tt===void 0?void 0:Tt.magFilter)!==void 0?(Lt=at.renderTargetOptions)===null||Lt===void 0?void 0:Lt.magFilter:LinearFilter,minFilter:((Ft=at.renderTargetOptions)===null||Ft===void 0?void 0:Ft.minFilter)!==void 0?(Ct=at.renderTargetOptions)===null||Ct===void 0?void 0:Ct.minFilter:LinearFilter,samples:((Ht=at.renderTargetOptions)===null||Ht===void 0?void 0:Ht.samples)!==void 0?(Gt=at.renderTargetOptions)===null||Gt===void 0?void 0:Gt.samples:void 0,wrapS:((jt=at.renderTargetOptions)===null||jt===void 0?void 0:jt.wrapS)!==void 0?(qt=at.renderTargetOptions)===null||qt===void 0?void 0:qt.wrapS:ClampToEdgeWrapping,wrapT:((Kt=at.renderTargetOptions)===null||Kt===void 0?void 0:Kt.wrapT)!==void 0?(An=at.renderTargetOptions)===null||An===void 0?void 0:An.wrapT:ClampToEdgeWrapping};if(this._material=at.material,at.renderer?this._renderer=at.renderer:(this._renderer=QuadRenderer.instantiateRenderer(),this._rendererIsDisposable=!0),this._scene=new Scene,this._camera=new OrthographicCamera,this._camera.position.set(0,0,10),this._camera.left=-.5,this._camera.right=.5,this._camera.top=.5,this._camera.bottom=-.5,this._camera.updateProjectionMatrix(),!canReadPixels(this._type,this._renderer,this._camera,In)){let tr;switch(this._type){case HalfFloatType:tr=this._renderer.extensions.has("EXT_color_buffer_float")?FloatType:void 0;break}tr!==void 0?(console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`),this._type=tr):(this._supportsReadPixels=!1,console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))}this._quad=new Mesh(new PlaneGeometry,this._material),this._quad.geometry.computeBoundingBox(),this._scene.add(this._quad),this._renderTarget=new WebGLRenderTarget(this.width,this.height,In),this._renderTarget.texture.mapping=((Sn=at.renderTargetOptions)===null||Sn===void 0?void 0:Sn.mapping)!==void 0?(wn=at.renderTargetOptions)===null||wn===void 0?void 0:wn.mapping:UVMapping}static instantiateRenderer(){const at=new WebGLRenderer;return at.setSize(128,128),at}toArray(){if(!this._supportsReadPixels)throw new Error("Can't read pixels in this browser");const at=getBufferForType(this._type,this._width,this._height);return this._renderer.readRenderTargetPixels(this._renderTarget,0,0,this._width,this._height,at),at}toDataTexture(at){const pt=new DataTexture(this.toArray(),this.width,this.height,RGBAFormat,this._type,(at==null?void 0:at.mapping)||UVMapping,(at==null?void 0:at.wrapS)||ClampToEdgeWrapping,(at==null?void 0:at.wrapT)||ClampToEdgeWrapping,(at==null?void 0:at.magFilter)||LinearFilter,(at==null?void 0:at.minFilter)||LinearFilter,(at==null?void 0:at.anisotropy)||1,LinearSRGBColorSpace$1);return pt.generateMipmaps=(at==null?void 0:at.generateMipmaps)!==void 0?at==null?void 0:at.generateMipmaps:!1,pt}disposeOnDemandRenderer(){this._renderer.setRenderTarget(null),this._rendererIsDisposable&&(this._renderer.dispose(),this._renderer.forceContextLoss())}dispose(at){this.disposeOnDemandRenderer(),at&&this.renderTarget.dispose(),this.material instanceof ShaderMaterial&&Object.values(this.material.uniforms).forEach(pt=>{pt.value instanceof Texture&&pt.value.dispose()}),Object.values(this.material).forEach(pt=>{pt instanceof Texture&&pt.dispose()}),this.material.dispose(),this._quad.geometry.dispose()}get width(){return this._width}set width(at){this._width=at,this._renderTarget.setSize(this._width,this._height)}get height(){return this._height}set height(at){this._height=at,this._renderTarget.setSize(this._width,this._height)}get renderer(){return this._renderer}get renderTarget(){return this._renderTarget}set renderTarget(at){this._renderTarget=at,this._width=at.width,this._height=at.height}get material(){return this._material}get type(){return this._type}get colorSpace(){return this._colorSpace}}const vertexShader=`
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,fragmentShader=`
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;class GainMapDecoderMaterial extends ShaderMaterial{constructor({gamma:at,offsetHdr:pt,offsetSdr:vt,gainMapMin:wt,gainMapMax:$t,maxDisplayBoost:Tt,hdrCapacityMin:Lt,hdrCapacityMax:Ft,sdr:Ct,gainMap:Ht}){super({name:"GainMapDecoderMaterial",vertexShader,fragmentShader,uniforms:{sdr:{value:Ct},gainMap:{value:Ht},gamma:{value:new Vector3(1/at[0],1/at[1],1/at[2])},offsetHdr:{value:new Vector3().fromArray(pt)},offsetSdr:{value:new Vector3().fromArray(vt)},gainMapMin:{value:new Vector3().fromArray(wt)},gainMapMax:{value:new Vector3().fromArray($t)},weightFactor:{value:(Math.log2(Tt)-Lt)/(Ft-Lt)}},blending:NoBlending,depthTest:!1,depthWrite:!1}),this._maxDisplayBoost=Tt,this._hdrCapacityMin=Lt,this._hdrCapacityMax=Ft,this.needsUpdate=!0,this.uniformsNeedUpdate=!0}get sdr(){return this.uniforms.sdr.value}set sdr(at){this.uniforms.sdr.value=at}get gainMap(){return this.uniforms.gainMap.value}set gainMap(at){this.uniforms.gainMap.value=at}get offsetHdr(){return this.uniforms.offsetHdr.value.toArray()}set offsetHdr(at){this.uniforms.offsetHdr.value.fromArray(at)}get offsetSdr(){return this.uniforms.offsetSdr.value.toArray()}set offsetSdr(at){this.uniforms.offsetSdr.value.fromArray(at)}get gainMapMin(){return this.uniforms.gainMapMin.value.toArray()}set gainMapMin(at){this.uniforms.gainMapMin.value.fromArray(at)}get gainMapMax(){return this.uniforms.gainMapMax.value.toArray()}set gainMapMax(at){this.uniforms.gainMapMax.value.fromArray(at)}get gamma(){const at=this.uniforms.gamma.value;return[1/at.x,1/at.y,1/at.z]}set gamma(at){const pt=this.uniforms.gamma.value;pt.x=1/at[0],pt.y=1/at[1],pt.z=1/at[2]}get hdrCapacityMin(){return this._hdrCapacityMin}set hdrCapacityMin(at){this._hdrCapacityMin=at,this.calculateWeight()}get hdrCapacityMax(){return this._hdrCapacityMax}set hdrCapacityMax(at){this._hdrCapacityMax=at,this.calculateWeight()}get maxDisplayBoost(){return this._maxDisplayBoost}set maxDisplayBoost(at){this._maxDisplayBoost=Math.max(1,Math.min(65504,at)),this.calculateWeight()}calculateWeight(){const at=(Math.log2(this._maxDisplayBoost)-this._hdrCapacityMin)/(this._hdrCapacityMax-this._hdrCapacityMin);this.uniforms.weightFactor.value=Math.max(0,Math.min(1,at))}}class GainMapNotFoundError extends Error{}class XMPMetadataNotFoundError extends Error{}const getAttribute=(st,at,pt)=>{var vt;let wt;const $t=(vt=st.attributes.getNamedItem(at))===null||vt===void 0?void 0:vt.nodeValue;if($t)wt=$t;else{const Tt=st.getElementsByTagName(at)[0];if(Tt){const Lt=Tt.getElementsByTagName("rdf:li");if(Lt.length===3)wt=Array.from(Lt).map(Ft=>Ft.innerHTML);else throw new Error(`Gainmap metadata contains an array of items for ${at} but its length is not 3`)}else{if(pt)return pt;throw new Error(`Can't find ${at} in gainmap metadata`)}}return wt},extractXMP=st=>{var at,pt;let vt;typeof TextDecoder<"u"?vt=new TextDecoder().decode(st):vt=st.toString();let wt=vt.indexOf("<x:xmpmeta");const $t=new DOMParser;for(;wt!==-1;){const Tt=vt.indexOf("x:xmpmeta>",wt);vt.slice(wt,Tt+10);const Lt=vt.slice(wt,Tt+10);try{const Ct=$t.parseFromString(Lt,"text/xml").getElementsByTagName("rdf:Description")[0],Ht=getAttribute(Ct,"hdrgm:GainMapMin","0"),Gt=getAttribute(Ct,"hdrgm:GainMapMax"),jt=getAttribute(Ct,"hdrgm:Gamma","1"),qt=getAttribute(Ct,"hdrgm:OffsetSDR","0.015625"),Kt=getAttribute(Ct,"hdrgm:OffsetHDR","0.015625");let An=(at=Ct.attributes.getNamedItem("hdrgm:HDRCapacityMin"))===null||at===void 0?void 0:at.nodeValue;An||(An="0");const Sn=(pt=Ct.attributes.getNamedItem("hdrgm:HDRCapacityMax"))===null||pt===void 0?void 0:pt.nodeValue;if(!Sn)throw new Error("Incomplete gainmap metadata");return{gainMapMin:Array.isArray(Ht)?Ht.map(wn=>parseFloat(wn)):[parseFloat(Ht),parseFloat(Ht),parseFloat(Ht)],gainMapMax:Array.isArray(Gt)?Gt.map(wn=>parseFloat(wn)):[parseFloat(Gt),parseFloat(Gt),parseFloat(Gt)],gamma:Array.isArray(jt)?jt.map(wn=>parseFloat(wn)):[parseFloat(jt),parseFloat(jt),parseFloat(jt)],offsetSdr:Array.isArray(qt)?qt.map(wn=>parseFloat(wn)):[parseFloat(qt),parseFloat(qt),parseFloat(qt)],offsetHdr:Array.isArray(Kt)?Kt.map(wn=>parseFloat(wn)):[parseFloat(Kt),parseFloat(Kt),parseFloat(Kt)],hdrCapacityMin:parseFloat(An),hdrCapacityMax:parseFloat(Sn)}}catch{}wt=vt.indexOf("<x:xmpmeta",Tt)}};class MPFExtractor{constructor(at){this.options={debug:at&&at.debug!==void 0?at.debug:!1,extractFII:at&&at.extractFII!==void 0?at.extractFII:!0,extractNonFII:at&&at.extractNonFII!==void 0?at.extractNonFII:!0}}extract(at){return new Promise((pt,vt)=>{const wt=this.options.debug,$t=new DataView(at.buffer);if($t.getUint16(0)!==65496){vt(new Error("Not a valid jpeg"));return}const Tt=$t.byteLength;let Lt=2,Ft=0,Ct;for(;Lt<Tt;){if(++Ft>250){vt(new Error(`Found no marker after ${Ft} loops `));return}if($t.getUint8(Lt)!==255){vt(new Error(`Not a valid marker at offset 0x${Lt.toString(16)}, found: 0x${$t.getUint8(Lt).toString(16)}`));return}if(Ct=$t.getUint8(Lt+1),wt&&console.log(`Marker: ${Ct.toString(16)}`),Ct===226){wt&&console.log("Found APP2 marker (0xffe2)");const Ht=Lt+4;if($t.getUint32(Ht)===1297106432){const Gt=Ht+4;let jt;if($t.getUint16(Gt)===18761)jt=!1;else if($t.getUint16(Gt)===19789)jt=!0;else{vt(new Error("No valid endianness marker found in TIFF header"));return}if($t.getUint16(Gt+2,!jt)!==42){vt(new Error("Not valid TIFF data! (no 0x002A marker)"));return}const qt=$t.getUint32(Gt+4,!jt);if(qt<8){vt(new Error("Not valid TIFF data! (First offset less than 8)"));return}const Kt=Gt+qt,An=$t.getUint16(Kt,!jt),Sn=Kt+2;let wn=0;for(let Hr=Sn;Hr<Sn+12*An;Hr+=12)$t.getUint16(Hr,!jt)===45057&&(wn=$t.getUint32(Hr+8,!jt));const tr=Kt+2+An*12+4,rr=[];for(let Hr=tr;Hr<tr+wn*16;Hr+=16){const qr={MPType:$t.getUint32(Hr,!jt),size:$t.getUint32(Hr+4,!jt),dataOffset:$t.getUint32(Hr+8,!jt),dependantImages:$t.getUint32(Hr+12,!jt),start:-1,end:-1,isFII:!1};qr.dataOffset?(qr.start=Gt+qr.dataOffset,qr.isFII=!1):(qr.start=0,qr.isFII=!0),qr.end=qr.start+qr.size,rr.push(qr)}if(this.options.extractNonFII&&rr.length){const Hr=new Blob([$t]),qr=[];for(const Zr of rr){if(Zr.isFII&&!this.options.extractFII)continue;const Bo=Hr.slice(Zr.start,Zr.end+1,"image/jpeg");qr.push(Bo)}pt(qr)}}}Lt+=2+$t.getUint16(Lt+2)}})}}const extractGainmapFromJPEG=async st=>{const at=extractXMP(st);if(!at)throw new XMPMetadataNotFoundError("Gain map XMP metadata not found");const vt=await new MPFExtractor({extractFII:!0,extractNonFII:!0}).extract(st);if(vt.length!==2)throw new GainMapNotFoundError("Gain map recovery image not found");return{sdr:new Uint8Array(await vt[0].arrayBuffer()),gainMap:new Uint8Array(await vt[1].arrayBuffer()),metadata:at}},getHTMLImageFromBlob=st=>new Promise((at,pt)=>{const vt=document.createElement("img");vt.onload=()=>{at(vt)},vt.onerror=wt=>{pt(wt)},vt.src=URL.createObjectURL(st)});class LoaderBase extends Loader{constructor(at,pt){super(pt),at&&(this._renderer=at),this._internalLoadingManager=new LoadingManager}setRenderer(at){return this._renderer=at,this}setRenderTargetOptions(at){return this._renderTargetOptions=at,this}prepareQuadRenderer(){this._renderer||console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");const at=new GainMapDecoderMaterial({gainMapMax:[1,1,1],gainMapMin:[0,0,0],gamma:[1,1,1],offsetHdr:[1,1,1],offsetSdr:[1,1,1],hdrCapacityMax:1,hdrCapacityMin:0,maxDisplayBoost:1,gainMap:new Texture,sdr:new Texture});return new QuadRenderer({width:16,height:16,type:HalfFloatType,colorSpace:LinearSRGBColorSpace$1,material:at,renderer:this._renderer,renderTargetOptions:this._renderTargetOptions})}async render(at,pt,vt,wt){const $t=wt?new Blob([wt],{type:"image/jpeg"}):void 0,Tt=new Blob([vt],{type:"image/jpeg"});let Lt,Ft,Ct=!1;if(typeof createImageBitmap>"u"){const jt=await Promise.all([$t?getHTMLImageFromBlob($t):Promise.resolve(void 0),getHTMLImageFromBlob(Tt)]);Ft=jt[0],Lt=jt[1],Ct=!0}else{const jt=await Promise.all([$t?createImageBitmap($t,{imageOrientation:"flipY"}):Promise.resolve(void 0),createImageBitmap(Tt,{imageOrientation:"flipY"})]);Ft=jt[0],Lt=jt[1]}const Ht=new Texture(Ft||new ImageData(2,2),UVMapping,ClampToEdgeWrapping,ClampToEdgeWrapping,LinearFilter,LinearMipMapLinearFilter,RGBAFormat,UnsignedByteType,1,LinearSRGBColorSpace$1);Ht.flipY=Ct,Ht.needsUpdate=!0;const Gt=new Texture(Lt,UVMapping,ClampToEdgeWrapping,ClampToEdgeWrapping,LinearFilter,LinearMipMapLinearFilter,RGBAFormat,UnsignedByteType,1,SRGBColorSpace$1);Gt.flipY=Ct,Gt.needsUpdate=!0,at.width=Lt.width,at.height=Lt.height,at.material.gainMap=Ht,at.material.sdr=Gt,at.material.gainMapMin=pt.gainMapMin,at.material.gainMapMax=pt.gainMapMax,at.material.offsetHdr=pt.offsetHdr,at.material.offsetSdr=pt.offsetSdr,at.material.gamma=pt.gamma,at.material.hdrCapacityMin=pt.hdrCapacityMin,at.material.hdrCapacityMax=pt.hdrCapacityMax,at.material.maxDisplayBoost=Math.pow(2,pt.hdrCapacityMax),at.material.needsUpdate=!0,at.render()}}class GainMapLoader extends LoaderBase{load([at,pt,vt],wt,$t,Tt){const Lt=this.prepareQuadRenderer();let Ft,Ct,Ht;const Gt=async()=>{if(Ft&&Ct&&Ht){try{await this.render(Lt,Ht,Ft,Ct)}catch(Xo){this.manager.itemError(at),this.manager.itemError(pt),this.manager.itemError(vt),typeof Tt=="function"&&Tt(Xo),Lt.disposeOnDemandRenderer();return}typeof wt=="function"&&wt(Lt),this.manager.itemEnd(at),this.manager.itemEnd(pt),this.manager.itemEnd(vt),Lt.disposeOnDemandRenderer()}};let jt=!0,qt=0,Kt=0,An=!0,Sn=0,wn=0,In=!0,tr=0,rr=0;const Hr=()=>{if(typeof $t=="function"){const Xo=qt+Sn+tr,Kr=Kt+wn+rr,ko=jt&&An&&In;$t(new ProgressEvent("progress",{lengthComputable:ko,loaded:Kr,total:Xo}))}};this.manager.itemStart(at),this.manager.itemStart(pt),this.manager.itemStart(vt);const qr=new FileLoader(this._internalLoadingManager);qr.setResponseType("arraybuffer"),qr.setRequestHeader(this.requestHeader),qr.setPath(this.path),qr.setWithCredentials(this.withCredentials),qr.load(at,async Xo=>{if(typeof Xo=="string")throw new Error("Invalid sdr buffer");Ft=Xo,await Gt()},Xo=>{jt=Xo.lengthComputable,Kt=Xo.loaded,qt=Xo.total,Hr()},Xo=>{this.manager.itemError(at),typeof Tt=="function"&&Tt(Xo)});const Zr=new FileLoader(this._internalLoadingManager);Zr.setResponseType("arraybuffer"),Zr.setRequestHeader(this.requestHeader),Zr.setPath(this.path),Zr.setWithCredentials(this.withCredentials),Zr.load(pt,async Xo=>{if(typeof Xo=="string")throw new Error("Invalid gainmap buffer");Ct=Xo,await Gt()},Xo=>{An=Xo.lengthComputable,wn=Xo.loaded,Sn=Xo.total,Hr()},Xo=>{this.manager.itemError(pt),typeof Tt=="function"&&Tt(Xo)});const Bo=new FileLoader(this._internalLoadingManager);return Bo.setRequestHeader(this.requestHeader),Bo.setPath(this.path),Bo.setWithCredentials(this.withCredentials),Bo.load(vt,async Xo=>{if(typeof Xo!="string")throw new Error("Invalid metadata string");Ht=JSON.parse(Xo),await Gt()},Xo=>{In=Xo.lengthComputable,rr=Xo.loaded,tr=Xo.total,Hr()},Xo=>{this.manager.itemError(vt),typeof Tt=="function"&&Tt(Xo)}),Lt}}class HDRJPGLoader extends LoaderBase{load(at,pt,vt,wt){const $t=this.prepareQuadRenderer(),Tt=new FileLoader(this._internalLoadingManager);return Tt.setResponseType("arraybuffer"),Tt.setRequestHeader(this.requestHeader),Tt.setPath(this.path),Tt.setWithCredentials(this.withCredentials),this.manager.itemStart(at),Tt.load(at,async Lt=>{if(typeof Lt=="string")throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");const Ft=new Uint8Array(Lt);let Ct,Ht,Gt;try{const jt=await extractGainmapFromJPEG(Ft);Ct=jt.sdr,Ht=jt.gainMap,Gt=jt.metadata}catch(jt){if(jt instanceof XMPMetadataNotFoundError||jt instanceof GainMapNotFoundError)console.warn(`Failure to reconstruct an HDR image from ${at}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`),Gt={gainMapMin:[0,0,0],gainMapMax:[1,1,1],gamma:[1,1,1],hdrCapacityMin:0,hdrCapacityMax:1,offsetHdr:[0,0,0],offsetSdr:[0,0,0]},Ct=Ft;else throw jt}try{await this.render($t,Gt,Ct,Ht)}catch(jt){this.manager.itemError(at),typeof wt=="function"&&wt(jt),$t.disposeOnDemandRenderer();return}typeof pt=="function"&&pt($t),this.manager.itemEnd(at),$t.disposeOnDemandRenderer()},vt,Lt=>{this.manager.itemError(at),typeof wt=="function"&&wt(Lt)}),$t}}const presetsObj={apartment:"lebombo_1k.hdr",city:"potsdamer_platz_1k.hdr",dawn:"kiara_1_dawn_1k.hdr",forest:"forest_slope_1k.hdr",lobby:"st_fagans_interior_1k.hdr",night:"dikhololo_night_1k.hdr",park:"rooitou_park_1k.hdr",studio:"studio_small_03_1k.hdr",sunset:"venice_sunset_1k.hdr",warehouse:"empty_warehouse_01_1k.hdr"},CUBEMAP_ROOT="https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",isArray=st=>Array.isArray(st);function useEnvironment({files:st=["/px.png","/nx.png","/py.png","/ny.png","/pz.png","/nz.png"],path:at="",preset:pt=void 0,encoding:vt=void 0,extensions:wt}={}){var $t;let Tt=null,Lt=!1,Ft;if(pt){if(!(pt in presetsObj))throw new Error("Preset must be one of: "+Object.keys(presetsObj).join(", "));st=presetsObj[pt],at=CUBEMAP_ROOT}const Ct=isArray(st)&&st.length===6,Ht=isArray(st)&&st.length===3&&st.some(Sn=>Sn.endsWith("json")),Gt=isArray(st)?st[0]:st;if(Lt=isArray(st),Ft=Ct?"cube":Ht?"webp":Gt.startsWith("data:application/exr")?"exr":Gt.startsWith("data:application/hdr")?"hdr":Gt.startsWith("data:image/jpeg")?"jpg":($t=Gt.split(".").pop())==null||($t=$t.split("?"))==null||($t=$t.shift())==null?void 0:$t.toLowerCase(),Tt=Ft==="cube"?CubeTextureLoader:Ft==="hdr"?RGBELoader:Ft==="exr"?EXRLoader:Ft==="jpg"||Ft==="jpeg"?HDRJPGLoader:Ft==="webp"?GainMapLoader:null,!Tt)throw new Error("useEnvironment: Unrecognized file extension: "+st);const jt=useThree(Sn=>Sn.gl),qt=useLoader(Tt,Lt?[st]:st,Sn=>{(Ft==="webp"||Ft==="jpg"||Ft==="jpeg")&&Sn.setRenderer(jt),Sn.setPath==null||Sn.setPath(at),wt&&wt(Sn)});let Kt=Lt?qt[0]:qt;if(Ft==="jpg"||Ft==="jpeg"||Ft==="webp"){var An;Kt=(An=Kt.renderTarget)==null?void 0:An.texture}return Kt.mapping=Ct?CubeReflectionMapping:EquirectangularReflectionMapping,"colorSpace"in Kt?Kt.colorSpace=vt??Ct?"srgb":"srgb-linear":Kt.encoding=vt??Ct?sRGBEncoding:LinearEncoding,Kt}const isRef=st=>st.current&&st.current.isScene,resolveScene=st=>isRef(st)?st.current:st;function setEnvProps(st,at,pt,vt,wt={}){var $t,Tt,Lt,Ft,Ct;wt={backgroundBlurriness:($t=wt.blur)!==null&&$t!==void 0?$t:0,backgroundIntensity:1,backgroundRotation:[0,0,0],environmentIntensity:1,environmentRotation:[0,0,0],...wt};const Ht=resolveScene(at||pt),Gt=Ht.background,jt=Ht.environment,qt={backgroundBlurriness:Ht.backgroundBlurriness,backgroundIntensity:Ht.backgroundIntensity,backgroundRotation:(Tt=(Lt=Ht.backgroundRotation)==null||Lt.clone==null?void 0:Lt.clone())!==null&&Tt!==void 0?Tt:[0,0,0],environmentIntensity:Ht.environmentIntensity,environmentRotation:(Ft=(Ct=Ht.environmentRotation)==null||Ct.clone==null?void 0:Ct.clone())!==null&&Ft!==void 0?Ft:[0,0,0]};return st!=="only"&&(Ht.environment=vt),st&&(Ht.background=vt),applyProps(Ht,wt),()=>{st!=="only"&&(Ht.environment=jt),st&&(Ht.background=Gt),applyProps(Ht,qt)}}function EnvironmentMap({scene:st,background:at=!1,map:pt,...vt}){const wt=useThree($t=>$t.scene);return reactExports.useLayoutEffect(()=>{if(pt)return setEnvProps(at,st,wt,pt,vt)}),null}function EnvironmentCube({background:st=!1,scene:at,blur:pt,backgroundBlurriness:vt,backgroundIntensity:wt,backgroundRotation:$t,environmentIntensity:Tt,environmentRotation:Lt,...Ft}){const Ct=useEnvironment(Ft),Ht=useThree(Gt=>Gt.scene);return reactExports.useLayoutEffect(()=>setEnvProps(st,at,Ht,Ct,{blur:pt,backgroundBlurriness:vt,backgroundIntensity:wt,backgroundRotation:$t,environmentIntensity:Tt,environmentRotation:Lt})),null}function EnvironmentPortal({children:st,near:at=1,far:pt=1e3,resolution:vt=256,frames:wt=1,map:$t,background:Tt=!1,blur:Lt,backgroundBlurriness:Ft,backgroundIntensity:Ct,backgroundRotation:Ht,environmentIntensity:Gt,environmentRotation:jt,scene:qt,files:Kt,path:An,preset:Sn=void 0,extensions:wn}){const In=useThree(Bo=>Bo.gl),tr=useThree(Bo=>Bo.scene),rr=reactExports.useRef(null),[Hr]=reactExports.useState(()=>new Scene),qr=reactExports.useMemo(()=>{const Bo=new WebGLCubeRenderTarget(vt);return Bo.texture.type=HalfFloatType,Bo},[vt]);reactExports.useLayoutEffect(()=>(wt===1&&rr.current.update(In,Hr),setEnvProps(Tt,qt,tr,qr.texture,{blur:Lt,backgroundBlurriness:Ft,backgroundIntensity:Ct,backgroundRotation:Ht,environmentIntensity:Gt,environmentRotation:jt})),[st,Hr,qr.texture,qt,tr,Tt,wt,In]);let Zr=1;return useFrame(()=>{(wt===1/0||Zr<wt)&&(rr.current.update(In,Hr),Zr++)}),reactExports.createElement(reactExports.Fragment,null,createPortal(reactExports.createElement(reactExports.Fragment,null,st,reactExports.createElement("cubeCamera",{ref:rr,args:[at,pt,qr]}),Kt||Sn?reactExports.createElement(EnvironmentCube,{background:!0,files:Kt,preset:Sn,path:An,extensions:wn}):$t?reactExports.createElement(EnvironmentMap,{background:!0,map:$t,extensions:wn}):null),Hr))}function EnvironmentGround(st){var at,pt,vt,wt;const $t=useEnvironment(st),Tt=st.map||$t;reactExports.useMemo(()=>extend$2({GroundProjectedEnvImpl:GroundProjectedEnv}),[]);const Lt=reactExports.useMemo(()=>[Tt],[Tt]),Ft=(at=st.ground)==null?void 0:at.height,Ct=(pt=st.ground)==null?void 0:pt.radius,Ht=(vt=(wt=st.ground)==null?void 0:wt.scale)!==null&&vt!==void 0?vt:1e3;return reactExports.createElement(reactExports.Fragment,null,reactExports.createElement(EnvironmentMap,_extends$1({},st,{map:Tt})),reactExports.createElement("groundProjectedEnvImpl",{args:Lt,scale:Ht,height:Ft,radius:Ct}))}function Environment(st){return st.ground?reactExports.createElement(EnvironmentGround,st):st.map?reactExports.createElement(EnvironmentMap,st):st.children?reactExports.createElement(EnvironmentPortal,st):reactExports.createElement(EnvironmentCube,st)}const accumulativeContext=reactExports.createContext(null),RandomizedLight=reactExports.forwardRef(({castShadow:st=!0,bias:at=.001,mapSize:pt=512,size:vt=5,near:wt=.5,far:$t=500,frames:Tt=1,position:Lt=[0,0,0],radius:Ft=1,amount:Ct=8,intensity:Ht=version>=155?Math.PI:1,ambient:Gt=.5,...jt},qt)=>{const Kt=reactExports.useRef(null),An=new Vector3(...Lt).length(),Sn=reactExports.useContext(accumulativeContext),wn=reactExports.useCallback(()=>{let tr;if(Kt.current)for(let rr=0;rr<Kt.current.children.length;rr++)if(tr=Kt.current.children[rr],Math.random()>Gt)tr.position.set(Lt[0]+MathUtils.randFloatSpread(Ft),Lt[1]+MathUtils.randFloatSpread(Ft),Lt[2]+MathUtils.randFloatSpread(Ft));else{let Hr=Math.acos(2*Math.random()-1)-Math.PI/2,qr=2*Math.PI*Math.random();tr.position.set(Math.cos(Hr)*Math.cos(qr)*An,Math.abs(Math.cos(Hr)*Math.sin(qr)*An),Math.sin(Hr)*An)}},[Ft,Gt,An,...Lt]),In=reactExports.useMemo(()=>({update:wn}),[wn]);return reactExports.useImperativeHandle(qt,()=>In,[In]),reactExports.useLayoutEffect(()=>{var tr;const rr=Kt.current;return Sn&&((tr=Sn.lights)==null||tr.set(rr.uuid,In)),()=>{var Hr;return void(Sn==null||(Hr=Sn.lights)==null?void 0:Hr.delete(rr.uuid))}},[Sn,In]),reactExports.createElement("group",_extends$1({ref:Kt},jt),Array.from({length:Ct},(tr,rr)=>reactExports.createElement("directionalLight",{key:rr,castShadow:st,"shadow-bias":at,"shadow-mapSize":[pt,pt],intensity:Ht/Ct},reactExports.createElement("orthographicCamera",{attach:"shadow-camera",args:[-vt,vt,vt,-vt,wt,$t]}))))});function calcPosFromAngles(st,at,pt=new Vector3){const vt=Math.PI*(st-.5),wt=2*Math.PI*(at-.5);return pt.x=Math.cos(wt),pt.y=Math.sin(vt),pt.z=Math.sin(wt),pt}const Sky=reactExports.forwardRef(({inclination:st=.6,azimuth:at=.1,distance:pt=1e3,mieCoefficient:vt=.005,mieDirectionalG:wt=.8,rayleigh:$t=.5,turbidity:Tt=10,sunPosition:Lt=calcPosFromAngles(st,at),...Ft},Ct)=>{const Ht=reactExports.useMemo(()=>new Vector3().setScalar(pt),[pt]),[Gt]=reactExports.useState(()=>new Sky$1);return reactExports.createElement("primitive",_extends$1({object:Gt,ref:Ct,"material-uniforms-mieCoefficient-value":vt,"material-uniforms-mieDirectionalG-value":wt,"material-uniforms-rayleigh-value":$t,"material-uniforms-sunPosition-value":Lt,"material-uniforms-turbidity-value":Tt,scale:Ht},Ft))}),Lighting=()=>jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment,{children:[jsxRuntimeExports.jsx(RandomizedLight,{amount:4,radius:9,intensity:.55,ambient:.25,position:[5,5,-10]}),jsxRuntimeExports.jsx(RandomizedLight,{amount:4,radius:5,intensity:.25,ambient:.55,position:[-5,5,-9]})]}),CameraRig=({children:st})=>{const at=reactExports.useRef();return jsxRuntimeExports.jsx("group",{ref:at,children:st})},basePath="/visual-experience/",defaultModelPath=`${basePath}/models/shirt_baked_2.glb`,Shirt=({modelPath:st=defaultModelPath,hexColor:at=16777215,texture:pt,scale:vt=new Vector3(1,1,1)},wt)=>{const{nodes:$t,materials:Tt}=useGLTF(st),Lt=useTexture({aoMap:`${basePath}/textures/wool/wool_texture_ao.jpg`,roughnessMap:`${basePath}/textures/wool/wool_texture_rough.jpg`,metalnessMap:`${basePath}/textures/wool/wool_texture_metal.jpg`,normalMap:`${basePath}/textures/wool/wool_texture_normal.jpg`}),Ft=useTexture({map:`${basePath}/textures/cotton/Fabric_001_COLOR.jpg`,aoMap:`${basePath}/textures/cotton/Fabric_001_OCC.jpg`,roughnessMap:`${basePath}/textures/cotton/Fabric_001_ROUGH.jpg`,normalMap:`${basePath}/textures/cotton/Fabric_001_NORM.jpg`});return reactExports.useEffect(()=>{pt==="Wool"?(Tt.lambert1.aoMap=Lt.aoMap,Tt.lambert1.roughnessMap=Lt.roughnessMap,Tt.lambert1.metalnessMap=Lt.metalnessMap,Tt.lambert1.normalMap=Lt.normalMap):pt==="Cotton"?(Tt.lambert1.map=Ft.map,Tt.lambert1.roughnessMap=Ft.roughnessMap,Tt.lambert1.normalMap=Ft.normalMap,Tt.lambert1.aoMap=Ft.aoMap):(Tt.lambert1.map=null,Tt.lambert1.roughnessMap=null,Tt.lambert1.normalMap=null,Tt.lambert1.aoMap=null,Tt.lambert1.metalnessMap=null),Tt.lambert1.needsUpdate=!0},[pt,Lt,Ft,Tt.lambert1]),Tt.lambert1.color=new Color$1(at),jsxRuntimeExports.jsx("group",{...wt,dispose:null,children:jsxRuntimeExports.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:$t.T_Shirt_male.geometry,material:Tt.lambert1,position:[.419,0,0],scale:vt,rotation:[Math.PI/2,0,0]})})};useGLTF.preload(defaultModelPath);extend$2({useGLTF,Environment,Center,OrbitControls,Canvas:Canvas$1});const ThreeScene=({position:st=[0,0,2.5],fov:at=25,hexColor:pt,texture:vt,scale:wt=new Vector3(1,1,1)})=>jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment,{children:jsxRuntimeExports.jsxs(Canvas$1,{shadows:!0,camera:{position:st,fov:at},gl:{preserveDrawingBuffer:!0},eventSource:document.getElementById("root"),eventPrefix:"client",children:[jsxRuntimeExports.jsx("ambientLight",{intensity:2}),jsxRuntimeExports.jsx(OrbitControls,{enableZoom:!1}),jsxRuntimeExports.jsx(Environment,{files:"https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/potsdamer_platz_1k.hdr"}),jsxRuntimeExports.jsx(Sky,{distance:45e4,sunPosition:[0,1,0],inclination:0,azimuth:.25}),jsxRuntimeExports.jsxs(CameraRig,{children:[jsxRuntimeExports.jsx(Lighting,{}),jsxRuntimeExports.jsx(Center,{children:jsxRuntimeExports.jsx(Float,{speed:1,rotationIntensity:.5,floatIntensity:1,floatingRange:[-0,.1],children:jsxRuntimeExports.jsx(Shirt,{hexColor:pt,texture:vt,scale:wt})})})]})]})}),getSrc=st=>typeof st=="string"?st:st.src,getArgs=({amount:st=3,format:at="array",group:pt=20,sample:vt=10}={})=>({amount:st,format:at,group:pt,sample:vt}),format$4=(st,at)=>{const pt=st.map(vt=>{const wt=Array.isArray(vt)?vt:vt.split(",").map(Number);return at.format==="hex"?rgbToHex(wt):wt});return at.amount===1||pt.length===1?pt[0]:pt},group=(st,at)=>{const pt=Math.round(st/at)*at;return Math.min(pt,255)},rgbToHex=st=>"#"+st.map(at=>{const pt=at.toString(16);return pt.length===1?"0"+pt:pt}).join(""),getImageData=st=>new Promise((at,pt)=>{const vt=document.createElement("canvas"),wt=vt.getContext("2d"),$t=new Image;$t.onload=()=>{vt.height=$t.height,vt.width=$t.width,wt.drawImage($t,0,0);const Tt=wt.getImageData(0,0,$t.width,$t.height).data;at(Tt)},$t.onerror=()=>pt(Error("Image loading failed.")),$t.crossOrigin="",$t.src=st}),getProminent=(st,at)=>{const pt=4*at.sample,vt={};for(let wt=0;wt<st.length;wt+=pt)if(st[wt+3]>0){const Tt=[group(st[wt],at.group),group(st[wt+1],at.group),group(st[wt+2],at.group)].join();vt[Tt]=vt[Tt]?vt[Tt]+1:1}return format$4(Object.entries(vt).sort(([wt,$t],[Tt,Lt])=>$t>Lt?-1:1).slice(0,at.amount).map(([wt])=>wt),at)},process$1=(st,at,pt)=>new Promise((vt,wt)=>getImageData(getSrc(at)).then($t=>vt(st($t,getArgs(pt)))).catch($t=>wt($t))),prominent=(st,at)=>process$1(getProminent,st,at);function $6ed0406888f73fc4$var$setRef(st,at){typeof st=="function"?st(at):st!=null&&(st.current=at)}function $6ed0406888f73fc4$export$43e446d32b3d21af(...st){return at=>st.forEach(pt=>$6ed0406888f73fc4$var$setRef(pt,at))}function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...st){return reactExports.useCallback($6ed0406888f73fc4$export$43e446d32b3d21af(...st),st)}const $5e63c961fc1ce211$export$8c6ed5c666ac1360=reactExports.forwardRef((st,at)=>{const{children:pt,...vt}=st,wt=reactExports.Children.toArray(pt),$t=wt.find($5e63c961fc1ce211$var$isSlottable);if($t){const Tt=$t.props.children,Lt=wt.map(Ft=>Ft===$t?reactExports.Children.count(Tt)>1?reactExports.Children.only(null):reactExports.isValidElement(Tt)?Tt.props.children:null:Ft);return reactExports.createElement($5e63c961fc1ce211$var$SlotClone,_extends$1({},vt,{ref:at}),reactExports.isValidElement(Tt)?reactExports.cloneElement(Tt,void 0,Lt):null)}return reactExports.createElement($5e63c961fc1ce211$var$SlotClone,_extends$1({},vt,{ref:at}),pt)});$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName="Slot";const $5e63c961fc1ce211$var$SlotClone=reactExports.forwardRef((st,at)=>{const{children:pt,...vt}=st;return reactExports.isValidElement(pt)?reactExports.cloneElement(pt,{...$5e63c961fc1ce211$var$mergeProps(vt,pt.props),ref:at?$6ed0406888f73fc4$export$43e446d32b3d21af(at,pt.ref):pt.ref}):reactExports.Children.count(pt)>1?reactExports.Children.only(null):null});$5e63c961fc1ce211$var$SlotClone.displayName="SlotClone";const $5e63c961fc1ce211$export$d9f1ccf0bdb05d45=({children:st})=>reactExports.createElement(reactExports.Fragment,null,st);function $5e63c961fc1ce211$var$isSlottable(st){return reactExports.isValidElement(st)&&st.type===$5e63c961fc1ce211$export$d9f1ccf0bdb05d45}function $5e63c961fc1ce211$var$mergeProps(st,at){const pt={...at};for(const vt in at){const wt=st[vt],$t=at[vt];/^on[A-Z]/.test(vt)?wt&&$t?pt[vt]=(...Lt)=>{$t(...Lt),wt(...Lt)}:wt&&(pt[vt]=wt):vt==="style"?pt[vt]={...wt,...$t}:vt==="className"&&(pt[vt]=[wt,$t].filter(Boolean).join(" "))}return{...st,...pt}}const $8927f6f2acc4f386$var$NODES=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],$8927f6f2acc4f386$export$250ffa63cdc0d034=$8927f6f2acc4f386$var$NODES.reduce((st,at)=>{const pt=reactExports.forwardRef((vt,wt)=>{const{asChild:$t,...Tt}=vt,Lt=$t?$5e63c961fc1ce211$export$8c6ed5c666ac1360:at;return reactExports.useEffect(()=>{window[Symbol.for("radix-ui")]=!0},[]),reactExports.createElement(Lt,_extends$1({},Tt,{ref:wt}))});return pt.displayName=`Primitive.${at}`,{...st,[at]:pt}},{});function $8927f6f2acc4f386$export$6d1a0317bde7de7f(st,at){st&&reactDomExports.flushSync(()=>st.dispatchEvent(at))}const $f1701beae083dbae$export$602eac185826482c=reactExports.forwardRef((st,at)=>{var pt;const{container:vt=globalThis==null||(pt=globalThis.document)===null||pt===void 0?void 0:pt.body,...wt}=st;return vt?ReactDOM.createPortal(reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div,_extends$1({},wt,{ref:at})),vt):null}),$f1701beae083dbae$export$be92b6f5f03c0fe9=$f1701beae083dbae$export$602eac185826482c;var has=Object.prototype.hasOwnProperty;function dequal(st,at){var pt,vt;if(st===at)return!0;if(st&&at&&(pt=st.constructor)===at.constructor){if(pt===Date)return st.getTime()===at.getTime();if(pt===RegExp)return st.toString()===at.toString();if(pt===Array){if((vt=st.length)===at.length)for(;vt--&&dequal(st[vt],at[vt]););return vt===-1}if(!pt||typeof st=="object"){vt=0;for(pt in st)if(has.call(st,pt)&&++vt&&!has.call(at,pt)||!(pt in at)||!dequal(st[pt],at[pt]))return!1;return Object.keys(at).length===vt}}return st!==st&&at!==at}var Rule=function(at,pt,vt,wt){this.name=at,this.fn=pt,this.args=vt,this.modifiers=wt};Rule.prototype._test=function(at){var pt=this.fn;try{testAux(this.modifiers.slice(),pt,this)(at)}catch{pt=function(){return!1}}try{return testAux(this.modifiers.slice(),pt,this)(at)}catch{return!1}};Rule.prototype._check=function(at){try{testAux(this.modifiers.slice(),this.fn,this)(at)}catch{if(testAux(this.modifiers.slice(),function(vt){return vt},this)(!1))return}if(!testAux(this.modifiers.slice(),this.fn,this)(at))throw null};Rule.prototype._testAsync=function(at){var pt=this;return new Promise(function(vt,wt){testAsyncAux(pt.modifiers.slice(),pt.fn,pt)(at).then(function($t){$t?vt(at):wt(null)}).catch(function($t){return wt($t)})})};function pickFn(st,at){return at===void 0&&(at="simple"),typeof st=="object"?st[at]:st}function testAux(st,at,pt){if(st.length){var vt=st.shift(),wt=testAux(st,at,pt);return vt.perform(wt,pt)}else return pickFn(at)}function testAsyncAux(st,at,pt){if(st.length){var vt=st.shift(),wt=testAsyncAux(st,at,pt);return vt.performAsync(wt,pt)}else return function($t){return Promise.resolve(pickFn(at,"async")($t))}}var Modifier=function(at,pt,vt){this.name=at,this.perform=pt,this.performAsync=vt},ValidationError=function(st){function at(pt,vt,wt,$t){for(var Tt=[],Lt=arguments.length-4;Lt-- >0;)Tt[Lt]=arguments[Lt+4];st.call(this,Tt),st.captureStackTrace&&st.captureStackTrace(this,at),this.rule=pt,this.value=vt,this.cause=wt,this.target=$t}return st&&(at.__proto__=st),at.prototype=Object.create(st&&st.prototype),at.prototype.constructor=at,at}(Error),Context=function(at,pt){at===void 0&&(at=[]),pt===void 0&&(pt=[]),this.chain=at,this.nextRuleModifiers=pt};Context.prototype._applyRule=function(at,pt){var vt=this;return function(){for(var wt=[],$t=arguments.length;$t--;)wt[$t]=arguments[$t];return vt.chain.push(new Rule(pt,at.apply(vt,wt),wt,vt.nextRuleModifiers)),vt.nextRuleModifiers=[],vt}};Context.prototype._applyModifier=function(at,pt){return this.nextRuleModifiers.push(new Modifier(pt,at.simple,at.async)),this};Context.prototype._clone=function(){return new Context(this.chain.slice(),this.nextRuleModifiers.slice())};Context.prototype.test=function(at){return this.chain.every(function(pt){return pt._test(at)})};Context.prototype.testAll=function(at){var pt=[];return this.chain.forEach(function(vt){try{vt._check(at)}catch(wt){pt.push(new ValidationError(vt,at,wt))}}),pt};Context.prototype.check=function(at){this.chain.forEach(function(pt){try{pt._check(at)}catch(vt){throw new ValidationError(pt,at,vt)}})};Context.prototype.testAsync=function(at){var pt=this;return new Promise(function(vt,wt){executeAsyncRules(at,pt.chain.slice(),vt,wt)})};function executeAsyncRules(st,at,pt,vt){if(at.length){var wt=at.shift();wt._testAsync(st).then(function(){executeAsyncRules(st,at,pt,vt)},function($t){vt(new ValidationError(wt,st,$t))})}else pt(st)}var consideredEmpty=function(st,at){return at&&typeof st=="string"&&st.trim().length===0?!0:st==null};function optional(st,at){return at===void 0&&(at=!1),{simple:function(pt){return consideredEmpty(pt,at)||st.check(pt)===void 0},async:function(pt){return consideredEmpty(pt,at)||st.testAsync(pt)}}}function v8n(){return typeof Proxy<"u"?proxyContext(new Context):proxylessContext(new Context)}var customRules={};v8n.extend=function(st){Object.assign(customRules,st)};v8n.clearCustomRules=function(){customRules={}};function proxyContext(st){return new Proxy(st,{get:function(pt,vt){if(vt in pt)return pt[vt];var wt=proxyContext(st._clone());if(vt in availableModifiers)return wt._applyModifier(availableModifiers[vt],vt);if(vt in customRules)return wt._applyRule(customRules[vt],vt);if(vt in availableRules)return wt._applyRule(availableRules[vt],vt)}})}function proxylessContext(st){var at=function(wt,$t){return Object.keys(wt).forEach(function(Tt){$t[Tt]=function(){for(var Lt=[],Ft=arguments.length;Ft--;)Lt[Ft]=arguments[Ft];var Ct=proxylessContext($t._clone()),Ht=Ct._applyRule(wt[Tt],Tt).apply(void 0,Lt);return Ht}}),$t},pt=at(availableRules,st),vt=at(customRules,pt);return Object.keys(availableModifiers).forEach(function(wt){Object.defineProperty(vt,wt,{get:function(){var $t=proxylessContext(vt._clone());return $t._applyModifier(availableModifiers[wt],wt)}})}),vt}var availableModifiers={not:{simple:function(st){return function(at){return!st(at)}},async:function(st){return function(at){return Promise.resolve(st(at)).then(function(pt){return!pt}).catch(function(){return!0})}}},some:{simple:function(st){return function(at){return split$1(at).some(function(pt){try{return st(pt)}catch{return!1}})}},async:function(st){return function(at){return Promise.all(split$1(at).map(function(pt){try{return st(pt).catch(function(){return!1})}catch{return!1}})).then(function(pt){return pt.some(Boolean)})}}},every:{simple:function(st){return function(at){return at!==!1&&split$1(at).every(st)}},async:function(st){return function(at){return Promise.all(split$1(at).map(st)).then(function(pt){return pt.every(Boolean)})}}},strict:{simple:function(st,at){return function(pt){return isSchemaRule(at)&&pt&&typeof pt=="object"?Object.keys(at.args[0]).length===Object.keys(pt).length&&st(pt):st(pt)}},async:function(st,at){return function(pt){return Promise.resolve(st(pt)).then(function(vt){return isSchemaRule(at)&&pt&&typeof pt=="object"?Object.keys(at.args[0]).length===Object.keys(pt).length&&vt:vt}).catch(function(){return!1})}}}};function isSchemaRule(st){return st&&st.name==="schema"&&st.args.length>0&&typeof st.args[0]=="object"}function split$1(st){return typeof st=="string"?st.split(""):st}var availableRules={equal:function(st){return function(at){return at==st}},exact:function(st){return function(at){return at===st}},number:function(st){return st===void 0&&(st=!0),function(at){return typeof at=="number"&&(st||isFinite(at))}},integer:function(){return function(st){var at=Number.isInteger||isIntegerPolyfill;return at(st)}},numeric:function(){return function(st){return!isNaN(parseFloat(st))&&isFinite(st)}},string:function(){return testType("string")},boolean:function(){return testType("boolean")},undefined:function(){return testType("undefined")},null:function(){return testType("null")},array:function(){return testType("array")},object:function(){return testType("object")},instanceOf:function(st){return function(at){return at instanceof st}},pattern:function(st){return function(at){return st.test(at)}},lowercase:function(){return function(st){return typeof st=="boolean"||st===st.toLowerCase()&&st.trim()!==""}},uppercase:function(){return function(st){return st===st.toUpperCase()&&st.trim()!==""}},vowel:function(){return function(st){return/^[aeiou]+$/i.test(st)}},consonant:function(){return function(st){return/^(?=[^aeiou])([a-z]+)$/i.test(st)}},first:function(st){return function(at){return at[0]==st}},last:function(st){return function(at){return at[at.length-1]==st}},empty:function(){return function(st){return st.length===0}},length:function(st,at){return function(pt){return pt.length>=st&&pt.length<=(at||st)}},minLength:function(st){return function(at){return at.length>=st}},maxLength:function(st){return function(at){return at.length<=st}},negative:function(){return function(st){return st<0}},positive:function(){return function(st){return st>=0}},between:function(st,at){return function(pt){return pt>=st&&pt<=at}},range:function(st,at){return function(pt){return pt>=st&&pt<=at}},lessThan:function(st){return function(at){return at<st}},lessThanOrEqual:function(st){return function(at){return at<=st}},greaterThan:function(st){return function(at){return at>st}},greaterThanOrEqual:function(st){return function(at){return at>=st}},even:function(){return function(st){return st%2===0}},odd:function(){return function(st){return st%2!==0}},includes:function(st){return function(at){return~at.indexOf(st)}},schema:function(st){return testSchema(st)},passesAnyOf:function(){for(var st=[],at=arguments.length;at--;)st[at]=arguments[at];return function(pt){return st.some(function(vt){return vt.test(pt)})}},optional};function testType(st){return function(at){return Array.isArray(at)&&st==="array"||at===null&&st==="null"||typeof at===st}}function isIntegerPolyfill(st){return typeof st=="number"&&isFinite(st)&&Math.floor(st)===st}function testSchema(st){return{simple:function(at){var pt=[];if(Object.keys(st).forEach(function(vt){var wt=st[vt];try{wt.check((at||{})[vt])}catch($t){$t.target=vt,pt.push($t)}}),pt.length>0)throw pt;return!0},async:function(at){var pt=[],vt=Object.keys(st).map(function(wt){var $t=st[wt];return $t.testAsync((at||{})[wt]).catch(function(Tt){Tt.target=wt,pt.push(Tt)})});return Promise.all(vt).then(function(){if(pt.length>0)throw pt;return!0})}}}var e$1="colors",t$1="sizes",r$1="space",n$1={gap:r$1,gridGap:r$1,columnGap:r$1,gridColumnGap:r$1,rowGap:r$1,gridRowGap:r$1,inset:r$1,insetBlock:r$1,insetBlockEnd:r$1,insetBlockStart:r$1,insetInline:r$1,insetInlineEnd:r$1,insetInlineStart:r$1,margin:r$1,marginTop:r$1,marginRight:r$1,marginBottom:r$1,marginLeft:r$1,marginBlock:r$1,marginBlockEnd:r$1,marginBlockStart:r$1,marginInline:r$1,marginInlineEnd:r$1,marginInlineStart:r$1,padding:r$1,paddingTop:r$1,paddingRight:r$1,paddingBottom:r$1,paddingLeft:r$1,paddingBlock:r$1,paddingBlockEnd:r$1,paddingBlockStart:r$1,paddingInline:r$1,paddingInlineEnd:r$1,paddingInlineStart:r$1,top:r$1,right:r$1,bottom:r$1,left:r$1,scrollMargin:r$1,scrollMarginTop:r$1,scrollMarginRight:r$1,scrollMarginBottom:r$1,scrollMarginLeft:r$1,scrollMarginX:r$1,scrollMarginY:r$1,scrollMarginBlock:r$1,scrollMarginBlockEnd:r$1,scrollMarginBlockStart:r$1,scrollMarginInline:r$1,scrollMarginInlineEnd:r$1,scrollMarginInlineStart:r$1,scrollPadding:r$1,scrollPaddingTop:r$1,scrollPaddingRight:r$1,scrollPaddingBottom:r$1,scrollPaddingLeft:r$1,scrollPaddingX:r$1,scrollPaddingY:r$1,scrollPaddingBlock:r$1,scrollPaddingBlockEnd:r$1,scrollPaddingBlockStart:r$1,scrollPaddingInline:r$1,scrollPaddingInlineEnd:r$1,scrollPaddingInlineStart:r$1,fontSize:"fontSizes",background:e$1,backgroundColor:e$1,backgroundImage:e$1,borderImage:e$1,border:e$1,borderBlock:e$1,borderBlockEnd:e$1,borderBlockStart:e$1,borderBottom:e$1,borderBottomColor:e$1,borderColor:e$1,borderInline:e$1,borderInlineEnd:e$1,borderInlineStart:e$1,borderLeft:e$1,borderLeftColor:e$1,borderRight:e$1,borderRightColor:e$1,borderTop:e$1,borderTopColor:e$1,caretColor:e$1,color:e$1,columnRuleColor:e$1,fill:e$1,outline:e$1,outlineColor:e$1,stroke:e$1,textDecorationColor:e$1,fontFamily:"fonts",fontWeight:"fontWeights",lineHeight:"lineHeights",letterSpacing:"letterSpacings",blockSize:t$1,minBlockSize:t$1,maxBlockSize:t$1,inlineSize:t$1,minInlineSize:t$1,maxInlineSize:t$1,width:t$1,minWidth:t$1,maxWidth:t$1,height:t$1,minHeight:t$1,maxHeight:t$1,flexBasis:t$1,gridTemplateColumns:t$1,gridTemplateRows:t$1,borderWidth:"borderWidths",borderTopWidth:"borderWidths",borderRightWidth:"borderWidths",borderBottomWidth:"borderWidths",borderLeftWidth:"borderWidths",borderStyle:"borderStyles",borderTopStyle:"borderStyles",borderRightStyle:"borderStyles",borderBottomStyle:"borderStyles",borderLeftStyle:"borderStyles",borderRadius:"radii",borderTopLeftRadius:"radii",borderTopRightRadius:"radii",borderBottomRightRadius:"radii",borderBottomLeftRadius:"radii",boxShadow:"shadows",textShadow:"shadows",transition:"transitions",zIndex:"zIndices"},i$2=(st,at)=>typeof at=="function"?{"()":Function.prototype.toString.call(at)}:at,o$1=()=>{const st=Object.create(null);return(at,pt,...vt)=>{const wt=($t=>JSON.stringify($t,i$2))(at);return wt in st?st[wt]:st[wt]=pt(at,...vt)}},l$1=Symbol.for("sxs.internal"),s$2=(st,at)=>Object.defineProperties(st,Object.getOwnPropertyDescriptors(at)),a$1=st=>{for(const at in st)return!0;return!1},{hasOwnProperty:c$2}=Object.prototype,d$2=st=>st.includes("-")?st:st.replace(/[A-Z]/g,at=>"-"+at.toLowerCase()),g$2=/\s+(?![^()]*\))/,p$2=st=>at=>st(...typeof at=="string"?String(at).split(g$2):[at]),u$2={appearance:st=>({WebkitAppearance:st,appearance:st}),backfaceVisibility:st=>({WebkitBackfaceVisibility:st,backfaceVisibility:st}),backdropFilter:st=>({WebkitBackdropFilter:st,backdropFilter:st}),backgroundClip:st=>({WebkitBackgroundClip:st,backgroundClip:st}),boxDecorationBreak:st=>({WebkitBoxDecorationBreak:st,boxDecorationBreak:st}),clipPath:st=>({WebkitClipPath:st,clipPath:st}),content:st=>({content:st.includes('"')||st.includes("'")||/^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(st)?st:`"${st}"`}),hyphens:st=>({WebkitHyphens:st,hyphens:st}),maskImage:st=>({WebkitMaskImage:st,maskImage:st}),maskSize:st=>({WebkitMaskSize:st,maskSize:st}),tabSize:st=>({MozTabSize:st,tabSize:st}),textSizeAdjust:st=>({WebkitTextSizeAdjust:st,textSizeAdjust:st}),userSelect:st=>({WebkitUserSelect:st,userSelect:st}),marginBlock:p$2((st,at)=>({marginBlockStart:st,marginBlockEnd:at||st})),marginInline:p$2((st,at)=>({marginInlineStart:st,marginInlineEnd:at||st})),maxSize:p$2((st,at)=>({maxBlockSize:st,maxInlineSize:at||st})),minSize:p$2((st,at)=>({minBlockSize:st,minInlineSize:at||st})),paddingBlock:p$2((st,at)=>({paddingBlockStart:st,paddingBlockEnd:at||st})),paddingInline:p$2((st,at)=>({paddingInlineStart:st,paddingInlineEnd:at||st}))},h$2=/([\d.]+)([^]*)/,f$2=(st,at)=>st.length?st.reduce((pt,vt)=>(pt.push(...at.map(wt=>wt.includes("&")?wt.replace(/&/g,/[ +>|~]/.test(vt)&&/&.*&/.test(wt)?`:is(${vt})`:vt):vt+" "+wt)),pt),[]):at,m$2=(st,at)=>st in b$2&&typeof at=="string"?at.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/,(pt,vt,wt,$t)=>vt+(wt==="stretch"?`-moz-available${$t};${d$2(st)}:${vt}-webkit-fill-available`:`-moz-fit-content${$t};${d$2(st)}:${vt}fit-content`)+$t):String(at),b$2={blockSize:1,height:1,inlineSize:1,maxBlockSize:1,maxHeight:1,maxInlineSize:1,maxWidth:1,minBlockSize:1,minHeight:1,minInlineSize:1,minWidth:1,width:1},S$2=st=>st?st+"-":"",k$2=(st,at,pt)=>st.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g,(vt,wt,$t,Tt,Lt)=>Tt=="$"==!!$t?vt:(wt||Tt=="--"?"calc(":"")+"var(--"+(Tt==="$"?S$2(at)+(Lt.includes("$")?"":S$2(pt))+Lt.replace(/\$/g,"-"):Lt)+")"+(wt||Tt=="--"?"*"+(wt||"")+($t||"1")+")":"")),y$2=/\s*,\s*(?![^()]*\))/,B$1=Object.prototype.toString,$$2=(st,at,pt,vt,wt)=>{let $t,Tt,Lt;const Ft=(Ct,Ht,Gt)=>{let jt,qt;const Kt=An=>{for(jt in An){const In=jt.charCodeAt(0)===64,tr=In&&Array.isArray(An[jt])?An[jt]:[An[jt]];for(qt of tr){const rr=/[A-Z]/.test(wn=jt)?wn:wn.replace(/-[^]/g,qr=>qr[1].toUpperCase()),Hr=typeof qt=="object"&&qt&&qt.toString===B$1&&(!vt.utils[rr]||!Ht.length);if(rr in vt.utils&&!Hr){const qr=vt.utils[rr];if(qr!==Tt){Tt=qr,Kt(qr(qt)),Tt=null;continue}}else if(rr in u$2){const qr=u$2[rr];if(qr!==Lt){Lt=qr,Kt(qr(qt)),Lt=null;continue}}if(In&&(Sn=jt.slice(1)in vt.media?"@media "+vt.media[jt.slice(1)]:jt,jt=Sn.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g,(qr,Zr,Bo,Xo,Kr,ko)=>{const f0=h$2.test(Zr),x0=.0625*(f0?-1:1),[l0,T0]=f0?[Xo,Zr]:[Zr,Xo];return"("+(Bo[0]==="="?"":Bo[0]===">"===f0?"max-":"min-")+l0+":"+(Bo[0]!=="="&&Bo.length===1?T0.replace(h$2,(t0,E0,n0)=>Number(E0)+x0*(Bo===">"?1:-1)+n0):T0)+(Kr?") and ("+(Kr[0]===">"?"min-":"max-")+l0+":"+(Kr.length===1?ko.replace(h$2,(t0,E0,n0)=>Number(E0)+x0*(Kr===">"?-1:1)+n0):ko):"")+")"})),Hr){const qr=In?Gt.concat(jt):[...Gt],Zr=In?[...Ht]:f$2(Ht,jt.split(y$2));$t!==void 0&&wt(x$1(...$t)),$t=void 0,Ft(qt,Zr,qr)}else $t===void 0&&($t=[[],Ht,Gt]),jt=In||jt.charCodeAt(0)!==36?jt:`--${S$2(vt.prefix)}${jt.slice(1).replace(/\$/g,"-")}`,qt=Hr?qt:typeof qt=="number"?qt&&rr in I$2?String(qt)+"px":String(qt):k$2(m$2(rr,qt??""),vt.prefix,vt.themeMap[rr]),$t[0].push(`${In?`${jt} `:`${d$2(jt)}:`}${qt}`)}}var Sn,wn};Kt(Ct),$t!==void 0&&wt(x$1(...$t)),$t=void 0};Ft(st,at,pt)},x$1=(st,at,pt)=>`${pt.map(vt=>`${vt}{`).join("")}${at.length?`${at.join(",")}{`:""}${st.join(";")}${at.length?"}":""}${Array(pt.length?pt.length+1:0).join("}")}`,I$2={animationDelay:1,animationDuration:1,backgroundSize:1,blockSize:1,border:1,borderBlock:1,borderBlockEnd:1,borderBlockEndWidth:1,borderBlockStart:1,borderBlockStartWidth:1,borderBlockWidth:1,borderBottom:1,borderBottomLeftRadius:1,borderBottomRightRadius:1,borderBottomWidth:1,borderEndEndRadius:1,borderEndStartRadius:1,borderInlineEnd:1,borderInlineEndWidth:1,borderInlineStart:1,borderInlineStartWidth:1,borderInlineWidth:1,borderLeft:1,borderLeftWidth:1,borderRadius:1,borderRight:1,borderRightWidth:1,borderSpacing:1,borderStartEndRadius:1,borderStartStartRadius:1,borderTop:1,borderTopLeftRadius:1,borderTopRightRadius:1,borderTopWidth:1,borderWidth:1,bottom:1,columnGap:1,columnRule:1,columnRuleWidth:1,columnWidth:1,containIntrinsicSize:1,flexBasis:1,fontSize:1,gap:1,gridAutoColumns:1,gridAutoRows:1,gridTemplateColumns:1,gridTemplateRows:1,height:1,inlineSize:1,inset:1,insetBlock:1,insetBlockEnd:1,insetBlockStart:1,insetInline:1,insetInlineEnd:1,insetInlineStart:1,left:1,letterSpacing:1,margin:1,marginBlock:1,marginBlockEnd:1,marginBlockStart:1,marginBottom:1,marginInline:1,marginInlineEnd:1,marginInlineStart:1,marginLeft:1,marginRight:1,marginTop:1,maxBlockSize:1,maxHeight:1,maxInlineSize:1,maxWidth:1,minBlockSize:1,minHeight:1,minInlineSize:1,minWidth:1,offsetDistance:1,offsetRotate:1,outline:1,outlineOffset:1,outlineWidth:1,overflowClipMargin:1,padding:1,paddingBlock:1,paddingBlockEnd:1,paddingBlockStart:1,paddingBottom:1,paddingInline:1,paddingInlineEnd:1,paddingInlineStart:1,paddingLeft:1,paddingRight:1,paddingTop:1,perspective:1,right:1,rowGap:1,scrollMargin:1,scrollMarginBlock:1,scrollMarginBlockEnd:1,scrollMarginBlockStart:1,scrollMarginBottom:1,scrollMarginInline:1,scrollMarginInlineEnd:1,scrollMarginInlineStart:1,scrollMarginLeft:1,scrollMarginRight:1,scrollMarginTop:1,scrollPadding:1,scrollPaddingBlock:1,scrollPaddingBlockEnd:1,scrollPaddingBlockStart:1,scrollPaddingBottom:1,scrollPaddingInline:1,scrollPaddingInlineEnd:1,scrollPaddingInlineStart:1,scrollPaddingLeft:1,scrollPaddingRight:1,scrollPaddingTop:1,shapeMargin:1,textDecoration:1,textDecorationThickness:1,textIndent:1,textUnderlineOffset:1,top:1,transitionDelay:1,transitionDuration:1,verticalAlign:1,width:1,wordSpacing:1},R$1=st=>String.fromCharCode(st+(st>25?39:97)),z$1=st=>(at=>{let pt,vt="";for(pt=Math.abs(at);pt>52;pt=pt/52|0)vt=R$1(pt%52)+vt;return R$1(pt%52)+vt})(((at,pt)=>{let vt=pt.length;for(;vt;)at=33*at^pt.charCodeAt(--vt);return at})(5381,JSON.stringify(st))>>>0),W=["themed","global","styled","onevar","resonevar","allvar","inline"],j$2=st=>{if(st.href&&!st.href.startsWith(location.origin))return!1;try{return!!st.cssRules}catch{return!1}},E=st=>{let at;const pt=()=>{const{cssRules:wt}=at.sheet;return[].map.call(wt,($t,Tt)=>{const{cssText:Lt}=$t;let Ft="";if(Lt.startsWith("--sxs"))return"";if(wt[Tt-1]&&(Ft=wt[Tt-1].cssText).startsWith("--sxs")){if(!$t.cssRules.length)return"";for(const Ct in at.rules)if(at.rules[Ct].group===$t)return`--sxs{--sxs:${[...at.rules[Ct].cache].join(" ")}}${Lt}`;return $t.cssRules.length?`${Ft}${Lt}`:""}return Lt}).join("")},vt=()=>{if(at){const{rules:Lt,sheet:Ft}=at;if(!Ft.deleteRule){for(;Object(Object(Ft.cssRules)[0]).type===3;)Ft.cssRules.splice(0,1);Ft.cssRules=[]}for(const Ct in Lt)delete Lt[Ct]}const wt=Object(st).styleSheets||[];for(const Lt of wt)if(j$2(Lt)){for(let Ft=0,Ct=Lt.cssRules;Ct[Ft];++Ft){const Ht=Object(Ct[Ft]);if(Ht.type!==1)continue;const Gt=Object(Ct[Ft+1]);if(Gt.type!==4)continue;++Ft;const{cssText:jt}=Ht;if(!jt.startsWith("--sxs"))continue;const qt=jt.slice(14,-3).trim().split(/\s+/),Kt=W[qt[0]];Kt&&(at||(at={sheet:Lt,reset:vt,rules:{},toString:pt}),at.rules[Kt]={group:Gt,index:Ft,cache:new Set(qt)})}if(at)break}if(!at){const Lt=(Ft,Ct)=>({type:Ct,cssRules:[],insertRule(Ht,Gt){this.cssRules.splice(Gt,0,Lt(Ht,{import:3,undefined:1}[(Ht.toLowerCase().match(/^@([a-z]+)/)||[])[1]]||4))},get cssText(){return Ft==="@media{}"?`@media{${[].map.call(this.cssRules,Ht=>Ht.cssText).join("")}}`:Ft}});at={sheet:st?(st.head||st).appendChild(document.createElement("style")).sheet:Lt("","text/css"),rules:{},reset:vt,toString:pt}}const{sheet:$t,rules:Tt}=at;for(let Lt=W.length-1;Lt>=0;--Lt){const Ft=W[Lt];if(!Tt[Ft]){const Ct=W[Lt+1],Ht=Tt[Ct]?Tt[Ct].index:$t.cssRules.length;$t.insertRule("@media{}",Ht),$t.insertRule(`--sxs{--sxs:${Lt}}`,Ht),Tt[Ft]={group:$t.cssRules[Ht+1],index:Ht,cache:new Set([Lt])}}v$2(Tt[Ft])}};return vt(),at},v$2=st=>{const at=st.group;let pt=at.cssRules.length;st.apply=vt=>{try{at.insertRule(vt,pt),++pt}catch{}}},T$1=Symbol(),w$1=o$1(),M$2=(st,at)=>w$1(st,()=>(...pt)=>{let vt={type:null,composers:new Set};for(const wt of pt)if(wt!=null)if(wt[l$1]){vt.type==null&&(vt.type=wt[l$1].type);for(const $t of wt[l$1].composers)vt.composers.add($t)}else wt.constructor!==Object||wt.$$typeof?vt.type==null&&(vt.type=wt):vt.composers.add(C(wt,st));return vt.type==null&&(vt.type="span"),vt.composers.size||vt.composers.add(["PJLV",{},[],[],{},[]]),P(st,vt,at)}),C=({variants:st,compoundVariants:at,defaultVariants:pt,...vt},wt)=>{const $t=`${S$2(wt.prefix)}c-${z$1(vt)}`,Tt=[],Lt=[],Ft=Object.create(null),Ct=[];for(const jt in pt)Ft[jt]=String(pt[jt]);if(typeof st=="object"&&st)for(const jt in st){Ht=Ft,Gt=jt,c$2.call(Ht,Gt)||(Ft[jt]="undefined");const qt=st[jt];for(const Kt in qt){const An={[jt]:String(Kt)};String(Kt)==="undefined"&&Ct.push(jt);const Sn=qt[Kt],wn=[An,Sn,!a$1(Sn)];Tt.push(wn)}}var Ht,Gt;if(typeof at=="object"&&at)for(const jt of at){let{css:qt,...Kt}=jt;qt=typeof qt=="object"&&qt||{};for(const Sn in Kt)Kt[Sn]=String(Kt[Sn]);const An=[Kt,qt,!a$1(qt)];Lt.push(An)}return[$t,vt,Tt,Lt,Ft,Ct]},P=(st,at,pt)=>{const[vt,wt,$t,Tt]=L$2(at.composers),Lt=typeof at.type=="function"||at.type.$$typeof?(Gt=>{function jt(){for(let qt=0;qt<jt[T$1].length;qt++){const[Kt,An]=jt[T$1][qt];Gt.rules[Kt].apply(An)}return jt[T$1]=[],null}return jt[T$1]=[],jt.rules={},W.forEach(qt=>jt.rules[qt]={apply:Kt=>jt[T$1].push([qt,Kt])}),jt})(pt):null,Ft=(Lt||pt).rules,Ct=`.${vt}${wt.length>1?`:where(.${wt.slice(1).join(".")})`:""}`,Ht=Gt=>{Gt=typeof Gt=="object"&&Gt||A;const{css:jt,...qt}=Gt,Kt={};for(const wn in $t)if(delete qt[wn],wn in Gt){let In=Gt[wn];typeof In=="object"&&In?Kt[wn]={"@initial":$t[wn],...In}:(In=String(In),Kt[wn]=In!=="undefined"||Tt.has(wn)?In:$t[wn])}else Kt[wn]=$t[wn];const An=new Set([...wt]);for(const[wn,In,tr,rr]of at.composers){pt.rules.styled.cache.has(wn)||(pt.rules.styled.cache.add(wn),$$2(In,[`.${wn}`],[],st,Zr=>{Ft.styled.apply(Zr)}));const Hr=O(tr,Kt,st.media),qr=O(rr,Kt,st.media,!0);for(const Zr of Hr)if(Zr!==void 0)for(const[Bo,Xo,Kr]of Zr){const ko=`${wn}-${z$1(Xo)}-${Bo}`;An.add(ko);const f0=(Kr?pt.rules.resonevar:pt.rules.onevar).cache,x0=Kr?Ft.resonevar:Ft.onevar;f0.has(ko)||(f0.add(ko),$$2(Xo,[`.${ko}`],[],st,l0=>{x0.apply(l0)}))}for(const Zr of qr)if(Zr!==void 0)for(const[Bo,Xo]of Zr){const Kr=`${wn}-${z$1(Xo)}-${Bo}`;An.add(Kr),pt.rules.allvar.cache.has(Kr)||(pt.rules.allvar.cache.add(Kr),$$2(Xo,[`.${Kr}`],[],st,ko=>{Ft.allvar.apply(ko)}))}}if(typeof jt=="object"&&jt){const wn=`${vt}-i${z$1(jt)}-css`;An.add(wn),pt.rules.inline.cache.has(wn)||(pt.rules.inline.cache.add(wn),$$2(jt,[`.${wn}`],[],st,In=>{Ft.inline.apply(In)}))}for(const wn of String(Gt.className||"").trim().split(/\s+/))wn&&An.add(wn);const Sn=qt.className=[...An].join(" ");return{type:at.type,className:Sn,selector:Ct,props:qt,toString:()=>Sn,deferredInjector:Lt}};return s$2(Ht,{className:vt,selector:Ct,[l$1]:at,toString:()=>(pt.rules.styled.cache.has(vt)||Ht(),vt)})},L$2=st=>{let at="";const pt=[],vt={},wt=[];for(const[$t,,,,Tt,Lt]of st){at===""&&(at=$t),pt.push($t),wt.push(...Lt);for(const Ft in Tt){const Ct=Tt[Ft];(vt[Ft]===void 0||Ct!=="undefined"||Lt.includes(Ct))&&(vt[Ft]=Ct)}}return[at,pt,vt,new Set(wt)]},O=(st,at,pt,vt)=>{const wt=[];e:for(let[$t,Tt,Lt]of st){if(Lt)continue;let Ft,Ct=0,Ht=!1;for(Ft in $t){const Gt=$t[Ft];let jt=at[Ft];if(jt!==Gt){if(typeof jt!="object"||!jt)continue e;{let qt,Kt,An=0;for(const Sn in jt){if(Gt===String(jt[Sn])){if(Sn!=="@initial"){const wn=Sn.slice(1);(Kt=Kt||[]).push(wn in pt?pt[wn]:Sn.replace(/^@media ?/,"")),Ht=!0}Ct+=An,qt=!0}++An}if(Kt&&Kt.length&&(Tt={["@media "+Kt.join(", ")]:Tt}),!qt)continue e}}}(wt[Ct]=wt[Ct]||[]).push([vt?"cv":`${Ft}-${$t[Ft]}`,Tt,Ht])}return wt},A={},N$1=o$1(),D=(st,at)=>N$1(st,()=>(...pt)=>{const vt=()=>{for(let wt of pt){wt=typeof wt=="object"&&wt||{};let $t=z$1(wt);if(!at.rules.global.cache.has($t)){if(at.rules.global.cache.add($t),"@import"in wt){let Tt=[].indexOf.call(at.sheet.cssRules,at.rules.themed.group)-1;for(let Lt of[].concat(wt["@import"]))Lt=Lt.includes('"')||Lt.includes("'")?Lt:`"${Lt}"`,at.sheet.insertRule(`@import ${Lt};`,Tt++);delete wt["@import"]}$$2(wt,[],[],st,Tt=>{at.rules.global.apply(Tt)})}}return""};return s$2(vt,{toString:vt})}),H$2=o$1(),V$2=(st,at)=>H$2(st,()=>pt=>{const vt=`${S$2(st.prefix)}k-${z$1(pt)}`,wt=()=>{if(!at.rules.global.cache.has(vt)){at.rules.global.cache.add(vt);const $t=[];$$2(pt,[],[],st,Lt=>$t.push(Lt));const Tt=`@keyframes ${vt}{${$t.join("")}}`;at.rules.global.apply(Tt)}return vt};return s$2(wt,{get name(){return wt()},toString:wt})}),G=class{constructor(st,at,pt,vt){this.token=st==null?"":String(st),this.value=at==null?"":String(at),this.scale=pt==null?"":String(pt),this.prefix=vt==null?"":String(vt)}get computedValue(){return"var("+this.variable+")"}get variable(){return"--"+S$2(this.prefix)+S$2(this.scale)+this.token}toString(){return this.computedValue}},F$1=o$1(),J$1=(st,at)=>F$1(st,()=>(pt,vt)=>{vt=typeof pt=="object"&&pt||Object(vt);const wt=`.${pt=(pt=typeof pt=="string"?pt:"")||`${S$2(st.prefix)}t-${z$1(vt)}`}`,$t={},Tt=[];for(const Ft in vt){$t[Ft]={};for(const Ct in vt[Ft]){const Ht=`--${S$2(st.prefix)}${Ft}-${Ct}`,Gt=k$2(String(vt[Ft][Ct]),st.prefix,Ft);$t[Ft][Ct]=new G(Ct,Gt,Ft,st.prefix),Tt.push(`${Ht}:${Gt}`)}}const Lt=()=>{if(Tt.length&&!at.rules.themed.cache.has(pt)){at.rules.themed.cache.add(pt);const Ft=`${vt===st.theme?":root,":""}.${pt}{${Tt.join(";")}}`;at.rules.themed.apply(Ft)}return pt};return{...$t,get className(){return Lt()},selector:wt,toString:Lt}}),U$3=o$1(),Y$1=o$1(),q$1=st=>{const at=(pt=>{let vt=!1;const wt=U$3(pt,$t=>{vt=!0;const Tt="prefix"in($t=typeof $t=="object"&&$t||{})?String($t.prefix):"",Lt=typeof $t.media=="object"&&$t.media||{},Ft=typeof $t.root=="object"?$t.root||null:globalThis.document||null,Ct=typeof $t.theme=="object"&&$t.theme||{},Ht={prefix:Tt,media:Lt,theme:Ct,themeMap:typeof $t.themeMap=="object"&&$t.themeMap||{...n$1},utils:typeof $t.utils=="object"&&$t.utils||{}},Gt=E(Ft),jt={css:M$2(Ht,Gt),globalCss:D(Ht,Gt),keyframes:V$2(Ht,Gt),createTheme:J$1(Ht,Gt),reset(){Gt.reset(),jt.theme.toString()},theme:{},sheet:Gt,config:Ht,prefix:Tt,getCssText:Gt.toString,toString:Gt.toString};return String(jt.theme=jt.createTheme(Ct)),jt});return vt||wt.reset(),wt})(st);return at.styled=(({config:pt,sheet:vt})=>Y$1(pt,()=>{const wt=M$2(pt,vt);return(...$t)=>{const Tt=wt(...$t),Lt=Tt[l$1].type,Ft=React.forwardRef((Ct,Ht)=>{const Gt=Ct&&Ct.as||Lt,{props:jt,deferredInjector:qt}=Tt(Ct);return delete jt.as,jt.ref=Ht,qt?React.createElement(React.Fragment,null,React.createElement(Gt,jt),React.createElement(qt,null)):React.createElement(Gt,jt)});return Ft.className=Tt.className,Ft.displayName=`Styled.${Lt.displayName||Lt.name||Lt}`,Ft.selector=Tt.selector,Ft.toString=()=>Tt.selector,Ft[l$1]=Tt[l$1],Ft}}))(at),at};function $e42e1063c40fb3ef$export$b9ecd428b558ff10(st,at,{checkForDefaultPrevented:pt=!0}={}){return function(wt){if(st==null||st(wt),pt===!1||!wt.defaultPrevented)return at==null?void 0:at(wt)}}function $c512c27ab02ef895$export$50c7b4e9d9f19c1(st,at=[]){let pt=[];function vt($t,Tt){const Lt=reactExports.createContext(Tt),Ft=pt.length;pt=[...pt,Tt];function Ct(Gt){const{scope:jt,children:qt,...Kt}=Gt,An=(jt==null?void 0:jt[st][Ft])||Lt,Sn=reactExports.useMemo(()=>Kt,Object.values(Kt));return reactExports.createElement(An.Provider,{value:Sn},qt)}function Ht(Gt,jt){const qt=(jt==null?void 0:jt[st][Ft])||Lt,Kt=reactExports.useContext(qt);if(Kt)return Kt;if(Tt!==void 0)return Tt;throw new Error(`\`${Gt}\` must be used within \`${$t}\``)}return Ct.displayName=$t+"Provider",[Ct,Ht]}const wt=()=>{const $t=pt.map(Tt=>reactExports.createContext(Tt));return function(Lt){const Ft=(Lt==null?void 0:Lt[st])||$t;return reactExports.useMemo(()=>({[`__scope${st}`]:{...Lt,[st]:Ft}}),[Lt,Ft])}};return wt.scopeName=st,[vt,$c512c27ab02ef895$var$composeContextScopes(wt,...at)]}function $c512c27ab02ef895$var$composeContextScopes(...st){const at=st[0];if(st.length===1)return at;const pt=()=>{const vt=st.map(wt=>({useScope:wt(),scopeName:wt.scopeName}));return function($t){const Tt=vt.reduce((Lt,{useScope:Ft,scopeName:Ct})=>{const Gt=Ft($t)[`__scope${Ct}`];return{...Lt,...Gt}},{});return reactExports.useMemo(()=>({[`__scope${at.scopeName}`]:Tt}),[Tt])}};return pt.scopeName=at.scopeName,pt}function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(st){const at=reactExports.useRef(st);return reactExports.useEffect(()=>{at.current=st}),reactExports.useMemo(()=>(...pt)=>{var vt;return(vt=at.current)===null||vt===void 0?void 0:vt.call(at,...pt)},[])}function $addc16e1bbe58fd0$export$3a72a57244d6e765(st,at=globalThis==null?void 0:globalThis.document){const pt=$b1b2314f5f9a1d84$export$25bec8c6f54ee79a(st);reactExports.useEffect(()=>{const vt=wt=>{wt.key==="Escape"&&pt(wt)};return at.addEventListener("keydown",vt),()=>at.removeEventListener("keydown",vt)},[pt,at])}const $5cb92bef7577960e$var$CONTEXT_UPDATE="dismissableLayer.update",$5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE="dismissableLayer.pointerDownOutside",$5cb92bef7577960e$var$FOCUS_OUTSIDE="dismissableLayer.focusOutside";let $5cb92bef7577960e$var$originalBodyPointerEvents;const $5cb92bef7577960e$var$DismissableLayerContext=reactExports.createContext({layers:new Set,layersWithOutsidePointerEventsDisabled:new Set,branches:new Set}),$5cb92bef7577960e$export$177fb62ff3ec1f22=reactExports.forwardRef((st,at)=>{var pt;const{disableOutsidePointerEvents:vt=!1,onEscapeKeyDown:wt,onPointerDownOutside:$t,onFocusOutside:Tt,onInteractOutside:Lt,onDismiss:Ft,...Ct}=st,Ht=reactExports.useContext($5cb92bef7577960e$var$DismissableLayerContext),[Gt,jt]=reactExports.useState(null),qt=(pt=Gt==null?void 0:Gt.ownerDocument)!==null&&pt!==void 0?pt:globalThis==null?void 0:globalThis.document,[,Kt]=reactExports.useState({}),An=$6ed0406888f73fc4$export$c7b2cbe3552a0d05(at,Bo=>jt(Bo)),Sn=Array.from(Ht.layers),[wn]=[...Ht.layersWithOutsidePointerEventsDisabled].slice(-1),In=Sn.indexOf(wn),tr=Gt?Sn.indexOf(Gt):-1,rr=Ht.layersWithOutsidePointerEventsDisabled.size>0,Hr=tr>=In,qr=$5cb92bef7577960e$var$usePointerDownOutside(Bo=>{const Xo=Bo.target,Kr=[...Ht.branches].some(ko=>ko.contains(Xo));!Hr||Kr||($t==null||$t(Bo),Lt==null||Lt(Bo),Bo.defaultPrevented||Ft==null||Ft())},qt),Zr=$5cb92bef7577960e$var$useFocusOutside(Bo=>{const Xo=Bo.target;[...Ht.branches].some(ko=>ko.contains(Xo))||(Tt==null||Tt(Bo),Lt==null||Lt(Bo),Bo.defaultPrevented||Ft==null||Ft())},qt);return $addc16e1bbe58fd0$export$3a72a57244d6e765(Bo=>{tr===Ht.layers.size-1&&(wt==null||wt(Bo),!Bo.defaultPrevented&&Ft&&(Bo.preventDefault(),Ft()))},qt),reactExports.useEffect(()=>{if(Gt)return vt&&(Ht.layersWithOutsidePointerEventsDisabled.size===0&&($5cb92bef7577960e$var$originalBodyPointerEvents=qt.body.style.pointerEvents,qt.body.style.pointerEvents="none"),Ht.layersWithOutsidePointerEventsDisabled.add(Gt)),Ht.layers.add(Gt),$5cb92bef7577960e$var$dispatchUpdate(),()=>{vt&&Ht.layersWithOutsidePointerEventsDisabled.size===1&&(qt.body.style.pointerEvents=$5cb92bef7577960e$var$originalBodyPointerEvents)}},[Gt,qt,vt,Ht]),reactExports.useEffect(()=>()=>{Gt&&(Ht.layers.delete(Gt),Ht.layersWithOutsidePointerEventsDisabled.delete(Gt),$5cb92bef7577960e$var$dispatchUpdate())},[Gt,Ht]),reactExports.useEffect(()=>{const Bo=()=>Kt({});return document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE,Bo),()=>document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE,Bo)},[]),reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div,_extends$1({},Ct,{ref:An,style:{pointerEvents:rr?Hr?"auto":"none":void 0,...st.style},onFocusCapture:$e42e1063c40fb3ef$export$b9ecd428b558ff10(st.onFocusCapture,Zr.onFocusCapture),onBlurCapture:$e42e1063c40fb3ef$export$b9ecd428b558ff10(st.onBlurCapture,Zr.onBlurCapture),onPointerDownCapture:$e42e1063c40fb3ef$export$b9ecd428b558ff10(st.onPointerDownCapture,qr.onPointerDownCapture)}))});function $5cb92bef7577960e$var$usePointerDownOutside(st,at=globalThis==null?void 0:globalThis.document){const pt=$b1b2314f5f9a1d84$export$25bec8c6f54ee79a(st),vt=reactExports.useRef(!1),wt=reactExports.useRef(()=>{});return reactExports.useEffect(()=>{const $t=Lt=>{if(Lt.target&&!vt.current){let Ht=function(){$5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE,pt,Ct,{discrete:!0})};var Ft=Ht;const Ct={originalEvent:Lt};Lt.pointerType==="touch"?(at.removeEventListener("click",wt.current),wt.current=Ht,at.addEventListener("click",wt.current,{once:!0})):Ht()}else at.removeEventListener("click",wt.current);vt.current=!1},Tt=window.setTimeout(()=>{at.addEventListener("pointerdown",$t)},0);return()=>{window.clearTimeout(Tt),at.removeEventListener("pointerdown",$t),at.removeEventListener("click",wt.current)}},[at,pt]),{onPointerDownCapture:()=>vt.current=!0}}function $5cb92bef7577960e$var$useFocusOutside(st,at=globalThis==null?void 0:globalThis.document){const pt=$b1b2314f5f9a1d84$export$25bec8c6f54ee79a(st),vt=reactExports.useRef(!1);return reactExports.useEffect(()=>{const wt=$t=>{$t.target&&!vt.current&&$5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE,pt,{originalEvent:$t},{discrete:!1})};return at.addEventListener("focusin",wt),()=>at.removeEventListener("focusin",wt)},[at,pt]),{onFocusCapture:()=>vt.current=!0,onBlurCapture:()=>vt.current=!1}}function $5cb92bef7577960e$var$dispatchUpdate(){const st=new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);document.dispatchEvent(st)}function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(st,at,pt,{discrete:vt}){const wt=pt.originalEvent.target,$t=new CustomEvent(st,{bubbles:!1,cancelable:!0,detail:pt});at&&wt.addEventListener(st,at,{once:!0}),vt?$8927f6f2acc4f386$export$6d1a0317bde7de7f(wt,$t):wt.dispatchEvent($t)}const $9f79659886946c16$export$e5c5a5f917a5871c=globalThis!=null&&globalThis.document?reactExports.useLayoutEffect:()=>{},$1746a345f3d73bb7$var$useReactId=$2AODx$react.useId||(()=>{});let $1746a345f3d73bb7$var$count=0;function $1746a345f3d73bb7$export$f680877a34711e37(st){const[at,pt]=reactExports.useState($1746a345f3d73bb7$var$useReactId());return $9f79659886946c16$export$e5c5a5f917a5871c(()=>{pt(vt=>vt??String($1746a345f3d73bb7$var$count++))},[st]),at?`radix-${at}`:""}const sides=["top","right","bottom","left"],min=Math.min,max=Math.max,round=Math.round,floor=Math.floor,createCoords=st=>({x:st,y:st}),oppositeSideMap={left:"right",right:"left",bottom:"top",top:"bottom"},oppositeAlignmentMap={start:"end",end:"start"};function clamp$1(st,at,pt){return max(st,min(at,pt))}function evaluate$1(st,at){return typeof st=="function"?st(at):st}function getSide(st){return st.split("-")[0]}function getAlignment(st){return st.split("-")[1]}function getOppositeAxis(st){return st==="x"?"y":"x"}function getAxisLength(st){return st==="y"?"height":"width"}function getSideAxis(st){return["top","bottom"].includes(getSide(st))?"y":"x"}function getAlignmentAxis(st){return getOppositeAxis(getSideAxis(st))}function getAlignmentSides(st,at,pt){pt===void 0&&(pt=!1);const vt=getAlignment(st),wt=getAlignmentAxis(st),$t=getAxisLength(wt);let Tt=wt==="x"?vt===(pt?"end":"start")?"right":"left":vt==="start"?"bottom":"top";return at.reference[$t]>at.floating[$t]&&(Tt=getOppositePlacement(Tt)),[Tt,getOppositePlacement(Tt)]}function getExpandedPlacements(st){const at=getOppositePlacement(st);return[getOppositeAlignmentPlacement(st),at,getOppositeAlignmentPlacement(at)]}function getOppositeAlignmentPlacement(st){return st.replace(/start|end/g,at=>oppositeAlignmentMap[at])}function getSideList(st,at,pt){const vt=["left","right"],wt=["right","left"],$t=["top","bottom"],Tt=["bottom","top"];switch(st){case"top":case"bottom":return pt?at?wt:vt:at?vt:wt;case"left":case"right":return at?$t:Tt;default:return[]}}function getOppositeAxisPlacements(st,at,pt,vt){const wt=getAlignment(st);let $t=getSideList(getSide(st),pt==="start",vt);return wt&&($t=$t.map(Tt=>Tt+"-"+wt),at&&($t=$t.concat($t.map(getOppositeAlignmentPlacement)))),$t}function getOppositePlacement(st){return st.replace(/left|right|bottom|top/g,at=>oppositeSideMap[at])}function expandPaddingObject(st){return{top:0,right:0,bottom:0,left:0,...st}}function getPaddingObject(st){return typeof st!="number"?expandPaddingObject(st):{top:st,right:st,bottom:st,left:st}}function rectToClientRect(st){const{x:at,y:pt,width:vt,height:wt}=st;return{width:vt,height:wt,top:pt,left:at,right:at+vt,bottom:pt+wt,x:at,y:pt}}function computeCoordsFromPlacement(st,at,pt){let{reference:vt,floating:wt}=st;const $t=getSideAxis(at),Tt=getAlignmentAxis(at),Lt=getAxisLength(Tt),Ft=getSide(at),Ct=$t==="y",Ht=vt.x+vt.width/2-wt.width/2,Gt=vt.y+vt.height/2-wt.height/2,jt=vt[Lt]/2-wt[Lt]/2;let qt;switch(Ft){case"top":qt={x:Ht,y:vt.y-wt.height};break;case"bottom":qt={x:Ht,y:vt.y+vt.height};break;case"right":qt={x:vt.x+vt.width,y:Gt};break;case"left":qt={x:vt.x-wt.width,y:Gt};break;default:qt={x:vt.x,y:vt.y}}switch(getAlignment(at)){case"start":qt[Tt]-=jt*(pt&&Ct?-1:1);break;case"end":qt[Tt]+=jt*(pt&&Ct?-1:1);break}return qt}const computePosition$1=async(st,at,pt)=>{const{placement:vt="bottom",strategy:wt="absolute",middleware:$t=[],platform:Tt}=pt,Lt=$t.filter(Boolean),Ft=await(Tt.isRTL==null?void 0:Tt.isRTL(at));let Ct=await Tt.getElementRects({reference:st,floating:at,strategy:wt}),{x:Ht,y:Gt}=computeCoordsFromPlacement(Ct,vt,Ft),jt=vt,qt={},Kt=0;for(let An=0;An<Lt.length;An++){const{name:Sn,fn:wn}=Lt[An],{x:In,y:tr,data:rr,reset:Hr}=await wn({x:Ht,y:Gt,initialPlacement:vt,placement:jt,strategy:wt,middlewareData:qt,rects:Ct,platform:Tt,elements:{reference:st,floating:at}});Ht=In??Ht,Gt=tr??Gt,qt={...qt,[Sn]:{...qt[Sn],...rr}},Hr&&Kt<=50&&(Kt++,typeof Hr=="object"&&(Hr.placement&&(jt=Hr.placement),Hr.rects&&(Ct=Hr.rects===!0?await Tt.getElementRects({reference:st,floating:at,strategy:wt}):Hr.rects),{x:Ht,y:Gt}=computeCoordsFromPlacement(Ct,jt,Ft)),An=-1)}return{x:Ht,y:Gt,placement:jt,strategy:wt,middlewareData:qt}};async function detectOverflow(st,at){var pt;at===void 0&&(at={});const{x:vt,y:wt,platform:$t,rects:Tt,elements:Lt,strategy:Ft}=st,{boundary:Ct="clippingAncestors",rootBoundary:Ht="viewport",elementContext:Gt="floating",altBoundary:jt=!1,padding:qt=0}=evaluate$1(at,st),Kt=getPaddingObject(qt),Sn=Lt[jt?Gt==="floating"?"reference":"floating":Gt],wn=rectToClientRect(await $t.getClippingRect({element:(pt=await($t.isElement==null?void 0:$t.isElement(Sn)))==null||pt?Sn:Sn.contextElement||await($t.getDocumentElement==null?void 0:$t.getDocumentElement(Lt.floating)),boundary:Ct,rootBoundary:Ht,strategy:Ft})),In=Gt==="floating"?{x:vt,y:wt,width:Tt.floating.width,height:Tt.floating.height}:Tt.reference,tr=await($t.getOffsetParent==null?void 0:$t.getOffsetParent(Lt.floating)),rr=await($t.isElement==null?void 0:$t.isElement(tr))?await($t.getScale==null?void 0:$t.getScale(tr))||{x:1,y:1}:{x:1,y:1},Hr=rectToClientRect($t.convertOffsetParentRelativeRectToViewportRelativeRect?await $t.convertOffsetParentRelativeRectToViewportRelativeRect({elements:Lt,rect:In,offsetParent:tr,strategy:Ft}):In);return{top:(wn.top-Hr.top+Kt.top)/rr.y,bottom:(Hr.bottom-wn.bottom+Kt.bottom)/rr.y,left:(wn.left-Hr.left+Kt.left)/rr.x,right:(Hr.right-wn.right+Kt.right)/rr.x}}const arrow$3=st=>({name:"arrow",options:st,async fn(at){const{x:pt,y:vt,placement:wt,rects:$t,platform:Tt,elements:Lt,middlewareData:Ft}=at,{element:Ct,padding:Ht=0}=evaluate$1(st,at)||{};if(Ct==null)return{};const Gt=getPaddingObject(Ht),jt={x:pt,y:vt},qt=getAlignmentAxis(wt),Kt=getAxisLength(qt),An=await Tt.getDimensions(Ct),Sn=qt==="y",wn=Sn?"top":"left",In=Sn?"bottom":"right",tr=Sn?"clientHeight":"clientWidth",rr=$t.reference[Kt]+$t.reference[qt]-jt[qt]-$t.floating[Kt],Hr=jt[qt]-$t.reference[qt],qr=await(Tt.getOffsetParent==null?void 0:Tt.getOffsetParent(Ct));let Zr=qr?qr[tr]:0;(!Zr||!await(Tt.isElement==null?void 0:Tt.isElement(qr)))&&(Zr=Lt.floating[tr]||$t.floating[Kt]);const Bo=rr/2-Hr/2,Xo=Zr/2-An[Kt]/2-1,Kr=min(Gt[wn],Xo),ko=min(Gt[In],Xo),f0=Kr,x0=Zr-An[Kt]-ko,l0=Zr/2-An[Kt]/2+Bo,T0=clamp$1(f0,l0,x0),t0=!Ft.arrow&&getAlignment(wt)!=null&&l0!==T0&&$t.reference[Kt]/2-(l0<f0?Kr:ko)-An[Kt]/2<0,E0=t0?l0<f0?l0-f0:l0-x0:0;return{[qt]:jt[qt]+E0,data:{[qt]:T0,centerOffset:l0-T0-E0,...t0&&{alignmentOffset:E0}},reset:t0}}}),flip$2=function(st){return st===void 0&&(st={}),{name:"flip",options:st,async fn(at){var pt,vt;const{placement:wt,middlewareData:$t,rects:Tt,initialPlacement:Lt,platform:Ft,elements:Ct}=at,{mainAxis:Ht=!0,crossAxis:Gt=!0,fallbackPlacements:jt,fallbackStrategy:qt="bestFit",fallbackAxisSideDirection:Kt="none",flipAlignment:An=!0,...Sn}=evaluate$1(st,at);if((pt=$t.arrow)!=null&&pt.alignmentOffset)return{};const wn=getSide(wt),In=getSide(Lt)===Lt,tr=await(Ft.isRTL==null?void 0:Ft.isRTL(Ct.floating)),rr=jt||(In||!An?[getOppositePlacement(Lt)]:getExpandedPlacements(Lt));!jt&&Kt!=="none"&&rr.push(...getOppositeAxisPlacements(Lt,An,Kt,tr));const Hr=[Lt,...rr],qr=await detectOverflow(at,Sn),Zr=[];let Bo=((vt=$t.flip)==null?void 0:vt.overflows)||[];if(Ht&&Zr.push(qr[wn]),Gt){const f0=getAlignmentSides(wt,Tt,tr);Zr.push(qr[f0[0]],qr[f0[1]])}if(Bo=[...Bo,{placement:wt,overflows:Zr}],!Zr.every(f0=>f0<=0)){var Xo,Kr;const f0=(((Xo=$t.flip)==null?void 0:Xo.index)||0)+1,x0=Hr[f0];if(x0)return{data:{index:f0,overflows:Bo},reset:{placement:x0}};let l0=(Kr=Bo.filter(T0=>T0.overflows[0]<=0).sort((T0,t0)=>T0.overflows[1]-t0.overflows[1])[0])==null?void 0:Kr.placement;if(!l0)switch(qt){case"bestFit":{var ko;const T0=(ko=Bo.map(t0=>[t0.placement,t0.overflows.filter(E0=>E0>0).reduce((E0,n0)=>E0+n0,0)]).sort((t0,E0)=>t0[1]-E0[1])[0])==null?void 0:ko[0];T0&&(l0=T0);break}case"initialPlacement":l0=Lt;break}if(wt!==l0)return{reset:{placement:l0}}}return{}}}};function getSideOffsets(st,at){return{top:st.top-at.height,right:st.right-at.width,bottom:st.bottom-at.height,left:st.left-at.width}}function isAnySideFullyClipped(st){return sides.some(at=>st[at]>=0)}const hide$2=function(st){return st===void 0&&(st={}),{name:"hide",options:st,async fn(at){const{rects:pt}=at,{strategy:vt="referenceHidden",...wt}=evaluate$1(st,at);switch(vt){case"referenceHidden":{const $t=await detectOverflow(at,{...wt,elementContext:"reference"}),Tt=getSideOffsets($t,pt.reference);return{data:{referenceHiddenOffsets:Tt,referenceHidden:isAnySideFullyClipped(Tt)}}}case"escaped":{const $t=await detectOverflow(at,{...wt,altBoundary:!0}),Tt=getSideOffsets($t,pt.floating);return{data:{escapedOffsets:Tt,escaped:isAnySideFullyClipped(Tt)}}}default:return{}}}}};async function convertValueToCoords(st,at){const{placement:pt,platform:vt,elements:wt}=st,$t=await(vt.isRTL==null?void 0:vt.isRTL(wt.floating)),Tt=getSide(pt),Lt=getAlignment(pt),Ft=getSideAxis(pt)==="y",Ct=["left","top"].includes(Tt)?-1:1,Ht=$t&&Ft?-1:1,Gt=evaluate$1(at,st);let{mainAxis:jt,crossAxis:qt,alignmentAxis:Kt}=typeof Gt=="number"?{mainAxis:Gt,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...Gt};return Lt&&typeof Kt=="number"&&(qt=Lt==="end"?Kt*-1:Kt),Ft?{x:qt*Ht,y:jt*Ct}:{x:jt*Ct,y:qt*Ht}}const offset$2=function(st){return st===void 0&&(st=0),{name:"offset",options:st,async fn(at){var pt,vt;const{x:wt,y:$t,placement:Tt,middlewareData:Lt}=at,Ft=await convertValueToCoords(at,st);return Tt===((pt=Lt.offset)==null?void 0:pt.placement)&&(vt=Lt.arrow)!=null&&vt.alignmentOffset?{}:{x:wt+Ft.x,y:$t+Ft.y,data:{...Ft,placement:Tt}}}}},shift$2=function(st){return st===void 0&&(st={}),{name:"shift",options:st,async fn(at){const{x:pt,y:vt,placement:wt}=at,{mainAxis:$t=!0,crossAxis:Tt=!1,limiter:Lt={fn:Sn=>{let{x:wn,y:In}=Sn;return{x:wn,y:In}}},...Ft}=evaluate$1(st,at),Ct={x:pt,y:vt},Ht=await detectOverflow(at,Ft),Gt=getSideAxis(getSide(wt)),jt=getOppositeAxis(Gt);let qt=Ct[jt],Kt=Ct[Gt];if($t){const Sn=jt==="y"?"top":"left",wn=jt==="y"?"bottom":"right",In=qt+Ht[Sn],tr=qt-Ht[wn];qt=clamp$1(In,qt,tr)}if(Tt){const Sn=Gt==="y"?"top":"left",wn=Gt==="y"?"bottom":"right",In=Kt+Ht[Sn],tr=Kt-Ht[wn];Kt=clamp$1(In,Kt,tr)}const An=Lt.fn({...at,[jt]:qt,[Gt]:Kt});return{...An,data:{x:An.x-pt,y:An.y-vt}}}}},limitShift$2=function(st){return st===void 0&&(st={}),{options:st,fn(at){const{x:pt,y:vt,placement:wt,rects:$t,middlewareData:Tt}=at,{offset:Lt=0,mainAxis:Ft=!0,crossAxis:Ct=!0}=evaluate$1(st,at),Ht={x:pt,y:vt},Gt=getSideAxis(wt),jt=getOppositeAxis(Gt);let qt=Ht[jt],Kt=Ht[Gt];const An=evaluate$1(Lt,at),Sn=typeof An=="number"?{mainAxis:An,crossAxis:0}:{mainAxis:0,crossAxis:0,...An};if(Ft){const tr=jt==="y"?"height":"width",rr=$t.reference[jt]-$t.floating[tr]+Sn.mainAxis,Hr=$t.reference[jt]+$t.reference[tr]-Sn.mainAxis;qt<rr?qt=rr:qt>Hr&&(qt=Hr)}if(Ct){var wn,In;const tr=jt==="y"?"width":"height",rr=["top","left"].includes(getSide(wt)),Hr=$t.reference[Gt]-$t.floating[tr]+(rr&&((wn=Tt.offset)==null?void 0:wn[Gt])||0)+(rr?0:Sn.crossAxis),qr=$t.reference[Gt]+$t.reference[tr]+(rr?0:((In=Tt.offset)==null?void 0:In[Gt])||0)-(rr?Sn.crossAxis:0);Kt<Hr?Kt=Hr:Kt>qr&&(Kt=qr)}return{[jt]:qt,[Gt]:Kt}}}},size$2=function(st){return st===void 0&&(st={}),{name:"size",options:st,async fn(at){const{placement:pt,rects:vt,platform:wt,elements:$t}=at,{apply:Tt=()=>{},...Lt}=evaluate$1(st,at),Ft=await detectOverflow(at,Lt),Ct=getSide(pt),Ht=getAlignment(pt),Gt=getSideAxis(pt)==="y",{width:jt,height:qt}=vt.floating;let Kt,An;Ct==="top"||Ct==="bottom"?(Kt=Ct,An=Ht===(await(wt.isRTL==null?void 0:wt.isRTL($t.floating))?"start":"end")?"left":"right"):(An=Ct,Kt=Ht==="end"?"top":"bottom");const Sn=qt-Ft.top-Ft.bottom,wn=jt-Ft.left-Ft.right,In=min(qt-Ft[Kt],Sn),tr=min(jt-Ft[An],wn),rr=!at.middlewareData.shift;let Hr=In,qr=tr;if(Gt?qr=Ht||rr?min(tr,wn):wn:Hr=Ht||rr?min(In,Sn):Sn,rr&&!Ht){const Bo=max(Ft.left,0),Xo=max(Ft.right,0),Kr=max(Ft.top,0),ko=max(Ft.bottom,0);Gt?qr=jt-2*(Bo!==0||Xo!==0?Bo+Xo:max(Ft.left,Ft.right)):Hr=qt-2*(Kr!==0||ko!==0?Kr+ko:max(Ft.top,Ft.bottom))}await Tt({...at,availableWidth:qr,availableHeight:Hr});const Zr=await wt.getDimensions($t.floating);return jt!==Zr.width||qt!==Zr.height?{reset:{rects:!0}}:{}}}};function getNodeName(st){return isNode(st)?(st.nodeName||"").toLowerCase():"#document"}function getWindow(st){var at;return(st==null||(at=st.ownerDocument)==null?void 0:at.defaultView)||window}function getDocumentElement(st){var at;return(at=(isNode(st)?st.ownerDocument:st.document)||window.document)==null?void 0:at.documentElement}function isNode(st){return st instanceof Node||st instanceof getWindow(st).Node}function isElement(st){return st instanceof Element||st instanceof getWindow(st).Element}function isHTMLElement(st){return st instanceof HTMLElement||st instanceof getWindow(st).HTMLElement}function isShadowRoot(st){return typeof ShadowRoot>"u"?!1:st instanceof ShadowRoot||st instanceof getWindow(st).ShadowRoot}function isOverflowElement(st){const{overflow:at,overflowX:pt,overflowY:vt,display:wt}=getComputedStyle$1(st);return/auto|scroll|overlay|hidden|clip/.test(at+vt+pt)&&!["inline","contents"].includes(wt)}function isTableElement(st){return["table","td","th"].includes(getNodeName(st))}function isContainingBlock(st){const at=isWebKit(),pt=getComputedStyle$1(st);return pt.transform!=="none"||pt.perspective!=="none"||(pt.containerType?pt.containerType!=="normal":!1)||!at&&(pt.backdropFilter?pt.backdropFilter!=="none":!1)||!at&&(pt.filter?pt.filter!=="none":!1)||["transform","perspective","filter"].some(vt=>(pt.willChange||"").includes(vt))||["paint","layout","strict","content"].some(vt=>(pt.contain||"").includes(vt))}function getContainingBlock(st){let at=getParentNode(st);for(;isHTMLElement(at)&&!isLastTraversableNode(at);){if(isContainingBlock(at))return at;at=getParentNode(at)}return null}function isWebKit(){return typeof CSS>"u"||!CSS.supports?!1:CSS.supports("-webkit-backdrop-filter","none")}function isLastTraversableNode(st){return["html","body","#document"].includes(getNodeName(st))}function getComputedStyle$1(st){return getWindow(st).getComputedStyle(st)}function getNodeScroll(st){return isElement(st)?{scrollLeft:st.scrollLeft,scrollTop:st.scrollTop}:{scrollLeft:st.pageXOffset,scrollTop:st.pageYOffset}}function getParentNode(st){if(getNodeName(st)==="html")return st;const at=st.assignedSlot||st.parentNode||isShadowRoot(st)&&st.host||getDocumentElement(st);return isShadowRoot(at)?at.host:at}function getNearestOverflowAncestor(st){const at=getParentNode(st);return isLastTraversableNode(at)?st.ownerDocument?st.ownerDocument.body:st.body:isHTMLElement(at)&&isOverflowElement(at)?at:getNearestOverflowAncestor(at)}function getOverflowAncestors(st,at,pt){var vt;at===void 0&&(at=[]),pt===void 0&&(pt=!0);const wt=getNearestOverflowAncestor(st),$t=wt===((vt=st.ownerDocument)==null?void 0:vt.body),Tt=getWindow(wt);return $t?at.concat(Tt,Tt.visualViewport||[],isOverflowElement(wt)?wt:[],Tt.frameElement&&pt?getOverflowAncestors(Tt.frameElement):[]):at.concat(wt,getOverflowAncestors(wt,[],pt))}function getCssDimensions(st){const at=getComputedStyle$1(st);let pt=parseFloat(at.width)||0,vt=parseFloat(at.height)||0;const wt=isHTMLElement(st),$t=wt?st.offsetWidth:pt,Tt=wt?st.offsetHeight:vt,Lt=round(pt)!==$t||round(vt)!==Tt;return Lt&&(pt=$t,vt=Tt),{width:pt,height:vt,$:Lt}}function unwrapElement(st){return isElement(st)?st:st.contextElement}function getScale(st){const at=unwrapElement(st);if(!isHTMLElement(at))return createCoords(1);const pt=at.getBoundingClientRect(),{width:vt,height:wt,$:$t}=getCssDimensions(at);let Tt=($t?round(pt.width):pt.width)/vt,Lt=($t?round(pt.height):pt.height)/wt;return(!Tt||!Number.isFinite(Tt))&&(Tt=1),(!Lt||!Number.isFinite(Lt))&&(Lt=1),{x:Tt,y:Lt}}const noOffsets=createCoords(0);function getVisualOffsets(st){const at=getWindow(st);return!isWebKit()||!at.visualViewport?noOffsets:{x:at.visualViewport.offsetLeft,y:at.visualViewport.offsetTop}}function shouldAddVisualOffsets(st,at,pt){return at===void 0&&(at=!1),!pt||at&&pt!==getWindow(st)?!1:at}function getBoundingClientRect(st,at,pt,vt){at===void 0&&(at=!1),pt===void 0&&(pt=!1);const wt=st.getBoundingClientRect(),$t=unwrapElement(st);let Tt=createCoords(1);at&&(vt?isElement(vt)&&(Tt=getScale(vt)):Tt=getScale(st));const Lt=shouldAddVisualOffsets($t,pt,vt)?getVisualOffsets($t):createCoords(0);let Ft=(wt.left+Lt.x)/Tt.x,Ct=(wt.top+Lt.y)/Tt.y,Ht=wt.width/Tt.x,Gt=wt.height/Tt.y;if($t){const jt=getWindow($t),qt=vt&&isElement(vt)?getWindow(vt):vt;let Kt=jt,An=Kt.frameElement;for(;An&&vt&&qt!==Kt;){const Sn=getScale(An),wn=An.getBoundingClientRect(),In=getComputedStyle$1(An),tr=wn.left+(An.clientLeft+parseFloat(In.paddingLeft))*Sn.x,rr=wn.top+(An.clientTop+parseFloat(In.paddingTop))*Sn.y;Ft*=Sn.x,Ct*=Sn.y,Ht*=Sn.x,Gt*=Sn.y,Ft+=tr,Ct+=rr,Kt=getWindow(An),An=Kt.frameElement}}return rectToClientRect({width:Ht,height:Gt,x:Ft,y:Ct})}const topLayerSelectors=[":popover-open",":modal"];function isTopLayer(st){return topLayerSelectors.some(at=>{try{return st.matches(at)}catch{return!1}})}function convertOffsetParentRelativeRectToViewportRelativeRect(st){let{elements:at,rect:pt,offsetParent:vt,strategy:wt}=st;const $t=wt==="fixed",Tt=getDocumentElement(vt),Lt=at?isTopLayer(at.floating):!1;if(vt===Tt||Lt&&$t)return pt;let Ft={scrollLeft:0,scrollTop:0},Ct=createCoords(1);const Ht=createCoords(0),Gt=isHTMLElement(vt);if((Gt||!Gt&&!$t)&&((getNodeName(vt)!=="body"||isOverflowElement(Tt))&&(Ft=getNodeScroll(vt)),isHTMLElement(vt))){const jt=getBoundingClientRect(vt);Ct=getScale(vt),Ht.x=jt.x+vt.clientLeft,Ht.y=jt.y+vt.clientTop}return{width:pt.width*Ct.x,height:pt.height*Ct.y,x:pt.x*Ct.x-Ft.scrollLeft*Ct.x+Ht.x,y:pt.y*Ct.y-Ft.scrollTop*Ct.y+Ht.y}}function getClientRects(st){return Array.from(st.getClientRects())}function getWindowScrollBarX(st){return getBoundingClientRect(getDocumentElement(st)).left+getNodeScroll(st).scrollLeft}function getDocumentRect(st){const at=getDocumentElement(st),pt=getNodeScroll(st),vt=st.ownerDocument.body,wt=max(at.scrollWidth,at.clientWidth,vt.scrollWidth,vt.clientWidth),$t=max(at.scrollHeight,at.clientHeight,vt.scrollHeight,vt.clientHeight);let Tt=-pt.scrollLeft+getWindowScrollBarX(st);const Lt=-pt.scrollTop;return getComputedStyle$1(vt).direction==="rtl"&&(Tt+=max(at.clientWidth,vt.clientWidth)-wt),{width:wt,height:$t,x:Tt,y:Lt}}function getViewportRect(st,at){const pt=getWindow(st),vt=getDocumentElement(st),wt=pt.visualViewport;let $t=vt.clientWidth,Tt=vt.clientHeight,Lt=0,Ft=0;if(wt){$t=wt.width,Tt=wt.height;const Ct=isWebKit();(!Ct||Ct&&at==="fixed")&&(Lt=wt.offsetLeft,Ft=wt.offsetTop)}return{width:$t,height:Tt,x:Lt,y:Ft}}function getInnerBoundingClientRect(st,at){const pt=getBoundingClientRect(st,!0,at==="fixed"),vt=pt.top+st.clientTop,wt=pt.left+st.clientLeft,$t=isHTMLElement(st)?getScale(st):createCoords(1),Tt=st.clientWidth*$t.x,Lt=st.clientHeight*$t.y,Ft=wt*$t.x,Ct=vt*$t.y;return{width:Tt,height:Lt,x:Ft,y:Ct}}function getClientRectFromClippingAncestor(st,at,pt){let vt;if(at==="viewport")vt=getViewportRect(st,pt);else if(at==="document")vt=getDocumentRect(getDocumentElement(st));else if(isElement(at))vt=getInnerBoundingClientRect(at,pt);else{const wt=getVisualOffsets(st);vt={...at,x:at.x-wt.x,y:at.y-wt.y}}return rectToClientRect(vt)}function hasFixedPositionAncestor(st,at){const pt=getParentNode(st);return pt===at||!isElement(pt)||isLastTraversableNode(pt)?!1:getComputedStyle$1(pt).position==="fixed"||hasFixedPositionAncestor(pt,at)}function getClippingElementAncestors(st,at){const pt=at.get(st);if(pt)return pt;let vt=getOverflowAncestors(st,[],!1).filter(Lt=>isElement(Lt)&&getNodeName(Lt)!=="body"),wt=null;const $t=getComputedStyle$1(st).position==="fixed";let Tt=$t?getParentNode(st):st;for(;isElement(Tt)&&!isLastTraversableNode(Tt);){const Lt=getComputedStyle$1(Tt),Ft=isContainingBlock(Tt);!Ft&&Lt.position==="fixed"&&(wt=null),($t?!Ft&&!wt:!Ft&&Lt.position==="static"&&!!wt&&["absolute","fixed"].includes(wt.position)||isOverflowElement(Tt)&&!Ft&&hasFixedPositionAncestor(st,Tt))?vt=vt.filter(Ht=>Ht!==Tt):wt=Lt,Tt=getParentNode(Tt)}return at.set(st,vt),vt}function getClippingRect(st){let{element:at,boundary:pt,rootBoundary:vt,strategy:wt}=st;const Tt=[...pt==="clippingAncestors"?isTopLayer(at)?[]:getClippingElementAncestors(at,this._c):[].concat(pt),vt],Lt=Tt[0],Ft=Tt.reduce((Ct,Ht)=>{const Gt=getClientRectFromClippingAncestor(at,Ht,wt);return Ct.top=max(Gt.top,Ct.top),Ct.right=min(Gt.right,Ct.right),Ct.bottom=min(Gt.bottom,Ct.bottom),Ct.left=max(Gt.left,Ct.left),Ct},getClientRectFromClippingAncestor(at,Lt,wt));return{width:Ft.right-Ft.left,height:Ft.bottom-Ft.top,x:Ft.left,y:Ft.top}}function getDimensions(st){const{width:at,height:pt}=getCssDimensions(st);return{width:at,height:pt}}function getRectRelativeToOffsetParent(st,at,pt){const vt=isHTMLElement(at),wt=getDocumentElement(at),$t=pt==="fixed",Tt=getBoundingClientRect(st,!0,$t,at);let Lt={scrollLeft:0,scrollTop:0};const Ft=createCoords(0);if(vt||!vt&&!$t)if((getNodeName(at)!=="body"||isOverflowElement(wt))&&(Lt=getNodeScroll(at)),vt){const Gt=getBoundingClientRect(at,!0,$t,at);Ft.x=Gt.x+at.clientLeft,Ft.y=Gt.y+at.clientTop}else wt&&(Ft.x=getWindowScrollBarX(wt));const Ct=Tt.left+Lt.scrollLeft-Ft.x,Ht=Tt.top+Lt.scrollTop-Ft.y;return{x:Ct,y:Ht,width:Tt.width,height:Tt.height}}function isStaticPositioned(st){return getComputedStyle$1(st).position==="static"}function getTrueOffsetParent(st,at){return!isHTMLElement(st)||getComputedStyle$1(st).position==="fixed"?null:at?at(st):st.offsetParent}function getOffsetParent(st,at){const pt=getWindow(st);if(isTopLayer(st))return pt;if(!isHTMLElement(st)){let wt=getParentNode(st);for(;wt&&!isLastTraversableNode(wt);){if(isElement(wt)&&!isStaticPositioned(wt))return wt;wt=getParentNode(wt)}return pt}let vt=getTrueOffsetParent(st,at);for(;vt&&isTableElement(vt)&&isStaticPositioned(vt);)vt=getTrueOffsetParent(vt,at);return vt&&isLastTraversableNode(vt)&&isStaticPositioned(vt)&&!isContainingBlock(vt)?pt:vt||getContainingBlock(st)||pt}const getElementRects=async function(st){const at=this.getOffsetParent||getOffsetParent,pt=this.getDimensions,vt=await pt(st.floating);return{reference:getRectRelativeToOffsetParent(st.reference,await at(st.floating),st.strategy),floating:{x:0,y:0,width:vt.width,height:vt.height}}};function isRTL(st){return getComputedStyle$1(st).direction==="rtl"}const platform={convertOffsetParentRelativeRectToViewportRelativeRect,getDocumentElement,getClippingRect,getOffsetParent,getElementRects,getClientRects,getDimensions,getScale,isElement,isRTL};function observeMove(st,at){let pt=null,vt;const wt=getDocumentElement(st);function $t(){var Lt;clearTimeout(vt),(Lt=pt)==null||Lt.disconnect(),pt=null}function Tt(Lt,Ft){Lt===void 0&&(Lt=!1),Ft===void 0&&(Ft=1),$t();const{left:Ct,top:Ht,width:Gt,height:jt}=st.getBoundingClientRect();if(Lt||at(),!Gt||!jt)return;const qt=floor(Ht),Kt=floor(wt.clientWidth-(Ct+Gt)),An=floor(wt.clientHeight-(Ht+jt)),Sn=floor(Ct),In={rootMargin:-qt+"px "+-Kt+"px "+-An+"px "+-Sn+"px",threshold:max(0,min(1,Ft))||1};let tr=!0;function rr(Hr){const qr=Hr[0].intersectionRatio;if(qr!==Ft){if(!tr)return Tt();qr?Tt(!1,qr):vt=setTimeout(()=>{Tt(!1,1e-7)},1e3)}tr=!1}try{pt=new IntersectionObserver(rr,{...In,root:wt.ownerDocument})}catch{pt=new IntersectionObserver(rr,In)}pt.observe(st)}return Tt(!0),$t}function autoUpdate(st,at,pt,vt){vt===void 0&&(vt={});const{ancestorScroll:wt=!0,ancestorResize:$t=!0,elementResize:Tt=typeof ResizeObserver=="function",layoutShift:Lt=typeof IntersectionObserver=="function",animationFrame:Ft=!1}=vt,Ct=unwrapElement(st),Ht=wt||$t?[...Ct?getOverflowAncestors(Ct):[],...getOverflowAncestors(at)]:[];Ht.forEach(wn=>{wt&&wn.addEventListener("scroll",pt,{passive:!0}),$t&&wn.addEventListener("resize",pt)});const Gt=Ct&&Lt?observeMove(Ct,pt):null;let jt=-1,qt=null;Tt&&(qt=new ResizeObserver(wn=>{let[In]=wn;In&&In.target===Ct&&qt&&(qt.unobserve(at),cancelAnimationFrame(jt),jt=requestAnimationFrame(()=>{var tr;(tr=qt)==null||tr.observe(at)})),pt()}),Ct&&!Ft&&qt.observe(Ct),qt.observe(at));let Kt,An=Ft?getBoundingClientRect(st):null;Ft&&Sn();function Sn(){const wn=getBoundingClientRect(st);An&&(wn.x!==An.x||wn.y!==An.y||wn.width!==An.width||wn.height!==An.height)&&pt(),An=wn,Kt=requestAnimationFrame(Sn)}return pt(),()=>{var wn;Ht.forEach(In=>{wt&&In.removeEventListener("scroll",pt),$t&&In.removeEventListener("resize",pt)}),Gt==null||Gt(),(wn=qt)==null||wn.disconnect(),qt=null,Ft&&cancelAnimationFrame(Kt)}}const offset$1=offset$2,shift$1=shift$2,flip$1=flip$2,size$1=size$2,hide$1=hide$2,arrow$2=arrow$3,limitShift$1=limitShift$2,computePosition=(st,at,pt)=>{const vt=new Map,wt={platform,...pt},$t={...wt.platform,_c:vt};return computePosition$1(st,at,{...wt,platform:$t})};var index=typeof document<"u"?reactExports.useLayoutEffect:reactExports.useEffect;function deepEqual(st,at){if(st===at)return!0;if(typeof st!=typeof at)return!1;if(typeof st=="function"&&st.toString()===at.toString())return!0;let pt,vt,wt;if(st&&at&&typeof st=="object"){if(Array.isArray(st)){if(pt=st.length,pt!==at.length)return!1;for(vt=pt;vt--!==0;)if(!deepEqual(st[vt],at[vt]))return!1;return!0}if(wt=Object.keys(st),pt=wt.length,pt!==Object.keys(at).length)return!1;for(vt=pt;vt--!==0;)if(!{}.hasOwnProperty.call(at,wt[vt]))return!1;for(vt=pt;vt--!==0;){const $t=wt[vt];if(!($t==="_owner"&&st.$$typeof)&&!deepEqual(st[$t],at[$t]))return!1}return!0}return st!==st&&at!==at}function getDPR(st){return typeof window>"u"?1:(st.ownerDocument.defaultView||window).devicePixelRatio||1}function roundByDPR(st,at){const pt=getDPR(st);return Math.round(at*pt)/pt}function useLatestRef(st){const at=reactExports.useRef(st);return index(()=>{at.current=st}),at}function useFloating(st){st===void 0&&(st={});const{placement:at="bottom",strategy:pt="absolute",middleware:vt=[],platform:wt,elements:{reference:$t,floating:Tt}={},transform:Lt=!0,whileElementsMounted:Ft,open:Ct}=st,[Ht,Gt]=reactExports.useState({x:0,y:0,strategy:pt,placement:at,middlewareData:{},isPositioned:!1}),[jt,qt]=reactExports.useState(vt);deepEqual(jt,vt)||qt(vt);const[Kt,An]=reactExports.useState(null),[Sn,wn]=reactExports.useState(null),In=reactExports.useCallback(E0=>{E0!==qr.current&&(qr.current=E0,An(E0))},[]),tr=reactExports.useCallback(E0=>{E0!==Zr.current&&(Zr.current=E0,wn(E0))},[]),rr=$t||Kt,Hr=Tt||Sn,qr=reactExports.useRef(null),Zr=reactExports.useRef(null),Bo=reactExports.useRef(Ht),Xo=Ft!=null,Kr=useLatestRef(Ft),ko=useLatestRef(wt),f0=reactExports.useCallback(()=>{if(!qr.current||!Zr.current)return;const E0={placement:at,strategy:pt,middleware:jt};ko.current&&(E0.platform=ko.current),computePosition(qr.current,Zr.current,E0).then(n0=>{const m0={...n0,isPositioned:!0};x0.current&&!deepEqual(Bo.current,m0)&&(Bo.current=m0,reactDomExports.flushSync(()=>{Gt(m0)}))})},[jt,at,pt,ko]);index(()=>{Ct===!1&&Bo.current.isPositioned&&(Bo.current.isPositioned=!1,Gt(E0=>({...E0,isPositioned:!1})))},[Ct]);const x0=reactExports.useRef(!1);index(()=>(x0.current=!0,()=>{x0.current=!1}),[]),index(()=>{if(rr&&(qr.current=rr),Hr&&(Zr.current=Hr),rr&&Hr){if(Kr.current)return Kr.current(rr,Hr,f0);f0()}},[rr,Hr,f0,Kr,Xo]);const l0=reactExports.useMemo(()=>({reference:qr,floating:Zr,setReference:In,setFloating:tr}),[In,tr]),T0=reactExports.useMemo(()=>({reference:rr,floating:Hr}),[rr,Hr]),t0=reactExports.useMemo(()=>{const E0={position:pt,left:0,top:0};if(!T0.floating)return E0;const n0=roundByDPR(T0.floating,Ht.x),m0=roundByDPR(T0.floating,Ht.y);return Lt?{...E0,transform:"translate("+n0+"px, "+m0+"px)",...getDPR(T0.floating)>=1.5&&{willChange:"transform"}}:{position:pt,left:n0,top:m0}},[pt,Lt,T0.floating,Ht.x,Ht.y]);return reactExports.useMemo(()=>({...Ht,update:f0,refs:l0,elements:T0,floatingStyles:t0}),[Ht,f0,l0,T0,t0])}const arrow$1=st=>{function at(pt){return{}.hasOwnProperty.call(pt,"current")}return{name:"arrow",options:st,fn(pt){const{element:vt,padding:wt}=typeof st=="function"?st(pt):st;return vt&&at(vt)?vt.current!=null?arrow$2({element:vt.current,padding:wt}).fn(pt):{}:vt?arrow$2({element:vt,padding:wt}).fn(pt):{}}}},offset=(st,at)=>({...offset$1(st),options:[st,at]}),shift=(st,at)=>({...shift$1(st),options:[st,at]}),limitShift=(st,at)=>({...limitShift$1(st),options:[st,at]}),flip=(st,at)=>({...flip$1(st),options:[st,at]}),size=(st,at)=>({...size$1(st),options:[st,at]}),hide=(st,at)=>({...hide$1(st),options:[st,at]}),arrow=(st,at)=>({...arrow$1(st),options:[st,at]}),$7e8f5cd07187803e$export$21b07c8f274aebd5=reactExports.forwardRef((st,at)=>{const{children:pt,width:vt=10,height:wt=5,...$t}=st;return reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.svg,_extends$1({},$t,{ref:at,width:vt,height:wt,viewBox:"0 0 30 10",preserveAspectRatio:"none"}),st.asChild?pt:reactExports.createElement("polygon",{points:"0,0 30,0 15,10"}))}),$7e8f5cd07187803e$export$be92b6f5f03c0fe9=$7e8f5cd07187803e$export$21b07c8f274aebd5;function $db6c3485150b8e66$export$1ab7ae714698c4b8(st){const[at,pt]=reactExports.useState(void 0);return $9f79659886946c16$export$e5c5a5f917a5871c(()=>{if(st){pt({width:st.offsetWidth,height:st.offsetHeight});const vt=new ResizeObserver(wt=>{if(!Array.isArray(wt)||!wt.length)return;const $t=wt[0];let Tt,Lt;if("borderBoxSize"in $t){const Ft=$t.borderBoxSize,Ct=Array.isArray(Ft)?Ft[0]:Ft;Tt=Ct.inlineSize,Lt=Ct.blockSize}else Tt=st.offsetWidth,Lt=st.offsetHeight;pt({width:Tt,height:Lt})});return vt.observe(st,{box:"border-box"}),()=>vt.unobserve(st)}else pt(void 0)},[st]),at}const $cf1ac5d9fe0e8206$var$POPPER_NAME="Popper",[$cf1ac5d9fe0e8206$var$createPopperContext,$cf1ac5d9fe0e8206$export$722aac194ae923]=$c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME),[$cf1ac5d9fe0e8206$var$PopperProvider,$cf1ac5d9fe0e8206$var$usePopperContext]=$cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME),$cf1ac5d9fe0e8206$export$badac9ada3a0bdf9=st=>{const{__scopePopper:at,children:pt}=st,[vt,wt]=reactExports.useState(null);return reactExports.createElement($cf1ac5d9fe0e8206$var$PopperProvider,{scope:at,anchor:vt,onAnchorChange:wt},pt)},$cf1ac5d9fe0e8206$var$ANCHOR_NAME="PopperAnchor",$cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d=reactExports.forwardRef((st,at)=>{const{__scopePopper:pt,virtualRef:vt,...wt}=st,$t=$cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME,pt),Tt=reactExports.useRef(null),Lt=$6ed0406888f73fc4$export$c7b2cbe3552a0d05(at,Tt);return reactExports.useEffect(()=>{$t.onAnchorChange((vt==null?void 0:vt.current)||Tt.current)}),vt?null:reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div,_extends$1({},wt,{ref:Lt}))}),$cf1ac5d9fe0e8206$var$CONTENT_NAME="PopperContent",[$cf1ac5d9fe0e8206$var$PopperContentProvider,$cf1ac5d9fe0e8206$var$useContentContext]=$cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME),$cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc=reactExports.forwardRef((st,at)=>{var pt,vt,wt,$t,Tt,Lt,Ft,Ct;const{__scopePopper:Ht,side:Gt="bottom",sideOffset:jt=0,align:qt="center",alignOffset:Kt=0,arrowPadding:An=0,avoidCollisions:Sn=!0,collisionBoundary:wn=[],collisionPadding:In=0,sticky:tr="partial",hideWhenDetached:rr=!1,updatePositionStrategy:Hr="optimized",onPlaced:qr,...Zr}=st,Bo=$cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME,Ht),[Xo,Kr]=reactExports.useState(null),ko=$6ed0406888f73fc4$export$c7b2cbe3552a0d05(at,yy=>Kr(yy)),[f0,x0]=reactExports.useState(null),l0=$db6c3485150b8e66$export$1ab7ae714698c4b8(f0),T0=(pt=l0==null?void 0:l0.width)!==null&&pt!==void 0?pt:0,t0=(vt=l0==null?void 0:l0.height)!==null&&vt!==void 0?vt:0,E0=Gt+(qt!=="center"?"-"+qt:""),n0=typeof In=="number"?In:{top:0,right:0,bottom:0,left:0,...In},m0=Array.isArray(wn)?wn:[wn],h0=m0.length>0,a0={padding:n0,boundary:m0.filter($cf1ac5d9fe0e8206$var$isNotNull),altBoundary:h0},{refs:P0,floatingStyles:V0,placement:B0,isPositioned:W0,middlewareData:K0}=useFloating({strategy:"fixed",placement:E0,whileElementsMounted:(...yy)=>autoUpdate(...yy,{animationFrame:Hr==="always"}),elements:{reference:Bo.anchor},middleware:[offset({mainAxis:jt+t0,alignmentAxis:Kt}),Sn&&shift({mainAxis:!0,crossAxis:!1,limiter:tr==="partial"?limitShift():void 0,...a0}),Sn&&flip({...a0}),size({...a0,apply:({elements:yy,rects:uy,availableWidth:Dy,availableHeight:Fy})=>{const{width:qy,height:rv}=uy.reference,y0=yy.floating.style;y0.setProperty("--radix-popper-available-width",`${Dy}px`),y0.setProperty("--radix-popper-available-height",`${Fy}px`),y0.setProperty("--radix-popper-anchor-width",`${qy}px`),y0.setProperty("--radix-popper-anchor-height",`${rv}px`)}}),f0&&arrow({element:f0,padding:An}),$cf1ac5d9fe0e8206$var$transformOrigin({arrowWidth:T0,arrowHeight:t0}),rr&&hide({strategy:"referenceHidden",...a0})]}),[Ty,$y]=$cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(B0),My=$b1b2314f5f9a1d84$export$25bec8c6f54ee79a(qr);$9f79659886946c16$export$e5c5a5f917a5871c(()=>{W0&&(My==null||My())},[W0,My]);const Wy=(wt=K0.arrow)===null||wt===void 0?void 0:wt.x,Ey=($t=K0.arrow)===null||$t===void 0?void 0:$t.y,_0=((Tt=K0.arrow)===null||Tt===void 0?void 0:Tt.centerOffset)!==0,[ay,J0]=reactExports.useState();return $9f79659886946c16$export$e5c5a5f917a5871c(()=>{Xo&&J0(window.getComputedStyle(Xo).zIndex)},[Xo]),reactExports.createElement("div",{ref:P0.setFloating,"data-radix-popper-content-wrapper":"",style:{...V0,transform:W0?V0.transform:"translate(0, -200%)",minWidth:"max-content",zIndex:ay,"--radix-popper-transform-origin":[(Lt=K0.transformOrigin)===null||Lt===void 0?void 0:Lt.x,(Ft=K0.transformOrigin)===null||Ft===void 0?void 0:Ft.y].join(" ")},dir:st.dir},reactExports.createElement($cf1ac5d9fe0e8206$var$PopperContentProvider,{scope:Ht,placedSide:Ty,onArrowChange:x0,arrowX:Wy,arrowY:Ey,shouldHideArrow:_0},reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div,_extends$1({"data-side":Ty,"data-align":$y},Zr,{ref:ko,style:{...Zr.style,animation:W0?void 0:"none",opacity:(Ct=K0.hide)!==null&&Ct!==void 0&&Ct.referenceHidden?0:void 0}}))))}),$cf1ac5d9fe0e8206$var$ARROW_NAME="PopperArrow",$cf1ac5d9fe0e8206$var$OPPOSITE_SIDE={top:"bottom",right:"left",bottom:"top",left:"right"},$cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0=reactExports.forwardRef(function(at,pt){const{__scopePopper:vt,...wt}=at,$t=$cf1ac5d9fe0e8206$var$useContentContext($cf1ac5d9fe0e8206$var$ARROW_NAME,vt),Tt=$cf1ac5d9fe0e8206$var$OPPOSITE_SIDE[$t.placedSide];return reactExports.createElement("span",{ref:$t.onArrowChange,style:{position:"absolute",left:$t.arrowX,top:$t.arrowY,[Tt]:0,transformOrigin:{top:"",right:"0 0",bottom:"center 0",left:"100% 0"}[$t.placedSide],transform:{top:"translateY(100%)",right:"translateY(50%) rotate(90deg) translateX(-50%)",bottom:"rotate(180deg)",left:"translateY(50%) rotate(-90deg) translateX(50%)"}[$t.placedSide],visibility:$t.shouldHideArrow?"hidden":void 0}},reactExports.createElement($7e8f5cd07187803e$export$be92b6f5f03c0fe9,_extends$1({},wt,{ref:pt,style:{...wt.style,display:"block"}})))});function $cf1ac5d9fe0e8206$var$isNotNull(st){return st!==null}const $cf1ac5d9fe0e8206$var$transformOrigin=st=>({name:"transformOrigin",options:st,fn(at){var pt,vt,wt,$t,Tt;const{placement:Lt,rects:Ft,middlewareData:Ct}=at,Gt=((pt=Ct.arrow)===null||pt===void 0?void 0:pt.centerOffset)!==0,jt=Gt?0:st.arrowWidth,qt=Gt?0:st.arrowHeight,[Kt,An]=$cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(Lt),Sn={start:"0%",center:"50%",end:"100%"}[An],wn=((vt=(wt=Ct.arrow)===null||wt===void 0?void 0:wt.x)!==null&&vt!==void 0?vt:0)+jt/2,In=(($t=(Tt=Ct.arrow)===null||Tt===void 0?void 0:Tt.y)!==null&&$t!==void 0?$t:0)+qt/2;let tr="",rr="";return Kt==="bottom"?(tr=Gt?Sn:`${wn}px`,rr=`${-qt}px`):Kt==="top"?(tr=Gt?Sn:`${wn}px`,rr=`${Ft.floating.height+qt}px`):Kt==="right"?(tr=`${-qt}px`,rr=Gt?Sn:`${In}px`):Kt==="left"&&(tr=`${Ft.floating.width+qt}px`,rr=Gt?Sn:`${In}px`),{data:{x:tr,y:rr}}}});function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(st){const[at,pt="center"]=st.split("-");return[at,pt]}const $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9=$cf1ac5d9fe0e8206$export$badac9ada3a0bdf9,$cf1ac5d9fe0e8206$export$b688253958b8dfe7=$cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d,$cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2=$cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc,$cf1ac5d9fe0e8206$export$21b07c8f274aebd5=$cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0;function $fe963b355347cc68$export$3e6543de14f8614f(st,at){return reactExports.useReducer((pt,vt)=>{const wt=at[pt][vt];return wt??pt},st)}const $921a889cee6df7e8$export$99c2b779aa4e8b8b=st=>{const{present:at,children:pt}=st,vt=$921a889cee6df7e8$var$usePresence(at),wt=typeof pt=="function"?pt({present:vt.isPresent}):reactExports.Children.only(pt),$t=$6ed0406888f73fc4$export$c7b2cbe3552a0d05(vt.ref,wt.ref);return typeof pt=="function"||vt.isPresent?reactExports.cloneElement(wt,{ref:$t}):null};$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName="Presence";function $921a889cee6df7e8$var$usePresence(st){const[at,pt]=reactExports.useState(),vt=reactExports.useRef({}),wt=reactExports.useRef(st),$t=reactExports.useRef("none"),Tt=st?"mounted":"unmounted",[Lt,Ft]=$fe963b355347cc68$export$3e6543de14f8614f(Tt,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}});return reactExports.useEffect(()=>{const Ct=$921a889cee6df7e8$var$getAnimationName(vt.current);$t.current=Lt==="mounted"?Ct:"none"},[Lt]),$9f79659886946c16$export$e5c5a5f917a5871c(()=>{const Ct=vt.current,Ht=wt.current;if(Ht!==st){const jt=$t.current,qt=$921a889cee6df7e8$var$getAnimationName(Ct);st?Ft("MOUNT"):qt==="none"||(Ct==null?void 0:Ct.display)==="none"?Ft("UNMOUNT"):Ft(Ht&&jt!==qt?"ANIMATION_OUT":"UNMOUNT"),wt.current=st}},[st,Ft]),$9f79659886946c16$export$e5c5a5f917a5871c(()=>{if(at){const Ct=Gt=>{const qt=$921a889cee6df7e8$var$getAnimationName(vt.current).includes(Gt.animationName);Gt.target===at&&qt&&reactDomExports.flushSync(()=>Ft("ANIMATION_END"))},Ht=Gt=>{Gt.target===at&&($t.current=$921a889cee6df7e8$var$getAnimationName(vt.current))};return at.addEventListener("animationstart",Ht),at.addEventListener("animationcancel",Ct),at.addEventListener("animationend",Ct),()=>{at.removeEventListener("animationstart",Ht),at.removeEventListener("animationcancel",Ct),at.removeEventListener("animationend",Ct)}}else Ft("ANIMATION_END")},[at,Ft]),{isPresent:["mounted","unmountSuspended"].includes(Lt),ref:reactExports.useCallback(Ct=>{Ct&&(vt.current=getComputedStyle(Ct)),pt(Ct)},[])}}function $921a889cee6df7e8$var$getAnimationName(st){return(st==null?void 0:st.animationName)||"none"}function $71cd76cc60e0454e$export$6f32135080cb4c3({prop:st,defaultProp:at,onChange:pt=()=>{}}){const[vt,wt]=$71cd76cc60e0454e$var$useUncontrolledState({defaultProp:at,onChange:pt}),$t=st!==void 0,Tt=$t?st:vt,Lt=$b1b2314f5f9a1d84$export$25bec8c6f54ee79a(pt),Ft=reactExports.useCallback(Ct=>{if($t){const Gt=typeof Ct=="function"?Ct(st):Ct;Gt!==st&&Lt(Gt)}else wt(Ct)},[$t,st,wt,Lt]);return[Tt,Ft]}function $71cd76cc60e0454e$var$useUncontrolledState({defaultProp:st,onChange:at}){const pt=reactExports.useState(st),[vt]=pt,wt=reactExports.useRef(vt),$t=$b1b2314f5f9a1d84$export$25bec8c6f54ee79a(at);return reactExports.useEffect(()=>{wt.current!==vt&&($t(vt),wt.current=vt)},[vt,wt,$t]),pt}const $ea1ef594cf570d83$export$439d29a4e110a164=reactExports.forwardRef((st,at)=>reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.span,_extends$1({},st,{ref:at,style:{position:"absolute",border:0,width:1,height:1,padding:0,margin:-1,overflow:"hidden",clip:"rect(0, 0, 0, 0)",whiteSpace:"nowrap",wordWrap:"normal",...st.style}}))),$ea1ef594cf570d83$export$be92b6f5f03c0fe9=$ea1ef594cf570d83$export$439d29a4e110a164,[$a093c7e1ec25a057$var$createTooltipContext,$a093c7e1ec25a057$export$1c540a2224f0d865]=$c512c27ab02ef895$export$50c7b4e9d9f19c1("Tooltip",[$cf1ac5d9fe0e8206$export$722aac194ae923]),$a093c7e1ec25a057$var$usePopperScope=$cf1ac5d9fe0e8206$export$722aac194ae923(),$a093c7e1ec25a057$var$PROVIDER_NAME="TooltipProvider",$a093c7e1ec25a057$var$TOOLTIP_OPEN="tooltip.open",[$a093c7e1ec25a057$var$TooltipProviderContextProvider,$a093c7e1ec25a057$var$useTooltipProviderContext]=$a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PROVIDER_NAME),$a093c7e1ec25a057$var$TOOLTIP_NAME="Tooltip",[$a093c7e1ec25a057$var$TooltipContextProvider,$a093c7e1ec25a057$var$useTooltipContext]=$a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME),$a093c7e1ec25a057$export$28c660c63b792dea=st=>{const{__scopeTooltip:at,children:pt,open:vt,defaultOpen:wt=!1,onOpenChange:$t,disableHoverableContent:Tt,delayDuration:Lt}=st,Ft=$a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$TOOLTIP_NAME,st.__scopeTooltip),Ct=$a093c7e1ec25a057$var$usePopperScope(at),[Ht,Gt]=reactExports.useState(null),jt=$1746a345f3d73bb7$export$f680877a34711e37(),qt=reactExports.useRef(0),Kt=Tt??Ft.disableHoverableContent,An=Lt??Ft.delayDuration,Sn=reactExports.useRef(!1),[wn=!1,In]=$71cd76cc60e0454e$export$6f32135080cb4c3({prop:vt,defaultProp:wt,onChange:Zr=>{Zr?(Ft.onOpen(),document.dispatchEvent(new CustomEvent($a093c7e1ec25a057$var$TOOLTIP_OPEN))):Ft.onClose(),$t==null||$t(Zr)}}),tr=reactExports.useMemo(()=>wn?Sn.current?"delayed-open":"instant-open":"closed",[wn]),rr=reactExports.useCallback(()=>{window.clearTimeout(qt.current),Sn.current=!1,In(!0)},[In]),Hr=reactExports.useCallback(()=>{window.clearTimeout(qt.current),In(!1)},[In]),qr=reactExports.useCallback(()=>{window.clearTimeout(qt.current),qt.current=window.setTimeout(()=>{Sn.current=!0,In(!0)},An)},[An,In]);return reactExports.useEffect(()=>()=>window.clearTimeout(qt.current),[]),reactExports.createElement($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9,Ct,reactExports.createElement($a093c7e1ec25a057$var$TooltipContextProvider,{scope:at,contentId:jt,open:wn,stateAttribute:tr,trigger:Ht,onTriggerChange:Gt,onTriggerEnter:reactExports.useCallback(()=>{Ft.isOpenDelayed?qr():rr()},[Ft.isOpenDelayed,qr,rr]),onTriggerLeave:reactExports.useCallback(()=>{Kt?Hr():window.clearTimeout(qt.current)},[Hr,Kt]),onOpen:rr,onClose:Hr,disableHoverableContent:Kt},pt))},$a093c7e1ec25a057$var$TRIGGER_NAME="TooltipTrigger",$a093c7e1ec25a057$export$8c610744efcf8a1d=reactExports.forwardRef((st,at)=>{const{__scopeTooltip:pt,...vt}=st,wt=$a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$TRIGGER_NAME,pt),$t=$a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$TRIGGER_NAME,pt),Tt=$a093c7e1ec25a057$var$usePopperScope(pt),Lt=reactExports.useRef(null),Ft=$6ed0406888f73fc4$export$c7b2cbe3552a0d05(at,Lt,wt.onTriggerChange),Ct=reactExports.useRef(!1),Ht=reactExports.useRef(!1),Gt=reactExports.useCallback(()=>Ct.current=!1,[]);return reactExports.useEffect(()=>()=>document.removeEventListener("pointerup",Gt),[Gt]),reactExports.createElement($cf1ac5d9fe0e8206$export$b688253958b8dfe7,_extends$1({asChild:!0},Tt),reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button,_extends$1({"aria-describedby":wt.open?wt.contentId:void 0,"data-state":wt.stateAttribute},vt,{ref:Ft,onPointerMove:$e42e1063c40fb3ef$export$b9ecd428b558ff10(st.onPointerMove,jt=>{jt.pointerType!=="touch"&&!Ht.current&&!$t.isPointerInTransitRef.current&&(wt.onTriggerEnter(),Ht.current=!0)}),onPointerLeave:$e42e1063c40fb3ef$export$b9ecd428b558ff10(st.onPointerLeave,()=>{wt.onTriggerLeave(),Ht.current=!1}),onPointerDown:$e42e1063c40fb3ef$export$b9ecd428b558ff10(st.onPointerDown,()=>{Ct.current=!0,document.addEventListener("pointerup",Gt,{once:!0})}),onFocus:$e42e1063c40fb3ef$export$b9ecd428b558ff10(st.onFocus,()=>{Ct.current||wt.onOpen()}),onBlur:$e42e1063c40fb3ef$export$b9ecd428b558ff10(st.onBlur,wt.onClose),onClick:$e42e1063c40fb3ef$export$b9ecd428b558ff10(st.onClick,wt.onClose)})))}),$a093c7e1ec25a057$var$PORTAL_NAME="TooltipPortal",[$a093c7e1ec25a057$var$PortalProvider,$a093c7e1ec25a057$var$usePortalContext]=$a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$PORTAL_NAME,{forceMount:void 0}),$a093c7e1ec25a057$var$CONTENT_NAME="TooltipContent",$a093c7e1ec25a057$export$e9003e2be37ec060=reactExports.forwardRef((st,at)=>{const pt=$a093c7e1ec25a057$var$usePortalContext($a093c7e1ec25a057$var$CONTENT_NAME,st.__scopeTooltip),{forceMount:vt=pt.forceMount,side:wt="top",...$t}=st,Tt=$a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME,st.__scopeTooltip);return reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b,{present:vt||Tt.open},Tt.disableHoverableContent?reactExports.createElement($a093c7e1ec25a057$var$TooltipContentImpl,_extends$1({side:wt},$t,{ref:at})):reactExports.createElement($a093c7e1ec25a057$var$TooltipContentHoverable,_extends$1({side:wt},$t,{ref:at})))}),$a093c7e1ec25a057$var$TooltipContentHoverable=reactExports.forwardRef((st,at)=>{const pt=$a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME,st.__scopeTooltip),vt=$a093c7e1ec25a057$var$useTooltipProviderContext($a093c7e1ec25a057$var$CONTENT_NAME,st.__scopeTooltip),wt=reactExports.useRef(null),$t=$6ed0406888f73fc4$export$c7b2cbe3552a0d05(at,wt),[Tt,Lt]=reactExports.useState(null),{trigger:Ft,onClose:Ct}=pt,Ht=wt.current,{onPointerInTransitChange:Gt}=vt,jt=reactExports.useCallback(()=>{Lt(null),Gt(!1)},[Gt]),qt=reactExports.useCallback((Kt,An)=>{const Sn=Kt.currentTarget,wn={x:Kt.clientX,y:Kt.clientY},In=$a093c7e1ec25a057$var$getExitSideFromRect(wn,Sn.getBoundingClientRect()),tr=$a093c7e1ec25a057$var$getPaddedExitPoints(wn,In),rr=$a093c7e1ec25a057$var$getPointsFromRect(An.getBoundingClientRect()),Hr=$a093c7e1ec25a057$var$getHull([...tr,...rr]);Lt(Hr),Gt(!0)},[Gt]);return reactExports.useEffect(()=>()=>jt(),[jt]),reactExports.useEffect(()=>{if(Ft&&Ht){const Kt=Sn=>qt(Sn,Ht),An=Sn=>qt(Sn,Ft);return Ft.addEventListener("pointerleave",Kt),Ht.addEventListener("pointerleave",An),()=>{Ft.removeEventListener("pointerleave",Kt),Ht.removeEventListener("pointerleave",An)}}},[Ft,Ht,qt,jt]),reactExports.useEffect(()=>{if(Tt){const Kt=An=>{const Sn=An.target,wn={x:An.clientX,y:An.clientY},In=(Ft==null?void 0:Ft.contains(Sn))||(Ht==null?void 0:Ht.contains(Sn)),tr=!$a093c7e1ec25a057$var$isPointInPolygon(wn,Tt);In?jt():tr&&(jt(),Ct())};return document.addEventListener("pointermove",Kt),()=>document.removeEventListener("pointermove",Kt)}},[Ft,Ht,Tt,Ct,jt]),reactExports.createElement($a093c7e1ec25a057$var$TooltipContentImpl,_extends$1({},st,{ref:$t}))}),[$a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider,$a093c7e1ec25a057$var$useVisuallyHiddenContentContext]=$a093c7e1ec25a057$var$createTooltipContext($a093c7e1ec25a057$var$TOOLTIP_NAME,{isInside:!1}),$a093c7e1ec25a057$var$TooltipContentImpl=reactExports.forwardRef((st,at)=>{const{__scopeTooltip:pt,children:vt,"aria-label":wt,onEscapeKeyDown:$t,onPointerDownOutside:Tt,...Lt}=st,Ft=$a093c7e1ec25a057$var$useTooltipContext($a093c7e1ec25a057$var$CONTENT_NAME,pt),Ct=$a093c7e1ec25a057$var$usePopperScope(pt),{onClose:Ht}=Ft;return reactExports.useEffect(()=>(document.addEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN,Ht),()=>document.removeEventListener($a093c7e1ec25a057$var$TOOLTIP_OPEN,Ht)),[Ht]),reactExports.useEffect(()=>{if(Ft.trigger){const Gt=jt=>{const qt=jt.target;qt!=null&&qt.contains(Ft.trigger)&&Ht()};return window.addEventListener("scroll",Gt,{capture:!0}),()=>window.removeEventListener("scroll",Gt,{capture:!0})}},[Ft.trigger,Ht]),reactExports.createElement($5cb92bef7577960e$export$177fb62ff3ec1f22,{asChild:!0,disableOutsidePointerEvents:!1,onEscapeKeyDown:$t,onPointerDownOutside:Tt,onFocusOutside:Gt=>Gt.preventDefault(),onDismiss:Ht},reactExports.createElement($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2,_extends$1({"data-state":Ft.stateAttribute},Ct,Lt,{ref:at,style:{...Lt.style,"--radix-tooltip-content-transform-origin":"var(--radix-popper-transform-origin)","--radix-tooltip-content-available-width":"var(--radix-popper-available-width)","--radix-tooltip-content-available-height":"var(--radix-popper-available-height)","--radix-tooltip-trigger-width":"var(--radix-popper-anchor-width)","--radix-tooltip-trigger-height":"var(--radix-popper-anchor-height)"}}),reactExports.createElement($5e63c961fc1ce211$export$d9f1ccf0bdb05d45,null,vt),reactExports.createElement($a093c7e1ec25a057$var$VisuallyHiddenContentContextProvider,{scope:pt,isInside:!0},reactExports.createElement($ea1ef594cf570d83$export$be92b6f5f03c0fe9,{id:Ft.contentId,role:"tooltip"},wt||vt))))}),$a093c7e1ec25a057$var$ARROW_NAME="TooltipArrow",$a093c7e1ec25a057$export$c27ee0ad710f7559=reactExports.forwardRef((st,at)=>{const{__scopeTooltip:pt,...vt}=st,wt=$a093c7e1ec25a057$var$usePopperScope(pt);return $a093c7e1ec25a057$var$useVisuallyHiddenContentContext($a093c7e1ec25a057$var$ARROW_NAME,pt).isInside?null:reactExports.createElement($cf1ac5d9fe0e8206$export$21b07c8f274aebd5,_extends$1({},wt,vt,{ref:at}))});function $a093c7e1ec25a057$var$getExitSideFromRect(st,at){const pt=Math.abs(at.top-st.y),vt=Math.abs(at.bottom-st.y),wt=Math.abs(at.right-st.x),$t=Math.abs(at.left-st.x);switch(Math.min(pt,vt,wt,$t)){case $t:return"left";case wt:return"right";case pt:return"top";case vt:return"bottom";default:throw new Error("unreachable")}}function $a093c7e1ec25a057$var$getPaddedExitPoints(st,at,pt=5){const vt=[];switch(at){case"top":vt.push({x:st.x-pt,y:st.y+pt},{x:st.x+pt,y:st.y+pt});break;case"bottom":vt.push({x:st.x-pt,y:st.y-pt},{x:st.x+pt,y:st.y-pt});break;case"left":vt.push({x:st.x+pt,y:st.y-pt},{x:st.x+pt,y:st.y+pt});break;case"right":vt.push({x:st.x-pt,y:st.y-pt},{x:st.x-pt,y:st.y+pt});break}return vt}function $a093c7e1ec25a057$var$getPointsFromRect(st){const{top:at,right:pt,bottom:vt,left:wt}=st;return[{x:wt,y:at},{x:pt,y:at},{x:pt,y:vt},{x:wt,y:vt}]}function $a093c7e1ec25a057$var$isPointInPolygon(st,at){const{x:pt,y:vt}=st;let wt=!1;for(let $t=0,Tt=at.length-1;$t<at.length;Tt=$t++){const Lt=at[$t].x,Ft=at[$t].y,Ct=at[Tt].x,Ht=at[Tt].y;Ft>vt!=Ht>vt&&pt<(Ct-Lt)*(vt-Ft)/(Ht-Ft)+Lt&&(wt=!wt)}return wt}function $a093c7e1ec25a057$var$getHull(st){const at=st.slice();return at.sort((pt,vt)=>pt.x<vt.x?-1:pt.x>vt.x?1:pt.y<vt.y?-1:pt.y>vt.y?1:0),$a093c7e1ec25a057$var$getHullPresorted(at)}function $a093c7e1ec25a057$var$getHullPresorted(st){if(st.length<=1)return st.slice();const at=[];for(let vt=0;vt<st.length;vt++){const wt=st[vt];for(;at.length>=2;){const $t=at[at.length-1],Tt=at[at.length-2];if(($t.x-Tt.x)*(wt.y-Tt.y)>=($t.y-Tt.y)*(wt.x-Tt.x))at.pop();else break}at.push(wt)}at.pop();const pt=[];for(let vt=st.length-1;vt>=0;vt--){const wt=st[vt];for(;pt.length>=2;){const $t=pt[pt.length-1],Tt=pt[pt.length-2];if(($t.x-Tt.x)*(wt.y-Tt.y)>=($t.y-Tt.y)*(wt.x-Tt.x))pt.pop();else break}pt.push(wt)}return pt.pop(),at.length===1&&pt.length===1&&at[0].x===pt[0].x&&at[0].y===pt[0].y?at:at.concat(pt)}const $a093c7e1ec25a057$export$be92b6f5f03c0fe9=$a093c7e1ec25a057$export$28c660c63b792dea,$a093c7e1ec25a057$export$41fb9f06171c75f4=$a093c7e1ec25a057$export$8c610744efcf8a1d,$a093c7e1ec25a057$export$7c6e2c02157bb7d2=$a093c7e1ec25a057$export$e9003e2be37ec060,$a093c7e1ec25a057$export$21b07c8f274aebd5=$a093c7e1ec25a057$export$c27ee0ad710f7559;function _objectWithoutPropertiesLoose$1(st,at){if(st==null)return{};var pt={},vt=Object.keys(st),wt,$t;for($t=0;$t<vt.length;$t++)wt=vt[$t],!(at.indexOf(wt)>=0)&&(pt[wt]=st[wt]);return pt}function _objectWithoutProperties$1(st,at){if(st==null)return{};var pt=_objectWithoutPropertiesLoose$1(st,at),vt,wt;if(Object.getOwnPropertySymbols){var $t=Object.getOwnPropertySymbols(st);for(wt=0;wt<$t.length;wt++)vt=$t[wt],!(at.indexOf(vt)>=0)&&Object.prototype.propertyIsEnumerable.call(st,vt)&&(pt[vt]=st[vt])}return pt}let LevaErrors;(function(st){st[st.UNSUPPORTED_INPUT=0]="UNSUPPORTED_INPUT",st[st.NO_COMPONENT_FOR_TYPE=1]="NO_COMPONENT_FOR_TYPE",st[st.UNKNOWN_INPUT=2]="UNKNOWN_INPUT",st[st.DUPLICATE_KEYS=3]="DUPLICATE_KEYS",st[st.ALREADY_REGISTERED_TYPE=4]="ALREADY_REGISTERED_TYPE",st[st.CLIPBOARD_ERROR=5]="CLIPBOARD_ERROR",st[st.THEME_ERROR=6]="THEME_ERROR",st[st.PATH_DOESNT_EXIST=7]="PATH_DOESNT_EXIST",st[st.INPUT_TYPE_OVERRIDE=8]="INPUT_TYPE_OVERRIDE",st[st.EMPTY_KEY=9]="EMPTY_KEY"})(LevaErrors||(LevaErrors={}));const ErrorList={[LevaErrors.UNSUPPORTED_INPUT]:(st,at)=>[`An input with type \`${st}\` input was found at path \`${at}\` but it's not supported yet.`],[LevaErrors.NO_COMPONENT_FOR_TYPE]:(st,at)=>[`Type \`${st}\` found at path \`${at}\` can't be displayed in panel because no component supports it yet.`],[LevaErrors.UNKNOWN_INPUT]:(st,at)=>[`input at path \`${st}\` is not recognized.`,at],[LevaErrors.DUPLICATE_KEYS]:(st,at,pt)=>[`Key \`${st}\` of path \`${at}\` already exists at path \`${pt}\`. Even nested keys need to be unique. Rename one of the keys.`],[LevaErrors.ALREADY_REGISTERED_TYPE]:st=>[`Type ${st} has already been registered. You can't register a component with the same type.`],[LevaErrors.CLIPBOARD_ERROR]:st=>["Error copying the value",st],[LevaErrors.THEME_ERROR]:(st,at)=>[`Error accessing the theme \`${st}.${at}\` value.`],[LevaErrors.PATH_DOESNT_EXIST]:st=>[`Error getting the value at path \`${st}\`. There is probably an error in your \`render\` function.`],[LevaErrors.PATH_DOESNT_EXIST]:st=>[`Error accessing the value at path \`${st}\``],[LevaErrors.INPUT_TYPE_OVERRIDE]:(st,at,pt)=>[`Input at path \`${st}\` already exists with type: \`${at}\`. Its type cannot be overridden with type \`${pt}\`.`],[LevaErrors.EMPTY_KEY]:()=>["Keys can not be empty, if you want to hide a label use whitespace."]};function _log(st,at,...pt){const[vt,...wt]=ErrorList[at](...pt);console[st]("LEVA: "+vt,...wt)}const warn=_log.bind(null,"warn"),log=_log.bind(null,"log"),_excluded$a=["value"],_excluded2$4=["schema"],_excluded3$1=["value"],Schemas=[],Plugins={};function getValueType(st){let{value:at}=st,pt=_objectWithoutProperties$1(st,_excluded$a);for(let vt of Schemas){const wt=vt(at,pt);if(wt)return wt}}function register(st,at){let{schema:pt}=at,vt=_objectWithoutProperties$1(at,_excluded2$4);if(st in Plugins){warn(LevaErrors.ALREADY_REGISTERED_TYPE,st);return}Schemas.push((wt,$t)=>pt(wt,$t)&&st),Plugins[st]=vt}function createInternalPlugin(st){return st}function normalize$3$1(st,at,pt,vt){const{normalize:wt}=Plugins[st];if(wt)return wt(at,pt,vt);if(typeof at!="object"||!("value"in at))return{value:at};const{value:$t}=at,Tt=_objectWithoutProperties$1(at,_excluded3$1);return{value:$t,settings:Tt}}function sanitize$4(st,at,pt,vt,wt,$t){const{sanitize:Tt}=Plugins[st];return Tt?Tt(at,pt,vt,wt,$t):at}function format$2(st,at,pt){const{format:vt}=Plugins[st];return vt?vt(at,pt):at}function _defineProperty$2(st,at,pt){return at in st?Object.defineProperty(st,at,{value:pt,enumerable:!0,configurable:!0,writable:!0}):st[at]=pt,st}function ownKeys$2(st,at){var pt=Object.keys(st);if(Object.getOwnPropertySymbols){var vt=Object.getOwnPropertySymbols(st);at&&(vt=vt.filter(function(wt){return Object.getOwnPropertyDescriptor(st,wt).enumerable})),pt.push.apply(pt,vt)}return pt}function _objectSpread2(st){for(var at=1;at<arguments.length;at++){var pt=arguments[at]!=null?arguments[at]:{};at%2?ownKeys$2(Object(pt),!0).forEach(function(vt){_defineProperty$2(st,vt,pt[vt])}):Object.getOwnPropertyDescriptors?Object.defineProperties(st,Object.getOwnPropertyDescriptors(pt)):ownKeys$2(Object(pt)).forEach(function(vt){Object.defineProperty(st,vt,Object.getOwnPropertyDescriptor(pt,vt))})}return st}const clamp=(st,at,pt)=>st>pt?pt:st<at?at:st,parseNumber=st=>{if(st===""||typeof st=="number")return st;try{const at=evaluate(st);if(!isNaN(at))return at}catch{}return parseFloat(st)},log10=Math.log(10);function getStep(st){let at=Math.abs(+String(st).replace(".",""));if(at===0)return .01;for(;at!==0&&at%10===0;)at/=10;const pt=Math.floor(Math.log(at)/log10)+1,vt=Math.floor(Math.log10(Math.abs(st))),wt=Math.pow(10,vt-pt);return Math.max(wt,.001)}const range=(st,at,pt)=>pt===at?0:(clamp(st,at,pt)-at)/(pt-at),invertedRange=(st,at,pt)=>st*(pt-at)+at,getUid=()=>"_"+Math.random().toString(36).substr(2,9),parens=/\(([0-9+\-*/^ .]+)\)/,exp=/(\d+(?:\.\d+)?) ?\^ ?(\d+(?:\.\d+)?)/,mul=/(\d+(?:\.\d+)?) ?\* ?(\d+(?:\.\d+)?)/,div=/(\d+(?:\.\d+)?) ?\/ ?(\d+(?:\.\d+)?)/,add=/(\d+(?:\.\d+)?) ?\+ ?(\d+(?:\.\d+)?)/,sub=/(\d+(?:\.\d+)?) ?- ?(\d+(?:\.\d+)?)/;function evaluate(st){if(isNaN(Number(st)))if(parens.test(st)){const at=st.replace(parens,(pt,vt)=>String(evaluate(vt)));return evaluate(at)}else if(exp.test(st)){const at=st.replace(exp,(pt,vt,wt)=>String(Math.pow(Number(vt),Number(wt))));return evaluate(at)}else if(mul.test(st)){const at=st.replace(mul,(pt,vt,wt)=>String(Number(vt)*Number(wt)));return evaluate(at)}else if(div.test(st)){const at=st.replace(div,(pt,vt,wt)=>{if(wt!=0)return String(Number(vt)/Number(wt));throw new Error("Division by zero")});return evaluate(at)}else if(add.test(st)){const at=st.replace(add,(pt,vt,wt)=>String(Number(vt)+Number(wt)));return evaluate(at)}else if(sub.test(st)){const at=st.replace(sub,(pt,vt,wt)=>String(Number(vt)-Number(wt)));return evaluate(at)}else return Number(st);return Number(st)}function pick(st,at){return at.reduce((pt,vt)=>(st&&st.hasOwnProperty(vt)&&(pt[vt]=st[vt]),pt),{})}function omit(st,at){const pt=_objectSpread2({},st);return at.forEach(vt=>vt in st&&delete pt[vt]),pt}function mapArrayToKeys(st,at){return st.reduce((pt,vt,wt)=>Object.assign(pt,{[at[wt]]:vt}),{})}function isObject$8(st){return Object.prototype.toString.call(st)==="[object Object]"}const isEmptyObject=st=>isObject$8(st)&&Object.keys(st).length===0;let SpecialInputs;(function(st){st.BUTTON="BUTTON",st.BUTTON_GROUP="BUTTON_GROUP",st.MONITOR="MONITOR",st.FOLDER="FOLDER"})(SpecialInputs||(SpecialInputs={}));let LevaInputs;(function(st){st.SELECT="SELECT",st.IMAGE="IMAGE",st.NUMBER="NUMBER",st.COLOR="COLOR",st.STRING="STRING",st.BOOLEAN="BOOLEAN",st.INTERVAL="INTERVAL",st.VECTOR3D="VECTOR3D",st.VECTOR2D="VECTOR2D"})(LevaInputs||(LevaInputs={}));const _excluded$9=["type","__customInput"],_excluded2$3=["render","label","optional","order","disabled","hint","onChange","onEditStart","onEditEnd","transient"],_excluded3$2=["type"];function parseOptions(st,at,pt={},vt){var wt,$t;if(typeof st!="object"||Array.isArray(st))return{type:vt,input:st,options:_objectSpread2({key:at,label:at,optional:!1,disabled:!1,order:0},pt)};if("__customInput"in st){const{type:Hr,__customInput:qr}=st,Zr=_objectWithoutProperties$1(st,_excluded$9);return parseOptions(qr,at,Zr,Hr)}const{render:Tt,label:Lt,optional:Ft,order:Ct=0,disabled:Ht,hint:Gt,onChange:jt,onEditStart:qt,onEditEnd:Kt,transient:An}=st,Sn=_objectWithoutProperties$1(st,_excluded2$3),wn=_objectSpread2({render:Tt,key:at,label:Lt??at,hint:Gt,transient:An??!!jt,onEditStart:qt,onEditEnd:Kt,disabled:Ht,optional:Ft,order:Ct},pt);let{type:In}=Sn,tr=_objectWithoutProperties$1(Sn,_excluded3$2);if(In=vt??In,In in SpecialInputs)return{type:In,input:tr,options:wn};let rr;return vt&&isObject$8(tr)&&"value"in tr?rr=tr.value:rr=isEmptyObject(tr)?void 0:tr,{type:In,input:rr,options:_objectSpread2(_objectSpread2({},wn),{},{onChange:jt,optional:(wt=wn.optional)!==null&&wt!==void 0?wt:!1,disabled:($t=wn.disabled)!==null&&$t!==void 0?$t:!1})}}function normalizeInput(st,at,pt,vt){const wt=parseOptions(st,at),{type:$t,input:Tt,options:Lt}=wt;if($t)return $t in SpecialInputs?wt:{type:$t,input:normalize$3$1($t,Tt,pt,vt),options:Lt};let Ft=getValueType(Tt);return Ft?{type:Ft,input:normalize$3$1(Ft,Tt,pt,vt),options:Lt}:(Ft=getValueType({value:Tt}),Ft?{type:Ft,input:normalize$3$1(Ft,{value:Tt},pt,vt),options:Lt}:!1)}function updateInput(st,at,pt,vt,wt){const{value:$t,type:Tt,settings:Lt}=st;st.value=sanitizeValue({type:Tt,value:$t,settings:Lt},at,pt,vt),st.fromPanel=wt}const ValueError=function(at,pt,vt){this.type="LEVA_ERROR",this.message="LEVA: "+at,this.previousValue=pt,this.error=vt};function sanitizeValue({type:st,value:at,settings:pt},vt,wt,$t){const Tt=st!=="SELECT"&&typeof vt=="function"?vt(at):vt;let Lt;try{Lt=sanitize$4(st,Tt,pt,at,wt,$t)}catch(Ft){throw new ValueError(`The value \`${vt}\` did not result in a correct value.`,at,Ft)}return dequal(Lt,at)?at:Lt}const debounce=(st,at,pt=!1)=>{let vt=0;return function(){const wt=arguments,$t=pt&&!vt,Tt=()=>st.apply(this,wt);window.clearTimeout(vt),vt=window.setTimeout(Tt,at),$t&&Tt()}},multiplyStep=st=>st.shiftKey?5:st.altKey?1/5:1;function render(st,at){const pt=console.error;console.error=()=>{},ReactDOM.render(st,at),console.error=pt}const _excluded$8=["value"],_excluded2$2$1=["min","max"],schema$3=st=>{if(typeof st=="number")return!0;if(typeof st=="string"){const at=parseFloat(st);return isNaN(at)?!1:st.substring((""+at).length).trim().length<4}return!1},sanitize$3=(st,{min:at=-1/0,max:pt=1/0,suffix:vt})=>{const wt=parseFloat(st);if(st===""||isNaN(wt))throw Error("Invalid number");const $t=clamp(wt,at,pt);return vt?$t+vt:$t},format$1$1=(st,{pad:at=0,suffix:pt})=>{const vt=parseFloat(st).toFixed(at);return pt?vt+pt:vt},normalize$2$1=st=>{let{value:at}=st,pt=_objectWithoutProperties$1(st,_excluded$8);const{min:vt=-1/0,max:wt=1/0}=pt,$t=_objectWithoutProperties$1(pt,_excluded2$2$1);let Tt=parseFloat(at);const Lt=typeof at=="string"?at.substring((""+Tt).length):void 0;Tt=clamp(Tt,vt,wt);let Ft=pt.step;Ft||(Number.isFinite(vt)?Number.isFinite(wt)?Ft=+(Math.abs(wt-vt)/100).toPrecision(1):Ft=+(Math.abs(Tt-vt)/100).toPrecision(1):Number.isFinite(wt)&&(Ft=+(Math.abs(wt-Tt)/100).toPrecision(1)));const Ct=Ft?getStep(Ft)*10:getStep(Tt);Ft=Ft||Ct/10;const Ht=Math.round(clamp(Math.log10(1/Ct),0,2));return{value:Lt?Tt+Lt:Tt,settings:_objectSpread2({initialValue:Tt,step:Ft,pad:Ht,min:vt,max:wt,suffix:Lt},$t)}},sanitizeStep$1=(st,{step:at,initialValue:pt})=>{const vt=Math.round((st-pt)/at);return pt+vt*at};var props$3=Object.freeze({__proto__:null,schema:schema$3,sanitize:sanitize$3,format:format$1$1,normalize:normalize$2$1,sanitizeStep:sanitizeStep$1});function _extends(){return _extends=Object.assign?Object.assign.bind():function(st){for(var at=1;at<arguments.length;at++){var pt=arguments[at];for(var vt in pt)Object.prototype.hasOwnProperty.call(pt,vt)&&(st[vt]=pt[vt])}return st},_extends.apply(this,arguments)}const InputContext=reactExports.createContext({});function useInputContext(){return reactExports.useContext(InputContext)}const ThemeContext=reactExports.createContext(null),StoreContext=reactExports.createContext(null),PanelSettingsContext=reactExports.createContext(null);function useStoreContext(){return reactExports.useContext(StoreContext)}function usePanelSettingsContext(){return reactExports.useContext(PanelSettingsContext)}const getDefaultTheme=()=>({colors:{elevation1:"#292d39",elevation2:"#181c20",elevation3:"#373c4b",accent1:"#0066dc",accent2:"#007bff",accent3:"#3c93ff",highlight1:"#535760",highlight2:"#8c92a4",highlight3:"#fefefe",vivid1:"#ffcc00",folderWidgetColor:"$highlight2",folderTextColor:"$highlight3",toolTipBackground:"$highlight3",toolTipText:"$elevation2"},radii:{xs:"2px",sm:"3px",lg:"10px"},space:{xs:"3px",sm:"6px",md:"10px",rowGap:"7px",colGap:"7px"},fonts:{mono:"ui-monospace, SFMono-Regular, Menlo, 'Roboto Mono', monospace",sans:"system-ui, sans-serif"},fontSizes:{root:"11px",toolTip:"$root"},sizes:{rootWidth:"280px",controlWidth:"160px",numberInputMinWidth:"38px",scrubberWidth:"8px",scrubberHeight:"16px",rowHeight:"24px",folderTitleHeight:"20px",checkboxSize:"16px",joystickWidth:"100px",joystickHeight:"100px",colorPickerWidth:"$controlWidth",colorPickerHeight:"100px",imagePreviewWidth:"$controlWidth",imagePreviewHeight:"100px",monitorHeight:"60px",titleBarHeight:"39px"},shadows:{level1:"0 0 9px 0 #00000088",level2:"0 4px 14px #00000033"},borderWidths:{root:"0px",input:"1px",focus:"1px",hover:"1px",active:"1px",folder:"1px"},fontWeights:{label:"normal",folder:"normal",button:"normal"}});function createStateClass(st,at){const[pt,vt]=st.split(" "),wt={};return pt!=="none"&&(wt.boxShadow=`${at.inset?"inset ":""}0 0 0 $borderWidths${[at.key]} $colors${pt!=="default"&&pt||at.borderColor}`),vt&&(wt.backgroundColor=vt),wt}const utils={$inputStyle:()=>st=>createStateClass(st,{key:"$input",borderColor:"$highlight1",inset:!0}),$focusStyle:()=>st=>createStateClass(st,{key:"$focus",borderColor:"$accent2"}),$hoverStyle:()=>st=>createStateClass(st,{key:"$hover",borderColor:"$accent1",inset:!0}),$activeStyle:()=>st=>createStateClass(st,{key:"$active",borderColor:"$accent1",inset:!0})},{styled,css,createTheme,globalCss,keyframes}=q$1({prefix:"leva",theme:getDefaultTheme(),utils:_objectSpread2(_objectSpread2({},utils),{},{$flex:()=>({display:"flex",alignItems:"center"}),$flexCenter:()=>({display:"flex",alignItems:"center",justifyContent:"center"}),$reset:()=>({outline:"none",fontSize:"inherit",fontWeight:"inherit",color:"inherit",fontFamily:"inherit",border:"none",backgroundColor:"transparent",appearance:"none"}),$draggable:()=>({touchAction:"none",WebkitUserDrag:"none",userSelect:"none"}),$focus:st=>({"&:focus":utils.$focusStyle()(st)}),$focusWithin:st=>({"&:focus-within":utils.$focusStyle()(st)}),$hover:st=>({"&:hover":utils.$hoverStyle()(st)}),$active:st=>({"&:active":utils.$activeStyle()(st)})})}),globalStyles=globalCss({".leva__panel__dragged":{WebkitUserDrag:"none",userSelect:"none",input:{userSelect:"none"},"*":{cursor:"ew-resize !important"}}});function mergeTheme(st){const at=getDefaultTheme();if(!st)return{theme:at,className:""};Object.keys(st).forEach(vt=>{Object.assign(at[vt],st[vt])});const pt=createTheme(at);return{theme:at,className:pt.className}}function useTh(st,at){const{theme:pt}=reactExports.useContext(ThemeContext);if(!(st in pt)||!(at in pt[st]))return warn(LevaErrors.THEME_ERROR,st,at),"";let vt=at;for(;;){let wt=pt[st][vt];if(typeof wt=="string"&&wt.charAt(0)==="$")vt=wt.substr(1);else return wt}}const StyledInput=styled("input",{$reset:"",padding:"0 $sm",width:0,minWidth:0,flex:1,height:"100%",variants:{levaType:{number:{textAlign:"right"}},as:{textarea:{padding:"$sm"}}}}),InnerLabel=styled("div",{$draggable:"",height:"100%",$flexCenter:"",position:"relative",padding:"0 $xs",fontSize:"0.8em",opacity:.8,cursor:"default",touchAction:"none",[`& + ${StyledInput}`]:{paddingLeft:0}}),InnerNumberLabel=styled(InnerLabel,{cursor:"ew-resize",marginRight:"-$xs",textTransform:"uppercase",opacity:.3,"&:hover":{opacity:1},variants:{dragging:{true:{backgroundColor:"$accent2",opacity:1}}}}),InputContainer=styled("div",{$flex:"",position:"relative",borderRadius:"$sm",overflow:"hidden",color:"inherit",height:"$rowHeight",backgroundColor:"$elevation3",$inputStyle:"$elevation1",$hover:"",$focusWithin:"",variants:{textArea:{true:{height:"auto"}}}}),_excluded$7$1=["innerLabel","value","onUpdate","onChange","onKeyDown","type","id","inputType","rows"],_excluded2$1$1=["onUpdate"];function ValueInput(st){let{innerLabel:at,value:pt,onUpdate:vt,onChange:wt,onKeyDown:$t,type:Tt,id:Lt,inputType:Ft="text",rows:Ct=0}=st,Ht=_objectWithoutProperties$1(st,_excluded$7$1);const{id:Gt,emitOnEditStart:jt,emitOnEditEnd:qt,disabled:Kt}=useInputContext(),An=Lt||Gt,Sn=reactExports.useRef(null),wn=Ct>0,In=wn?"textarea":"input",tr=reactExports.useCallback(qr=>Zr=>{const Bo=Zr.currentTarget.value;qr(Bo)},[]);React.useEffect(()=>{const qr=Sn.current,Zr=tr(Bo=>{vt(Bo),qt()});return qr==null||qr.addEventListener("blur",Zr),()=>qr==null?void 0:qr.removeEventListener("blur",Zr)},[tr,vt,qt]);const rr=reactExports.useCallback(qr=>{qr.key==="Enter"&&tr(vt)(qr)},[tr,vt]),Hr=Object.assign({as:In},wn?{rows:Ct}:{},Ht);return React.createElement(InputContainer,{textArea:wn},at&&typeof at=="string"?React.createElement(InnerLabel,null,at):at,React.createElement(StyledInput,_extends({levaType:Tt,ref:Sn,id:An,type:Ft,autoComplete:"off",spellCheck:"false",value:pt,onChange:tr(wt),onFocus:()=>jt(),onKeyPress:rr,onKeyDown:$t,disabled:Kt},Hr)))}function NumberInput(st){let{onUpdate:at}=st,pt=_objectWithoutProperties$1(st,_excluded2$1$1);const vt=reactExports.useCallback($t=>at(parseNumber($t)),[at]),wt=reactExports.useCallback($t=>{const Tt=$t.key==="ArrowUp"?1:$t.key==="ArrowDown"?-1:0;if(Tt){$t.preventDefault();const Lt=$t.altKey?.1:$t.shiftKey?10:1;at(Ft=>parseFloat(Ft)+Tt*Lt)}},[at]);return React.createElement(ValueInput,_extends({},pt,{onUpdate:vt,onKeyDown:wt,type:"number"}))}const StyledFolder=styled("div",{}),StyledWrapper=styled("div",{position:"relative",background:"$elevation2",transition:"height 300ms ease",variants:{fill:{true:{},false:{}},flat:{false:{},true:{}},isRoot:{true:{},false:{paddingLeft:"$md","&::after":{content:'""',position:"absolute",left:0,top:0,width:"$borderWidths$folder",height:"100%",backgroundColor:"$folderWidgetColor",opacity:.4,transform:"translateX(-50%)"}}}},compoundVariants:[{isRoot:!0,fill:!1,css:{overflowY:"auto",maxHeight:"calc(100vh - 20px - $$titleBarHeight)"}},{isRoot:!0,flat:!1,css:{borderRadius:"$lg"}}]}),StyledTitle=styled("div",{$flex:"",color:"$folderTextColor",userSelect:"none",cursor:"pointer",height:"$folderTitleHeight",fontWeight:"$folder","> svg":{marginLeft:-4,marginRight:4,cursor:"pointer",fill:"$folderWidgetColor",opacity:.6},"&:hover > svg":{fill:"$folderWidgetColor"},[`&:hover + ${StyledWrapper}::after`]:{opacity:.6},[`${StyledFolder}:hover > & + ${StyledWrapper}::after`]:{opacity:.6},[`${StyledFolder}:hover > & > svg`]:{opacity:1}}),StyledContent=styled("div",{position:"relative",display:"grid",gridTemplateColumns:"100%",rowGap:"$rowGap",transition:"opacity 250ms ease",variants:{toggled:{true:{opacity:1,transitionDelay:"250ms"},false:{opacity:0,transitionDelay:"0ms",pointerEvents:"none"}},isRoot:{true:{"& > div":{paddingLeft:"$md",paddingRight:"$md"},"& > div:first-of-type":{paddingTop:"$sm"},"& > div:last-of-type":{paddingBottom:"$sm"},[`> ${StyledFolder}:not(:first-of-type)`]:{paddingTop:"$sm",marginTop:"$md",borderTop:"$borderWidths$folder solid $colors$elevation1"}}}}}),StyledRow=styled("div",{position:"relative",zIndex:100,display:"grid",rowGap:"$rowGap",gridTemplateRows:"minmax($sizes$rowHeight, max-content)",alignItems:"center",color:"$highlight2",[`${StyledContent} > &`]:{"&:first-of-type":{marginTop:"$rowGap"},"&:last-of-type":{marginBottom:"$rowGap"}},variants:{disabled:{true:{pointerEvents:"none"},false:{"&:hover,&:focus-within":{color:"$highlight3"}}}}}),StyledInputRow=styled(StyledRow,{gridTemplateColumns:"auto $sizes$controlWidth",columnGap:"$colGap"}),CopyLabelContainer=styled("div",{$flex:"",height:"100%",position:"relative",overflow:"hidden","& > div":{marginLeft:"$colGap",padding:"0 $xs",opacity:.4},"& > div:hover":{opacity:.8},"& > div > svg":{display:"none",cursor:"pointer",width:13,minWidth:13,height:13,backgroundColor:"$elevation2"},"&:hover > div > svg":{display:"block"},variants:{align:{top:{height:"100%",alignItems:"flex-start",paddingTop:"$sm"}}}}),StyledOptionalToggle=styled("input",{$reset:"",height:0,width:0,opacity:0,margin:0,"& + label":{position:"relative",$flexCenter:"",height:"100%",userSelect:"none",cursor:"pointer",paddingLeft:2,paddingRight:"$sm",pointerEvents:"auto"},"& + label:after":{content:'""',width:6,height:6,backgroundColor:"$elevation3",borderRadius:"50%",$activeStyle:""},"&:focus + label:after":{$focusStyle:""},"& + label:active:after":{backgroundColor:"$accent1",$focusStyle:""},"&:checked + label:after":{backgroundColor:"$accent1"}}),StyledLabel=styled("label",{fontWeight:"$label",overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap","& > svg":{display:"block"}}),StyledInputWrapper$1=styled("div",{opacity:1,variants:{disabled:{true:{opacity:.6,pointerEvents:"none",[`& ${StyledLabel}`]:{pointerEvents:"auto"}}}}}),Overlay=styled("div",{position:"fixed",top:0,bottom:0,right:0,left:0,zIndex:1e3,userSelect:"none"}),StyledToolTipContent=styled("div",{background:"$toolTipBackground",fontFamily:"$sans",fontSize:"$toolTip",padding:"$xs $sm",color:"$toolTipText",borderRadius:"$xs",boxShadow:"$level2",maxWidth:260}),ToolTipArrow=styled($a093c7e1ec25a057$export$21b07c8f274aebd5,{fill:"$toolTipBackground"});function Portal({children:st}){const{className:at}=reactExports.useContext(ThemeContext);return React.createElement($f1701beae083dbae$export$be92b6f5f03c0fe9,{className:at},st)}const _excluded$6$1=["align"];function OptionalToggle(){const{id:st,disable:at,disabled:pt}=useInputContext();return React.createElement(React.Fragment,null,React.createElement(StyledOptionalToggle,{id:st+"__disable",type:"checkbox",checked:!pt,onChange:()=>at(!pt)}),React.createElement("label",{htmlFor:st+"__disable"}))}function RawLabel(st){const{id:at,optional:pt,hint:vt}=useInputContext(),wt=st.htmlFor||(at?{htmlFor:at}:null),$t=!vt&&typeof st.children=="string"?{title:st.children}:null;return React.createElement(React.Fragment,null,pt&&React.createElement(OptionalToggle,null),vt!==void 0?React.createElement($a093c7e1ec25a057$export$be92b6f5f03c0fe9,null,React.createElement($a093c7e1ec25a057$export$41fb9f06171c75f4,{asChild:!0},React.createElement(StyledLabel,_extends({},wt,st))),React.createElement($a093c7e1ec25a057$export$7c6e2c02157bb7d2,{side:"top",sideOffset:2},React.createElement(StyledToolTipContent,null,vt,React.createElement(ToolTipArrow,null)))):React.createElement(StyledLabel,_extends({},wt,$t,st)))}function Label(st){let{align:at}=st,pt=_objectWithoutProperties$1(st,_excluded$6$1);const{value:vt,label:wt,key:$t,disabled:Tt}=useInputContext(),{hideCopyButton:Lt}=usePanelSettingsContext(),Ft=!Lt&&$t!==void 0,[Ct,Ht]=reactExports.useState(!1),Gt=async()=>{try{await navigator.clipboard.writeText(JSON.stringify({[$t]:vt??""})),Ht(!0)}catch{warn(LevaErrors.CLIPBOARD_ERROR,{[$t]:vt})}};return React.createElement(CopyLabelContainer,{align:at,onPointerLeave:()=>Ht(!1)},React.createElement(RawLabel,pt),Ft&&!Tt&&React.createElement("div",{title:`Click to copy ${typeof wt=="string"?wt:$t} value`},Ct?React.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor"},React.createElement("path",{d:"M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"}),React.createElement("path",{fillRule:"evenodd",d:"M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm9.707 5.707a1 1 0 00-1.414-1.414L9 12.586l-1.293-1.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z",clipRule:"evenodd"})):React.createElement("svg",{onClick:Gt,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor"},React.createElement("path",{d:"M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z"}),React.createElement("path",{d:"M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z"}))))}const _excluded$5$1=["toggled"],Svg=styled("svg",{fill:"currentColor",transition:"transform 350ms ease, fill 250ms ease"});function Chevron(st){let{toggled:at}=st,pt=_objectWithoutProperties$1(st,_excluded$5$1);return React.createElement(Svg,_extends({width:"9",height:"5",viewBox:"0 0 9 5",xmlns:"http://www.w3.org/2000/svg",style:{transform:`rotate(${at?0:-90}deg)`}},pt),React.createElement("path",{d:"M3.8 4.4c.4.3 1 .3 1.4 0L8 1.7A1 1 0 007.4 0H1.6a1 1 0 00-.7 1.7l3 2.7z"}))}const _excluded$4$1=["input"];function Row(st){let{input:at}=st,pt=_objectWithoutProperties$1(st,_excluded$4$1);return at?React.createElement(StyledInputRow,pt):React.createElement(StyledRow,pt)}function useInputSetters({value:st,type:at,settings:pt,setValue:vt}){const[wt,$t]=reactExports.useState(format$2(at,st,pt)),Tt=reactExports.useRef(st),Lt=reactExports.useRef(pt);Lt.current=pt;const Ft=reactExports.useCallback(Ht=>$t(format$2(at,Ht,Lt.current)),[at]),Ct=reactExports.useCallback(Ht=>{try{vt(Ht)}catch(Gt){const{type:jt,previousValue:qt}=Gt;if(jt!=="LEVA_ERROR")throw Gt;Ft(qt)}},[Ft,vt]);return reactExports.useEffect(()=>{dequal(st,Tt.current)||Ft(st),Tt.current=st},[st,Ft]),{displayValue:wt,onChange:$t,onUpdate:Ct}}function useDrag(st,at){const{emitOnEditStart:pt,emitOnEditEnd:vt}=useInputContext();return useDrag$1(wt=>{wt.first&&(document.body.classList.add("leva__panel__dragged"),pt==null||pt());const $t=st(wt);return wt.last&&(document.body.classList.remove("leva__panel__dragged"),vt==null||vt()),$t},at)}function useCanvas2d(st){const at=reactExports.useRef(null),pt=reactExports.useRef(null),vt=reactExports.useRef(!1);return reactExports.useEffect(()=>{const wt=debounce(()=>{at.current.width=at.current.offsetWidth*window.devicePixelRatio,at.current.height=at.current.offsetHeight*window.devicePixelRatio,st(at.current,pt.current)},250);return window.addEventListener("resize",wt),vt.current||(wt(),vt.current=!0),()=>window.removeEventListener("resize",wt)},[st]),reactExports.useEffect(()=>{pt.current=at.current.getContext("2d")},[]),[at,pt]}function useTransform(){const st=reactExports.useRef(null),at=reactExports.useRef({x:0,y:0}),pt=reactExports.useCallback(vt=>{Object.assign(at.current,vt),st.current&&(st.current.style.transform=`translate3d(${at.current.x}px, ${at.current.y}px, 0)`)},[]);return[st,pt]}const _excluded$3$1=["__refCount"],getInputAtPath=(st,at)=>{if(!st[at])return null;const pt=st[at];return _objectWithoutProperties$1(pt,_excluded$3$1)};function useInput(st){const at=useStoreContext(),[pt,vt]=reactExports.useState(getInputAtPath(at.getData(),st)),wt=reactExports.useCallback(Ct=>at.setValueAtPath(st,Ct,!0),[st,at]),$t=reactExports.useCallback(Ct=>at.setSettingsAtPath(st,Ct),[st,at]),Tt=reactExports.useCallback(Ct=>at.disableInputAtPath(st,Ct),[st,at]),Lt=reactExports.useCallback(()=>at.emitOnEditStart(st),[st,at]),Ft=reactExports.useCallback(()=>at.emitOnEditEnd(st),[st,at]);return reactExports.useEffect(()=>{vt(getInputAtPath(at.getData(),st));const Ct=at.useStore.subscribe(Ht=>getInputAtPath(Ht.data,st),vt,{equalityFn:shallow});return()=>Ct()},[at,st]),[pt,{set:wt,setSettings:$t,disable:Tt,storeId:at.storeId,emitOnEditStart:Lt,emitOnEditEnd:Ft}]}const RangeGrid=styled("div",{variants:{hasRange:{true:{position:"relative",display:"grid",gridTemplateColumns:"auto $sizes$numberInputMinWidth",columnGap:"$colGap",alignItems:"center"}}}}),Range=styled("div",{position:"relative",width:"100%",height:2,borderRadius:"$xs",backgroundColor:"$elevation1"}),Scrubber=styled("div",{position:"absolute",width:"$scrubberWidth",height:"$scrubberHeight",borderRadius:"$xs",boxShadow:"0 0 0 2px $colors$elevation2",backgroundColor:"$accent2",cursor:"pointer",$active:"none $accent1",$hover:"none $accent3",variants:{position:{left:{borderTopRightRadius:0,borderBottomRightRadius:0,transform:"translateX(calc(-0.5 * ($sizes$scrubberWidth + 4px)))"},right:{borderTopLeftRadius:0,borderBottomLeftRadius:0,transform:"translateX(calc(0.5 * ($sizes$scrubberWidth + 4px)))"}}}}),RangeWrapper=styled("div",{position:"relative",$flex:"",height:"100%",cursor:"pointer",touchAction:"none"}),Indicator=styled("div",{position:"absolute",height:"100%",backgroundColor:"$accent2"});function RangeSlider({value:st,min:at,max:pt,onDrag:vt,step:wt,initialValue:$t}){const Tt=reactExports.useRef(null),Lt=reactExports.useRef(null),Ft=reactExports.useRef(0),Ct=useTh("sizes","scrubberWidth"),Ht=useDrag(({event:jt,first:qt,xy:[Kt],movement:[An],memo:Sn})=>{if(qt){const{width:In,left:tr}=Tt.current.getBoundingClientRect();Ft.current=In-parseFloat(Ct),Sn=(jt==null?void 0:jt.target)===Lt.current?st:invertedRange((Kt-tr)/In,at,pt)}const wn=Sn+invertedRange(An/Ft.current,0,pt-at);return vt(sanitizeStep$1(wn,{step:wt,initialValue:$t})),Sn}),Gt=range(st,at,pt);return React.createElement(RangeWrapper,_extends({ref:Tt},Ht()),React.createElement(Range,null,React.createElement(Indicator,{style:{left:0,right:`${(1-Gt)*100}%`}})),React.createElement(Scrubber,{ref:Lt,style:{left:`calc(${Gt} * (100% - ${Ct}))`}}))}const DraggableLabel=React.memo(({label:st,onUpdate:at,step:pt,innerLabelTrim:vt})=>{const[wt,$t]=reactExports.useState(!1),Tt=useDrag(({active:Lt,delta:[Ft],event:Ct,memo:Ht=0})=>($t(Lt),Ht+=Ft/2,Math.abs(Ht)>=1&&(at(Gt=>parseFloat(Gt)+Math.floor(Ht)*pt*multiplyStep(Ct)),Ht=0),Ht));return React.createElement(InnerNumberLabel,_extends({dragging:wt,title:st.length>1?st:""},Tt()),st.slice(0,vt))});function Number$1({label:st,id:at,displayValue:pt,onUpdate:vt,onChange:wt,settings:$t,innerLabelTrim:Tt=1}){const Lt=Tt>0&&React.createElement(DraggableLabel,{label:st,step:$t.step,onUpdate:vt,innerLabelTrim:Tt});return React.createElement(NumberInput,{id:at,value:String(pt),onUpdate:vt,onChange:wt,innerLabel:Lt})}function NumberComponent(){const st=useInputContext(),{label:at,value:pt,onUpdate:vt,settings:wt,id:$t}=st,{min:Tt,max:Lt}=wt,Ft=Lt!==1/0&&Tt!==-1/0;return React.createElement(Row,{input:!0},React.createElement(Label,null,at),React.createElement(RangeGrid,{hasRange:Ft},Ft&&React.createElement(RangeSlider,_extends({value:parseFloat(pt),onDrag:vt},wt)),React.createElement(Number$1,_extends({},st,{id:$t,label:"value",innerLabelTrim:Ft?0:1}))))}const{sanitizeStep}=props$3,rest=_objectWithoutProperties$1(props$3,["sanitizeStep"]);var number$1=_objectSpread2({component:NumberComponent},rest);const schema$2$1=(st,at)=>v8n().schema({options:v8n().passesAnyOf(v8n().object(),v8n().array())}).test(at),sanitize$2$1=(st,{values:at})=>{if(at.indexOf(st)<0)throw Error("Selected value doesn't match Select options");return st},format$3=(st,{values:at})=>at.indexOf(st),normalize$1$1=st=>{let{value:at,options:pt}=st,vt,wt;return Array.isArray(pt)?(wt=pt,vt=pt.map($t=>String($t))):(wt=Object.values(pt),vt=Object.keys(pt)),"value"in st?wt.includes(at)||(vt.unshift(String(at)),wt.unshift(at)):at=wt[0],Object.values(pt).includes(at)||(pt[String(at)]=at),{value:at,settings:{keys:vt,values:wt}}};var props$2$1=Object.freeze({__proto__:null,schema:schema$2$1,sanitize:sanitize$2$1,format:format$3,normalize:normalize$1$1});const SelectContainer=styled("div",{$flexCenter:"",position:"relative","> svg":{pointerEvents:"none",position:"absolute",right:"$md"}}),NativeSelect=styled("select",{position:"absolute",top:0,left:0,width:"100%",height:"100%",opacity:0}),PresentationalSelect=styled("div",{display:"flex",alignItems:"center",width:"100%",height:"$rowHeight",backgroundColor:"$elevation3",borderRadius:"$sm",padding:"0 $sm",cursor:"pointer",[`${NativeSelect}:focus + &`]:{$focusStyle:""},[`${NativeSelect}:hover + &`]:{$hoverStyle:""}});function Select({displayValue:st,value:at,onUpdate:pt,id:vt,settings:wt,disabled:$t}){const{keys:Tt,values:Lt}=wt,Ft=reactExports.useRef();return at===Lt[st]&&(Ft.current=Tt[st]),React.createElement(SelectContainer,null,React.createElement(NativeSelect,{id:vt,value:st,onChange:Ct=>pt(Lt[Number(Ct.currentTarget.value)]),disabled:$t},Tt.map((Ct,Ht)=>React.createElement("option",{key:Ct,value:Ht},Ct))),React.createElement(PresentationalSelect,null,Ft.current),React.createElement(Chevron,{toggled:!0}))}function SelectComponent(){const{label:st,value:at,displayValue:pt,onUpdate:vt,id:wt,disabled:$t,settings:Tt}=useInputContext();return React.createElement(Row,{input:!0},React.createElement(Label,null,st),React.createElement(Select,{id:wt,value:at,displayValue:pt,onUpdate:vt,settings:Tt,disabled:$t}))}var select=_objectSpread2({component:SelectComponent},props$2$1);const schema$1$1=st=>v8n().string().test(st),sanitize$1$1=st=>{if(typeof st!="string")throw Error("Invalid string");return st},normalize$4=({value:st,editable:at=!0,rows:pt=!1})=>({value:st,settings:{editable:at,rows:typeof pt=="number"?pt:pt?5:0}});var props$1$1=Object.freeze({__proto__:null,schema:schema$1$1,sanitize:sanitize$1$1,normalize:normalize$4});const _excluded$2$1=["displayValue","onUpdate","onChange","editable"],NonEditableString=styled("div",{whiteSpace:"pre-wrap"});function String$1(st){let{displayValue:at,onUpdate:pt,onChange:vt,editable:wt=!0}=st,$t=_objectWithoutProperties$1(st,_excluded$2$1);return wt?React.createElement(ValueInput,_extends({value:at,onUpdate:pt,onChange:vt},$t)):React.createElement(NonEditableString,null,at)}function StringComponent(){const{label:st,settings:at,displayValue:pt,onUpdate:vt,onChange:wt}=useInputContext();return React.createElement(Row,{input:!0},React.createElement(Label,null,st),React.createElement(String$1,_extends({displayValue:pt,onUpdate:vt,onChange:wt},at)))}var string=_objectSpread2({component:StringComponent},props$1$1);const schema$4=st=>v8n().boolean().test(st),sanitize$5=st=>{if(typeof st!="boolean")throw Error("Invalid boolean");return st};var props$4=Object.freeze({__proto__:null,schema:schema$4,sanitize:sanitize$5});const StyledInputWrapper=styled("div",{position:"relative",$flex:"",height:"$rowHeight",input:{$reset:"",height:0,width:0,opacity:0,margin:0},label:{position:"relative",$flexCenter:"",userSelect:"none",cursor:"pointer",height:"$checkboxSize",width:"$checkboxSize",backgroundColor:"$elevation3",borderRadius:"$sm",$hover:""},"input:focus + label":{$focusStyle:""},"input:focus:checked + label, input:checked + label:hover":{$hoverStyle:"$accent3"},"input + label:active":{backgroundColor:"$accent1"},"input:checked + label:active":{backgroundColor:"$accent1"},"label > svg":{display:"none",width:"90%",height:"90%",stroke:"$highlight3"},"input:checked + label":{backgroundColor:"$accent2"},"input:checked + label > svg":{display:"block"}});function Boolean$1({value:st,onUpdate:at,id:pt,disabled:vt}){return React.createElement(StyledInputWrapper,null,React.createElement("input",{id:pt,type:"checkbox",checked:st,onChange:wt=>at(wt.currentTarget.checked),disabled:vt}),React.createElement("label",{htmlFor:pt},React.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24"},React.createElement("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M5 13l4 4L19 7"}))))}function BooleanComponent(){const{label:st,value:at,onUpdate:pt,disabled:vt,id:wt}=useInputContext();return React.createElement(Row,{input:!0},React.createElement(Label,null,st),React.createElement(Boolean$1,{value:at,onUpdate:pt,id:wt,disabled:vt}))}var boolean=_objectSpread2({component:BooleanComponent},props$4);const _excluded$1$1=["locked"];function Coordinate({value:st,id:at,valueKey:pt,settings:vt,onUpdate:wt,innerLabelTrim:$t}){const Tt=reactExports.useRef(st[pt]);Tt.current=st[pt];const Lt=reactExports.useCallback(Ct=>wt({[pt]:sanitizeValue({type:"NUMBER",value:Tt.current,settings:vt},Ct)}),[wt,vt,pt]),Ft=useInputSetters({type:"NUMBER",value:st[pt],settings:vt,setValue:Lt});return React.createElement(Number$1,{id:at,label:pt,value:st[pt],displayValue:Ft.displayValue,onUpdate:Ft.onUpdate,onChange:Ft.onChange,settings:vt,innerLabelTrim:$t})}const Container$2=styled("div",{display:"grid",columnGap:"$colGap",gridAutoFlow:"column dense",alignItems:"center",variants:{withLock:{true:{gridTemplateColumns:"10px auto","> svg":{cursor:"pointer"}}}}});function Lock(st){let{locked:at}=st,pt=_objectWithoutProperties$1(st,_excluded$1$1);return React.createElement("svg",_extends({width:"10",height:"10",viewBox:"0 0 15 15",fill:"none",xmlns:"http://www.w3.org/2000/svg"},pt),at?React.createElement("path",{d:"M5 4.63601C5 3.76031 5.24219 3.1054 5.64323 2.67357C6.03934 2.24705 6.64582 1.9783 7.5014 1.9783C8.35745 1.9783 8.96306 2.24652 9.35823 2.67208C9.75838 3.10299 10 3.75708 10 4.63325V5.99999H5V4.63601ZM4 5.99999V4.63601C4 3.58148 4.29339 2.65754 4.91049 1.99307C5.53252 1.32329 6.42675 0.978302 7.5014 0.978302C8.57583 0.978302 9.46952 1.32233 10.091 1.99162C10.7076 2.65557 11 3.57896 11 4.63325V5.99999H12C12.5523 5.99999 13 6.44771 13 6.99999V13C13 13.5523 12.5523 14 12 14H3C2.44772 14 2 13.5523 2 13V6.99999C2 6.44771 2.44772 5.99999 3 5.99999H4ZM3 6.99999H12V13H3V6.99999Z",fill:"currentColor",fillRule:"evenodd",clipRule:"evenodd"}):React.createElement("path",{d:"M9 3.63601C9 2.76044 9.24207 2.11211 9.64154 1.68623C10.0366 1.26502 10.6432 1 11.5014 1C12.4485 1 13.0839 1.30552 13.4722 1.80636C13.8031 2.23312 14 2.84313 14 3.63325H15C15 2.68242 14.7626 1.83856 14.2625 1.19361C13.6389 0.38943 12.6743 0 11.5014 0C10.4294 0 9.53523 0.337871 8.91218 1.0021C8.29351 1.66167 8 2.58135 8 3.63601V6H1C0.447715 6 0 6.44772 0 7V13C0 13.5523 0.447715 14 1 14H10C10.5523 14 11 13.5523 11 13V7C11 6.44772 10.5523 6 10 6H9V3.63601ZM1 7H10V13H1V7Z",fill:"currentColor",fillRule:"evenodd",clipRule:"evenodd"}))}function Vector({value:st,onUpdate:at,settings:pt,innerLabelTrim:vt}){const{id:wt,setSettings:$t}=useInputContext(),{lock:Tt,locked:Lt}=pt;return React.createElement(Container$2,{withLock:Tt},Tt&&React.createElement(Lock,{locked:Lt,onClick:()=>$t({locked:!Lt})}),Object.keys(st).map((Ft,Ct)=>React.createElement(Coordinate,{id:Ct===0?wt:`${wt}.${Ft}`,key:Ft,valueKey:Ft,value:st,settings:pt[Ft],onUpdate:at,innerLabelTrim:vt})))}const normalizeKeyedNumberSettings=(st,at)=>{const pt={};let vt=0,wt=1/0;Object.entries(st).forEach(([$t,Tt])=>{pt[$t]=normalize$2$1(_objectSpread2({value:Tt},at[$t])).settings,vt=Math.max(vt,pt[$t].step),wt=Math.min(wt,pt[$t].pad)});for(let $t in pt){const{step:Tt,min:Lt,max:Ft}=at[$t]||{};!isFinite(Tt)&&(!isFinite(Lt)||!isFinite(Ft))&&(pt[$t].step=vt,pt[$t].pad=wt)}return pt},_excluded$b=["lock"],_excluded2$5=["value"];function getVectorSchema(st){const at=v8n().array().length(st).every.number(),pt=vt=>{if(!vt||typeof vt!="object")return!1;const wt=Object.values(vt);return wt.length===st&&wt.every($t=>isFinite($t))};return vt=>at.test(vt)||pt(vt)}function getVectorType(st){return Array.isArray(st)?"array":"object"}function convert$1(st,at,pt){return getVectorType(st)===at?st:at==="array"?Object.values(st):mapArrayToKeys(st,pt)}const sanitizeVector=(st,at,pt)=>{const vt=convert$1(st,"object",at.keys);for(let Tt in vt)vt[Tt]=sanitize$3(vt[Tt],at[Tt]);const wt=Object.keys(vt);let $t={};if(wt.length===at.keys.length)$t=vt;else{const Tt=convert$1(pt,"object",at.keys);if(wt.length===1&&at.locked){const Lt=wt[0],Ft=vt[Lt],Ct=Tt[Lt],Ht=Ct!==0?Ft/Ct:1;for(let Gt in Tt)Gt===Lt?$t[Lt]=Ft:$t[Gt]=Tt[Gt]*Ht}else $t=_objectSpread2(_objectSpread2({},Tt),vt)}return convert$1($t,at.format,at.keys)},formatVector=(st,at)=>convert$1(st,"object",at.keys),isNumberSettings=st=>!!st&&("step"in st||"min"in st||"max"in st);function normalizeVector(st,at,pt=[]){const{lock:vt=!1}=at,wt=_objectWithoutProperties$1(at,_excluded$b),$t=Array.isArray(st)?"array":"object",Tt=$t==="object"?Object.keys(st):pt,Lt=convert$1(st,"object",Tt),Ft=isNumberSettings(wt)?Tt.reduce((Ht,Gt)=>Object.assign(Ht,{[Gt]:wt}),{}):wt,Ct=normalizeKeyedNumberSettings(Lt,Ft);return{value:$t==="array"?st:Lt,settings:_objectSpread2(_objectSpread2({},Ct),{},{format:$t,keys:Tt,lock:vt,locked:!1})}}function getVectorPlugin(st){return{schema:getVectorSchema(st.length),normalize:at=>{let{value:pt}=at,vt=_objectWithoutProperties$1(at,_excluded2$5);return normalizeVector(pt,vt,st)},format:(at,pt)=>formatVector(at,pt),sanitize:(at,pt,vt)=>sanitizeVector(at,pt,vt)}}var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(st){return typeof st=="string"?st.length>0:typeof st=="number"},n=function(st,at,pt){return at===void 0&&(at=0),pt===void 0&&(pt=Math.pow(10,at)),Math.round(pt*st)/pt+0},e=function(st,at,pt){return at===void 0&&(at=0),pt===void 0&&(pt=1),st>pt?pt:st>at?st:at},u$1=function(st){return(st=isFinite(st)?st%360:0)>0?st:st+360},a=function(st){return{r:e(st.r,0,255),g:e(st.g,0,255),b:e(st.b,0,255),a:e(st.a)}},o=function(st){return{r:n(st.r),g:n(st.g),b:n(st.b),a:n(st.a,3)}},i$1=/^#([0-9a-f]{3,8})$/i,s$1=function(st){var at=st.toString(16);return at.length<2?"0"+at:at},h$1=function(st){var at=st.r,pt=st.g,vt=st.b,wt=st.a,$t=Math.max(at,pt,vt),Tt=$t-Math.min(at,pt,vt),Lt=Tt?$t===at?(pt-vt)/Tt:$t===pt?2+(vt-at)/Tt:4+(at-pt)/Tt:0;return{h:60*(Lt<0?Lt+6:Lt),s:$t?Tt/$t*100:0,v:$t/255*100,a:wt}},b$1=function(st){var at=st.h,pt=st.s,vt=st.v,wt=st.a;at=at/360*6,pt/=100,vt/=100;var $t=Math.floor(at),Tt=vt*(1-pt),Lt=vt*(1-(at-$t)*pt),Ft=vt*(1-(1-at+$t)*pt),Ct=$t%6;return{r:255*[vt,Lt,Tt,Tt,Ft,vt][Ct],g:255*[Ft,vt,vt,Lt,Tt,Tt][Ct],b:255*[Tt,Tt,Ft,vt,vt,Lt][Ct],a:wt}},g$1=function(st){return{h:u$1(st.h),s:e(st.s,0,100),l:e(st.l,0,100),a:e(st.a)}},d$1=function(st){return{h:n(st.h),s:n(st.s),l:n(st.l),a:n(st.a,3)}},f$1=function(st){return b$1((pt=(at=st).s,{h:at.h,s:(pt*=((vt=at.l)<50?vt:100-vt)/100)>0?2*pt/(vt+pt)*100:0,v:vt+pt,a:at.a}));var at,pt,vt},c$1=function(st){return{h:(at=h$1(st)).h,s:(wt=(200-(pt=at.s))*(vt=at.v)/100)>0&&wt<200?pt*vt/100/(wt<=100?wt:200-wt)*100:0,l:wt/2,a:at.a};var at,pt,vt,wt},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p$1=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v$1=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m$1=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y$1={string:[[function(st){var at=i$1.exec(st);return at?(st=at[1]).length<=4?{r:parseInt(st[0]+st[0],16),g:parseInt(st[1]+st[1],16),b:parseInt(st[2]+st[2],16),a:st.length===4?n(parseInt(st[3]+st[3],16)/255,2):1}:st.length===6||st.length===8?{r:parseInt(st.substr(0,2),16),g:parseInt(st.substr(2,2),16),b:parseInt(st.substr(4,2),16),a:st.length===8?n(parseInt(st.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(st){var at=v$1.exec(st)||m$1.exec(st);return at?at[2]!==at[4]||at[4]!==at[6]?null:a({r:Number(at[1])/(at[2]?100/255:1),g:Number(at[3])/(at[4]?100/255:1),b:Number(at[5])/(at[6]?100/255:1),a:at[7]===void 0?1:Number(at[7])/(at[8]?100:1)}):null},"rgb"],[function(st){var at=l.exec(st)||p$1.exec(st);if(!at)return null;var pt,vt,wt=g$1({h:(pt=at[1],vt=at[2],vt===void 0&&(vt="deg"),Number(pt)*(r[vt]||1)),s:Number(at[3]),l:Number(at[4]),a:at[5]===void 0?1:Number(at[5])/(at[6]?100:1)});return f$1(wt)},"hsl"]],object:[[function(st){var at=st.r,pt=st.g,vt=st.b,wt=st.a,$t=wt===void 0?1:wt;return t(at)&&t(pt)&&t(vt)?a({r:Number(at),g:Number(pt),b:Number(vt),a:Number($t)}):null},"rgb"],[function(st){var at=st.h,pt=st.s,vt=st.l,wt=st.a,$t=wt===void 0?1:wt;if(!t(at)||!t(pt)||!t(vt))return null;var Tt=g$1({h:Number(at),s:Number(pt),l:Number(vt),a:Number($t)});return f$1(Tt)},"hsl"],[function(st){var at=st.h,pt=st.s,vt=st.v,wt=st.a,$t=wt===void 0?1:wt;if(!t(at)||!t(pt)||!t(vt))return null;var Tt=function(Lt){return{h:u$1(Lt.h),s:e(Lt.s,0,100),v:e(Lt.v,0,100),a:e(Lt.a)}}({h:Number(at),s:Number(pt),v:Number(vt),a:Number($t)});return b$1(Tt)},"hsv"]]},N=function(st,at){for(var pt=0;pt<at.length;pt++){var vt=at[pt][0](st);if(vt)return[vt,at[pt][1]]}return[null,void 0]},x=function(st){return typeof st=="string"?N(st.trim(),y$1.string):typeof st=="object"&&st!==null?N(st,y$1.object):[null,void 0]},I$1=function(st){return x(st)[1]},M$1=function(st,at){var pt=c$1(st);return{h:pt.h,s:e(pt.s+100*at,0,100),l:pt.l,a:pt.a}},H$1=function(st){return(299*st.r+587*st.g+114*st.b)/1e3/255},$$1=function(st,at){var pt=c$1(st);return{h:pt.h,s:pt.s,l:e(pt.l+100*at,0,100),a:pt.a}},j$1=function(){function st(at){this.parsed=x(at)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return st.prototype.isValid=function(){return this.parsed!==null},st.prototype.brightness=function(){return n(H$1(this.rgba),2)},st.prototype.isDark=function(){return H$1(this.rgba)<.5},st.prototype.isLight=function(){return H$1(this.rgba)>=.5},st.prototype.toHex=function(){return at=o(this.rgba),pt=at.r,vt=at.g,wt=at.b,Tt=($t=at.a)<1?s$1(n(255*$t)):"","#"+s$1(pt)+s$1(vt)+s$1(wt)+Tt;var at,pt,vt,wt,$t,Tt},st.prototype.toRgb=function(){return o(this.rgba)},st.prototype.toRgbString=function(){return at=o(this.rgba),pt=at.r,vt=at.g,wt=at.b,($t=at.a)<1?"rgba("+pt+", "+vt+", "+wt+", "+$t+")":"rgb("+pt+", "+vt+", "+wt+")";var at,pt,vt,wt,$t},st.prototype.toHsl=function(){return d$1(c$1(this.rgba))},st.prototype.toHslString=function(){return at=d$1(c$1(this.rgba)),pt=at.h,vt=at.s,wt=at.l,($t=at.a)<1?"hsla("+pt+", "+vt+"%, "+wt+"%, "+$t+")":"hsl("+pt+", "+vt+"%, "+wt+"%)";var at,pt,vt,wt,$t},st.prototype.toHsv=function(){return at=h$1(this.rgba),{h:n(at.h),s:n(at.s),v:n(at.v),a:n(at.a,3)};var at},st.prototype.invert=function(){return w({r:255-(at=this.rgba).r,g:255-at.g,b:255-at.b,a:at.a});var at},st.prototype.saturate=function(at){return at===void 0&&(at=.1),w(M$1(this.rgba,at))},st.prototype.desaturate=function(at){return at===void 0&&(at=.1),w(M$1(this.rgba,-at))},st.prototype.grayscale=function(){return w(M$1(this.rgba,-1))},st.prototype.lighten=function(at){return at===void 0&&(at=.1),w($$1(this.rgba,at))},st.prototype.darken=function(at){return at===void 0&&(at=.1),w($$1(this.rgba,-at))},st.prototype.rotate=function(at){return at===void 0&&(at=15),this.hue(this.hue()+at)},st.prototype.alpha=function(at){return typeof at=="number"?w({r:(pt=this.rgba).r,g:pt.g,b:pt.b,a:at}):n(this.rgba.a,3);var pt},st.prototype.hue=function(at){var pt=c$1(this.rgba);return typeof at=="number"?w({h:at,s:pt.s,l:pt.l,a:pt.a}):n(pt.h)},st.prototype.isEqual=function(at){return this.toHex()===w(at).toHex()},st}(),w=function(st){return st instanceof j$1?st:new j$1(st)},S$1=[],k$1=function(st){st.forEach(function(at){S$1.indexOf(at)<0&&(at(j$1,y$1),S$1.push(at))})};function namesPlugin(st,at){var pt={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},vt={};for(var wt in pt)vt[pt[wt]]=wt;var $t={};st.prototype.toName=function(Tt){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var Lt,Ft,Ct=vt[this.toHex()];if(Ct)return Ct;if(Tt!=null&&Tt.closest){var Ht=this.toRgb(),Gt=1/0,jt="black";if(!$t.length)for(var qt in pt)$t[qt]=new st(pt[qt]).toRgb();for(var Kt in pt){var An=(Lt=Ht,Ft=$t[Kt],Math.pow(Lt.r-Ft.r,2)+Math.pow(Lt.g-Ft.g,2)+Math.pow(Lt.b-Ft.b,2));An<Gt&&(Gt=An,jt=Kt)}return jt}},at.string.push([function(Tt){var Lt=Tt.toLowerCase(),Ft=Lt==="transparent"?"#0000":pt[Lt];return Ft?new st(Ft).toRgb():null},"name"])}function u(){return(u=Object.assign||function(st){for(var at=1;at<arguments.length;at++){var pt=arguments[at];for(var vt in pt)Object.prototype.hasOwnProperty.call(pt,vt)&&(st[vt]=pt[vt])}return st}).apply(this,arguments)}function c(st,at){if(st==null)return{};var pt,vt,wt={},$t=Object.keys(st);for(vt=0;vt<$t.length;vt++)at.indexOf(pt=$t[vt])>=0||(wt[pt]=st[pt]);return wt}function i(st){var at=reactExports.useRef(st),pt=reactExports.useRef(function(vt){at.current&&at.current(vt)});return at.current=st,pt.current}var s=function(st,at,pt){return at===void 0&&(at=0),pt===void 0&&(pt=1),st>pt?pt:st<at?at:st},f=function(st){return"touches"in st},v=function(st){return st&&st.ownerDocument.defaultView||self},d=function(st,at,pt){var vt=st.getBoundingClientRect(),wt=f(at)?function($t,Tt){for(var Lt=0;Lt<$t.length;Lt++)if($t[Lt].identifier===Tt)return $t[Lt];return $t[0]}(at.touches,pt):at;return{left:s((wt.pageX-(vt.left+v(st).pageXOffset))/vt.width),top:s((wt.pageY-(vt.top+v(st).pageYOffset))/vt.height)}},h=function(st){!f(st)&&st.preventDefault()},m=React.memo(function(st){var at=st.onMove,pt=st.onKey,vt=c(st,["onMove","onKey"]),wt=reactExports.useRef(null),$t=i(at),Tt=i(pt),Lt=reactExports.useRef(null),Ft=reactExports.useRef(!1),Ct=reactExports.useMemo(function(){var qt=function(Sn){h(Sn),(f(Sn)?Sn.touches.length>0:Sn.buttons>0)&&wt.current?$t(d(wt.current,Sn,Lt.current)):An(!1)},Kt=function(){return An(!1)};function An(Sn){var wn=Ft.current,In=v(wt.current),tr=Sn?In.addEventListener:In.removeEventListener;tr(wn?"touchmove":"mousemove",qt),tr(wn?"touchend":"mouseup",Kt)}return[function(Sn){var wn=Sn.nativeEvent,In=wt.current;if(In&&(h(wn),!function(rr,Hr){return Hr&&!f(rr)}(wn,Ft.current)&&In)){if(f(wn)){Ft.current=!0;var tr=wn.changedTouches||[];tr.length&&(Lt.current=tr[0].identifier)}In.focus(),$t(d(In,wn,Lt.current)),An(!0)}},function(Sn){var wn=Sn.which||Sn.keyCode;wn<37||wn>40||(Sn.preventDefault(),Tt({left:wn===39?.05:wn===37?-.05:0,top:wn===40?.05:wn===38?-.05:0}))},An]},[Tt,$t]),Ht=Ct[0],Gt=Ct[1],jt=Ct[2];return reactExports.useEffect(function(){return jt},[jt]),React.createElement("div",u({},vt,{onTouchStart:Ht,onMouseDown:Ht,className:"react-colorful__interactive",ref:wt,onKeyDown:Gt,tabIndex:0,role:"slider"}))}),g=function(st){return st.filter(Boolean).join(" ")},p=function(st){var at=st.color,pt=st.left,vt=st.top,wt=vt===void 0?.5:vt,$t=g(["react-colorful__pointer",st.className]);return React.createElement("div",{className:$t,style:{top:100*wt+"%",left:100*pt+"%"}},React.createElement("div",{className:"react-colorful__pointer-fill",style:{backgroundColor:at}}))},b=function(st,at,pt){return at===void 0&&(at=0),pt===void 0&&(pt=Math.pow(10,at)),Math.round(pt*st)/pt},y=function(st){var at=st.s,pt=st.v,vt=st.a,wt=(200-at)*pt/100;return{h:b(st.h),s:b(wt>0&&wt<200?at*pt/100/(wt<=100?wt:200-wt)*100:0),l:b(wt/2),a:b(vt,2)}},q=function(st){var at=y(st);return"hsl("+at.h+", "+at.s+"%, "+at.l+"%)"},k=function(st){var at=y(st);return"hsla("+at.h+", "+at.s+"%, "+at.l+"%, "+at.a+")"},I=function(st){var at=st.h,pt=st.s,vt=st.v,wt=st.a;at=at/360*6,pt/=100,vt/=100;var $t=Math.floor(at),Tt=vt*(1-pt),Lt=vt*(1-(at-$t)*pt),Ft=vt*(1-(1-at+$t)*pt),Ct=$t%6;return{r:b(255*[vt,Lt,Tt,Tt,Ft,vt][Ct]),g:b(255*[Ft,vt,vt,Lt,Tt,Tt][Ct]),b:b(255*[Tt,Tt,Ft,vt,vt,Lt][Ct]),a:b(wt,2)}},L$1=function(st){var at=st.r,pt=st.g,vt=st.b,wt=st.a,$t=Math.max(at,pt,vt),Tt=$t-Math.min(at,pt,vt),Lt=Tt?$t===at?(pt-vt)/Tt:$t===pt?2+(vt-at)/Tt:4+(at-pt)/Tt:0;return{h:b(60*(Lt<0?Lt+6:Lt)),s:b($t?Tt/$t*100:0),v:b($t/255*100),a:wt}},S=React.memo(function(st){var at=st.hue,pt=st.onChange,vt=g(["react-colorful__hue",st.className]);return React.createElement("div",{className:vt},React.createElement(m,{onMove:function(wt){pt({h:360*wt.left})},onKey:function(wt){pt({h:s(at+360*wt.left,0,360)})},"aria-label":"Hue","aria-valuenow":b(at),"aria-valuemax":"360","aria-valuemin":"0"},React.createElement(p,{className:"react-colorful__hue-pointer",left:at/360,color:q({h:at,s:100,v:100,a:1})})))}),T=React.memo(function(st){var at=st.hsva,pt=st.onChange,vt={backgroundColor:q({h:at.h,s:100,v:100,a:1})};return React.createElement("div",{className:"react-colorful__saturation",style:vt},React.createElement(m,{onMove:function(wt){pt({s:100*wt.left,v:100-100*wt.top})},onKey:function(wt){pt({s:s(at.s+100*wt.left,0,100),v:s(at.v-100*wt.top,0,100)})},"aria-label":"Color","aria-valuetext":"Saturation "+b(at.s)+"%, Brightness "+b(at.v)+"%"},React.createElement(p,{className:"react-colorful__saturation-pointer",top:1-at.v/100,left:at.s/100,color:q(at)})))}),F=function(st,at){if(st===at)return!0;for(var pt in st)if(st[pt]!==at[pt])return!1;return!0};function Y(st,at,pt){var vt=i(pt),wt=reactExports.useState(function(){return st.toHsva(at)}),$t=wt[0],Tt=wt[1],Lt=reactExports.useRef({color:at,hsva:$t});reactExports.useEffect(function(){if(!st.equal(at,Lt.current.color)){var Ct=st.toHsva(at);Lt.current={hsva:Ct,color:at},Tt(Ct)}},[at,st]),reactExports.useEffect(function(){var Ct;F($t,Lt.current.hsva)||st.equal(Ct=st.fromHsva($t),Lt.current.color)||(Lt.current={hsva:$t,color:Ct},vt(Ct))},[$t,st,vt]);var Ft=reactExports.useCallback(function(Ct){Tt(function(Ht){return Object.assign({},Ht,Ct)})},[]);return[$t,Ft]}var V$1=typeof window<"u"?reactExports.useLayoutEffect:reactExports.useEffect,$=function(){return typeof __webpack_nonce__<"u"?__webpack_nonce__:void 0},J=new Map,Q$1=function(st){V$1(function(){var at=st.current?st.current.ownerDocument:document;if(at!==void 0&&!J.has(at)){var pt=at.createElement("style");pt.innerHTML=`.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}`,J.set(at,pt);var vt=$();vt&&pt.setAttribute("nonce",vt),at.head.appendChild(pt)}},[])},U$2=function(st){var at=st.className,pt=st.colorModel,vt=st.color,wt=vt===void 0?pt.defaultColor:vt,$t=st.onChange,Tt=c(st,["className","colorModel","color","onChange"]),Lt=reactExports.useRef(null);Q$1(Lt);var Ft=Y(pt,wt,$t),Ct=Ft[0],Ht=Ft[1],Gt=g(["react-colorful",at]);return React.createElement("div",u({},Tt,{ref:Lt,className:Gt}),React.createElement(T,{hsva:Ct,onChange:Ht}),React.createElement(S,{hue:Ct.h,onChange:Ht,className:"react-colorful__last-control"}))},ee=function(st){var at=st.className,pt=st.hsva,vt=st.onChange,wt={backgroundImage:"linear-gradient(90deg, "+k(Object.assign({},pt,{a:0}))+", "+k(Object.assign({},pt,{a:1}))+")"},$t=g(["react-colorful__alpha",at]),Tt=b(100*pt.a);return React.createElement("div",{className:$t},React.createElement("div",{className:"react-colorful__alpha-gradient",style:wt}),React.createElement(m,{onMove:function(Lt){vt({a:Lt.left})},onKey:function(Lt){vt({a:s(pt.a+Lt.left)})},"aria-label":"Alpha","aria-valuetext":Tt+"%","aria-valuenow":Tt,"aria-valuemin":"0","aria-valuemax":"100"},React.createElement(p,{className:"react-colorful__alpha-pointer",left:pt.a,color:k(pt)})))},re=function(st){var at=st.className,pt=st.colorModel,vt=st.color,wt=vt===void 0?pt.defaultColor:vt,$t=st.onChange,Tt=c(st,["className","colorModel","color","onChange"]),Lt=reactExports.useRef(null);Q$1(Lt);var Ft=Y(pt,wt,$t),Ct=Ft[0],Ht=Ft[1],Gt=g(["react-colorful",at]);return React.createElement("div",u({},Tt,{ref:Lt,className:Gt}),React.createElement(T,{hsva:Ct,onChange:Ht}),React.createElement(S,{hue:Ct.h,onChange:Ht}),React.createElement(ee,{hsva:Ct,onChange:Ht,className:"react-colorful__last-control"}))},xe$1={defaultColor:{r:0,g:0,b:0,a:1},toHsva:L$1,fromHsva:I,equal:F},Ce=function(st){return React.createElement(re,u({},st,{colorModel:xe$1}))},Me$1={defaultColor:{r:0,g:0,b:0},toHsva:function(st){return L$1({r:st.r,g:st.g,b:st.b,a:1})},fromHsva:function(st){return{r:(at=I(st)).r,g:at.g,b:at.b};var at},equal:F},Ne$1=function(st){return React.createElement(U$2,u({},st,{colorModel:Me$1}))};function __awaiter(st,at,pt,vt){function wt($t){return $t instanceof pt?$t:new pt(function(Tt){Tt($t)})}return new(pt||(pt=Promise))(function($t,Tt){function Lt(Ht){try{Ct(vt.next(Ht))}catch(Gt){Tt(Gt)}}function Ft(Ht){try{Ct(vt.throw(Ht))}catch(Gt){Tt(Gt)}}function Ct(Ht){Ht.done?$t(Ht.value):wt(Ht.value).then(Lt,Ft)}Ct((vt=vt.apply(st,at||[])).next())})}function __generator(st,at){var pt={label:0,sent:function(){if($t[0]&1)throw $t[1];return $t[1]},trys:[],ops:[]},vt,wt,$t,Tt;return Tt={next:Lt(0),throw:Lt(1),return:Lt(2)},typeof Symbol=="function"&&(Tt[Symbol.iterator]=function(){return this}),Tt;function Lt(Ct){return function(Ht){return Ft([Ct,Ht])}}function Ft(Ct){if(vt)throw new TypeError("Generator is already executing.");for(;Tt&&(Tt=0,Ct[0]&&(pt=0)),pt;)try{if(vt=1,wt&&($t=Ct[0]&2?wt.return:Ct[0]?wt.throw||(($t=wt.return)&&$t.call(wt),0):wt.next)&&!($t=$t.call(wt,Ct[1])).done)return $t;switch(wt=0,$t&&(Ct=[Ct[0]&2,$t.value]),Ct[0]){case 0:case 1:$t=Ct;break;case 4:return pt.label++,{value:Ct[1],done:!1};case 5:pt.label++,wt=Ct[1],Ct=[0];continue;case 7:Ct=pt.ops.pop(),pt.trys.pop();continue;default:if($t=pt.trys,!($t=$t.length>0&&$t[$t.length-1])&&(Ct[0]===6||Ct[0]===2)){pt=0;continue}if(Ct[0]===3&&(!$t||Ct[1]>$t[0]&&Ct[1]<$t[3])){pt.label=Ct[1];break}if(Ct[0]===6&&pt.label<$t[1]){pt.label=$t[1],$t=Ct;break}if($t&&pt.label<$t[2]){pt.label=$t[2],pt.ops.push(Ct);break}$t[2]&&pt.ops.pop(),pt.trys.pop();continue}Ct=at.call(st,pt)}catch(Ht){Ct=[6,Ht],wt=0}finally{vt=$t=0}if(Ct[0]&5)throw Ct[1];return{value:Ct[0]?Ct[1]:void 0,done:!0}}}function __read(st,at){var pt=typeof Symbol=="function"&&st[Symbol.iterator];if(!pt)return st;var vt=pt.call(st),wt,$t=[],Tt;try{for(;(at===void 0||at-- >0)&&!(wt=vt.next()).done;)$t.push(wt.value)}catch(Lt){Tt={error:Lt}}finally{try{wt&&!wt.done&&(pt=vt.return)&&pt.call(vt)}finally{if(Tt)throw Tt.error}}return $t}function __spread(){for(var st=[],at=0;at<arguments.length;at++)st=st.concat(__read(arguments[at]));return st}typeof SuppressedError=="function"&&SuppressedError;var COMMON_MIME_TYPES=new Map([["aac","audio/aac"],["abw","application/x-abiword"],["arc","application/x-freearc"],["avif","image/avif"],["avi","video/x-msvideo"],["azw","application/vnd.amazon.ebook"],["bin","application/octet-stream"],["bmp","image/bmp"],["bz","application/x-bzip"],["bz2","application/x-bzip2"],["cda","application/x-cdf"],["csh","application/x-csh"],["css","text/css"],["csv","text/csv"],["doc","application/msword"],["docx","application/vnd.openxmlformats-officedocument.wordprocessingml.document"],["eot","application/vnd.ms-fontobject"],["epub","application/epub+zip"],["gz","application/gzip"],["gif","image/gif"],["heic","image/heic"],["heif","image/heif"],["htm","text/html"],["html","text/html"],["ico","image/vnd.microsoft.icon"],["ics","text/calendar"],["jar","application/java-archive"],["jpeg","image/jpeg"],["jpg","image/jpeg"],["js","text/javascript"],["json","application/json"],["jsonld","application/ld+json"],["mid","audio/midi"],["midi","audio/midi"],["mjs","text/javascript"],["mp3","audio/mpeg"],["mp4","video/mp4"],["mpeg","video/mpeg"],["mpkg","application/vnd.apple.installer+xml"],["odp","application/vnd.oasis.opendocument.presentation"],["ods","application/vnd.oasis.opendocument.spreadsheet"],["odt","application/vnd.oasis.opendocument.text"],["oga","audio/ogg"],["ogv","video/ogg"],["ogx","application/ogg"],["opus","audio/opus"],["otf","font/otf"],["png","image/png"],["pdf","application/pdf"],["php","application/x-httpd-php"],["ppt","application/vnd.ms-powerpoint"],["pptx","application/vnd.openxmlformats-officedocument.presentationml.presentation"],["rar","application/vnd.rar"],["rtf","application/rtf"],["sh","application/x-sh"],["svg","image/svg+xml"],["swf","application/x-shockwave-flash"],["tar","application/x-tar"],["tif","image/tiff"],["tiff","image/tiff"],["ts","video/mp2t"],["ttf","font/ttf"],["txt","text/plain"],["vsd","application/vnd.visio"],["wav","audio/wav"],["weba","audio/webm"],["webm","video/webm"],["webp","image/webp"],["woff","font/woff"],["woff2","font/woff2"],["xhtml","application/xhtml+xml"],["xls","application/vnd.ms-excel"],["xlsx","application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],["xml","application/xml"],["xul","application/vnd.mozilla.xul+xml"],["zip","application/zip"],["7z","application/x-7z-compressed"],["mkv","video/x-matroska"],["mov","video/quicktime"],["msg","application/vnd.ms-outlook"]]);function toFileWithPath(st,at){var pt=withMimeType(st);if(typeof pt.path!="string"){var vt=st.webkitRelativePath;Object.defineProperty(pt,"path",{value:typeof at=="string"?at:typeof vt=="string"&&vt.length>0?vt:st.name,writable:!1,configurable:!1,enumerable:!0})}return pt}function withMimeType(st){var at=st.name,pt=at&&at.lastIndexOf(".")!==-1;if(pt&&!st.type){var vt=at.split(".").pop().toLowerCase(),wt=COMMON_MIME_TYPES.get(vt);wt&&Object.defineProperty(st,"type",{value:wt,writable:!1,configurable:!1,enumerable:!0})}return st}var FILES_TO_IGNORE=[".DS_Store","Thumbs.db"];function fromEvent(st){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(at){return isObject$7(st)&&isDataTransfer(st)?[2,getDataTransferFiles(st.dataTransfer,st.type)]:isChangeEvt(st)?[2,getInputFiles(st)]:Array.isArray(st)&&st.every(function(pt){return"getFile"in pt&&typeof pt.getFile=="function"})?[2,getFsHandleFiles(st)]:[2,[]]})})}function isDataTransfer(st){return isObject$7(st.dataTransfer)}function isChangeEvt(st){return isObject$7(st)&&isObject$7(st.target)}function isObject$7(st){return typeof st=="object"&&st!==null}function getInputFiles(st){return fromList(st.target.files).map(function(at){return toFileWithPath(at)})}function getFsHandleFiles(st){return __awaiter(this,void 0,void 0,function(){var at;return __generator(this,function(pt){switch(pt.label){case 0:return[4,Promise.all(st.map(function(vt){return vt.getFile()}))];case 1:return at=pt.sent(),[2,at.map(function(vt){return toFileWithPath(vt)})]}})})}function getDataTransferFiles(st,at){return __awaiter(this,void 0,void 0,function(){var pt,vt;return __generator(this,function(wt){switch(wt.label){case 0:return st===null?[2,[]]:st.items?(pt=fromList(st.items).filter(function($t){return $t.kind==="file"}),at!=="drop"?[2,pt]:[4,Promise.all(pt.map(toFilePromises))]):[3,2];case 1:return vt=wt.sent(),[2,noIgnoredFiles(flatten(vt))];case 2:return[2,noIgnoredFiles(fromList(st.files).map(function($t){return toFileWithPath($t)}))]}})})}function noIgnoredFiles(st){return st.filter(function(at){return FILES_TO_IGNORE.indexOf(at.name)===-1})}function fromList(st){if(st===null)return[];for(var at=[],pt=0;pt<st.length;pt++){var vt=st[pt];at.push(vt)}return at}function toFilePromises(st){if(typeof st.webkitGetAsEntry!="function")return fromDataTransferItem(st);var at=st.webkitGetAsEntry();return at&&at.isDirectory?fromDirEntry(at):fromDataTransferItem(st)}function flatten(st){return st.reduce(function(at,pt){return __spread(at,Array.isArray(pt)?flatten(pt):[pt])},[])}function fromDataTransferItem(st){var at=st.getAsFile();if(!at)return Promise.reject(st+" is not a File");var pt=toFileWithPath(at);return Promise.resolve(pt)}function fromEntry(st){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(at){return[2,st.isDirectory?fromDirEntry(st):fromFileEntry(st)]})})}function fromDirEntry(st){var at=st.createReader();return new Promise(function(pt,vt){var wt=[];function $t(){var Tt=this;at.readEntries(function(Lt){return __awaiter(Tt,void 0,void 0,function(){var Ft,Ct,Ht;return __generator(this,function(Gt){switch(Gt.label){case 0:if(Lt.length)return[3,5];Gt.label=1;case 1:return Gt.trys.push([1,3,,4]),[4,Promise.all(wt)];case 2:return Ft=Gt.sent(),pt(Ft),[3,4];case 3:return Ct=Gt.sent(),vt(Ct),[3,4];case 4:return[3,6];case 5:Ht=Promise.all(Lt.map(fromEntry)),wt.push(Ht),$t(),Gt.label=6;case 6:return[2]}})})},function(Lt){vt(Lt)})}$t()})}function fromFileEntry(st){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(at){return[2,new Promise(function(pt,vt){st.file(function(wt){var $t=toFileWithPath(wt,st.fullPath);pt($t)},function(wt){vt(wt)})})]})})}var _default=function(st,at){if(st&&at){var pt=Array.isArray(at)?at:at.split(","),vt=st.name||"",wt=(st.type||"").toLowerCase(),$t=wt.replace(/\/.*$/,"");return pt.some(function(Tt){var Lt=Tt.trim().toLowerCase();return Lt.charAt(0)==="."?vt.toLowerCase().endsWith(Lt):Lt.endsWith("/*")?$t===Lt.replace(/\/.*$/,""):wt===Lt})}return!0};function ownKeys$1(st,at){var pt=Object.keys(st);if(Object.getOwnPropertySymbols){var vt=Object.getOwnPropertySymbols(st);at&&(vt=vt.filter(function(wt){return Object.getOwnPropertyDescriptor(st,wt).enumerable})),pt.push.apply(pt,vt)}return pt}function _objectSpread$1(st){for(var at=1;at<arguments.length;at++){var pt=arguments[at]!=null?arguments[at]:{};at%2?ownKeys$1(Object(pt),!0).forEach(function(vt){_defineProperty$1(st,vt,pt[vt])}):Object.getOwnPropertyDescriptors?Object.defineProperties(st,Object.getOwnPropertyDescriptors(pt)):ownKeys$1(Object(pt)).forEach(function(vt){Object.defineProperty(st,vt,Object.getOwnPropertyDescriptor(pt,vt))})}return st}function _defineProperty$1(st,at,pt){return at in st?Object.defineProperty(st,at,{value:pt,enumerable:!0,configurable:!0,writable:!0}):st[at]=pt,st}function _slicedToArray$1(st,at){return _arrayWithHoles$1(st)||_iterableToArrayLimit$1(st,at)||_unsupportedIterableToArray$1(st,at)||_nonIterableRest$1()}function _nonIterableRest$1(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _unsupportedIterableToArray$1(st,at){if(st){if(typeof st=="string")return _arrayLikeToArray$1(st,at);var pt=Object.prototype.toString.call(st).slice(8,-1);if(pt==="Object"&&st.constructor&&(pt=st.constructor.name),pt==="Map"||pt==="Set")return Array.from(st);if(pt==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(pt))return _arrayLikeToArray$1(st,at)}}function _arrayLikeToArray$1(st,at){(at==null||at>st.length)&&(at=st.length);for(var pt=0,vt=new Array(at);pt<at;pt++)vt[pt]=st[pt];return vt}function _iterableToArrayLimit$1(st,at){var pt=st==null?null:typeof Symbol<"u"&&st[Symbol.iterator]||st["@@iterator"];if(pt!=null){var vt=[],wt=!0,$t=!1,Tt,Lt;try{for(pt=pt.call(st);!(wt=(Tt=pt.next()).done)&&(vt.push(Tt.value),!(at&&vt.length===at));wt=!0);}catch(Ft){$t=!0,Lt=Ft}finally{try{!wt&&pt.return!=null&&pt.return()}finally{if($t)throw Lt}}return vt}}function _arrayWithHoles$1(st){if(Array.isArray(st))return st}var FILE_INVALID_TYPE="file-invalid-type",FILE_TOO_LARGE="file-too-large",FILE_TOO_SMALL="file-too-small",TOO_MANY_FILES="too-many-files",getInvalidTypeRejectionErr=function(at){at=Array.isArray(at)&&at.length===1?at[0]:at;var pt=Array.isArray(at)?"one of ".concat(at.join(", ")):at;return{code:FILE_INVALID_TYPE,message:"File type must be ".concat(pt)}},getTooLargeRejectionErr=function(at){return{code:FILE_TOO_LARGE,message:"File is larger than ".concat(at," ").concat(at===1?"byte":"bytes")}},getTooSmallRejectionErr=function(at){return{code:FILE_TOO_SMALL,message:"File is smaller than ".concat(at," ").concat(at===1?"byte":"bytes")}},TOO_MANY_FILES_REJECTION={code:TOO_MANY_FILES,message:"Too many files"};function fileAccepted(st,at){var pt=st.type==="application/x-moz-file"||_default(st,at);return[pt,pt?null:getInvalidTypeRejectionErr(at)]}function fileMatchSize(st,at,pt){if(isDefined(st.size))if(isDefined(at)&&isDefined(pt)){if(st.size>pt)return[!1,getTooLargeRejectionErr(pt)];if(st.size<at)return[!1,getTooSmallRejectionErr(at)]}else{if(isDefined(at)&&st.size<at)return[!1,getTooSmallRejectionErr(at)];if(isDefined(pt)&&st.size>pt)return[!1,getTooLargeRejectionErr(pt)]}return[!0,null]}function isDefined(st){return st!=null}function allFilesAccepted(st){var at=st.files,pt=st.accept,vt=st.minSize,wt=st.maxSize,$t=st.multiple,Tt=st.maxFiles;return!$t&&at.length>1||$t&&Tt>=1&&at.length>Tt?!1:at.every(function(Lt){var Ft=fileAccepted(Lt,pt),Ct=_slicedToArray$1(Ft,1),Ht=Ct[0],Gt=fileMatchSize(Lt,vt,wt),jt=_slicedToArray$1(Gt,1),qt=jt[0];return Ht&&qt})}function isPropagationStopped(st){return typeof st.isPropagationStopped=="function"?st.isPropagationStopped():typeof st.cancelBubble<"u"?st.cancelBubble:!1}function isEvtWithFiles(st){return st.dataTransfer?Array.prototype.some.call(st.dataTransfer.types,function(at){return at==="Files"||at==="application/x-moz-file"}):!!st.target&&!!st.target.files}function onDocumentDragOver(st){st.preventDefault()}function isIe(st){return st.indexOf("MSIE")!==-1||st.indexOf("Trident/")!==-1}function isEdge(st){return st.indexOf("Edge/")!==-1}function isIeOrEdge(){var st=arguments.length>0&&arguments[0]!==void 0?arguments[0]:window.navigator.userAgent;return isIe(st)||isEdge(st)}function composeEventHandlers(){for(var st=arguments.length,at=new Array(st),pt=0;pt<st;pt++)at[pt]=arguments[pt];return function(vt){for(var wt=arguments.length,$t=new Array(wt>1?wt-1:0),Tt=1;Tt<wt;Tt++)$t[Tt-1]=arguments[Tt];return at.some(function(Lt){return!isPropagationStopped(vt)&&Lt&&Lt.apply(void 0,[vt].concat($t)),isPropagationStopped(vt)})}}function canUseFileSystemAccessAPI(){return"showOpenFilePicker"in window}function filePickerOptionsTypes(st){return st=typeof st=="string"?st.split(","):st,[{description:"everything",accept:Array.isArray(st)?st.filter(function(at){return at==="audio/*"||at==="video/*"||at==="image/*"||at==="text/*"||/\w+\/[-+.\w]+/g.test(at)}).reduce(function(at,pt){return _objectSpread$1(_objectSpread$1({},at),{},_defineProperty$1({},pt,[]))},{}):{}}]}function isAbort(st){return st instanceof DOMException&&(st.name==="AbortError"||st.code===st.ABORT_ERR)}function isSecurityError(st){return st instanceof DOMException&&(st.name==="SecurityError"||st.code===st.SECURITY_ERR)}var _excluded=["children"],_excluded2$2=["open"],_excluded3=["refKey","role","onKeyDown","onFocus","onBlur","onClick","onDragEnter","onDragOver","onDragLeave","onDrop"],_excluded4=["refKey","onChange","onClick"];function _toConsumableArray(st){return _arrayWithoutHoles(st)||_iterableToArray(st)||_unsupportedIterableToArray(st)||_nonIterableSpread()}function _nonIterableSpread(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _iterableToArray(st){if(typeof Symbol<"u"&&st[Symbol.iterator]!=null||st["@@iterator"]!=null)return Array.from(st)}function _arrayWithoutHoles(st){if(Array.isArray(st))return _arrayLikeToArray(st)}function _slicedToArray(st,at){return _arrayWithHoles(st)||_iterableToArrayLimit(st,at)||_unsupportedIterableToArray(st,at)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function _unsupportedIterableToArray(st,at){if(st){if(typeof st=="string")return _arrayLikeToArray(st,at);var pt=Object.prototype.toString.call(st).slice(8,-1);if(pt==="Object"&&st.constructor&&(pt=st.constructor.name),pt==="Map"||pt==="Set")return Array.from(st);if(pt==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(pt))return _arrayLikeToArray(st,at)}}function _arrayLikeToArray(st,at){(at==null||at>st.length)&&(at=st.length);for(var pt=0,vt=new Array(at);pt<at;pt++)vt[pt]=st[pt];return vt}function _iterableToArrayLimit(st,at){var pt=st==null?null:typeof Symbol<"u"&&st[Symbol.iterator]||st["@@iterator"];if(pt!=null){var vt=[],wt=!0,$t=!1,Tt,Lt;try{for(pt=pt.call(st);!(wt=(Tt=pt.next()).done)&&(vt.push(Tt.value),!(at&&vt.length===at));wt=!0);}catch(Ft){$t=!0,Lt=Ft}finally{try{!wt&&pt.return!=null&&pt.return()}finally{if($t)throw Lt}}return vt}}function _arrayWithHoles(st){if(Array.isArray(st))return st}function ownKeys(st,at){var pt=Object.keys(st);if(Object.getOwnPropertySymbols){var vt=Object.getOwnPropertySymbols(st);at&&(vt=vt.filter(function(wt){return Object.getOwnPropertyDescriptor(st,wt).enumerable})),pt.push.apply(pt,vt)}return pt}function _objectSpread(st){for(var at=1;at<arguments.length;at++){var pt=arguments[at]!=null?arguments[at]:{};at%2?ownKeys(Object(pt),!0).forEach(function(vt){_defineProperty(st,vt,pt[vt])}):Object.getOwnPropertyDescriptors?Object.defineProperties(st,Object.getOwnPropertyDescriptors(pt)):ownKeys(Object(pt)).forEach(function(vt){Object.defineProperty(st,vt,Object.getOwnPropertyDescriptor(pt,vt))})}return st}function _defineProperty(st,at,pt){return at in st?Object.defineProperty(st,at,{value:pt,enumerable:!0,configurable:!0,writable:!0}):st[at]=pt,st}function _objectWithoutProperties(st,at){if(st==null)return{};var pt=_objectWithoutPropertiesLoose(st,at),vt,wt;if(Object.getOwnPropertySymbols){var $t=Object.getOwnPropertySymbols(st);for(wt=0;wt<$t.length;wt++)vt=$t[wt],!(at.indexOf(vt)>=0)&&Object.prototype.propertyIsEnumerable.call(st,vt)&&(pt[vt]=st[vt])}return pt}function _objectWithoutPropertiesLoose(st,at){if(st==null)return{};var pt={},vt=Object.keys(st),wt,$t;for($t=0;$t<vt.length;$t++)wt=vt[$t],!(at.indexOf(wt)>=0)&&(pt[wt]=st[wt]);return pt}var Dropzone=reactExports.forwardRef(function(st,at){var pt=st.children,vt=_objectWithoutProperties(st,_excluded),wt=useDropzone(vt),$t=wt.open,Tt=_objectWithoutProperties(wt,_excluded2$2);return reactExports.useImperativeHandle(at,function(){return{open:$t}},[$t]),React.createElement(reactExports.Fragment,null,pt(_objectSpread(_objectSpread({},Tt),{},{open:$t})))});Dropzone.displayName="Dropzone";var defaultProps={disabled:!1,getFilesFromEvent:fromEvent,maxSize:1/0,minSize:0,multiple:!0,maxFiles:0,preventDropOnDocument:!0,noClick:!1,noKeyboard:!1,noDrag:!1,noDragEventsBubbling:!1,validator:null,useFsAccessApi:!0};Dropzone.defaultProps=defaultProps;Dropzone.propTypes={children:PropTypes.func,accept:PropTypes.oneOfType([PropTypes.string,PropTypes.arrayOf(PropTypes.string)]),multiple:PropTypes.bool,preventDropOnDocument:PropTypes.bool,noClick:PropTypes.bool,noKeyboard:PropTypes.bool,noDrag:PropTypes.bool,noDragEventsBubbling:PropTypes.bool,minSize:PropTypes.number,maxSize:PropTypes.number,maxFiles:PropTypes.number,disabled:PropTypes.bool,getFilesFromEvent:PropTypes.func,onFileDialogCancel:PropTypes.func,onFileDialogOpen:PropTypes.func,useFsAccessApi:PropTypes.bool,onDragEnter:PropTypes.func,onDragLeave:PropTypes.func,onDragOver:PropTypes.func,onDrop:PropTypes.func,onDropAccepted:PropTypes.func,onDropRejected:PropTypes.func,validator:PropTypes.func};var initialState={isFocused:!1,isFileDialogActive:!1,isDragActive:!1,isDragAccept:!1,isDragReject:!1,draggedFiles:[],acceptedFiles:[],fileRejections:[]};function useDropzone(){var st=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},at=_objectSpread(_objectSpread({},defaultProps),st),pt=at.accept,vt=at.disabled,wt=at.getFilesFromEvent,$t=at.maxSize,Tt=at.minSize,Lt=at.multiple,Ft=at.maxFiles,Ct=at.onDragEnter,Ht=at.onDragLeave,Gt=at.onDragOver,jt=at.onDrop,qt=at.onDropAccepted,Kt=at.onDropRejected,An=at.onFileDialogCancel,Sn=at.onFileDialogOpen,wn=at.useFsAccessApi,In=at.preventDropOnDocument,tr=at.noClick,rr=at.noKeyboard,Hr=at.noDrag,qr=at.noDragEventsBubbling,Zr=at.validator,Bo=reactExports.useMemo(function(){return typeof Sn=="function"?Sn:noop},[Sn]),Xo=reactExports.useMemo(function(){return typeof An=="function"?An:noop},[An]),Kr=reactExports.useRef(null),ko=reactExports.useRef(null),f0=reactExports.useReducer(reducer,initialState),x0=_slicedToArray(f0,2),l0=x0[0],T0=x0[1],t0=l0.isFocused,E0=l0.isFileDialogActive,n0=l0.draggedFiles,m0=reactExports.useRef(typeof window<"u"&&window.isSecureContext&&wn&&canUseFileSystemAccessAPI()),h0=function(){!m0.current&&E0&&setTimeout(function(){if(ko.current){var G0=ko.current.files;G0.length||(T0({type:"closeDialog"}),Xo())}},300)};reactExports.useEffect(function(){return window.addEventListener("focus",h0,!1),function(){window.removeEventListener("focus",h0,!1)}},[ko,E0,Xo,m0]);var a0=reactExports.useRef([]),P0=function(G0){Kr.current&&Kr.current.contains(G0.target)||(G0.preventDefault(),a0.current=[])};reactExports.useEffect(function(){return In&&(document.addEventListener("dragover",onDocumentDragOver,!1),document.addEventListener("drop",P0,!1)),function(){In&&(document.removeEventListener("dragover",onDocumentDragOver),document.removeEventListener("drop",P0))}},[Kr,In]);var V0=reactExports.useCallback(function(M0){M0.preventDefault(),M0.persist(),uy(M0),a0.current=[].concat(_toConsumableArray(a0.current),[M0.target]),isEvtWithFiles(M0)&&Promise.resolve(wt(M0)).then(function(G0){isPropagationStopped(M0)&&!qr||(T0({draggedFiles:G0,isDragActive:!0,type:"setDraggedFiles"}),Ct&&Ct(M0))})},[wt,Ct,qr]),B0=reactExports.useCallback(function(M0){M0.preventDefault(),M0.persist(),uy(M0);var G0=isEvtWithFiles(M0);if(G0&&M0.dataTransfer)try{M0.dataTransfer.dropEffect="copy"}catch{}return G0&&Gt&&Gt(M0),!1},[Gt,qr]),W0=reactExports.useCallback(function(M0){M0.preventDefault(),M0.persist(),uy(M0);var G0=a0.current.filter(function(dy){return Kr.current&&Kr.current.contains(dy)}),sy=G0.indexOf(M0.target);sy!==-1&&G0.splice(sy,1),a0.current=G0,!(G0.length>0)&&(T0({isDragActive:!1,type:"setDraggedFiles",draggedFiles:[]}),isEvtWithFiles(M0)&&Ht&&Ht(M0))},[Kr,Ht,qr]),K0=reactExports.useCallback(function(M0,G0){var sy=[],dy=[];M0.forEach(function(Vy){var Xy=fileAccepted(Vy,pt),hy=_slicedToArray(Xy,2),Ly=hy[0],Py=hy[1],Sy=fileMatchSize(Vy,Tt,$t),Ev=_slicedToArray(Sy,2),Qy=Ev[0],cy=Ev[1],C0=Zr?Zr(Vy):null;if(Ly&&Qy&&!C0)sy.push(Vy);else{var U0=[Py,cy];C0&&(U0=U0.concat(C0)),dy.push({file:Vy,errors:U0.filter(function(xy){return xy})})}}),(!Lt&&sy.length>1||Lt&&Ft>=1&&sy.length>Ft)&&(sy.forEach(function(Vy){dy.push({file:Vy,errors:[TOO_MANY_FILES_REJECTION]})}),sy.splice(0)),T0({acceptedFiles:sy,fileRejections:dy,type:"setFiles"}),jt&&jt(sy,dy,G0),dy.length>0&&Kt&&Kt(dy,G0),sy.length>0&&qt&&qt(sy,G0)},[T0,Lt,pt,Tt,$t,Ft,jt,qt,Kt,Zr]),Ty=reactExports.useCallback(function(M0){M0.preventDefault(),M0.persist(),uy(M0),a0.current=[],isEvtWithFiles(M0)&&Promise.resolve(wt(M0)).then(function(G0){isPropagationStopped(M0)&&!qr||K0(G0,M0)}),T0({type:"reset"})},[wt,K0,qr]),$y=reactExports.useCallback(function(){if(m0.current){T0({type:"openDialog"}),Bo();var M0={multiple:Lt,types:filePickerOptionsTypes(pt)};window.showOpenFilePicker(M0).then(function(G0){return wt(G0)}).then(function(G0){K0(G0,null),T0({type:"closeDialog"})}).catch(function(G0){isAbort(G0)?(Xo(G0),T0({type:"closeDialog"})):isSecurityError(G0)&&(m0.current=!1,ko.current&&(ko.current.value=null,ko.current.click()))});return}ko.current&&(T0({type:"openDialog"}),Bo(),ko.current.value=null,ko.current.click())},[T0,Bo,Xo,wn,K0,pt,Lt]),My=reactExports.useCallback(function(M0){!Kr.current||!Kr.current.isEqualNode(M0.target)||(M0.key===" "||M0.key==="Enter"||M0.keyCode===32||M0.keyCode===13)&&(M0.preventDefault(),$y())},[Kr,$y]),Wy=reactExports.useCallback(function(){T0({type:"focus"})},[]),Ey=reactExports.useCallback(function(){T0({type:"blur"})},[]),_0=reactExports.useCallback(function(){tr||(isIeOrEdge()?setTimeout($y,0):$y())},[tr,$y]),ay=function(G0){return vt?null:G0},J0=function(G0){return rr?null:ay(G0)},yy=function(G0){return Hr?null:ay(G0)},uy=function(G0){qr&&G0.stopPropagation()},Dy=reactExports.useMemo(function(){return function(){var M0=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},G0=M0.refKey,sy=G0===void 0?"ref":G0,dy=M0.role,Vy=M0.onKeyDown,Xy=M0.onFocus,hy=M0.onBlur,Ly=M0.onClick,Py=M0.onDragEnter,Sy=M0.onDragOver,Ev=M0.onDragLeave,Qy=M0.onDrop,cy=_objectWithoutProperties(M0,_excluded3);return _objectSpread(_objectSpread(_defineProperty({onKeyDown:J0(composeEventHandlers(Vy,My)),onFocus:J0(composeEventHandlers(Xy,Wy)),onBlur:J0(composeEventHandlers(hy,Ey)),onClick:ay(composeEventHandlers(Ly,_0)),onDragEnter:yy(composeEventHandlers(Py,V0)),onDragOver:yy(composeEventHandlers(Sy,B0)),onDragLeave:yy(composeEventHandlers(Ev,W0)),onDrop:yy(composeEventHandlers(Qy,Ty)),role:typeof dy=="string"&&dy!==""?dy:"button"},sy,Kr),!vt&&!rr?{tabIndex:0}:{}),cy)}},[Kr,My,Wy,Ey,_0,V0,B0,W0,Ty,rr,Hr,vt]),Fy=reactExports.useCallback(function(M0){M0.stopPropagation()},[]),qy=reactExports.useMemo(function(){return function(){var M0=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},G0=M0.refKey,sy=G0===void 0?"ref":G0,dy=M0.onChange,Vy=M0.onClick,Xy=_objectWithoutProperties(M0,_excluded4),hy=_defineProperty({accept:pt,multiple:Lt,type:"file",style:{display:"none"},onChange:ay(composeEventHandlers(dy,Ty)),onClick:ay(composeEventHandlers(Vy,Fy)),tabIndex:-1},sy,ko);return _objectSpread(_objectSpread({},hy),Xy)}},[ko,pt,Lt,Ty,vt]),rv=n0.length,y0=rv>0&&allFilesAccepted({files:n0,accept:pt,minSize:Tt,maxSize:$t,multiple:Lt,maxFiles:Ft}),r0=rv>0&&!y0;return _objectSpread(_objectSpread({},l0),{},{isDragAccept:y0,isDragReject:r0,isFocused:t0&&!vt,getRootProps:Dy,getInputProps:qy,rootRef:Kr,inputRef:ko,open:ay($y)})}function reducer(st,at){switch(at.type){case"focus":return _objectSpread(_objectSpread({},st),{},{isFocused:!0});case"blur":return _objectSpread(_objectSpread({},st),{},{isFocused:!1});case"openDialog":return _objectSpread(_objectSpread({},initialState),{},{isFileDialogActive:!0});case"closeDialog":return _objectSpread(_objectSpread({},st),{},{isFileDialogActive:!1});case"setDraggedFiles":var pt=at.isDragActive,vt=at.draggedFiles;return _objectSpread(_objectSpread({},st),{},{draggedFiles:vt,isDragActive:pt});case"setFiles":return _objectSpread(_objectSpread({},st),{},{acceptedFiles:at.acceptedFiles,fileRejections:at.fileRejections});case"reset":return _objectSpread({},initialState);default:return st}}function noop(){}/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */var isobject=function(at){return at!=null&&typeof at=="object"&&Array.isArray(at)===!1};/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */var isObject$6=isobject;function isObjectObject(st){return isObject$6(st)===!0&&Object.prototype.toString.call(st)==="[object Object]"}var isPlainObject$2=function(at){var pt,vt;return!(isObjectObject(at)===!1||(pt=at.constructor,typeof pt!="function")||(vt=pt.prototype,isObjectObject(vt)===!1)||vt.hasOwnProperty("isPrototypeOf")===!1)};/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */var isPlainObject$1=isPlainObject$2,isExtendable$4=function(at){return isPlainObject$1(at)||typeof at=="function"||Array.isArray(at)};/*!
 * for-in <https://github.com/jonschlinkert/for-in>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */var forIn$1=function(at,pt,vt){for(var wt in at)if(pt.call(vt,at[wt],wt,at)===!1)break},isExtendable$3=isExtendable$4,forIn=forIn$1;function mixinDeep(st,at){for(var pt=arguments.length,vt=0;++vt<pt;){var wt=arguments[vt];isObject$5(wt)&&forIn(wt,copy,st)}return st}function copy(st,at){if(isValidKey$1(at)){var pt=this[at];isObject$5(st)&&isObject$5(pt)?mixinDeep(pt,st):this[at]=st}}function isObject$5(st){return isExtendable$3(st)&&!Array.isArray(st)}function isValidKey$1(st){return st!=="__proto__"&&st!=="constructor"&&st!=="prototype"}var mixinDeep_1=mixinDeep;/*!
 * get-value <https://github.com/jonschlinkert/get-value>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */var getValue$1=function(st,at,pt,vt,wt){if(!isObject$4(st)||!at)return st;if(at=toString(at),pt&&(at+="."+toString(pt)),vt&&(at+="."+toString(vt)),wt&&(at+="."+toString(wt)),at in st)return st[at];for(var $t=at.split("."),Tt=$t.length,Lt=-1;st&&++Lt<Tt;){for(var Ft=$t[Lt];Ft[Ft.length-1]==="\\";)Ft=Ft.slice(0,-1)+"."+$t[++Lt];st=st[Ft]}return st};function isObject$4(st){return st!==null&&(typeof st=="object"||typeof st=="function")}function toString(st){return st?Array.isArray(st)?st.join("."):st:""}/*!
 * assign-symbols <https://github.com/jonschlinkert/assign-symbols>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */var assignSymbols$1=function(st,at){if(st===null||typeof st>"u")throw new TypeError("expected first argument to be an object.");if(typeof at>"u"||typeof Symbol>"u"||typeof Object.getOwnPropertySymbols!="function")return st;for(var pt=Object.prototype.propertyIsEnumerable,vt=Object(st),wt=arguments.length,$t=0;++$t<wt;)for(var Tt=Object(arguments[$t]),Lt=Object.getOwnPropertySymbols(Tt),Ft=0;Ft<Lt.length;Ft++){var Ct=Lt[Ft];pt.call(Tt,Ct)&&(vt[Ct]=Tt[Ct])}return vt},isExtendable$2=isExtendable$4,assignSymbols=assignSymbols$1,extendShallow$1=Object.assign||function(st){if(st===null||typeof st>"u")throw new TypeError("Cannot convert undefined or null to object");isObject$3(st)||(st={});for(var at=1;at<arguments.length;at++){var pt=arguments[at];isString(pt)&&(pt=toObject(pt)),isObject$3(pt)&&(assign$1(st,pt),assignSymbols(st,pt))}return st};function assign$1(st,at){for(var pt in at)hasOwn$1(at,pt)&&(st[pt]=at[pt])}function isString(st){return st&&typeof st=="string"}function toObject(st){var at={};for(var pt in st)at[pt]=st[pt];return at}function isObject$3(st){return st&&typeof st=="object"||isExtendable$2(st)}function hasOwn$1(st,at){return Object.prototype.hasOwnProperty.call(st,at)}/*!
 * split-string <https://github.com/jonschlinkert/split-string>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */var extend$1=extendShallow$1,splitString=function(st,at,pt){if(typeof st!="string")throw new TypeError("expected a string");typeof at=="function"&&(pt=at,at=null),typeof at=="string"&&(at={sep:at});var vt=extend$1({sep:"."},at),wt=vt.quotes||['"',"'","`"],$t;vt.brackets===!0?$t={"<":">","(":")","[":"]","{":"}"}:vt.brackets&&($t=vt.brackets);var Tt=[],Lt=[],Ft=[""],Ct=vt.sep,Ht=st.length,Gt=-1,jt;function qt(){if($t&&Lt.length)return $t[Lt[Lt.length-1]]}for(;++Gt<Ht;){var Kt=st[Gt],An=st[Gt+1],Sn={val:Kt,idx:Gt,arr:Ft,str:st};if(Tt.push(Sn),Kt==="\\"){Sn.val=keepEscaping(vt,st,Gt)===!0?Kt+An:An,Sn.escaped=!0,typeof pt=="function"&&pt(Sn),Ft[Ft.length-1]+=Sn.val,Gt++;continue}if($t&&$t[Kt]){Lt.push(Kt);var wn=qt(),In=Gt+1;if(st.indexOf(wn,In+1)!==-1)for(;Lt.length&&In<Ht;){var tr=st[++In];if(tr==="\\"){tr++;continue}if(wt.indexOf(tr)!==-1){In=getClosingQuote(st,tr,In+1);continue}if(wn=qt(),Lt.length&&st.indexOf(wn,In+1)===-1)break;if($t[tr]){Lt.push(tr);continue}wn===tr&&Lt.pop()}if(jt=In,jt===-1){Ft[Ft.length-1]+=Kt;continue}Kt=st.slice(Gt,jt+1),Sn.val=Kt,Sn.idx=Gt=jt}if(wt.indexOf(Kt)!==-1){if(jt=getClosingQuote(st,Kt,Gt+1),jt===-1){Ft[Ft.length-1]+=Kt;continue}keepQuotes(Kt,vt)===!0?Kt=st.slice(Gt,jt+1):Kt=st.slice(Gt+1,jt),Sn.val=Kt,Sn.idx=Gt=jt}if(typeof pt=="function"&&(pt(Sn,Tt),Kt=Sn.val,Gt=Sn.idx),Sn.val===Ct&&Sn.split!==!1){Ft.push("");continue}Ft[Ft.length-1]+=Sn.val}return Ft};function getClosingQuote(st,at,pt,vt){var wt=st.indexOf(at,pt);return st.charAt(wt-1)==="\\"?getClosingQuote(st,at,wt+1):wt}function keepQuotes(st,at){return at.keepDoubleQuotes===!0&&st==='"'||at.keepSingleQuotes===!0&&st==="'"?!0:at.keepQuotes}function keepEscaping(st,at,pt){return typeof st.keepEscaping=="function"?st.keepEscaping(at,pt):st.keepEscaping===!0||at[pt+1]==="\\"}/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */var isExtendable$1=function(at){return typeof at<"u"&&at!==null&&(typeof at=="object"||typeof at=="function")},isObject$2=isExtendable$1,extendShallow=function(at){isObject$2(at)||(at={});for(var pt=arguments.length,vt=1;vt<pt;vt++){var wt=arguments[vt];isObject$2(wt)&&assign(at,wt)}return at};function assign(st,at){for(var pt in at)hasOwn(at,pt)&&(st[pt]=at[pt])}function hasOwn(st,at){return Object.prototype.hasOwnProperty.call(st,at)}/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */var isExtendable=function(at){return typeof at<"u"&&at!==null&&(typeof at=="object"||typeof at=="function")};/*!
 * set-value <https://github.com/jonschlinkert/set-value>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */var split=splitString,extend=extendShallow,isPlainObject=isPlainObject$2,isObject$1=isExtendable,setValue=function(st,at,pt){if(!isObject$1(st)||(Array.isArray(at)&&(at=[].concat.apply([],at).join(".")),typeof at!="string"))return st;for(var vt=split(at,{sep:".",brackets:!0}).filter(isValidKey),wt=vt.length,$t=-1,Tt=st;++$t<wt;){var Lt=vt[$t];if($t!==wt-1){isObject$1(Tt[Lt])||(Tt[Lt]={}),Tt=Tt[Lt];continue}isPlainObject(Tt[Lt])&&isPlainObject(pt)?Tt[Lt]=extend({},Tt[Lt],pt):Tt[Lt]=pt}return st};function isValidKey(st){return st!=="__proto__"&&st!=="constructor"&&st!=="prototype"}var isObject=isExtendable$4,merge=mixinDeep_1,get=getValue$1,set=setValue,mergeValue=function(at,pt,vt){if(!isObject(at))throw new TypeError("expected an object");if(typeof pt!="string"||vt==null)return merge.apply(null,arguments);if(typeof vt=="string")return set(at,pt,vt),at;var wt=get(at,pt);return isObject(vt)&&isObject(wt)&&(vt=merge({},wt,vt)),set(at,pt,vt),at};const merge$1=getDefaultExportFromCjs(mergeValue),join=(...st)=>st.filter(Boolean).join(".");function getKeyPath(st){const at=st.split(".");return[at.pop(),at.join(".")||void 0]}function getValuesForPaths(st,at){return Object.entries(pick(st,at)).reduce((pt,[,{value:vt,disabled:wt,key:$t}])=>(pt[$t]=wt?void 0:vt,pt),{})}function useCompareMemoize(st,at){const pt=reactExports.useRef();return dequal(st,pt.current)||(pt.current=st),pt.current}function useDeepMemo(st,at){return reactExports.useMemo(st,useCompareMemoize(at))}function useToggle(st){const at=reactExports.useRef(null),pt=reactExports.useRef(null),vt=reactExports.useRef(!0);return reactExports.useLayoutEffect(()=>{st||(at.current.style.height="0px",at.current.style.overflow="hidden")},[]),reactExports.useEffect(()=>{if(vt.current){vt.current=!1;return}let wt;const $t=at.current,Tt=()=>{st&&($t.style.removeProperty("height"),$t.style.removeProperty("overflow"),pt.current.scrollIntoView({behavior:"smooth",block:"nearest"}))};$t.addEventListener("transitionend",Tt,{once:!0});const{height:Lt}=pt.current.getBoundingClientRect();return $t.style.height=Lt+"px",st||($t.style.overflow="hidden",wt=window.setTimeout(()=>$t.style.height="0px",50)),()=>{$t.removeEventListener("transitionend",Tt),clearTimeout(wt)}},[st]),{wrapperRef:at,contentRef:pt}}const useVisiblePaths=st=>{const[at,pt]=reactExports.useState(st.getVisiblePaths());return reactExports.useEffect(()=>{pt(st.getVisiblePaths());const vt=st.useStore.subscribe(st.getVisiblePaths,pt,{equalityFn:shallow});return()=>vt()},[st]),at};function useValuesForPath(st,at,pt){return st.useStore(wt=>{const $t=_objectSpread2(_objectSpread2({},pt),wt.data);return getValuesForPaths($t,at)},shallow)}function usePopin(st=3){const at=reactExports.useRef(null),pt=reactExports.useRef(null),[vt,wt]=reactExports.useState(!1),$t=reactExports.useCallback(()=>wt(!0),[]),Tt=reactExports.useCallback(()=>wt(!1),[]);return reactExports.useLayoutEffect(()=>{if(vt){const{bottom:Lt,top:Ft,left:Ct}=at.current.getBoundingClientRect(),{height:Ht}=pt.current.getBoundingClientRect(),Gt=Lt+Ht>window.innerHeight-40?"up":"down";pt.current.style.position="fixed",pt.current.style.zIndex="10000",pt.current.style.left=Ct+"px",Gt==="down"?pt.current.style.top=Lt+st+"px":pt.current.style.bottom=window.innerHeight-Ft+st+"px"}},[st,vt]),{popinRef:at,wrapperRef:pt,shown:vt,show:$t,hide:Tt}}k$1([namesPlugin]);const convertMap={rgb:"toRgb",hsl:"toHsl",hsv:"toHsv",hex:"toHex"};v8n.extend({color:()=>st=>w(st).isValid()});const schema$2=st=>v8n().color().test(st);function convert(st,{format:at,hasAlpha:pt,isString:vt}){const wt=convertMap[at]+(vt&&at!=="hex"?"String":""),$t=st[wt]();return typeof $t=="object"&&!pt?omit($t,["a"]):$t}const sanitize$2=(st,at)=>{const pt=w(st);if(!pt.isValid())throw Error("Invalid color");return convert(pt,at)},format$1=(st,at)=>convert(w(st),_objectSpread2(_objectSpread2({},at),{},{isString:!0,format:"hex"})),normalize$3=({value:st})=>{const at=I$1(st),pt=at==="name"?"hex":at,vt=typeof st=="object"?"a"in st:at==="hex"&&st.length===8||/^(rgba)|(hsla)|(hsva)/.test(st),wt={format:pt,hasAlpha:vt,isString:typeof st=="string"};return{value:sanitize$2(st,wt),settings:wt}};var props$2=Object.freeze({__proto__:null,schema:schema$2,sanitize:sanitize$2,format:format$1,normalize:normalize$3});const ColorPreview=styled("div",{position:"relative",boxSizing:"border-box",borderRadius:"$sm",overflow:"hidden",cursor:"pointer",height:"$rowHeight",width:"$rowHeight",backgroundColor:"#fff",backgroundImage:`url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>')`,$inputStyle:"",$hover:"",zIndex:1,variants:{active:{true:{$inputStyle:"$accent1"}}},"&::before":{content:'""',position:"absolute",top:0,bottom:0,right:0,left:0,backgroundColor:"currentColor",zIndex:1}}),PickerContainer=styled("div",{position:"relative",display:"grid",gridTemplateColumns:"$sizes$rowHeight auto",columnGap:"$colGap",alignItems:"center"}),PickerWrapper=styled("div",{width:"$colorPickerWidth",height:"$colorPickerHeight",".react-colorful":{width:"100%",height:"100%",boxShadow:"$level2",cursor:"crosshair"},".react-colorful__saturation":{borderRadius:"$sm $sm 0 0"},".react-colorful__alpha, .react-colorful__hue":{height:10},".react-colorful__last-control":{borderRadius:"0 0 $sm $sm"},".react-colorful__pointer":{height:12,width:12}});function convertToRgb(st,at){return at!=="rgb"?w(st).toRgb():st}function Color({value:st,displayValue:at,settings:pt,onUpdate:vt}){const{emitOnEditStart:wt,emitOnEditEnd:$t}=useInputContext(),{format:Tt,hasAlpha:Lt}=pt,{popinRef:Ft,wrapperRef:Ct,shown:Ht,show:Gt,hide:jt}=usePopin(),qt=reactExports.useRef(0),[Kt,An]=reactExports.useState(()=>convertToRgb(st,Tt)),Sn=Lt?Ce:Ne$1,wn=()=>{An(convertToRgb(st,Tt)),Gt(),wt()},In=()=>{jt(),$t(),window.clearTimeout(qt.current)},tr=()=>{qt.current=window.setTimeout(In,500)};return reactExports.useEffect(()=>()=>window.clearTimeout(qt.current),[]),React.createElement(React.Fragment,null,React.createElement(ColorPreview,{ref:Ft,active:Ht,onClick:()=>wn(),style:{color:at}}),Ht&&React.createElement(Portal,null,React.createElement(Overlay,{onPointerUp:In}),React.createElement(PickerWrapper,{ref:Ct,onMouseEnter:()=>window.clearTimeout(qt.current),onMouseLeave:rr=>rr.buttons===0&&tr()},React.createElement(Sn,{color:Kt,onChange:vt}))))}function ColorComponent(){const{value:st,displayValue:at,label:pt,onChange:vt,onUpdate:wt,settings:$t}=useInputContext();return React.createElement(Row,{input:!0},React.createElement(Label,null,pt),React.createElement(PickerContainer,null,React.createElement(Color,{value:st,displayValue:at,onChange:vt,onUpdate:wt,settings:$t}),React.createElement(ValueInput,{value:at,onChange:vt,onUpdate:wt})))}var color=_objectSpread2({component:ColorComponent},props$2);function Vector3dComponent(){const{label:st,displayValue:at,onUpdate:pt,settings:vt}=useInputContext();return React.createElement(Row,{input:!0},React.createElement(Label,null,st),React.createElement(Vector,{value:at,settings:vt,onUpdate:pt}))}var vector3d=_objectSpread2({component:Vector3dComponent},getVectorPlugin(["x","y","z"]));const JoystickTrigger=styled("div",{$flexCenter:"",position:"relative",backgroundColor:"$elevation3",borderRadius:"$sm",cursor:"pointer",height:"$rowHeight",width:"$rowHeight",touchAction:"none",$draggable:"",$hover:"","&:active":{cursor:"none"},"&::after":{content:'""',backgroundColor:"$accent2",height:4,width:4,borderRadius:2}}),JoystickPlayground=styled("div",{$flexCenter:"",width:"$joystickWidth",height:"$joystickHeight",borderRadius:"$sm",boxShadow:"$level2",position:"fixed",zIndex:1e4,overflow:"hidden",$draggable:"",transform:"translate(-50%, -50%)",variants:{isOutOfBounds:{true:{backgroundColor:"$elevation1"},false:{backgroundColor:"$elevation3"}}},"> div":{position:"absolute",$flexCenter:"",borderStyle:"solid",borderWidth:1,borderColor:"$highlight1",backgroundColor:"$elevation3",width:"80%",height:"80%","&::after,&::before":{content:'""',position:"absolute",zindex:10,backgroundColor:"$highlight1"},"&::before":{width:"100%",height:1},"&::after":{height:"100%",width:1}},"> span":{position:"relative",zindex:100,width:10,height:10,backgroundColor:"$accent2",borderRadius:"50%"}});function Joystick({value:st,settings:at,onUpdate:pt}){const vt=reactExports.useRef(),wt=reactExports.useRef(0),$t=reactExports.useRef(0),Tt=reactExports.useRef(1),[Lt,Ft]=reactExports.useState(!1),[Ct,Ht]=reactExports.useState(!1),[Gt,jt]=useTransform(),qt=reactExports.useRef(null),Kt=reactExports.useRef(null);reactExports.useLayoutEffect(()=>{if(Lt){const{top:f0,left:x0,width:l0,height:T0}=qt.current.getBoundingClientRect();Kt.current.style.left=x0+l0/2+"px",Kt.current.style.top=f0+T0/2+"px"}},[Lt]);const{keys:[An,Sn],joystick:wn}=at,In=wn==="invertY"?1:-1,{[An]:{step:tr},[Sn]:{step:rr}}=at,Hr=useTh("sizes","joystickWidth"),qr=useTh("sizes","joystickHeight"),Zr=parseFloat(Hr)*.8/2,Bo=parseFloat(qr)*.8/2,Xo=reactExports.useCallback(()=>{vt.current||(Ht(!0),wt.current&&jt({x:wt.current*Zr}),$t.current&&jt({y:$t.current*-Bo}),vt.current=window.setInterval(()=>{pt(f0=>{const x0=tr*wt.current*Tt.current,l0=In*rr*$t.current*Tt.current;return Array.isArray(f0)?{[An]:f0[0]+x0,[Sn]:f0[1]+l0}:{[An]:f0[An]+x0,[Sn]:f0[Sn]+l0}})},16))},[Zr,Bo,pt,jt,tr,rr,An,Sn,In]),Kr=reactExports.useCallback(()=>{window.clearTimeout(vt.current),vt.current=void 0,Ht(!1)},[]);reactExports.useEffect(()=>{function f0(x0){Tt.current=multiplyStep(x0)}return window.addEventListener("keydown",f0),window.addEventListener("keyup",f0),()=>{window.clearTimeout(vt.current),window.removeEventListener("keydown",f0),window.removeEventListener("keyup",f0)}},[]);const ko=useDrag(({first:f0,active:x0,delta:[l0,T0],movement:[t0,E0]})=>{f0&&Ft(!0);const n0=clamp(t0,-Zr,Zr),m0=clamp(E0,-Bo,Bo);wt.current=Math.abs(t0)>Math.abs(n0)?Math.sign(t0-n0):0,$t.current=Math.abs(E0)>Math.abs(m0)?Math.sign(m0-E0):0;let h0=st[An],a0=st[Sn];x0?(wt.current||(h0+=l0*tr*Tt.current,jt({x:n0})),$t.current||(a0-=In*T0*rr*Tt.current,jt({y:m0})),wt.current||$t.current?Xo():Kr(),pt({[An]:h0,[Sn]:a0})):(Ft(!1),wt.current=0,$t.current=0,jt({x:0,y:0}),Kr())});return React.createElement(JoystickTrigger,_extends({ref:qt},ko()),Lt&&React.createElement(Portal,null,React.createElement(JoystickPlayground,{ref:Kt,isOutOfBounds:Ct},React.createElement("div",null),React.createElement("span",{ref:Gt}))))}const Container$1=styled("div",{display:"grid",columnGap:"$colGap",variants:{withJoystick:{true:{gridTemplateColumns:"$sizes$rowHeight auto"},false:{gridTemplateColumns:"auto"}}}});function Vector2dComponent(){const{label:st,displayValue:at,onUpdate:pt,settings:vt}=useInputContext();return React.createElement(Row,{input:!0},React.createElement(Label,null,st),React.createElement(Container$1,{withJoystick:!!vt.joystick},vt.joystick&&React.createElement(Joystick,{value:at,settings:vt,onUpdate:pt}),React.createElement(Vector,{value:at,settings:vt,onUpdate:pt})))}const _excluded$7=["joystick"],plugin=getVectorPlugin(["x","y"]),normalize$2=st=>{let{joystick:at=!0}=st,pt=_objectWithoutProperties$1(st,_excluded$7);const{value:vt,settings:wt}=plugin.normalize(pt);return{value:vt,settings:_objectSpread2(_objectSpread2({},wt),{},{joystick:at})}};var vector2d=_objectSpread2(_objectSpread2({component:Vector2dComponent},plugin),{},{normalize:normalize$2});const sanitize$1=st=>{if(st!==void 0){if(st instanceof File)try{return URL.createObjectURL(st)}catch{return}if(typeof st=="string"&&st.indexOf("blob:")===0)return st;throw Error("Invalid image format [undefined | blob |File].")}},schema$1=(st,at)=>typeof at=="object"&&"image"in at,normalize$1=({image:st})=>({value:st});var props$1=Object.freeze({__proto__:null,sanitize:sanitize$1,schema:schema$1,normalize:normalize$1});const ImageContainer=styled("div",{position:"relative",display:"grid",gridTemplateColumns:"$sizes$rowHeight auto 20px",columnGap:"$colGap",alignItems:"center"}),DropZone=styled("div",{$flexCenter:"",overflow:"hidden",height:"$rowHeight",background:"$elevation3",textAlign:"center",color:"inherit",borderRadius:"$sm",outline:"none",userSelect:"none",cursor:"pointer",$inputStyle:"",$hover:"",$focusWithin:"",$active:"$accent1 $elevation1",variants:{isDragAccept:{true:{$inputStyle:"$accent1",backgroundColor:"$elevation1"}}}}),ImagePreview=styled("div",{boxSizing:"border-box",borderRadius:"$sm",height:"$rowHeight",width:"$rowHeight",$inputStyle:"",backgroundSize:"cover",backgroundPosition:"center",variants:{hasImage:{true:{cursor:"pointer",$hover:"",$active:""}}}}),ImageLargePreview=styled("div",{$flexCenter:"",width:"$imagePreviewWidth",height:"$imagePreviewHeight",borderRadius:"$sm",boxShadow:"$level2",pointerEvents:"none",$inputStyle:"",backgroundSize:"cover",backgroundPosition:"center"}),Instructions=styled("div",{fontSize:"0.8em",height:"100%",padding:"$rowGap $md"}),Remove=styled("div",{$flexCenter:"",top:"0",right:"0",marginRight:"$sm",height:"100%",cursor:"pointer",variants:{disabled:{true:{color:"$elevation3",cursor:"default"}}},"&::after,&::before":{content:'""',position:"absolute",height:2,width:10,borderRadius:1,backgroundColor:"currentColor"},"&::after":{transform:"rotate(45deg)"},"&::before":{transform:"rotate(-45deg)"}});function ImageComponent(){const{label:st,value:at,onUpdate:pt,disabled:vt}=useInputContext(),{popinRef:wt,wrapperRef:$t,shown:Tt,show:Lt,hide:Ft}=usePopin(),Ct=reactExports.useCallback(Kt=>{Kt.length&&pt(Kt[0])},[pt]),Ht=reactExports.useCallback(Kt=>{Kt.stopPropagation(),pt(void 0)},[pt]),{getRootProps:Gt,getInputProps:jt,isDragAccept:qt}=useDropzone({maxFiles:1,accept:"image/*",onDrop:Ct,disabled:vt});return React.createElement(Row,{input:!0},React.createElement(Label,null,st),React.createElement(ImageContainer,null,React.createElement(ImagePreview,{ref:wt,hasImage:!!at,onPointerDown:()=>!!at&&Lt(),onPointerUp:Ft,style:{backgroundImage:at?`url(${at})`:"none"}}),Tt&&!!at&&React.createElement(Portal,null,React.createElement(Overlay,{onPointerUp:Ft,style:{cursor:"pointer"}}),React.createElement(ImageLargePreview,{ref:$t,style:{backgroundImage:`url(${at})`}})),React.createElement(DropZone,Gt({isDragAccept:qt}),React.createElement("input",jt()),React.createElement(Instructions,null,qt?"drop image":"click or drop")),React.createElement(Remove,{onClick:Ht,disabled:!at})))}var image=_objectSpread2({component:ImageComponent},props$1);const number=v8n().number(),schema=(st,at)=>v8n().array().length(2).every.number().test(st)&&v8n().schema({min:number,max:number}).test(at),format=st=>({min:st[0],max:st[1]}),sanitize=(st,{bounds:[at,pt]},vt)=>{const wt=Array.isArray(st)?format(st):st,$t={min:vt[0],max:vt[1]},{min:Tt,max:Lt}=_objectSpread2(_objectSpread2({},$t),wt);return[clamp(Number(Tt),at,Math.max(at,Lt)),clamp(Number(Lt),Math.min(pt,Tt),pt)]},normalize=({value:st,min:at,max:pt})=>{const vt={min:at,max:pt},wt=normalizeKeyedNumberSettings(format(st),{min:vt,max:vt}),$t=[at,pt],Tt=_objectSpread2(_objectSpread2({},wt),{},{bounds:$t});return{value:sanitize(format(st),Tt,st),settings:Tt}};var props=Object.freeze({__proto__:null,schema,format,sanitize,normalize});const _excluded$6=["value","bounds","onDrag"],_excluded2$1=["bounds"],Container=styled("div",{display:"grid",columnGap:"$colGap",gridTemplateColumns:"auto calc($sizes$numberInputMinWidth * 2 + $space$rowGap)"});function IntervalSlider(st){let{value:at,bounds:[pt,vt],onDrag:wt}=st,$t=_objectWithoutProperties$1(st,_excluded$6);const Tt=reactExports.useRef(null),Lt=reactExports.useRef(null),Ft=reactExports.useRef(null),Ct=reactExports.useRef(0),Ht=useTh("sizes","scrubberWidth"),Gt=useDrag(({event:Kt,first:An,xy:[Sn],movement:[wn],memo:In={}})=>{if(An){const{width:rr,left:Hr}=Tt.current.getBoundingClientRect();Ct.current=rr-parseFloat(Ht);const qr=(Kt==null?void 0:Kt.target)===Lt.current||(Kt==null?void 0:Kt.target)===Ft.current;In.pos=invertedRange((Sn-Hr)/rr,pt,vt);const Zr=Math.abs(In.pos-at.min)-Math.abs(In.pos-at.max);In.key=Zr<0||Zr===0&&In.pos<=at.min?"min":"max",qr&&(In.pos=at[In.key])}const tr=In.pos+invertedRange(wn/Ct.current,0,vt-pt);return wt({[In.key]:sanitizeStep(tr,$t[In.key])}),In}),jt=`calc(${range(at.min,pt,vt)} * (100% - ${Ht} - 8px) + 4px)`,qt=`calc(${1-range(at.max,pt,vt)} * (100% - ${Ht} - 8px) + 4px)`;return React.createElement(RangeWrapper,_extends({ref:Tt},Gt()),React.createElement(Range,null,React.createElement(Indicator,{style:{left:jt,right:qt}})),React.createElement(Scrubber,{position:"left",ref:Lt,style:{left:jt}}),React.createElement(Scrubber,{position:"right",ref:Ft,style:{right:qt}}))}function IntervalComponent(){const{label:st,displayValue:at,onUpdate:pt,settings:vt}=useInputContext(),wt=_objectWithoutProperties$1(vt,_excluded2$1);return React.createElement(React.Fragment,null,React.createElement(Row,{input:!0},React.createElement(Label,null,st),React.createElement(Container,null,React.createElement(IntervalSlider,_extends({value:at},vt,{onDrag:pt})),React.createElement(Vector,{value:at,settings:wt,onUpdate:pt,innerLabelTrim:0}))))}var interval=_objectSpread2({component:IntervalComponent},props);const createEventEmitter=()=>{const st=new Map;return{on:(at,pt)=>{let vt=st.get(at);vt===void 0&&(vt=new Set,st.set(at,vt)),vt.add(pt)},off:(at,pt)=>{const vt=st.get(at);vt!==void 0&&(vt.delete(pt),vt.size===0&&st.delete(at))},emit:(at,...pt)=>{const vt=st.get(at);if(vt!==void 0)for(const wt of vt)wt(...pt)}}},_excluded$5=["type","value"],_excluded2=["onChange","transient","onEditStart","onEditEnd"],Store=function(){const at=create(subscribeWithSelector(()=>({data:{}}))),pt=createEventEmitter();this.storeId=getUid(),this.useStore=at;const vt={},wt=new Set;this.getVisiblePaths=()=>{const Tt=this.getData(),Lt=Object.keys(Tt),Ft=[];Object.entries(vt).forEach(([Ht,Gt])=>{Gt.render&&Lt.some(jt=>jt.indexOf(Ht)===0)&&!Gt.render(this.get)&&Ft.push(Ht+".")});const Ct=[];return wt.forEach(Ht=>{Ht in Tt&&Tt[Ht].__refCount>0&&Ft.every(Gt=>Ht.indexOf(Gt)===-1)&&(!Tt[Ht].render||Tt[Ht].render(this.get))&&Ct.push(Ht)}),Ct},this.setOrderedPaths=Tt=>{Tt.forEach(Lt=>wt.add(Lt))},this.orderPaths=Tt=>(this.setOrderedPaths(Tt),Tt),this.disposePaths=Tt=>{at.setState(Lt=>{const Ft=Lt.data;return Tt.forEach(Ct=>{if(Ct in Ft){const Ht=Ft[Ct];Ht.__refCount--,Ht.__refCount===0&&Ht.type in SpecialInputs&&delete Ft[Ct]}}),{data:Ft}})},this.dispose=()=>{at.setState(()=>({data:{}}))},this.getFolderSettings=Tt=>vt[Tt]||{},this.getData=()=>at.getState().data,this.addData=(Tt,Lt)=>{at.setState(Ft=>{const Ct=Ft.data;return Object.entries(Tt).forEach(([Ht,Gt])=>{let jt=Ct[Ht];if(jt){const{type:qt,value:Kt}=Gt,An=_objectWithoutProperties$1(Gt,_excluded$5);qt!==jt.type?warn(LevaErrors.INPUT_TYPE_OVERRIDE,qt):((jt.__refCount===0||Lt)&&Object.assign(jt,An),jt.__refCount++)}else Ct[Ht]=_objectSpread2(_objectSpread2({},Gt),{},{__refCount:1})}),{data:Ct}})},this.setValueAtPath=(Tt,Lt,Ft)=>{at.setState(Ct=>{const Ht=Ct.data;return updateInput(Ht[Tt],Lt,Tt,this,Ft),{data:Ht}})},this.setSettingsAtPath=(Tt,Lt)=>{at.setState(Ft=>{const Ct=Ft.data;return Ct[Tt].settings=_objectSpread2(_objectSpread2({},Ct[Tt].settings),Lt),{data:Ct}})},this.disableInputAtPath=(Tt,Lt)=>{at.setState(Ft=>{const Ct=Ft.data;return Ct[Tt].disabled=Lt,{data:Ct}})},this.set=(Tt,Lt)=>{at.setState(Ft=>{const Ct=Ft.data;return Object.entries(Tt).forEach(([Ht,Gt])=>{try{updateInput(Ct[Ht],Gt,void 0,void 0,Lt)}catch{}}),{data:Ct}})},this.getInput=Tt=>{try{return this.getData()[Tt]}catch{warn(LevaErrors.PATH_DOESNT_EXIST,Tt)}},this.get=Tt=>{var Lt;return(Lt=this.getInput(Tt))===null||Lt===void 0?void 0:Lt.value},this.emitOnEditStart=Tt=>{pt.emit(`onEditStart:${Tt}`,this.get(Tt),Tt,_objectSpread2(_objectSpread2({},this.getInput(Tt)),{},{get:this.get}))},this.emitOnEditEnd=Tt=>{pt.emit(`onEditEnd:${Tt}`,this.get(Tt),Tt,_objectSpread2(_objectSpread2({},this.getInput(Tt)),{},{get:this.get}))},this.subscribeToEditStart=(Tt,Lt)=>{const Ft=`onEditStart:${Tt}`;return pt.on(Ft,Lt),()=>pt.off(Ft,Lt)},this.subscribeToEditEnd=(Tt,Lt)=>{const Ft=`onEditEnd:${Tt}`;return pt.on(Ft,Lt),()=>pt.off(Ft,Lt)};const $t=(Tt,Lt,Ft)=>{const Ct={};return Object.entries(Tt).forEach(([Ht,Gt])=>{if(Ht==="")return warn(LevaErrors.EMPTY_KEY);let jt=join(Lt,Ht);if(Gt.type===SpecialInputs.FOLDER){const qt=$t(Gt.schema,jt,Ft);Object.assign(Ct,qt),jt in vt||(vt[jt]=Gt.settings)}else if(Ht in Ft)warn(LevaErrors.DUPLICATE_KEYS,Ht,jt,Ft[Ht].path);else{const qt=normalizeInput(Gt,Ht,jt,Ct);if(qt){const{type:Kt,options:An,input:Sn}=qt,{onChange:wn,transient:In,onEditStart:tr,onEditEnd:rr}=An,Hr=_objectWithoutProperties$1(An,_excluded2);Ct[jt]=_objectSpread2(_objectSpread2(_objectSpread2({type:Kt},Hr),Sn),{},{fromPanel:!0}),Ft[Ht]={path:jt,onChange:wn,transient:In,onEditStart:tr,onEditEnd:rr}}else warn(LevaErrors.UNKNOWN_INPUT,jt,Gt)}}),Ct};this.getDataFromSchema=Tt=>{const Lt={};return[$t(Tt,"",Lt),Lt]}},levaStore=new Store,defaultSettings$2={collapsed:!1};function folder(st,at){return{type:SpecialInputs.FOLDER,schema:st,settings:_objectSpread2(_objectSpread2({},defaultSettings$2),at)}}const defaultSettings$1={disabled:!1};function button(st,at){return{type:SpecialInputs.BUTTON,onClick:st,settings:_objectSpread2(_objectSpread2({},defaultSettings$1),at)}}const isInput=st=>"__levaInput"in st,buildTree=(st,at)=>{const pt={},vt=at?at.toLowerCase():null;return st.forEach(wt=>{const[$t,Tt]=getKeyPath(wt);(!vt||$t.toLowerCase().indexOf(vt)>-1)&&merge$1(pt,Tt,{[$t]:{__levaInput:!0,path:wt}})}),pt},_excluded$4=["type","label","path","valueKey","value","settings","setValue","disabled"];function ControlInput(st){let{type:at,label:pt,path:vt,valueKey:wt,value:$t,settings:Tt,setValue:Lt,disabled:Ft}=st,Ct=_objectWithoutProperties$1(st,_excluded$4);const{displayValue:Ht,onChange:Gt,onUpdate:jt}=useInputSetters({type:at,value:$t,settings:Tt,setValue:Lt}),qt=Plugins[at].component;return qt?React.createElement(InputContext.Provider,{value:_objectSpread2({key:wt,path:vt,id:""+vt,label:pt,displayValue:Ht,value:$t,onChange:Gt,onUpdate:jt,settings:Tt,setValue:Lt,disabled:Ft},Ct)},React.createElement(StyledInputWrapper$1,{disabled:Ft},React.createElement(qt,null))):(warn(LevaErrors.NO_COMPONENT_FOR_TYPE,at,vt),null)}const StyledButton=styled("button",{display:"block",$reset:"",fontWeight:"$button",height:"$rowHeight",borderStyle:"none",borderRadius:"$sm",backgroundColor:"$elevation1",color:"$highlight1","&:not(:disabled)":{color:"$highlight3",backgroundColor:"$accent2",cursor:"pointer",$hover:"$accent3",$active:"$accent3 $accent1",$focus:""}});function Button({onClick:st,settings:at,label:pt}){const vt=useStoreContext();return React.createElement(Row,null,React.createElement(StyledButton,{disabled:at.disabled,onClick:()=>st(vt.get)},pt))}const StyledButtonGroup=styled("div",{$flex:"",justifyContent:"flex-end",gap:"$colGap"}),StyledButtonGroupButton=styled("button",{$reset:"",cursor:"pointer",borderRadius:"$xs","&:hover":{backgroundColor:"$elevation3"}}),getOpts=({label:st,opts:at})=>{let pt=typeof st=="string"&&st.trim()===""?null:st,vt=at;return typeof at.opts=="object"&&(vt.label!==void 0&&(pt=at.label),vt=at.opts),{label:pt,opts:vt}};function ButtonGroup(st){const{label:at,opts:pt}=getOpts(st),vt=useStoreContext();return React.createElement(Row,{input:!!at},at&&React.createElement(Label,null,at),React.createElement(StyledButtonGroup,null,Object.entries(pt).map(([wt,$t])=>React.createElement(StyledButtonGroupButton,{key:wt,onClick:()=>$t(vt.get)},wt))))}const Canvas=styled("canvas",{height:"$monitorHeight",width:"100%",display:"block",borderRadius:"$sm"}),POINTS=100;function push(st,at){st.push(at),st.length>POINTS&&st.shift()}const MonitorCanvas=reactExports.forwardRef(function({initialValue:st},at){const pt=useTh("colors","highlight3"),vt=useTh("colors","elevation2"),wt=useTh("colors","highlight1"),[$t,Tt]=reactExports.useMemo(()=>[w(wt).alpha(.4).toRgbString(),w(wt).alpha(.1).toRgbString()],[wt]),Lt=reactExports.useRef([st]),Ft=reactExports.useRef(st),Ct=reactExports.useRef(st),Ht=reactExports.useRef(),Gt=reactExports.useCallback((Kt,An)=>{if(!Kt)return;const{width:Sn,height:wn}=Kt,In=new Path2D,tr=Sn/POINTS,rr=wn*.05;for(let Zr=0;Zr<Lt.current.length;Zr++){const Bo=range(Lt.current[Zr],Ft.current,Ct.current),Xo=tr*Zr,Kr=wn-Bo*(wn-rr*2)-rr;In.lineTo(Xo,Kr)}An.clearRect(0,0,Sn,wn);const Hr=new Path2D(In);Hr.lineTo(tr*(Lt.current.length+1),wn),Hr.lineTo(0,wn),Hr.lineTo(0,0);const qr=An.createLinearGradient(0,0,0,wn);qr.addColorStop(0,$t),qr.addColorStop(1,Tt),An.fillStyle=qr,An.fill(Hr),An.strokeStyle=vt,An.lineJoin="round",An.lineWidth=14,An.stroke(In),An.strokeStyle=pt,An.lineWidth=2,An.stroke(In)},[pt,vt,$t,Tt]),[jt,qt]=useCanvas2d(Gt);return reactExports.useImperativeHandle(at,()=>({frame:Kt=>{(Ft.current===void 0||Kt<Ft.current)&&(Ft.current=Kt),(Ct.current===void 0||Kt>Ct.current)&&(Ct.current=Kt),push(Lt.current,Kt),Ht.current=requestAnimationFrame(()=>Gt(jt.current,qt.current))}}),[jt,qt,Gt]),reactExports.useEffect(()=>()=>cancelAnimationFrame(Ht.current),[]),React.createElement(Canvas,{ref:jt})}),parse=st=>Number.isFinite(st)?st.toPrecision(2):st.toString(),MonitorLog=reactExports.forwardRef(function({initialValue:st},at){const[pt,vt]=reactExports.useState(parse(st));return reactExports.useImperativeHandle(at,()=>({frame:wt=>vt(parse(wt))}),[]),React.createElement("div",null,pt)});function getValue(st){return typeof st=="function"?st():st.current}function Monitor({label:st,objectOrFn:at,settings:pt}){const vt=reactExports.useRef(),wt=reactExports.useRef(getValue(at));return reactExports.useEffect(()=>{const $t=window.setInterval(()=>{var Tt;document.hidden||(Tt=vt.current)===null||Tt===void 0||Tt.frame(getValue(at))},pt.interval);return()=>window.clearInterval($t)},[at,pt.interval]),React.createElement(Row,{input:!0},React.createElement(Label,{align:"top"},st),pt.graph?React.createElement(MonitorCanvas,{ref:vt,initialValue:wt.current}):React.createElement(MonitorLog,{ref:vt,initialValue:wt.current}))}const _excluded$3=["type","label","key"],specialComponents={[SpecialInputs.BUTTON]:Button,[SpecialInputs.BUTTON_GROUP]:ButtonGroup,[SpecialInputs.MONITOR]:Monitor},Control=React.memo(({path:st})=>{const[at,{set:pt,setSettings:vt,disable:wt,storeId:$t,emitOnEditStart:Tt,emitOnEditEnd:Lt}]=useInput(st);if(!at)return null;const{type:Ft,label:Ct,key:Ht}=at,Gt=_objectWithoutProperties$1(at,_excluded$3);if(Ft in SpecialInputs){const jt=specialComponents[Ft];return React.createElement(jt,_extends({label:Ct,path:st},Gt))}return Ft in Plugins?React.createElement(ControlInput,_extends({key:$t+st,type:Ft,label:Ct,storeId:$t,path:st,valueKey:Ht,setValue:pt,setSettings:vt,disable:wt,emitOnEditStart:Tt,emitOnEditEnd:Lt},Gt)):(log(LevaErrors.UNSUPPORTED_INPUT,Ft,st),null)});function FolderTitle({toggle:st,toggled:at,name:pt}){return React.createElement(StyledTitle,{onClick:()=>st()},React.createElement(Chevron,{toggled:at}),React.createElement("div",null,pt))}const Folder=({name:st,path:at,tree:pt})=>{const vt=useStoreContext(),wt=join(at,st),{collapsed:$t,color:Tt}=vt.getFolderSettings(wt),[Lt,Ft]=reactExports.useState(!$t),Ct=reactExports.useRef(null),Ht=useTh("colors","folderWidgetColor"),Gt=useTh("colors","folderTextColor");return reactExports.useLayoutEffect(()=>{Ct.current.style.setProperty("--leva-colors-folderWidgetColor",Tt||Ht),Ct.current.style.setProperty("--leva-colors-folderTextColor",Tt||Gt)},[Tt,Ht,Gt]),React.createElement(StyledFolder,{ref:Ct},React.createElement(FolderTitle,{name:st,toggled:Lt,toggle:()=>Ft(jt=>!jt)}),React.createElement(TreeWrapper,{parent:wt,tree:pt,toggled:Lt}))},TreeWrapper=React.memo(({isRoot:st=!1,fill:at=!1,flat:pt=!1,parent:vt,tree:wt,toggled:$t})=>{const{wrapperRef:Tt,contentRef:Lt}=useToggle($t),Ft=useStoreContext(),Ct=([Gt,jt])=>{var qt;return(isInput(jt)?(qt=Ft.getInput(jt.path))===null||qt===void 0?void 0:qt.order:Ft.getFolderSettings(join(vt,Gt)).order)||0},Ht=Object.entries(wt).sort((Gt,jt)=>Ct(Gt)-Ct(jt));return React.createElement(StyledWrapper,{ref:Tt,isRoot:st,fill:at,flat:pt},React.createElement(StyledContent,{ref:Lt,isRoot:st,toggled:$t},Ht.map(([Gt,jt])=>isInput(jt)?React.createElement(Control,{key:jt.path,valueKey:jt.valueKey,path:jt.path}):React.createElement(Folder,{key:Gt,name:Gt,path:vt,tree:jt}))))}),StyledRoot=styled("div",{position:"relative",fontFamily:"$mono",fontSize:"$root",color:"$rootText",backgroundColor:"$elevation1",variants:{fill:{false:{position:"fixed",top:"10px",right:"10px",zIndex:1e3,width:"$rootWidth"},true:{position:"relative",width:"100%"}},flat:{false:{borderRadius:"$lg",boxShadow:"$level1"}},oneLineLabels:{true:{[`${StyledInputRow}`]:{gridTemplateColumns:"auto",gridAutoColumns:"minmax(max-content, 1fr)",gridAutoRows:"minmax($sizes$rowHeight), auto)",rowGap:0,columnGap:0,marginTop:"$rowGap"}}},hideTitleBar:{true:{$$titleBarHeight:"0px"},false:{$$titleBarHeight:"$sizes$titleBarHeight"}}},"&,*,*:after,*:before":{boxSizing:"border-box"},"*::selection":{backgroundColor:"$accent2"}}),iconWidth=40,Icon=styled("i",{$flexCenter:"",width:iconWidth,userSelect:"none",cursor:"pointer","> svg":{fill:"$highlight1",transition:"transform 350ms ease, fill 250ms ease"},"&:hover > svg":{fill:"$highlight3"},variants:{active:{true:{"> svg":{fill:"$highlight2"}}}}}),StyledTitleWithFilter=styled("div",{display:"flex",alignItems:"stretch",justifyContent:"space-between",height:"$titleBarHeight",variants:{mode:{drag:{cursor:"grab"}}}}),FilterWrapper=styled("div",{$flex:"",position:"relative",width:"100%",overflow:"hidden",transition:"height 250ms ease",color:"$highlight3",paddingLeft:"$md",[`> ${Icon}`]:{height:30},variants:{toggled:{true:{height:30},false:{height:0}}}}),StyledFilterInput=styled("input",{$reset:"",flex:1,position:"relative",height:30,width:"100%",backgroundColor:"transparent",fontSize:"10px",borderRadius:"$root","&:focus":{},"&::placeholder":{color:"$highlight2"}}),TitleContainer=styled("div",{touchAction:"none",$flexCenter:"",flex:1,"> svg":{fill:"$highlight1"},color:"$highlight1",variants:{drag:{true:{$draggable:"","> svg":{transition:"fill 250ms ease"},"&:hover":{color:"$highlight3"},"&:hover > svg":{fill:"$highlight3"}}},filterEnabled:{false:{paddingRight:iconWidth}}}}),FilterInput=React.forwardRef(({setFilter:st,toggle:at},pt)=>{const[vt,wt]=reactExports.useState(""),$t=reactExports.useMemo(()=>debounce(st,250),[st]),Tt=()=>{st(""),wt("")},Lt=Ft=>{const Ct=Ft.currentTarget.value;at(!0),wt(Ct)};return reactExports.useEffect(()=>{$t(vt)},[vt,$t]),React.createElement(React.Fragment,null,React.createElement(StyledFilterInput,{ref:pt,value:vt,placeholder:"[Open filter with CMD+SHIFT+L]",onPointerDown:Ft=>Ft.stopPropagation(),onChange:Lt}),React.createElement(Icon,{onClick:()=>Tt(),style:{visibility:vt?"visible":"hidden"}},React.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",height:"14",width:"14",viewBox:"0 0 20 20",fill:"currentColor"},React.createElement("path",{fillRule:"evenodd",d:"M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",clipRule:"evenodd"}))))});function TitleWithFilter({setFilter:st,onDrag:at,onDragStart:pt,onDragEnd:vt,toggle:wt,toggled:$t,title:Tt,drag:Lt,filterEnabled:Ft,from:Ct}){const[Ht,Gt]=reactExports.useState(!1),jt=reactExports.useRef(null);reactExports.useEffect(()=>{var Kt,An;Ht?(Kt=jt.current)===null||Kt===void 0||Kt.focus():(An=jt.current)===null||An===void 0||An.blur()},[Ht]);const qt=useDrag(({offset:[Kt,An],first:Sn,last:wn})=>{at({x:Kt,y:An}),Sn&&pt({x:Kt,y:An}),wn&&vt({x:Kt,y:An})},{filterTaps:!0,from:({offset:[Kt,An]})=>[(Ct==null?void 0:Ct.x)||Kt,(Ct==null?void 0:Ct.y)||An]});return reactExports.useEffect(()=>{const Kt=An=>{An.key==="L"&&An.shiftKey&&An.metaKey&&Gt(Sn=>!Sn)};return window.addEventListener("keydown",Kt),()=>window.removeEventListener("keydown",Kt)},[]),React.createElement(React.Fragment,null,React.createElement(StyledTitleWithFilter,{mode:Lt?"drag":void 0},React.createElement(Icon,{active:!$t,onClick:()=>wt()},React.createElement(Chevron,{toggled:$t,width:12,height:8})),React.createElement(TitleContainer,_extends({},Lt?qt():{},{drag:Lt,filterEnabled:Ft}),Tt===void 0&&Lt?React.createElement("svg",{width:"20",height:"10",viewBox:"0 0 28 14",xmlns:"http://www.w3.org/2000/svg"},React.createElement("circle",{cx:"2",cy:"2",r:"2"}),React.createElement("circle",{cx:"14",cy:"2",r:"2"}),React.createElement("circle",{cx:"26",cy:"2",r:"2"}),React.createElement("circle",{cx:"2",cy:"12",r:"2"}),React.createElement("circle",{cx:"14",cy:"12",r:"2"}),React.createElement("circle",{cx:"26",cy:"12",r:"2"})):Tt),Ft&&React.createElement(Icon,{active:Ht,onClick:()=>Gt(Kt=>!Kt)},React.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",height:"20",viewBox:"0 0 20 20"},React.createElement("path",{d:"M9 9a2 2 0 114 0 2 2 0 01-4 0z"}),React.createElement("path",{fillRule:"evenodd",d:"M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a4 4 0 00-3.446 6.032l-2.261 2.26a1 1 0 101.414 1.415l2.261-2.261A4 4 0 1011 5z",clipRule:"evenodd"})))),React.createElement(FilterWrapper,{toggled:Ht},React.createElement(FilterInput,{ref:jt,setFilter:st,toggle:wt})))}const _excluded$2=["store","hidden","theme","collapsed"];function LevaRoot(st){let{store:at,hidden:pt=!1,theme:vt,collapsed:wt=!1}=st,$t=_objectWithoutProperties$1(st,_excluded$2);const Tt=useDeepMemo(()=>mergeTheme(vt),[vt]),[Lt,Ft]=reactExports.useState(!wt),Ct=typeof wt=="object"?!wt.collapsed:Lt,Ht=reactExports.useMemo(()=>typeof wt=="object"?Gt=>{typeof Gt=="function"?wt.onChange(!Gt(!wt.collapsed)):wt.onChange(!Gt)}:Ft,[wt]);return!at||pt?null:React.createElement(ThemeContext.Provider,{value:Tt},React.createElement(LevaCore,_extends({store:at},$t,{toggled:Ct,setToggle:Ht,rootClass:Tt.className})))}const LevaCore=React.memo(({store:st,rootClass:at,fill:pt=!1,flat:vt=!1,neverHide:wt=!1,oneLineLabels:$t=!1,titleBar:Tt={title:void 0,drag:!0,filter:!0,position:void 0,onDrag:void 0,onDragStart:void 0,onDragEnd:void 0},hideCopyButton:Lt=!1,toggled:Ft,setToggle:Ct})=>{var Ht,Gt;const jt=useVisiblePaths(st),[qt,Kt]=reactExports.useState(""),An=reactExports.useMemo(()=>buildTree(jt,qt),[jt,qt]),[Sn,wn]=useTransform(),In=wt||jt.length>0,tr=typeof Tt=="object"&&Tt.title||void 0,rr=typeof Tt=="object"&&(Ht=Tt.drag)!==null&&Ht!==void 0?Ht:!0,Hr=typeof Tt=="object"&&(Gt=Tt.filter)!==null&&Gt!==void 0?Gt:!0,qr=typeof Tt=="object"&&Tt.position||void 0,Zr=typeof Tt=="object"&&Tt.onDrag||void 0,Bo=typeof Tt=="object"&&Tt.onDragStart||void 0,Xo=typeof Tt=="object"&&Tt.onDragEnd||void 0;return React.useEffect(()=>{wn({x:qr==null?void 0:qr.x,y:qr==null?void 0:qr.y})},[qr,wn]),globalStyles(),React.createElement(PanelSettingsContext.Provider,{value:{hideCopyButton:Lt}},React.createElement(StyledRoot,{ref:Sn,className:at,fill:pt,flat:vt,oneLineLabels:$t,hideTitleBar:!Tt,style:{display:In?"block":"none"}},Tt&&React.createElement(TitleWithFilter,{onDrag:Kr=>{wn(Kr),Zr==null||Zr(Kr)},onDragStart:Kr=>Bo==null?void 0:Bo(Kr),onDragEnd:Kr=>Xo==null?void 0:Xo(Kr),setFilter:Kt,toggle:Kr=>Ct(ko=>Kr??!ko),toggled:Ft,title:tr,drag:rr,filterEnabled:Hr,from:qr}),In&&React.createElement(StoreContext.Provider,{value:st},React.createElement(TreeWrapper,{isRoot:!0,fill:pt,flat:vt,tree:An,toggled:Ft}))))}),_excluded$1=["isRoot"];let rootInitialized=!1,rootEl=null;function Leva(st){let{isRoot:at=!1}=st,pt=_objectWithoutProperties$1(st,_excluded$1);return reactExports.useEffect(()=>(rootInitialized=!0,!at&&rootEl&&(rootEl.remove(),rootEl=null),()=>{at||(rootInitialized=!1)}),[at]),React.createElement(LevaRoot,_extends({store:levaStore},pt))}function useRenderRoot(st){reactExports.useEffect(()=>{st&&!rootInitialized&&(rootEl||(rootEl=document.getElementById("leva__root")||Object.assign(document.createElement("div"),{id:"leva__root"}),document.body&&(document.body.appendChild(rootEl),render(React.createElement(Leva,{isRoot:!0}),rootEl))),rootInitialized=!0)},[st])}function parseArgs(st,at,pt,vt,wt){let $t,Tt,Lt,Ft,Ct;return typeof st=="string"?(Tt=st,$t=at,Array.isArray(pt)&&(Ct=pt)):($t=st,Array.isArray(at)?Ct=at:(Ft=at,Ct=pt)),{schema:$t,folderName:Tt,folderSettings:Lt,hookSettings:Ft,deps:Ct||[]}}function useControls(st,at,pt,vt,wt){const{folderName:$t,schema:Tt,folderSettings:Lt,hookSettings:Ft,deps:Ct}=parseArgs(st,at,pt),Ht=typeof Tt=="function",Gt=reactExports.useRef(!1),jt=reactExports.useRef(!0),qt=useDeepMemo(()=>{Gt.current=!0;const ko=typeof Tt=="function"?Tt():Tt;return $t?{[$t]:folder(ko,Lt)}:ko},Ct),Kt=!(Ft!=null&&Ft.store);useRenderRoot(Kt);const[An]=reactExports.useState(()=>(Ft==null?void 0:Ft.store)||levaStore),[Sn,wn]=reactExports.useMemo(()=>An.getDataFromSchema(qt),[An,qt]),[In,tr,rr,Hr,qr]=reactExports.useMemo(()=>{const ko=[],f0=[],x0={},l0={},T0={};return Object.values(wn).forEach(({path:t0,onChange:E0,onEditStart:n0,onEditEnd:m0,transient:h0})=>{ko.push(t0),E0?(x0[t0]=E0,h0||f0.push(t0)):f0.push(t0),n0&&(l0[t0]=n0),m0&&(T0[t0]=m0)}),[ko,f0,x0,l0,T0]},[wn]),Zr=reactExports.useMemo(()=>An.orderPaths(In),[In,An]),Bo=useValuesForPath(An,tr,Sn),Xo=reactExports.useCallback(ko=>{const f0=Object.entries(ko).reduce((x0,[l0,T0])=>Object.assign(x0,{[wn[l0].path]:T0}),{});An.set(f0,!1)},[An,wn]),Kr=reactExports.useCallback(ko=>An.get(wn[ko].path),[An,wn]);return reactExports.useEffect(()=>{const ko=!jt.current&&Gt.current;return An.addData(Sn,ko),jt.current=!1,Gt.current=!1,()=>An.disposePaths(Zr)},[An,Zr,Sn]),reactExports.useEffect(()=>{const ko=[];return Object.entries(rr).forEach(([f0,x0])=>{x0(An.get(f0),f0,_objectSpread2({initial:!0,get:An.get},An.getInput(f0)));const l0=An.useStore.subscribe(T0=>{const t0=T0.data[f0];return[t0.disabled?void 0:t0.value,t0]},([T0,t0])=>x0(T0,f0,_objectSpread2({initial:!1,get:An.get},t0)),{equalityFn:shallow});ko.push(l0)}),()=>ko.forEach(f0=>f0())},[An,rr]),reactExports.useEffect(()=>{const ko=[];return Object.entries(Hr).forEach(([f0,x0])=>ko.push(An.subscribeToEditStart(f0,x0))),Object.entries(qr).forEach(([f0,x0])=>ko.push(An.subscribeToEditEnd(f0,x0))),()=>ko.forEach(f0=>f0())},[Hr,qr,An]),Ht?[Bo,Xo,Kr]:Bo}register(LevaInputs.SELECT,select);register(LevaInputs.IMAGE,image);register(LevaInputs.NUMBER,number$1);register(LevaInputs.COLOR,color);register(LevaInputs.STRING,string);register(LevaInputs.BOOLEAN,boolean);register(LevaInputs.INTERVAL,interval);register(LevaInputs.VECTOR3D,vector3d);register(LevaInputs.VECTOR2D,vector2d);const Pane=({setParentHexColor:st,setParentScale:at,setParentTexture:pt,handleFileUpload:vt})=>{const wt=Gt=>parseInt(Gt.slice(1),16),$t=()=>{const Gt=document.querySelector("canvas");if(Gt){const jt=document.createElement("a");jt.setAttribute("download","canvas.png");const qt=Gt.toDataURL("image/png").replace("image/png","image/octet-stream");jt.setAttribute("href",qt),jt.click()}else console.error("Canvas element not found.")},{color:Tt,upload:Lt,scale:Ft,texture:Ct}=useControls({color:"#fff",texture:{value:"None",options:["None","Wool","Cotton"]},scale:{x:1,y:1,z:1},upload:{image:void 0},download:button(()=>$t())});async function Ht(Gt){const qt=await(await fetch(Gt)).blob(),Kt=Gt.substring(Gt.lastIndexOf("/")+1);return new File([qt],Kt,{type:qt.type})}return reactExports.useEffect(()=>{Lt&&(console.log("From Pane Upload"),Ht(Lt).then(Gt=>{vt(Gt),console.log("From Pane File:",Gt)}).catch(Gt=>{console.error("Error:",Gt)}))},[Lt]),reactExports.useEffect(()=>{Ft&&at(new Vector3(Ft.x,Ft.y,Ft.z))},[Ft]),reactExports.useEffect(()=>{Ct&&pt(Ct)},[Ct]),reactExports.useEffect(()=>{Tt&&st(wt(Tt))},[Tt]),jsxRuntimeExports.jsx("div",{})};function iota$1(st){for(var at=new Array(st),pt=0;pt<st;++pt)at[pt]=pt;return at}var iota_1=iota$1;/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */var isBuffer_1=function(st){return st!=null&&(isBuffer$1(st)||isSlowBuffer(st)||!!st._isBuffer)};function isBuffer$1(st){return!!st.constructor&&typeof st.constructor.isBuffer=="function"&&st.constructor.isBuffer(st)}function isSlowBuffer(st){return typeof st.readFloatLE=="function"&&typeof st.slice=="function"&&isBuffer$1(st.slice(0,0))}var iota=iota_1,isBuffer=isBuffer_1,hasTypedArrays=typeof Float64Array<"u";function compare1st(st,at){return st[0]-at[0]}function order(){var st=this.stride,at=new Array(st.length),pt;for(pt=0;pt<at.length;++pt)at[pt]=[Math.abs(st[pt]),pt];at.sort(compare1st);var vt=new Array(at.length);for(pt=0;pt<vt.length;++pt)vt[pt]=at[pt][1];return vt}function compileConstructor(st,at){var pt=["View",at,"d",st].join("");at<0&&(pt="View_Nil"+st);var vt=st==="generic";if(at===-1){var wt="function "+pt+"(a){this.data=a;};var proto="+pt+".prototype;proto.dtype='"+st+"';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new "+pt+"(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_"+pt+"(a){return new "+pt+"(a);}",An=new Function(wt);return An()}else if(at===0){var wt="function "+pt+"(a,d) {this.data = a;this.offset = d};var proto="+pt+".prototype;proto.dtype='"+st+"';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function "+pt+"_copy() {return new "+pt+"(this.data,this.offset)};proto.pick=function "+pt+"_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function "+pt+"_get(){return "+(vt?"this.data.get(this.offset)":"this.data[this.offset]")+"};proto.set=function "+pt+"_set(v){return "+(vt?"this.data.set(this.offset,v)":"this.data[this.offset]=v")+"};return function construct_"+pt+"(a,b,c,d){return new "+pt+"(a,d)}",An=new Function("TrivialArray",wt);return An(CACHED_CONSTRUCTORS[st][0])}var wt=["'use strict'"],$t=iota(at),Tt=$t.map(function(Sn){return"i"+Sn}),Lt="this.offset+"+$t.map(function(Sn){return"this.stride["+Sn+"]*i"+Sn}).join("+"),Ft=$t.map(function(Sn){return"b"+Sn}).join(","),Ct=$t.map(function(Sn){return"c"+Sn}).join(",");wt.push("function "+pt+"(a,"+Ft+","+Ct+",d){this.data=a","this.shape=["+Ft+"]","this.stride=["+Ct+"]","this.offset=d|0}","var proto="+pt+".prototype","proto.dtype='"+st+"'","proto.dimension="+at),wt.push("Object.defineProperty(proto,'size',{get:function "+pt+"_size(){return "+$t.map(function(Sn){return"this.shape["+Sn+"]"}).join("*"),"}})"),at===1?wt.push("proto.order=[0]"):(wt.push("Object.defineProperty(proto,'order',{get:"),at<4?(wt.push("function "+pt+"_order(){"),at===2?wt.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})"):at===3&&wt.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})")):wt.push("ORDER})")),wt.push("proto.set=function "+pt+"_set("+Tt.join(",")+",v){"),vt?wt.push("return this.data.set("+Lt+",v)}"):wt.push("return this.data["+Lt+"]=v}"),wt.push("proto.get=function "+pt+"_get("+Tt.join(",")+"){"),vt?wt.push("return this.data.get("+Lt+")}"):wt.push("return this.data["+Lt+"]}"),wt.push("proto.index=function "+pt+"_index(",Tt.join(),"){return "+Lt+"}"),wt.push("proto.hi=function "+pt+"_hi("+Tt.join(",")+"){return new "+pt+"(this.data,"+$t.map(function(Sn){return["(typeof i",Sn,"!=='number'||i",Sn,"<0)?this.shape[",Sn,"]:i",Sn,"|0"].join("")}).join(",")+","+$t.map(function(Sn){return"this.stride["+Sn+"]"}).join(",")+",this.offset)}");var Ht=$t.map(function(Sn){return"a"+Sn+"=this.shape["+Sn+"]"}),Gt=$t.map(function(Sn){return"c"+Sn+"=this.stride["+Sn+"]"});wt.push("proto.lo=function "+pt+"_lo("+Tt.join(",")+"){var b=this.offset,d=0,"+Ht.join(",")+","+Gt.join(","));for(var jt=0;jt<at;++jt)wt.push("if(typeof i"+jt+"==='number'&&i"+jt+">=0){d=i"+jt+"|0;b+=c"+jt+"*d;a"+jt+"-=d}");wt.push("return new "+pt+"(this.data,"+$t.map(function(Sn){return"a"+Sn}).join(",")+","+$t.map(function(Sn){return"c"+Sn}).join(",")+",b)}"),wt.push("proto.step=function "+pt+"_step("+Tt.join(",")+"){var "+$t.map(function(Sn){return"a"+Sn+"=this.shape["+Sn+"]"}).join(",")+","+$t.map(function(Sn){return"b"+Sn+"=this.stride["+Sn+"]"}).join(",")+",c=this.offset,d=0,ceil=Math.ceil");for(var jt=0;jt<at;++jt)wt.push("if(typeof i"+jt+"==='number'){d=i"+jt+"|0;if(d<0){c+=b"+jt+"*(a"+jt+"-1);a"+jt+"=ceil(-a"+jt+"/d)}else{a"+jt+"=ceil(a"+jt+"/d)}b"+jt+"*=d}");wt.push("return new "+pt+"(this.data,"+$t.map(function(Sn){return"a"+Sn}).join(",")+","+$t.map(function(Sn){return"b"+Sn}).join(",")+",c)}");for(var qt=new Array(at),Kt=new Array(at),jt=0;jt<at;++jt)qt[jt]="a[i"+jt+"]",Kt[jt]="b[i"+jt+"]";wt.push("proto.transpose=function "+pt+"_transpose("+Tt+"){"+Tt.map(function(Sn,wn){return Sn+"=("+Sn+"===undefined?"+wn+":"+Sn+"|0)"}).join(";"),"var a=this.shape,b=this.stride;return new "+pt+"(this.data,"+qt.join(",")+","+Kt.join(",")+",this.offset)}"),wt.push("proto.pick=function "+pt+"_pick("+Tt+"){var a=[],b=[],c=this.offset");for(var jt=0;jt<at;++jt)wt.push("if(typeof i"+jt+"==='number'&&i"+jt+">=0){c=(c+this.stride["+jt+"]*i"+jt+")|0}else{a.push(this.shape["+jt+"]);b.push(this.stride["+jt+"])}");wt.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"),wt.push("return function construct_"+pt+"(data,shape,stride,offset){return new "+pt+"(data,"+$t.map(function(Sn){return"shape["+Sn+"]"}).join(",")+","+$t.map(function(Sn){return"stride["+Sn+"]"}).join(",")+",offset)}");var An=new Function("CTOR_LIST","ORDER",wt.join(`
`));return An(CACHED_CONSTRUCTORS[st],order)}function arrayDType(st){if(isBuffer(st))return"buffer";if(hasTypedArrays)switch(Object.prototype.toString.call(st)){case"[object Float64Array]":return"float64";case"[object Float32Array]":return"float32";case"[object Int8Array]":return"int8";case"[object Int16Array]":return"int16";case"[object Int32Array]":return"int32";case"[object Uint8Array]":return"uint8";case"[object Uint16Array]":return"uint16";case"[object Uint32Array]":return"uint32";case"[object Uint8ClampedArray]":return"uint8_clamped";case"[object BigInt64Array]":return"bigint64";case"[object BigUint64Array]":return"biguint64"}return Array.isArray(st)?"array":"generic"}var CACHED_CONSTRUCTORS={float32:[],float64:[],int8:[],int16:[],int32:[],uint8:[],uint16:[],uint32:[],array:[],uint8_clamped:[],bigint64:[],biguint64:[],buffer:[],generic:[]};function wrappedNDArrayCtor(st,at,pt,vt){if(st===void 0){var Ct=CACHED_CONSTRUCTORS.array[0];return Ct([])}else typeof st=="number"&&(st=[st]);at===void 0&&(at=[st.length]);var wt=at.length;if(pt===void 0){pt=new Array(wt);for(var $t=wt-1,Tt=1;$t>=0;--$t)pt[$t]=Tt,Tt*=at[$t]}if(vt===void 0){vt=0;for(var $t=0;$t<wt;++$t)pt[$t]<0&&(vt-=(at[$t]-1)*pt[$t])}for(var Lt=arrayDType(st),Ft=CACHED_CONSTRUCTORS[Lt];Ft.length<=wt+1;)Ft.push(compileConstructor(Lt,Ft.length-1));var Ct=Ft[wt+1];return Ct(st,at,pt,vt)}var ndarray=wrappedNDArrayCtor;const ndarray4=getDefaultExportFromCjs(ndarray);/*!
 * ONNX Runtime Web v1.18.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var vd$1=Object.create,Pn$1=Object.defineProperty,_d$1=Object.getOwnPropertyDescriptor,Od$1=Object.getOwnPropertyNames,Id$1=Object.getPrototypeOf,Sd$1=Object.prototype.hasOwnProperty,L=(st,at)=>()=>(st&&(at=st(st=0)),at),me=(st,at)=>()=>(at||st((at={exports:{}}).exports,at),at.exports),Sr=(st,at)=>{for(var pt in at)Pn$1(st,pt,{get:at[pt],enumerable:!0})},Va$1=(st,at,pt,vt)=>{if(at&&typeof at=="object"||typeof at=="function")for(let wt of Od$1(at))!Sd$1.call(st,wt)&&wt!==pt&&Pn$1(st,wt,{get:()=>at[wt],enumerable:!(vt=_d$1(at,wt))||vt.enumerable});return st},Ar=(st,at,pt)=>(pt=st!=null?vd$1(Id$1(st)):{},Va$1(!st||!st.__esModule?Pn$1(pt,"default",{value:st,enumerable:!0}):pt,st)),ar=st=>Va$1(Pn$1({},"__esModule",{value:!0}),st),En,sr$1,Pr$1,Ad$1,Dn$1,Ln$1=L(()=>{En=new Map,sr$1=[],Pr$1=(st,at,pt)=>{if(at&&typeof at.init=="function"&&typeof at.createInferenceSessionHandler=="function"){let vt=En.get(st);if(vt===void 0)En.set(st,{backend:at,priority:pt});else{if(vt.priority>pt)return;if(vt.priority===pt&&vt.backend!==at)throw new Error(`cannot register backend "${st}" using priority ${pt}`)}if(pt>=0){let wt=sr$1.indexOf(st);wt!==-1&&sr$1.splice(wt,1);for(let $t=0;$t<sr$1.length;$t++)if(En.get(sr$1[$t]).priority<=pt){sr$1.splice($t,0,st);return}sr$1.push(st)}return}throw new TypeError("not a valid backend")},Ad$1=async st=>{let at=En.get(st);if(!at)return"backend not found.";if(at.initialized)return at.backend;if(at.aborted)return at.error;{let pt=!!at.initPromise;try{return pt||(at.initPromise=at.backend.init(st)),await at.initPromise,at.initialized=!0,at.backend}catch(vt){return pt||(at.error=`${vt}`,at.aborted=!0),at.error}finally{delete at.initPromise}}},Dn$1=async st=>{let at=st.executionProviders||[],pt=at.map(Ft=>typeof Ft=="string"?Ft:Ft.name),vt=pt.length===0?sr$1:pt,wt,$t=[],Tt=new Set;for(let Ft of vt){let Ct=await Ad$1(Ft);typeof Ct=="string"?$t.push({name:Ft,err:Ct}):(wt||(wt=Ct),wt===Ct&&Tt.add(Ft))}if(!wt)throw new Error(`no available backend found. ERR: ${$t.map(Ft=>`[${Ft.name}] ${Ft.err}`).join(", ")}`);for(let{name:Ft,err:Ct}of $t)pt.includes(Ft)&&console.warn(`removing requested execution provider "${Ft}" from session options because it is not available: ${Ct}`);let Lt=at.filter(Ft=>Tt.has(typeof Ft=="string"?Ft:Ft.name));return[wt,new Proxy(st,{get:(Ft,Ct)=>Ct==="executionProviders"?Lt:Reflect.get(Ft,Ct)})]}}),Wa=L(()=>{Ln$1()}),Ha$1,qa$1=L(()=>{Ha$1="1.18.0"}),ja$1,ut$1,Vo=L(()=>{qa$1(),ja$1="warning",ut$1={wasm:{},webgl:{},webgpu:{},versions:{common:Ha$1},set logLevel(st){if(st!==void 0){if(typeof st!="string"||["verbose","info","warning","error","fatal"].indexOf(st)===-1)throw new Error(`Unsupported logging level: ${st}`);ja$1=st}},get logLevel(){return ja$1}},Object.defineProperty(ut$1,"logLevel",{enumerable:!0})}),Z,Ya$1=L(()=>{Vo(),Z=ut$1}),Xa$1,Ka$1,Ja$1=L(()=>{Xa$1=(st,at)=>{let pt=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);pt.width=st.dims[3],pt.height=st.dims[2];let vt=pt.getContext("2d");if(vt!=null){let wt,$t;(at==null?void 0:at.tensorLayout)!==void 0&&at.tensorLayout==="NHWC"?(wt=st.dims[2],$t=st.dims[3]):(wt=st.dims[3],$t=st.dims[2]);let Tt=(at==null?void 0:at.format)!==void 0?at.format:"RGB",Lt=at==null?void 0:at.norm,Ft,Ct;Lt===void 0||Lt.mean===void 0?Ft=[255,255,255,255]:typeof Lt.mean=="number"?Ft=[Lt.mean,Lt.mean,Lt.mean,Lt.mean]:(Ft=[Lt.mean[0],Lt.mean[1],Lt.mean[2],0],Lt.mean[3]!==void 0&&(Ft[3]=Lt.mean[3])),Lt===void 0||Lt.bias===void 0?Ct=[0,0,0,0]:typeof Lt.bias=="number"?Ct=[Lt.bias,Lt.bias,Lt.bias,Lt.bias]:(Ct=[Lt.bias[0],Lt.bias[1],Lt.bias[2],0],Lt.bias[3]!==void 0&&(Ct[3]=Lt.bias[3]));let Ht=$t*wt,Gt=0,jt=Ht,qt=Ht*2,Kt=-1;Tt==="RGBA"?(Gt=0,jt=Ht,qt=Ht*2,Kt=Ht*3):Tt==="RGB"?(Gt=0,jt=Ht,qt=Ht*2):Tt==="RBG"&&(Gt=0,qt=Ht,jt=Ht*2);for(let An=0;An<$t;An++)for(let Sn=0;Sn<wt;Sn++){let wn=(st.data[Gt++]-Ct[0])*Ft[0],In=(st.data[jt++]-Ct[1])*Ft[1],tr=(st.data[qt++]-Ct[2])*Ft[2],rr=Kt===-1?255:(st.data[Kt++]-Ct[3])*Ft[3];vt.fillStyle="rgba("+wn+","+In+","+tr+","+rr+")",vt.fillRect(Sn,An,1,1)}if("toDataURL"in pt)return pt.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Ka$1=(st,at)=>{let pt=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),vt;if(pt!=null){let wt,$t,Tt;(at==null?void 0:at.tensorLayout)!==void 0&&at.tensorLayout==="NHWC"?(wt=st.dims[2],$t=st.dims[1],Tt=st.dims[3]):(wt=st.dims[3],$t=st.dims[2],Tt=st.dims[1]);let Lt=at!==void 0&&at.format!==void 0?at.format:"RGB",Ft=at==null?void 0:at.norm,Ct,Ht;Ft===void 0||Ft.mean===void 0?Ct=[255,255,255,255]:typeof Ft.mean=="number"?Ct=[Ft.mean,Ft.mean,Ft.mean,Ft.mean]:(Ct=[Ft.mean[0],Ft.mean[1],Ft.mean[2],255],Ft.mean[3]!==void 0&&(Ct[3]=Ft.mean[3])),Ft===void 0||Ft.bias===void 0?Ht=[0,0,0,0]:typeof Ft.bias=="number"?Ht=[Ft.bias,Ft.bias,Ft.bias,Ft.bias]:(Ht=[Ft.bias[0],Ft.bias[1],Ft.bias[2],0],Ft.bias[3]!==void 0&&(Ht[3]=Ft.bias[3]));let Gt=$t*wt;if(at!==void 0&&(at.format!==void 0&&Tt===4&&at.format!=="RGBA"||Tt===3&&at.format!=="RGB"&&at.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let jt=4,qt=0,Kt=1,An=2,Sn=3,wn=0,In=Gt,tr=Gt*2,rr=-1;Lt==="RGBA"?(wn=0,In=Gt,tr=Gt*2,rr=Gt*3):Lt==="RGB"?(wn=0,In=Gt,tr=Gt*2):Lt==="RBG"&&(wn=0,tr=Gt,In=Gt*2),vt=pt.createImageData(wt,$t);for(let Hr=0;Hr<$t*wt;qt+=jt,Kt+=jt,An+=jt,Sn+=jt,Hr++)vt.data[qt]=(st.data[wn++]-Ht[0])*Ct[0],vt.data[Kt]=(st.data[In++]-Ht[1])*Ct[1],vt.data[An]=(st.data[tr++]-Ht[2])*Ct[2],vt.data[Sn]=rr===-1?255:(st.data[rr++]-Ht[3])*Ct[3]}else throw new Error("Can not access image data");return vt}}),Wo,Za$1,Qa$1,es$1,ts$1,rs$1=L(()=>{Cn(),Wo=(st,at)=>{if(st===void 0)throw new Error("Image buffer must be defined");if(at.height===void 0||at.width===void 0)throw new Error("Image height and width must be defined");if(at.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:pt,width:vt}=at,wt=at.norm??{mean:255,bias:0},$t,Tt;typeof wt.mean=="number"?$t=[wt.mean,wt.mean,wt.mean,wt.mean]:$t=[wt.mean[0],wt.mean[1],wt.mean[2],wt.mean[3]??255],typeof wt.bias=="number"?Tt=[wt.bias,wt.bias,wt.bias,wt.bias]:Tt=[wt.bias[0],wt.bias[1],wt.bias[2],wt.bias[3]??0];let Lt=at.format!==void 0?at.format:"RGBA",Ft=at.tensorFormat!==void 0&&at.tensorFormat!==void 0?at.tensorFormat:"RGB",Ct=pt*vt,Ht=Ft==="RGBA"?new Float32Array(Ct*4):new Float32Array(Ct*3),Gt=4,jt=0,qt=1,Kt=2,An=3,Sn=0,wn=Ct,In=Ct*2,tr=-1;Lt==="RGB"&&(Gt=3,jt=0,qt=1,Kt=2,An=-1),Ft==="RGBA"?tr=Ct*3:Ft==="RBG"?(Sn=0,In=Ct,wn=Ct*2):Ft==="BGR"&&(In=0,wn=Ct,Sn=Ct*2);for(let rr=0;rr<Ct;rr++,jt+=Gt,Kt+=Gt,qt+=Gt,An+=Gt)Ht[Sn++]=(st[jt]+Tt[0])/$t[0],Ht[wn++]=(st[qt]+Tt[1])/$t[1],Ht[In++]=(st[Kt]+Tt[2])/$t[2],tr!==-1&&An!==-1&&(Ht[tr++]=(st[An]+Tt[3])/$t[3]);return Ft==="RGBA"?new Je("float32",Ht,[1,4,pt,vt]):new Je("float32",Ht,[1,3,pt,vt])},Za$1=async(st,at)=>{let pt=typeof HTMLImageElement<"u"&&st instanceof HTMLImageElement,vt=typeof ImageData<"u"&&st instanceof ImageData,wt=typeof ImageBitmap<"u"&&st instanceof ImageBitmap,$t=typeof st=="string",Tt,Lt=at??{},Ft=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},Ct=Ht=>Ht instanceof HTMLCanvasElement||Ht instanceof OffscreenCanvas?Ht.getContext("2d"):null;if(pt){let Ht=Ft();Ht.width=st.width,Ht.height=st.height;let Gt=Ct(Ht);if(Gt!=null){let jt=st.height,qt=st.width;if(at!==void 0&&at.resizedHeight!==void 0&&at.resizedWidth!==void 0&&(jt=at.resizedHeight,qt=at.resizedWidth),at!==void 0){if(Lt=at,at.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");Lt.tensorFormat="RGBA",Lt.height=jt,Lt.width=qt}else Lt.tensorFormat="RGBA",Lt.height=jt,Lt.width=qt;Gt.drawImage(st,0,0),Tt=Gt.getImageData(0,0,qt,jt).data}else throw new Error("Can not access image data")}else if(vt){let Ht,Gt;if(at!==void 0&&at.resizedWidth!==void 0&&at.resizedHeight!==void 0?(Ht=at.resizedHeight,Gt=at.resizedWidth):(Ht=st.height,Gt=st.width),at!==void 0&&(Lt=at),Lt.format="RGBA",Lt.height=Ht,Lt.width=Gt,at!==void 0){let jt=Ft();jt.width=Gt,jt.height=Ht;let qt=Ct(jt);if(qt!=null)qt.putImageData(st,0,0),Tt=qt.getImageData(0,0,Gt,Ht).data;else throw new Error("Can not access image data")}else Tt=st.data}else if(wt){if(at===void 0)throw new Error("Please provide image config with format for Imagebitmap");let Ht=Ft();Ht.width=st.width,Ht.height=st.height;let Gt=Ct(Ht);if(Gt!=null){let jt=st.height,qt=st.width;return Gt.drawImage(st,0,0,qt,jt),Tt=Gt.getImageData(0,0,qt,jt).data,Lt.height=jt,Lt.width=qt,Wo(Tt,Lt)}else throw new Error("Can not access image data")}else{if($t)return new Promise((Ht,Gt)=>{let jt=Ft(),qt=Ct(jt);if(!st||!qt)return Gt();let Kt=new Image;Kt.crossOrigin="Anonymous",Kt.src=st,Kt.onload=()=>{jt.width=Kt.width,jt.height=Kt.height,qt.drawImage(Kt,0,0,jt.width,jt.height);let An=qt.getImageData(0,0,jt.width,jt.height);Lt.height=jt.height,Lt.width=jt.width,Ht(Wo(An.data,Lt))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(Tt!==void 0)return Wo(Tt,Lt);throw new Error("Input data provided is not supported - aborted tensor creation")},Qa$1=(st,at)=>{let{width:pt,height:vt,download:wt,dispose:$t}=at,Tt=[1,vt,pt,4];return new Je({location:"texture",type:"float32",texture:st,dims:Tt,download:wt,dispose:$t})},es$1=(st,at)=>{let{dataType:pt,dims:vt,download:wt,dispose:$t}=at;return new Je({location:"gpu-buffer",type:pt??"float32",gpuBuffer:st,dims:vt,download:wt,dispose:$t})},ts$1=(st,at,pt)=>new Je({location:"cpu-pinned",type:st,data:at,dims:pt??[at.length]})}),ur$1,Qr$1,ns,os$1,is$1=L(()=>{ur$1=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Qr$1=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),ns=!1,os$1=()=>{if(!ns){ns=!0;let st=typeof BigInt64Array<"u"&&BigInt64Array.from,at=typeof BigUint64Array<"u"&&BigUint64Array.from,pt=typeof Float16Array<"u"&&Float16Array.from;st&&(ur$1.set("int64",BigInt64Array),Qr$1.set(BigInt64Array,"int64")),at&&(ur$1.set("uint64",BigUint64Array),Qr$1.set(BigUint64Array,"uint64")),pt?(ur$1.set("float16",Float16Array),Qr$1.set(Float16Array,"float16")):ur$1.set("float16",Uint16Array)}}}),as$1,ss$1,us$1=L(()=>{Cn(),as$1=st=>{let at=1;for(let pt=0;pt<st.length;pt++){let vt=st[pt];if(typeof vt!="number"||!Number.isSafeInteger(vt))throw new TypeError(`dims[${pt}] must be an integer, got: ${vt}`);if(vt<0)throw new RangeError(`dims[${pt}] must be a non-negative integer, got: ${vt}`);at*=vt}return at},ss$1=(st,at)=>{switch(st.location){case"cpu":return new Je(st.type,st.data,at);case"cpu-pinned":return new Je({location:"cpu-pinned",data:st.data,type:st.type,dims:at});case"texture":return new Je({location:"texture",texture:st.texture,type:st.type,dims:at});case"gpu-buffer":return new Je({location:"gpu-buffer",gpuBuffer:st.gpuBuffer,type:st.type,dims:at});default:throw new Error(`tensorReshape: tensor location ${st.location} is not supported`)}}}),Je,Cn=L(()=>{Ja$1(),rs$1(),is$1(),us$1(),Je=class{constructor(st,at,pt){os$1();let vt,wt;if(typeof st=="object"&&"location"in st)switch(this.dataLocation=st.location,vt=st.type,wt=st.dims,st.location){case"cpu-pinned":{let Tt=ur$1.get(vt);if(!Tt)throw new TypeError(`unsupported type "${vt}" to create tensor from pinned buffer`);if(!(st.data instanceof Tt))throw new TypeError(`buffer should be of type ${Tt.name}`);this.cpuData=st.data;break}case"texture":{if(vt!=="float32")throw new TypeError(`unsupported type "${vt}" to create tensor from texture`);this.gpuTextureData=st.texture,this.downloader=st.download,this.disposer=st.dispose;break}case"gpu-buffer":{if(vt!=="float32"&&vt!=="float16"&&vt!=="int32"&&vt!=="int64"&&vt!=="uint32"&&vt!=="uint8"&&vt!=="bool")throw new TypeError(`unsupported type "${vt}" to create tensor from gpu buffer`);this.gpuBufferData=st.gpuBuffer,this.downloader=st.download,this.disposer=st.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let Tt,Lt;if(typeof st=="string")if(vt=st,Lt=pt,st==="string"){if(!Array.isArray(at))throw new TypeError("A string tensor's data must be a string array.");Tt=at}else{let Ft=ur$1.get(st);if(Ft===void 0)throw new TypeError(`Unsupported tensor type: ${st}.`);if(Array.isArray(at)){if(st==="float16"&&Ft===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");st==="uint64"||st==="int64"?Tt=Ft.from(at,BigInt):Tt=Ft.from(at)}else if(at instanceof Ft)Tt=at;else throw new TypeError(`A ${vt} tensor's data must be type of ${Ft}`)}else if(Lt=at,Array.isArray(st)){if(st.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let Ft=typeof st[0];if(Ft==="string")vt="string",Tt=st;else if(Ft==="boolean")vt="bool",Tt=Uint8Array.from(st);else throw new TypeError(`Invalid element type of data array: ${Ft}.`)}else{let Ft=Qr$1.get(st.constructor);if(Ft===void 0)throw new TypeError(`Unsupported type for tensor data: ${st.constructor}.`);vt=Ft,Tt=st}if(Lt===void 0)Lt=[Tt.length];else if(!Array.isArray(Lt))throw new TypeError("A tensor's dims must be a number array");wt=Lt,this.cpuData=Tt,this.dataLocation="cpu"}let $t=as$1(wt);if(this.cpuData&&$t!==this.cpuData.length)throw new Error(`Tensor's size(${$t}) does not match data length(${this.cpuData.length}).`);this.type=vt,this.dims=wt,this.size=$t}static async fromImage(st,at){return Za$1(st,at)}static fromTexture(st,at){return Qa$1(st,at)}static fromGpuBuffer(st,at){return es$1(st,at)}static fromPinnedBuffer(st,at,pt){return ts$1(st,at,pt)}toDataURL(st){return Xa$1(this,st)}toImageData(st){return Ka$1(this,st)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(st){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let at=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=at,st&&this.disposer&&(this.disposer(),this.disposer=void 0),at}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(st){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return ss$1(this,st)}}}),Me,Fn$1=L(()=>{Cn(),Me=Je}),ls$1,fs$1,lr$1,fr$1,Ho=L(()=>{Vo(),ls$1=(st,at)=>{(typeof ut$1.trace>"u"?!ut$1.wasm.trace:!ut$1.trace)||console.timeStamp(`${st}::ORT::${at}`)},fs$1=(st,at)=>{var wt;let pt=((wt=new Error().stack)==null?void 0:wt.split(/\r\n|\r|\n/g))||[],vt=!1;for(let $t=0;$t<pt.length;$t++){if(vt&&!pt[$t].includes("TRACE_FUNC")){let Tt=`FUNC_${st}::${pt[$t].trim().split(" ")[1]}`;at&&(Tt+=`::${at}`),ls$1("CPU",Tt);return}pt[$t].includes("TRACE_FUNC")&&(vt=!0)}},lr$1=st=>{(typeof ut$1.trace>"u"?!ut$1.wasm.trace:!ut$1.trace)||fs$1("BEGIN",st)},fr$1=st=>{(typeof ut$1.trace>"u"?!ut$1.wasm.trace:!ut$1.trace)||fs$1("END",st)}}),$n,cs$1=L(()=>{Ln$1(),Fn$1(),Ho(),$n=class jE{constructor(at){this.handler=at}async run(at,pt,vt){lr$1();let wt={},$t={};if(typeof at!="object"||at===null||at instanceof Me||Array.isArray(at))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let Tt=!0;if(typeof pt=="object"){if(pt===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(pt instanceof Me)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(pt)){if(pt.length===0)throw new TypeError("'fetches' cannot be an empty array.");Tt=!1;for(let Ct of pt){if(typeof Ct!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(Ct)===-1)throw new RangeError(`'fetches' contains invalid output name: ${Ct}.`);wt[Ct]=null}if(typeof vt=="object"&&vt!==null)$t=vt;else if(typeof vt<"u")throw new TypeError("'options' must be an object.")}else{let Ct=!1,Ht=Object.getOwnPropertyNames(pt);for(let Gt of this.outputNames)if(Ht.indexOf(Gt)!==-1){let jt=pt[Gt];(jt===null||jt instanceof Me)&&(Ct=!0,Tt=!1,wt[Gt]=jt)}if(Ct){if(typeof vt=="object"&&vt!==null)$t=vt;else if(typeof vt<"u")throw new TypeError("'options' must be an object.")}else $t=pt}}else if(typeof pt<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let Ct of this.inputNames)if(typeof at[Ct]>"u")throw new Error(`input '${Ct}' is missing in 'feeds'.`);if(Tt)for(let Ct of this.outputNames)wt[Ct]=null;let Lt=await this.handler.run(at,wt,$t),Ft={};for(let Ct in Lt)if(Object.hasOwnProperty.call(Lt,Ct)){let Ht=Lt[Ct];Ht instanceof Me?Ft[Ct]=Ht:Ft[Ct]=new Me(Ht.type,Ht.data,Ht.dims)}return fr$1(),Ft}async release(){return this.handler.dispose()}static async create(at,pt,vt,wt){lr$1();let $t,Tt={};if(typeof at=="string"){if($t=at,typeof pt=="object"&&pt!==null)Tt=pt;else if(typeof pt<"u")throw new TypeError("'options' must be an object.")}else if(at instanceof Uint8Array){if($t=at,typeof pt=="object"&&pt!==null)Tt=pt;else if(typeof pt<"u")throw new TypeError("'options' must be an object.")}else if(at instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&at instanceof SharedArrayBuffer){let Ht=at,Gt=0,jt=at.byteLength;if(typeof pt=="object"&&pt!==null)Tt=pt;else if(typeof pt=="number"){if(Gt=pt,!Number.isSafeInteger(Gt))throw new RangeError("'byteOffset' must be an integer.");if(Gt<0||Gt>=Ht.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${Ht.byteLength}).`);if(jt=at.byteLength-Gt,typeof vt=="number"){if(jt=vt,!Number.isSafeInteger(jt))throw new RangeError("'byteLength' must be an integer.");if(jt<=0||Gt+jt>Ht.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${Ht.byteLength-Gt}].`);if(typeof wt=="object"&&wt!==null)Tt=wt;else if(typeof wt<"u")throw new TypeError("'options' must be an object.")}else if(typeof vt<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof pt<"u")throw new TypeError("'options' must be an object.");$t=new Uint8Array(Ht,Gt,jt)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[Lt,Ft]=await Dn$1(Tt),Ct=await Lt.createInferenceSessionHandler($t,Ft);return fr$1(),new jE(Ct)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),Pd$1,ps$1=L(()=>{cs$1(),Pd$1=$n}),ds$1=L(()=>{}),hs$1=L(()=>{}),ms$1=L(()=>{}),bs$1=L(()=>{}),Ed$1,kn$1,gs$1=L(()=>{Ln$1(),Fn$1(),Ed$1="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",kn$1=class qE{constructor(at,pt,vt){this.handler=at,this.hasOptimizerModel=pt,this.hasEvalModel=vt}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(at,pt){let vt=at.evalModel||"",wt=at.optimizerModel||"",$t=pt||{},[Tt,Lt]=await Dn$1($t);if(Tt.createTrainingSessionHandler){let Ft=await Tt.createTrainingSessionHandler(at.checkpointState,at.trainModel,vt,wt,Lt);return new qE(Ft,!!at.optimizerModel,!!at.evalModel)}else throw new Error(Ed$1)}typeNarrowingForRunStep(at,pt,vt,wt,$t){let Tt={},Lt={};if(typeof vt!="object"||vt===null||vt instanceof Me||Array.isArray(vt))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let Ft=!0;if(typeof wt=="object"){if(wt===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(wt instanceof Me)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(wt)){if(wt.length===0)throw new TypeError("'fetches' cannot be an empty array.");Ft=!1;for(let Ct of wt){if(typeof Ct!="string")throw new TypeError("'fetches' must be a string array or an object.");if(pt.indexOf(Ct)===-1)throw new RangeError(`'fetches' contains invalid output name: ${Ct}.`);Tt[Ct]=null}if(typeof $t=="object"&&$t!==null)Lt=$t;else if(typeof $t<"u")throw new TypeError("'options' must be an object.")}else{let Ct=!1,Ht=Object.getOwnPropertyNames(wt);for(let Gt of pt)if(Ht.indexOf(Gt)!==-1){let jt=wt[Gt];(jt===null||jt instanceof Me)&&(Ct=!0,Ft=!1,Tt[Gt]=jt)}if(Ct){if(typeof $t=="object"&&$t!==null)Lt=$t;else if(typeof $t<"u")throw new TypeError("'options' must be an object.")}else Lt=wt}}else if(typeof wt<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let Ct of at)if(typeof vt[Ct]>"u")throw new Error(`input '${Ct}' is missing in 'feeds'.`);if(Ft)for(let Ct of pt)Tt[Ct]=null;return[Tt,Lt]}convertHandlerReturnTypeToMapOfTensors(at){let pt={};for(let vt in at)if(Object.hasOwnProperty.call(at,vt)){let wt=at[vt];wt instanceof Me?pt[vt]=wt:pt[vt]=new Me(wt.type,wt.data,wt.dims)}return pt}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(at,pt,vt){let[wt,$t]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,at,pt,vt),Tt=await this.handler.runTrainStep(at,wt,$t);return this.convertHandlerReturnTypeToMapOfTensors(Tt)}async runOptimizerStep(at){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(at||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(at,pt,vt){if(this.hasEvalModel){let[wt,$t]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,at,pt,vt),Tt=await this.handler.runEvalStep(at,wt,$t);return this.convertHandlerReturnTypeToMapOfTensors(Tt)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(at=!0){return this.handler.getParametersSize(at)}async loadParametersBuffer(at,pt=!0){let vt=await this.getParametersSize(pt);if(at.length!==4*vt)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(at,pt)}async getContiguousParameters(at=!0){return this.handler.getContiguousParameters(at)}async release(){return this.handler.dispose()}}}),Dd$1,ys$1=L(()=>{gs$1(),Dd$1=kn$1}),qo={};Sr(qo,{InferenceSession:()=>Pd$1,TRACE:()=>ls$1,TRACE_FUNC_BEGIN:()=>lr$1,TRACE_FUNC_END:()=>fr$1,Tensor:()=>Me,TrainingSession:()=>Dd$1,env:()=>Z,registerBackend:()=>Pr$1});var Ot$1=L(()=>{Wa(),Ya$1(),ps$1(),Fn$1(),ds$1(),hs$1(),Ho(),ms$1(),bs$1(),ys$1()});function Xt$1(st,at,pt,vt){if(at===void 0)return Cd$1(st);if(pt===void 0)Bn$1(st,at);else if(typeof pt=="number"&&vt===void 0)Bn$1(st,at);else if(typeof pt=="string"&&vt===void 0)Bn$1(st,pt,1,at);else if(typeof pt=="string"&&typeof vt=="number")Bn$1(st,pt,vt,at);else throw new TypeError("input is valid")}function Cd$1(st){return{verbose:Xt$1.verbose.bind(null,st),info:Xt$1.info.bind(null,st),warning:Xt$1.warning.bind(null,st),error:Xt$1.error.bind(null,st),fatal:Xt$1.fatal.bind(null,st)}}function Bn$1(st,at,pt,vt){let wt=en$1[vt||""]||en$1[""];xs$1[st]<xs$1[wt.minimalSeverity]||(wt.logDateTime&&(at=`${new Date().toISOString()}|${at}`),wt.logSourceLocation,Ld$1[wt.provider].log(st,at,vt))}var jo,Yo,xs$1,Ld$1,ws$1,en$1,ce,Rn$1,Mn$1,Gn$1,Nn$1,lt$1=L(()=>{jo=class{log(st,at,pt){}},Yo=class{log(st,at,pt){console.log(`${this.color(st)} ${pt?"\x1B[35m"+pt+"\x1B[0m ":""}${at}`)}color(st){switch(st){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${st}`)}}},xs$1={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},Ld$1={none:new jo,console:new Yo},ws$1={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},en$1={"":ws$1},(st=>{function at(Ct,Ht){st("verbose",Ct,Ht)}st.verbose=at;function pt(Ct,Ht){st("info",Ct,Ht)}st.info=pt;function vt(Ct,Ht){st("warning",Ct,Ht)}st.warning=vt;function wt(Ct,Ht){st("error",Ct,Ht)}st.error=wt;function $t(Ct,Ht){st("fatal",Ct,Ht)}st.fatal=$t;function Tt(Ct){en$1={},Lt("",Ct||{})}st.reset=Tt;function Lt(Ct,Ht){if(Ct==="*")Tt(Ht);else{let Gt=en$1[Ct]||ws$1;en$1[Ct]={provider:Ht.provider||Gt.provider,minimalSeverity:Ht.minimalSeverity||Gt.minimalSeverity,logDateTime:Ht.logDateTime===void 0?Gt.logDateTime:Ht.logDateTime,logSourceLocation:Ht.logSourceLocation===void 0?Gt.logSourceLocation:Ht.logSourceLocation}}}st.set=Lt;function Ft(Ct){let Ht={};Ct.logLevel&&(Ht.minimalSeverity=Ct.logLevel),Lt("",Ht)}st.setWithEnv=Ft})(Xt$1||(Xt$1={})),ce=Xt$1,Rn$1=class{constructor(st,at,pt,vt,wt,$t){this.category=st,this.name=at,this.startTime=pt,this.endCallback=vt,this.timer=wt,this.ctx=$t}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},Mn$1=class{constructor(st,at,pt,vt){this.category=st,this.name=at,this.startTime=pt,this.endTime=vt}},Gn$1=class{constructor(st,at,pt){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=st===void 0?1e4:st,this._flushBatchSize=at===void 0?10:at,this._flushIntervalInMilliseconds=pt===void 0?5e3:pt}static create(st){return st===void 0?new this:new this(st.maxNumberEvents,st.flushBatchSize,st.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=Nn$1(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(st,at,pt,vt){let wt=this._started?this.begin(st,at,vt):void 0,$t=!1,Tt=pt();if(Tt&&typeof Tt.then=="function")return $t=!0,new Promise((Lt,Ft)=>{Tt.then(async Ct=>{wt&&await wt.end(),Lt(Ct)},async Ct=>{wt&&await wt.end(),Ft(Ct)})});if(!$t&&wt){let Lt=wt.end();if(Lt&&typeof Lt.then=="function")return new Promise((Ft,Ct)=>{Lt.then(()=>{Ft(Tt)},Ht=>{Ct(Ht)})})}return Tt}begin(st,at,pt){if(!this._started)throw new Error("profiler is not started yet");if(pt===void 0){let vt=Nn$1();return this.flush(vt),new Rn$1(st,at,vt,wt=>this.endSync(wt))}else{let vt=pt.beginTimer();return new Rn$1(st,at,0,async wt=>this.end(wt),vt,pt)}}async end(st){let at=await st.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new Mn$1(st.category,st.name,st.startTime,at)),this.flush(at))}endSync(st){let at=Nn$1();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new Mn$1(st.category,st.name,st.startTime,at)),this.flush(at))}logOneEvent(st){ce.verbose(`Profiler.${st.category}`,`${(st.endTime-st.startTime).toFixed(2)}ms on event '${st.name}' at ${st.endTime.toFixed(2)}`)}flush(st){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||st-this._flushTime>=this._flushIntervalInMilliseconds){for(let at=this._flushPointer;this._flushPointer<at+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=Nn$1()}}get started(){return this._started}},Nn$1=typeof performance<"u"&&performance.now?()=>performance.now():Date.now});function vs$1(st,at,pt){for(let vt of pt){let wt=vt[0],$t=vt[1],Tt=vt[2],Lt=vt[3],Ft=vt[4];if(st.opType===wt){for(let Ct of at)if((Ct.domain===$t||Ct.domain==="ai.onnx"&&$t==="")&&Fd$1(Ct.version,Tt))return{opImpl:Lt,opInit:Ft}}}throw new TypeError(`cannot resolve operator '${st.opType}' with opsets: ${at.map(vt=>`${vt.domain||"ai.onnx"} v${vt.version}`).join(", ")}`)}function Fd$1(st,at){if(at.endsWith("+")){let pt=Number.parseInt(at.substring(0,at.length-1),10);return!isNaN(pt)&&pt<=st}else if(at.split("-").length===2){let pt=at.split("-"),vt=Number.parseInt(pt[0],10),wt=Number.parseInt(pt[1],10);return!isNaN(vt)&&!isNaN(wt)&&vt<=st&&st<=wt}else return Number.parseInt(at,10)===st}var _s$1=L(()=>{}),Os$1=me(st=>{st.__esModule=!0;var at=function(){function pt(vt){if(!vt)throw new TypeError("Invalid argument; `value` has no value.");this.value=pt.EMPTY,vt&&pt.isGuid(vt)&&(this.value=vt)}return pt.isGuid=function(vt){var wt=vt.toString();return vt&&(vt instanceof pt||pt.validator.test(wt))},pt.create=function(){return new pt([pt.gen(2),pt.gen(1),pt.gen(1),pt.gen(1),pt.gen(3)].join("-"))},pt.createEmpty=function(){return new pt("emptyguid")},pt.parse=function(vt){return new pt(vt)},pt.raw=function(){return[pt.gen(2),pt.gen(1),pt.gen(1),pt.gen(1),pt.gen(3)].join("-")},pt.gen=function(vt){for(var wt="",$t=0;$t<vt;$t++)wt+=((1+Math.random())*65536|0).toString(16).substring(1);return wt},pt.prototype.equals=function(vt){return pt.isGuid(vt)&&this.value===vt.toString()},pt.prototype.isEmpty=function(){return this.value===pt.EMPTY},pt.prototype.toString=function(){return this.value},pt.prototype.toJSON=function(){return{value:this.value}},pt.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),pt.EMPTY="00000000-0000-0000-0000-000000000000",pt}();st.Guid=at});function be(st,at,pt){this.low=st|0,this.high=at|0,this.unsigned=!!pt}function Xe(st){return(st&&st.__isLong__)===!0}function Is$1(st){var at=Math.clz32(st&-st);return st?31-at:at}function cr$1(st,at){var pt,vt,wt;return at?(st>>>=0,(wt=0<=st&&st<256)&&(vt=As$1[st],vt)?vt:(pt=le(st,0,!0),wt&&(As$1[st]=pt),pt)):(st|=0,(wt=-128<=st&&st<128)&&(vt=Ss$1[st],vt)?vt:(pt=le(st,st<0?-1:0,!1),wt&&(Ss$1[st]=pt),pt))}function ct(st,at){if(isNaN(st))return at?zt$1:It;if(at){if(st<0)return zt$1;if(st>=Ls$1)return $s$1}else{if(st<=-Es$1)return nt$1;if(st+1>=Es$1)return Fs$1}return st<0?ct(-st,at).neg():le(st%Dr|0,st/Dr|0,at)}function le(st,at,pt){return new be(st,at,pt)}function Jo(st,at,pt){if(st.length===0)throw Error("empty string");if(typeof at=="number"?(pt=at,at=!1):at=!!at,st==="NaN"||st==="Infinity"||st==="+Infinity"||st==="-Infinity")return at?zt$1:It;if(pt=pt||10,pt<2||36<pt)throw RangeError("radix");var vt;if((vt=st.indexOf("-"))>0)throw Error("interior hyphen");if(vt===0)return Jo(st.substring(1),at,pt).neg();for(var wt=ct(Un$1(pt,8)),$t=It,Tt=0;Tt<st.length;Tt+=8){var Lt=Math.min(8,st.length-Tt),Ft=parseInt(st.substring(Tt,Tt+Lt),pt);if(Lt<8){var Ct=ct(Un$1(pt,Lt));$t=$t.mul(Ct).add(ct(Ft))}else $t=$t.mul(wt),$t=$t.add(ct(Ft))}return $t.unsigned=at,$t}function St$1(st,at){return typeof st=="number"?ct(st,at):typeof st=="string"?Jo(st,at):le(st.low,st.high,typeof at=="boolean"?at:st.unsigned)}var ft,Ss$1,As$1,Un$1,Ps$1,kd$1,Dr,Ls$1,Es$1,Ds$1,It,zt$1,Er$1,Cs$1,Ko,Fs$1,$s$1,nt$1,B,Vt,Zo=L(()=>{ft=null;try{ft=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}be.prototype.__isLong__,Object.defineProperty(be.prototype,"__isLong__",{value:!0}),be.isLong=Xe,Ss$1={},As$1={},be.fromInt=cr$1,be.fromNumber=ct,be.fromBits=le,Un$1=Math.pow,be.fromString=Jo,be.fromValue=St$1,Ps$1=65536,kd$1=1<<24,Dr=Ps$1*Ps$1,Ls$1=Dr*Dr,Es$1=Ls$1/2,Ds$1=cr$1(kd$1),It=cr$1(0),be.ZERO=It,zt$1=cr$1(0,!0),be.UZERO=zt$1,Er$1=cr$1(1),be.ONE=Er$1,Cs$1=cr$1(1,!0),be.UONE=Cs$1,Ko=cr$1(-1),be.NEG_ONE=Ko,Fs$1=le(-1,2147483647,!1),be.MAX_VALUE=Fs$1,$s$1=le(-1,-1,!0),be.MAX_UNSIGNED_VALUE=$s$1,nt$1=le(0,-2147483648,!1),be.MIN_VALUE=nt$1,B=be.prototype,B.toInt=function(){return this.unsigned?this.low>>>0:this.low},B.toNumber=function(){return this.unsigned?(this.high>>>0)*Dr+(this.low>>>0):this.high*Dr+(this.low>>>0)},B.toString=function(st){if(st=st||10,st<2||36<st)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(nt$1)){var at=ct(st),pt=this.div(at),vt=pt.mul(at).sub(this);return pt.toString(st)+vt.toInt().toString(st)}else return"-"+this.neg().toString(st);for(var wt=ct(Un$1(st,6),this.unsigned),$t=this,Tt="";;){var Lt=$t.div(wt),Ft=$t.sub(Lt.mul(wt)).toInt()>>>0,Ct=Ft.toString(st);if($t=Lt,$t.isZero())return Ct+Tt;for(;Ct.length<6;)Ct="0"+Ct;Tt=""+Ct+Tt}},B.getHighBits=function(){return this.high},B.getHighBitsUnsigned=function(){return this.high>>>0},B.getLowBits=function(){return this.low},B.getLowBitsUnsigned=function(){return this.low>>>0},B.getNumBitsAbs=function(){if(this.isNegative())return this.eq(nt$1)?64:this.neg().getNumBitsAbs();for(var st=this.high!=0?this.high:this.low,at=31;at>0&&!(st&1<<at);at--);return this.high!=0?at+33:at+1},B.isZero=function(){return this.high===0&&this.low===0},B.eqz=B.isZero,B.isNegative=function(){return!this.unsigned&&this.high<0},B.isPositive=function(){return this.unsigned||this.high>=0},B.isOdd=function(){return(this.low&1)===1},B.isEven=function(){return(this.low&1)===0},B.equals=function(st){return Xe(st)||(st=St$1(st)),this.unsigned!==st.unsigned&&this.high>>>31===1&&st.high>>>31===1?!1:this.high===st.high&&this.low===st.low},B.eq=B.equals,B.notEquals=function(st){return!this.eq(st)},B.neq=B.notEquals,B.ne=B.notEquals,B.lessThan=function(st){return this.comp(st)<0},B.lt=B.lessThan,B.lessThanOrEqual=function(st){return this.comp(st)<=0},B.lte=B.lessThanOrEqual,B.le=B.lessThanOrEqual,B.greaterThan=function(st){return this.comp(st)>0},B.gt=B.greaterThan,B.greaterThanOrEqual=function(st){return this.comp(st)>=0},B.gte=B.greaterThanOrEqual,B.ge=B.greaterThanOrEqual,B.compare=function(st){if(Xe(st)||(st=St$1(st)),this.eq(st))return 0;var at=this.isNegative(),pt=st.isNegative();return at&&!pt?-1:!at&&pt?1:this.unsigned?st.high>>>0>this.high>>>0||st.high===this.high&&st.low>>>0>this.low>>>0?-1:1:this.sub(st).isNegative()?-1:1},B.comp=B.compare,B.negate=function(){return!this.unsigned&&this.eq(nt$1)?nt$1:this.not().add(Er$1)},B.neg=B.negate,B.add=function(st){Xe(st)||(st=St$1(st));var at=this.high>>>16,pt=this.high&65535,vt=this.low>>>16,wt=this.low&65535,$t=st.high>>>16,Tt=st.high&65535,Lt=st.low>>>16,Ft=st.low&65535,Ct=0,Ht=0,Gt=0,jt=0;return jt+=wt+Ft,Gt+=jt>>>16,jt&=65535,Gt+=vt+Lt,Ht+=Gt>>>16,Gt&=65535,Ht+=pt+Tt,Ct+=Ht>>>16,Ht&=65535,Ct+=at+$t,Ct&=65535,le(Gt<<16|jt,Ct<<16|Ht,this.unsigned)},B.subtract=function(st){return Xe(st)||(st=St$1(st)),this.add(st.neg())},B.sub=B.subtract,B.multiply=function(st){if(this.isZero())return this;if(Xe(st)||(st=St$1(st)),ft){var at=ft.mul(this.low,this.high,st.low,st.high);return le(at,ft.get_high(),this.unsigned)}if(st.isZero())return this.unsigned?zt$1:It;if(this.eq(nt$1))return st.isOdd()?nt$1:It;if(st.eq(nt$1))return this.isOdd()?nt$1:It;if(this.isNegative())return st.isNegative()?this.neg().mul(st.neg()):this.neg().mul(st).neg();if(st.isNegative())return this.mul(st.neg()).neg();if(this.lt(Ds$1)&&st.lt(Ds$1))return ct(this.toNumber()*st.toNumber(),this.unsigned);var pt=this.high>>>16,vt=this.high&65535,wt=this.low>>>16,$t=this.low&65535,Tt=st.high>>>16,Lt=st.high&65535,Ft=st.low>>>16,Ct=st.low&65535,Ht=0,Gt=0,jt=0,qt=0;return qt+=$t*Ct,jt+=qt>>>16,qt&=65535,jt+=wt*Ct,Gt+=jt>>>16,jt&=65535,jt+=$t*Ft,Gt+=jt>>>16,jt&=65535,Gt+=vt*Ct,Ht+=Gt>>>16,Gt&=65535,Gt+=wt*Ft,Ht+=Gt>>>16,Gt&=65535,Gt+=$t*Lt,Ht+=Gt>>>16,Gt&=65535,Ht+=pt*Ct+vt*Ft+wt*Lt+$t*Tt,Ht&=65535,le(jt<<16|qt,Ht<<16|Gt,this.unsigned)},B.mul=B.multiply,B.divide=function(st){if(Xe(st)||(st=St$1(st)),st.isZero())throw Error("division by zero");if(ft){if(!this.unsigned&&this.high===-2147483648&&st.low===-1&&st.high===-1)return this;var at=(this.unsigned?ft.div_u:ft.div_s)(this.low,this.high,st.low,st.high);return le(at,ft.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?zt$1:It;var pt,vt,wt;if(this.unsigned){if(st.unsigned||(st=st.toUnsigned()),st.gt(this))return zt$1;if(st.gt(this.shru(1)))return Cs$1;wt=zt$1}else{if(this.eq(nt$1)){if(st.eq(Er$1)||st.eq(Ko))return nt$1;if(st.eq(nt$1))return Er$1;var $t=this.shr(1);return pt=$t.div(st).shl(1),pt.eq(It)?st.isNegative()?Er$1:Ko:(vt=this.sub(st.mul(pt)),wt=pt.add(vt.div(st)),wt)}else if(st.eq(nt$1))return this.unsigned?zt$1:It;if(this.isNegative())return st.isNegative()?this.neg().div(st.neg()):this.neg().div(st).neg();if(st.isNegative())return this.div(st.neg()).neg();wt=It}for(vt=this;vt.gte(st);){pt=Math.max(1,Math.floor(vt.toNumber()/st.toNumber()));for(var Tt=Math.ceil(Math.log(pt)/Math.LN2),Lt=Tt<=48?1:Un$1(2,Tt-48),Ft=ct(pt),Ct=Ft.mul(st);Ct.isNegative()||Ct.gt(vt);)pt-=Lt,Ft=ct(pt,this.unsigned),Ct=Ft.mul(st);Ft.isZero()&&(Ft=Er$1),wt=wt.add(Ft),vt=vt.sub(Ct)}return wt},B.div=B.divide,B.modulo=function(st){if(Xe(st)||(st=St$1(st)),ft){var at=(this.unsigned?ft.rem_u:ft.rem_s)(this.low,this.high,st.low,st.high);return le(at,ft.get_high(),this.unsigned)}return this.sub(this.div(st).mul(st))},B.mod=B.modulo,B.rem=B.modulo,B.not=function(){return le(~this.low,~this.high,this.unsigned)},B.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},B.clz=B.countLeadingZeros,B.countTrailingZeros=function(){return this.low?Is$1(this.low):Is$1(this.high)+32},B.ctz=B.countTrailingZeros,B.and=function(st){return Xe(st)||(st=St$1(st)),le(this.low&st.low,this.high&st.high,this.unsigned)},B.or=function(st){return Xe(st)||(st=St$1(st)),le(this.low|st.low,this.high|st.high,this.unsigned)},B.xor=function(st){return Xe(st)||(st=St$1(st)),le(this.low^st.low,this.high^st.high,this.unsigned)},B.shiftLeft=function(st){return Xe(st)&&(st=st.toInt()),(st&=63)===0?this:st<32?le(this.low<<st,this.high<<st|this.low>>>32-st,this.unsigned):le(0,this.low<<st-32,this.unsigned)},B.shl=B.shiftLeft,B.shiftRight=function(st){return Xe(st)&&(st=st.toInt()),(st&=63)===0?this:st<32?le(this.low>>>st|this.high<<32-st,this.high>>st,this.unsigned):le(this.high>>st-32,this.high>=0?0:-1,this.unsigned)},B.shr=B.shiftRight,B.shiftRightUnsigned=function(st){return Xe(st)&&(st=st.toInt()),(st&=63)===0?this:st<32?le(this.low>>>st|this.high<<32-st,this.high>>>st,this.unsigned):st===32?le(this.high,0,this.unsigned):le(this.high>>>st-32,0,this.unsigned)},B.shru=B.shiftRightUnsigned,B.shr_u=B.shiftRightUnsigned,B.rotateLeft=function(st){var at;return Xe(st)&&(st=st.toInt()),(st&=63)===0?this:st===32?le(this.high,this.low,this.unsigned):st<32?(at=32-st,le(this.low<<st|this.high>>>at,this.high<<st|this.low>>>at,this.unsigned)):(st-=32,at=32-st,le(this.high<<st|this.low>>>at,this.low<<st|this.high>>>at,this.unsigned))},B.rotl=B.rotateLeft,B.rotateRight=function(st){var at;return Xe(st)&&(st=st.toInt()),(st&=63)===0?this:st===32?le(this.high,this.low,this.unsigned):st<32?(at=32-st,le(this.high<<at|this.low>>>st,this.low<<at|this.high>>>st,this.unsigned)):(st-=32,at=32-st,le(this.low<<at|this.high>>>st,this.high<<at|this.low>>>st,this.unsigned))},B.rotr=B.rotateRight,B.toSigned=function(){return this.unsigned?le(this.low,this.high,!1):this},B.toUnsigned=function(){return this.unsigned?this:le(this.low,this.high,!0)},B.toBytes=function(st){return st?this.toBytesLE():this.toBytesBE()},B.toBytesLE=function(){var st=this.high,at=this.low;return[at&255,at>>>8&255,at>>>16&255,at>>>24,st&255,st>>>8&255,st>>>16&255,st>>>24]},B.toBytesBE=function(){var st=this.high,at=this.low;return[st>>>24,st>>>16&255,st>>>8&255,st&255,at>>>24,at>>>16&255,at>>>8&255,at&255]},be.fromBytes=function(st,at,pt){return pt?be.fromBytesLE(st,at):be.fromBytesBE(st,at)},be.fromBytesLE=function(st,at){return new be(st[0]|st[1]<<8|st[2]<<16|st[3]<<24,st[4]|st[5]<<8|st[6]<<16|st[7]<<24,at)},be.fromBytesBE=function(st,at){return new be(st[4]<<24|st[5]<<16|st[6]<<8|st[7],st[0]<<24|st[1]<<16|st[2]<<8|st[3],at)},Vt=be}),_,zn$1=L(()=>{_={},_.Offset,_.Table,_.SIZEOF_SHORT=2,_.SIZEOF_INT=4,_.FILE_IDENTIFIER_LENGTH=4,_.SIZE_PREFIX_LENGTH=4,_.Encoding={UTF8_BYTES:1,UTF16_STRING:2},_.int32=new Int32Array(2),_.float32=new Float32Array(_.int32.buffer),_.float64=new Float64Array(_.int32.buffer),_.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,_.Long=function(st,at){this.low=st|0,this.high=at|0},_.Long.create=function(st,at){return st==0&&at==0?_.Long.ZERO:new _.Long(st,at)},_.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296},_.Long.prototype.equals=function(st){return this.low==st.low&&this.high==st.high},_.Long.ZERO=new _.Long(0,0),_.Builder=function(st){if(st)var at=st;else var at=1024;this.bb=_.ByteBuffer.allocate(at),this.space=at,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},_.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},_.Builder.prototype.forceDefaults=function(st){this.force_defaults=st},_.Builder.prototype.dataBuffer=function(){return this.bb},_.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},_.Builder.prototype.prep=function(st,at){st>this.minalign&&(this.minalign=st);for(var pt=~(this.bb.capacity()-this.space+at)+1&st-1;this.space<pt+st+at;){var vt=this.bb.capacity();this.bb=_.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-vt}this.pad(pt)},_.Builder.prototype.pad=function(st){for(var at=0;at<st;at++)this.bb.writeInt8(--this.space,0)},_.Builder.prototype.writeInt8=function(st){this.bb.writeInt8(this.space-=1,st)},_.Builder.prototype.writeInt16=function(st){this.bb.writeInt16(this.space-=2,st)},_.Builder.prototype.writeInt32=function(st){this.bb.writeInt32(this.space-=4,st)},_.Builder.prototype.writeInt64=function(st){this.bb.writeInt64(this.space-=8,st)},_.Builder.prototype.writeFloat32=function(st){this.bb.writeFloat32(this.space-=4,st)},_.Builder.prototype.writeFloat64=function(st){this.bb.writeFloat64(this.space-=8,st)},_.Builder.prototype.addInt8=function(st){this.prep(1,0),this.writeInt8(st)},_.Builder.prototype.addInt16=function(st){this.prep(2,0),this.writeInt16(st)},_.Builder.prototype.addInt32=function(st){this.prep(4,0),this.writeInt32(st)},_.Builder.prototype.addInt64=function(st){this.prep(8,0),this.writeInt64(st)},_.Builder.prototype.addFloat32=function(st){this.prep(4,0),this.writeFloat32(st)},_.Builder.prototype.addFloat64=function(st){this.prep(8,0),this.writeFloat64(st)},_.Builder.prototype.addFieldInt8=function(st,at,pt){(this.force_defaults||at!=pt)&&(this.addInt8(at),this.slot(st))},_.Builder.prototype.addFieldInt16=function(st,at,pt){(this.force_defaults||at!=pt)&&(this.addInt16(at),this.slot(st))},_.Builder.prototype.addFieldInt32=function(st,at,pt){(this.force_defaults||at!=pt)&&(this.addInt32(at),this.slot(st))},_.Builder.prototype.addFieldInt64=function(st,at,pt){(this.force_defaults||!at.equals(pt))&&(this.addInt64(at),this.slot(st))},_.Builder.prototype.addFieldFloat32=function(st,at,pt){(this.force_defaults||at!=pt)&&(this.addFloat32(at),this.slot(st))},_.Builder.prototype.addFieldFloat64=function(st,at,pt){(this.force_defaults||at!=pt)&&(this.addFloat64(at),this.slot(st))},_.Builder.prototype.addFieldOffset=function(st,at,pt){(this.force_defaults||at!=pt)&&(this.addOffset(at),this.slot(st))},_.Builder.prototype.addFieldStruct=function(st,at,pt){at!=pt&&(this.nested(at),this.slot(st))},_.Builder.prototype.nested=function(st){if(st!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},_.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},_.Builder.prototype.slot=function(st){this.vtable[st]=this.offset()},_.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},_.Builder.growByteBuffer=function(st){var at=st.capacity();if(at&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var pt=at<<1,vt=_.ByteBuffer.allocate(pt);return vt.setPosition(pt-at),vt.bytes().set(st.bytes(),pt-at),vt},_.Builder.prototype.addOffset=function(st){this.prep(_.SIZEOF_INT,0),this.writeInt32(this.offset()-st+_.SIZEOF_INT)},_.Builder.prototype.startObject=function(st){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=st;for(var at=0;at<st;at++)this.vtable[at]=0;this.isNested=!0,this.object_start=this.offset()},_.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var st=this.offset(),at=this.vtable_in_use-1;at>=0&&this.vtable[at]==0;at--);for(var pt=at+1;at>=0;at--)this.addInt16(this.vtable[at]!=0?st-this.vtable[at]:0);var vt=2;this.addInt16(st-this.object_start);var wt=(pt+vt)*_.SIZEOF_SHORT;this.addInt16(wt);var $t=0,Tt=this.space;e:for(at=0;at<this.vtables.length;at++){var Lt=this.bb.capacity()-this.vtables[at];if(wt==this.bb.readInt16(Lt)){for(var Ft=_.SIZEOF_SHORT;Ft<wt;Ft+=_.SIZEOF_SHORT)if(this.bb.readInt16(Tt+Ft)!=this.bb.readInt16(Lt+Ft))continue e;$t=this.vtables[at];break}}return $t?(this.space=this.bb.capacity()-st,this.bb.writeInt32(this.space,$t-st)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-st,this.offset()-st)),this.isNested=!1,st},_.Builder.prototype.finish=function(st,at,pt){var vt=pt?_.SIZE_PREFIX_LENGTH:0;if(at){var wt=at;if(this.prep(this.minalign,_.SIZEOF_INT+_.FILE_IDENTIFIER_LENGTH+vt),wt.length!=_.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+_.FILE_IDENTIFIER_LENGTH);for(var $t=_.FILE_IDENTIFIER_LENGTH-1;$t>=0;$t--)this.writeInt8(wt.charCodeAt($t))}this.prep(this.minalign,_.SIZEOF_INT+vt),this.addOffset(st),vt&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},_.Builder.prototype.finishSizePrefixed=function(st,at){this.finish(st,at,!0)},_.Builder.prototype.requiredField=function(st,at){var pt=this.bb.capacity()-st,vt=pt-this.bb.readInt32(pt),wt=this.bb.readInt16(vt+at)!=0;if(!wt)throw new Error("FlatBuffers: field "+at+" must be set")},_.Builder.prototype.startVector=function(st,at,pt){this.notNested(),this.vector_num_elems=at,this.prep(_.SIZEOF_INT,st*at),this.prep(pt,st*at)},_.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},_.Builder.prototype.createString=function(st){if(st instanceof Uint8Array)var at=st;else for(var at=[],pt=0;pt<st.length;){var vt,wt=st.charCodeAt(pt++);if(wt<55296||wt>=56320)vt=wt;else{var $t=st.charCodeAt(pt++);vt=(wt<<10)+$t+-56613888}vt<128?at.push(vt):(vt<2048?at.push(vt>>6&31|192):(vt<65536?at.push(vt>>12&15|224):at.push(vt>>18&7|240,vt>>12&63|128),at.push(vt>>6&63|128)),at.push(vt&63|128))}this.addInt8(0),this.startVector(1,at.length,1),this.bb.setPosition(this.space-=at.length);for(var pt=0,Tt=this.space,Lt=this.bb.bytes();pt<at.length;pt++)Lt[Tt++]=at[pt];return this.endVector()},_.Builder.prototype.createLong=function(st,at){return _.Long.create(st,at)},_.ByteBuffer=function(st){this.bytes_=st,this.position_=0},_.ByteBuffer.allocate=function(st){return new _.ByteBuffer(new Uint8Array(st))},_.ByteBuffer.prototype.clear=function(){this.position_=0},_.ByteBuffer.prototype.bytes=function(){return this.bytes_},_.ByteBuffer.prototype.position=function(){return this.position_},_.ByteBuffer.prototype.setPosition=function(st){this.position_=st},_.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},_.ByteBuffer.prototype.readInt8=function(st){return this.readUint8(st)<<24>>24},_.ByteBuffer.prototype.readUint8=function(st){return this.bytes_[st]},_.ByteBuffer.prototype.readInt16=function(st){return this.readUint16(st)<<16>>16},_.ByteBuffer.prototype.readUint16=function(st){return this.bytes_[st]|this.bytes_[st+1]<<8},_.ByteBuffer.prototype.readInt32=function(st){return this.bytes_[st]|this.bytes_[st+1]<<8|this.bytes_[st+2]<<16|this.bytes_[st+3]<<24},_.ByteBuffer.prototype.readUint32=function(st){return this.readInt32(st)>>>0},_.ByteBuffer.prototype.readInt64=function(st){return new _.Long(this.readInt32(st),this.readInt32(st+4))},_.ByteBuffer.prototype.readUint64=function(st){return new _.Long(this.readUint32(st),this.readUint32(st+4))},_.ByteBuffer.prototype.readFloat32=function(st){return _.int32[0]=this.readInt32(st),_.float32[0]},_.ByteBuffer.prototype.readFloat64=function(st){return _.int32[_.isLittleEndian?0:1]=this.readInt32(st),_.int32[_.isLittleEndian?1:0]=this.readInt32(st+4),_.float64[0]},_.ByteBuffer.prototype.writeInt8=function(st,at){this.bytes_[st]=at},_.ByteBuffer.prototype.writeUint8=function(st,at){this.bytes_[st]=at},_.ByteBuffer.prototype.writeInt16=function(st,at){this.bytes_[st]=at,this.bytes_[st+1]=at>>8},_.ByteBuffer.prototype.writeUint16=function(st,at){this.bytes_[st]=at,this.bytes_[st+1]=at>>8},_.ByteBuffer.prototype.writeInt32=function(st,at){this.bytes_[st]=at,this.bytes_[st+1]=at>>8,this.bytes_[st+2]=at>>16,this.bytes_[st+3]=at>>24},_.ByteBuffer.prototype.writeUint32=function(st,at){this.bytes_[st]=at,this.bytes_[st+1]=at>>8,this.bytes_[st+2]=at>>16,this.bytes_[st+3]=at>>24},_.ByteBuffer.prototype.writeInt64=function(st,at){this.writeInt32(st,at.low),this.writeInt32(st+4,at.high)},_.ByteBuffer.prototype.writeUint64=function(st,at){this.writeUint32(st,at.low),this.writeUint32(st+4,at.high)},_.ByteBuffer.prototype.writeFloat32=function(st,at){_.float32[0]=at,this.writeInt32(st,_.int32[0])},_.ByteBuffer.prototype.writeFloat64=function(st,at){_.float64[0]=at,this.writeInt32(st,_.int32[_.isLittleEndian?0:1]),this.writeInt32(st+4,_.int32[_.isLittleEndian?1:0])},_.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+_.SIZEOF_INT+_.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var st="",at=0;at<_.FILE_IDENTIFIER_LENGTH;at++)st+=String.fromCharCode(this.readInt8(this.position_+_.SIZEOF_INT+at));return st},_.ByteBuffer.prototype.__offset=function(st,at){var pt=st-this.readInt32(st);return at<this.readInt16(pt)?this.readInt16(pt+at):0},_.ByteBuffer.prototype.__union=function(st,at){return st.bb_pos=at+this.readInt32(at),st.bb=this,st},_.ByteBuffer.prototype.__string=function(st,at){st+=this.readInt32(st);var pt=this.readInt32(st),vt="",wt=0;if(st+=_.SIZEOF_INT,at===_.Encoding.UTF8_BYTES)return this.bytes_.subarray(st,st+pt);for(;wt<pt;){var $t,Tt=this.readUint8(st+wt++);if(Tt<192)$t=Tt;else{var Lt=this.readUint8(st+wt++);if(Tt<224)$t=(Tt&31)<<6|Lt&63;else{var Ft=this.readUint8(st+wt++);if(Tt<240)$t=(Tt&15)<<12|(Lt&63)<<6|Ft&63;else{var Ct=this.readUint8(st+wt++);$t=(Tt&7)<<18|(Lt&63)<<12|(Ft&63)<<6|Ct&63}}}$t<65536?vt+=String.fromCharCode($t):($t-=65536,vt+=String.fromCharCode(($t>>10)+55296,($t&1023)+56320))}return vt},_.ByteBuffer.prototype.__indirect=function(st){return st+this.readInt32(st)},_.ByteBuffer.prototype.__vector=function(st){return st+this.readInt32(st)+_.SIZEOF_INT},_.ByteBuffer.prototype.__vector_len=function(st){return this.readInt32(st+this.readInt32(st))},_.ByteBuffer.prototype.__has_identifier=function(st){if(st.length!=_.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+_.FILE_IDENTIFIER_LENGTH);for(var at=0;at<_.FILE_IDENTIFIER_LENGTH;at++)if(st.charCodeAt(at)!=this.readInt8(this.position_+_.SIZEOF_INT+at))return!1;return!0},_.ByteBuffer.prototype.createLong=function(st,at){return _.Long.create(st,at)}}),V,tn$1=L(()=>{zn$1(),(st=>{(at=>{(pt=>{(vt=>(vt[vt.UNDEFINED=0]="UNDEFINED",vt[vt.FLOAT=1]="FLOAT",vt[vt.INT=2]="INT",vt[vt.STRING=3]="STRING",vt[vt.TENSOR=4]="TENSOR",vt[vt.GRAPH=5]="GRAPH",vt[vt.FLOATS=6]="FLOATS",vt[vt.INTS=7]="INTS",vt[vt.STRINGS=8]="STRINGS",vt[vt.TENSORS=9]="TENSORS",vt[vt.GRAPHS=10]="GRAPHS",vt[vt.SPARSE_TENSOR=11]="SPARSE_TENSOR",vt[vt.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(pt.AttributeType||(pt.AttributeType={}))})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{(vt=>(vt[vt.UNKNOWN=0]="UNKNOWN",vt[vt.VALUE=1]="VALUE",vt[vt.PARAM=2]="PARAM"))(pt.DimensionValueType||(pt.DimensionValueType={}))})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{(vt=>(vt[vt.UNDEFINED=0]="UNDEFINED",vt[vt.FLOAT=1]="FLOAT",vt[vt.UINT8=2]="UINT8",vt[vt.INT8=3]="INT8",vt[vt.UINT16=4]="UINT16",vt[vt.INT16=5]="INT16",vt[vt.INT32=6]="INT32",vt[vt.INT64=7]="INT64",vt[vt.STRING=8]="STRING",vt[vt.BOOL=9]="BOOL",vt[vt.FLOAT16=10]="FLOAT16",vt[vt.DOUBLE=11]="DOUBLE",vt[vt.UINT32=12]="UINT32",vt[vt.UINT64=13]="UINT64",vt[vt.COMPLEX64=14]="COMPLEX64",vt[vt.COMPLEX128=15]="COMPLEX128",vt[vt.BFLOAT16=16]="BFLOAT16",vt[vt.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",vt[vt.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",vt[vt.FLOAT8E5M2=19]="FLOAT8E5M2",vt[vt.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(pt.TensorDataType||(pt.TensorDataType={}))})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{(vt=>(vt[vt.Primitive=0]="Primitive",vt[vt.Fused=1]="Fused"))(pt.NodeType||(pt.NodeType={}))})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{(vt=>(vt[vt.NONE=0]="NONE",vt[vt.tensor_type=1]="tensor_type",vt[vt.sequence_type=2]="sequence_type",vt[vt.map_type=3]="map_type"))(pt.TypeInfoValue||(pt.TypeInfoValue={}))})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsShape($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsShape($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}dim($t,Tt){let Lt=this.bb.__offset(this.bb_pos,4);return Lt?(Tt||new st.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+Lt)+$t*4),this.bb):null}dimLength(){let $t=this.bb.__offset(this.bb_pos,4);return $t?this.bb.__vector_len(this.bb_pos+$t):0}static startShape($t){$t.startObject(1)}static addDim($t,Tt){$t.addFieldOffset(0,Tt,0)}static createDimVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startDimVector($t,Tt){$t.startVector(4,Tt,4)}static endShape($t){return $t.endObject()}static createShape($t,Tt){return vt.startShape($t),vt.addDim($t,Tt),vt.endShape($t)}}pt.Shape=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsDimension($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsDimension($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}value($t){let Tt=this.bb.__offset(this.bb_pos,4);return Tt?($t||new st.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+Tt),this.bb):null}denotation($t){let Tt=this.bb.__offset(this.bb_pos,6);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}static startDimension($t){$t.startObject(2)}static addValue($t,Tt){$t.addFieldOffset(0,Tt,0)}static addDenotation($t,Tt){$t.addFieldOffset(1,Tt,0)}static endDimension($t){return $t.endObject()}static createDimension($t,Tt,Lt){return vt.startDimension($t),vt.addValue($t,Tt),vt.addDenotation($t,Lt),vt.endDimension($t)}}pt.Dimension=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsDimensionValue($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsDimensionValue($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}dimType(){let $t=this.bb.__offset(this.bb_pos,4);return $t?this.bb.readInt8(this.bb_pos+$t):0}dimValue(){let $t=this.bb.__offset(this.bb_pos,6);return $t?this.bb.readInt64(this.bb_pos+$t):this.bb.createLong(0,0)}dimParam($t){let Tt=this.bb.__offset(this.bb_pos,8);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}static startDimensionValue($t){$t.startObject(3)}static addDimType($t,Tt){$t.addFieldInt8(0,Tt,0)}static addDimValue($t,Tt){$t.addFieldInt64(1,Tt,$t.createLong(0,0))}static addDimParam($t,Tt){$t.addFieldOffset(2,Tt,0)}static endDimensionValue($t){return $t.endObject()}static createDimensionValue($t,Tt,Lt,Ft){return vt.startDimensionValue($t),vt.addDimType($t,Tt),vt.addDimValue($t,Lt),vt.addDimParam($t,Ft),vt.endDimensionValue($t)}}pt.DimensionValue=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsTensorTypeAndShape($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsTensorTypeAndShape($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}elemType(){let $t=this.bb.__offset(this.bb_pos,4);return $t?this.bb.readInt32(this.bb_pos+$t):0}shape($t){let Tt=this.bb.__offset(this.bb_pos,6);return Tt?($t||new st.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+Tt),this.bb):null}static startTensorTypeAndShape($t){$t.startObject(2)}static addElemType($t,Tt){$t.addFieldInt32(0,Tt,0)}static addShape($t,Tt){$t.addFieldOffset(1,Tt,0)}static endTensorTypeAndShape($t){return $t.endObject()}static createTensorTypeAndShape($t,Tt,Lt){return vt.startTensorTypeAndShape($t),vt.addElemType($t,Tt),vt.addShape($t,Lt),vt.endTensorTypeAndShape($t)}}pt.TensorTypeAndShape=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsMapType($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsMapType($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}keyType(){let $t=this.bb.__offset(this.bb_pos,4);return $t?this.bb.readInt32(this.bb_pos+$t):0}valueType($t){let Tt=this.bb.__offset(this.bb_pos,6);return Tt?($t||new st.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+Tt),this.bb):null}static startMapType($t){$t.startObject(2)}static addKeyType($t,Tt){$t.addFieldInt32(0,Tt,0)}static addValueType($t,Tt){$t.addFieldOffset(1,Tt,0)}static endMapType($t){return $t.endObject()}static createMapType($t,Tt,Lt){return vt.startMapType($t),vt.addKeyType($t,Tt),vt.addValueType($t,Lt),vt.endMapType($t)}}pt.MapType=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsSequenceType($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsSequenceType($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}elemType($t){let Tt=this.bb.__offset(this.bb_pos,4);return Tt?($t||new st.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+Tt),this.bb):null}static startSequenceType($t){$t.startObject(1)}static addElemType($t,Tt){$t.addFieldOffset(0,Tt,0)}static endSequenceType($t){return $t.endObject()}static createSequenceType($t,Tt){return vt.startSequenceType($t),vt.addElemType($t,Tt),vt.endSequenceType($t)}}pt.SequenceType=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd($t,Tt,Lt,Ft){return $t.prep(4,12),$t.writeInt32(Ft),$t.writeInt32(Lt),$t.writeInt32(Tt),$t.offset()}}pt.EdgeEnd=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsNodeEdge($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsNodeEdge($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}nodeIndex(){let $t=this.bb.__offset(this.bb_pos,4);return $t?this.bb.readUint32(this.bb_pos+$t):0}inputEdges($t,Tt){let Lt=this.bb.__offset(this.bb_pos,6);return Lt?(Tt||new st.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+Lt)+$t*12,this.bb):null}inputEdgesLength(){let $t=this.bb.__offset(this.bb_pos,6);return $t?this.bb.__vector_len(this.bb_pos+$t):0}outputEdges($t,Tt){let Lt=this.bb.__offset(this.bb_pos,8);return Lt?(Tt||new st.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+Lt)+$t*12,this.bb):null}outputEdgesLength(){let $t=this.bb.__offset(this.bb_pos,8);return $t?this.bb.__vector_len(this.bb_pos+$t):0}static startNodeEdge($t){$t.startObject(3)}static addNodeIndex($t,Tt){$t.addFieldInt32(0,Tt,0)}static addInputEdges($t,Tt){$t.addFieldOffset(1,Tt,0)}static startInputEdgesVector($t,Tt){$t.startVector(12,Tt,4)}static addOutputEdges($t,Tt){$t.addFieldOffset(2,Tt,0)}static startOutputEdgesVector($t,Tt){$t.startVector(12,Tt,4)}static endNodeEdge($t){return $t.endObject()}static createNodeEdge($t,Tt,Lt,Ft){return vt.startNodeEdge($t),vt.addNodeIndex($t,Tt),vt.addInputEdges($t,Lt),vt.addOutputEdges($t,Ft),vt.endNodeEdge($t)}}pt.NodeEdge=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsNode($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsNode($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}name($t){let Tt=this.bb.__offset(this.bb_pos,4);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}docString($t){let Tt=this.bb.__offset(this.bb_pos,6);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}domain($t){let Tt=this.bb.__offset(this.bb_pos,8);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}sinceVersion(){let $t=this.bb.__offset(this.bb_pos,10);return $t?this.bb.readInt32(this.bb_pos+$t):0}index(){let $t=this.bb.__offset(this.bb_pos,12);return $t?this.bb.readUint32(this.bb_pos+$t):0}opType($t){let Tt=this.bb.__offset(this.bb_pos,14);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}type(){let $t=this.bb.__offset(this.bb_pos,16);return $t?this.bb.readInt32(this.bb_pos+$t):0}executionProviderType($t){let Tt=this.bb.__offset(this.bb_pos,18);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}inputs($t,Tt){let Lt=this.bb.__offset(this.bb_pos,20);return Lt?this.bb.__string(this.bb.__vector(this.bb_pos+Lt)+$t*4,Tt):null}inputsLength(){let $t=this.bb.__offset(this.bb_pos,20);return $t?this.bb.__vector_len(this.bb_pos+$t):0}outputs($t,Tt){let Lt=this.bb.__offset(this.bb_pos,22);return Lt?this.bb.__string(this.bb.__vector(this.bb_pos+Lt)+$t*4,Tt):null}outputsLength(){let $t=this.bb.__offset(this.bb_pos,22);return $t?this.bb.__vector_len(this.bb_pos+$t):0}attributes($t,Tt){let Lt=this.bb.__offset(this.bb_pos,24);return Lt?(Tt||new st.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+Lt)+$t*4),this.bb):null}attributesLength(){let $t=this.bb.__offset(this.bb_pos,24);return $t?this.bb.__vector_len(this.bb_pos+$t):0}inputArgCounts($t){let Tt=this.bb.__offset(this.bb_pos,26);return Tt?this.bb.readInt32(this.bb.__vector(this.bb_pos+Tt)+$t*4):0}inputArgCountsLength(){let $t=this.bb.__offset(this.bb_pos,26);return $t?this.bb.__vector_len(this.bb_pos+$t):0}inputArgCountsArray(){let $t=this.bb.__offset(this.bb_pos,26);return $t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+$t),this.bb.__vector_len(this.bb_pos+$t)):null}implicitInputs($t,Tt){let Lt=this.bb.__offset(this.bb_pos,28);return Lt?this.bb.__string(this.bb.__vector(this.bb_pos+Lt)+$t*4,Tt):null}implicitInputsLength(){let $t=this.bb.__offset(this.bb_pos,28);return $t?this.bb.__vector_len(this.bb_pos+$t):0}static startNode($t){$t.startObject(13)}static addName($t,Tt){$t.addFieldOffset(0,Tt,0)}static addDocString($t,Tt){$t.addFieldOffset(1,Tt,0)}static addDomain($t,Tt){$t.addFieldOffset(2,Tt,0)}static addSinceVersion($t,Tt){$t.addFieldInt32(3,Tt,0)}static addIndex($t,Tt){$t.addFieldInt32(4,Tt,0)}static addOpType($t,Tt){$t.addFieldOffset(5,Tt,0)}static addType($t,Tt){$t.addFieldInt32(6,Tt,0)}static addExecutionProviderType($t,Tt){$t.addFieldOffset(7,Tt,0)}static addInputs($t,Tt){$t.addFieldOffset(8,Tt,0)}static createInputsVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startInputsVector($t,Tt){$t.startVector(4,Tt,4)}static addOutputs($t,Tt){$t.addFieldOffset(9,Tt,0)}static createOutputsVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startOutputsVector($t,Tt){$t.startVector(4,Tt,4)}static addAttributes($t,Tt){$t.addFieldOffset(10,Tt,0)}static createAttributesVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startAttributesVector($t,Tt){$t.startVector(4,Tt,4)}static addInputArgCounts($t,Tt){$t.addFieldOffset(11,Tt,0)}static createInputArgCountsVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addInt32(Tt[Lt]);return $t.endVector()}static startInputArgCountsVector($t,Tt){$t.startVector(4,Tt,4)}static addImplicitInputs($t,Tt){$t.addFieldOffset(12,Tt,0)}static createImplicitInputsVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startImplicitInputsVector($t,Tt){$t.startVector(4,Tt,4)}static endNode($t){return $t.endObject()}static createNode($t,Tt,Lt,Ft,Ct,Ht,Gt,jt,qt,Kt,An,Sn,wn,In){return vt.startNode($t),vt.addName($t,Tt),vt.addDocString($t,Lt),vt.addDomain($t,Ft),vt.addSinceVersion($t,Ct),vt.addIndex($t,Ht),vt.addOpType($t,Gt),vt.addType($t,jt),vt.addExecutionProviderType($t,qt),vt.addInputs($t,Kt),vt.addOutputs($t,An),vt.addAttributes($t,Sn),vt.addInputArgCounts($t,wn),vt.addImplicitInputs($t,In),vt.endNode($t)}}pt.Node=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsValueInfo($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsValueInfo($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}name($t){let Tt=this.bb.__offset(this.bb_pos,4);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}docString($t){let Tt=this.bb.__offset(this.bb_pos,6);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}type($t){let Tt=this.bb.__offset(this.bb_pos,8);return Tt?($t||new st.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+Tt),this.bb):null}static startValueInfo($t){$t.startObject(3)}static addName($t,Tt){$t.addFieldOffset(0,Tt,0)}static addDocString($t,Tt){$t.addFieldOffset(1,Tt,0)}static addType($t,Tt){$t.addFieldOffset(2,Tt,0)}static endValueInfo($t){return $t.endObject()}static createValueInfo($t,Tt,Lt,Ft){return vt.startValueInfo($t),vt.addName($t,Tt),vt.addDocString($t,Lt),vt.addType($t,Ft),vt.endValueInfo($t)}}pt.ValueInfo=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsTypeInfo($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsTypeInfo($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}denotation($t){let Tt=this.bb.__offset(this.bb_pos,4);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}valueType(){let $t=this.bb.__offset(this.bb_pos,6);return $t?this.bb.readUint8(this.bb_pos+$t):0}value($t){let Tt=this.bb.__offset(this.bb_pos,8);return Tt?this.bb.__union($t,this.bb_pos+Tt):null}static startTypeInfo($t){$t.startObject(3)}static addDenotation($t,Tt){$t.addFieldOffset(0,Tt,0)}static addValueType($t,Tt){$t.addFieldInt8(1,Tt,0)}static addValue($t,Tt){$t.addFieldOffset(2,Tt,0)}static endTypeInfo($t){return $t.endObject()}static createTypeInfo($t,Tt,Lt,Ft){return vt.startTypeInfo($t),vt.addDenotation($t,Tt),vt.addValueType($t,Lt),vt.addValue($t,Ft),vt.endTypeInfo($t)}}pt.TypeInfo=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsOperatorSetId($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsOperatorSetId($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}domain($t){let Tt=this.bb.__offset(this.bb_pos,4);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}version(){let $t=this.bb.__offset(this.bb_pos,6);return $t?this.bb.readInt64(this.bb_pos+$t):this.bb.createLong(0,0)}static startOperatorSetId($t){$t.startObject(2)}static addDomain($t,Tt){$t.addFieldOffset(0,Tt,0)}static addVersion($t,Tt){$t.addFieldInt64(1,Tt,$t.createLong(0,0))}static endOperatorSetId($t){return $t.endObject()}static createOperatorSetId($t,Tt,Lt){return vt.startOperatorSetId($t),vt.addDomain($t,Tt),vt.addVersion($t,Lt),vt.endOperatorSetId($t)}}pt.OperatorSetId=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsTensor($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsTensor($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}name($t){let Tt=this.bb.__offset(this.bb_pos,4);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}docString($t){let Tt=this.bb.__offset(this.bb_pos,6);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}dims($t){let Tt=this.bb.__offset(this.bb_pos,8);return Tt?this.bb.readInt64(this.bb.__vector(this.bb_pos+Tt)+$t*8):this.bb.createLong(0,0)}dimsLength(){let $t=this.bb.__offset(this.bb_pos,8);return $t?this.bb.__vector_len(this.bb_pos+$t):0}dataType(){let $t=this.bb.__offset(this.bb_pos,10);return $t?this.bb.readInt32(this.bb_pos+$t):0}rawData($t){let Tt=this.bb.__offset(this.bb_pos,12);return Tt?this.bb.readUint8(this.bb.__vector(this.bb_pos+Tt)+$t):0}rawDataLength(){let $t=this.bb.__offset(this.bb_pos,12);return $t?this.bb.__vector_len(this.bb_pos+$t):0}rawDataArray(){let $t=this.bb.__offset(this.bb_pos,12);return $t?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+$t),this.bb.__vector_len(this.bb_pos+$t)):null}stringData($t,Tt){let Lt=this.bb.__offset(this.bb_pos,14);return Lt?this.bb.__string(this.bb.__vector(this.bb_pos+Lt)+$t*4,Tt):null}stringDataLength(){let $t=this.bb.__offset(this.bb_pos,14);return $t?this.bb.__vector_len(this.bb_pos+$t):0}static startTensor($t){$t.startObject(6)}static addName($t,Tt){$t.addFieldOffset(0,Tt,0)}static addDocString($t,Tt){$t.addFieldOffset(1,Tt,0)}static addDims($t,Tt){$t.addFieldOffset(2,Tt,0)}static createDimsVector($t,Tt){$t.startVector(8,Tt.length,8);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addInt64(Tt[Lt]);return $t.endVector()}static startDimsVector($t,Tt){$t.startVector(8,Tt,8)}static addDataType($t,Tt){$t.addFieldInt32(3,Tt,0)}static addRawData($t,Tt){$t.addFieldOffset(4,Tt,0)}static createRawDataVector($t,Tt){$t.startVector(1,Tt.length,1);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addInt8(Tt[Lt]);return $t.endVector()}static startRawDataVector($t,Tt){$t.startVector(1,Tt,1)}static addStringData($t,Tt){$t.addFieldOffset(5,Tt,0)}static createStringDataVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startStringDataVector($t,Tt){$t.startVector(4,Tt,4)}static endTensor($t){return $t.endObject()}static createTensor($t,Tt,Lt,Ft,Ct,Ht,Gt){return vt.startTensor($t),vt.addName($t,Tt),vt.addDocString($t,Lt),vt.addDims($t,Ft),vt.addDataType($t,Ct),vt.addRawData($t,Ht),vt.addStringData($t,Gt),vt.endTensor($t)}}pt.Tensor=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsSparseTensor($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsSparseTensor($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}values($t){let Tt=this.bb.__offset(this.bb_pos,4);return Tt?($t||new st.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+Tt),this.bb):null}indices($t){let Tt=this.bb.__offset(this.bb_pos,6);return Tt?($t||new st.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+Tt),this.bb):null}dims($t){let Tt=this.bb.__offset(this.bb_pos,8);return Tt?this.bb.readInt64(this.bb.__vector(this.bb_pos+Tt)+$t*8):this.bb.createLong(0,0)}dimsLength(){let $t=this.bb.__offset(this.bb_pos,8);return $t?this.bb.__vector_len(this.bb_pos+$t):0}static startSparseTensor($t){$t.startObject(3)}static addValues($t,Tt){$t.addFieldOffset(0,Tt,0)}static addIndices($t,Tt){$t.addFieldOffset(1,Tt,0)}static addDims($t,Tt){$t.addFieldOffset(2,Tt,0)}static createDimsVector($t,Tt){$t.startVector(8,Tt.length,8);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addInt64(Tt[Lt]);return $t.endVector()}static startDimsVector($t,Tt){$t.startVector(8,Tt,8)}static endSparseTensor($t){return $t.endObject()}static createSparseTensor($t,Tt,Lt,Ft){return vt.startSparseTensor($t),vt.addValues($t,Tt),vt.addIndices($t,Lt),vt.addDims($t,Ft),vt.endSparseTensor($t)}}pt.SparseTensor=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsAttribute($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsAttribute($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}name($t){let Tt=this.bb.__offset(this.bb_pos,4);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}docString($t){let Tt=this.bb.__offset(this.bb_pos,6);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}type(){let $t=this.bb.__offset(this.bb_pos,8);return $t?this.bb.readInt32(this.bb_pos+$t):0}f(){let $t=this.bb.__offset(this.bb_pos,10);return $t?this.bb.readFloat32(this.bb_pos+$t):0}i(){let $t=this.bb.__offset(this.bb_pos,12);return $t?this.bb.readInt64(this.bb_pos+$t):this.bb.createLong(0,0)}s($t){let Tt=this.bb.__offset(this.bb_pos,14);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}t($t){let Tt=this.bb.__offset(this.bb_pos,16);return Tt?($t||new st.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+Tt),this.bb):null}g($t){let Tt=this.bb.__offset(this.bb_pos,18);return Tt?($t||new st.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+Tt),this.bb):null}floats($t){let Tt=this.bb.__offset(this.bb_pos,20);return Tt?this.bb.readFloat32(this.bb.__vector(this.bb_pos+Tt)+$t*4):0}floatsLength(){let $t=this.bb.__offset(this.bb_pos,20);return $t?this.bb.__vector_len(this.bb_pos+$t):0}floatsArray(){let $t=this.bb.__offset(this.bb_pos,20);return $t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+$t),this.bb.__vector_len(this.bb_pos+$t)):null}ints($t){let Tt=this.bb.__offset(this.bb_pos,22);return Tt?this.bb.readInt64(this.bb.__vector(this.bb_pos+Tt)+$t*8):this.bb.createLong(0,0)}intsLength(){let $t=this.bb.__offset(this.bb_pos,22);return $t?this.bb.__vector_len(this.bb_pos+$t):0}strings($t,Tt){let Lt=this.bb.__offset(this.bb_pos,24);return Lt?this.bb.__string(this.bb.__vector(this.bb_pos+Lt)+$t*4,Tt):null}stringsLength(){let $t=this.bb.__offset(this.bb_pos,24);return $t?this.bb.__vector_len(this.bb_pos+$t):0}tensors($t,Tt){let Lt=this.bb.__offset(this.bb_pos,26);return Lt?(Tt||new st.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+Lt)+$t*4),this.bb):null}tensorsLength(){let $t=this.bb.__offset(this.bb_pos,26);return $t?this.bb.__vector_len(this.bb_pos+$t):0}graphs($t,Tt){let Lt=this.bb.__offset(this.bb_pos,28);return Lt?(Tt||new st.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+Lt)+$t*4),this.bb):null}graphsLength(){let $t=this.bb.__offset(this.bb_pos,28);return $t?this.bb.__vector_len(this.bb_pos+$t):0}static startAttribute($t){$t.startObject(13)}static addName($t,Tt){$t.addFieldOffset(0,Tt,0)}static addDocString($t,Tt){$t.addFieldOffset(1,Tt,0)}static addType($t,Tt){$t.addFieldInt32(2,Tt,0)}static addF($t,Tt){$t.addFieldFloat32(3,Tt,0)}static addI($t,Tt){$t.addFieldInt64(4,Tt,$t.createLong(0,0))}static addS($t,Tt){$t.addFieldOffset(5,Tt,0)}static addT($t,Tt){$t.addFieldOffset(6,Tt,0)}static addG($t,Tt){$t.addFieldOffset(7,Tt,0)}static addFloats($t,Tt){$t.addFieldOffset(8,Tt,0)}static createFloatsVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addFloat32(Tt[Lt]);return $t.endVector()}static startFloatsVector($t,Tt){$t.startVector(4,Tt,4)}static addInts($t,Tt){$t.addFieldOffset(9,Tt,0)}static createIntsVector($t,Tt){$t.startVector(8,Tt.length,8);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addInt64(Tt[Lt]);return $t.endVector()}static startIntsVector($t,Tt){$t.startVector(8,Tt,8)}static addStrings($t,Tt){$t.addFieldOffset(10,Tt,0)}static createStringsVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startStringsVector($t,Tt){$t.startVector(4,Tt,4)}static addTensors($t,Tt){$t.addFieldOffset(11,Tt,0)}static createTensorsVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startTensorsVector($t,Tt){$t.startVector(4,Tt,4)}static addGraphs($t,Tt){$t.addFieldOffset(12,Tt,0)}static createGraphsVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startGraphsVector($t,Tt){$t.startVector(4,Tt,4)}static endAttribute($t){return $t.endObject()}static createAttribute($t,Tt,Lt,Ft,Ct,Ht,Gt,jt,qt,Kt,An,Sn,wn,In){return vt.startAttribute($t),vt.addName($t,Tt),vt.addDocString($t,Lt),vt.addType($t,Ft),vt.addF($t,Ct),vt.addI($t,Ht),vt.addS($t,Gt),vt.addT($t,jt),vt.addG($t,qt),vt.addFloats($t,Kt),vt.addInts($t,An),vt.addStrings($t,Sn),vt.addTensors($t,wn),vt.addGraphs($t,In),vt.endAttribute($t)}}pt.Attribute=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsGraph($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsGraph($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}initializers($t,Tt){let Lt=this.bb.__offset(this.bb_pos,4);return Lt?(Tt||new st.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+Lt)+$t*4),this.bb):null}initializersLength(){let $t=this.bb.__offset(this.bb_pos,4);return $t?this.bb.__vector_len(this.bb_pos+$t):0}nodeArgs($t,Tt){let Lt=this.bb.__offset(this.bb_pos,6);return Lt?(Tt||new st.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+Lt)+$t*4),this.bb):null}nodeArgsLength(){let $t=this.bb.__offset(this.bb_pos,6);return $t?this.bb.__vector_len(this.bb_pos+$t):0}nodes($t,Tt){let Lt=this.bb.__offset(this.bb_pos,8);return Lt?(Tt||new st.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+Lt)+$t*4),this.bb):null}nodesLength(){let $t=this.bb.__offset(this.bb_pos,8);return $t?this.bb.__vector_len(this.bb_pos+$t):0}maxNodeIndex(){let $t=this.bb.__offset(this.bb_pos,10);return $t?this.bb.readUint32(this.bb_pos+$t):0}nodeEdges($t,Tt){let Lt=this.bb.__offset(this.bb_pos,12);return Lt?(Tt||new st.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+Lt)+$t*4),this.bb):null}nodeEdgesLength(){let $t=this.bb.__offset(this.bb_pos,12);return $t?this.bb.__vector_len(this.bb_pos+$t):0}inputs($t,Tt){let Lt=this.bb.__offset(this.bb_pos,14);return Lt?this.bb.__string(this.bb.__vector(this.bb_pos+Lt)+$t*4,Tt):null}inputsLength(){let $t=this.bb.__offset(this.bb_pos,14);return $t?this.bb.__vector_len(this.bb_pos+$t):0}outputs($t,Tt){let Lt=this.bb.__offset(this.bb_pos,16);return Lt?this.bb.__string(this.bb.__vector(this.bb_pos+Lt)+$t*4,Tt):null}outputsLength(){let $t=this.bb.__offset(this.bb_pos,16);return $t?this.bb.__vector_len(this.bb_pos+$t):0}sparseInitializers($t,Tt){let Lt=this.bb.__offset(this.bb_pos,18);return Lt?(Tt||new st.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+Lt)+$t*4),this.bb):null}sparseInitializersLength(){let $t=this.bb.__offset(this.bb_pos,18);return $t?this.bb.__vector_len(this.bb_pos+$t):0}static startGraph($t){$t.startObject(8)}static addInitializers($t,Tt){$t.addFieldOffset(0,Tt,0)}static createInitializersVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startInitializersVector($t,Tt){$t.startVector(4,Tt,4)}static addNodeArgs($t,Tt){$t.addFieldOffset(1,Tt,0)}static createNodeArgsVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startNodeArgsVector($t,Tt){$t.startVector(4,Tt,4)}static addNodes($t,Tt){$t.addFieldOffset(2,Tt,0)}static createNodesVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startNodesVector($t,Tt){$t.startVector(4,Tt,4)}static addMaxNodeIndex($t,Tt){$t.addFieldInt32(3,Tt,0)}static addNodeEdges($t,Tt){$t.addFieldOffset(4,Tt,0)}static createNodeEdgesVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startNodeEdgesVector($t,Tt){$t.startVector(4,Tt,4)}static addInputs($t,Tt){$t.addFieldOffset(5,Tt,0)}static createInputsVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startInputsVector($t,Tt){$t.startVector(4,Tt,4)}static addOutputs($t,Tt){$t.addFieldOffset(6,Tt,0)}static createOutputsVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startOutputsVector($t,Tt){$t.startVector(4,Tt,4)}static addSparseInitializers($t,Tt){$t.addFieldOffset(7,Tt,0)}static createSparseInitializersVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startSparseInitializersVector($t,Tt){$t.startVector(4,Tt,4)}static endGraph($t){return $t.endObject()}static createGraph($t,Tt,Lt,Ft,Ct,Ht,Gt,jt,qt){return vt.startGraph($t),vt.addInitializers($t,Tt),vt.addNodeArgs($t,Lt),vt.addNodes($t,Ft),vt.addMaxNodeIndex($t,Ct),vt.addNodeEdges($t,Ht),vt.addInputs($t,Gt),vt.addOutputs($t,jt),vt.addSparseInitializers($t,qt),vt.endGraph($t)}}pt.Graph=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsModel($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsModel($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}irVersion(){let $t=this.bb.__offset(this.bb_pos,4);return $t?this.bb.readInt64(this.bb_pos+$t):this.bb.createLong(0,0)}opsetImport($t,Tt){let Lt=this.bb.__offset(this.bb_pos,6);return Lt?(Tt||new st.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+Lt)+$t*4),this.bb):null}opsetImportLength(){let $t=this.bb.__offset(this.bb_pos,6);return $t?this.bb.__vector_len(this.bb_pos+$t):0}producerName($t){let Tt=this.bb.__offset(this.bb_pos,8);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}producerVersion($t){let Tt=this.bb.__offset(this.bb_pos,10);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}domain($t){let Tt=this.bb.__offset(this.bb_pos,12);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}modelVersion(){let $t=this.bb.__offset(this.bb_pos,14);return $t?this.bb.readInt64(this.bb_pos+$t):this.bb.createLong(0,0)}docString($t){let Tt=this.bb.__offset(this.bb_pos,16);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}graph($t){let Tt=this.bb.__offset(this.bb_pos,18);return Tt?($t||new st.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+Tt),this.bb):null}graphDocString($t){let Tt=this.bb.__offset(this.bb_pos,20);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}static startModel($t){$t.startObject(9)}static addIrVersion($t,Tt){$t.addFieldInt64(0,Tt,$t.createLong(0,0))}static addOpsetImport($t,Tt){$t.addFieldOffset(1,Tt,0)}static createOpsetImportVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startOpsetImportVector($t,Tt){$t.startVector(4,Tt,4)}static addProducerName($t,Tt){$t.addFieldOffset(2,Tt,0)}static addProducerVersion($t,Tt){$t.addFieldOffset(3,Tt,0)}static addDomain($t,Tt){$t.addFieldOffset(4,Tt,0)}static addModelVersion($t,Tt){$t.addFieldInt64(5,Tt,$t.createLong(0,0))}static addDocString($t,Tt){$t.addFieldOffset(6,Tt,0)}static addGraph($t,Tt){$t.addFieldOffset(7,Tt,0)}static addGraphDocString($t,Tt){$t.addFieldOffset(8,Tt,0)}static endModel($t){return $t.endObject()}static createModel($t,Tt,Lt,Ft,Ct,Ht,Gt,jt,qt,Kt){return vt.startModel($t),vt.addIrVersion($t,Tt),vt.addOpsetImport($t,Lt),vt.addProducerName($t,Ft),vt.addProducerVersion($t,Ct),vt.addDomain($t,Ht),vt.addModelVersion($t,Gt),vt.addDocString($t,jt),vt.addGraph($t,qt),vt.addGraphDocString($t,Kt),vt.endModel($t)}}pt.Model=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsKernelCreateInfos($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsKernelCreateInfos($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}nodeIndices($t){let Tt=this.bb.__offset(this.bb_pos,4);return Tt?this.bb.readUint32(this.bb.__vector(this.bb_pos+Tt)+$t*4):0}nodeIndicesLength(){let $t=this.bb.__offset(this.bb_pos,4);return $t?this.bb.__vector_len(this.bb_pos+$t):0}nodeIndicesArray(){let $t=this.bb.__offset(this.bb_pos,4);return $t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+$t),this.bb.__vector_len(this.bb_pos+$t)):null}kernelDefHashes($t){let Tt=this.bb.__offset(this.bb_pos,6);return Tt?this.bb.readUint64(this.bb.__vector(this.bb_pos+Tt)+$t*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let $t=this.bb.__offset(this.bb_pos,6);return $t?this.bb.__vector_len(this.bb_pos+$t):0}static startKernelCreateInfos($t){$t.startObject(2)}static addNodeIndices($t,Tt){$t.addFieldOffset(0,Tt,0)}static createNodeIndicesVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addInt32(Tt[Lt]);return $t.endVector()}static startNodeIndicesVector($t,Tt){$t.startVector(4,Tt,4)}static addKernelDefHashes($t,Tt){$t.addFieldOffset(1,Tt,0)}static createKernelDefHashesVector($t,Tt){$t.startVector(8,Tt.length,8);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addInt64(Tt[Lt]);return $t.endVector()}static startKernelDefHashesVector($t,Tt){$t.startVector(8,Tt,8)}static endKernelCreateInfos($t){return $t.endObject()}static createKernelCreateInfos($t,Tt,Lt){return vt.startKernelCreateInfos($t),vt.addNodeIndices($t,Tt),vt.addKernelDefHashes($t,Lt),vt.endKernelCreateInfos($t)}}pt.KernelCreateInfos=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsSubGraphSessionState($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsSubGraphSessionState($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}graphId($t){let Tt=this.bb.__offset(this.bb_pos,4);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}sessionState($t){let Tt=this.bb.__offset(this.bb_pos,6);return Tt?($t||new st.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+Tt),this.bb):null}static startSubGraphSessionState($t){$t.startObject(2)}static addGraphId($t,Tt){$t.addFieldOffset(0,Tt,0)}static addSessionState($t,Tt){$t.addFieldOffset(1,Tt,0)}static endSubGraphSessionState($t){let Tt=$t.endObject();return $t.requiredField(Tt,4),Tt}static createSubGraphSessionState($t,Tt,Lt){return vt.startSubGraphSessionState($t),vt.addGraphId($t,Tt),vt.addSessionState($t,Lt),vt.endSubGraphSessionState($t)}}pt.SubGraphSessionState=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsSessionState($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsSessionState($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}kernels($t){let Tt=this.bb.__offset(this.bb_pos,4);return Tt?($t||new st.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+Tt),this.bb):null}subGraphSessionStates($t,Tt){let Lt=this.bb.__offset(this.bb_pos,6);return Lt?(Tt||new st.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+Lt)+$t*4),this.bb):null}subGraphSessionStatesLength(){let $t=this.bb.__offset(this.bb_pos,6);return $t?this.bb.__vector_len(this.bb_pos+$t):0}static startSessionState($t){$t.startObject(2)}static addKernels($t,Tt){$t.addFieldOffset(0,Tt,0)}static addSubGraphSessionStates($t,Tt){$t.addFieldOffset(1,Tt,0)}static createSubGraphSessionStatesVector($t,Tt){$t.startVector(4,Tt.length,4);for(let Lt=Tt.length-1;Lt>=0;Lt--)$t.addOffset(Tt[Lt]);return $t.endVector()}static startSubGraphSessionStatesVector($t,Tt){$t.startVector(4,Tt,4)}static endSessionState($t){return $t.endObject()}static createSessionState($t,Tt,Lt){return vt.startSessionState($t),vt.addKernels($t,Tt),vt.addSubGraphSessionStates($t,Lt),vt.endSessionState($t)}}pt.SessionState=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={})),(st=>{(at=>{(pt=>{class vt{constructor(){this.bb=null,this.bb_pos=0}__init($t,Tt){return this.bb_pos=$t,this.bb=Tt,this}static getRootAsInferenceSession($t,Tt){return(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static getSizePrefixedRootAsInferenceSession($t,Tt){return $t.setPosition($t.position()+_.SIZE_PREFIX_LENGTH),(Tt||new vt).__init($t.readInt32($t.position())+$t.position(),$t)}static bufferHasIdentifier($t){return $t.__has_identifier("ORTM")}ortVersion($t){let Tt=this.bb.__offset(this.bb_pos,4);return Tt?this.bb.__string(this.bb_pos+Tt,$t):null}model($t){let Tt=this.bb.__offset(this.bb_pos,6);return Tt?($t||new st.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+Tt),this.bb):null}sessionState($t){let Tt=this.bb.__offset(this.bb_pos,8);return Tt?($t||new st.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+Tt),this.bb):null}static startInferenceSession($t){$t.startObject(3)}static addOrtVersion($t,Tt){$t.addFieldOffset(0,Tt,0)}static addModel($t,Tt){$t.addFieldOffset(1,Tt,0)}static addSessionState($t,Tt){$t.addFieldOffset(2,Tt,0)}static endInferenceSession($t){return $t.endObject()}static finishInferenceSessionBuffer($t,Tt){$t.finish(Tt,"ORTM")}static finishSizePrefixedInferenceSessionBuffer($t,Tt){$t.finish(Tt,"ORTM",!0)}static createInferenceSession($t,Tt,Lt,Ft){return vt.startInferenceSession($t),vt.addOrtVersion($t,Tt),vt.addModel($t,Lt),vt.addSessionState($t,Ft),vt.endInferenceSession($t)}}pt.InferenceSession=vt})(at.fbs||(at.fbs={}))})(st.experimental||(st.experimental={}))})(V||(V={}))}),Bs$1=me((st,at)=>{at.exports=pt;function pt(vt,wt){for(var $t=new Array(arguments.length-1),Tt=0,Lt=2,Ft=!0;Lt<arguments.length;)$t[Tt++]=arguments[Lt++];return new Promise(function(Ct,Ht){$t[Tt]=function(Gt){if(Ft)if(Ft=!1,Gt)Ht(Gt);else{for(var jt=new Array(arguments.length-1),qt=0;qt<jt.length;)jt[qt++]=arguments[qt];Ct.apply(null,jt)}};try{vt.apply(wt||null,$t)}catch(Gt){Ft&&(Ft=!1,Ht(Gt))}})}}),Gs$1=me(st=>{var at=st;at.length=function(Tt){var Lt=Tt.length;if(!Lt)return 0;for(var Ft=0;--Lt%4>1&&Tt.charAt(Lt)==="=";)++Ft;return Math.ceil(Tt.length*3)/4-Ft};var pt=new Array(64),vt=new Array(123);for(wt=0;wt<64;)vt[pt[wt]=wt<26?wt+65:wt<52?wt+71:wt<62?wt-4:wt-59|43]=wt++;var wt;at.encode=function(Tt,Lt,Ft){for(var Ct=null,Ht=[],Gt=0,jt=0,qt;Lt<Ft;){var Kt=Tt[Lt++];switch(jt){case 0:Ht[Gt++]=pt[Kt>>2],qt=(Kt&3)<<4,jt=1;break;case 1:Ht[Gt++]=pt[qt|Kt>>4],qt=(Kt&15)<<2,jt=2;break;case 2:Ht[Gt++]=pt[qt|Kt>>6],Ht[Gt++]=pt[Kt&63],jt=0;break}Gt>8191&&((Ct||(Ct=[])).push(String.fromCharCode.apply(String,Ht)),Gt=0)}return jt&&(Ht[Gt++]=pt[qt],Ht[Gt++]=61,jt===1&&(Ht[Gt++]=61)),Ct?(Gt&&Ct.push(String.fromCharCode.apply(String,Ht.slice(0,Gt))),Ct.join("")):String.fromCharCode.apply(String,Ht.slice(0,Gt))};var $t="invalid encoding";at.decode=function(Tt,Lt,Ft){for(var Ct=Ft,Ht=0,Gt,jt=0;jt<Tt.length;){var qt=Tt.charCodeAt(jt++);if(qt===61&&Ht>1)break;if((qt=vt[qt])===void 0)throw Error($t);switch(Ht){case 0:Gt=qt,Ht=1;break;case 1:Lt[Ft++]=Gt<<2|(qt&48)>>4,Gt=qt,Ht=2;break;case 2:Lt[Ft++]=(Gt&15)<<4|(qt&60)>>2,Gt=qt,Ht=3;break;case 3:Lt[Ft++]=(Gt&3)<<6|qt,Ht=0;break}}if(Ht===1)throw Error($t);return Ft-Ct},at.test=function(Tt){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(Tt)}}),zs$1=me((st,at)=>{at.exports=pt;function pt(){this._listeners={}}pt.prototype.on=function(vt,wt,$t){return(this._listeners[vt]||(this._listeners[vt]=[])).push({fn:wt,ctx:$t||this}),this},pt.prototype.off=function(vt,wt){if(vt===void 0)this._listeners={};else if(wt===void 0)this._listeners[vt]=[];else for(var $t=this._listeners[vt],Tt=0;Tt<$t.length;)$t[Tt].fn===wt?$t.splice(Tt,1):++Tt;return this},pt.prototype.emit=function(vt){var wt=this._listeners[vt];if(wt){for(var $t=[],Tt=1;Tt<arguments.length;)$t.push(arguments[Tt++]);for(Tt=0;Tt<wt.length;)wt[Tt].fn.apply(wt[Tt++].ctx,$t)}return this}}),Xs$1=me((st,at)=>{at.exports=pt(pt);function pt(Lt){return typeof Float32Array<"u"?function(){var Ft=new Float32Array([-0]),Ct=new Uint8Array(Ft.buffer),Ht=Ct[3]===128;function Gt(An,Sn,wn){Ft[0]=An,Sn[wn]=Ct[0],Sn[wn+1]=Ct[1],Sn[wn+2]=Ct[2],Sn[wn+3]=Ct[3]}function jt(An,Sn,wn){Ft[0]=An,Sn[wn]=Ct[3],Sn[wn+1]=Ct[2],Sn[wn+2]=Ct[1],Sn[wn+3]=Ct[0]}Lt.writeFloatLE=Ht?Gt:jt,Lt.writeFloatBE=Ht?jt:Gt;function qt(An,Sn){return Ct[0]=An[Sn],Ct[1]=An[Sn+1],Ct[2]=An[Sn+2],Ct[3]=An[Sn+3],Ft[0]}function Kt(An,Sn){return Ct[3]=An[Sn],Ct[2]=An[Sn+1],Ct[1]=An[Sn+2],Ct[0]=An[Sn+3],Ft[0]}Lt.readFloatLE=Ht?qt:Kt,Lt.readFloatBE=Ht?Kt:qt}():function(){function Ft(Ht,Gt,jt,qt){var Kt=Gt<0?1:0;if(Kt&&(Gt=-Gt),Gt===0)Ht(1/Gt>0?0:2147483648,jt,qt);else if(isNaN(Gt))Ht(2143289344,jt,qt);else if(Gt>34028234663852886e22)Ht((Kt<<31|2139095040)>>>0,jt,qt);else if(Gt<11754943508222875e-54)Ht((Kt<<31|Math.round(Gt/1401298464324817e-60))>>>0,jt,qt);else{var An=Math.floor(Math.log(Gt)/Math.LN2),Sn=Math.round(Gt*Math.pow(2,-An)*8388608)&8388607;Ht((Kt<<31|An+127<<23|Sn)>>>0,jt,qt)}}Lt.writeFloatLE=Ft.bind(null,vt),Lt.writeFloatBE=Ft.bind(null,wt);function Ct(Ht,Gt,jt){var qt=Ht(Gt,jt),Kt=(qt>>31)*2+1,An=qt>>>23&255,Sn=qt&8388607;return An===255?Sn?NaN:Kt*(1/0):An===0?Kt*1401298464324817e-60*Sn:Kt*Math.pow(2,An-150)*(Sn+8388608)}Lt.readFloatLE=Ct.bind(null,$t),Lt.readFloatBE=Ct.bind(null,Tt)}(),typeof Float64Array<"u"?function(){var Ft=new Float64Array([-0]),Ct=new Uint8Array(Ft.buffer),Ht=Ct[7]===128;function Gt(An,Sn,wn){Ft[0]=An,Sn[wn]=Ct[0],Sn[wn+1]=Ct[1],Sn[wn+2]=Ct[2],Sn[wn+3]=Ct[3],Sn[wn+4]=Ct[4],Sn[wn+5]=Ct[5],Sn[wn+6]=Ct[6],Sn[wn+7]=Ct[7]}function jt(An,Sn,wn){Ft[0]=An,Sn[wn]=Ct[7],Sn[wn+1]=Ct[6],Sn[wn+2]=Ct[5],Sn[wn+3]=Ct[4],Sn[wn+4]=Ct[3],Sn[wn+5]=Ct[2],Sn[wn+6]=Ct[1],Sn[wn+7]=Ct[0]}Lt.writeDoubleLE=Ht?Gt:jt,Lt.writeDoubleBE=Ht?jt:Gt;function qt(An,Sn){return Ct[0]=An[Sn],Ct[1]=An[Sn+1],Ct[2]=An[Sn+2],Ct[3]=An[Sn+3],Ct[4]=An[Sn+4],Ct[5]=An[Sn+5],Ct[6]=An[Sn+6],Ct[7]=An[Sn+7],Ft[0]}function Kt(An,Sn){return Ct[7]=An[Sn],Ct[6]=An[Sn+1],Ct[5]=An[Sn+2],Ct[4]=An[Sn+3],Ct[3]=An[Sn+4],Ct[2]=An[Sn+5],Ct[1]=An[Sn+6],Ct[0]=An[Sn+7],Ft[0]}Lt.readDoubleLE=Ht?qt:Kt,Lt.readDoubleBE=Ht?Kt:qt}():function(){function Ft(Ht,Gt,jt,qt,Kt,An){var Sn=qt<0?1:0;if(Sn&&(qt=-qt),qt===0)Ht(0,Kt,An+Gt),Ht(1/qt>0?0:2147483648,Kt,An+jt);else if(isNaN(qt))Ht(0,Kt,An+Gt),Ht(2146959360,Kt,An+jt);else if(qt>17976931348623157e292)Ht(0,Kt,An+Gt),Ht((Sn<<31|2146435072)>>>0,Kt,An+jt);else{var wn;if(qt<22250738585072014e-324)wn=qt/5e-324,Ht(wn>>>0,Kt,An+Gt),Ht((Sn<<31|wn/4294967296)>>>0,Kt,An+jt);else{var In=Math.floor(Math.log(qt)/Math.LN2);In===1024&&(In=1023),wn=qt*Math.pow(2,-In),Ht(wn*4503599627370496>>>0,Kt,An+Gt),Ht((Sn<<31|In+1023<<20|wn*1048576&1048575)>>>0,Kt,An+jt)}}}Lt.writeDoubleLE=Ft.bind(null,vt,0,4),Lt.writeDoubleBE=Ft.bind(null,wt,4,0);function Ct(Ht,Gt,jt,qt,Kt){var An=Ht(qt,Kt+Gt),Sn=Ht(qt,Kt+jt),wn=(Sn>>31)*2+1,In=Sn>>>20&2047,tr=4294967296*(Sn&1048575)+An;return In===2047?tr?NaN:wn*(1/0):In===0?wn*5e-324*tr:wn*Math.pow(2,In-1075)*(tr+4503599627370496)}Lt.readDoubleLE=Ct.bind(null,$t,0,4),Lt.readDoubleBE=Ct.bind(null,Tt,4,0)}(),Lt}function vt(Lt,Ft,Ct){Ft[Ct]=Lt&255,Ft[Ct+1]=Lt>>>8&255,Ft[Ct+2]=Lt>>>16&255,Ft[Ct+3]=Lt>>>24}function wt(Lt,Ft,Ct){Ft[Ct]=Lt>>>24,Ft[Ct+1]=Lt>>>16&255,Ft[Ct+2]=Lt>>>8&255,Ft[Ct+3]=Lt&255}function $t(Lt,Ft){return(Lt[Ft]|Lt[Ft+1]<<8|Lt[Ft+2]<<16|Lt[Ft+3]<<24)>>>0}function Tt(Lt,Ft){return(Lt[Ft]<<24|Lt[Ft+1]<<16|Lt[Ft+2]<<8|Lt[Ft+3])>>>0}}),Ks$1=me((exports,module)=>{module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(st){}return null}}),Zs$1=me(st=>{var at=st;at.length=function(pt){for(var vt=0,wt=0,$t=0;$t<pt.length;++$t)wt=pt.charCodeAt($t),wt<128?vt+=1:wt<2048?vt+=2:(wt&64512)===55296&&(pt.charCodeAt($t+1)&64512)===56320?(++$t,vt+=4):vt+=3;return vt},at.read=function(pt,vt,wt){var $t=wt-vt;if($t<1)return"";for(var Tt=null,Lt=[],Ft=0,Ct;vt<wt;)Ct=pt[vt++],Ct<128?Lt[Ft++]=Ct:Ct>191&&Ct<224?Lt[Ft++]=(Ct&31)<<6|pt[vt++]&63:Ct>239&&Ct<365?(Ct=((Ct&7)<<18|(pt[vt++]&63)<<12|(pt[vt++]&63)<<6|pt[vt++]&63)-65536,Lt[Ft++]=55296+(Ct>>10),Lt[Ft++]=56320+(Ct&1023)):Lt[Ft++]=(Ct&15)<<12|(pt[vt++]&63)<<6|pt[vt++]&63,Ft>8191&&((Tt||(Tt=[])).push(String.fromCharCode.apply(String,Lt)),Ft=0);return Tt?(Ft&&Tt.push(String.fromCharCode.apply(String,Lt.slice(0,Ft))),Tt.join("")):String.fromCharCode.apply(String,Lt.slice(0,Ft))},at.write=function(pt,vt,wt){for(var $t=wt,Tt,Lt,Ft=0;Ft<pt.length;++Ft)Tt=pt.charCodeAt(Ft),Tt<128?vt[wt++]=Tt:Tt<2048?(vt[wt++]=Tt>>6|192,vt[wt++]=Tt&63|128):(Tt&64512)===55296&&((Lt=pt.charCodeAt(Ft+1))&64512)===56320?(Tt=65536+((Tt&1023)<<10)+(Lt&1023),++Ft,vt[wt++]=Tt>>18|240,vt[wt++]=Tt>>12&63|128,vt[wt++]=Tt>>6&63|128,vt[wt++]=Tt&63|128):(vt[wt++]=Tt>>12|224,vt[wt++]=Tt>>6&63|128,vt[wt++]=Tt&63|128);return wt-$t}}),eu$1=me((st,at)=>{at.exports=pt;function pt(vt,wt,$t){var Tt=$t||8192,Lt=Tt>>>1,Ft=null,Ct=Tt;return function(Ht){if(Ht<1||Ht>Lt)return vt(Ht);Ct+Ht>Tt&&(Ft=vt(Tt),Ct=0);var Gt=wt.call(Ft,Ct,Ct+=Ht);return Ct&7&&(Ct=(Ct|7)+1),Gt}}}),ru$1=me((st,at)=>{at.exports=vt;var pt=Jt();function vt(Lt,Ft){this.lo=Lt>>>0,this.hi=Ft>>>0}var wt=vt.zero=new vt(0,0);wt.toNumber=function(){return 0},wt.zzEncode=wt.zzDecode=function(){return this},wt.length=function(){return 1};var $t=vt.zeroHash="\0\0\0\0\0\0\0\0";vt.fromNumber=function(Lt){if(Lt===0)return wt;var Ft=Lt<0;Ft&&(Lt=-Lt);var Ct=Lt>>>0,Ht=(Lt-Ct)/4294967296>>>0;return Ft&&(Ht=~Ht>>>0,Ct=~Ct>>>0,++Ct>4294967295&&(Ct=0,++Ht>4294967295&&(Ht=0))),new vt(Ct,Ht)},vt.from=function(Lt){if(typeof Lt=="number")return vt.fromNumber(Lt);if(pt.isString(Lt))if(pt.Long)Lt=pt.Long.fromString(Lt);else return vt.fromNumber(parseInt(Lt,10));return Lt.low||Lt.high?new vt(Lt.low>>>0,Lt.high>>>0):wt},vt.prototype.toNumber=function(Lt){if(!Lt&&this.hi>>>31){var Ft=~this.lo+1>>>0,Ct=~this.hi>>>0;return Ft||(Ct=Ct+1>>>0),-(Ft+Ct*4294967296)}return this.lo+this.hi*4294967296},vt.prototype.toLong=function(Lt){return pt.Long?new pt.Long(this.lo|0,this.hi|0,!!Lt):{low:this.lo|0,high:this.hi|0,unsigned:!!Lt}};var Tt=String.prototype.charCodeAt;vt.fromHash=function(Lt){return Lt===$t?wt:new vt((Tt.call(Lt,0)|Tt.call(Lt,1)<<8|Tt.call(Lt,2)<<16|Tt.call(Lt,3)<<24)>>>0,(Tt.call(Lt,4)|Tt.call(Lt,5)<<8|Tt.call(Lt,6)<<16|Tt.call(Lt,7)<<24)>>>0)},vt.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},vt.prototype.zzEncode=function(){var Lt=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^Lt)>>>0,this.lo=(this.lo<<1^Lt)>>>0,this},vt.prototype.zzDecode=function(){var Lt=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^Lt)>>>0,this.hi=(this.hi>>>1^Lt)>>>0,this},vt.prototype.length=function(){var Lt=this.lo,Ft=(this.lo>>>28|this.hi<<4)>>>0,Ct=this.hi>>>24;return Ct===0?Ft===0?Lt<16384?Lt<128?1:2:Lt<2097152?3:4:Ft<16384?Ft<128?5:6:Ft<2097152?7:8:Ct<128?9:10}}),Jt=me(st=>{var at=st;at.asPromise=Bs$1(),at.base64=Gs$1(),at.EventEmitter=zs$1(),at.float=Xs$1(),at.inquire=Ks$1(),at.utf8=Zs$1(),at.pool=eu$1(),at.LongBits=ru$1(),at.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node),at.global=at.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||st,at.emptyArray=Object.freeze?Object.freeze([]):[],at.emptyObject=Object.freeze?Object.freeze({}):{},at.isInteger=Number.isInteger||function(wt){return typeof wt=="number"&&isFinite(wt)&&Math.floor(wt)===wt},at.isString=function(wt){return typeof wt=="string"||wt instanceof String},at.isObject=function(wt){return wt&&typeof wt=="object"},at.isset=at.isSet=function(wt,$t){var Tt=wt[$t];return Tt!=null&&wt.hasOwnProperty($t)?typeof Tt!="object"||(Array.isArray(Tt)?Tt.length:Object.keys(Tt).length)>0:!1},at.Buffer=function(){try{var wt=at.inquire("buffer").Buffer;return wt.prototype.utf8Write?wt:null}catch{return null}}(),at._Buffer_from=null,at._Buffer_allocUnsafe=null,at.newBuffer=function(wt){return typeof wt=="number"?at.Buffer?at._Buffer_allocUnsafe(wt):new at.Array(wt):at.Buffer?at._Buffer_from(wt):typeof Uint8Array>"u"?wt:new Uint8Array(wt)},at.Array=typeof Uint8Array<"u"?Uint8Array:Array,at.Long=at.global.dcodeIO&&at.global.dcodeIO.Long||at.global.Long||at.inquire("long"),at.key2Re=/^true|false|0|1$/,at.key32Re=/^-?(?:0|[1-9][0-9]*)$/,at.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,at.longToHash=function(wt){return wt?at.LongBits.from(wt).toHash():at.LongBits.zeroHash},at.longFromHash=function(wt,$t){var Tt=at.LongBits.fromHash(wt);return at.Long?at.Long.fromBits(Tt.lo,Tt.hi,$t):Tt.toNumber(!!$t)};function pt(wt,$t,Tt){for(var Lt=Object.keys($t),Ft=0;Ft<Lt.length;++Ft)(wt[Lt[Ft]]===void 0||!Tt)&&(wt[Lt[Ft]]=$t[Lt[Ft]]);return wt}at.merge=pt,at.lcFirst=function(wt){return wt.charAt(0).toLowerCase()+wt.substring(1)};function vt(wt){function $t(Tt,Lt){if(!(this instanceof $t))return new $t(Tt,Lt);Object.defineProperty(this,"message",{get:function(){return Tt}}),Error.captureStackTrace?Error.captureStackTrace(this,$t):Object.defineProperty(this,"stack",{value:new Error().stack||""}),Lt&&pt(this,Lt)}return $t.prototype=Object.create(Error.prototype,{constructor:{value:$t,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return wt},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),$t}at.newError=vt,at.ProtocolError=vt("ProtocolError"),at.oneOfGetter=function(wt){for(var $t={},Tt=0;Tt<wt.length;++Tt)$t[wt[Tt]]=1;return function(){for(var Lt=Object.keys(this),Ft=Lt.length-1;Ft>-1;--Ft)if($t[Lt[Ft]]===1&&this[Lt[Ft]]!==void 0&&this[Lt[Ft]]!==null)return Lt[Ft]}},at.oneOfSetter=function(wt){return function($t){for(var Tt=0;Tt<wt.length;++Tt)wt[Tt]!==$t&&delete this[wt[Tt]]}},at.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},at._configure=function(){var wt=at.Buffer;if(!wt){at._Buffer_from=at._Buffer_allocUnsafe=null;return}at._Buffer_from=wt.from!==Uint8Array.from&&wt.from||function($t,Tt){return new wt($t,Tt)},at._Buffer_allocUnsafe=wt.allocUnsafe||function($t){return new wt($t)}}}),si$1=me((st,at)=>{at.exports=Ht;var pt=Jt(),vt,wt=pt.LongBits,$t=pt.base64,Tt=pt.utf8;function Lt(In,tr,rr){this.fn=In,this.len=tr,this.next=void 0,this.val=rr}function Ft(){}function Ct(In){this.head=In.head,this.tail=In.tail,this.len=In.len,this.next=In.states}function Ht(){this.len=0,this.head=new Lt(Ft,0,0),this.tail=this.head,this.states=null}var Gt=function(){return pt.Buffer?function(){return(Ht.create=function(){return new vt})()}:function(){return new Ht}};Ht.create=Gt(),Ht.alloc=function(In){return new pt.Array(In)},pt.Array!==Array&&(Ht.alloc=pt.pool(Ht.alloc,pt.Array.prototype.subarray)),Ht.prototype._push=function(In,tr,rr){return this.tail=this.tail.next=new Lt(In,tr,rr),this.len+=tr,this};function jt(In,tr,rr){tr[rr]=In&255}function qt(In,tr,rr){for(;In>127;)tr[rr++]=In&127|128,In>>>=7;tr[rr]=In}function Kt(In,tr){this.len=In,this.next=void 0,this.val=tr}Kt.prototype=Object.create(Lt.prototype),Kt.prototype.fn=qt,Ht.prototype.uint32=function(In){return this.len+=(this.tail=this.tail.next=new Kt((In=In>>>0)<128?1:In<16384?2:In<2097152?3:In<268435456?4:5,In)).len,this},Ht.prototype.int32=function(In){return In<0?this._push(An,10,wt.fromNumber(In)):this.uint32(In)},Ht.prototype.sint32=function(In){return this.uint32((In<<1^In>>31)>>>0)};function An(In,tr,rr){for(;In.hi;)tr[rr++]=In.lo&127|128,In.lo=(In.lo>>>7|In.hi<<25)>>>0,In.hi>>>=7;for(;In.lo>127;)tr[rr++]=In.lo&127|128,In.lo=In.lo>>>7;tr[rr++]=In.lo}Ht.prototype.uint64=function(In){var tr=wt.from(In);return this._push(An,tr.length(),tr)},Ht.prototype.int64=Ht.prototype.uint64,Ht.prototype.sint64=function(In){var tr=wt.from(In).zzEncode();return this._push(An,tr.length(),tr)},Ht.prototype.bool=function(In){return this._push(jt,1,In?1:0)};function Sn(In,tr,rr){tr[rr]=In&255,tr[rr+1]=In>>>8&255,tr[rr+2]=In>>>16&255,tr[rr+3]=In>>>24}Ht.prototype.fixed32=function(In){return this._push(Sn,4,In>>>0)},Ht.prototype.sfixed32=Ht.prototype.fixed32,Ht.prototype.fixed64=function(In){var tr=wt.from(In);return this._push(Sn,4,tr.lo)._push(Sn,4,tr.hi)},Ht.prototype.sfixed64=Ht.prototype.fixed64,Ht.prototype.float=function(In){return this._push(pt.float.writeFloatLE,4,In)},Ht.prototype.double=function(In){return this._push(pt.float.writeDoubleLE,8,In)};var wn=pt.Array.prototype.set?function(In,tr,rr){tr.set(In,rr)}:function(In,tr,rr){for(var Hr=0;Hr<In.length;++Hr)tr[rr+Hr]=In[Hr]};Ht.prototype.bytes=function(In){var tr=In.length>>>0;if(!tr)return this._push(jt,1,0);if(pt.isString(In)){var rr=Ht.alloc(tr=$t.length(In));$t.decode(In,rr,0),In=rr}return this.uint32(tr)._push(wn,tr,In)},Ht.prototype.string=function(In){var tr=Tt.length(In);return tr?this.uint32(tr)._push(Tt.write,tr,In):this._push(jt,1,0)},Ht.prototype.fork=function(){return this.states=new Ct(this),this.head=this.tail=new Lt(Ft,0,0),this.len=0,this},Ht.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Lt(Ft,0,0),this.len=0),this},Ht.prototype.ldelim=function(){var In=this.head,tr=this.tail,rr=this.len;return this.reset().uint32(rr),rr&&(this.tail.next=In.next,this.tail=tr,this.len+=rr),this},Ht.prototype.finish=function(){for(var In=this.head.next,tr=this.constructor.alloc(this.len),rr=0;In;)In.fn(In.val,tr,rr),rr+=In.len,In=In.next;return tr},Ht._configure=function(In){vt=In,Ht.create=Gt(),vt._configure()}}),cu$1=me((st,at)=>{at.exports=wt;var pt=si$1();(wt.prototype=Object.create(pt.prototype)).constructor=wt;var vt=Jt();function wt(){pt.call(this)}wt._configure=function(){wt.alloc=vt._Buffer_allocUnsafe,wt.writeBytesBuffer=vt.Buffer&&vt.Buffer.prototype instanceof Uint8Array&&vt.Buffer.prototype.set.name==="set"?function(Tt,Lt,Ft){Lt.set(Tt,Ft)}:function(Tt,Lt,Ft){if(Tt.copy)Tt.copy(Lt,Ft,0,Tt.length);else for(var Ct=0;Ct<Tt.length;)Lt[Ft++]=Tt[Ct++]}},wt.prototype.bytes=function(Tt){vt.isString(Tt)&&(Tt=vt._Buffer_from(Tt,"base64"));var Lt=Tt.length>>>0;return this.uint32(Lt),Lt&&this._push(wt.writeBytesBuffer,Lt,Tt),this};function $t(Tt,Lt,Ft){Tt.length<40?vt.utf8.write(Tt,Lt,Ft):Lt.utf8Write?Lt.utf8Write(Tt,Ft):Lt.write(Tt,Ft)}wt.prototype.string=function(Tt){var Lt=vt.Buffer.byteLength(Tt);return this.uint32(Lt),Lt&&this._push($t,Lt,Tt),this},wt._configure()}),fi$1=me((st,at)=>{at.exports=Lt;var pt=Jt(),vt,wt=pt.LongBits,$t=pt.utf8;function Tt(qt,Kt){return RangeError("index out of range: "+qt.pos+" + "+(Kt||1)+" > "+qt.len)}function Lt(qt){this.buf=qt,this.pos=0,this.len=qt.length}var Ft=typeof Uint8Array<"u"?function(qt){if(qt instanceof Uint8Array||Array.isArray(qt))return new Lt(qt);throw Error("illegal buffer")}:function(qt){if(Array.isArray(qt))return new Lt(qt);throw Error("illegal buffer")},Ct=function(){return pt.Buffer?function(qt){return(Lt.create=function(Kt){return pt.Buffer.isBuffer(Kt)?new vt(Kt):Ft(Kt)})(qt)}:Ft};Lt.create=Ct(),Lt.prototype._slice=pt.Array.prototype.subarray||pt.Array.prototype.slice,Lt.prototype.uint32=function(){var qt=4294967295;return function(){if(qt=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(qt=(qt|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(qt=(qt|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(qt=(qt|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(qt=(qt|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return qt;if((this.pos+=5)>this.len)throw this.pos=this.len,Tt(this,10);return qt}}(),Lt.prototype.int32=function(){return this.uint32()|0},Lt.prototype.sint32=function(){var qt=this.uint32();return qt>>>1^-(qt&1)|0};function Ht(){var qt=new wt(0,0),Kt=0;if(this.len-this.pos>4){for(;Kt<4;++Kt)if(qt.lo=(qt.lo|(this.buf[this.pos]&127)<<Kt*7)>>>0,this.buf[this.pos++]<128)return qt;if(qt.lo=(qt.lo|(this.buf[this.pos]&127)<<28)>>>0,qt.hi=(qt.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return qt;Kt=0}else{for(;Kt<3;++Kt){if(this.pos>=this.len)throw Tt(this);if(qt.lo=(qt.lo|(this.buf[this.pos]&127)<<Kt*7)>>>0,this.buf[this.pos++]<128)return qt}return qt.lo=(qt.lo|(this.buf[this.pos++]&127)<<Kt*7)>>>0,qt}if(this.len-this.pos>4){for(;Kt<5;++Kt)if(qt.hi=(qt.hi|(this.buf[this.pos]&127)<<Kt*7+3)>>>0,this.buf[this.pos++]<128)return qt}else for(;Kt<5;++Kt){if(this.pos>=this.len)throw Tt(this);if(qt.hi=(qt.hi|(this.buf[this.pos]&127)<<Kt*7+3)>>>0,this.buf[this.pos++]<128)return qt}throw Error("invalid varint encoding")}Lt.prototype.bool=function(){return this.uint32()!==0};function Gt(qt,Kt){return(qt[Kt-4]|qt[Kt-3]<<8|qt[Kt-2]<<16|qt[Kt-1]<<24)>>>0}Lt.prototype.fixed32=function(){if(this.pos+4>this.len)throw Tt(this,4);return Gt(this.buf,this.pos+=4)},Lt.prototype.sfixed32=function(){if(this.pos+4>this.len)throw Tt(this,4);return Gt(this.buf,this.pos+=4)|0};function jt(){if(this.pos+8>this.len)throw Tt(this,8);return new wt(Gt(this.buf,this.pos+=4),Gt(this.buf,this.pos+=4))}Lt.prototype.float=function(){if(this.pos+4>this.len)throw Tt(this,4);var qt=pt.float.readFloatLE(this.buf,this.pos);return this.pos+=4,qt},Lt.prototype.double=function(){if(this.pos+8>this.len)throw Tt(this,4);var qt=pt.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,qt},Lt.prototype.bytes=function(){var qt=this.uint32(),Kt=this.pos,An=this.pos+qt;if(An>this.len)throw Tt(this,qt);if(this.pos+=qt,Array.isArray(this.buf))return this.buf.slice(Kt,An);if(Kt===An){var Sn=pt.Buffer;return Sn?Sn.alloc(0):new this.buf.constructor(0)}return this._slice.call(this.buf,Kt,An)},Lt.prototype.string=function(){var qt=this.bytes();return $t.read(qt,0,qt.length)},Lt.prototype.skip=function(qt){if(typeof qt=="number"){if(this.pos+qt>this.len)throw Tt(this,qt);this.pos+=qt}else do if(this.pos>=this.len)throw Tt(this);while(this.buf[this.pos++]&128);return this},Lt.prototype.skipType=function(qt){switch(qt){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(qt=this.uint32()&7)!==4;)this.skipType(qt);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+qt+" at offset "+this.pos)}return this},Lt._configure=function(qt){vt=qt,Lt.create=Ct(),vt._configure();var Kt=pt.Long?"toLong":"toNumber";pt.merge(Lt.prototype,{int64:function(){return Ht.call(this)[Kt](!1)},uint64:function(){return Ht.call(this)[Kt](!0)},sint64:function(){return Ht.call(this).zzDecode()[Kt](!1)},fixed64:function(){return jt.call(this)[Kt](!0)},sfixed64:function(){return jt.call(this)[Kt](!1)}})}}),xu=me((st,at)=>{at.exports=wt;var pt=fi$1();(wt.prototype=Object.create(pt.prototype)).constructor=wt;var vt=Jt();function wt($t){pt.call(this,$t)}wt._configure=function(){vt.Buffer&&(wt.prototype._slice=vt.Buffer.prototype.slice)},wt.prototype.string=function(){var $t=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+$t,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+$t,this.len))},wt._configure()}),vu$1=me((st,at)=>{at.exports=vt;var pt=Jt();(vt.prototype=Object.create(pt.EventEmitter.prototype)).constructor=vt;function vt(wt,$t,Tt){if(typeof wt!="function")throw TypeError("rpcImpl must be a function");pt.EventEmitter.call(this),this.rpcImpl=wt,this.requestDelimited=!!$t,this.responseDelimited=!!Tt}vt.prototype.rpcCall=function wt($t,Tt,Lt,Ft,Ct){if(!Ft)throw TypeError("request must be specified");var Ht=this;if(!Ct)return pt.asPromise(wt,Ht,$t,Tt,Lt,Ft);if(!Ht.rpcImpl){setTimeout(function(){Ct(Error("already ended"))},0);return}try{return Ht.rpcImpl($t,Tt[Ht.requestDelimited?"encodeDelimited":"encode"](Ft).finish(),function(Gt,jt){if(Gt)return Ht.emit("error",Gt,$t),Ct(Gt);if(jt===null){Ht.end(!0);return}if(!(jt instanceof Lt))try{jt=Lt[Ht.responseDelimited?"decodeDelimited":"decode"](jt)}catch(qt){return Ht.emit("error",qt,$t),Ct(qt)}return Ht.emit("data",jt,$t),Ct(null,jt)})}catch(Gt){Ht.emit("error",Gt,$t),setTimeout(function(){Ct(Gt)},0);return}},vt.prototype.end=function(wt){return this.rpcImpl&&(wt||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}}),Ou$1=me(st=>{var at=st;at.Service=vu$1()}),Su$1=me((st,at)=>{at.exports={}}),Eu$1=me(st=>{var at=st;at.build="minimal",at.Writer=si$1(),at.BufferWriter=cu$1(),at.Reader=fi$1(),at.BufferReader=xu(),at.util=Jt(),at.rpc=Ou$1(),at.roots=Su$1(),at.configure=pt;function pt(){at.util._configure(),at.Writer._configure(at.BufferWriter),at.Reader._configure(at.BufferReader)}pt()}),Lu$1=me((st,at)=>{at.exports=Eu$1()}),Cr=me((st,at)=>{var pt=Lu$1(),vt=pt.Reader,wt=pt.Writer,$t=pt.util,Tt=pt.roots.default||(pt.roots.default={});Tt.onnx=function(){var Lt={};return Lt.Version=function(){var Ft={},Ct=Object.create(Ft);return Ct[Ft[0]="_START_VERSION"]=0,Ct[Ft[1]="IR_VERSION_2017_10_10"]=1,Ct[Ft[2]="IR_VERSION_2017_10_30"]=2,Ct[Ft[3]="IR_VERSION_2017_11_3"]=3,Ct[Ft[4]="IR_VERSION_2019_1_22"]=4,Ct[Ft[5]="IR_VERSION_2019_3_18"]=5,Ct[Ft[6]="IR_VERSION_2019_9_19"]=6,Ct[Ft[7]="IR_VERSION_2020_5_8"]=7,Ct[Ft[8]="IR_VERSION_2021_7_30"]=8,Ct[Ft[9]="IR_VERSION"]=9,Ct}(),Lt.AttributeProto=function(){function Ft(Ct){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],Ct)for(var Ht=Object.keys(Ct),Gt=0;Gt<Ht.length;++Gt)Ct[Ht[Gt]]!=null&&(this[Ht[Gt]]=Ct[Ht[Gt]])}return Ft.prototype.name="",Ft.prototype.refAttrName="",Ft.prototype.docString="",Ft.prototype.type=0,Ft.prototype.f=0,Ft.prototype.i=$t.Long?$t.Long.fromBits(0,0,!1):0,Ft.prototype.s=$t.newBuffer([]),Ft.prototype.t=null,Ft.prototype.g=null,Ft.prototype.sparseTensor=null,Ft.prototype.tp=null,Ft.prototype.floats=$t.emptyArray,Ft.prototype.ints=$t.emptyArray,Ft.prototype.strings=$t.emptyArray,Ft.prototype.tensors=$t.emptyArray,Ft.prototype.graphs=$t.emptyArray,Ft.prototype.sparseTensors=$t.emptyArray,Ft.prototype.typeProtos=$t.emptyArray,Ft.create=function(Ct){return new Ft(Ct)},Ft.encode=function(Ct,Ht){if(Ht||(Ht=wt.create()),Ct.name!=null&&Object.hasOwnProperty.call(Ct,"name")&&Ht.uint32(10).string(Ct.name),Ct.f!=null&&Object.hasOwnProperty.call(Ct,"f")&&Ht.uint32(21).float(Ct.f),Ct.i!=null&&Object.hasOwnProperty.call(Ct,"i")&&Ht.uint32(24).int64(Ct.i),Ct.s!=null&&Object.hasOwnProperty.call(Ct,"s")&&Ht.uint32(34).bytes(Ct.s),Ct.t!=null&&Object.hasOwnProperty.call(Ct,"t")&&Tt.onnx.TensorProto.encode(Ct.t,Ht.uint32(42).fork()).ldelim(),Ct.g!=null&&Object.hasOwnProperty.call(Ct,"g")&&Tt.onnx.GraphProto.encode(Ct.g,Ht.uint32(50).fork()).ldelim(),Ct.floats!=null&&Ct.floats.length){Ht.uint32(58).fork();for(var Gt=0;Gt<Ct.floats.length;++Gt)Ht.float(Ct.floats[Gt]);Ht.ldelim()}if(Ct.ints!=null&&Ct.ints.length){Ht.uint32(66).fork();for(var Gt=0;Gt<Ct.ints.length;++Gt)Ht.int64(Ct.ints[Gt]);Ht.ldelim()}if(Ct.strings!=null&&Ct.strings.length)for(var Gt=0;Gt<Ct.strings.length;++Gt)Ht.uint32(74).bytes(Ct.strings[Gt]);if(Ct.tensors!=null&&Ct.tensors.length)for(var Gt=0;Gt<Ct.tensors.length;++Gt)Tt.onnx.TensorProto.encode(Ct.tensors[Gt],Ht.uint32(82).fork()).ldelim();if(Ct.graphs!=null&&Ct.graphs.length)for(var Gt=0;Gt<Ct.graphs.length;++Gt)Tt.onnx.GraphProto.encode(Ct.graphs[Gt],Ht.uint32(90).fork()).ldelim();if(Ct.docString!=null&&Object.hasOwnProperty.call(Ct,"docString")&&Ht.uint32(106).string(Ct.docString),Ct.tp!=null&&Object.hasOwnProperty.call(Ct,"tp")&&Tt.onnx.TypeProto.encode(Ct.tp,Ht.uint32(114).fork()).ldelim(),Ct.typeProtos!=null&&Ct.typeProtos.length)for(var Gt=0;Gt<Ct.typeProtos.length;++Gt)Tt.onnx.TypeProto.encode(Ct.typeProtos[Gt],Ht.uint32(122).fork()).ldelim();if(Ct.type!=null&&Object.hasOwnProperty.call(Ct,"type")&&Ht.uint32(160).int32(Ct.type),Ct.refAttrName!=null&&Object.hasOwnProperty.call(Ct,"refAttrName")&&Ht.uint32(170).string(Ct.refAttrName),Ct.sparseTensor!=null&&Object.hasOwnProperty.call(Ct,"sparseTensor")&&Tt.onnx.SparseTensorProto.encode(Ct.sparseTensor,Ht.uint32(178).fork()).ldelim(),Ct.sparseTensors!=null&&Ct.sparseTensors.length)for(var Gt=0;Gt<Ct.sparseTensors.length;++Gt)Tt.onnx.SparseTensorProto.encode(Ct.sparseTensors[Gt],Ht.uint32(186).fork()).ldelim();return Ht},Ft.encodeDelimited=function(Ct,Ht){return this.encode(Ct,Ht).ldelim()},Ft.decode=function(Ct,Ht){Ct instanceof vt||(Ct=vt.create(Ct));for(var Gt=Ht===void 0?Ct.len:Ct.pos+Ht,jt=new Tt.onnx.AttributeProto;Ct.pos<Gt;){var qt=Ct.uint32();switch(qt>>>3){case 1:{jt.name=Ct.string();break}case 21:{jt.refAttrName=Ct.string();break}case 13:{jt.docString=Ct.string();break}case 20:{jt.type=Ct.int32();break}case 2:{jt.f=Ct.float();break}case 3:{jt.i=Ct.int64();break}case 4:{jt.s=Ct.bytes();break}case 5:{jt.t=Tt.onnx.TensorProto.decode(Ct,Ct.uint32());break}case 6:{jt.g=Tt.onnx.GraphProto.decode(Ct,Ct.uint32());break}case 22:{jt.sparseTensor=Tt.onnx.SparseTensorProto.decode(Ct,Ct.uint32());break}case 14:{jt.tp=Tt.onnx.TypeProto.decode(Ct,Ct.uint32());break}case 7:{if(jt.floats&&jt.floats.length||(jt.floats=[]),(qt&7)===2)for(var Kt=Ct.uint32()+Ct.pos;Ct.pos<Kt;)jt.floats.push(Ct.float());else jt.floats.push(Ct.float());break}case 8:{if(jt.ints&&jt.ints.length||(jt.ints=[]),(qt&7)===2)for(var Kt=Ct.uint32()+Ct.pos;Ct.pos<Kt;)jt.ints.push(Ct.int64());else jt.ints.push(Ct.int64());break}case 9:{jt.strings&&jt.strings.length||(jt.strings=[]),jt.strings.push(Ct.bytes());break}case 10:{jt.tensors&&jt.tensors.length||(jt.tensors=[]),jt.tensors.push(Tt.onnx.TensorProto.decode(Ct,Ct.uint32()));break}case 11:{jt.graphs&&jt.graphs.length||(jt.graphs=[]),jt.graphs.push(Tt.onnx.GraphProto.decode(Ct,Ct.uint32()));break}case 23:{jt.sparseTensors&&jt.sparseTensors.length||(jt.sparseTensors=[]),jt.sparseTensors.push(Tt.onnx.SparseTensorProto.decode(Ct,Ct.uint32()));break}case 15:{jt.typeProtos&&jt.typeProtos.length||(jt.typeProtos=[]),jt.typeProtos.push(Tt.onnx.TypeProto.decode(Ct,Ct.uint32()));break}default:Ct.skipType(qt&7);break}}return jt},Ft.decodeDelimited=function(Ct){return Ct instanceof vt||(Ct=new vt(Ct)),this.decode(Ct,Ct.uint32())},Ft.verify=function(Ct){if(typeof Ct!="object"||Ct===null)return"object expected";if(Ct.name!=null&&Ct.hasOwnProperty("name")&&!$t.isString(Ct.name))return"name: string expected";if(Ct.refAttrName!=null&&Ct.hasOwnProperty("refAttrName")&&!$t.isString(Ct.refAttrName))return"refAttrName: string expected";if(Ct.docString!=null&&Ct.hasOwnProperty("docString")&&!$t.isString(Ct.docString))return"docString: string expected";if(Ct.type!=null&&Ct.hasOwnProperty("type"))switch(Ct.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(Ct.f!=null&&Ct.hasOwnProperty("f")&&typeof Ct.f!="number")return"f: number expected";if(Ct.i!=null&&Ct.hasOwnProperty("i")&&!$t.isInteger(Ct.i)&&!(Ct.i&&$t.isInteger(Ct.i.low)&&$t.isInteger(Ct.i.high)))return"i: integer|Long expected";if(Ct.s!=null&&Ct.hasOwnProperty("s")&&!(Ct.s&&typeof Ct.s.length=="number"||$t.isString(Ct.s)))return"s: buffer expected";if(Ct.t!=null&&Ct.hasOwnProperty("t")){var Ht=Tt.onnx.TensorProto.verify(Ct.t);if(Ht)return"t."+Ht}if(Ct.g!=null&&Ct.hasOwnProperty("g")){var Ht=Tt.onnx.GraphProto.verify(Ct.g);if(Ht)return"g."+Ht}if(Ct.sparseTensor!=null&&Ct.hasOwnProperty("sparseTensor")){var Ht=Tt.onnx.SparseTensorProto.verify(Ct.sparseTensor);if(Ht)return"sparseTensor."+Ht}if(Ct.tp!=null&&Ct.hasOwnProperty("tp")){var Ht=Tt.onnx.TypeProto.verify(Ct.tp);if(Ht)return"tp."+Ht}if(Ct.floats!=null&&Ct.hasOwnProperty("floats")){if(!Array.isArray(Ct.floats))return"floats: array expected";for(var Gt=0;Gt<Ct.floats.length;++Gt)if(typeof Ct.floats[Gt]!="number")return"floats: number[] expected"}if(Ct.ints!=null&&Ct.hasOwnProperty("ints")){if(!Array.isArray(Ct.ints))return"ints: array expected";for(var Gt=0;Gt<Ct.ints.length;++Gt)if(!$t.isInteger(Ct.ints[Gt])&&!(Ct.ints[Gt]&&$t.isInteger(Ct.ints[Gt].low)&&$t.isInteger(Ct.ints[Gt].high)))return"ints: integer|Long[] expected"}if(Ct.strings!=null&&Ct.hasOwnProperty("strings")){if(!Array.isArray(Ct.strings))return"strings: array expected";for(var Gt=0;Gt<Ct.strings.length;++Gt)if(!(Ct.strings[Gt]&&typeof Ct.strings[Gt].length=="number"||$t.isString(Ct.strings[Gt])))return"strings: buffer[] expected"}if(Ct.tensors!=null&&Ct.hasOwnProperty("tensors")){if(!Array.isArray(Ct.tensors))return"tensors: array expected";for(var Gt=0;Gt<Ct.tensors.length;++Gt){var Ht=Tt.onnx.TensorProto.verify(Ct.tensors[Gt]);if(Ht)return"tensors."+Ht}}if(Ct.graphs!=null&&Ct.hasOwnProperty("graphs")){if(!Array.isArray(Ct.graphs))return"graphs: array expected";for(var Gt=0;Gt<Ct.graphs.length;++Gt){var Ht=Tt.onnx.GraphProto.verify(Ct.graphs[Gt]);if(Ht)return"graphs."+Ht}}if(Ct.sparseTensors!=null&&Ct.hasOwnProperty("sparseTensors")){if(!Array.isArray(Ct.sparseTensors))return"sparseTensors: array expected";for(var Gt=0;Gt<Ct.sparseTensors.length;++Gt){var Ht=Tt.onnx.SparseTensorProto.verify(Ct.sparseTensors[Gt]);if(Ht)return"sparseTensors."+Ht}}if(Ct.typeProtos!=null&&Ct.hasOwnProperty("typeProtos")){if(!Array.isArray(Ct.typeProtos))return"typeProtos: array expected";for(var Gt=0;Gt<Ct.typeProtos.length;++Gt){var Ht=Tt.onnx.TypeProto.verify(Ct.typeProtos[Gt]);if(Ht)return"typeProtos."+Ht}}return null},Ft.fromObject=function(Ct){if(Ct instanceof Tt.onnx.AttributeProto)return Ct;var Ht=new Tt.onnx.AttributeProto;switch(Ct.name!=null&&(Ht.name=String(Ct.name)),Ct.refAttrName!=null&&(Ht.refAttrName=String(Ct.refAttrName)),Ct.docString!=null&&(Ht.docString=String(Ct.docString)),Ct.type){default:if(typeof Ct.type=="number"){Ht.type=Ct.type;break}break;case"UNDEFINED":case 0:Ht.type=0;break;case"FLOAT":case 1:Ht.type=1;break;case"INT":case 2:Ht.type=2;break;case"STRING":case 3:Ht.type=3;break;case"TENSOR":case 4:Ht.type=4;break;case"GRAPH":case 5:Ht.type=5;break;case"SPARSE_TENSOR":case 11:Ht.type=11;break;case"TYPE_PROTO":case 13:Ht.type=13;break;case"FLOATS":case 6:Ht.type=6;break;case"INTS":case 7:Ht.type=7;break;case"STRINGS":case 8:Ht.type=8;break;case"TENSORS":case 9:Ht.type=9;break;case"GRAPHS":case 10:Ht.type=10;break;case"SPARSE_TENSORS":case 12:Ht.type=12;break;case"TYPE_PROTOS":case 14:Ht.type=14;break}if(Ct.f!=null&&(Ht.f=Number(Ct.f)),Ct.i!=null&&($t.Long?(Ht.i=$t.Long.fromValue(Ct.i)).unsigned=!1:typeof Ct.i=="string"?Ht.i=parseInt(Ct.i,10):typeof Ct.i=="number"?Ht.i=Ct.i:typeof Ct.i=="object"&&(Ht.i=new $t.LongBits(Ct.i.low>>>0,Ct.i.high>>>0).toNumber())),Ct.s!=null&&(typeof Ct.s=="string"?$t.base64.decode(Ct.s,Ht.s=$t.newBuffer($t.base64.length(Ct.s)),0):Ct.s.length>=0&&(Ht.s=Ct.s)),Ct.t!=null){if(typeof Ct.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");Ht.t=Tt.onnx.TensorProto.fromObject(Ct.t)}if(Ct.g!=null){if(typeof Ct.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");Ht.g=Tt.onnx.GraphProto.fromObject(Ct.g)}if(Ct.sparseTensor!=null){if(typeof Ct.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");Ht.sparseTensor=Tt.onnx.SparseTensorProto.fromObject(Ct.sparseTensor)}if(Ct.tp!=null){if(typeof Ct.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");Ht.tp=Tt.onnx.TypeProto.fromObject(Ct.tp)}if(Ct.floats){if(!Array.isArray(Ct.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");Ht.floats=[];for(var Gt=0;Gt<Ct.floats.length;++Gt)Ht.floats[Gt]=Number(Ct.floats[Gt])}if(Ct.ints){if(!Array.isArray(Ct.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");Ht.ints=[];for(var Gt=0;Gt<Ct.ints.length;++Gt)$t.Long?(Ht.ints[Gt]=$t.Long.fromValue(Ct.ints[Gt])).unsigned=!1:typeof Ct.ints[Gt]=="string"?Ht.ints[Gt]=parseInt(Ct.ints[Gt],10):typeof Ct.ints[Gt]=="number"?Ht.ints[Gt]=Ct.ints[Gt]:typeof Ct.ints[Gt]=="object"&&(Ht.ints[Gt]=new $t.LongBits(Ct.ints[Gt].low>>>0,Ct.ints[Gt].high>>>0).toNumber())}if(Ct.strings){if(!Array.isArray(Ct.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");Ht.strings=[];for(var Gt=0;Gt<Ct.strings.length;++Gt)typeof Ct.strings[Gt]=="string"?$t.base64.decode(Ct.strings[Gt],Ht.strings[Gt]=$t.newBuffer($t.base64.length(Ct.strings[Gt])),0):Ct.strings[Gt].length>=0&&(Ht.strings[Gt]=Ct.strings[Gt])}if(Ct.tensors){if(!Array.isArray(Ct.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");Ht.tensors=[];for(var Gt=0;Gt<Ct.tensors.length;++Gt){if(typeof Ct.tensors[Gt]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");Ht.tensors[Gt]=Tt.onnx.TensorProto.fromObject(Ct.tensors[Gt])}}if(Ct.graphs){if(!Array.isArray(Ct.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");Ht.graphs=[];for(var Gt=0;Gt<Ct.graphs.length;++Gt){if(typeof Ct.graphs[Gt]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");Ht.graphs[Gt]=Tt.onnx.GraphProto.fromObject(Ct.graphs[Gt])}}if(Ct.sparseTensors){if(!Array.isArray(Ct.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");Ht.sparseTensors=[];for(var Gt=0;Gt<Ct.sparseTensors.length;++Gt){if(typeof Ct.sparseTensors[Gt]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");Ht.sparseTensors[Gt]=Tt.onnx.SparseTensorProto.fromObject(Ct.sparseTensors[Gt])}}if(Ct.typeProtos){if(!Array.isArray(Ct.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");Ht.typeProtos=[];for(var Gt=0;Gt<Ct.typeProtos.length;++Gt){if(typeof Ct.typeProtos[Gt]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");Ht.typeProtos[Gt]=Tt.onnx.TypeProto.fromObject(Ct.typeProtos[Gt])}}return Ht},Ft.toObject=function(Ct,Ht){Ht||(Ht={});var Gt={};if((Ht.arrays||Ht.defaults)&&(Gt.floats=[],Gt.ints=[],Gt.strings=[],Gt.tensors=[],Gt.graphs=[],Gt.typeProtos=[],Gt.sparseTensors=[]),Ht.defaults){if(Gt.name="",Gt.f=0,$t.Long){var jt=new $t.Long(0,0,!1);Gt.i=Ht.longs===String?jt.toString():Ht.longs===Number?jt.toNumber():jt}else Gt.i=Ht.longs===String?"0":0;Ht.bytes===String?Gt.s="":(Gt.s=[],Ht.bytes!==Array&&(Gt.s=$t.newBuffer(Gt.s))),Gt.t=null,Gt.g=null,Gt.docString="",Gt.tp=null,Gt.type=Ht.enums===String?"UNDEFINED":0,Gt.refAttrName="",Gt.sparseTensor=null}if(Ct.name!=null&&Ct.hasOwnProperty("name")&&(Gt.name=Ct.name),Ct.f!=null&&Ct.hasOwnProperty("f")&&(Gt.f=Ht.json&&!isFinite(Ct.f)?String(Ct.f):Ct.f),Ct.i!=null&&Ct.hasOwnProperty("i")&&(typeof Ct.i=="number"?Gt.i=Ht.longs===String?String(Ct.i):Ct.i:Gt.i=Ht.longs===String?$t.Long.prototype.toString.call(Ct.i):Ht.longs===Number?new $t.LongBits(Ct.i.low>>>0,Ct.i.high>>>0).toNumber():Ct.i),Ct.s!=null&&Ct.hasOwnProperty("s")&&(Gt.s=Ht.bytes===String?$t.base64.encode(Ct.s,0,Ct.s.length):Ht.bytes===Array?Array.prototype.slice.call(Ct.s):Ct.s),Ct.t!=null&&Ct.hasOwnProperty("t")&&(Gt.t=Tt.onnx.TensorProto.toObject(Ct.t,Ht)),Ct.g!=null&&Ct.hasOwnProperty("g")&&(Gt.g=Tt.onnx.GraphProto.toObject(Ct.g,Ht)),Ct.floats&&Ct.floats.length){Gt.floats=[];for(var qt=0;qt<Ct.floats.length;++qt)Gt.floats[qt]=Ht.json&&!isFinite(Ct.floats[qt])?String(Ct.floats[qt]):Ct.floats[qt]}if(Ct.ints&&Ct.ints.length){Gt.ints=[];for(var qt=0;qt<Ct.ints.length;++qt)typeof Ct.ints[qt]=="number"?Gt.ints[qt]=Ht.longs===String?String(Ct.ints[qt]):Ct.ints[qt]:Gt.ints[qt]=Ht.longs===String?$t.Long.prototype.toString.call(Ct.ints[qt]):Ht.longs===Number?new $t.LongBits(Ct.ints[qt].low>>>0,Ct.ints[qt].high>>>0).toNumber():Ct.ints[qt]}if(Ct.strings&&Ct.strings.length){Gt.strings=[];for(var qt=0;qt<Ct.strings.length;++qt)Gt.strings[qt]=Ht.bytes===String?$t.base64.encode(Ct.strings[qt],0,Ct.strings[qt].length):Ht.bytes===Array?Array.prototype.slice.call(Ct.strings[qt]):Ct.strings[qt]}if(Ct.tensors&&Ct.tensors.length){Gt.tensors=[];for(var qt=0;qt<Ct.tensors.length;++qt)Gt.tensors[qt]=Tt.onnx.TensorProto.toObject(Ct.tensors[qt],Ht)}if(Ct.graphs&&Ct.graphs.length){Gt.graphs=[];for(var qt=0;qt<Ct.graphs.length;++qt)Gt.graphs[qt]=Tt.onnx.GraphProto.toObject(Ct.graphs[qt],Ht)}if(Ct.docString!=null&&Ct.hasOwnProperty("docString")&&(Gt.docString=Ct.docString),Ct.tp!=null&&Ct.hasOwnProperty("tp")&&(Gt.tp=Tt.onnx.TypeProto.toObject(Ct.tp,Ht)),Ct.typeProtos&&Ct.typeProtos.length){Gt.typeProtos=[];for(var qt=0;qt<Ct.typeProtos.length;++qt)Gt.typeProtos[qt]=Tt.onnx.TypeProto.toObject(Ct.typeProtos[qt],Ht)}if(Ct.type!=null&&Ct.hasOwnProperty("type")&&(Gt.type=Ht.enums===String?Tt.onnx.AttributeProto.AttributeType[Ct.type]===void 0?Ct.type:Tt.onnx.AttributeProto.AttributeType[Ct.type]:Ct.type),Ct.refAttrName!=null&&Ct.hasOwnProperty("refAttrName")&&(Gt.refAttrName=Ct.refAttrName),Ct.sparseTensor!=null&&Ct.hasOwnProperty("sparseTensor")&&(Gt.sparseTensor=Tt.onnx.SparseTensorProto.toObject(Ct.sparseTensor,Ht)),Ct.sparseTensors&&Ct.sparseTensors.length){Gt.sparseTensors=[];for(var qt=0;qt<Ct.sparseTensors.length;++qt)Gt.sparseTensors[qt]=Tt.onnx.SparseTensorProto.toObject(Ct.sparseTensors[qt],Ht)}return Gt},Ft.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ft.getTypeUrl=function(Ct){return Ct===void 0&&(Ct="type.googleapis.com"),Ct+"/onnx.AttributeProto"},Ft.AttributeType=function(){var Ct={},Ht=Object.create(Ct);return Ht[Ct[0]="UNDEFINED"]=0,Ht[Ct[1]="FLOAT"]=1,Ht[Ct[2]="INT"]=2,Ht[Ct[3]="STRING"]=3,Ht[Ct[4]="TENSOR"]=4,Ht[Ct[5]="GRAPH"]=5,Ht[Ct[11]="SPARSE_TENSOR"]=11,Ht[Ct[13]="TYPE_PROTO"]=13,Ht[Ct[6]="FLOATS"]=6,Ht[Ct[7]="INTS"]=7,Ht[Ct[8]="STRINGS"]=8,Ht[Ct[9]="TENSORS"]=9,Ht[Ct[10]="GRAPHS"]=10,Ht[Ct[12]="SPARSE_TENSORS"]=12,Ht[Ct[14]="TYPE_PROTOS"]=14,Ht}(),Ft}(),Lt.ValueInfoProto=function(){function Ft(Ct){if(Ct)for(var Ht=Object.keys(Ct),Gt=0;Gt<Ht.length;++Gt)Ct[Ht[Gt]]!=null&&(this[Ht[Gt]]=Ct[Ht[Gt]])}return Ft.prototype.name="",Ft.prototype.type=null,Ft.prototype.docString="",Ft.create=function(Ct){return new Ft(Ct)},Ft.encode=function(Ct,Ht){return Ht||(Ht=wt.create()),Ct.name!=null&&Object.hasOwnProperty.call(Ct,"name")&&Ht.uint32(10).string(Ct.name),Ct.type!=null&&Object.hasOwnProperty.call(Ct,"type")&&Tt.onnx.TypeProto.encode(Ct.type,Ht.uint32(18).fork()).ldelim(),Ct.docString!=null&&Object.hasOwnProperty.call(Ct,"docString")&&Ht.uint32(26).string(Ct.docString),Ht},Ft.encodeDelimited=function(Ct,Ht){return this.encode(Ct,Ht).ldelim()},Ft.decode=function(Ct,Ht){Ct instanceof vt||(Ct=vt.create(Ct));for(var Gt=Ht===void 0?Ct.len:Ct.pos+Ht,jt=new Tt.onnx.ValueInfoProto;Ct.pos<Gt;){var qt=Ct.uint32();switch(qt>>>3){case 1:{jt.name=Ct.string();break}case 2:{jt.type=Tt.onnx.TypeProto.decode(Ct,Ct.uint32());break}case 3:{jt.docString=Ct.string();break}default:Ct.skipType(qt&7);break}}return jt},Ft.decodeDelimited=function(Ct){return Ct instanceof vt||(Ct=new vt(Ct)),this.decode(Ct,Ct.uint32())},Ft.verify=function(Ct){if(typeof Ct!="object"||Ct===null)return"object expected";if(Ct.name!=null&&Ct.hasOwnProperty("name")&&!$t.isString(Ct.name))return"name: string expected";if(Ct.type!=null&&Ct.hasOwnProperty("type")){var Ht=Tt.onnx.TypeProto.verify(Ct.type);if(Ht)return"type."+Ht}return Ct.docString!=null&&Ct.hasOwnProperty("docString")&&!$t.isString(Ct.docString)?"docString: string expected":null},Ft.fromObject=function(Ct){if(Ct instanceof Tt.onnx.ValueInfoProto)return Ct;var Ht=new Tt.onnx.ValueInfoProto;if(Ct.name!=null&&(Ht.name=String(Ct.name)),Ct.type!=null){if(typeof Ct.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");Ht.type=Tt.onnx.TypeProto.fromObject(Ct.type)}return Ct.docString!=null&&(Ht.docString=String(Ct.docString)),Ht},Ft.toObject=function(Ct,Ht){Ht||(Ht={});var Gt={};return Ht.defaults&&(Gt.name="",Gt.type=null,Gt.docString=""),Ct.name!=null&&Ct.hasOwnProperty("name")&&(Gt.name=Ct.name),Ct.type!=null&&Ct.hasOwnProperty("type")&&(Gt.type=Tt.onnx.TypeProto.toObject(Ct.type,Ht)),Ct.docString!=null&&Ct.hasOwnProperty("docString")&&(Gt.docString=Ct.docString),Gt},Ft.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ft.getTypeUrl=function(Ct){return Ct===void 0&&(Ct="type.googleapis.com"),Ct+"/onnx.ValueInfoProto"},Ft}(),Lt.NodeProto=function(){function Ft(Ct){if(this.input=[],this.output=[],this.attribute=[],Ct)for(var Ht=Object.keys(Ct),Gt=0;Gt<Ht.length;++Gt)Ct[Ht[Gt]]!=null&&(this[Ht[Gt]]=Ct[Ht[Gt]])}return Ft.prototype.input=$t.emptyArray,Ft.prototype.output=$t.emptyArray,Ft.prototype.name="",Ft.prototype.opType="",Ft.prototype.domain="",Ft.prototype.attribute=$t.emptyArray,Ft.prototype.docString="",Ft.create=function(Ct){return new Ft(Ct)},Ft.encode=function(Ct,Ht){if(Ht||(Ht=wt.create()),Ct.input!=null&&Ct.input.length)for(var Gt=0;Gt<Ct.input.length;++Gt)Ht.uint32(10).string(Ct.input[Gt]);if(Ct.output!=null&&Ct.output.length)for(var Gt=0;Gt<Ct.output.length;++Gt)Ht.uint32(18).string(Ct.output[Gt]);if(Ct.name!=null&&Object.hasOwnProperty.call(Ct,"name")&&Ht.uint32(26).string(Ct.name),Ct.opType!=null&&Object.hasOwnProperty.call(Ct,"opType")&&Ht.uint32(34).string(Ct.opType),Ct.attribute!=null&&Ct.attribute.length)for(var Gt=0;Gt<Ct.attribute.length;++Gt)Tt.onnx.AttributeProto.encode(Ct.attribute[Gt],Ht.uint32(42).fork()).ldelim();return Ct.docString!=null&&Object.hasOwnProperty.call(Ct,"docString")&&Ht.uint32(50).string(Ct.docString),Ct.domain!=null&&Object.hasOwnProperty.call(Ct,"domain")&&Ht.uint32(58).string(Ct.domain),Ht},Ft.encodeDelimited=function(Ct,Ht){return this.encode(Ct,Ht).ldelim()},Ft.decode=function(Ct,Ht){Ct instanceof vt||(Ct=vt.create(Ct));for(var Gt=Ht===void 0?Ct.len:Ct.pos+Ht,jt=new Tt.onnx.NodeProto;Ct.pos<Gt;){var qt=Ct.uint32();switch(qt>>>3){case 1:{jt.input&&jt.input.length||(jt.input=[]),jt.input.push(Ct.string());break}case 2:{jt.output&&jt.output.length||(jt.output=[]),jt.output.push(Ct.string());break}case 3:{jt.name=Ct.string();break}case 4:{jt.opType=Ct.string();break}case 7:{jt.domain=Ct.string();break}case 5:{jt.attribute&&jt.attribute.length||(jt.attribute=[]),jt.attribute.push(Tt.onnx.AttributeProto.decode(Ct,Ct.uint32()));break}case 6:{jt.docString=Ct.string();break}default:Ct.skipType(qt&7);break}}return jt},Ft.decodeDelimited=function(Ct){return Ct instanceof vt||(Ct=new vt(Ct)),this.decode(Ct,Ct.uint32())},Ft.verify=function(Ct){if(typeof Ct!="object"||Ct===null)return"object expected";if(Ct.input!=null&&Ct.hasOwnProperty("input")){if(!Array.isArray(Ct.input))return"input: array expected";for(var Ht=0;Ht<Ct.input.length;++Ht)if(!$t.isString(Ct.input[Ht]))return"input: string[] expected"}if(Ct.output!=null&&Ct.hasOwnProperty("output")){if(!Array.isArray(Ct.output))return"output: array expected";for(var Ht=0;Ht<Ct.output.length;++Ht)if(!$t.isString(Ct.output[Ht]))return"output: string[] expected"}if(Ct.name!=null&&Ct.hasOwnProperty("name")&&!$t.isString(Ct.name))return"name: string expected";if(Ct.opType!=null&&Ct.hasOwnProperty("opType")&&!$t.isString(Ct.opType))return"opType: string expected";if(Ct.domain!=null&&Ct.hasOwnProperty("domain")&&!$t.isString(Ct.domain))return"domain: string expected";if(Ct.attribute!=null&&Ct.hasOwnProperty("attribute")){if(!Array.isArray(Ct.attribute))return"attribute: array expected";for(var Ht=0;Ht<Ct.attribute.length;++Ht){var Gt=Tt.onnx.AttributeProto.verify(Ct.attribute[Ht]);if(Gt)return"attribute."+Gt}}return Ct.docString!=null&&Ct.hasOwnProperty("docString")&&!$t.isString(Ct.docString)?"docString: string expected":null},Ft.fromObject=function(Ct){if(Ct instanceof Tt.onnx.NodeProto)return Ct;var Ht=new Tt.onnx.NodeProto;if(Ct.input){if(!Array.isArray(Ct.input))throw TypeError(".onnx.NodeProto.input: array expected");Ht.input=[];for(var Gt=0;Gt<Ct.input.length;++Gt)Ht.input[Gt]=String(Ct.input[Gt])}if(Ct.output){if(!Array.isArray(Ct.output))throw TypeError(".onnx.NodeProto.output: array expected");Ht.output=[];for(var Gt=0;Gt<Ct.output.length;++Gt)Ht.output[Gt]=String(Ct.output[Gt])}if(Ct.name!=null&&(Ht.name=String(Ct.name)),Ct.opType!=null&&(Ht.opType=String(Ct.opType)),Ct.domain!=null&&(Ht.domain=String(Ct.domain)),Ct.attribute){if(!Array.isArray(Ct.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");Ht.attribute=[];for(var Gt=0;Gt<Ct.attribute.length;++Gt){if(typeof Ct.attribute[Gt]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");Ht.attribute[Gt]=Tt.onnx.AttributeProto.fromObject(Ct.attribute[Gt])}}return Ct.docString!=null&&(Ht.docString=String(Ct.docString)),Ht},Ft.toObject=function(Ct,Ht){Ht||(Ht={});var Gt={};if((Ht.arrays||Ht.defaults)&&(Gt.input=[],Gt.output=[],Gt.attribute=[]),Ht.defaults&&(Gt.name="",Gt.opType="",Gt.docString="",Gt.domain=""),Ct.input&&Ct.input.length){Gt.input=[];for(var jt=0;jt<Ct.input.length;++jt)Gt.input[jt]=Ct.input[jt]}if(Ct.output&&Ct.output.length){Gt.output=[];for(var jt=0;jt<Ct.output.length;++jt)Gt.output[jt]=Ct.output[jt]}if(Ct.name!=null&&Ct.hasOwnProperty("name")&&(Gt.name=Ct.name),Ct.opType!=null&&Ct.hasOwnProperty("opType")&&(Gt.opType=Ct.opType),Ct.attribute&&Ct.attribute.length){Gt.attribute=[];for(var jt=0;jt<Ct.attribute.length;++jt)Gt.attribute[jt]=Tt.onnx.AttributeProto.toObject(Ct.attribute[jt],Ht)}return Ct.docString!=null&&Ct.hasOwnProperty("docString")&&(Gt.docString=Ct.docString),Ct.domain!=null&&Ct.hasOwnProperty("domain")&&(Gt.domain=Ct.domain),Gt},Ft.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ft.getTypeUrl=function(Ct){return Ct===void 0&&(Ct="type.googleapis.com"),Ct+"/onnx.NodeProto"},Ft}(),Lt.TrainingInfoProto=function(){function Ft(Ct){if(this.initializationBinding=[],this.updateBinding=[],Ct)for(var Ht=Object.keys(Ct),Gt=0;Gt<Ht.length;++Gt)Ct[Ht[Gt]]!=null&&(this[Ht[Gt]]=Ct[Ht[Gt]])}return Ft.prototype.initialization=null,Ft.prototype.algorithm=null,Ft.prototype.initializationBinding=$t.emptyArray,Ft.prototype.updateBinding=$t.emptyArray,Ft.create=function(Ct){return new Ft(Ct)},Ft.encode=function(Ct,Ht){if(Ht||(Ht=wt.create()),Ct.initialization!=null&&Object.hasOwnProperty.call(Ct,"initialization")&&Tt.onnx.GraphProto.encode(Ct.initialization,Ht.uint32(10).fork()).ldelim(),Ct.algorithm!=null&&Object.hasOwnProperty.call(Ct,"algorithm")&&Tt.onnx.GraphProto.encode(Ct.algorithm,Ht.uint32(18).fork()).ldelim(),Ct.initializationBinding!=null&&Ct.initializationBinding.length)for(var Gt=0;Gt<Ct.initializationBinding.length;++Gt)Tt.onnx.StringStringEntryProto.encode(Ct.initializationBinding[Gt],Ht.uint32(26).fork()).ldelim();if(Ct.updateBinding!=null&&Ct.updateBinding.length)for(var Gt=0;Gt<Ct.updateBinding.length;++Gt)Tt.onnx.StringStringEntryProto.encode(Ct.updateBinding[Gt],Ht.uint32(34).fork()).ldelim();return Ht},Ft.encodeDelimited=function(Ct,Ht){return this.encode(Ct,Ht).ldelim()},Ft.decode=function(Ct,Ht){Ct instanceof vt||(Ct=vt.create(Ct));for(var Gt=Ht===void 0?Ct.len:Ct.pos+Ht,jt=new Tt.onnx.TrainingInfoProto;Ct.pos<Gt;){var qt=Ct.uint32();switch(qt>>>3){case 1:{jt.initialization=Tt.onnx.GraphProto.decode(Ct,Ct.uint32());break}case 2:{jt.algorithm=Tt.onnx.GraphProto.decode(Ct,Ct.uint32());break}case 3:{jt.initializationBinding&&jt.initializationBinding.length||(jt.initializationBinding=[]),jt.initializationBinding.push(Tt.onnx.StringStringEntryProto.decode(Ct,Ct.uint32()));break}case 4:{jt.updateBinding&&jt.updateBinding.length||(jt.updateBinding=[]),jt.updateBinding.push(Tt.onnx.StringStringEntryProto.decode(Ct,Ct.uint32()));break}default:Ct.skipType(qt&7);break}}return jt},Ft.decodeDelimited=function(Ct){return Ct instanceof vt||(Ct=new vt(Ct)),this.decode(Ct,Ct.uint32())},Ft.verify=function(Ct){if(typeof Ct!="object"||Ct===null)return"object expected";if(Ct.initialization!=null&&Ct.hasOwnProperty("initialization")){var Ht=Tt.onnx.GraphProto.verify(Ct.initialization);if(Ht)return"initialization."+Ht}if(Ct.algorithm!=null&&Ct.hasOwnProperty("algorithm")){var Ht=Tt.onnx.GraphProto.verify(Ct.algorithm);if(Ht)return"algorithm."+Ht}if(Ct.initializationBinding!=null&&Ct.hasOwnProperty("initializationBinding")){if(!Array.isArray(Ct.initializationBinding))return"initializationBinding: array expected";for(var Gt=0;Gt<Ct.initializationBinding.length;++Gt){var Ht=Tt.onnx.StringStringEntryProto.verify(Ct.initializationBinding[Gt]);if(Ht)return"initializationBinding."+Ht}}if(Ct.updateBinding!=null&&Ct.hasOwnProperty("updateBinding")){if(!Array.isArray(Ct.updateBinding))return"updateBinding: array expected";for(var Gt=0;Gt<Ct.updateBinding.length;++Gt){var Ht=Tt.onnx.StringStringEntryProto.verify(Ct.updateBinding[Gt]);if(Ht)return"updateBinding."+Ht}}return null},Ft.fromObject=function(Ct){if(Ct instanceof Tt.onnx.TrainingInfoProto)return Ct;var Ht=new Tt.onnx.TrainingInfoProto;if(Ct.initialization!=null){if(typeof Ct.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");Ht.initialization=Tt.onnx.GraphProto.fromObject(Ct.initialization)}if(Ct.algorithm!=null){if(typeof Ct.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");Ht.algorithm=Tt.onnx.GraphProto.fromObject(Ct.algorithm)}if(Ct.initializationBinding){if(!Array.isArray(Ct.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");Ht.initializationBinding=[];for(var Gt=0;Gt<Ct.initializationBinding.length;++Gt){if(typeof Ct.initializationBinding[Gt]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");Ht.initializationBinding[Gt]=Tt.onnx.StringStringEntryProto.fromObject(Ct.initializationBinding[Gt])}}if(Ct.updateBinding){if(!Array.isArray(Ct.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");Ht.updateBinding=[];for(var Gt=0;Gt<Ct.updateBinding.length;++Gt){if(typeof Ct.updateBinding[Gt]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");Ht.updateBinding[Gt]=Tt.onnx.StringStringEntryProto.fromObject(Ct.updateBinding[Gt])}}return Ht},Ft.toObject=function(Ct,Ht){Ht||(Ht={});var Gt={};if((Ht.arrays||Ht.defaults)&&(Gt.initializationBinding=[],Gt.updateBinding=[]),Ht.defaults&&(Gt.initialization=null,Gt.algorithm=null),Ct.initialization!=null&&Ct.hasOwnProperty("initialization")&&(Gt.initialization=Tt.onnx.GraphProto.toObject(Ct.initialization,Ht)),Ct.algorithm!=null&&Ct.hasOwnProperty("algorithm")&&(Gt.algorithm=Tt.onnx.GraphProto.toObject(Ct.algorithm,Ht)),Ct.initializationBinding&&Ct.initializationBinding.length){Gt.initializationBinding=[];for(var jt=0;jt<Ct.initializationBinding.length;++jt)Gt.initializationBinding[jt]=Tt.onnx.StringStringEntryProto.toObject(Ct.initializationBinding[jt],Ht)}if(Ct.updateBinding&&Ct.updateBinding.length){Gt.updateBinding=[];for(var jt=0;jt<Ct.updateBinding.length;++jt)Gt.updateBinding[jt]=Tt.onnx.StringStringEntryProto.toObject(Ct.updateBinding[jt],Ht)}return Gt},Ft.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ft.getTypeUrl=function(Ct){return Ct===void 0&&(Ct="type.googleapis.com"),Ct+"/onnx.TrainingInfoProto"},Ft}(),Lt.ModelProto=function(){function Ft(Ct){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],Ct)for(var Ht=Object.keys(Ct),Gt=0;Gt<Ht.length;++Gt)Ct[Ht[Gt]]!=null&&(this[Ht[Gt]]=Ct[Ht[Gt]])}return Ft.prototype.irVersion=$t.Long?$t.Long.fromBits(0,0,!1):0,Ft.prototype.opsetImport=$t.emptyArray,Ft.prototype.producerName="",Ft.prototype.producerVersion="",Ft.prototype.domain="",Ft.prototype.modelVersion=$t.Long?$t.Long.fromBits(0,0,!1):0,Ft.prototype.docString="",Ft.prototype.graph=null,Ft.prototype.metadataProps=$t.emptyArray,Ft.prototype.trainingInfo=$t.emptyArray,Ft.prototype.functions=$t.emptyArray,Ft.create=function(Ct){return new Ft(Ct)},Ft.encode=function(Ct,Ht){if(Ht||(Ht=wt.create()),Ct.irVersion!=null&&Object.hasOwnProperty.call(Ct,"irVersion")&&Ht.uint32(8).int64(Ct.irVersion),Ct.producerName!=null&&Object.hasOwnProperty.call(Ct,"producerName")&&Ht.uint32(18).string(Ct.producerName),Ct.producerVersion!=null&&Object.hasOwnProperty.call(Ct,"producerVersion")&&Ht.uint32(26).string(Ct.producerVersion),Ct.domain!=null&&Object.hasOwnProperty.call(Ct,"domain")&&Ht.uint32(34).string(Ct.domain),Ct.modelVersion!=null&&Object.hasOwnProperty.call(Ct,"modelVersion")&&Ht.uint32(40).int64(Ct.modelVersion),Ct.docString!=null&&Object.hasOwnProperty.call(Ct,"docString")&&Ht.uint32(50).string(Ct.docString),Ct.graph!=null&&Object.hasOwnProperty.call(Ct,"graph")&&Tt.onnx.GraphProto.encode(Ct.graph,Ht.uint32(58).fork()).ldelim(),Ct.opsetImport!=null&&Ct.opsetImport.length)for(var Gt=0;Gt<Ct.opsetImport.length;++Gt)Tt.onnx.OperatorSetIdProto.encode(Ct.opsetImport[Gt],Ht.uint32(66).fork()).ldelim();if(Ct.metadataProps!=null&&Ct.metadataProps.length)for(var Gt=0;Gt<Ct.metadataProps.length;++Gt)Tt.onnx.StringStringEntryProto.encode(Ct.metadataProps[Gt],Ht.uint32(114).fork()).ldelim();if(Ct.trainingInfo!=null&&Ct.trainingInfo.length)for(var Gt=0;Gt<Ct.trainingInfo.length;++Gt)Tt.onnx.TrainingInfoProto.encode(Ct.trainingInfo[Gt],Ht.uint32(162).fork()).ldelim();if(Ct.functions!=null&&Ct.functions.length)for(var Gt=0;Gt<Ct.functions.length;++Gt)Tt.onnx.FunctionProto.encode(Ct.functions[Gt],Ht.uint32(202).fork()).ldelim();return Ht},Ft.encodeDelimited=function(Ct,Ht){return this.encode(Ct,Ht).ldelim()},Ft.decode=function(Ct,Ht){Ct instanceof vt||(Ct=vt.create(Ct));for(var Gt=Ht===void 0?Ct.len:Ct.pos+Ht,jt=new Tt.onnx.ModelProto;Ct.pos<Gt;){var qt=Ct.uint32();switch(qt>>>3){case 1:{jt.irVersion=Ct.int64();break}case 8:{jt.opsetImport&&jt.opsetImport.length||(jt.opsetImport=[]),jt.opsetImport.push(Tt.onnx.OperatorSetIdProto.decode(Ct,Ct.uint32()));break}case 2:{jt.producerName=Ct.string();break}case 3:{jt.producerVersion=Ct.string();break}case 4:{jt.domain=Ct.string();break}case 5:{jt.modelVersion=Ct.int64();break}case 6:{jt.docString=Ct.string();break}case 7:{jt.graph=Tt.onnx.GraphProto.decode(Ct,Ct.uint32());break}case 14:{jt.metadataProps&&jt.metadataProps.length||(jt.metadataProps=[]),jt.metadataProps.push(Tt.onnx.StringStringEntryProto.decode(Ct,Ct.uint32()));break}case 20:{jt.trainingInfo&&jt.trainingInfo.length||(jt.trainingInfo=[]),jt.trainingInfo.push(Tt.onnx.TrainingInfoProto.decode(Ct,Ct.uint32()));break}case 25:{jt.functions&&jt.functions.length||(jt.functions=[]),jt.functions.push(Tt.onnx.FunctionProto.decode(Ct,Ct.uint32()));break}default:Ct.skipType(qt&7);break}}return jt},Ft.decodeDelimited=function(Ct){return Ct instanceof vt||(Ct=new vt(Ct)),this.decode(Ct,Ct.uint32())},Ft.verify=function(Ct){if(typeof Ct!="object"||Ct===null)return"object expected";if(Ct.irVersion!=null&&Ct.hasOwnProperty("irVersion")&&!$t.isInteger(Ct.irVersion)&&!(Ct.irVersion&&$t.isInteger(Ct.irVersion.low)&&$t.isInteger(Ct.irVersion.high)))return"irVersion: integer|Long expected";if(Ct.opsetImport!=null&&Ct.hasOwnProperty("opsetImport")){if(!Array.isArray(Ct.opsetImport))return"opsetImport: array expected";for(var Ht=0;Ht<Ct.opsetImport.length;++Ht){var Gt=Tt.onnx.OperatorSetIdProto.verify(Ct.opsetImport[Ht]);if(Gt)return"opsetImport."+Gt}}if(Ct.producerName!=null&&Ct.hasOwnProperty("producerName")&&!$t.isString(Ct.producerName))return"producerName: string expected";if(Ct.producerVersion!=null&&Ct.hasOwnProperty("producerVersion")&&!$t.isString(Ct.producerVersion))return"producerVersion: string expected";if(Ct.domain!=null&&Ct.hasOwnProperty("domain")&&!$t.isString(Ct.domain))return"domain: string expected";if(Ct.modelVersion!=null&&Ct.hasOwnProperty("modelVersion")&&!$t.isInteger(Ct.modelVersion)&&!(Ct.modelVersion&&$t.isInteger(Ct.modelVersion.low)&&$t.isInteger(Ct.modelVersion.high)))return"modelVersion: integer|Long expected";if(Ct.docString!=null&&Ct.hasOwnProperty("docString")&&!$t.isString(Ct.docString))return"docString: string expected";if(Ct.graph!=null&&Ct.hasOwnProperty("graph")){var Gt=Tt.onnx.GraphProto.verify(Ct.graph);if(Gt)return"graph."+Gt}if(Ct.metadataProps!=null&&Ct.hasOwnProperty("metadataProps")){if(!Array.isArray(Ct.metadataProps))return"metadataProps: array expected";for(var Ht=0;Ht<Ct.metadataProps.length;++Ht){var Gt=Tt.onnx.StringStringEntryProto.verify(Ct.metadataProps[Ht]);if(Gt)return"metadataProps."+Gt}}if(Ct.trainingInfo!=null&&Ct.hasOwnProperty("trainingInfo")){if(!Array.isArray(Ct.trainingInfo))return"trainingInfo: array expected";for(var Ht=0;Ht<Ct.trainingInfo.length;++Ht){var Gt=Tt.onnx.TrainingInfoProto.verify(Ct.trainingInfo[Ht]);if(Gt)return"trainingInfo."+Gt}}if(Ct.functions!=null&&Ct.hasOwnProperty("functions")){if(!Array.isArray(Ct.functions))return"functions: array expected";for(var Ht=0;Ht<Ct.functions.length;++Ht){var Gt=Tt.onnx.FunctionProto.verify(Ct.functions[Ht]);if(Gt)return"functions."+Gt}}return null},Ft.fromObject=function(Ct){if(Ct instanceof Tt.onnx.ModelProto)return Ct;var Ht=new Tt.onnx.ModelProto;if(Ct.irVersion!=null&&($t.Long?(Ht.irVersion=$t.Long.fromValue(Ct.irVersion)).unsigned=!1:typeof Ct.irVersion=="string"?Ht.irVersion=parseInt(Ct.irVersion,10):typeof Ct.irVersion=="number"?Ht.irVersion=Ct.irVersion:typeof Ct.irVersion=="object"&&(Ht.irVersion=new $t.LongBits(Ct.irVersion.low>>>0,Ct.irVersion.high>>>0).toNumber())),Ct.opsetImport){if(!Array.isArray(Ct.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");Ht.opsetImport=[];for(var Gt=0;Gt<Ct.opsetImport.length;++Gt){if(typeof Ct.opsetImport[Gt]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");Ht.opsetImport[Gt]=Tt.onnx.OperatorSetIdProto.fromObject(Ct.opsetImport[Gt])}}if(Ct.producerName!=null&&(Ht.producerName=String(Ct.producerName)),Ct.producerVersion!=null&&(Ht.producerVersion=String(Ct.producerVersion)),Ct.domain!=null&&(Ht.domain=String(Ct.domain)),Ct.modelVersion!=null&&($t.Long?(Ht.modelVersion=$t.Long.fromValue(Ct.modelVersion)).unsigned=!1:typeof Ct.modelVersion=="string"?Ht.modelVersion=parseInt(Ct.modelVersion,10):typeof Ct.modelVersion=="number"?Ht.modelVersion=Ct.modelVersion:typeof Ct.modelVersion=="object"&&(Ht.modelVersion=new $t.LongBits(Ct.modelVersion.low>>>0,Ct.modelVersion.high>>>0).toNumber())),Ct.docString!=null&&(Ht.docString=String(Ct.docString)),Ct.graph!=null){if(typeof Ct.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");Ht.graph=Tt.onnx.GraphProto.fromObject(Ct.graph)}if(Ct.metadataProps){if(!Array.isArray(Ct.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");Ht.metadataProps=[];for(var Gt=0;Gt<Ct.metadataProps.length;++Gt){if(typeof Ct.metadataProps[Gt]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");Ht.metadataProps[Gt]=Tt.onnx.StringStringEntryProto.fromObject(Ct.metadataProps[Gt])}}if(Ct.trainingInfo){if(!Array.isArray(Ct.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");Ht.trainingInfo=[];for(var Gt=0;Gt<Ct.trainingInfo.length;++Gt){if(typeof Ct.trainingInfo[Gt]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");Ht.trainingInfo[Gt]=Tt.onnx.TrainingInfoProto.fromObject(Ct.trainingInfo[Gt])}}if(Ct.functions){if(!Array.isArray(Ct.functions))throw TypeError(".onnx.ModelProto.functions: array expected");Ht.functions=[];for(var Gt=0;Gt<Ct.functions.length;++Gt){if(typeof Ct.functions[Gt]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");Ht.functions[Gt]=Tt.onnx.FunctionProto.fromObject(Ct.functions[Gt])}}return Ht},Ft.toObject=function(Ct,Ht){Ht||(Ht={});var Gt={};if((Ht.arrays||Ht.defaults)&&(Gt.opsetImport=[],Gt.metadataProps=[],Gt.trainingInfo=[],Gt.functions=[]),Ht.defaults){if($t.Long){var jt=new $t.Long(0,0,!1);Gt.irVersion=Ht.longs===String?jt.toString():Ht.longs===Number?jt.toNumber():jt}else Gt.irVersion=Ht.longs===String?"0":0;if(Gt.producerName="",Gt.producerVersion="",Gt.domain="",$t.Long){var jt=new $t.Long(0,0,!1);Gt.modelVersion=Ht.longs===String?jt.toString():Ht.longs===Number?jt.toNumber():jt}else Gt.modelVersion=Ht.longs===String?"0":0;Gt.docString="",Gt.graph=null}if(Ct.irVersion!=null&&Ct.hasOwnProperty("irVersion")&&(typeof Ct.irVersion=="number"?Gt.irVersion=Ht.longs===String?String(Ct.irVersion):Ct.irVersion:Gt.irVersion=Ht.longs===String?$t.Long.prototype.toString.call(Ct.irVersion):Ht.longs===Number?new $t.LongBits(Ct.irVersion.low>>>0,Ct.irVersion.high>>>0).toNumber():Ct.irVersion),Ct.producerName!=null&&Ct.hasOwnProperty("producerName")&&(Gt.producerName=Ct.producerName),Ct.producerVersion!=null&&Ct.hasOwnProperty("producerVersion")&&(Gt.producerVersion=Ct.producerVersion),Ct.domain!=null&&Ct.hasOwnProperty("domain")&&(Gt.domain=Ct.domain),Ct.modelVersion!=null&&Ct.hasOwnProperty("modelVersion")&&(typeof Ct.modelVersion=="number"?Gt.modelVersion=Ht.longs===String?String(Ct.modelVersion):Ct.modelVersion:Gt.modelVersion=Ht.longs===String?$t.Long.prototype.toString.call(Ct.modelVersion):Ht.longs===Number?new $t.LongBits(Ct.modelVersion.low>>>0,Ct.modelVersion.high>>>0).toNumber():Ct.modelVersion),Ct.docString!=null&&Ct.hasOwnProperty("docString")&&(Gt.docString=Ct.docString),Ct.graph!=null&&Ct.hasOwnProperty("graph")&&(Gt.graph=Tt.onnx.GraphProto.toObject(Ct.graph,Ht)),Ct.opsetImport&&Ct.opsetImport.length){Gt.opsetImport=[];for(var qt=0;qt<Ct.opsetImport.length;++qt)Gt.opsetImport[qt]=Tt.onnx.OperatorSetIdProto.toObject(Ct.opsetImport[qt],Ht)}if(Ct.metadataProps&&Ct.metadataProps.length){Gt.metadataProps=[];for(var qt=0;qt<Ct.metadataProps.length;++qt)Gt.metadataProps[qt]=Tt.onnx.StringStringEntryProto.toObject(Ct.metadataProps[qt],Ht)}if(Ct.trainingInfo&&Ct.trainingInfo.length){Gt.trainingInfo=[];for(var qt=0;qt<Ct.trainingInfo.length;++qt)Gt.trainingInfo[qt]=Tt.onnx.TrainingInfoProto.toObject(Ct.trainingInfo[qt],Ht)}if(Ct.functions&&Ct.functions.length){Gt.functions=[];for(var qt=0;qt<Ct.functions.length;++qt)Gt.functions[qt]=Tt.onnx.FunctionProto.toObject(Ct.functions[qt],Ht)}return Gt},Ft.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ft.getTypeUrl=function(Ct){return Ct===void 0&&(Ct="type.googleapis.com"),Ct+"/onnx.ModelProto"},Ft}(),Lt.StringStringEntryProto=function(){function Ft(Ct){if(Ct)for(var Ht=Object.keys(Ct),Gt=0;Gt<Ht.length;++Gt)Ct[Ht[Gt]]!=null&&(this[Ht[Gt]]=Ct[Ht[Gt]])}return Ft.prototype.key="",Ft.prototype.value="",Ft.create=function(Ct){return new Ft(Ct)},Ft.encode=function(Ct,Ht){return Ht||(Ht=wt.create()),Ct.key!=null&&Object.hasOwnProperty.call(Ct,"key")&&Ht.uint32(10).string(Ct.key),Ct.value!=null&&Object.hasOwnProperty.call(Ct,"value")&&Ht.uint32(18).string(Ct.value),Ht},Ft.encodeDelimited=function(Ct,Ht){return this.encode(Ct,Ht).ldelim()},Ft.decode=function(Ct,Ht){Ct instanceof vt||(Ct=vt.create(Ct));for(var Gt=Ht===void 0?Ct.len:Ct.pos+Ht,jt=new Tt.onnx.StringStringEntryProto;Ct.pos<Gt;){var qt=Ct.uint32();switch(qt>>>3){case 1:{jt.key=Ct.string();break}case 2:{jt.value=Ct.string();break}default:Ct.skipType(qt&7);break}}return jt},Ft.decodeDelimited=function(Ct){return Ct instanceof vt||(Ct=new vt(Ct)),this.decode(Ct,Ct.uint32())},Ft.verify=function(Ct){return typeof Ct!="object"||Ct===null?"object expected":Ct.key!=null&&Ct.hasOwnProperty("key")&&!$t.isString(Ct.key)?"key: string expected":Ct.value!=null&&Ct.hasOwnProperty("value")&&!$t.isString(Ct.value)?"value: string expected":null},Ft.fromObject=function(Ct){if(Ct instanceof Tt.onnx.StringStringEntryProto)return Ct;var Ht=new Tt.onnx.StringStringEntryProto;return Ct.key!=null&&(Ht.key=String(Ct.key)),Ct.value!=null&&(Ht.value=String(Ct.value)),Ht},Ft.toObject=function(Ct,Ht){Ht||(Ht={});var Gt={};return Ht.defaults&&(Gt.key="",Gt.value=""),Ct.key!=null&&Ct.hasOwnProperty("key")&&(Gt.key=Ct.key),Ct.value!=null&&Ct.hasOwnProperty("value")&&(Gt.value=Ct.value),Gt},Ft.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ft.getTypeUrl=function(Ct){return Ct===void 0&&(Ct="type.googleapis.com"),Ct+"/onnx.StringStringEntryProto"},Ft}(),Lt.TensorAnnotation=function(){function Ft(Ct){if(this.quantParameterTensorNames=[],Ct)for(var Ht=Object.keys(Ct),Gt=0;Gt<Ht.length;++Gt)Ct[Ht[Gt]]!=null&&(this[Ht[Gt]]=Ct[Ht[Gt]])}return Ft.prototype.tensorName="",Ft.prototype.quantParameterTensorNames=$t.emptyArray,Ft.create=function(Ct){return new Ft(Ct)},Ft.encode=function(Ct,Ht){if(Ht||(Ht=wt.create()),Ct.tensorName!=null&&Object.hasOwnProperty.call(Ct,"tensorName")&&Ht.uint32(10).string(Ct.tensorName),Ct.quantParameterTensorNames!=null&&Ct.quantParameterTensorNames.length)for(var Gt=0;Gt<Ct.quantParameterTensorNames.length;++Gt)Tt.onnx.StringStringEntryProto.encode(Ct.quantParameterTensorNames[Gt],Ht.uint32(18).fork()).ldelim();return Ht},Ft.encodeDelimited=function(Ct,Ht){return this.encode(Ct,Ht).ldelim()},Ft.decode=function(Ct,Ht){Ct instanceof vt||(Ct=vt.create(Ct));for(var Gt=Ht===void 0?Ct.len:Ct.pos+Ht,jt=new Tt.onnx.TensorAnnotation;Ct.pos<Gt;){var qt=Ct.uint32();switch(qt>>>3){case 1:{jt.tensorName=Ct.string();break}case 2:{jt.quantParameterTensorNames&&jt.quantParameterTensorNames.length||(jt.quantParameterTensorNames=[]),jt.quantParameterTensorNames.push(Tt.onnx.StringStringEntryProto.decode(Ct,Ct.uint32()));break}default:Ct.skipType(qt&7);break}}return jt},Ft.decodeDelimited=function(Ct){return Ct instanceof vt||(Ct=new vt(Ct)),this.decode(Ct,Ct.uint32())},Ft.verify=function(Ct){if(typeof Ct!="object"||Ct===null)return"object expected";if(Ct.tensorName!=null&&Ct.hasOwnProperty("tensorName")&&!$t.isString(Ct.tensorName))return"tensorName: string expected";if(Ct.quantParameterTensorNames!=null&&Ct.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(Ct.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var Ht=0;Ht<Ct.quantParameterTensorNames.length;++Ht){var Gt=Tt.onnx.StringStringEntryProto.verify(Ct.quantParameterTensorNames[Ht]);if(Gt)return"quantParameterTensorNames."+Gt}}return null},Ft.fromObject=function(Ct){if(Ct instanceof Tt.onnx.TensorAnnotation)return Ct;var Ht=new Tt.onnx.TensorAnnotation;if(Ct.tensorName!=null&&(Ht.tensorName=String(Ct.tensorName)),Ct.quantParameterTensorNames){if(!Array.isArray(Ct.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");Ht.quantParameterTensorNames=[];for(var Gt=0;Gt<Ct.quantParameterTensorNames.length;++Gt){if(typeof Ct.quantParameterTensorNames[Gt]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");Ht.quantParameterTensorNames[Gt]=Tt.onnx.StringStringEntryProto.fromObject(Ct.quantParameterTensorNames[Gt])}}return Ht},Ft.toObject=function(Ct,Ht){Ht||(Ht={});var Gt={};if((Ht.arrays||Ht.defaults)&&(Gt.quantParameterTensorNames=[]),Ht.defaults&&(Gt.tensorName=""),Ct.tensorName!=null&&Ct.hasOwnProperty("tensorName")&&(Gt.tensorName=Ct.tensorName),Ct.quantParameterTensorNames&&Ct.quantParameterTensorNames.length){Gt.quantParameterTensorNames=[];for(var jt=0;jt<Ct.quantParameterTensorNames.length;++jt)Gt.quantParameterTensorNames[jt]=Tt.onnx.StringStringEntryProto.toObject(Ct.quantParameterTensorNames[jt],Ht)}return Gt},Ft.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ft.getTypeUrl=function(Ct){return Ct===void 0&&(Ct="type.googleapis.com"),Ct+"/onnx.TensorAnnotation"},Ft}(),Lt.GraphProto=function(){function Ft(Ct){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],Ct)for(var Ht=Object.keys(Ct),Gt=0;Gt<Ht.length;++Gt)Ct[Ht[Gt]]!=null&&(this[Ht[Gt]]=Ct[Ht[Gt]])}return Ft.prototype.node=$t.emptyArray,Ft.prototype.name="",Ft.prototype.initializer=$t.emptyArray,Ft.prototype.sparseInitializer=$t.emptyArray,Ft.prototype.docString="",Ft.prototype.input=$t.emptyArray,Ft.prototype.output=$t.emptyArray,Ft.prototype.valueInfo=$t.emptyArray,Ft.prototype.quantizationAnnotation=$t.emptyArray,Ft.create=function(Ct){return new Ft(Ct)},Ft.encode=function(Ct,Ht){if(Ht||(Ht=wt.create()),Ct.node!=null&&Ct.node.length)for(var Gt=0;Gt<Ct.node.length;++Gt)Tt.onnx.NodeProto.encode(Ct.node[Gt],Ht.uint32(10).fork()).ldelim();if(Ct.name!=null&&Object.hasOwnProperty.call(Ct,"name")&&Ht.uint32(18).string(Ct.name),Ct.initializer!=null&&Ct.initializer.length)for(var Gt=0;Gt<Ct.initializer.length;++Gt)Tt.onnx.TensorProto.encode(Ct.initializer[Gt],Ht.uint32(42).fork()).ldelim();if(Ct.docString!=null&&Object.hasOwnProperty.call(Ct,"docString")&&Ht.uint32(82).string(Ct.docString),Ct.input!=null&&Ct.input.length)for(var Gt=0;Gt<Ct.input.length;++Gt)Tt.onnx.ValueInfoProto.encode(Ct.input[Gt],Ht.uint32(90).fork()).ldelim();if(Ct.output!=null&&Ct.output.length)for(var Gt=0;Gt<Ct.output.length;++Gt)Tt.onnx.ValueInfoProto.encode(Ct.output[Gt],Ht.uint32(98).fork()).ldelim();if(Ct.valueInfo!=null&&Ct.valueInfo.length)for(var Gt=0;Gt<Ct.valueInfo.length;++Gt)Tt.onnx.ValueInfoProto.encode(Ct.valueInfo[Gt],Ht.uint32(106).fork()).ldelim();if(Ct.quantizationAnnotation!=null&&Ct.quantizationAnnotation.length)for(var Gt=0;Gt<Ct.quantizationAnnotation.length;++Gt)Tt.onnx.TensorAnnotation.encode(Ct.quantizationAnnotation[Gt],Ht.uint32(114).fork()).ldelim();if(Ct.sparseInitializer!=null&&Ct.sparseInitializer.length)for(var Gt=0;Gt<Ct.sparseInitializer.length;++Gt)Tt.onnx.SparseTensorProto.encode(Ct.sparseInitializer[Gt],Ht.uint32(122).fork()).ldelim();return Ht},Ft.encodeDelimited=function(Ct,Ht){return this.encode(Ct,Ht).ldelim()},Ft.decode=function(Ct,Ht){Ct instanceof vt||(Ct=vt.create(Ct));for(var Gt=Ht===void 0?Ct.len:Ct.pos+Ht,jt=new Tt.onnx.GraphProto;Ct.pos<Gt;){var qt=Ct.uint32();switch(qt>>>3){case 1:{jt.node&&jt.node.length||(jt.node=[]),jt.node.push(Tt.onnx.NodeProto.decode(Ct,Ct.uint32()));break}case 2:{jt.name=Ct.string();break}case 5:{jt.initializer&&jt.initializer.length||(jt.initializer=[]),jt.initializer.push(Tt.onnx.TensorProto.decode(Ct,Ct.uint32()));break}case 15:{jt.sparseInitializer&&jt.sparseInitializer.length||(jt.sparseInitializer=[]),jt.sparseInitializer.push(Tt.onnx.SparseTensorProto.decode(Ct,Ct.uint32()));break}case 10:{jt.docString=Ct.string();break}case 11:{jt.input&&jt.input.length||(jt.input=[]),jt.input.push(Tt.onnx.ValueInfoProto.decode(Ct,Ct.uint32()));break}case 12:{jt.output&&jt.output.length||(jt.output=[]),jt.output.push(Tt.onnx.ValueInfoProto.decode(Ct,Ct.uint32()));break}case 13:{jt.valueInfo&&jt.valueInfo.length||(jt.valueInfo=[]),jt.valueInfo.push(Tt.onnx.ValueInfoProto.decode(Ct,Ct.uint32()));break}case 14:{jt.quantizationAnnotation&&jt.quantizationAnnotation.length||(jt.quantizationAnnotation=[]),jt.quantizationAnnotation.push(Tt.onnx.TensorAnnotation.decode(Ct,Ct.uint32()));break}default:Ct.skipType(qt&7);break}}return jt},Ft.decodeDelimited=function(Ct){return Ct instanceof vt||(Ct=new vt(Ct)),this.decode(Ct,Ct.uint32())},Ft.verify=function(Ct){if(typeof Ct!="object"||Ct===null)return"object expected";if(Ct.node!=null&&Ct.hasOwnProperty("node")){if(!Array.isArray(Ct.node))return"node: array expected";for(var Ht=0;Ht<Ct.node.length;++Ht){var Gt=Tt.onnx.NodeProto.verify(Ct.node[Ht]);if(Gt)return"node."+Gt}}if(Ct.name!=null&&Ct.hasOwnProperty("name")&&!$t.isString(Ct.name))return"name: string expected";if(Ct.initializer!=null&&Ct.hasOwnProperty("initializer")){if(!Array.isArray(Ct.initializer))return"initializer: array expected";for(var Ht=0;Ht<Ct.initializer.length;++Ht){var Gt=Tt.onnx.TensorProto.verify(Ct.initializer[Ht]);if(Gt)return"initializer."+Gt}}if(Ct.sparseInitializer!=null&&Ct.hasOwnProperty("sparseInitializer")){if(!Array.isArray(Ct.sparseInitializer))return"sparseInitializer: array expected";for(var Ht=0;Ht<Ct.sparseInitializer.length;++Ht){var Gt=Tt.onnx.SparseTensorProto.verify(Ct.sparseInitializer[Ht]);if(Gt)return"sparseInitializer."+Gt}}if(Ct.docString!=null&&Ct.hasOwnProperty("docString")&&!$t.isString(Ct.docString))return"docString: string expected";if(Ct.input!=null&&Ct.hasOwnProperty("input")){if(!Array.isArray(Ct.input))return"input: array expected";for(var Ht=0;Ht<Ct.input.length;++Ht){var Gt=Tt.onnx.ValueInfoProto.verify(Ct.input[Ht]);if(Gt)return"input."+Gt}}if(Ct.output!=null&&Ct.hasOwnProperty("output")){if(!Array.isArray(Ct.output))return"output: array expected";for(var Ht=0;Ht<Ct.output.length;++Ht){var Gt=Tt.onnx.ValueInfoProto.verify(Ct.output[Ht]);if(Gt)return"output."+Gt}}if(Ct.valueInfo!=null&&Ct.hasOwnProperty("valueInfo")){if(!Array.isArray(Ct.valueInfo))return"valueInfo: array expected";for(var Ht=0;Ht<Ct.valueInfo.length;++Ht){var Gt=Tt.onnx.ValueInfoProto.verify(Ct.valueInfo[Ht]);if(Gt)return"valueInfo."+Gt}}if(Ct.quantizationAnnotation!=null&&Ct.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(Ct.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var Ht=0;Ht<Ct.quantizationAnnotation.length;++Ht){var Gt=Tt.onnx.TensorAnnotation.verify(Ct.quantizationAnnotation[Ht]);if(Gt)return"quantizationAnnotation."+Gt}}return null},Ft.fromObject=function(Ct){if(Ct instanceof Tt.onnx.GraphProto)return Ct;var Ht=new Tt.onnx.GraphProto;if(Ct.node){if(!Array.isArray(Ct.node))throw TypeError(".onnx.GraphProto.node: array expected");Ht.node=[];for(var Gt=0;Gt<Ct.node.length;++Gt){if(typeof Ct.node[Gt]!="object")throw TypeError(".onnx.GraphProto.node: object expected");Ht.node[Gt]=Tt.onnx.NodeProto.fromObject(Ct.node[Gt])}}if(Ct.name!=null&&(Ht.name=String(Ct.name)),Ct.initializer){if(!Array.isArray(Ct.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");Ht.initializer=[];for(var Gt=0;Gt<Ct.initializer.length;++Gt){if(typeof Ct.initializer[Gt]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");Ht.initializer[Gt]=Tt.onnx.TensorProto.fromObject(Ct.initializer[Gt])}}if(Ct.sparseInitializer){if(!Array.isArray(Ct.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");Ht.sparseInitializer=[];for(var Gt=0;Gt<Ct.sparseInitializer.length;++Gt){if(typeof Ct.sparseInitializer[Gt]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");Ht.sparseInitializer[Gt]=Tt.onnx.SparseTensorProto.fromObject(Ct.sparseInitializer[Gt])}}if(Ct.docString!=null&&(Ht.docString=String(Ct.docString)),Ct.input){if(!Array.isArray(Ct.input))throw TypeError(".onnx.GraphProto.input: array expected");Ht.input=[];for(var Gt=0;Gt<Ct.input.length;++Gt){if(typeof Ct.input[Gt]!="object")throw TypeError(".onnx.GraphProto.input: object expected");Ht.input[Gt]=Tt.onnx.ValueInfoProto.fromObject(Ct.input[Gt])}}if(Ct.output){if(!Array.isArray(Ct.output))throw TypeError(".onnx.GraphProto.output: array expected");Ht.output=[];for(var Gt=0;Gt<Ct.output.length;++Gt){if(typeof Ct.output[Gt]!="object")throw TypeError(".onnx.GraphProto.output: object expected");Ht.output[Gt]=Tt.onnx.ValueInfoProto.fromObject(Ct.output[Gt])}}if(Ct.valueInfo){if(!Array.isArray(Ct.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");Ht.valueInfo=[];for(var Gt=0;Gt<Ct.valueInfo.length;++Gt){if(typeof Ct.valueInfo[Gt]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");Ht.valueInfo[Gt]=Tt.onnx.ValueInfoProto.fromObject(Ct.valueInfo[Gt])}}if(Ct.quantizationAnnotation){if(!Array.isArray(Ct.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");Ht.quantizationAnnotation=[];for(var Gt=0;Gt<Ct.quantizationAnnotation.length;++Gt){if(typeof Ct.quantizationAnnotation[Gt]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");Ht.quantizationAnnotation[Gt]=Tt.onnx.TensorAnnotation.fromObject(Ct.quantizationAnnotation[Gt])}}return Ht},Ft.toObject=function(Ct,Ht){Ht||(Ht={});var Gt={};if((Ht.arrays||Ht.defaults)&&(Gt.node=[],Gt.initializer=[],Gt.input=[],Gt.output=[],Gt.valueInfo=[],Gt.quantizationAnnotation=[],Gt.sparseInitializer=[]),Ht.defaults&&(Gt.name="",Gt.docString=""),Ct.node&&Ct.node.length){Gt.node=[];for(var jt=0;jt<Ct.node.length;++jt)Gt.node[jt]=Tt.onnx.NodeProto.toObject(Ct.node[jt],Ht)}if(Ct.name!=null&&Ct.hasOwnProperty("name")&&(Gt.name=Ct.name),Ct.initializer&&Ct.initializer.length){Gt.initializer=[];for(var jt=0;jt<Ct.initializer.length;++jt)Gt.initializer[jt]=Tt.onnx.TensorProto.toObject(Ct.initializer[jt],Ht)}if(Ct.docString!=null&&Ct.hasOwnProperty("docString")&&(Gt.docString=Ct.docString),Ct.input&&Ct.input.length){Gt.input=[];for(var jt=0;jt<Ct.input.length;++jt)Gt.input[jt]=Tt.onnx.ValueInfoProto.toObject(Ct.input[jt],Ht)}if(Ct.output&&Ct.output.length){Gt.output=[];for(var jt=0;jt<Ct.output.length;++jt)Gt.output[jt]=Tt.onnx.ValueInfoProto.toObject(Ct.output[jt],Ht)}if(Ct.valueInfo&&Ct.valueInfo.length){Gt.valueInfo=[];for(var jt=0;jt<Ct.valueInfo.length;++jt)Gt.valueInfo[jt]=Tt.onnx.ValueInfoProto.toObject(Ct.valueInfo[jt],Ht)}if(Ct.quantizationAnnotation&&Ct.quantizationAnnotation.length){Gt.quantizationAnnotation=[];for(var jt=0;jt<Ct.quantizationAnnotation.length;++jt)Gt.quantizationAnnotation[jt]=Tt.onnx.TensorAnnotation.toObject(Ct.quantizationAnnotation[jt],Ht)}if(Ct.sparseInitializer&&Ct.sparseInitializer.length){Gt.sparseInitializer=[];for(var jt=0;jt<Ct.sparseInitializer.length;++jt)Gt.sparseInitializer[jt]=Tt.onnx.SparseTensorProto.toObject(Ct.sparseInitializer[jt],Ht)}return Gt},Ft.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ft.getTypeUrl=function(Ct){return Ct===void 0&&(Ct="type.googleapis.com"),Ct+"/onnx.GraphProto"},Ft}(),Lt.TensorProto=function(){function Ft(Ct){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],Ct)for(var Ht=Object.keys(Ct),Gt=0;Gt<Ht.length;++Gt)Ct[Ht[Gt]]!=null&&(this[Ht[Gt]]=Ct[Ht[Gt]])}return Ft.prototype.dims=$t.emptyArray,Ft.prototype.dataType=0,Ft.prototype.segment=null,Ft.prototype.floatData=$t.emptyArray,Ft.prototype.int32Data=$t.emptyArray,Ft.prototype.stringData=$t.emptyArray,Ft.prototype.int64Data=$t.emptyArray,Ft.prototype.name="",Ft.prototype.docString="",Ft.prototype.rawData=$t.newBuffer([]),Ft.prototype.externalData=$t.emptyArray,Ft.prototype.dataLocation=0,Ft.prototype.doubleData=$t.emptyArray,Ft.prototype.uint64Data=$t.emptyArray,Ft.create=function(Ct){return new Ft(Ct)},Ft.encode=function(Ct,Ht){if(Ht||(Ht=wt.create()),Ct.dims!=null&&Ct.dims.length){Ht.uint32(10).fork();for(var Gt=0;Gt<Ct.dims.length;++Gt)Ht.int64(Ct.dims[Gt]);Ht.ldelim()}if(Ct.dataType!=null&&Object.hasOwnProperty.call(Ct,"dataType")&&Ht.uint32(16).int32(Ct.dataType),Ct.segment!=null&&Object.hasOwnProperty.call(Ct,"segment")&&Tt.onnx.TensorProto.Segment.encode(Ct.segment,Ht.uint32(26).fork()).ldelim(),Ct.floatData!=null&&Ct.floatData.length){Ht.uint32(34).fork();for(var Gt=0;Gt<Ct.floatData.length;++Gt)Ht.float(Ct.floatData[Gt]);Ht.ldelim()}if(Ct.int32Data!=null&&Ct.int32Data.length){Ht.uint32(42).fork();for(var Gt=0;Gt<Ct.int32Data.length;++Gt)Ht.int32(Ct.int32Data[Gt]);Ht.ldelim()}if(Ct.stringData!=null&&Ct.stringData.length)for(var Gt=0;Gt<Ct.stringData.length;++Gt)Ht.uint32(50).bytes(Ct.stringData[Gt]);if(Ct.int64Data!=null&&Ct.int64Data.length){Ht.uint32(58).fork();for(var Gt=0;Gt<Ct.int64Data.length;++Gt)Ht.int64(Ct.int64Data[Gt]);Ht.ldelim()}if(Ct.name!=null&&Object.hasOwnProperty.call(Ct,"name")&&Ht.uint32(66).string(Ct.name),Ct.rawData!=null&&Object.hasOwnProperty.call(Ct,"rawData")&&Ht.uint32(74).bytes(Ct.rawData),Ct.doubleData!=null&&Ct.doubleData.length){Ht.uint32(82).fork();for(var Gt=0;Gt<Ct.doubleData.length;++Gt)Ht.double(Ct.doubleData[Gt]);Ht.ldelim()}if(Ct.uint64Data!=null&&Ct.uint64Data.length){Ht.uint32(90).fork();for(var Gt=0;Gt<Ct.uint64Data.length;++Gt)Ht.uint64(Ct.uint64Data[Gt]);Ht.ldelim()}if(Ct.docString!=null&&Object.hasOwnProperty.call(Ct,"docString")&&Ht.uint32(98).string(Ct.docString),Ct.externalData!=null&&Ct.externalData.length)for(var Gt=0;Gt<Ct.externalData.length;++Gt)Tt.onnx.StringStringEntryProto.encode(Ct.externalData[Gt],Ht.uint32(106).fork()).ldelim();return Ct.dataLocation!=null&&Object.hasOwnProperty.call(Ct,"dataLocation")&&Ht.uint32(112).int32(Ct.dataLocation),Ht},Ft.encodeDelimited=function(Ct,Ht){return this.encode(Ct,Ht).ldelim()},Ft.decode=function(Ct,Ht){Ct instanceof vt||(Ct=vt.create(Ct));for(var Gt=Ht===void 0?Ct.len:Ct.pos+Ht,jt=new Tt.onnx.TensorProto;Ct.pos<Gt;){var qt=Ct.uint32();switch(qt>>>3){case 1:{if(jt.dims&&jt.dims.length||(jt.dims=[]),(qt&7)===2)for(var Kt=Ct.uint32()+Ct.pos;Ct.pos<Kt;)jt.dims.push(Ct.int64());else jt.dims.push(Ct.int64());break}case 2:{jt.dataType=Ct.int32();break}case 3:{jt.segment=Tt.onnx.TensorProto.Segment.decode(Ct,Ct.uint32());break}case 4:{if(jt.floatData&&jt.floatData.length||(jt.floatData=[]),(qt&7)===2)for(var Kt=Ct.uint32()+Ct.pos;Ct.pos<Kt;)jt.floatData.push(Ct.float());else jt.floatData.push(Ct.float());break}case 5:{if(jt.int32Data&&jt.int32Data.length||(jt.int32Data=[]),(qt&7)===2)for(var Kt=Ct.uint32()+Ct.pos;Ct.pos<Kt;)jt.int32Data.push(Ct.int32());else jt.int32Data.push(Ct.int32());break}case 6:{jt.stringData&&jt.stringData.length||(jt.stringData=[]),jt.stringData.push(Ct.bytes());break}case 7:{if(jt.int64Data&&jt.int64Data.length||(jt.int64Data=[]),(qt&7)===2)for(var Kt=Ct.uint32()+Ct.pos;Ct.pos<Kt;)jt.int64Data.push(Ct.int64());else jt.int64Data.push(Ct.int64());break}case 8:{jt.name=Ct.string();break}case 12:{jt.docString=Ct.string();break}case 9:{jt.rawData=Ct.bytes();break}case 13:{jt.externalData&&jt.externalData.length||(jt.externalData=[]),jt.externalData.push(Tt.onnx.StringStringEntryProto.decode(Ct,Ct.uint32()));break}case 14:{jt.dataLocation=Ct.int32();break}case 10:{if(jt.doubleData&&jt.doubleData.length||(jt.doubleData=[]),(qt&7)===2)for(var Kt=Ct.uint32()+Ct.pos;Ct.pos<Kt;)jt.doubleData.push(Ct.double());else jt.doubleData.push(Ct.double());break}case 11:{if(jt.uint64Data&&jt.uint64Data.length||(jt.uint64Data=[]),(qt&7)===2)for(var Kt=Ct.uint32()+Ct.pos;Ct.pos<Kt;)jt.uint64Data.push(Ct.uint64());else jt.uint64Data.push(Ct.uint64());break}default:Ct.skipType(qt&7);break}}return jt},Ft.decodeDelimited=function(Ct){return Ct instanceof vt||(Ct=new vt(Ct)),this.decode(Ct,Ct.uint32())},Ft.verify=function(Ct){if(typeof Ct!="object"||Ct===null)return"object expected";if(Ct.dims!=null&&Ct.hasOwnProperty("dims")){if(!Array.isArray(Ct.dims))return"dims: array expected";for(var Ht=0;Ht<Ct.dims.length;++Ht)if(!$t.isInteger(Ct.dims[Ht])&&!(Ct.dims[Ht]&&$t.isInteger(Ct.dims[Ht].low)&&$t.isInteger(Ct.dims[Ht].high)))return"dims: integer|Long[] expected"}if(Ct.dataType!=null&&Ct.hasOwnProperty("dataType")&&!$t.isInteger(Ct.dataType))return"dataType: integer expected";if(Ct.segment!=null&&Ct.hasOwnProperty("segment")){var Gt=Tt.onnx.TensorProto.Segment.verify(Ct.segment);if(Gt)return"segment."+Gt}if(Ct.floatData!=null&&Ct.hasOwnProperty("floatData")){if(!Array.isArray(Ct.floatData))return"floatData: array expected";for(var Ht=0;Ht<Ct.floatData.length;++Ht)if(typeof Ct.floatData[Ht]!="number")return"floatData: number[] expected"}if(Ct.int32Data!=null&&Ct.hasOwnProperty("int32Data")){if(!Array.isArray(Ct.int32Data))return"int32Data: array expected";for(var Ht=0;Ht<Ct.int32Data.length;++Ht)if(!$t.isInteger(Ct.int32Data[Ht]))return"int32Data: integer[] expected"}if(Ct.stringData!=null&&Ct.hasOwnProperty("stringData")){if(!Array.isArray(Ct.stringData))return"stringData: array expected";for(var Ht=0;Ht<Ct.stringData.length;++Ht)if(!(Ct.stringData[Ht]&&typeof Ct.stringData[Ht].length=="number"||$t.isString(Ct.stringData[Ht])))return"stringData: buffer[] expected"}if(Ct.int64Data!=null&&Ct.hasOwnProperty("int64Data")){if(!Array.isArray(Ct.int64Data))return"int64Data: array expected";for(var Ht=0;Ht<Ct.int64Data.length;++Ht)if(!$t.isInteger(Ct.int64Data[Ht])&&!(Ct.int64Data[Ht]&&$t.isInteger(Ct.int64Data[Ht].low)&&$t.isInteger(Ct.int64Data[Ht].high)))return"int64Data: integer|Long[] expected"}if(Ct.name!=null&&Ct.hasOwnProperty("name")&&!$t.isString(Ct.name))return"name: string expected";if(Ct.docString!=null&&Ct.hasOwnProperty("docString")&&!$t.isString(Ct.docString))return"docString: string expected";if(Ct.rawData!=null&&Ct.hasOwnProperty("rawData")&&!(Ct.rawData&&typeof Ct.rawData.length=="number"||$t.isString(Ct.rawData)))return"rawData: buffer expected";if(Ct.externalData!=null&&Ct.hasOwnProperty("externalData")){if(!Array.isArray(Ct.externalData))return"externalData: array expected";for(var Ht=0;Ht<Ct.externalData.length;++Ht){var Gt=Tt.onnx.StringStringEntryProto.verify(Ct.externalData[Ht]);if(Gt)return"externalData."+Gt}}if(Ct.dataLocation!=null&&Ct.hasOwnProperty("dataLocation"))switch(Ct.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(Ct.doubleData!=null&&Ct.hasOwnProperty("doubleData")){if(!Array.isArray(Ct.doubleData))return"doubleData: array expected";for(var Ht=0;Ht<Ct.doubleData.length;++Ht)if(typeof Ct.doubleData[Ht]!="number")return"doubleData: number[] expected"}if(Ct.uint64Data!=null&&Ct.hasOwnProperty("uint64Data")){if(!Array.isArray(Ct.uint64Data))return"uint64Data: array expected";for(var Ht=0;Ht<Ct.uint64Data.length;++Ht)if(!$t.isInteger(Ct.uint64Data[Ht])&&!(Ct.uint64Data[Ht]&&$t.isInteger(Ct.uint64Data[Ht].low)&&$t.isInteger(Ct.uint64Data[Ht].high)))return"uint64Data: integer|Long[] expected"}return null},Ft.fromObject=function(Ct){if(Ct instanceof Tt.onnx.TensorProto)return Ct;var Ht=new Tt.onnx.TensorProto;if(Ct.dims){if(!Array.isArray(Ct.dims))throw TypeError(".onnx.TensorProto.dims: array expected");Ht.dims=[];for(var Gt=0;Gt<Ct.dims.length;++Gt)$t.Long?(Ht.dims[Gt]=$t.Long.fromValue(Ct.dims[Gt])).unsigned=!1:typeof Ct.dims[Gt]=="string"?Ht.dims[Gt]=parseInt(Ct.dims[Gt],10):typeof Ct.dims[Gt]=="number"?Ht.dims[Gt]=Ct.dims[Gt]:typeof Ct.dims[Gt]=="object"&&(Ht.dims[Gt]=new $t.LongBits(Ct.dims[Gt].low>>>0,Ct.dims[Gt].high>>>0).toNumber())}if(Ct.dataType!=null&&(Ht.dataType=Ct.dataType|0),Ct.segment!=null){if(typeof Ct.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");Ht.segment=Tt.onnx.TensorProto.Segment.fromObject(Ct.segment)}if(Ct.floatData){if(!Array.isArray(Ct.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");Ht.floatData=[];for(var Gt=0;Gt<Ct.floatData.length;++Gt)Ht.floatData[Gt]=Number(Ct.floatData[Gt])}if(Ct.int32Data){if(!Array.isArray(Ct.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");Ht.int32Data=[];for(var Gt=0;Gt<Ct.int32Data.length;++Gt)Ht.int32Data[Gt]=Ct.int32Data[Gt]|0}if(Ct.stringData){if(!Array.isArray(Ct.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");Ht.stringData=[];for(var Gt=0;Gt<Ct.stringData.length;++Gt)typeof Ct.stringData[Gt]=="string"?$t.base64.decode(Ct.stringData[Gt],Ht.stringData[Gt]=$t.newBuffer($t.base64.length(Ct.stringData[Gt])),0):Ct.stringData[Gt].length>=0&&(Ht.stringData[Gt]=Ct.stringData[Gt])}if(Ct.int64Data){if(!Array.isArray(Ct.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");Ht.int64Data=[];for(var Gt=0;Gt<Ct.int64Data.length;++Gt)$t.Long?(Ht.int64Data[Gt]=$t.Long.fromValue(Ct.int64Data[Gt])).unsigned=!1:typeof Ct.int64Data[Gt]=="string"?Ht.int64Data[Gt]=parseInt(Ct.int64Data[Gt],10):typeof Ct.int64Data[Gt]=="number"?Ht.int64Data[Gt]=Ct.int64Data[Gt]:typeof Ct.int64Data[Gt]=="object"&&(Ht.int64Data[Gt]=new $t.LongBits(Ct.int64Data[Gt].low>>>0,Ct.int64Data[Gt].high>>>0).toNumber())}if(Ct.name!=null&&(Ht.name=String(Ct.name)),Ct.docString!=null&&(Ht.docString=String(Ct.docString)),Ct.rawData!=null&&(typeof Ct.rawData=="string"?$t.base64.decode(Ct.rawData,Ht.rawData=$t.newBuffer($t.base64.length(Ct.rawData)),0):Ct.rawData.length>=0&&(Ht.rawData=Ct.rawData)),Ct.externalData){if(!Array.isArray(Ct.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");Ht.externalData=[];for(var Gt=0;Gt<Ct.externalData.length;++Gt){if(typeof Ct.externalData[Gt]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");Ht.externalData[Gt]=Tt.onnx.StringStringEntryProto.fromObject(Ct.externalData[Gt])}}switch(Ct.dataLocation){default:if(typeof Ct.dataLocation=="number"){Ht.dataLocation=Ct.dataLocation;break}break;case"DEFAULT":case 0:Ht.dataLocation=0;break;case"EXTERNAL":case 1:Ht.dataLocation=1;break}if(Ct.doubleData){if(!Array.isArray(Ct.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");Ht.doubleData=[];for(var Gt=0;Gt<Ct.doubleData.length;++Gt)Ht.doubleData[Gt]=Number(Ct.doubleData[Gt])}if(Ct.uint64Data){if(!Array.isArray(Ct.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");Ht.uint64Data=[];for(var Gt=0;Gt<Ct.uint64Data.length;++Gt)$t.Long?(Ht.uint64Data[Gt]=$t.Long.fromValue(Ct.uint64Data[Gt])).unsigned=!0:typeof Ct.uint64Data[Gt]=="string"?Ht.uint64Data[Gt]=parseInt(Ct.uint64Data[Gt],10):typeof Ct.uint64Data[Gt]=="number"?Ht.uint64Data[Gt]=Ct.uint64Data[Gt]:typeof Ct.uint64Data[Gt]=="object"&&(Ht.uint64Data[Gt]=new $t.LongBits(Ct.uint64Data[Gt].low>>>0,Ct.uint64Data[Gt].high>>>0).toNumber(!0))}return Ht},Ft.toObject=function(Ct,Ht){Ht||(Ht={});var Gt={};if((Ht.arrays||Ht.defaults)&&(Gt.dims=[],Gt.floatData=[],Gt.int32Data=[],Gt.stringData=[],Gt.int64Data=[],Gt.doubleData=[],Gt.uint64Data=[],Gt.externalData=[]),Ht.defaults&&(Gt.dataType=0,Gt.segment=null,Gt.name="",Ht.bytes===String?Gt.rawData="":(Gt.rawData=[],Ht.bytes!==Array&&(Gt.rawData=$t.newBuffer(Gt.rawData))),Gt.docString="",Gt.dataLocation=Ht.enums===String?"DEFAULT":0),Ct.dims&&Ct.dims.length){Gt.dims=[];for(var jt=0;jt<Ct.dims.length;++jt)typeof Ct.dims[jt]=="number"?Gt.dims[jt]=Ht.longs===String?String(Ct.dims[jt]):Ct.dims[jt]:Gt.dims[jt]=Ht.longs===String?$t.Long.prototype.toString.call(Ct.dims[jt]):Ht.longs===Number?new $t.LongBits(Ct.dims[jt].low>>>0,Ct.dims[jt].high>>>0).toNumber():Ct.dims[jt]}if(Ct.dataType!=null&&Ct.hasOwnProperty("dataType")&&(Gt.dataType=Ct.dataType),Ct.segment!=null&&Ct.hasOwnProperty("segment")&&(Gt.segment=Tt.onnx.TensorProto.Segment.toObject(Ct.segment,Ht)),Ct.floatData&&Ct.floatData.length){Gt.floatData=[];for(var jt=0;jt<Ct.floatData.length;++jt)Gt.floatData[jt]=Ht.json&&!isFinite(Ct.floatData[jt])?String(Ct.floatData[jt]):Ct.floatData[jt]}if(Ct.int32Data&&Ct.int32Data.length){Gt.int32Data=[];for(var jt=0;jt<Ct.int32Data.length;++jt)Gt.int32Data[jt]=Ct.int32Data[jt]}if(Ct.stringData&&Ct.stringData.length){Gt.stringData=[];for(var jt=0;jt<Ct.stringData.length;++jt)Gt.stringData[jt]=Ht.bytes===String?$t.base64.encode(Ct.stringData[jt],0,Ct.stringData[jt].length):Ht.bytes===Array?Array.prototype.slice.call(Ct.stringData[jt]):Ct.stringData[jt]}if(Ct.int64Data&&Ct.int64Data.length){Gt.int64Data=[];for(var jt=0;jt<Ct.int64Data.length;++jt)typeof Ct.int64Data[jt]=="number"?Gt.int64Data[jt]=Ht.longs===String?String(Ct.int64Data[jt]):Ct.int64Data[jt]:Gt.int64Data[jt]=Ht.longs===String?$t.Long.prototype.toString.call(Ct.int64Data[jt]):Ht.longs===Number?new $t.LongBits(Ct.int64Data[jt].low>>>0,Ct.int64Data[jt].high>>>0).toNumber():Ct.int64Data[jt]}if(Ct.name!=null&&Ct.hasOwnProperty("name")&&(Gt.name=Ct.name),Ct.rawData!=null&&Ct.hasOwnProperty("rawData")&&(Gt.rawData=Ht.bytes===String?$t.base64.encode(Ct.rawData,0,Ct.rawData.length):Ht.bytes===Array?Array.prototype.slice.call(Ct.rawData):Ct.rawData),Ct.doubleData&&Ct.doubleData.length){Gt.doubleData=[];for(var jt=0;jt<Ct.doubleData.length;++jt)Gt.doubleData[jt]=Ht.json&&!isFinite(Ct.doubleData[jt])?String(Ct.doubleData[jt]):Ct.doubleData[jt]}if(Ct.uint64Data&&Ct.uint64Data.length){Gt.uint64Data=[];for(var jt=0;jt<Ct.uint64Data.length;++jt)typeof Ct.uint64Data[jt]=="number"?Gt.uint64Data[jt]=Ht.longs===String?String(Ct.uint64Data[jt]):Ct.uint64Data[jt]:Gt.uint64Data[jt]=Ht.longs===String?$t.Long.prototype.toString.call(Ct.uint64Data[jt]):Ht.longs===Number?new $t.LongBits(Ct.uint64Data[jt].low>>>0,Ct.uint64Data[jt].high>>>0).toNumber(!0):Ct.uint64Data[jt]}if(Ct.docString!=null&&Ct.hasOwnProperty("docString")&&(Gt.docString=Ct.docString),Ct.externalData&&Ct.externalData.length){Gt.externalData=[];for(var jt=0;jt<Ct.externalData.length;++jt)Gt.externalData[jt]=Tt.onnx.StringStringEntryProto.toObject(Ct.externalData[jt],Ht)}return Ct.dataLocation!=null&&Ct.hasOwnProperty("dataLocation")&&(Gt.dataLocation=Ht.enums===String?Tt.onnx.TensorProto.DataLocation[Ct.dataLocation]===void 0?Ct.dataLocation:Tt.onnx.TensorProto.DataLocation[Ct.dataLocation]:Ct.dataLocation),Gt},Ft.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ft.getTypeUrl=function(Ct){return Ct===void 0&&(Ct="type.googleapis.com"),Ct+"/onnx.TensorProto"},Ft.DataType=function(){var Ct={},Ht=Object.create(Ct);return Ht[Ct[0]="UNDEFINED"]=0,Ht[Ct[1]="FLOAT"]=1,Ht[Ct[2]="UINT8"]=2,Ht[Ct[3]="INT8"]=3,Ht[Ct[4]="UINT16"]=4,Ht[Ct[5]="INT16"]=5,Ht[Ct[6]="INT32"]=6,Ht[Ct[7]="INT64"]=7,Ht[Ct[8]="STRING"]=8,Ht[Ct[9]="BOOL"]=9,Ht[Ct[10]="FLOAT16"]=10,Ht[Ct[11]="DOUBLE"]=11,Ht[Ct[12]="UINT32"]=12,Ht[Ct[13]="UINT64"]=13,Ht[Ct[14]="COMPLEX64"]=14,Ht[Ct[15]="COMPLEX128"]=15,Ht[Ct[16]="BFLOAT16"]=16,Ht[Ct[17]="FLOAT8E4M3FN"]=17,Ht[Ct[18]="FLOAT8E4M3FNUZ"]=18,Ht[Ct[19]="FLOAT8E5M2"]=19,Ht[Ct[20]="FLOAT8E5M2FNUZ"]=20,Ht}(),Ft.Segment=function(){function Ct(Ht){if(Ht)for(var Gt=Object.keys(Ht),jt=0;jt<Gt.length;++jt)Ht[Gt[jt]]!=null&&(this[Gt[jt]]=Ht[Gt[jt]])}return Ct.prototype.begin=$t.Long?$t.Long.fromBits(0,0,!1):0,Ct.prototype.end=$t.Long?$t.Long.fromBits(0,0,!1):0,Ct.create=function(Ht){return new Ct(Ht)},Ct.encode=function(Ht,Gt){return Gt||(Gt=wt.create()),Ht.begin!=null&&Object.hasOwnProperty.call(Ht,"begin")&&Gt.uint32(8).int64(Ht.begin),Ht.end!=null&&Object.hasOwnProperty.call(Ht,"end")&&Gt.uint32(16).int64(Ht.end),Gt},Ct.encodeDelimited=function(Ht,Gt){return this.encode(Ht,Gt).ldelim()},Ct.decode=function(Ht,Gt){Ht instanceof vt||(Ht=vt.create(Ht));for(var jt=Gt===void 0?Ht.len:Ht.pos+Gt,qt=new Tt.onnx.TensorProto.Segment;Ht.pos<jt;){var Kt=Ht.uint32();switch(Kt>>>3){case 1:{qt.begin=Ht.int64();break}case 2:{qt.end=Ht.int64();break}default:Ht.skipType(Kt&7);break}}return qt},Ct.decodeDelimited=function(Ht){return Ht instanceof vt||(Ht=new vt(Ht)),this.decode(Ht,Ht.uint32())},Ct.verify=function(Ht){return typeof Ht!="object"||Ht===null?"object expected":Ht.begin!=null&&Ht.hasOwnProperty("begin")&&!$t.isInteger(Ht.begin)&&!(Ht.begin&&$t.isInteger(Ht.begin.low)&&$t.isInteger(Ht.begin.high))?"begin: integer|Long expected":Ht.end!=null&&Ht.hasOwnProperty("end")&&!$t.isInteger(Ht.end)&&!(Ht.end&&$t.isInteger(Ht.end.low)&&$t.isInteger(Ht.end.high))?"end: integer|Long expected":null},Ct.fromObject=function(Ht){if(Ht instanceof Tt.onnx.TensorProto.Segment)return Ht;var Gt=new Tt.onnx.TensorProto.Segment;return Ht.begin!=null&&($t.Long?(Gt.begin=$t.Long.fromValue(Ht.begin)).unsigned=!1:typeof Ht.begin=="string"?Gt.begin=parseInt(Ht.begin,10):typeof Ht.begin=="number"?Gt.begin=Ht.begin:typeof Ht.begin=="object"&&(Gt.begin=new $t.LongBits(Ht.begin.low>>>0,Ht.begin.high>>>0).toNumber())),Ht.end!=null&&($t.Long?(Gt.end=$t.Long.fromValue(Ht.end)).unsigned=!1:typeof Ht.end=="string"?Gt.end=parseInt(Ht.end,10):typeof Ht.end=="number"?Gt.end=Ht.end:typeof Ht.end=="object"&&(Gt.end=new $t.LongBits(Ht.end.low>>>0,Ht.end.high>>>0).toNumber())),Gt},Ct.toObject=function(Ht,Gt){Gt||(Gt={});var jt={};if(Gt.defaults){if($t.Long){var qt=new $t.Long(0,0,!1);jt.begin=Gt.longs===String?qt.toString():Gt.longs===Number?qt.toNumber():qt}else jt.begin=Gt.longs===String?"0":0;if($t.Long){var qt=new $t.Long(0,0,!1);jt.end=Gt.longs===String?qt.toString():Gt.longs===Number?qt.toNumber():qt}else jt.end=Gt.longs===String?"0":0}return Ht.begin!=null&&Ht.hasOwnProperty("begin")&&(typeof Ht.begin=="number"?jt.begin=Gt.longs===String?String(Ht.begin):Ht.begin:jt.begin=Gt.longs===String?$t.Long.prototype.toString.call(Ht.begin):Gt.longs===Number?new $t.LongBits(Ht.begin.low>>>0,Ht.begin.high>>>0).toNumber():Ht.begin),Ht.end!=null&&Ht.hasOwnProperty("end")&&(typeof Ht.end=="number"?jt.end=Gt.longs===String?String(Ht.end):Ht.end:jt.end=Gt.longs===String?$t.Long.prototype.toString.call(Ht.end):Gt.longs===Number?new $t.LongBits(Ht.end.low>>>0,Ht.end.high>>>0).toNumber():Ht.end),jt},Ct.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ct.getTypeUrl=function(Ht){return Ht===void 0&&(Ht="type.googleapis.com"),Ht+"/onnx.TensorProto.Segment"},Ct}(),Ft.DataLocation=function(){var Ct={},Ht=Object.create(Ct);return Ht[Ct[0]="DEFAULT"]=0,Ht[Ct[1]="EXTERNAL"]=1,Ht}(),Ft}(),Lt.SparseTensorProto=function(){function Ft(Ct){if(this.dims=[],Ct)for(var Ht=Object.keys(Ct),Gt=0;Gt<Ht.length;++Gt)Ct[Ht[Gt]]!=null&&(this[Ht[Gt]]=Ct[Ht[Gt]])}return Ft.prototype.values=null,Ft.prototype.indices=null,Ft.prototype.dims=$t.emptyArray,Ft.create=function(Ct){return new Ft(Ct)},Ft.encode=function(Ct,Ht){if(Ht||(Ht=wt.create()),Ct.values!=null&&Object.hasOwnProperty.call(Ct,"values")&&Tt.onnx.TensorProto.encode(Ct.values,Ht.uint32(10).fork()).ldelim(),Ct.indices!=null&&Object.hasOwnProperty.call(Ct,"indices")&&Tt.onnx.TensorProto.encode(Ct.indices,Ht.uint32(18).fork()).ldelim(),Ct.dims!=null&&Ct.dims.length){Ht.uint32(26).fork();for(var Gt=0;Gt<Ct.dims.length;++Gt)Ht.int64(Ct.dims[Gt]);Ht.ldelim()}return Ht},Ft.encodeDelimited=function(Ct,Ht){return this.encode(Ct,Ht).ldelim()},Ft.decode=function(Ct,Ht){Ct instanceof vt||(Ct=vt.create(Ct));for(var Gt=Ht===void 0?Ct.len:Ct.pos+Ht,jt=new Tt.onnx.SparseTensorProto;Ct.pos<Gt;){var qt=Ct.uint32();switch(qt>>>3){case 1:{jt.values=Tt.onnx.TensorProto.decode(Ct,Ct.uint32());break}case 2:{jt.indices=Tt.onnx.TensorProto.decode(Ct,Ct.uint32());break}case 3:{if(jt.dims&&jt.dims.length||(jt.dims=[]),(qt&7)===2)for(var Kt=Ct.uint32()+Ct.pos;Ct.pos<Kt;)jt.dims.push(Ct.int64());else jt.dims.push(Ct.int64());break}default:Ct.skipType(qt&7);break}}return jt},Ft.decodeDelimited=function(Ct){return Ct instanceof vt||(Ct=new vt(Ct)),this.decode(Ct,Ct.uint32())},Ft.verify=function(Ct){if(typeof Ct!="object"||Ct===null)return"object expected";if(Ct.values!=null&&Ct.hasOwnProperty("values")){var Ht=Tt.onnx.TensorProto.verify(Ct.values);if(Ht)return"values."+Ht}if(Ct.indices!=null&&Ct.hasOwnProperty("indices")){var Ht=Tt.onnx.TensorProto.verify(Ct.indices);if(Ht)return"indices."+Ht}if(Ct.dims!=null&&Ct.hasOwnProperty("dims")){if(!Array.isArray(Ct.dims))return"dims: array expected";for(var Gt=0;Gt<Ct.dims.length;++Gt)if(!$t.isInteger(Ct.dims[Gt])&&!(Ct.dims[Gt]&&$t.isInteger(Ct.dims[Gt].low)&&$t.isInteger(Ct.dims[Gt].high)))return"dims: integer|Long[] expected"}return null},Ft.fromObject=function(Ct){if(Ct instanceof Tt.onnx.SparseTensorProto)return Ct;var Ht=new Tt.onnx.SparseTensorProto;if(Ct.values!=null){if(typeof Ct.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");Ht.values=Tt.onnx.TensorProto.fromObject(Ct.values)}if(Ct.indices!=null){if(typeof Ct.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");Ht.indices=Tt.onnx.TensorProto.fromObject(Ct.indices)}if(Ct.dims){if(!Array.isArray(Ct.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");Ht.dims=[];for(var Gt=0;Gt<Ct.dims.length;++Gt)$t.Long?(Ht.dims[Gt]=$t.Long.fromValue(Ct.dims[Gt])).unsigned=!1:typeof Ct.dims[Gt]=="string"?Ht.dims[Gt]=parseInt(Ct.dims[Gt],10):typeof Ct.dims[Gt]=="number"?Ht.dims[Gt]=Ct.dims[Gt]:typeof Ct.dims[Gt]=="object"&&(Ht.dims[Gt]=new $t.LongBits(Ct.dims[Gt].low>>>0,Ct.dims[Gt].high>>>0).toNumber())}return Ht},Ft.toObject=function(Ct,Ht){Ht||(Ht={});var Gt={};if((Ht.arrays||Ht.defaults)&&(Gt.dims=[]),Ht.defaults&&(Gt.values=null,Gt.indices=null),Ct.values!=null&&Ct.hasOwnProperty("values")&&(Gt.values=Tt.onnx.TensorProto.toObject(Ct.values,Ht)),Ct.indices!=null&&Ct.hasOwnProperty("indices")&&(Gt.indices=Tt.onnx.TensorProto.toObject(Ct.indices,Ht)),Ct.dims&&Ct.dims.length){Gt.dims=[];for(var jt=0;jt<Ct.dims.length;++jt)typeof Ct.dims[jt]=="number"?Gt.dims[jt]=Ht.longs===String?String(Ct.dims[jt]):Ct.dims[jt]:Gt.dims[jt]=Ht.longs===String?$t.Long.prototype.toString.call(Ct.dims[jt]):Ht.longs===Number?new $t.LongBits(Ct.dims[jt].low>>>0,Ct.dims[jt].high>>>0).toNumber():Ct.dims[jt]}return Gt},Ft.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ft.getTypeUrl=function(Ct){return Ct===void 0&&(Ct="type.googleapis.com"),Ct+"/onnx.SparseTensorProto"},Ft}(),Lt.TensorShapeProto=function(){function Ft(Ct){if(this.dim=[],Ct)for(var Ht=Object.keys(Ct),Gt=0;Gt<Ht.length;++Gt)Ct[Ht[Gt]]!=null&&(this[Ht[Gt]]=Ct[Ht[Gt]])}return Ft.prototype.dim=$t.emptyArray,Ft.create=function(Ct){return new Ft(Ct)},Ft.encode=function(Ct,Ht){if(Ht||(Ht=wt.create()),Ct.dim!=null&&Ct.dim.length)for(var Gt=0;Gt<Ct.dim.length;++Gt)Tt.onnx.TensorShapeProto.Dimension.encode(Ct.dim[Gt],Ht.uint32(10).fork()).ldelim();return Ht},Ft.encodeDelimited=function(Ct,Ht){return this.encode(Ct,Ht).ldelim()},Ft.decode=function(Ct,Ht){Ct instanceof vt||(Ct=vt.create(Ct));for(var Gt=Ht===void 0?Ct.len:Ct.pos+Ht,jt=new Tt.onnx.TensorShapeProto;Ct.pos<Gt;){var qt=Ct.uint32();switch(qt>>>3){case 1:{jt.dim&&jt.dim.length||(jt.dim=[]),jt.dim.push(Tt.onnx.TensorShapeProto.Dimension.decode(Ct,Ct.uint32()));break}default:Ct.skipType(qt&7);break}}return jt},Ft.decodeDelimited=function(Ct){return Ct instanceof vt||(Ct=new vt(Ct)),this.decode(Ct,Ct.uint32())},Ft.verify=function(Ct){if(typeof Ct!="object"||Ct===null)return"object expected";if(Ct.dim!=null&&Ct.hasOwnProperty("dim")){if(!Array.isArray(Ct.dim))return"dim: array expected";for(var Ht=0;Ht<Ct.dim.length;++Ht){var Gt=Tt.onnx.TensorShapeProto.Dimension.verify(Ct.dim[Ht]);if(Gt)return"dim."+Gt}}return null},Ft.fromObject=function(Ct){if(Ct instanceof Tt.onnx.TensorShapeProto)return Ct;var Ht=new Tt.onnx.TensorShapeProto;if(Ct.dim){if(!Array.isArray(Ct.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");Ht.dim=[];for(var Gt=0;Gt<Ct.dim.length;++Gt){if(typeof Ct.dim[Gt]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");Ht.dim[Gt]=Tt.onnx.TensorShapeProto.Dimension.fromObject(Ct.dim[Gt])}}return Ht},Ft.toObject=function(Ct,Ht){Ht||(Ht={});var Gt={};if((Ht.arrays||Ht.defaults)&&(Gt.dim=[]),Ct.dim&&Ct.dim.length){Gt.dim=[];for(var jt=0;jt<Ct.dim.length;++jt)Gt.dim[jt]=Tt.onnx.TensorShapeProto.Dimension.toObject(Ct.dim[jt],Ht)}return Gt},Ft.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ft.getTypeUrl=function(Ct){return Ct===void 0&&(Ct="type.googleapis.com"),Ct+"/onnx.TensorShapeProto"},Ft.Dimension=function(){function Ct(Gt){if(Gt)for(var jt=Object.keys(Gt),qt=0;qt<jt.length;++qt)Gt[jt[qt]]!=null&&(this[jt[qt]]=Gt[jt[qt]])}Ct.prototype.dimValue=null,Ct.prototype.dimParam=null,Ct.prototype.denotation="";var Ht;return Object.defineProperty(Ct.prototype,"value",{get:$t.oneOfGetter(Ht=["dimValue","dimParam"]),set:$t.oneOfSetter(Ht)}),Ct.create=function(Gt){return new Ct(Gt)},Ct.encode=function(Gt,jt){return jt||(jt=wt.create()),Gt.dimValue!=null&&Object.hasOwnProperty.call(Gt,"dimValue")&&jt.uint32(8).int64(Gt.dimValue),Gt.dimParam!=null&&Object.hasOwnProperty.call(Gt,"dimParam")&&jt.uint32(18).string(Gt.dimParam),Gt.denotation!=null&&Object.hasOwnProperty.call(Gt,"denotation")&&jt.uint32(26).string(Gt.denotation),jt},Ct.encodeDelimited=function(Gt,jt){return this.encode(Gt,jt).ldelim()},Ct.decode=function(Gt,jt){Gt instanceof vt||(Gt=vt.create(Gt));for(var qt=jt===void 0?Gt.len:Gt.pos+jt,Kt=new Tt.onnx.TensorShapeProto.Dimension;Gt.pos<qt;){var An=Gt.uint32();switch(An>>>3){case 1:{Kt.dimValue=Gt.int64();break}case 2:{Kt.dimParam=Gt.string();break}case 3:{Kt.denotation=Gt.string();break}default:Gt.skipType(An&7);break}}return Kt},Ct.decodeDelimited=function(Gt){return Gt instanceof vt||(Gt=new vt(Gt)),this.decode(Gt,Gt.uint32())},Ct.verify=function(Gt){if(typeof Gt!="object"||Gt===null)return"object expected";var jt={};if(Gt.dimValue!=null&&Gt.hasOwnProperty("dimValue")&&(jt.value=1,!$t.isInteger(Gt.dimValue)&&!(Gt.dimValue&&$t.isInteger(Gt.dimValue.low)&&$t.isInteger(Gt.dimValue.high))))return"dimValue: integer|Long expected";if(Gt.dimParam!=null&&Gt.hasOwnProperty("dimParam")){if(jt.value===1)return"value: multiple values";if(jt.value=1,!$t.isString(Gt.dimParam))return"dimParam: string expected"}return Gt.denotation!=null&&Gt.hasOwnProperty("denotation")&&!$t.isString(Gt.denotation)?"denotation: string expected":null},Ct.fromObject=function(Gt){if(Gt instanceof Tt.onnx.TensorShapeProto.Dimension)return Gt;var jt=new Tt.onnx.TensorShapeProto.Dimension;return Gt.dimValue!=null&&($t.Long?(jt.dimValue=$t.Long.fromValue(Gt.dimValue)).unsigned=!1:typeof Gt.dimValue=="string"?jt.dimValue=parseInt(Gt.dimValue,10):typeof Gt.dimValue=="number"?jt.dimValue=Gt.dimValue:typeof Gt.dimValue=="object"&&(jt.dimValue=new $t.LongBits(Gt.dimValue.low>>>0,Gt.dimValue.high>>>0).toNumber())),Gt.dimParam!=null&&(jt.dimParam=String(Gt.dimParam)),Gt.denotation!=null&&(jt.denotation=String(Gt.denotation)),jt},Ct.toObject=function(Gt,jt){jt||(jt={});var qt={};return jt.defaults&&(qt.denotation=""),Gt.dimValue!=null&&Gt.hasOwnProperty("dimValue")&&(typeof Gt.dimValue=="number"?qt.dimValue=jt.longs===String?String(Gt.dimValue):Gt.dimValue:qt.dimValue=jt.longs===String?$t.Long.prototype.toString.call(Gt.dimValue):jt.longs===Number?new $t.LongBits(Gt.dimValue.low>>>0,Gt.dimValue.high>>>0).toNumber():Gt.dimValue,jt.oneofs&&(qt.value="dimValue")),Gt.dimParam!=null&&Gt.hasOwnProperty("dimParam")&&(qt.dimParam=Gt.dimParam,jt.oneofs&&(qt.value="dimParam")),Gt.denotation!=null&&Gt.hasOwnProperty("denotation")&&(qt.denotation=Gt.denotation),qt},Ct.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ct.getTypeUrl=function(Gt){return Gt===void 0&&(Gt="type.googleapis.com"),Gt+"/onnx.TensorShapeProto.Dimension"},Ct}(),Ft}(),Lt.TypeProto=function(){function Ft(Ht){if(Ht)for(var Gt=Object.keys(Ht),jt=0;jt<Gt.length;++jt)Ht[Gt[jt]]!=null&&(this[Gt[jt]]=Ht[Gt[jt]])}Ft.prototype.tensorType=null,Ft.prototype.sequenceType=null,Ft.prototype.mapType=null,Ft.prototype.optionalType=null,Ft.prototype.sparseTensorType=null,Ft.prototype.denotation="";var Ct;return Object.defineProperty(Ft.prototype,"value",{get:$t.oneOfGetter(Ct=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:$t.oneOfSetter(Ct)}),Ft.create=function(Ht){return new Ft(Ht)},Ft.encode=function(Ht,Gt){return Gt||(Gt=wt.create()),Ht.tensorType!=null&&Object.hasOwnProperty.call(Ht,"tensorType")&&Tt.onnx.TypeProto.Tensor.encode(Ht.tensorType,Gt.uint32(10).fork()).ldelim(),Ht.sequenceType!=null&&Object.hasOwnProperty.call(Ht,"sequenceType")&&Tt.onnx.TypeProto.Sequence.encode(Ht.sequenceType,Gt.uint32(34).fork()).ldelim(),Ht.mapType!=null&&Object.hasOwnProperty.call(Ht,"mapType")&&Tt.onnx.TypeProto.Map.encode(Ht.mapType,Gt.uint32(42).fork()).ldelim(),Ht.denotation!=null&&Object.hasOwnProperty.call(Ht,"denotation")&&Gt.uint32(50).string(Ht.denotation),Ht.sparseTensorType!=null&&Object.hasOwnProperty.call(Ht,"sparseTensorType")&&Tt.onnx.TypeProto.SparseTensor.encode(Ht.sparseTensorType,Gt.uint32(66).fork()).ldelim(),Ht.optionalType!=null&&Object.hasOwnProperty.call(Ht,"optionalType")&&Tt.onnx.TypeProto.Optional.encode(Ht.optionalType,Gt.uint32(74).fork()).ldelim(),Gt},Ft.encodeDelimited=function(Ht,Gt){return this.encode(Ht,Gt).ldelim()},Ft.decode=function(Ht,Gt){Ht instanceof vt||(Ht=vt.create(Ht));for(var jt=Gt===void 0?Ht.len:Ht.pos+Gt,qt=new Tt.onnx.TypeProto;Ht.pos<jt;){var Kt=Ht.uint32();switch(Kt>>>3){case 1:{qt.tensorType=Tt.onnx.TypeProto.Tensor.decode(Ht,Ht.uint32());break}case 4:{qt.sequenceType=Tt.onnx.TypeProto.Sequence.decode(Ht,Ht.uint32());break}case 5:{qt.mapType=Tt.onnx.TypeProto.Map.decode(Ht,Ht.uint32());break}case 9:{qt.optionalType=Tt.onnx.TypeProto.Optional.decode(Ht,Ht.uint32());break}case 8:{qt.sparseTensorType=Tt.onnx.TypeProto.SparseTensor.decode(Ht,Ht.uint32());break}case 6:{qt.denotation=Ht.string();break}default:Ht.skipType(Kt&7);break}}return qt},Ft.decodeDelimited=function(Ht){return Ht instanceof vt||(Ht=new vt(Ht)),this.decode(Ht,Ht.uint32())},Ft.verify=function(Ht){if(typeof Ht!="object"||Ht===null)return"object expected";var Gt={};if(Ht.tensorType!=null&&Ht.hasOwnProperty("tensorType")){Gt.value=1;{var jt=Tt.onnx.TypeProto.Tensor.verify(Ht.tensorType);if(jt)return"tensorType."+jt}}if(Ht.sequenceType!=null&&Ht.hasOwnProperty("sequenceType")){if(Gt.value===1)return"value: multiple values";Gt.value=1;{var jt=Tt.onnx.TypeProto.Sequence.verify(Ht.sequenceType);if(jt)return"sequenceType."+jt}}if(Ht.mapType!=null&&Ht.hasOwnProperty("mapType")){if(Gt.value===1)return"value: multiple values";Gt.value=1;{var jt=Tt.onnx.TypeProto.Map.verify(Ht.mapType);if(jt)return"mapType."+jt}}if(Ht.optionalType!=null&&Ht.hasOwnProperty("optionalType")){if(Gt.value===1)return"value: multiple values";Gt.value=1;{var jt=Tt.onnx.TypeProto.Optional.verify(Ht.optionalType);if(jt)return"optionalType."+jt}}if(Ht.sparseTensorType!=null&&Ht.hasOwnProperty("sparseTensorType")){if(Gt.value===1)return"value: multiple values";Gt.value=1;{var jt=Tt.onnx.TypeProto.SparseTensor.verify(Ht.sparseTensorType);if(jt)return"sparseTensorType."+jt}}return Ht.denotation!=null&&Ht.hasOwnProperty("denotation")&&!$t.isString(Ht.denotation)?"denotation: string expected":null},Ft.fromObject=function(Ht){if(Ht instanceof Tt.onnx.TypeProto)return Ht;var Gt=new Tt.onnx.TypeProto;if(Ht.tensorType!=null){if(typeof Ht.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");Gt.tensorType=Tt.onnx.TypeProto.Tensor.fromObject(Ht.tensorType)}if(Ht.sequenceType!=null){if(typeof Ht.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");Gt.sequenceType=Tt.onnx.TypeProto.Sequence.fromObject(Ht.sequenceType)}if(Ht.mapType!=null){if(typeof Ht.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");Gt.mapType=Tt.onnx.TypeProto.Map.fromObject(Ht.mapType)}if(Ht.optionalType!=null){if(typeof Ht.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");Gt.optionalType=Tt.onnx.TypeProto.Optional.fromObject(Ht.optionalType)}if(Ht.sparseTensorType!=null){if(typeof Ht.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");Gt.sparseTensorType=Tt.onnx.TypeProto.SparseTensor.fromObject(Ht.sparseTensorType)}return Ht.denotation!=null&&(Gt.denotation=String(Ht.denotation)),Gt},Ft.toObject=function(Ht,Gt){Gt||(Gt={});var jt={};return Gt.defaults&&(jt.denotation=""),Ht.tensorType!=null&&Ht.hasOwnProperty("tensorType")&&(jt.tensorType=Tt.onnx.TypeProto.Tensor.toObject(Ht.tensorType,Gt),Gt.oneofs&&(jt.value="tensorType")),Ht.sequenceType!=null&&Ht.hasOwnProperty("sequenceType")&&(jt.sequenceType=Tt.onnx.TypeProto.Sequence.toObject(Ht.sequenceType,Gt),Gt.oneofs&&(jt.value="sequenceType")),Ht.mapType!=null&&Ht.hasOwnProperty("mapType")&&(jt.mapType=Tt.onnx.TypeProto.Map.toObject(Ht.mapType,Gt),Gt.oneofs&&(jt.value="mapType")),Ht.denotation!=null&&Ht.hasOwnProperty("denotation")&&(jt.denotation=Ht.denotation),Ht.sparseTensorType!=null&&Ht.hasOwnProperty("sparseTensorType")&&(jt.sparseTensorType=Tt.onnx.TypeProto.SparseTensor.toObject(Ht.sparseTensorType,Gt),Gt.oneofs&&(jt.value="sparseTensorType")),Ht.optionalType!=null&&Ht.hasOwnProperty("optionalType")&&(jt.optionalType=Tt.onnx.TypeProto.Optional.toObject(Ht.optionalType,Gt),Gt.oneofs&&(jt.value="optionalType")),jt},Ft.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ft.getTypeUrl=function(Ht){return Ht===void 0&&(Ht="type.googleapis.com"),Ht+"/onnx.TypeProto"},Ft.Tensor=function(){function Ht(Gt){if(Gt)for(var jt=Object.keys(Gt),qt=0;qt<jt.length;++qt)Gt[jt[qt]]!=null&&(this[jt[qt]]=Gt[jt[qt]])}return Ht.prototype.elemType=0,Ht.prototype.shape=null,Ht.create=function(Gt){return new Ht(Gt)},Ht.encode=function(Gt,jt){return jt||(jt=wt.create()),Gt.elemType!=null&&Object.hasOwnProperty.call(Gt,"elemType")&&jt.uint32(8).int32(Gt.elemType),Gt.shape!=null&&Object.hasOwnProperty.call(Gt,"shape")&&Tt.onnx.TensorShapeProto.encode(Gt.shape,jt.uint32(18).fork()).ldelim(),jt},Ht.encodeDelimited=function(Gt,jt){return this.encode(Gt,jt).ldelim()},Ht.decode=function(Gt,jt){Gt instanceof vt||(Gt=vt.create(Gt));for(var qt=jt===void 0?Gt.len:Gt.pos+jt,Kt=new Tt.onnx.TypeProto.Tensor;Gt.pos<qt;){var An=Gt.uint32();switch(An>>>3){case 1:{Kt.elemType=Gt.int32();break}case 2:{Kt.shape=Tt.onnx.TensorShapeProto.decode(Gt,Gt.uint32());break}default:Gt.skipType(An&7);break}}return Kt},Ht.decodeDelimited=function(Gt){return Gt instanceof vt||(Gt=new vt(Gt)),this.decode(Gt,Gt.uint32())},Ht.verify=function(Gt){if(typeof Gt!="object"||Gt===null)return"object expected";if(Gt.elemType!=null&&Gt.hasOwnProperty("elemType")&&!$t.isInteger(Gt.elemType))return"elemType: integer expected";if(Gt.shape!=null&&Gt.hasOwnProperty("shape")){var jt=Tt.onnx.TensorShapeProto.verify(Gt.shape);if(jt)return"shape."+jt}return null},Ht.fromObject=function(Gt){if(Gt instanceof Tt.onnx.TypeProto.Tensor)return Gt;var jt=new Tt.onnx.TypeProto.Tensor;if(Gt.elemType!=null&&(jt.elemType=Gt.elemType|0),Gt.shape!=null){if(typeof Gt.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");jt.shape=Tt.onnx.TensorShapeProto.fromObject(Gt.shape)}return jt},Ht.toObject=function(Gt,jt){jt||(jt={});var qt={};return jt.defaults&&(qt.elemType=0,qt.shape=null),Gt.elemType!=null&&Gt.hasOwnProperty("elemType")&&(qt.elemType=Gt.elemType),Gt.shape!=null&&Gt.hasOwnProperty("shape")&&(qt.shape=Tt.onnx.TensorShapeProto.toObject(Gt.shape,jt)),qt},Ht.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ht.getTypeUrl=function(Gt){return Gt===void 0&&(Gt="type.googleapis.com"),Gt+"/onnx.TypeProto.Tensor"},Ht}(),Ft.Sequence=function(){function Ht(Gt){if(Gt)for(var jt=Object.keys(Gt),qt=0;qt<jt.length;++qt)Gt[jt[qt]]!=null&&(this[jt[qt]]=Gt[jt[qt]])}return Ht.prototype.elemType=null,Ht.create=function(Gt){return new Ht(Gt)},Ht.encode=function(Gt,jt){return jt||(jt=wt.create()),Gt.elemType!=null&&Object.hasOwnProperty.call(Gt,"elemType")&&Tt.onnx.TypeProto.encode(Gt.elemType,jt.uint32(10).fork()).ldelim(),jt},Ht.encodeDelimited=function(Gt,jt){return this.encode(Gt,jt).ldelim()},Ht.decode=function(Gt,jt){Gt instanceof vt||(Gt=vt.create(Gt));for(var qt=jt===void 0?Gt.len:Gt.pos+jt,Kt=new Tt.onnx.TypeProto.Sequence;Gt.pos<qt;){var An=Gt.uint32();switch(An>>>3){case 1:{Kt.elemType=Tt.onnx.TypeProto.decode(Gt,Gt.uint32());break}default:Gt.skipType(An&7);break}}return Kt},Ht.decodeDelimited=function(Gt){return Gt instanceof vt||(Gt=new vt(Gt)),this.decode(Gt,Gt.uint32())},Ht.verify=function(Gt){if(typeof Gt!="object"||Gt===null)return"object expected";if(Gt.elemType!=null&&Gt.hasOwnProperty("elemType")){var jt=Tt.onnx.TypeProto.verify(Gt.elemType);if(jt)return"elemType."+jt}return null},Ht.fromObject=function(Gt){if(Gt instanceof Tt.onnx.TypeProto.Sequence)return Gt;var jt=new Tt.onnx.TypeProto.Sequence;if(Gt.elemType!=null){if(typeof Gt.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");jt.elemType=Tt.onnx.TypeProto.fromObject(Gt.elemType)}return jt},Ht.toObject=function(Gt,jt){jt||(jt={});var qt={};return jt.defaults&&(qt.elemType=null),Gt.elemType!=null&&Gt.hasOwnProperty("elemType")&&(qt.elemType=Tt.onnx.TypeProto.toObject(Gt.elemType,jt)),qt},Ht.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ht.getTypeUrl=function(Gt){return Gt===void 0&&(Gt="type.googleapis.com"),Gt+"/onnx.TypeProto.Sequence"},Ht}(),Ft.Map=function(){function Ht(Gt){if(Gt)for(var jt=Object.keys(Gt),qt=0;qt<jt.length;++qt)Gt[jt[qt]]!=null&&(this[jt[qt]]=Gt[jt[qt]])}return Ht.prototype.keyType=0,Ht.prototype.valueType=null,Ht.create=function(Gt){return new Ht(Gt)},Ht.encode=function(Gt,jt){return jt||(jt=wt.create()),Gt.keyType!=null&&Object.hasOwnProperty.call(Gt,"keyType")&&jt.uint32(8).int32(Gt.keyType),Gt.valueType!=null&&Object.hasOwnProperty.call(Gt,"valueType")&&Tt.onnx.TypeProto.encode(Gt.valueType,jt.uint32(18).fork()).ldelim(),jt},Ht.encodeDelimited=function(Gt,jt){return this.encode(Gt,jt).ldelim()},Ht.decode=function(Gt,jt){Gt instanceof vt||(Gt=vt.create(Gt));for(var qt=jt===void 0?Gt.len:Gt.pos+jt,Kt=new Tt.onnx.TypeProto.Map;Gt.pos<qt;){var An=Gt.uint32();switch(An>>>3){case 1:{Kt.keyType=Gt.int32();break}case 2:{Kt.valueType=Tt.onnx.TypeProto.decode(Gt,Gt.uint32());break}default:Gt.skipType(An&7);break}}return Kt},Ht.decodeDelimited=function(Gt){return Gt instanceof vt||(Gt=new vt(Gt)),this.decode(Gt,Gt.uint32())},Ht.verify=function(Gt){if(typeof Gt!="object"||Gt===null)return"object expected";if(Gt.keyType!=null&&Gt.hasOwnProperty("keyType")&&!$t.isInteger(Gt.keyType))return"keyType: integer expected";if(Gt.valueType!=null&&Gt.hasOwnProperty("valueType")){var jt=Tt.onnx.TypeProto.verify(Gt.valueType);if(jt)return"valueType."+jt}return null},Ht.fromObject=function(Gt){if(Gt instanceof Tt.onnx.TypeProto.Map)return Gt;var jt=new Tt.onnx.TypeProto.Map;if(Gt.keyType!=null&&(jt.keyType=Gt.keyType|0),Gt.valueType!=null){if(typeof Gt.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");jt.valueType=Tt.onnx.TypeProto.fromObject(Gt.valueType)}return jt},Ht.toObject=function(Gt,jt){jt||(jt={});var qt={};return jt.defaults&&(qt.keyType=0,qt.valueType=null),Gt.keyType!=null&&Gt.hasOwnProperty("keyType")&&(qt.keyType=Gt.keyType),Gt.valueType!=null&&Gt.hasOwnProperty("valueType")&&(qt.valueType=Tt.onnx.TypeProto.toObject(Gt.valueType,jt)),qt},Ht.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ht.getTypeUrl=function(Gt){return Gt===void 0&&(Gt="type.googleapis.com"),Gt+"/onnx.TypeProto.Map"},Ht}(),Ft.Optional=function(){function Ht(Gt){if(Gt)for(var jt=Object.keys(Gt),qt=0;qt<jt.length;++qt)Gt[jt[qt]]!=null&&(this[jt[qt]]=Gt[jt[qt]])}return Ht.prototype.elemType=null,Ht.create=function(Gt){return new Ht(Gt)},Ht.encode=function(Gt,jt){return jt||(jt=wt.create()),Gt.elemType!=null&&Object.hasOwnProperty.call(Gt,"elemType")&&Tt.onnx.TypeProto.encode(Gt.elemType,jt.uint32(10).fork()).ldelim(),jt},Ht.encodeDelimited=function(Gt,jt){return this.encode(Gt,jt).ldelim()},Ht.decode=function(Gt,jt){Gt instanceof vt||(Gt=vt.create(Gt));for(var qt=jt===void 0?Gt.len:Gt.pos+jt,Kt=new Tt.onnx.TypeProto.Optional;Gt.pos<qt;){var An=Gt.uint32();switch(An>>>3){case 1:{Kt.elemType=Tt.onnx.TypeProto.decode(Gt,Gt.uint32());break}default:Gt.skipType(An&7);break}}return Kt},Ht.decodeDelimited=function(Gt){return Gt instanceof vt||(Gt=new vt(Gt)),this.decode(Gt,Gt.uint32())},Ht.verify=function(Gt){if(typeof Gt!="object"||Gt===null)return"object expected";if(Gt.elemType!=null&&Gt.hasOwnProperty("elemType")){var jt=Tt.onnx.TypeProto.verify(Gt.elemType);if(jt)return"elemType."+jt}return null},Ht.fromObject=function(Gt){if(Gt instanceof Tt.onnx.TypeProto.Optional)return Gt;var jt=new Tt.onnx.TypeProto.Optional;if(Gt.elemType!=null){if(typeof Gt.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");jt.elemType=Tt.onnx.TypeProto.fromObject(Gt.elemType)}return jt},Ht.toObject=function(Gt,jt){jt||(jt={});var qt={};return jt.defaults&&(qt.elemType=null),Gt.elemType!=null&&Gt.hasOwnProperty("elemType")&&(qt.elemType=Tt.onnx.TypeProto.toObject(Gt.elemType,jt)),qt},Ht.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ht.getTypeUrl=function(Gt){return Gt===void 0&&(Gt="type.googleapis.com"),Gt+"/onnx.TypeProto.Optional"},Ht}(),Ft.SparseTensor=function(){function Ht(Gt){if(Gt)for(var jt=Object.keys(Gt),qt=0;qt<jt.length;++qt)Gt[jt[qt]]!=null&&(this[jt[qt]]=Gt[jt[qt]])}return Ht.prototype.elemType=0,Ht.prototype.shape=null,Ht.create=function(Gt){return new Ht(Gt)},Ht.encode=function(Gt,jt){return jt||(jt=wt.create()),Gt.elemType!=null&&Object.hasOwnProperty.call(Gt,"elemType")&&jt.uint32(8).int32(Gt.elemType),Gt.shape!=null&&Object.hasOwnProperty.call(Gt,"shape")&&Tt.onnx.TensorShapeProto.encode(Gt.shape,jt.uint32(18).fork()).ldelim(),jt},Ht.encodeDelimited=function(Gt,jt){return this.encode(Gt,jt).ldelim()},Ht.decode=function(Gt,jt){Gt instanceof vt||(Gt=vt.create(Gt));for(var qt=jt===void 0?Gt.len:Gt.pos+jt,Kt=new Tt.onnx.TypeProto.SparseTensor;Gt.pos<qt;){var An=Gt.uint32();switch(An>>>3){case 1:{Kt.elemType=Gt.int32();break}case 2:{Kt.shape=Tt.onnx.TensorShapeProto.decode(Gt,Gt.uint32());break}default:Gt.skipType(An&7);break}}return Kt},Ht.decodeDelimited=function(Gt){return Gt instanceof vt||(Gt=new vt(Gt)),this.decode(Gt,Gt.uint32())},Ht.verify=function(Gt){if(typeof Gt!="object"||Gt===null)return"object expected";if(Gt.elemType!=null&&Gt.hasOwnProperty("elemType")&&!$t.isInteger(Gt.elemType))return"elemType: integer expected";if(Gt.shape!=null&&Gt.hasOwnProperty("shape")){var jt=Tt.onnx.TensorShapeProto.verify(Gt.shape);if(jt)return"shape."+jt}return null},Ht.fromObject=function(Gt){if(Gt instanceof Tt.onnx.TypeProto.SparseTensor)return Gt;var jt=new Tt.onnx.TypeProto.SparseTensor;if(Gt.elemType!=null&&(jt.elemType=Gt.elemType|0),Gt.shape!=null){if(typeof Gt.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");jt.shape=Tt.onnx.TensorShapeProto.fromObject(Gt.shape)}return jt},Ht.toObject=function(Gt,jt){jt||(jt={});var qt={};return jt.defaults&&(qt.elemType=0,qt.shape=null),Gt.elemType!=null&&Gt.hasOwnProperty("elemType")&&(qt.elemType=Gt.elemType),Gt.shape!=null&&Gt.hasOwnProperty("shape")&&(qt.shape=Tt.onnx.TensorShapeProto.toObject(Gt.shape,jt)),qt},Ht.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ht.getTypeUrl=function(Gt){return Gt===void 0&&(Gt="type.googleapis.com"),Gt+"/onnx.TypeProto.SparseTensor"},Ht}(),Ft}(),Lt.OperatorSetIdProto=function(){function Ft(Ct){if(Ct)for(var Ht=Object.keys(Ct),Gt=0;Gt<Ht.length;++Gt)Ct[Ht[Gt]]!=null&&(this[Ht[Gt]]=Ct[Ht[Gt]])}return Ft.prototype.domain="",Ft.prototype.version=$t.Long?$t.Long.fromBits(0,0,!1):0,Ft.create=function(Ct){return new Ft(Ct)},Ft.encode=function(Ct,Ht){return Ht||(Ht=wt.create()),Ct.domain!=null&&Object.hasOwnProperty.call(Ct,"domain")&&Ht.uint32(10).string(Ct.domain),Ct.version!=null&&Object.hasOwnProperty.call(Ct,"version")&&Ht.uint32(16).int64(Ct.version),Ht},Ft.encodeDelimited=function(Ct,Ht){return this.encode(Ct,Ht).ldelim()},Ft.decode=function(Ct,Ht){Ct instanceof vt||(Ct=vt.create(Ct));for(var Gt=Ht===void 0?Ct.len:Ct.pos+Ht,jt=new Tt.onnx.OperatorSetIdProto;Ct.pos<Gt;){var qt=Ct.uint32();switch(qt>>>3){case 1:{jt.domain=Ct.string();break}case 2:{jt.version=Ct.int64();break}default:Ct.skipType(qt&7);break}}return jt},Ft.decodeDelimited=function(Ct){return Ct instanceof vt||(Ct=new vt(Ct)),this.decode(Ct,Ct.uint32())},Ft.verify=function(Ct){return typeof Ct!="object"||Ct===null?"object expected":Ct.domain!=null&&Ct.hasOwnProperty("domain")&&!$t.isString(Ct.domain)?"domain: string expected":Ct.version!=null&&Ct.hasOwnProperty("version")&&!$t.isInteger(Ct.version)&&!(Ct.version&&$t.isInteger(Ct.version.low)&&$t.isInteger(Ct.version.high))?"version: integer|Long expected":null},Ft.fromObject=function(Ct){if(Ct instanceof Tt.onnx.OperatorSetIdProto)return Ct;var Ht=new Tt.onnx.OperatorSetIdProto;return Ct.domain!=null&&(Ht.domain=String(Ct.domain)),Ct.version!=null&&($t.Long?(Ht.version=$t.Long.fromValue(Ct.version)).unsigned=!1:typeof Ct.version=="string"?Ht.version=parseInt(Ct.version,10):typeof Ct.version=="number"?Ht.version=Ct.version:typeof Ct.version=="object"&&(Ht.version=new $t.LongBits(Ct.version.low>>>0,Ct.version.high>>>0).toNumber())),Ht},Ft.toObject=function(Ct,Ht){Ht||(Ht={});var Gt={};if(Ht.defaults)if(Gt.domain="",$t.Long){var jt=new $t.Long(0,0,!1);Gt.version=Ht.longs===String?jt.toString():Ht.longs===Number?jt.toNumber():jt}else Gt.version=Ht.longs===String?"0":0;return Ct.domain!=null&&Ct.hasOwnProperty("domain")&&(Gt.domain=Ct.domain),Ct.version!=null&&Ct.hasOwnProperty("version")&&(typeof Ct.version=="number"?Gt.version=Ht.longs===String?String(Ct.version):Ct.version:Gt.version=Ht.longs===String?$t.Long.prototype.toString.call(Ct.version):Ht.longs===Number?new $t.LongBits(Ct.version.low>>>0,Ct.version.high>>>0).toNumber():Ct.version),Gt},Ft.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ft.getTypeUrl=function(Ct){return Ct===void 0&&(Ct="type.googleapis.com"),Ct+"/onnx.OperatorSetIdProto"},Ft}(),Lt.OperatorStatus=function(){var Ft={},Ct=Object.create(Ft);return Ct[Ft[0]="EXPERIMENTAL"]=0,Ct[Ft[1]="STABLE"]=1,Ct}(),Lt.FunctionProto=function(){function Ft(Ct){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],Ct)for(var Ht=Object.keys(Ct),Gt=0;Gt<Ht.length;++Gt)Ct[Ht[Gt]]!=null&&(this[Ht[Gt]]=Ct[Ht[Gt]])}return Ft.prototype.name="",Ft.prototype.input=$t.emptyArray,Ft.prototype.output=$t.emptyArray,Ft.prototype.attribute=$t.emptyArray,Ft.prototype.attributeProto=$t.emptyArray,Ft.prototype.node=$t.emptyArray,Ft.prototype.docString="",Ft.prototype.opsetImport=$t.emptyArray,Ft.prototype.domain="",Ft.create=function(Ct){return new Ft(Ct)},Ft.encode=function(Ct,Ht){if(Ht||(Ht=wt.create()),Ct.name!=null&&Object.hasOwnProperty.call(Ct,"name")&&Ht.uint32(10).string(Ct.name),Ct.input!=null&&Ct.input.length)for(var Gt=0;Gt<Ct.input.length;++Gt)Ht.uint32(34).string(Ct.input[Gt]);if(Ct.output!=null&&Ct.output.length)for(var Gt=0;Gt<Ct.output.length;++Gt)Ht.uint32(42).string(Ct.output[Gt]);if(Ct.attribute!=null&&Ct.attribute.length)for(var Gt=0;Gt<Ct.attribute.length;++Gt)Ht.uint32(50).string(Ct.attribute[Gt]);if(Ct.node!=null&&Ct.node.length)for(var Gt=0;Gt<Ct.node.length;++Gt)Tt.onnx.NodeProto.encode(Ct.node[Gt],Ht.uint32(58).fork()).ldelim();if(Ct.docString!=null&&Object.hasOwnProperty.call(Ct,"docString")&&Ht.uint32(66).string(Ct.docString),Ct.opsetImport!=null&&Ct.opsetImport.length)for(var Gt=0;Gt<Ct.opsetImport.length;++Gt)Tt.onnx.OperatorSetIdProto.encode(Ct.opsetImport[Gt],Ht.uint32(74).fork()).ldelim();if(Ct.domain!=null&&Object.hasOwnProperty.call(Ct,"domain")&&Ht.uint32(82).string(Ct.domain),Ct.attributeProto!=null&&Ct.attributeProto.length)for(var Gt=0;Gt<Ct.attributeProto.length;++Gt)Tt.onnx.AttributeProto.encode(Ct.attributeProto[Gt],Ht.uint32(90).fork()).ldelim();return Ht},Ft.encodeDelimited=function(Ct,Ht){return this.encode(Ct,Ht).ldelim()},Ft.decode=function(Ct,Ht){Ct instanceof vt||(Ct=vt.create(Ct));for(var Gt=Ht===void 0?Ct.len:Ct.pos+Ht,jt=new Tt.onnx.FunctionProto;Ct.pos<Gt;){var qt=Ct.uint32();switch(qt>>>3){case 1:{jt.name=Ct.string();break}case 4:{jt.input&&jt.input.length||(jt.input=[]),jt.input.push(Ct.string());break}case 5:{jt.output&&jt.output.length||(jt.output=[]),jt.output.push(Ct.string());break}case 6:{jt.attribute&&jt.attribute.length||(jt.attribute=[]),jt.attribute.push(Ct.string());break}case 11:{jt.attributeProto&&jt.attributeProto.length||(jt.attributeProto=[]),jt.attributeProto.push(Tt.onnx.AttributeProto.decode(Ct,Ct.uint32()));break}case 7:{jt.node&&jt.node.length||(jt.node=[]),jt.node.push(Tt.onnx.NodeProto.decode(Ct,Ct.uint32()));break}case 8:{jt.docString=Ct.string();break}case 9:{jt.opsetImport&&jt.opsetImport.length||(jt.opsetImport=[]),jt.opsetImport.push(Tt.onnx.OperatorSetIdProto.decode(Ct,Ct.uint32()));break}case 10:{jt.domain=Ct.string();break}default:Ct.skipType(qt&7);break}}return jt},Ft.decodeDelimited=function(Ct){return Ct instanceof vt||(Ct=new vt(Ct)),this.decode(Ct,Ct.uint32())},Ft.verify=function(Ct){if(typeof Ct!="object"||Ct===null)return"object expected";if(Ct.name!=null&&Ct.hasOwnProperty("name")&&!$t.isString(Ct.name))return"name: string expected";if(Ct.input!=null&&Ct.hasOwnProperty("input")){if(!Array.isArray(Ct.input))return"input: array expected";for(var Ht=0;Ht<Ct.input.length;++Ht)if(!$t.isString(Ct.input[Ht]))return"input: string[] expected"}if(Ct.output!=null&&Ct.hasOwnProperty("output")){if(!Array.isArray(Ct.output))return"output: array expected";for(var Ht=0;Ht<Ct.output.length;++Ht)if(!$t.isString(Ct.output[Ht]))return"output: string[] expected"}if(Ct.attribute!=null&&Ct.hasOwnProperty("attribute")){if(!Array.isArray(Ct.attribute))return"attribute: array expected";for(var Ht=0;Ht<Ct.attribute.length;++Ht)if(!$t.isString(Ct.attribute[Ht]))return"attribute: string[] expected"}if(Ct.attributeProto!=null&&Ct.hasOwnProperty("attributeProto")){if(!Array.isArray(Ct.attributeProto))return"attributeProto: array expected";for(var Ht=0;Ht<Ct.attributeProto.length;++Ht){var Gt=Tt.onnx.AttributeProto.verify(Ct.attributeProto[Ht]);if(Gt)return"attributeProto."+Gt}}if(Ct.node!=null&&Ct.hasOwnProperty("node")){if(!Array.isArray(Ct.node))return"node: array expected";for(var Ht=0;Ht<Ct.node.length;++Ht){var Gt=Tt.onnx.NodeProto.verify(Ct.node[Ht]);if(Gt)return"node."+Gt}}if(Ct.docString!=null&&Ct.hasOwnProperty("docString")&&!$t.isString(Ct.docString))return"docString: string expected";if(Ct.opsetImport!=null&&Ct.hasOwnProperty("opsetImport")){if(!Array.isArray(Ct.opsetImport))return"opsetImport: array expected";for(var Ht=0;Ht<Ct.opsetImport.length;++Ht){var Gt=Tt.onnx.OperatorSetIdProto.verify(Ct.opsetImport[Ht]);if(Gt)return"opsetImport."+Gt}}return Ct.domain!=null&&Ct.hasOwnProperty("domain")&&!$t.isString(Ct.domain)?"domain: string expected":null},Ft.fromObject=function(Ct){if(Ct instanceof Tt.onnx.FunctionProto)return Ct;var Ht=new Tt.onnx.FunctionProto;if(Ct.name!=null&&(Ht.name=String(Ct.name)),Ct.input){if(!Array.isArray(Ct.input))throw TypeError(".onnx.FunctionProto.input: array expected");Ht.input=[];for(var Gt=0;Gt<Ct.input.length;++Gt)Ht.input[Gt]=String(Ct.input[Gt])}if(Ct.output){if(!Array.isArray(Ct.output))throw TypeError(".onnx.FunctionProto.output: array expected");Ht.output=[];for(var Gt=0;Gt<Ct.output.length;++Gt)Ht.output[Gt]=String(Ct.output[Gt])}if(Ct.attribute){if(!Array.isArray(Ct.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");Ht.attribute=[];for(var Gt=0;Gt<Ct.attribute.length;++Gt)Ht.attribute[Gt]=String(Ct.attribute[Gt])}if(Ct.attributeProto){if(!Array.isArray(Ct.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");Ht.attributeProto=[];for(var Gt=0;Gt<Ct.attributeProto.length;++Gt){if(typeof Ct.attributeProto[Gt]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");Ht.attributeProto[Gt]=Tt.onnx.AttributeProto.fromObject(Ct.attributeProto[Gt])}}if(Ct.node){if(!Array.isArray(Ct.node))throw TypeError(".onnx.FunctionProto.node: array expected");Ht.node=[];for(var Gt=0;Gt<Ct.node.length;++Gt){if(typeof Ct.node[Gt]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");Ht.node[Gt]=Tt.onnx.NodeProto.fromObject(Ct.node[Gt])}}if(Ct.docString!=null&&(Ht.docString=String(Ct.docString)),Ct.opsetImport){if(!Array.isArray(Ct.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");Ht.opsetImport=[];for(var Gt=0;Gt<Ct.opsetImport.length;++Gt){if(typeof Ct.opsetImport[Gt]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");Ht.opsetImport[Gt]=Tt.onnx.OperatorSetIdProto.fromObject(Ct.opsetImport[Gt])}}return Ct.domain!=null&&(Ht.domain=String(Ct.domain)),Ht},Ft.toObject=function(Ct,Ht){Ht||(Ht={});var Gt={};if((Ht.arrays||Ht.defaults)&&(Gt.input=[],Gt.output=[],Gt.attribute=[],Gt.node=[],Gt.opsetImport=[],Gt.attributeProto=[]),Ht.defaults&&(Gt.name="",Gt.docString="",Gt.domain=""),Ct.name!=null&&Ct.hasOwnProperty("name")&&(Gt.name=Ct.name),Ct.input&&Ct.input.length){Gt.input=[];for(var jt=0;jt<Ct.input.length;++jt)Gt.input[jt]=Ct.input[jt]}if(Ct.output&&Ct.output.length){Gt.output=[];for(var jt=0;jt<Ct.output.length;++jt)Gt.output[jt]=Ct.output[jt]}if(Ct.attribute&&Ct.attribute.length){Gt.attribute=[];for(var jt=0;jt<Ct.attribute.length;++jt)Gt.attribute[jt]=Ct.attribute[jt]}if(Ct.node&&Ct.node.length){Gt.node=[];for(var jt=0;jt<Ct.node.length;++jt)Gt.node[jt]=Tt.onnx.NodeProto.toObject(Ct.node[jt],Ht)}if(Ct.docString!=null&&Ct.hasOwnProperty("docString")&&(Gt.docString=Ct.docString),Ct.opsetImport&&Ct.opsetImport.length){Gt.opsetImport=[];for(var jt=0;jt<Ct.opsetImport.length;++jt)Gt.opsetImport[jt]=Tt.onnx.OperatorSetIdProto.toObject(Ct.opsetImport[jt],Ht)}if(Ct.domain!=null&&Ct.hasOwnProperty("domain")&&(Gt.domain=Ct.domain),Ct.attributeProto&&Ct.attributeProto.length){Gt.attributeProto=[];for(var jt=0;jt<Ct.attributeProto.length;++jt)Gt.attributeProto[jt]=Tt.onnx.AttributeProto.toObject(Ct.attributeProto[jt],Ht)}return Gt},Ft.prototype.toJSON=function(){return this.constructor.toObject(this,pt.util.toJSONOptions)},Ft.getTypeUrl=function(Ct){return Ct===void 0&&(Ct="type.googleapis.com"),Ct+"/onnx.FunctionProto"},Ft}(),Lt}(),at.exports=Tt});function Fr(st,at){if(!st)throw new Error(typeof at=="string"?at:at())}function sn$1(st){return new TextDecoder().decode(st)}var ye$1,hr$1,pi$1,Ze$1,jn$1,We$1,it,U$1,an$1,mr$1,br,gr$1,fe$1=L(()=>{zn$1(),Zo(),ye$1=Ar(Cr()),yr(),hr$1=class{static arraysEqual(st,at){if(st.length!==at.length)return!1;for(let pt=0;pt<st.length;pt++)if(st[pt]!==at[pt])return!1;return!0}},pi$1=class{static preprocessInputShapes(st,at){let pt=st.length===1?[1,st[0]]:st,vt=at.length===1?[at[0],1]:at;return[pt,vt]}static postprocessOutputShape(st,at,pt){at===1&&st.splice(st.length-2,1),pt===1&&st.pop()}static calcMatMulShape(st,at){return st[1]!==at[0]?void 0:[st[0],at[1]]}},Ze$1=class y${static calcShape(at,pt,vt=!1){let wt=at.length,$t=pt.length;if(wt===0)return pt;if($t===0)return at;let Tt=Math.max(at.length,pt.length),Lt=new Array(Tt);if(vt){if(wt<2||$t<2)return;let Ft=pi$1.calcMatMulShape([at[wt-2],at[wt-1]],[pt[$t-2],pt[$t-1]]);if(Ft===void 0)return;[Lt[Tt-2],Lt[Tt-1]]=Ft}for(let Ft=vt?3:1;Ft<=Tt;Ft++){let Ct=wt-Ft<0?1:at[wt-Ft],Ht=$t-Ft<0?1:pt[$t-Ft];if(Ct!==Ht&&Ct>1&&Ht>1)return;Lt[Tt-Ft]=Math.max(Ct,Ht)}return Lt}static index(at,pt){let vt=new Array(pt.length);return y$.fillIndex(at,pt,vt),vt}static fillIndex(at,pt,vt){let wt=at.length-pt.length;for(let $t=0;$t<pt.length;$t++)vt[$t]=at[wt+$t]%pt[$t]}static calc(at,pt,vt,wt,$t){let Tt=y$.calcShape(at.dims,pt.dims);if(Tt){if(wt&&!U$1.areEqual(Tt,at.dims))return;let Lt=U$1.size(Tt),Ft=wt?at:new $e(Tt,$t||at.type);if(Tt.length===0)Ft.set([],vt(at.get([]),pt.get([])));else{let Ct=new Array(Tt.length),Ht=new Array(at.dims.length),Gt=new Array(pt.dims.length),jt=0,qt=0,Kt=!1,An=!1;at.dims.length===0&&(jt=at.get([]),Kt=!0),pt.dims.length===0&&(qt=pt.get([]),An=!0);let Sn;for(let wn=0;wn<Lt;wn++){Sn=wn;for(let In=Tt.length-1;In>=0;In--)Ct[In]=Sn%Tt[In],Sn=Math.floor(Sn/Tt[In]);Kt||(y$.fillIndex(Ct,at.dims,Ht),jt=at.get(Ht)),An||(y$.fillIndex(Ct,pt.dims,Gt),qt=pt.get(Gt)),Ft.set(Ct,vt(jt,qt))}}return Ft}}static isValidBroadcast(at,pt){let vt=at.length,wt=pt.length;if(vt>wt)return!1;for(let $t=1;$t<=vt;$t++)if(at[vt-$t]!==1&&at[vt-$t]!==pt[wt-$t])return!1;return!0}static getBroadcastDims(at,pt){let vt=at.length,wt=[];for(let $t=0;$t<vt;$t++){let Tt=vt-1-$t,Lt=at[Tt]||1;(pt[pt.length-1-$t]||1)>1&&Lt===1&&wt.unshift(Tt)}return wt}},jn$1=class{static getShapeOfGemmResult(st,at,pt,vt,wt){if(st.length!==2||pt.length!==2)throw new Error("shape need to be of size 2");let $t,Tt,Lt;at?($t=st[1],Tt=st[0]):($t=st[0],Tt=st[1]);let Ft=-1;if(vt?(Lt=pt[0],Ft=1):(Lt=pt[1],Ft=0),pt[Ft]!==Tt)throw new Error("dimension mismatch");if($t<=0||Lt<=0||Tt<=0)throw new Error("invalid shape specified");if(wt&&!Ze$1.isValidBroadcast(wt,[$t,Lt]))throw new Error("gemm: invalid bias shape for broadcast");return[$t,Lt,Tt]}},We$1=class YS{static tensorDataTypeFromProto(at){switch(at){case ye$1.onnx.TensorProto.DataType.INT8:return"int8";case ye$1.onnx.TensorProto.DataType.UINT8:return"uint8";case ye$1.onnx.TensorProto.DataType.BOOL:return"bool";case ye$1.onnx.TensorProto.DataType.INT16:return"int16";case ye$1.onnx.TensorProto.DataType.UINT16:return"uint16";case ye$1.onnx.TensorProto.DataType.INT32:return"int32";case ye$1.onnx.TensorProto.DataType.UINT32:return"uint32";case ye$1.onnx.TensorProto.DataType.FLOAT:return"float32";case ye$1.onnx.TensorProto.DataType.DOUBLE:return"float64";case ye$1.onnx.TensorProto.DataType.STRING:return"string";case ye$1.onnx.TensorProto.DataType.INT64:return"int32";case ye$1.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${ye$1.onnx.TensorProto.DataType[at]}`)}}static tensorDataTypeStringToEnum(at){switch(at){case"int8":return ye$1.onnx.TensorProto.DataType.INT8;case"uint8":return ye$1.onnx.TensorProto.DataType.UINT8;case"bool":return ye$1.onnx.TensorProto.DataType.BOOL;case"int16":return ye$1.onnx.TensorProto.DataType.INT16;case"uint16":return ye$1.onnx.TensorProto.DataType.UINT16;case"int32":return ye$1.onnx.TensorProto.DataType.INT32;case"uint32":return ye$1.onnx.TensorProto.DataType.UINT32;case"float32":return ye$1.onnx.TensorProto.DataType.FLOAT;case"float64":return ye$1.onnx.TensorProto.DataType.DOUBLE;case"string":return ye$1.onnx.TensorProto.DataType.STRING;case"int64":return ye$1.onnx.TensorProto.DataType.INT64;case"uint64":return ye$1.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${at}`)}}static tensorDimsFromProto(at){return at.map(pt=>Vt.isLong(pt)?pt.toNumber():pt)}static tensorValueTypeFromProto(at){return{tensorType:YS.tensorDataTypeFromProto(at.elemType),shape:{dims:YS.tensorDimsFromProto(at.shape.dim.map(pt=>pt.dimValue))}}}static tensorDimsFromORTFormat(at){let pt=[];for(let vt=0;vt<at.dimsLength();vt++)pt.push(it.longToNumber(at.dims(vt)));return pt}static tensorAttributesFromORTFormat(at){let pt=[];for(let vt=0;vt<at.attributesLength();vt++)pt.push(at.attributes(vt));return pt}},it=class{static longToNumber(st,at){return Vt.isLong(st)?st.toNumber():st instanceof _.Long?Vt.fromValue({low:st.low,high:st.high,unsigned:at??!1}).toNumber():st}static isLong(st){return Vt.isLong(st)||st instanceof _.Long}},U$1=class Pw{static size(at){return Pw.getSizeFromDimensionRange(at,0,at.length)}static sizeFromDimension(at,pt){if(pt<0||pt>at.length)throw new Error(`invalid dimension of ${pt} for sizeFromDimension as Tensor has ${at.length} dimensions.`);return Pw.getSizeFromDimensionRange(at,pt,at.length)}static sizeToDimension(at,pt){if(pt<0||pt>at.length)throw new Error(`invalid dimension of ${pt} for sizeToDimension as Tensor has ${at.length} dimensions.`);return Pw.getSizeFromDimensionRange(at,0,pt)}static getSizeFromDimensionRange(at,pt,vt){let wt=1;for(let $t=pt;$t<vt;$t++){if(at[$t]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");wt*=at[$t]}return wt}static computeStrides(at){let pt=at.length;if(pt===0)return[];if(pt===1)return[1];let vt=new Array(pt);vt[pt-1]=1,vt[pt-2]=at[pt-1];for(let wt=pt-3;wt>=0;--wt)vt[wt]=vt[wt+1]*at[wt+1];return vt}static transpose(at){return at.slice().reverse()}static indicesToOffset(at,pt,vt){vt===void 0&&(vt=at.length);let wt=0;for(let $t=0;$t<vt;++$t)wt+=pt[$t]*at[$t];return wt}static offsetToIndices(at,pt){let vt=pt.length;if(vt===0)return[];if(vt===1)return[at*pt[0]];let wt=new Array(pt.length);for(let $t=0;$t<wt.length-1;++$t)wt[$t]=Math.floor(at/pt[$t]),at-=wt[$t]*pt[$t];return wt[wt.length-1]=at,wt}static normalizeAxis(at,pt){if(at<-pt&&at>=pt)throw new Error("unsupported axis for this operation.");return at<0?at+pt:at}static normalizeAxes(at,pt){return at.map(vt=>this.normalizeAxis(vt,pt))}static incrementIndex(at,pt,vt){if(pt.length===0||at.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(vt===void 0)vt=pt.length;else if(vt<=0||vt>pt.length)throw new Error("Incorrect axis to increment on");for(let wt=vt-1;wt>=0&&(at[wt]++,!(at[wt]<pt[wt]));--wt)at[wt]=0}static calculateReshapedDims(at,pt){if(pt.length===0){if(at.length===0||Pw.size(at)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let vt=pt.length,wt=new Array(vt),$t=-1,Tt=1;for(let Ft=0;Ft<vt;Ft++){if(pt[Ft]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(pt[Ft]===-1){if($t!==-1)throw new Error("at most one dimension in shape hints can be -1");$t=Ft}else{if(pt[Ft]===0){if(Ft>=at.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");wt[Ft]=at[Ft]}else wt[Ft]=pt[Ft];Tt*=wt[Ft]}}let Lt=Pw.size(at);if($t!==-1){if(Lt%Tt!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${at}] Output shape: [${pt}]`);wt[$t]=Lt/Tt}else if(Tt!==Lt)throw new Error("reshapedDims and originalDims don't have matching sizes");return wt}static sortBasedOnPerm(at,pt){return pt?pt.map(vt=>at[vt]):at.slice().reverse()}static padShape(at,pt){let vt=at.length;return at.map((wt,$t)=>wt+pt[$t]+pt[$t+vt])}static areEqual(at,pt){return at.length!==pt.length?!1:at.every((vt,wt)=>vt===pt[wt])}static validateDimsAndCalcSize(at){if(at.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let pt=1;for(let vt of at){if(!Number.isInteger(vt))throw new TypeError(`Invalid shape: ${vt} is not an integer`);if(vt<0||vt>2147483647)throw new TypeError(`Invalid shape: length ${vt} is not allowed`);pt*=vt}return pt}static flattenShape(at,pt){pt<0&&(pt+=at.length);let vt=at.reduce(($t,Tt)=>$t*Tt,1),wt=at.slice(pt).reduce(($t,Tt)=>$t*Tt,1);return[vt/wt,wt]}static squeezeShape(at,pt){let vt=new Array;pt=Pw.normalizeAxes(pt,at.length);for(let wt=0;wt<at.length;wt++){let $t=pt.indexOf(wt)>=0;if($t&&at[wt]!==1)throw new Error("squeeze an axis of size different than 1");(pt.length===0&&at[wt]>1||pt.length>0&&!$t)&&vt.push(at[wt])}return vt}static unsqueezeShape(at,pt){let vt=new Array(at.length+pt.length);vt.fill(0);for(let $t=0;$t<pt.length;$t++){let Tt=Pw.normalizeAxis(pt[$t],vt.length);if(Tt>=vt.length)throw new Error("'axes' has an out of range axis");if(vt[Tt]!==0)throw new Error("'axes' has a duplicate axis");vt[Tt]=1}let wt=0;for(let $t=0;$t<vt.length;$t++)vt[$t]===0&&(vt[$t]=at[wt++]);if(wt!==at.length)throw new Error("the unsqueezed dimension could not be established");return vt}},an$1=class KE{static splitShape(at,pt,vt,wt){if(vt.length===0){if(!wt)throw new Error("need to know number of outputs when the 'split' attribute is not specified");KE.determineSplit(at[pt],wt,vt)}let $t=[],Tt=[0];for(let Lt=0;Lt<vt.length;++Lt){Lt!==0&&Tt.push(Tt[Lt-1]+vt[Lt-1]);let Ft=at.slice();Ft[pt]=vt[Lt],$t.push(Ft)}return[$t,Tt]}static determineSplit(at,pt,vt){if(at%pt!==0)throw new Error("cannot split tensor to equal sized parts");for(let wt=0;wt<pt;++wt)vt.push(at/pt)}},mr$1=class v${static adjustPoolAttributes(at,pt,vt,wt,$t,Tt){if(!at&&vt.length!==pt.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(at)for(let Lt=0;Lt<pt.length-2;Lt++)Lt>=vt.length?vt.push(pt[Lt+2]):vt[Lt]=pt[Lt+2];for(let Lt=0;Lt<vt.length;Lt++)if(Lt<wt.length){if(wt[Lt]<0)throw new Error("strides should be greater than or equal to 1")}else wt.push(1);for(let Lt=0;Lt<vt.length;Lt++)if(Lt<$t.length){if($t[Lt]<0)throw new Error("dilations should be greater than or equal to 1")}else $t.push(1);for(let Lt=0;Lt<vt.length*2;Lt++)if(Lt<Tt.length){if(Tt[Lt]<0)throw new Error("pad should be greater than or equal to 1")}else Tt.push(0);for(let Lt=0;Lt<vt.length;Lt++){if(vt[Lt]<=0)throw new Error("kernel shapes need to be greater than 0");if(Tt[Lt]>=vt[Lt]||Tt[Lt+vt.length]>=vt[Lt])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(at,pt,vt,wt,$t,Tt){if(Tt){if($t.length!==2*(at.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(pt.length!==at.length-2)throw new Error("length of strides should be the length of data dimensions");if(wt.length!==at.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let Lt=0;Lt<at.length-2;Lt++)v$.adjustPadAndReturnShape(at[Lt+2],pt[Lt],vt[Lt],wt[Lt],$t,Lt,Lt+at.length-2,Tt)}}static computePoolOutputShape(at,pt,vt,wt,$t,Tt,Lt){if(pt.length<=0)throw new Error("input shape must be of size greater than 0");let Ft=[pt[0],pt[1]];return v$.computeShapeHelper(at,pt,Ft,vt,wt,$t,Tt,Lt),Ft}static computeConvOutputShape(at,pt,vt,wt,$t,Tt,Lt){if(at.length<=0||pt.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let Ft=[at[0],pt[0]];return v$.computeShapeHelper(!1,at,Ft,vt,wt,$t,Tt,Lt),Ft}static computeShapeHelper(at,pt,vt,wt,$t,Tt,Lt,Ft){if(at)for(let Ct=0;Ct<pt.length-2;Ct++)vt.push(1);else for(let Ct=0;Ct<pt.length-2;Ct++)vt.push(v$.adjustPadAndReturnShape(pt[Ct+2],wt[Ct],$t[Ct],Tt[Ct],Lt,Ct,Ct+pt.length-2,Ft))}static adjustPadAndReturnShape(at,pt,vt,wt,$t,Tt,Lt,Ft){let Ct=vt*(wt-1)+1;if(Ft&&Ft!=="NOTSET")switch(Ft){case"VALID":return $t[Tt]=0,$t[Lt]=0,Math.floor((at-Ct)/pt+1);case"SAME_LOWER":case"SAME_UPPER":if(vt!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let Ht=((at+pt-1)/pt-1)*pt+wt-at;return $t[Tt]=Math.floor(Ft==="SAME_LOWER"?(Ht+1)/2:Ht/2),$t[Lt]=Ht-$t[Tt],Math.floor((at+Ht-wt)/pt+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((at+$t[Tt]+$t[Lt]-Ct)/pt+1)}},br=-34028234663852886e22,gr$1=34028234663852886e22});function Hd$1(st){switch(st){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${st}`)}}function Fu$1(st){switch(st){case ne.onnx.TensorProto.DataType.UINT8:case ne.onnx.TensorProto.DataType.INT8:case ne.onnx.TensorProto.DataType.BOOL:return 1;case ne.onnx.TensorProto.DataType.UINT16:case ne.onnx.TensorProto.DataType.INT16:return 2;case ne.onnx.TensorProto.DataType.FLOAT:case ne.onnx.TensorProto.DataType.INT32:case ne.onnx.TensorProto.DataType.UINT32:return 4;case ne.onnx.TensorProto.DataType.INT64:case ne.onnx.TensorProto.DataType.DOUBLE:case ne.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${ne.onnx.TensorProto.DataType[st]}`)}}function qd$1(st,at){return new(Bu$1(at))(st)}function Bu$1(st){switch(st){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function hi$1(st,at){if(at===ne.onnx.TensorProto.DataType.INT64||at===di$1.TensorDataType.INT64){if(st.greaterThanOrEqual(2147483648)||st.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(at===ne.onnx.TensorProto.DataType.UINT32||at===di$1.TensorDataType.UINT32||at===ne.onnx.TensorProto.DataType.UINT64||at===di$1.TensorDataType.UINT64){if(st.greaterThanOrEqual(4294967296)||st.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${ne.onnx.TensorProto.DataType[at]}`);return st.toNumber()}function $u$1(st,at,pt){switch(at){case ne.onnx.TensorProto.DataType.BOOL:case ne.onnx.TensorProto.DataType.UINT8:return st.getUint8(pt);case ne.onnx.TensorProto.DataType.INT8:return st.getInt8(pt);case ne.onnx.TensorProto.DataType.UINT16:return st.getUint16(pt,!0);case ne.onnx.TensorProto.DataType.INT16:return st.getInt16(pt,!0);case ne.onnx.TensorProto.DataType.FLOAT:return st.getFloat32(pt,!0);case ne.onnx.TensorProto.DataType.INT32:return st.getInt32(pt,!0);case ne.onnx.TensorProto.DataType.UINT32:return st.getUint32(pt,!0);case ne.onnx.TensorProto.DataType.INT64:return hi$1(Vt.fromBits(st.getUint32(pt,!0),st.getUint32(pt+4,!0),!1),at);case ne.onnx.TensorProto.DataType.DOUBLE:return st.getFloat64(pt,!0);case ne.onnx.TensorProto.DataType.UINT64:return hi$1(Vt.fromBits(st.getUint32(pt,!0),st.getUint32(pt+4,!0),!0),at);default:throw new Error(`cannot read from DataView for type ${ne.onnx.TensorProto.DataType[at]}`)}}var ku$1,ne,di$1,$e,yr=L(()=>{ku$1=Ar(Os$1()),Zo(),tn$1(),ne=Ar(Cr()),fe$1(),di$1=V.experimental.fbs,$e=class yS{constructor(at,pt,vt,wt,$t,Tt=ku$1.Guid.create()){this.dims=at,this.type=pt,this.dataProvider=vt,this.asyncDataProvider=wt,this.cache=$t,this.dataId=Tt,this.size=U$1.validateDimsAndCalcSize(at);let Lt=this.size,Ft=vt===void 0&&wt===void 0&&$t===void 0;if($t!==void 0&&$t.length!==Lt)throw new RangeError("Input dims doesn't match data length.");if(pt==="string"){if($t!==void 0&&(!Array.isArray($t)||!$t.every(Ct=>typeof Ct=="string")))throw new TypeError("cache should be a string array");Ft&&(this.cache=new Array(Lt))}else{if($t!==void 0){let Ct=Bu$1(pt);if(!($t instanceof Ct))throw new TypeError(`cache should be type ${Ct.name}`)}if(Ft){let Ct=new ArrayBuffer(Lt*Hd$1(pt));this.cache=qd$1(Ct,pt)}}}get data(){if(this.cache===void 0){let at=this.dataProvider(this.dataId);if(at.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=at}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(at){return this.data[U$1.indicesToOffset(at,this.strides)]}set(at,pt){this.data[U$1.indicesToOffset(at,this.strides)]=pt}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=U$1.computeStrides(this.dims)),this._strides}static fromProto(at){if(!at)throw new Error("cannot construct Value from an empty tensor");let pt=We$1.tensorDataTypeFromProto(at.dataType),vt=We$1.tensorDimsFromProto(at.dims),wt=new yS(vt,pt);if(pt==="string")at.stringData.forEach(($t,Tt)=>{wt.data[Tt]=sn$1($t)});else if(at.rawData&&typeof at.rawData.byteLength=="number"&&at.rawData.byteLength>0){let $t=wt.data,Tt=new DataView(at.rawData.buffer,at.rawData.byteOffset,at.rawData.byteLength),Lt=Fu$1(at.dataType),Ft=at.rawData.byteLength/Lt;if(at.rawData.byteLength%Lt!==0)throw new Error("invalid buffer length");if($t.length!==Ft)throw new Error("buffer length mismatch");for(let Ct=0;Ct<Ft;Ct++){let Ht=$u$1(Tt,at.dataType,Ct*Lt);$t[Ct]=Ht}}else{let $t;switch(at.dataType){case ne.onnx.TensorProto.DataType.FLOAT:$t=at.floatData;break;case ne.onnx.TensorProto.DataType.INT32:case ne.onnx.TensorProto.DataType.INT16:case ne.onnx.TensorProto.DataType.UINT16:case ne.onnx.TensorProto.DataType.INT8:case ne.onnx.TensorProto.DataType.UINT8:case ne.onnx.TensorProto.DataType.BOOL:$t=at.int32Data;break;case ne.onnx.TensorProto.DataType.INT64:$t=at.int64Data;break;case ne.onnx.TensorProto.DataType.DOUBLE:$t=at.doubleData;break;case ne.onnx.TensorProto.DataType.UINT32:case ne.onnx.TensorProto.DataType.UINT64:$t=at.uint64Data;break;default:throw new Error("unspecific error")}if($t==null)throw new Error("failed to populate data from a tensorproto value");let Tt=wt.data;if(Tt.length!==$t.length)throw new Error("array length mismatch");for(let Lt=0;Lt<$t.length;Lt++){let Ft=$t[Lt];Vt.isLong(Ft)?Tt[Lt]=hi$1(Ft,at.dataType):Tt[Lt]=Ft}}return wt}static fromData(at,pt,vt){return new yS(pt,vt,void 0,void 0,at)}static fromOrtTensor(at){if(!at)throw new Error("cannot construct Value from an empty tensor");let pt=We$1.tensorDimsFromORTFormat(at),vt=We$1.tensorDataTypeFromProto(at.dataType()),wt=new yS(pt,vt);if(vt==="string")for(let $t=0;$t<at.stringDataLength();$t++)wt.data[$t]=at.stringData($t);else if(at.rawDataArray()&&typeof at.rawDataLength()=="number"&&at.rawDataLength()>0){let $t=wt.data,Tt=new DataView(at.rawDataArray().buffer,at.rawDataArray().byteOffset,at.rawDataLength()),Lt=Fu$1(at.dataType()),Ft=at.rawDataLength()/Lt;if(at.rawDataLength()%Lt!==0)throw new Error("invalid buffer length");if($t.length!==Ft)throw new Error("buffer length mismatch");for(let Ct=0;Ct<Ft;Ct++){let Ht=$u$1(Tt,at.dataType(),Ct*Lt);$t[Ct]=Ht}}return wt}}});function H(st){return st===1?jd$1:Yd$1}function Nu$1(st){let at=H(st);return`${at.version}
      precision highp float;
      ${at.attribute} vec3 position;
      ${at.attribute} vec2 textureCoord;

      ${at.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`}function Ru$1(st){let at=H(st);return`${at.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${at.varyingFrag} vec2 TexCoords;
    ${at.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `}function Mu$1(st,at){let pt=H(st);return`
  void main() {
    int indices[${at}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${pt.output} = result;
  }
  `}var jd$1,Yd$1,we$1=L(()=>{jd$1={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},Yd$1={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}}),ae=L(()=>{});async function mi$1(st,at=vt=>0,pt){return new Promise((vt,wt)=>{let $t=0,Tt=()=>{if(st()){vt();return}$t++;let Lt=at($t);setTimeout(Tt,Lt)};Tt()})}function Yn$1(st){return Fr(typeof st<"u"&&st.length!==0,()=>"empty string found for sampler name"),"get"+st.charAt(0).toUpperCase()+st.slice(1)}function Gu$1(st){return Fr(typeof st<"u"&&st.length!==0,()=>"empty string found for sampler name"),"get"+st.charAt(0).toUpperCase()+st.slice(1)+"AtOutCoords"}function $r(st,at){let pt=JSON.parse(JSON.stringify(st));return pt=at,pt}function kr$1(st,at){return at.map(pt=>st[pt]).join(", ")}function Qe(st){if(st<=1)return"int";if(st===2)return"ivec2";if(st===3)return"ivec3";if(st===4)return"ivec4";if(st===5)return"ivec5";if(st===6)return"ivec6";throw Error(`GPU for rank ${st} is not yet supported`)}function Dt$1(st=6){return["x","y","z","w","u","v"].slice(0,st)}var Bt$1=L(()=>{fe$1()});function Xd$1(st,at){return Dt$1(at).map(pt=>`${st}.${pt}`)}function Br$1(st,at){return at===1?[st]:Xd$1(st,at)}function Nt(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}var Tr=L(()=>{Bt$1()});function Jd(st,at,pt){if(st===0)return"false";if(st===1)return`rc > ${at[0]}`;let vt="";for(let wt=st-2;wt<st;wt++)vt+=`${pt[wt]} >= ${at[wt-st+2]}`,wt<st-1&&(vt+="||");return vt}function Zd(st,at){let pt=st.length;if(pt===0)return"getA(), 0, 0, 0";if(pt===1)return`getA(rc),
            rc + 1 >= ${st[0]} ? 0. : getA(rc + 1),
            0, 0`;let vt="r, c",wt="r, cp1",$t="rp1, c",Tt="rp1, cp1",Lt="";if(pt>2)for(let Ft=0;Ft<pt-2;++Ft)Lt=Lt+`${at[Ft]},`;return`getA(${Lt}${vt}),
          rEdge ? 0. : getA(${Lt}${$t}),
          cEdge ? 0. : getA(${Lt}${wt}),
          rEdge || cEdge ? 0. : getA(${Lt}${Tt})`}function Qd(st,at,pt,vt){return st===0||st===1?"":`
    int r = ${at[st-2]};
    int c = ${at[st-1]};
    int rp1 = ${at[st-2]} + 1;
    int cp1 = ${at[st-1]} + 1;
    bool rEdge = rp1 >= ${vt};
    bool cEdge = cp1 >= ${pt};
    `}var Uu$1,Kd$1,zu$1,Vu$1=L(()=>{we$1(),ae(),Bt$1(),Tr(),Uu$1={name:"pack",inputNames:["A"],inputTypes:[1]},Kd$1=(st,at)=>{let pt=H(st.session.backend.glContext.version),vt=at.dims,wt=vt.length,$t=at.dims.length,Tt=Qe($t),Lt=Br$1("rc",$t),Ft=Qd($t,Lt,vt[vt.length-2],vt[vt.length-1]),Ct;wt===0?Ct=[1,1]:wt===1?Ct=[vt[0],1]:Ct=[vt[$t-1],vt[$t-2]];let Ht=Jd($t,Ct,Lt),Gt=Zd(vt,Lt),jt=`
        void main() {
          ${Tt} rc = getOutputCoords();

          if(${Ht}) {
            ${pt.output} = vec4(0);
          } else {
            ${Ft}

            ${pt.output} = vec4(${Gt});
          }
        }
      `;return{...Uu$1,hasMain:!0,output:{dims:at.dims,type:at.type,textureType:2},shaderSource:jt}},zu$1=(st,at)=>({...Uu$1,get:()=>Kd$1(st,at)})});function bi(st){if(st.length===0)return[1,1,1];let at=1;for(let pt=0;pt<st.length-2;++pt)at*=st[pt];return[at,st.length>1?st[st.length-2]:1,st[st.length-1]]}function Hu$1(st,at){let pt=!1;return st.length===0||at.length===0?pt=!0:st.length<2||at.length<2?pt=st[st.length-1]===at[at.length-1]:pt=st[st.length-1]===at[at.length-1]&&st[st.length-2]===at[at.length-2],pt}function rh(st){let at=U$1.computeStrides(st),pt=["b","r","c"],vt="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${at.map((wt,$t)=>{let Tt=`int ${pt[$t]} = ${vt} / ${wt}`,Lt=$t===at.length-1?`int ${pt[$t+1]} = ${vt} - ${pt[$t]} * ${wt}`:`index -= ${pt[$t]} * ${wt}`;return`${Tt}; ${Lt};`}).join("")}
      return ivec3(b, r, c);
    }
  `}function nh(st){let at=U$1.computeStrides(st);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${at[0]} + coords.z * ${at[1]} + coords.y;
  }
`}var eh,th,Wu$1,qu$1=L(()=>{fe$1(),we$1(),ae(),Tr(),eh=st=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${st}`}),th=(st,at,pt,vt)=>{let wt=at.dims,$t=vt,Tt="";for(let Ct=0;Ct<4;Ct++){let Ht="";switch(Ct){case 0:Ht="outputCoords = rc;";break;case 1:Ht="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:Ht="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:Ht="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}Tt+=`
        ${Ht}
        ${Ct>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${Ct}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${Ct>0?"}":""}
      `}let Lt=H(st.session.backend.glContext.version),Ft=`
      ${rh(wt)}
      ${nh($t)}
      ${Nt()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${$t[2]};
        int cols = ${$t[1]};

        ${Tt}
        ${Lt.output} = result;
      }
    `;return{...pt,output:{dims:$t,type:at.type,textureType:2},shaderSource:Ft,hasMain:!0}},Wu$1=(st,at,pt)=>{let vt=eh(pt);return{...vt,get:()=>th(st,at,vt,pt)}}}),gi,ju$1=L(()=>{we$1(),ae(),gi=(st,at)=>{let pt=at.shape,vt=H(st.session.backend.glContext.version),wt=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${vt.texture2D}(X,TexCoords).r;
      ${vt.output} = encodeAsUint8(value);
    }`,$t={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:pt,type:at.tensor.type,textureType:3},shaderSource:wt,hasMain:!0};return st.executeProgram($t,[at.tensor])}});function ih(st,at){if(st===1)return"rc";let pt="";for(let vt=0;vt<st;vt++)pt+=at[vt],vt<st-1&&(pt+=",");return pt}var Yu$1,oh,Xu$1,Ku$1=L(()=>{we$1(),ae(),Bt$1(),Tr(),Yu$1={name:"unpack",inputNames:["A"],inputTypes:[2]},oh=(st,at)=>{let pt=at.dims.length,vt=Br$1("rc",pt),wt=vt.slice(-2),$t=Qe(pt),Tt=Nt(),Lt=at.dims.length===0?"":ih(pt,vt),Ft=pt<=1?"rc":`vec2(${wt.join(",")})`,Ct=H(st.session.backend.glContext.version),Ht=`
    ${Tt}
    void main() {
      ${$t} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${Lt});

       ${Ct.output} = vec4(getChannel(packedInput, ${Ft}), 0, 0, 0);
     }
   `;return{...Yu$1,hasMain:!0,output:{dims:at.dims,type:at.type,textureType:0},shaderSource:Ht}},Xu$1=(st,at)=>({...Yu$1,get:()=>oh(st,at)})}),Xn$1,un,Kn$1,ln=L(()=>{lt$1(),Xn$1=class{constructor(st,at=1){if(at===1)this.internalFormat=st.R32F,this.format=st.RED,this.textureType=st.FLOAT,this.channelSize=at;else if(at===4)this.internalFormat=st.RGBA32F,this.format=st.RGBA,this.textureType=st.FLOAT,this.channelSize=at;else throw new Error(`Invalid number of channels: ${at}`)}encode(st,at){let pt,vt;return st.constructor!==Float32Array&&(ce.warning("Encoder","data was not of type Float32; creating new Float32Array"),vt=new Float32Array(st)),at*this.channelSize>st.length?(ce.warning("Encoder","Source data too small. Allocating larger array"),vt=st,pt=this.allocate(at*this.channelSize),vt.forEach((wt,$t)=>pt[$t]=wt)):(vt=st,pt=vt),pt}allocate(st){return new Float32Array(st*4)}decode(st,at){return this.channelSize===1?st.filter((pt,vt)=>vt%4===0).subarray(0,at):st.subarray(0,at)}},un=class{constructor(st,at=1,pt){if(at!==1&&at!==4)throw new Error(`Invalid number of channels: ${at}`);this.internalFormat=st.RGBA,this.format=st.RGBA,this.channelSize=at,this.textureType=pt||st.FLOAT}encode(st,at){let pt=st;return this.channelSize===1&&(ce.verbose("Encoder","Exploding into a larger array"),pt=this.allocate(at),st.forEach((vt,wt)=>pt[wt*4]=vt)),pt}allocate(st){return new Float32Array(st*4)}decode(st,at){return this.channelSize===1?st.filter((pt,vt)=>vt%4===0).subarray(0,at):st.subarray(0,at)}},Kn$1=class{constructor(st,at=1){if(this.channelSize=4,at===1)this.internalFormat=st.ALPHA,this.format=st.ALPHA,this.textureType=st.UNSIGNED_BYTE,this.channelSize=at;else if(at===4)this.internalFormat=st.RGBA,this.format=st.RGBA,this.textureType=st.UNSIGNED_BYTE,this.channelSize=at;else throw new Error(`Invalid number of channels: ${at}`)}encode(st,at){return new Uint8Array(st.buffer,st.byteOffset,st.byteLength)}allocate(st){return new Uint8Array(st*this.channelSize)}decode(st,at){if(st instanceof Uint8Array)return st.subarray(0,at);throw new Error(`Invalid array type: ${st.constructor}`)}}}),fn,Ju$1,yi,Zu$1=L(()=>{fe$1(),ae(),fn=(st,at,pt)=>{let vt=pt===0||pt===1?1:4,wt=pt===2,$t=pt===1||pt===2,Tt=pt===4?at.length-1:void 0,Lt=pt===4?at.map((Ft,Ct)=>Ct===at.length-1?Ft*4:Ft):void 0;return yi(st,at,vt,Lt,{isPacked:wt,reverseWH:$t,breakAxis:Tt})},Ju$1=(st,at,pt)=>{let vt=fn(st,at,pt);return[vt.width,vt.height]},yi=(st,at,pt=1,vt,wt)=>{let $t=!!(wt&&wt.isPacked),[Tt,Lt]=st.computeTextureWH($t&&vt||at,wt),Ft=at.length,Ct=at.slice(0);if(Ft===0&&(Ct=[1]),pt===1)vt=at;else if($t){if(pt!==4)throw new Error("a packed texture must be 4-channel");vt=at,Ft>0&&(Ct[Ft-1]=Math.ceil(Ct[Ft-1]/2)),Ft>1&&(Ct[Ft-2]=Math.ceil(Ct[Ft-2]/2))}else if(!vt)throw new Error("Unpacked shape is needed when using channels > 1");return{width:Tt,height:Lt,channels:pt,isPacked:$t,shape:Ct,strides:U$1.computeStrides(Ct),unpackedShape:vt,reversedWH:wt&&wt.reverseWH}}}),sh,Jn$1,el$1=L(()=>{lt$1(),yr(),fe$1(),Vu$1(),qu$1(),ju$1(),Ku$1(),ln(),Zu$1(),ae(),sh=(st,at)=>{let pt=at.map(wt=>`${wt.unpackedShape.join(",")};${wt.width}x${wt.height}`).join("_"),vt=st.name;return st.cacheHint&&(vt+="["+st.cacheHint+"]"),vt+=":"+pt,vt},Jn$1=class{constructor(st){this.session=st,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(st,at){return Ju$1(this.session.layoutStrategy,st,at)}executeProgram(st,at){if(at.length<st.inputNames.length)throw new Error(`Input size mustn't be less than ${st.inputNames.length}.`);if(st.inputNames.length!==st.inputTypes.length)throw new Error("input names size does not match input types");let pt=[];for(let Ft=0;Ft<st.inputNames.length;++Ft)pt[Ft]=this.getOrCreateTextureData(at[Ft],st.inputTypes[Ft]);let vt=sh(st,pt),wt=this.session.programManager.getArtifact(vt),$t=wt?wt.programInfo:typeof st.get=="function"?st.get():st,Tt=fn(this.session.layoutStrategy,$t.output.dims,$t.output.textureType),Lt=this.createTextureData(Tt,$t.output.type);return wt||(wt=this.session.programManager.build($t,pt,Lt),this.session.programManager.setArtifact(vt,wt)),this.runProgram(wt,pt,Lt),Lt}run(st,at){return this.executeProgram(st,at).tensor}runProgram(st,at,pt){for(let vt=0;vt<at.length;++vt)if(!!at[vt].isPacked!=(st.programInfo.inputTypes[vt]===2))throw new Error(`input[${vt}] property packed inconsistent`);if(!!pt.isPacked!=(st.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(st,at,pt)}getOrCreateTextureData(st,at){let pt=this.getTextureData(st.dataId,at===2);if(!pt&&(pt=this.getTextureData(st.dataId,at!==2),pt))return at===2?this.pack(pt):this.unpack(pt);if(!pt){let vt=fn(this.session.layoutStrategy,st.dims,at);if(at===4){let wt=st.dims;if(wt.length===4){let $t=[wt[0],Math.ceil(wt[1]*wt[2]*wt[3]/4)],Tt=fn(this.session.layoutStrategy,$t,at),Lt=st.numberData;if(wt[1]*wt[2]*wt[3]%4!==0){let Ft=wt[0],Ct=wt[1]*wt[2]*wt[3],Ht=Math.ceil(Ct*1/4)*4,Gt=Ft*Ht;Lt=new Float32Array(Gt);for(let jt=0;jt<Ft;++jt){let qt=jt*Ct,Kt=jt*Ht+jt%1*Ct;Lt.set(st.numberData.subarray(qt,qt+Ct),Kt)}}return this.createTextureData(Tt,st.type,Lt,st,1)}}if(at===2){let wt=yi(this.session.layoutStrategy,st.dims,1,[],{reverseWH:!0}),$t=this.createTextureData(wt,st.type,st.numberData,st,1);pt=this.pack($t)}else pt=this.createTextureData(vt,st.type,st.numberData,st,1)}return pt}createTextureDataFromLayoutBindTensor(st,at,pt,vt){return this.createTextureData(st,at,pt,vt,1)}createTextureData(st,at,pt,vt,wt){ce.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(st)}]`);let $t=this.session.textureManager.createTextureFromLayout(at,st,pt,wt);return this.createTextureDataFromTexture(st,at,$t,vt)}reshapeUnpacked(st,at){let pt=this.getOrCreateTextureData(st,0),vt={channels:pt.channels,height:pt.height,width:pt.width,shape:at.length!==0?at:[1],strides:U$1.computeStrides(at),unpackedShape:at};return this.createTextureDataFromTexture(vt,st.type,pt.texture).tensor}reshapePacked(st,at){let pt=this.getOrCreateTextureData(st,2);if(Hu$1(st.dims,at)){let Lt={channels:pt.channels,height:pt.height,width:pt.width,shape:at.length!==0?at:[1],strides:U$1.computeStrides(at),unpackedShape:at,isPacked:!0};return this.createTextureDataFromTexture(Lt,st.type,pt.texture).tensor}let vt=bi(st.dims),wt=bi(at),$t=this.reshapePacked(st,vt),Tt=this.run(Wu$1(this,$t,wt),[$t]);return this.reshapePacked(Tt,at)}cast(st,at){let pt=this.getOrCreateTextureData(st,0);return this.createTextureDataFromTexture(pt,at,pt.texture).tensor}createTextureDataFromTexture(st,at,pt,vt,wt){let $t={...st,tensor:vt||new $e(st.unpackedShape,at,Tt=>this.readTexture($t),async Tt=>this.readTextureAsync($t),void 0,wt),texture:pt};return this.setTextureData($t.tensor.dataId,$t,st.isPacked),$t}getTextureData(st,at=!1){return this.session.isInitializer(st)?this.session.getTextureData(st,at):at?this.packedTextureDataCache.get(st):this.unpackedTextureDataCache.get(st)}setTextureData(st,at,pt=!1){this.session.isInitializer(st)?this.session.setTextureData(st,at,pt):(pt?this.packedTextureDataCache:this.unpackedTextureDataCache).set(st,at)}isTextureLayoutCached(st,at=!1){return!!this.getTextureData(st.dataId,at)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(st=>this.session.textureManager.releaseTexture(st)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(st=>this.session.textureManager.releaseTexture(st)),this.unpackedTextureDataCache=new Map}readTexture(st){return st.isPacked?this.readTexture(this.unpack(st)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(st,st.tensor.type,st.channels):this.session.textureManager.readUint8TextureAsFloat(gi(this,st))}async readTextureAsync(st){return st.isPacked?this.readTextureAsync(this.unpack(st)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(st,st.tensor.type,st.channels):this.session.textureManager.readUint8TextureAsFloat(gi(this,st))}pack(st){return this.executeProgram(zu$1(this,st.tensor),[st.tensor])}unpack(st){return this.executeProgram(Xu$1(this,st.tensor),[st.tensor])}}}),Ti,Q,Ue$1=L(()=>{Ti=class{constructor(st){Object.assign(this,st)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(st=>`${this[st]}`).join(";")),this.key}},Q=st=>new Ti(st)}),tl$1,rl$1,nl$1,uh,lh,ol$1=L(()=>{Ue$1(),we$1(),ae(),tl$1={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},rl$1=(st,at,pt)=>(lh(at),[st.run({...tl$1,cacheHint:pt.cacheKey,get:()=>uh(st,at,pt)},at)]),nl$1=st=>{let at=st.attributes.getFloat("epsilon",1e-5),pt=st.attributes.getFloat("momentum",.9),vt=st.attributes.getInt("spatial",1);return Q({epsilon:at,momentum:pt,spatial:vt})},uh=(st,at,pt)=>{let vt=H(st.session.backend.glContext.version),wt=at[0].dims.length,[$t,Tt]=st.calculateTextureWidthAndHeight(at[1].dims,0),Lt=`
  float process(int[${wt}] indices) {
    vec2 position = offsetToCoords(indices[1], ${$t}, ${Tt});
    float scale = getColorAsFloat(${vt.texture2D}(Scale, position));
    float mean = getColorAsFloat(${vt.texture2D}(Mean, position));
    float variance = getColorAsFloat(${vt.texture2D}(Variance, position));
    float b = getColorAsFloat(${vt.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${pt.epsilon})) ) + b;
  }`;return{...tl$1,output:{dims:at[0].dims,type:at[0].type,textureType:0},shaderSource:Lt}},lh=st=>{if(!st||st.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let at=st[0],pt=st[1],vt=st[2],wt=st[3],$t=st[4];if(at.dims.length<3||pt.dims.length!==1||vt.dims.length!==1||wt.dims.length!==1||$t.dims.length!==1)throw new Error("invalid input shape.");if(pt.dims[0]!==at.dims[1]||vt.dims[0]!==at.dims[1]||wt.dims[0]!==at.dims[1]||$t.dims[0]!==at.dims[1])throw new Error("invalid input shape.");if(at.type!=="float32"&&at.type!=="float64"||pt.type!=="float32"&&pt.type!=="float64"||vt.type!=="float32"&&vt.type!=="float64"||wt.type!=="float32"&&wt.type!=="float64"||$t.type!=="float32"&&$t.type!=="float64")throw new Error("invalid input tensor types.")}}),Zn$1,dt,R,cn,Qn$1,Wt$1=L(()=>{Zn$1=class{constructor(st,at,pt,vt){this.glContext=st,this.programInfo=at,this.inputTextureLayouts=pt,this.outputTextureLayout=vt}},dt=class{constructor(st){this.context=st}},R=class{constructor(st,at){this.routineBody=st,this.dependencies=at}},cn=class{constructor(st,at,pt){this.name=st,pt?this.dependencies=pt:this.dependencies=[],at&&(this.routineBody=at)}addDependency(st){st&&this.dependencies.push(st)}},Qn$1=class{static returnOrderedNodes(st){if(!st||st.length===0)return[];if(st.length===1)return st;let at=new Set,pt=new Set,vt=new Array;return this.createOrderedNodes(st,at,pt,vt),vt}static createOrderedNodes(st,at,pt,vt){for(let wt=0;wt<st.length;++wt)this.dfsTraverse(st[wt],at,pt,vt)}static dfsTraverse(st,at,pt,vt){if(!st||pt.has(st.name))return;if(at.has(st.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");at.add(st.name);let wt=st.dependencies;if(wt&&wt.length>0)for(let $t=0;$t<wt.length;++$t)this.dfsTraverse(wt[$t],at,pt,vt);vt.push(st),pt.add(st.name),at.delete(st.name)}}});function ch(){let st="add_";return{body:`
  float ${st}(float a, float b) {
    return a + b;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:st,type:0}}function ph(){let st="div_";return{body:`
  float ${st}(float a, float b) {
    return a / b;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:st,type:0}}function dh(){let st="mul_";return{body:`
  float ${st}(float a, float b) {
    return a * b;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:st,type:0}}function hh(){let st="sub_";return{body:`
  float ${st}(float a, float b) {
    return a - b;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:st,type:0}}function mh(){let st="equal_";return{body:`
  float ${st}(float a, float b) {
    return float(a == b);
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:st,type:0}}function bh(){let st="greater_";return{body:`
  float ${st}(float a, float b) {
    return float(a > b);
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:st,type:0}}function gh(){let st="less_";return{body:`
  float ${st}(float a, float b) {
    return float(a < b);
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:st,type:0}}function yh(){let st="and_";return{body:`
  float ${st}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:st,type:0}}function Th(){let st="or_";return{body:`
  float ${st}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:st,type:0}}function xh(){let st="xor_";return{body:`
  float ${st}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:st,type:0}}function wh(){return _h("pow")}function vh(){let st="prelu_";return{body:`
  float ${st}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:st,type:0}}function _h(st){let at=`${st}_`;return{body:`
  float ${at}(float a, float b) {
    return ${st}(a, b);
  }
  vec4 ${at}(vec4 v1, vec4 v2) {
    return ${st}(v1, v2);
  }
  `,name:at,type:0}}var ht,Oh,il$1,al$1,sl$1,ul$1,ll$1,fl$1,cl$1,pl$1,dl$1,hl$1,ml$1,bl$1,gl$1=L(()=>{fe$1(),Wt$1(),we$1(),ae(),ht=(st,at,pt,vt=at[0].type,wt)=>{let $t=st.session.pack?2:0;return{name:pt.name,inputNames:["A","B"],inputTypes:[$t,$t],cacheHint:wt,get:()=>Oh(st,at,pt,vt)}},Oh=(st,at,pt,vt=at[0].type)=>{let wt=st.session.pack?2:0,$t=!U$1.areEqual(at[0].dims,at[1].dims),Tt=at[0].dims,Lt=st.session.pack;if($t){let Ht=Ze$1.calcShape(at[0].dims,at[1].dims,!1);if(!Ht)throw new Error("Can't perform binary op on the given tensors");Tt=Ht;let Gt=Tt.length,jt=at[0].dims.length!==0?at[0].dims.length:1,qt=at[1].dims.length!==0?at[1].dims.length:1,Kt=at[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",An=at[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",Sn=H(st.session.backend.glContext.version),wn=Lt?`
      ${pt.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${pt.name}(a, b);
        ${Sn.output} = result;
      }`:`
      ${pt.body}
      float process(int indices[${Gt}]) {
        int aindices[${jt}];
        int bindices[${qt}];
        ${Kt}
        ${An}
        return ${pt.name}(_A(aindices), _B(bindices));
      }`;return{name:pt.name,inputNames:["A","B"],inputTypes:[wt,wt],output:{dims:Tt,type:vt,textureType:wt},shaderSource:wn,hasMain:Lt}}let Ft=H(st.session.backend.glContext.version),Ct=`
    ${pt.body}
    void main() {
      vec4 v1 = ${Ft.texture2D}(A, TexCoords);
      vec4 v2 = ${Ft.texture2D}(B, TexCoords);
      vec4 result = ${pt.name}(v1, v2);
      ${Ft.output} = result;
    }
    `;return{name:pt.name,inputNames:["A","B"],inputTypes:[wt,wt],output:{dims:at[0].dims,type:vt,textureType:wt},shaderSource:Ct,hasMain:!0}},il$1=(st,at)=>[st.run(ht(st,at,ch()),at)],al$1=(st,at)=>[st.run(ht(st,at,yh(),"bool"),at)],sl$1=(st,at)=>[st.run(ht(st,at,ph()),at)],ul$1=(st,at)=>[st.run(ht(st,at,mh(),"bool"),at)],ll$1=(st,at)=>[st.run(ht(st,at,bh(),"bool"),at)],fl$1=(st,at)=>[st.run(ht(st,at,gh(),"bool"),at)],cl$1=(st,at)=>[st.run(ht(st,at,dh()),at)],pl$1=(st,at)=>[st.run(ht(st,at,Th(),"bool"),at)],dl$1=(st,at)=>[st.run(ht(st,at,wh()),at)],hl$1=(st,at)=>[st.run(ht(st,at,vh()),at)],ml$1=(st,at)=>[st.run(ht(st,at,hh()),at)],bl$1=(st,at)=>[st.run(ht(st,at,xh(),"bool"),at)]}),yl$1,Tl$1,Sh,xl$1=L(()=>{fe$1(),yl$1=(st,at,pt)=>(Sh(at),[st.cast(at[0],pt)]),Tl$1=st=>We$1.tensorDataTypeFromProto(st.attributes.getInt("to")),Sh=st=>{if(!st||st.length!==1)throw new Error("Cast requires 1 input.");if(st[0].type==="string")throw new Error("Invalid input type.")}}),Ah,Ph,wl$1,eo$1,vl$1=L(()=>{we$1(),ae(),Bt$1(),Tr(),Ah=(st,at)=>({name:"Concat (packed)",inputNames:Array.from({length:st},(pt,vt)=>`X${vt}`),inputTypes:Array(st).fill(2),cacheHint:at}),Ph=(st,at,pt,vt)=>{let wt=pt[0].dims.slice();if(vt>=wt.length||vt<-1*wt.length)throw new Error("axis specified for concat doesn't match input dimensionality");vt<0&&(vt=wt.length+vt);let $t=wt.slice(0);for(let Hr=1;Hr<pt.length;Hr++){let qr=pt[Hr].dims.slice();for(let Zr=0;Zr<wt.length;Zr++)if(Zr===vt)$t[vt]+=qr[Zr];else if(wt[Zr]!==qr[Zr])throw new Error("non concat dimensions must match")}let Tt=$t.length,Lt=Br$1("coords",Tt),Ft=Qe(Tt),Ct=Nt(),Ht=pt.map(Hr=>Hr.dims),Gt=Dt$1(Tt),jt=new Array(Ht.length-1);jt[0]=Ht[0][vt];for(let Hr=1;Hr<jt.length;Hr++)jt[Hr]=jt[Hr-1]+Ht[Hr][vt];let qt=Gt[vt],Kt=Gt.slice(-2),An=Gt.join(),Sn=`if (${qt} < ${jt[0]}) {
        return getChannel(
            getX0(${An}), vec2(${Kt.join()}));
        }`;for(let Hr=1;Hr<jt.length;Hr++){let qr=jt[Hr-1];Sn+=`
            if (${qt} < ${jt[Hr]}  && ${qt} >= ${jt[Hr-1]}) {
              return getChannel(
                getX${Hr}(${eo$1(Gt,qt,qr)}),
                vec2(${eo$1(Kt,qt,qr)}));
            }`}let wn=jt.length,In=jt[jt.length-1];Sn+=`
            return getChannel(
              getX${wn}(${eo$1(Gt,qt,In)}),
              vec2(${eo$1(Kt,qt,In)}));`;let tr=H(st.session.backend.glContext.version),rr=`
          ${Ct}
          float getValue(${Gt.map(Hr=>"int "+Hr)}) {
            ${Sn}
          }

          void main() {
            ${Ft} coords = getOutputCoords();
            int lastDim = coords.${Gt[Tt-1]};
            coords.${Gt[Tt-1]} = coords.${Gt[Tt-2]};
            coords.${Gt[Tt-2]} = lastDim;

            vec4 result = vec4(getValue(${Lt}), 0., 0., 0.);

            ${Lt[Tt-1]} = ${Lt[Tt-1]} + 1;
            if (${Lt[Tt-1]} < ${$t[Tt-1]}) {
              result.g = getValue(${Lt});
            }

            ${Lt[Tt-2]} = ${Lt[Tt-2]} + 1;
            if (${Lt[Tt-2]} < ${$t[Tt-2]}) {
              result.a = getValue(${Lt});
            }

            ${Lt[Tt-1]} = ${Lt[Tt-1]} - 1;
            if (${Lt[Tt-2]} < ${$t[Tt-2]} &&
                ${Lt[Tt-1]} < ${$t[Tt-1]}) {
              result.b = getValue(${Lt});
            }
            ${tr.output} = result;
          }
        `;return{...at,output:{dims:$t,type:pt[0].type,textureType:2},shaderSource:rr,hasMain:!0}},wl$1=(st,at,pt)=>{let vt=Ah(at.length,pt.cacheKey);return{...vt,get:()=>Ph(st,vt,at,pt.axis)}},eo$1=(st,at,pt)=>{let vt=st.indexOf(at);return st.map((wt,$t)=>$t===vt?`${wt} - ${pt}`:wt).join()}}),_l$1,Eh,Dh,Lh,Ol$1,Ch,Fh,$h,Il$1,kh,Sl$1=L(()=>{Ue$1(),ae(),vl$1(),_l$1=(st,at,pt)=>(kh(at),st.session.pack&&at[0].dims.length>1?[st.run(wl$1(st,at,pt),at)]:[st.run(Lh(st,at,pt),at)]),Eh=(st,at)=>({name:"Concat",inputNames:Array.from({length:st},(pt,vt)=>`X${vt}`),inputTypes:Array(st).fill(0),cacheHint:at}),Dh=(st,at,pt,vt)=>{let wt=pt[0].dims.slice();if(vt>=wt.length||vt<-1*wt.length)throw new Error("axis specified for concat doesn't match input dimensionality");vt<0&&(vt=wt.length+vt);let $t=wt.slice(0);for(let qt=1;qt<pt.length;qt++){let Kt=pt[qt].dims.slice();for(let An=0;An<wt.length;An++)if(An===vt)$t[vt]+=Kt[An];else if(wt[An]!==Kt[An])throw new Error("non concat dimensions must match")}let Tt=$t.length,Lt=new Array(pt.length),Ft=0;for(let qt=0;qt<Lt.length;++qt)Ft+=pt[qt].dims[vt],Lt[qt]=Ft;let Ct="";pt.length<5?Ct=Ol$1(Lt):Ct=Ch(Lt);let Ht=Fh(pt.length,Tt),Gt=$h(Lt),jt=`
        ${Ht}
        ${Gt}
        ${Ct}
        float process(int indices[${Tt}]) {
          int textureIndex = getTextureWhereDataResides (indices[${vt}]);

          if(textureIndex != 0) {
            indices[${vt}] = indices[${vt}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...at,output:{dims:$t,type:pt[0].type,textureType:0},shaderSource:jt}},Lh=(st,at,pt)=>{let vt=Eh(at.length,pt.cacheKey);return{...vt,get:()=>Dh(st,vt,at,pt.axis)}},Ol$1=st=>`int getTextureWhereDataResides(int index) {
      ${st.map((at,pt)=>`if(index<${at}) {return ${pt};}
`).join("")}
    }`,Ch=st=>Ol$1(st),Fh=(st,at)=>{let pt=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${at}]) {`];for(let vt=0;vt<st;++vt)vt===0?pt.push(`	if (textureIndex == ${vt}) { return _X${vt}(indices); }`):vt===st-1?pt.push(`	else { return _X${vt}(indices); }`):pt.push(`	else if (textureIndex == ${vt}) { return _X${vt}(indices); }`);return pt.push("	}"),pt.join(`
`)},$h=st=>{let at=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let pt=0;pt<st.length;++pt)pt===0?at.push(`	if (index == ${pt}) { return ${st[pt]}; }`):pt===st.length-1?at.push(`	else { return ${st[pt]}; }`):at.push(`	else if (index == ${pt}) { return ${st[pt]}; }`);return at.push("	}"),at.join(`
`)},Il$1=st=>Q({axis:st.attributes.getInt("axis")}),kh=st=>{if(!st||st.length<1)throw new Error("too few inputs");let at=st[0].type,pt=st[0].dims.length;if(at==="string")throw new Error("string tensor is not supported yet");for(let vt of st){if(vt.type!==at)throw new Error("input tensors should be one type");if(vt.dims.length!==pt)throw new Error("input tensors should have the same shape")}}});function Bh(){return mt("abs")}function Nh(){return mt("acos")}function Rh(){return mt("asin")}function Mh(){return mt("atan")}function Gh(){return mt("ceil")}function Uh(){return mt("cos")}function zh(st){let at="elu";return{body:`
  const float alpha = float(${st});

  float ${at}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${at}_(vec4 v) {
    return vec4(${at}_(v.x), ${at}_(v.y), ${at}_(v.z), ${at}_(v.w));
  }
  `,name:at,type:0}}function Vh(){return mt("exp")}function Wh(){return mt("floor")}function xi(st,at){let pt="clip";return{body:`
  const float min = float(${st});
  const float max = float(${at});

  float ${pt}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${pt}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:pt,type:0}}function Hh(){let st="indentity";return{body:`
  float ${st}_(float a) {
    return a;
  }
  vec4 ${st}_(vec4 v) {
    return v;
  }
  `,name:st,type:0}}function qh(st){let at="leakyRelu";return{body:`
  const float alpha = float(${st});

  float ${at}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${at}_(vec4 v) {
    return vec4(${at}_(v.x), ${at}_(v.y), ${at}_(v.z), ${at}_(v.w));
  }
  `,name:at,type:0}}function jh(){return mt("log")}function Yh(){let st="neg";return{body:`
  float ${st}_(float a) {
    return -a;
  }
  vec4 ${st}_(vec4 v) {
    return -v;
  }
  `,name:st,type:0}}function Xh(){let st="not";return{body:`
  float ${st}_(float a) {
    return float( ! bool(a) );
  }
  bool ${st}_(bool a) {
    return !a;
  }
  vec4 ${st}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${st}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:st,type:0}}function Kh(){return mt("sin")}function wi(){let st="relu";return{body:`
  float ${st}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${st}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:st,type:0}}function vi(){let st="sigmoid";return{body:`
  float ${st}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${st}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:st,type:0}}function Jh(){return mt("sqrt")}function Zh(){return mt("tan")}function Qh(){let st="tanh";return{body:`
  float ${st}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${st}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:st,type:0}}function mt(st){return{body:`
  float ${st}_(float a) {
    return ${st}(a);
  }
  vec4 ${st}_(vec4 v) {
    return ${st}(v);
  }
  `,name:st,type:0}}var em$1,Ee,Al$1,Pl$1,El$1,Dl$1,_i,Ll$1,Cl$1,tm$1,Fl$1,$l$1,kl$1,Bl$1,Nl$1,Rl$1,Oi$1,Ml$1,Gl$1,Ul$1,zl$1,Vl$1,Wl$1,Hl$1,ql$1,jl$1,Yl$1,Xl$1,Ii=L(()=>{Ue$1(),fe$1(),Wt$1(),we$1(),ae(),em$1=(st,at,pt,vt)=>{let wt=st.session.pack?2:0,$t=H(st.session.backend.glContext.version);return{...at,output:{dims:pt.dims,type:pt.type,textureType:wt},shaderSource:`
     ${vt.body}
     void main() {
       vec4 v = ${$t.texture2D}(A, TexCoords);
       v = ${vt.name}_(v);
       ${$t.output} = v;
     }
     `,hasMain:!0}},Ee=(st,at,pt,vt)=>{let wt=st.session.pack?2:0,$t={name:pt.name,inputTypes:[wt],inputNames:["A"],cacheHint:vt};return{...$t,get:()=>em$1(st,$t,at,pt)}},Al$1=(st,at)=>[st.run(Ee(st,at[0],Bh()),at)],Pl$1=(st,at)=>[st.run(Ee(st,at[0],Nh()),at)],El$1=(st,at)=>[st.run(Ee(st,at[0],Rh()),at)],Dl$1=(st,at)=>[st.run(Ee(st,at[0],Mh()),at)],_i=(st,at,pt)=>[st.run(Ee(st,at[0],xi(pt.min,pt.max),pt.cacheKey),at)],Ll$1=st=>Q({min:st.attributes.getFloat("min",br),max:st.attributes.getFloat("max",gr$1)}),Cl$1=(st,at)=>{let pt=tm$1(st,at);return _i(st,[at[0]],pt)},tm$1=(st,at)=>{if(at.length>=3&&(!st.session.isInitializer(at[1].dataId)||!st.session.isInitializer(at[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let pt=at.length>=3?at[1].numberData[0]:br,vt=at.length>=3?at[2].numberData[0]:gr$1;return Q({min:pt,max:vt})},Fl$1=(st,at)=>[st.run(Ee(st,at[0],Gh()),at)],$l$1=(st,at)=>[st.run(Ee(st,at[0],Uh()),at)],kl$1=(st,at,pt)=>[st.run(Ee(st,at[0],zh(pt.alpha),pt.cacheKey),at)],Bl$1=st=>Q({alpha:st.attributes.getFloat("alpha",1)}),Nl$1=(st,at)=>[st.run(Ee(st,at[0],Vh()),at)],Rl$1=(st,at)=>[st.run(Ee(st,at[0],Wh()),at)],Oi$1=(st,at)=>[st.run(Ee(st,at[0],Hh()),at)],Ml$1=(st,at,pt)=>[st.run(Ee(st,at[0],qh(pt.alpha),pt.cacheKey),at)],Gl$1=st=>Q({alpha:st.attributes.getFloat("alpha",.01)}),Ul$1=(st,at)=>[st.run(Ee(st,at[0],jh()),at)],zl$1=(st,at)=>[st.run(Ee(st,at[0],Yh()),at)],Vl$1=(st,at)=>[st.run(Ee(st,at[0],Xh()),at)],Wl$1=(st,at)=>[st.run(Ee(st,at[0],wi()),at)],Hl$1=(st,at)=>[st.run(Ee(st,at[0],vi()),at)],ql$1=(st,at)=>[st.run(Ee(st,at[0],Kh()),at)],jl$1=(st,at)=>[st.run(Ee(st,at[0],Jh()),at)],Yl$1=(st,at)=>[st.run(Ee(st,at[0],Zh()),at)],Xl$1=(st,at)=>[st.run(Ee(st,at[0],Qh()),at)]});function Rt(st){let at;switch(st.activation){case"Relu":at=wi();break;case"Sigmoid":at=vi();break;case"Clip":at=xi(st.clipMin,st.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let pt=at.name,vt=at.body,wt=`value = ${pt}_(value);`;return{activationFunction:vt,applyActivation:wt}}var Nr,xr=L(()=>{fe$1(),Ii(),Nr=st=>{let at=st.getString("activation","");if(at==="Clip"){let[pt,vt]=st.getFloats("activation_params",[br,gr$1]);return{activation:at,clipMax:vt,clipMin:pt,activationCacheKey:`${at}:${pt},${vt}`}}return{activation:at,activationCacheKey:at}}}),nm$1,om$1,Kl$1,Jl$1=L(()=>{lt$1(),we$1(),ae(),to$1(),xr(),nm$1=(st,at)=>({name:"GroupedConv",inputNames:st?["X","W","Bias"]:["X","W"],inputTypes:st?[0,0,0]:[0,0],cacheHint:at}),om$1=(st,at,pt,vt)=>{let wt=at.length>2?"value += getBias(output_channel);":"",$t=at[0].dims.slice(),Tt=at[1].dims.slice(),Lt=Tt[0]/vt.group;ce.verbose("GroupedConv",`autpPad:${vt.autoPad}, dilations:${vt.dilations}, group:${vt.group}, kernelShape:${vt.kernelShape}, pads:${vt.pads}, strides:${vt.strides}`);let Ft=Rr$1($t,Tt,vt.dilations,vt.pads,vt.strides),Ct=H(st.session.backend.glContext.version),{activationFunction:Ht,applyActivation:Gt}=Rt(vt),jt=`
  const ivec2 strides = ivec2(${vt.strides[0]}, ${vt.strides[1]});
  const ivec2 pads = ivec2(${vt.pads[0]}, ${vt.pads[1]});
  ${Ht}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${Lt};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${Tt[1]}; wInChannel++) {
      int input_channel = group_id * ${Tt[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${Tt[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${vt.dilations[0]};

        if (xHeight < 0 || xHeight >= ${$t[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${Tt[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${vt.dilations[1]};
          if (xWidth < 0 || xWidth >= ${$t[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${wt}
    ${Gt}
    ${Ct.output} = vec4(value, .0, .0, .0);
  }
`;return{...pt,output:{dims:Ft,type:at[0].type,textureType:0},shaderSource:jt,hasMain:!0}},Kl$1=(st,at,pt)=>{let vt=nm$1(at.length>2,pt.cacheKey);return{...vt,get:()=>om$1(st,at,vt,pt)}}}),im$1,am$1,Zl$1,Ql$1=L(()=>{we$1(),ae(),Tr(),im$1=st=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:st}),am$1=(st,at,pt,vt,wt,$t)=>{let Tt=pt.dims,Lt=vt.dims,Ft=2,Ct=3,Ht=wt.length,Gt=[Lt[1]*Lt[2]*Lt[3],wt[2]*wt[3]],jt=Lt[2]*Lt[3],qt=Nt(),Kt=H(st.session.backend.glContext.version),An="";for(let wn=0;wn<=1;wn++)for(let In=0;In<=1;In++)An+=`
            blockIndex = rc.x + ${In};
            pos = rc.y + ${wn};

            if(blockIndex < ${Gt[1]} && pos < ${Gt[0]}) {
              offsetY = int(blockIndex / (${wt[Ht-1]})) * ${$t.strides[0]} -
                ${$t.pads[0]};
              d0 = offsetY + ${$t.dilations[0]} * (imod(pos, ${jt}) / ${Lt[2]});

              if(d0 < ${Tt[Ft]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${wt[Ht-1]}) * ${$t.strides[1]} -
                  ${$t.pads[1]};
                d1 = offsetX + ${$t.dilations[1]} * imod(imod(pos, ${jt}), ${Lt[2]});

                if(d1 < ${Tt[Ct]} && d1 >= 0) {

                  ch = int(float(pos)/ ${jt}.);
                    innerDims = vec2(d0, d1);
                    result[${wn*2+In}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let Sn=`
      ${qt}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${An}
          ${Kt.output} = result;
      }
            `;return{...at,output:{dims:Gt,type:pt.type,textureType:2},shaderSource:Sn,hasMain:!0}},Zl$1=(st,at,pt,vt,wt)=>{let $t=im$1(wt.cacheKey);return{...$t,get:()=>am$1(st,$t,at,pt,vt,wt)}}});function um$1(st,at,pt){let vt=at[0].dims,wt=at[1].dims,$t=Ze$1.calcShape(vt,wt,!0);if(!$t)throw new Error("Can't use matmul on the given tensors");let Tt=Qe($t.length),Lt=Dt$1(),{activationFunction:Ft,applyActivation:Ct}=Rt(pt),Ht=at.length>2,Gt=Ht?"value += getBiasForMatmul();":"",jt=Ht?`${Ai(Tt,Lt,at[2].dims,$t,!1)}`:"",qt=$t.length,Kt=vt.length,An=wt.length,Sn=vt[vt.length-1],wn=`
    ${Ft}
    ${jt}
    float process(int indices[${qt}]) {
        int a[${Kt}];
        int b[${An}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${Sn}; ++k) {
            a[${Kt-1}] = k;
            b[${An-2}] = k;
            value += _A(a) * _B(b);
        }
        ${Gt}
        ${Ct}
        return value;
    }`;return{...st,output:{dims:$t,type:at[0].type,textureType:0},shaderSource:wn}}function Si(st,at){let pt=sm$1(st.length>2,at.activationCacheKey);return{...pt,get:()=>um$1(pt,st,at)}}function Ai(st,at,pt,vt,wt){let $t="",Tt=pt.length,Lt=vt.length,Ft=Lt-Tt;Lt<2&&Tt>0?$t="coords":$t=pt.map((jt,qt)=>`coords.${at[qt+Ft]}`).join(", ");let Ct=Ze$1.getBroadcastDims(pt,vt).map(jt=>`coords.${at[jt+Ft]} = 0;`).join(`
`),Ht=U$1.size(pt)===1,Gt="vec4(outputValue.xx, outputValue.yy)";return Ht&&(Gt="vec4(outputValue.x)"),wt?`
vec4 getBiasForMatmul() {
  ${st} coords = getOutputCoords();
  ${Ct}
  vec4 outputValue = getBias(${$t});
  return ${Gt};
}`:`
float getBiasForMatmul() {
  ${st} coords = getOutputCoords();
  ${Ct}
  return getBias(coords.x);
}`}var ef$1,tf$1,sm$1,lm$1,ro$1=L(()=>{fe$1(),ae(),Bt$1(),xr(),Pi$1(),ef$1=(st,at,pt)=>(lm$1(at),st.session.pack?[st.run(no$1(st,at,pt),at)]:[st.run(Si(at,pt),at)]),tf$1=st=>Nr(st.attributes),sm$1=(st,at)=>({name:"MatMul",inputNames:st?["A","B","Bias"]:["A","B"],inputTypes:st?[0,0,0]:[0,0],cacheHint:at}),lm$1=st=>{if(!st||st.length!==2)throw new Error("MatMul requires 2 inputs.");if(st[0].dims[st[0].dims.length-1]!==st[1].dims[st[1].dims.length-2])throw new Error("shared dimension does not match.");if(st[0].type!=="float32"&&st[0].type!=="float64"||st[1].type!=="float32"&&st[1].type!=="float64")throw new Error("inputs should be float type");if(st[0].type!==st[1].type)throw new Error("inputs types should match")}});function pm$1(st,at,pt,vt){let wt=[],$t=[],Tt=pt[0].dims,Lt=pt[1].dims,Ft=Tt.length,Ct=Lt.length,Ht=vt.length,Gt=Ht-Ft,jt=Ht-Ct;wt=Tt.map((In,tr)=>`coords.${at[tr+Gt]}`),wt[Ft-1]="i*2",wt.join(", "),$t=Lt.map((In,tr)=>`coords.${at[tr+jt]}`),$t[Ct-2]="i*2",$t.join(", ");let qt=Ze$1.getBroadcastDims(Tt,vt),Kt=Ze$1.getBroadcastDims(Lt,vt),An=qt.map(In=>`coords.${at[In+Gt]} = 0;`).join(`
`),Sn=Kt.map(In=>`coords.${at[In+jt]} = 0;`).join(`
`),wn=`int lastDim = coords.${at[Ht-1]};
  coords.${at[Ht-1]} = coords.${at[Ht-2]};
  coords.${at[Ht-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${st} coords = getOutputCoords();
  ${wn}
  ${An}
  vec4 outputValue = getA(${wt});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${st} coords = getOutputCoords();
  ${wn}
  ${Sn}
  vec4 outputValue = getB(${$t});
  return outputValue;
}`}function dm$1(st,at){let pt="";for(let vt=0;vt<at-2;vt++)pt+=`rc.${st[vt]}, `;return pt+=`rc.${st[at-2]}, i*2`,pt}function hm$1(st,at){let pt="";for(let vt=0;vt<at-2;vt++)pt+=`rc.${st[vt]}, `;return pt+=`i*2, rc.${st[at-1]}`,pt}var fm$1,cm$1,no$1,Pi$1=L(()=>{fe$1(),we$1(),ae(),Bt$1(),xr(),ro$1(),fm$1=(st,at)=>({name:"MatMul (packed)",inputNames:st?["A","B","Bias"]:["A","B"],inputTypes:st?[2,2,2]:[2,2],cacheHint:at}),cm$1=(st,at,pt,vt)=>{let wt=pt.length>2,$t=wt?"value += getBiasForMatmul();":"",Tt=pt[0].dims,Lt=pt[1].dims,Ft=Ze$1.calcShape(Tt,Lt,!0),Ct=!U$1.areEqual(pt[0].dims,pt[1].dims);if(!Ft)throw new Error("Can't use matmul on the given tensors");let Ht=Tt[Tt.length-1],Gt=Math.ceil(Ht/2),jt=Tt.length,qt=Lt.length,Kt=H(st.session.backend.glContext.version),An=Qe(Ft.length),Sn=Ft.length,wn=Dt$1(),{activationFunction:In,applyActivation:tr}=Rt(vt),rr=wt?`${Ai(An,wn,pt[2].dims,Ft,!0)}`:"",Hr=Ct?`${pm$1(An,wn,pt,Ft)}`:"",qr=Ct?"getAAtOutCoordsMatmul(i)":`getA(${dm$1(wn,jt)})`,Zr=Ct?"getBAtOutCoordsMatmul(i)":`getB(${hm$1(wn,qt)})`,Bo=Ct?"":`${An} rc =
          getOutputCoords(); int lastDim = rc.${wn[Sn-1]}; rc.${wn[Sn-1]} =
          rc.${wn[Sn-2]}; rc.${wn[Sn-2]} = lastDim;
      `,Xo=`
            ${Hr}
            ${rr}
            ${In}
            void main() {
              ${Bo}

              vec4 value = vec4(0);
              for (int i = 0; i < ${Gt}; i++) {
                vec4 a = ${qr};
                vec4 b = ${Zr};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${$t}
              ${tr}
              ${Kt.output} = value;
            }`;return{...at,output:{dims:Ft,type:pt[0].type,textureType:2},shaderSource:Xo,hasMain:!0}},no$1=(st,at,pt)=>{let vt=fm$1(at.length>2,pt.activationCacheKey);return{...vt,get:()=>cm$1(st,vt,at,pt)}}}),rf$1,nf$1=L(()=>{to$1(),Ql$1(),Pi$1(),rf$1=(st,at,pt)=>{let vt=at[0].dims,wt=at[1].dims,$t=Rr$1(vt,wt,pt.dilations,pt.pads,pt.strides),Tt=st.run(Zl$1(st,at[0],at[1],$t,pt),[at[0]]),Lt=st.reshapePacked(at[1],[wt[0],wt[1]*wt[2]*wt[3]]),Ft=at.length===3?[Lt,Tt,at[2]]:[Lt,Tt],Ct=st.run(no$1(st,Ft,pt),Ft);return st.reshapePacked(Ct,$t)}}),mm$1,bm$1,of$1,Ei,Di$1=L(()=>{ae(),mm$1=st=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:st}),bm$1=(st,at,pt,vt,wt,$t)=>{let Tt=pt.dims,Lt=vt.dims,Ft=wt.length,Ct=Ei(Tt,Lt,wt,4),Ht=`
        const int XC = ${Tt[1]};
        const int XH = ${Tt[2]};
        const int XW = ${Tt[3]};
        const int KH = ${$t.kernelShape[0]};
        const int KW = ${$t.kernelShape[1]};
        const int dilationH = ${$t.dilations[0]};
        const int dilationW = ${$t.dilations[1]};
        const int strideH = ${$t.strides[0]};
        const int strideW = ${$t.strides[1]};
        const int padH = ${$t.pads[0]};
        const int padW = ${$t.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${Ft}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${Tt.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...at,output:{dims:Ct,type:pt.type,textureType:4},shaderSource:Ht}},of$1=(st,at,pt,vt,wt)=>{let $t=mm$1(wt.cacheKey);return{...$t,get:()=>bm$1(st,$t,at,pt,vt,wt)}},Ei=(st,at,pt,vt=4)=>[pt[0],pt[2],pt[3],Math.ceil(st[1]*at[2]*at[3]/vt)]}),gm$1,ym$1,af$1,sf$1=L(()=>{fe$1(),we$1(),ae(),xr(),Di$1(),gm$1=(st,at)=>({name:"ConvDotProduct",inputNames:st?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:st?[0,4,0]:[0,4],cacheKey:at.activationCacheKey}),ym$1=(st,at,pt,vt,wt)=>{let $t=pt[0].dims,Tt=pt[1].dims,Lt=[Tt[0],Math.ceil($t[1]*Tt[2]*Tt[3]/4)],Ft=Ei($t,Tt,vt),[Ct,Ht]=st.calculateTextureWidthAndHeight(Lt,4),Gt=U$1.computeStrides(Ft),[jt,qt]=st.calculateTextureWidthAndHeight(Ft,4),Kt=vt.length,An=pt.length<3?"0.0":"_B(b)",Sn=Math.ceil($t[1]*Tt[2]*Tt[3]/4),{activationFunction:wn,applyActivation:In}=Rt(wt),tr=H(st.session.backend.glContext.version),rr=`
${wn}
float process(int indices[${Kt}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${Gt[0]} + im2col[1] * ${Gt[1]} + im2col[2] * ${Gt[2]};
  int kernelOffset = indices[1] * ${Lt[1]};
  float value = ${An};
  for (int i = 0; i < ${Sn}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${jt}, ${qt});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${Ct}, ${Ht});
    value += dot(${tr.texture2D}(Im2Col, im2colCoords), ${tr.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${In}
  return value;
}`;return{...at,output:{dims:vt,type:pt[0].type,textureType:0},shaderSource:rr}},af$1=(st,at,pt,vt)=>{let wt=gm$1(at.length>2,vt);return{...wt,get:()=>ym$1(st,wt,at,pt,vt)}}}),Rr$1,Li$1,Tm$1,xm$1,wm$1,vm,Ci,_m$1,to$1=L(()=>{Ue$1(),fe$1(),Jl$1(),nf$1(),sf$1(),xr(),Di$1(),ro$1(),Rr$1=(st,at,pt,vt,wt)=>{let $t=st[0],Tt=st.slice(2),Lt=Tt.length,Ft=at[0],Ct=at.slice(2).map((Gt,jt)=>Gt+(Gt-1)*(pt[jt]-1)),Ht=Tt.map((Gt,jt)=>Gt+vt[jt]+vt[jt+Lt]).map((Gt,jt)=>Math.floor((Gt-Ct[jt]+wt[jt])/wt[jt]));return[$t,Ft].concat(...Ht)},Li$1=(st,at,pt)=>(_m$1(at,pt),Tm$1(st,at,pt)),Tm$1=(st,at,pt)=>{let vt=vm(pt,at),wt=st.session.pack,$t=vt.kernelShape[0]===1&&vt.kernelShape[1]===1;return vt.group>1?[st.run(Kl$1(st,at,vt),at)]:$t&&wt?[xm$1(st,at,vt)]:wt&&at[0].dims.length===4&&at[0].dims[0]===1&&!$t?[rf$1(st,at,vt)]:[wm$1(st,at,vt)]},xm$1=(st,at,pt)=>{let vt=at[0].dims,wt=at[1].dims,$t=Rr$1(vt,wt,pt.dilations,pt.pads,pt.strides),Tt=st.reshapeUnpacked(at[0],[vt[1],vt[2]*vt[3]]),Lt=st.reshapeUnpacked(at[1],[wt[0],wt[1]]),Ft=at.length>2?[Lt,Tt,at[2]]:[Lt,Tt],Ct=st.run(Si(Ft,pt),Ft);return st.reshapeUnpacked(Ct,$t)},wm$1=(st,at,pt)=>{let vt=at[0].dims,wt=at[1].dims,$t=Rr$1(vt,wt,pt.dilations,pt.pads,pt.strides),Tt=st.run(of$1(st,at[0],at[1],$t,pt),[at[0]]),Lt=at.length===3?[Tt,at[1],at[2]]:[Tt,at[1]];return st.run(af$1(st,at,$t,pt),Lt)},vm=(st,at)=>{let pt=st.kernelShape.slice();if(st.kernelShape.length===0)for(let $t=2;$t<at[1].dims.length;++$t)pt.push(at[1].dims[$t]);let vt=st.pads.slice();mr$1.adjustPadsBasedOnAutoPad(at[0].dims,st.strides,st.dilations,pt,vt,st.autoPad);let wt=Object.assign({},st);return Object.assign(wt,{kernelShape:pt,pads:vt,cacheKey:st.cacheKey}),wt},Ci=st=>{let at=st.attributes,pt=Nr(at),vt=at.getString("auto_pad","NOTSET"),wt=at.getInts("dilations",[1,1]),$t=at.getInt("group",1),Tt=at.getInts("kernel_shape",[]),Lt=at.getInts("pads",[0,0,0,0]),Ft=at.getInts("strides",[1,1]);return Q({autoPad:vt,dilations:wt,group:$t,kernelShape:Tt,pads:Lt,strides:Ft,...pt})},_m$1=(st,at)=>{if(!st||st.length!==2&&st.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(st[0].dims.length!==4||st[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let pt=st[0].dims[1],vt=st[1].dims[1]*at.group;if(pt!==vt)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(st.length===3&&(st[2].dims.length!==1||st[1].dims[0]!==st[2].dims[0]))throw new Error("invalid bias");let wt=st[0].dims.length-2;if(at.dilations.length!==wt)throw new Error(`dilations should be ${wt}D`);if(at.strides.length!==wt)throw new Error(`strides should be ${wt}D`);if(at.pads.length!==wt*2)throw new Error(`pads should be ${wt*2}D`);if(at.kernelShape.length!==0&&at.kernelShape.length!==st[1].dims.length-2)throw new Error("invalid kernel shape");if(st[0].type!=="float32"||st[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(st.length===3&&st[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}}),Om$1,Im$1,Sm$1,uf$1,Am$1,Pm$1,Em$1,Dm$1,Lm$1,Cm$1,lf$1,Fm$1,ff$1=L(()=>{Ue$1(),we$1(),ae(),xr(),Om$1=(st,at,pt,vt,wt,$t)=>(st-1)*at+pt+(vt-1)*wt+1-$t,Im$1=(st,at,pt,vt,wt)=>{let $t=Math.floor(st/2);at==="SAME_UPPER"?(pt[vt]=$t,pt[wt]=st-$t):at==="SAME_LOWER"&&(pt[vt]=st-$t,pt[wt]=$t)},Sm$1=(st,at,pt,vt,wt,$t,Tt,Lt)=>{let Ft=st.length-2,Ct=Lt.length===0;for(let Ht=0;Ht<Ft;++Ht){let Gt=Ct?st[Ht+2]*$t[Ht]:Lt[Ht],jt=Om$1(st[Ht+2],$t[Ht],wt[Ht],at[Ht],pt[Ht],Gt);Im$1(jt,vt,wt,Ht,Ht+Ft),Ct&&Lt.push($t[Ht]*(st[Ht+2]-1)+Tt[Ht]+(at[Ht]-1)*pt[Ht]+1-wt[Ht]-wt[Ht+Ft])}},uf$1=(st,at,pt)=>(Fm$1(at,pt),Am$1(st,at,pt)),Am$1=(st,at,pt)=>{let vt=Cm$1(pt,at);return[Lm$1(st,at,vt)]},Pm$1=(st,at)=>({name:"ConvTranspose",inputNames:st?["X","W","B"]:["X","W"],inputTypes:st?[0,0,0]:[0,0],cacheHint:at}),Em$1=(st,at,pt,vt)=>{let wt=at.length>2?"getB(output_channel)":"0.0",$t=at[0].dims,Tt=at[1].dims,Lt=Tt[1],Ft=Tt[0]/vt.group,Ct=[at[0].dims[0],at[1].dims[1]*vt.group,...vt.outputShape],Ht=H(st.session.backend.glContext.version),{activationFunction:Gt,applyActivation:jt}=Rt(vt),qt=`
  const ivec2 strides = ivec2(${vt.strides[0]}, ${vt.strides[1]});
  const ivec2 pads = ivec2(${vt.pads[0]}, ${vt.pads[1]});
  ${Gt}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${Lt};
    int wOutChannel = output_channel - group_id * ${Lt};

    float value = ${wt};
    for (int inChannelOffset = 0; inChannelOffset < ${Ft}; inChannelOffset++) {
      int input_channel = group_id * ${Ft} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${Tt[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${Tt[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${vt.dilations[0]}, wHOff * ${vt.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${$t[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${$t[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${jt}
    ${Ht.output} = vec4(value, .0, .0, .0);
  }
`;return{...pt,output:{dims:Ct,type:at[0].type,textureType:0},shaderSource:qt,hasMain:!0}},Dm$1=(st,at,pt)=>{let vt=Pm$1(at.length>2,pt.cacheKey);return{...vt,get:()=>Em$1(st,at,vt,pt)}},Lm$1=(st,at,pt)=>st.run(Dm$1(st,at,pt),at),Cm$1=(st,at)=>{let pt=st.kernelShape.slice();if(st.kernelShape.length===0)for(let Lt=2;Lt<at[1].dims.length;++Lt)pt.push(at[1].dims[Lt]);let vt=st.pads.slice(),wt=st.outputShape.slice(),$t=at[0].dims;Sm$1($t,pt,st.dilations,st.autoPad,vt,st.strides,st.outputPadding,wt);let Tt=Object.assign({},st);return Object.assign(Tt,{kernelShape:pt,pads:vt,outputShape:wt,cacheKey:st.cacheKey}),Tt},lf$1=st=>{let at=st.attributes,pt=Nr(at),vt=at.getString("auto_pad","NOTSET"),wt=at.getInts("dilations",[1,1]),$t=at.getInt("group",1),Tt=at.getInts("kernel_shape",[]),Lt=at.getInts("output_padding",[0,0]),Ft=at.getInts("output_shape",[]),Ct=at.getInts("pads",[0,0,0,0]),Ht=at.getInts("strides",[1,1]);return Q({autoPad:vt,dilations:wt,group:$t,kernelShape:Tt,outputPadding:Lt,outputShape:Ft,pads:Ct,strides:Ht,...pt})},Fm$1=(st,at)=>{if(!st||st.length!==2&&st.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(st[0].dims.length!==4||st[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let pt=st[0].dims[1],vt=st[1].dims[0];if(pt!==vt)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let wt=st[1].dims[1]*at.group;if(st.length===3&&(st[2].dims.length!==1||st[2].dims[0]!==wt))throw new Error("invalid bias");let $t=st[0].dims.length-2;if(at.dilations.length!==$t)throw new Error(`dilations should be ${$t}D`);if(at.strides.length!==$t)throw new Error(`strides should be ${$t}D`);if(at.pads.length!==$t*2)throw new Error(`pads should be ${$t*2}D`);if(at.outputPadding.length!==$t)throw new Error(`output_padding should be ${$t}D`);if(at.kernelShape.length!==0&&at.kernelShape.length!==st[1].dims.length-2)throw new Error("invalid kernel shape");if(at.outputShape.length!==0&&at.outputShape.length!==st[0].dims.length-2)throw new Error("invalid output shape");if(st[0].type!=="float32"||st[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(st.length===3&&st[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}}),cf,wr,pf$1,$m$1,df,km$1,Bm$1,Nm$1,oo$1=L(()=>{Ue$1(),fe$1(),ae(),cf={name:"Transpose",inputNames:["A"],inputTypes:[0]},wr=(st,at,pt)=>(Nm$1(at),[st.run({...cf,cacheHint:pt.cacheKey,get:()=>$m$1(st,at[0],pt.perm)},at)]),pf$1=st=>Q({perm:st.attributes.getInts("perm",[])}),$m$1=(st,at,pt)=>{let vt=at.dims;pt=df(vt,pt);let wt=km$1(vt,pt),$t=vt.length,Tt=`
      ${Bm$1("perm",pt,$t)}
      float process(int indices[${$t}]) {
        int a[${$t}];
        perm(a, indices);
        return _A(a);
      }`;return{...cf,output:{dims:wt,type:at.type,textureType:0},shaderSource:Tt}},df=(st,at)=>(at&&at.length!==st.length&&(at=[...st.keys()].reverse()),at),km$1=(st,at)=>(at=df(st,at),U$1.sortBasedOnPerm(st,at)),Bm$1=(st,at,pt)=>{let vt=[];vt.push(`void ${st}(out int a[${pt}], int src[${pt}]) {`);for(let wt=0;wt<pt;++wt)vt.push(`	a[${at[wt]}]=src[${wt}];`);return vt.push("	}"),vt.join(`
`)},Nm$1=st=>{if(!st||st.length!==1)throw new Error("Transpose requires 1 input.");if(st[0].type!=="float32"&&st[0].type!=="float64")throw new Error("input should be float tensor")}}),hf$1,mf$1,Rm$1,bf=L(()=>{oo$1(),hf$1=(st,at,pt)=>{Rm$1(at);let vt=pt.blocksize,wt=vt*vt,$t=pt.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],Tt=pt.mode==="DCR"?[at[0].dims[0],vt,vt,at[0].dims[1]/wt,at[0].dims[2],at[0].dims[3]]:[at[0].dims[0],at[0].dims[1]/wt,vt,vt,at[0].dims[2],at[0].dims[3]],Lt=st.reshapeUnpacked(at[0],Tt),Ft={perm:$t,cacheKey:`${$t}`},[Ct]=wr(st,[Lt],Ft),Ht=[at[0].dims[0],at[0].dims[1]/wt,at[0].dims[2]*vt,at[0].dims[3]*vt];return[st.reshapeUnpacked(Ct,Ht)]},mf$1=st=>{let at=st.attributes.getInt("blocksize");if(at<1)throw new Error(`blocksize must be >= 1, but got : ${at} for DepthToSpace`);let pt=st.attributes.getString("mode","DCR");if(pt!=="DCR"&&pt!=="CRD")throw new Error(`unrecognized mode: ${pt} for DepthToSpace`);return{mode:pt,blocksize:at}},Rm$1=st=>{if(st.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${st.length}`);if(st[0].type==="string"||st[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}}),gf,yf,Mm$1,Tf=L(()=>{fe$1(),gf=(st,at,pt)=>{Mm$1(at,pt);let vt=U$1.flattenShape(at[0].dims,pt);return[st.reshapeUnpacked(at[0],vt)]},yf=st=>st.attributes.getInt("axis",1),Mm$1=(st,at)=>{if(!st||st.length!==1)throw new Error("Flatten requires 1 input.");let pt=st[0].dims.length;if(pt===0)throw new Error("scalar tensor is not supported.");if(at<-pt||at>pt)throw new Error("Invalid axis");if(st[0].type==="string")throw new Error("string tensor is not supported.")}}),Qt,pn=L(()=>{Qt=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]}),xf,wf,Gm$1,Um$1,zm$1,Vm$1,vf=L(()=>{Ue$1(),pn(),fe$1(),ae(),xf=(st,at,pt)=>(Vm$1(at,pt.axis),[st.run(zm$1(st,at,pt),at)]),wf=st=>Q({axis:st.attributes.getInt("axis",0)}),Gm$1={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},Um$1=(st,at,pt,vt)=>{let wt=pt[0].dims.slice(),$t=pt[1].dims.slice(),Tt=new Array(wt.length+$t.length-1);vt=U$1.normalizeAxis(vt,wt.length);let Lt=[];for(let jt=0;jt<Tt.length;jt++)jt<vt?(Tt[jt]=wt[jt],Lt.push(`inputIdx[${jt}] = outputIdx[${jt}];`)):jt<vt+$t.length?(Tt[jt]=$t[jt-vt],Lt.push(`indexDataIdx[${jt-vt}] = outputIdx[${jt}];`)):(Tt[jt]=wt[jt-$t.length+1],Lt.push(`inputIdx[${jt-$t.length+1}] = outputIdx[${jt}];`));let Ft=Tt.length||1,Ct=wt.length,Ht=$t.length||1,Gt=`
      float process(int outputIdx[${Ft}]) {
        int inputIdx[${Ct}];
        int indexDataIdx[${Ht}];
        indexDataIdx[0] = 0;
        ${Lt.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${vt}] = idx < 0 ? idx + ${wt[vt]} : idx;
        return _A(inputIdx);
      }`;return{...at,output:{dims:Tt,type:pt[0].type,textureType:0},shaderSource:Gt}},zm$1=(st,at,pt)=>{let vt={...Gm$1,cacheHint:pt.cacheKey};return{...vt,get:()=>Um$1(st,vt,at,pt.axis)}},Vm$1=(st,at)=>{if(!st||st.length!==2)throw new Error("Gather requires 2 inputs.");let pt=st[0].dims.length;if(pt<1)throw new Error("Invalid input shape.");if(at<-pt||at>pt-1)throw new Error("Invalid axis.");if(Qt.indexOf(st[0].type)===-1)throw new Error("Invaid input type.");if(st[1].type!=="int32"&&st[1].type!=="int16")throw new Error("Invaid input type.")}}),Fi$1,_f,Of,If,Wm$1,Hm$1,qm$1,Sf=L(()=>{Ue$1(),fe$1(),ae(),Fi$1=(st,at,pt)=>(qm$1(at,pt),[st.run(Wm$1(at,pt),at)]),_f=(st,at)=>{let pt=st.attributes.getInt("transA",0)!==0,vt=st.attributes.getInt("transB",0)!==0,wt=st.attributes.getFloat("alpha",1),$t=st.attributes.getFloat("beta",1);return Q({transA:pt,transB:vt,alpha:wt,beta:$t,isOptionalC:at})},Of=st=>_f(st,!1),If=st=>_f(st,!0),Wm$1=(st,at)=>{let pt={name:"Gemm",inputNames:st.length===3?["A","B","C"]:["A","B"],inputTypes:st.length===3?[0,0,0]:[0,0],key:at.cacheKey};return{...pt,get:()=>Hm$1(pt,st,at)}},Hm$1=(st,at,pt)=>{let vt=at[0].dims.slice(),wt=at[1].dims.slice(),[$t,Tt]=jn$1.getShapeOfGemmResult(vt,pt.transA,wt,pt.transB,at.length===3?at[2].dims:void 0),Lt=[$t,Tt];if(!Lt)throw new Error("Can't use gemm on the given tensors");let Ft=vt[vt.length-1],Ct="";pt.transA&&(Ft=vt[0]),pt.transA&&pt.transB?Ct="value += _A_T(a) * _B_T(b);":pt.transA&&!pt.transB?Ct="value += _A_T(a) * _B(b);":!pt.transA&&pt.transB?Ct="value += _A(a) * _B_T(b);":!pt.transA&&!pt.transB&&(Ct="value += _A(a) * _B(b);");let Ht=Lt.length,Gt=at.length===3?`int c[${at[2].dims.length}];`:"",jt=at.length===3?"bcastIndices_C(indices, c);":"",qt=at.length===3?"value += beta * _C(c);":"",Kt=`
      float process(int indices[${Ht}]) {
          int a[${Ht}];
          int b[${Ht}];
          ${Gt}

          copyVec(indices, a);
          copyVec(indices, b);
          ${jt}

          float value = 0.0;
          for (int k=0; k<${Ft}; ++k) {
              a[${Ht-1}] = k;
              b[${Ht-2}] = k;
              ${Ct}
          }

          value = value * alpha;
          ${qt}
          return value;
      }`;return{...st,output:{dims:Lt,type:at[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:pt.alpha},{name:"beta",type:"float",data:pt.beta}],shaderSource:Kt}},qm$1=(st,at)=>{if(!st)throw new Error("Input is missing");if(at.isOptionalC&&(st.length<2||st.length>3))throw new Error("Invaid input shape.");if(!at.isOptionalC&&st.length!==3)throw new Error("Gemm requires 3 inputs");if(st.length===3&&st[2].dims.length!==1&&st[2].dims.length!==2)throw new Error("Invalid input shape of C");if(st[0].type!=="float32"&&st[0].type!=="float64"||st[1].type!=="float32"&&st[1].type!=="float64"||st.length===3&&st[2].type!=="float32"&&st[2].type!=="float64")throw new Error("Invalid input type.");if(st[0].type!==st[1].type||st.length===3&&st[0].type!==st[2].type)throw new Error("Input types are mismatched")}}),Af,Pf,jm$1,Ym$1,Xm$1,Km$1,Jm$1,Ef=L(()=>{Ue$1(),ae(),Af=(st,at,pt)=>(Jm$1(at),[st.run(Xm$1(st,at,pt),at)]),Pf=st=>{let at=st.attributes.getFloat("scale"),pt=st.attributes.getFloats("bias");return Q({scale:at,bias:pt})},jm$1={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},Ym$1=(st,at,pt,vt)=>{let wt=pt[0].dims.slice(),$t=wt.length,Tt=`
      ${Km$1(vt.bias.length)}
      float process(int indices[${$t}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...at,output:{dims:wt,type:pt[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:vt.bias.length,data:vt.bias},{name:"scale",type:"float",data:vt.scale}],shaderSource:Tt}},Xm$1=(st,at,pt)=>{let vt={...jm$1,cacheHint:pt.cacheKey};return{...vt,get:()=>Ym$1(st,vt,at,pt)}},Km$1=st=>{let at=[`float getBias(float bias[${st}], int channel) {`];for(let pt=0;pt<st;++pt)pt===0?at.push(`	if (channel == ${pt}) { return bias[${pt}]; }`):pt===st-1?at.push(`	else { return bias[${pt}]; }`):at.push(`	else if (channel == ${pt}) { return bias[${pt}]; }`);return at.push("	}"),at.join(`
`)},Jm$1=st=>{if(!st||st.length!==1)throw new Error("ImageScaler requires 1 input.");if(st[0].dims.length!==4)throw new Error("Invalid input shape.");if(st[0].type!=="float32"&&st[0].type!=="float64")throw new Error("Invalid input type.")}}),Lf,Cf,Df,Zm$1,Qm$1,eb,tb,rb,nb,Ff=L(()=>{we$1(),ae(),Lf=(st,at,pt)=>{nb(at);let vt=st.run(Qm$1(at[0]),at);return[st.run(rb(st,at[0],pt,vt.dims),[at[0],vt,at[1],at[2]])]},Cf=st=>st.attributes.getFloat("epsilon",1e-5),Df={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},Zm$1=(st,at)=>{let pt=at.dims.slice(),vt=pt[1],wt=pt[2]*pt[3],$t=[pt[0],vt],Tt=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${pt[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${pt[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${wt});
        temp = 0.0;
        for(int a2=0; a2<${pt[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${pt[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${wt});

        return v;
      }`;return{...st,output:{dims:$t,type:at.type,textureType:4},shaderSource:Tt}},Qm$1=st=>({...Df,get:()=>Zm$1(Df,st)}),eb={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},tb=(st,at,pt,vt,wt)=>{let $t=H(st.session.backend.glContext.version),[Tt,Lt]=st.calculateTextureWidthAndHeight(wt,4),[Ft,Ct]=[Tt/4,Lt],Ht=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${Ft}, ${Ct});
        return ${$t.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...at,output:{dims:pt.dims,type:pt.type,textureType:0},variables:[{name:"epsilon",type:"float",data:vt}],shaderSource:Ht}},rb=(st,at,pt,vt)=>{let wt={...eb,cacheHint:`${pt}`};return{...wt,get:()=>tb(st,wt,at,pt,vt)}},nb=st=>{if(!st||st.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let at=st[0],pt=st[1],vt=st[2];if(at.dims.length<3||pt.dims.length!==1||vt.dims.length!==1)throw new Error("Invalid input shape.");if(pt.dims[0]!==at.dims[1]||vt.dims[0]!==at.dims[1])throw new Error("Input shapes are mismatched.");if(at.type!=="float32"&&at.type!=="float64"||pt.type!=="float32"&&pt.type!=="float64"||vt.type!=="float32"&&vt.type!=="float64")throw new Error("Invalid input type.");if(st[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}});function ob(st,at){let pt=st[0].dims[1],vt=st[0].dims.length,wt=-Math.floor((at.size-1)/2),$t=Math.ceil((at.size-1)/2),Tt=`float(${at.alpha}) / float(${at.size})`,Lt=`float(${at.bias})`,Ft=`float(${at.beta})`,Ct=`
    float process(int indices[${vt}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${wt}; i <= ${$t}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${pt}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${Lt} + ${Tt} * square_sum, ${Ft});
    }`;return{...Bf,cacheHint:at.cacheKey,output:{dims:st[0].dims,type:st[0].type,textureType:0},shaderSource:Ct}}function ib(st,at){return{...Bf,cacheHint:at.cacheKey,get:()=>ob(st,at)}}var $f,kf,Bf,ab,Nf=L(()=>{Ue$1(),ae(),$f=(st,at,pt)=>(ab(at),[st.run(ib(at,pt),at)]),kf=st=>{let at=st.attributes.getFloat("alpha",1e-4),pt=st.attributes.getFloat("beta",.75),vt=st.attributes.getFloat("bias",1),wt=st.attributes.getInt("size");return Q({alpha:at,beta:pt,bias:vt,size:wt})},Bf={name:"LRN",inputNames:["X"],inputTypes:[0]},ab=st=>{if(!st||st.length!==1)throw new Error("LRN requires 1 input.");if(st[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(st[0].type!=="float32")throw new Error("input should be float type")}}),sb,$i,Rf,Mf,Gf,ub,lb,fb,cb,pb,db,hb,mb,Uf=L(()=>{Ue$1(),fe$1(),we$1(),ae(),sb={name:"Pad",inputNames:["A"],inputTypes:[0]},$i=(st,at,pt)=>(fb(at),[st.run({...sb,cacheHint:pt.cacheKey,get:()=>lb(st,at[0],pt)},at)]),Rf=st=>{let at=st.attributes.getString("mode","constant"),pt=st.attributes.getFloat("value",0),vt=st.attributes.getInts("pads");return Q({mode:at,value:pt,pads:vt})},Mf=(st,at,pt)=>{cb(at);let vt=ub(st,at,pt);return $i(st,[at[0]],vt)},Gf=st=>st.attributes.getString("mode","constant"),ub=(st,at,pt)=>{if(!st.session.isInitializer(at[1].dataId)||at.length>=3&&!st.session.isInitializer(at[2].dataId))throw new Error("dynamic pad attributes are not allowed");let vt=Array.from(at[1].integerData),wt=at.length>=3?at[2].floatData[0]:0;return Q({mode:pt,pads:vt,value:wt})},lb=(st,at,pt)=>{let vt=U$1.padShape(at.dims.slice(),pt.pads),wt=vt.length,$t=`
      ${pb(st,at,pt)}
      float process(int[${wt}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:vt,type:at.type,textureType:0},shaderSource:$t}},fb=st=>{if(!st||st.length!==1)throw new Error("Pad requires 1 input");if(st[0].type!=="float32"&&st[0].type!=="float64")throw new Error("Invalid input type.")},cb=st=>{if(!st||st.length!==2&&st.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(st[1].type!=="int32")throw new Error("Invalid input type.");if(st.length>=3&&st[2].type==="string")throw new Error("Invalid input type.")},pb=(st,at,pt)=>{let vt=H(st.session.backend.glContext.version),[wt,$t]=st.calculateTextureWidthAndHeight(at.dims,0),Tt=U$1.computeStrides(at.dims);switch(pt.mode){case"constant":return db(vt,at.dims,Tt,wt,$t,pt.pads,pt.value);case"reflect":return hb(vt,at.dims,Tt,wt,$t,pt.pads);case"edge":return mb(vt,at.dims,Tt,wt,$t,pt.pads);default:throw new Error("Invalid mode")}},db=(st,at,pt,vt,wt,$t,Tt)=>{let Lt=at.length,Ft="";for(let Ct=Lt-1;Ct>=0;--Ct)Ft+=`
        k = m[${Ct}] - ${$t[Ct]};
        if (k < 0)  return constant;
        if (k >= ${at[Ct]}) return constant;
        offset += k * ${pt[Ct]};
        `;return`
      float padA(int m[${Lt}]) {
        const float constant = float(${Tt});
        int offset = 0;
        int k = 0;
        ${Ft}
        vec2 coords = offsetToCoords(offset, ${vt}, ${wt});
        float value = getColorAsFloat(${st.texture2D}(A, coords));
        return value;
      }
      `},hb=(st,at,pt,vt,wt,$t)=>{let Tt=at.length,Lt="";for(let Ft=Tt-1;Ft>=0;--Ft)Lt+=`
        k = m[${Ft}] - ${$t[Ft]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(at[Ft]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${at[Ft]}) { k = _2n_1 - k; }
        }
        offset += k * ${pt[Ft]};
        `;return`
      float padA(int m[${Tt}]) {
        int offset = 0;
        int k = 0;
        ${Lt}
        vec2 coords = offsetToCoords(offset, ${vt}, ${wt});
        float value = getColorAsFloat(${st.texture2D}(A, coords));
        return value;
      }
      `},mb=(st,at,pt,vt,wt,$t)=>{let Tt=at.length,Lt="";for(let Ft=Tt-1;Ft>=0;--Ft)Lt+=`
        k = m[${Ft}] - ${$t[Ft]};
        if (k < 0)  k = 0;
        if (k >= ${at[Ft]}) k = ${at[Ft]-1};
        offset += k * ${pt[Ft]};
      `;return`
      float padA(int m[${Tt}]) {
        int offset = 0;
        int k = 0;
        ${Lt}
        vec2 coords = offsetToCoords(offset, ${vt}, ${wt});
        float value = getColorAsFloat(${st.texture2D}(A, coords));
        return value;
      }
      `}}),Vf,Wf,Hf,qf,jf,Yf,Xf,Kf,Jf,bb,zf,Zf,ao$1,Qf,io$1,gb,ec=L(()=>{Ue$1(),fe$1(),ae(),Vf=(st,at,pt)=>{ao$1(at);let vt={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:pt.cacheKey};return[st.run({...vt,get:()=>Hf(at,vt,!1,pt)},at)]},Wf=st=>{let at=st.attributes.getString("auto_pad","NOTSET"),pt=st.attributes.getInt("ceil_mode",0),vt=st.attributes.getInt("count_include_pad",0)!==0,wt=st.attributes.getInts("kernel_shape"),$t=st.attributes.getInts("strides",[]),Tt=st.attributes.getInts("pads",[]);if(pt!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return Q({autoPad:at,ceilMode:pt,countIncludePad:vt,kernelShape:wt,strides:$t,pads:Tt})},Hf=(st,at,pt,vt)=>{let[wt,$t]=Jf(st,vt,pt),Tt=U$1.size(wt.kernelShape),Lt="value += _X(x);",Ft="";wt.countIncludePad?Ft+=`value /= float(${Tt});`:Ft+=`value /= float(${Tt} - pad);`;let Ct=`
        ${Qf(st[0].dims,wt,Lt,Ft,"0.0")}
      `;return{...at,output:{dims:$t,type:st[0].type,textureType:0},shaderSource:Ct}},qf=(st,at,pt)=>{ao$1(at);let vt={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${pt.countIncludePad}`};return[st.run({...vt,get:()=>Hf(at,vt,!0,pt)},at)]},jf=st=>{let at=st.attributes.getInt("count_include_pad",0)!==0;return Q({autoPad:"",ceilMode:0,countIncludePad:at,kernelShape:[],strides:[],pads:[]})},Yf=(st,at,pt)=>{ao$1(at);let vt={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:pt.cacheKey};return[st.run({...vt,get:()=>Kf(at,vt,!1,pt)},at)]},Xf=st=>{let at=st.attributes.getString("auto_pad","NOTSET"),pt=st.attributes.getInt("ceil_mode",0),vt=st.attributes.getInts("kernel_shape"),wt=st.attributes.getInts("strides",[]),$t=st.attributes.getInts("pads",[]),Tt=st.attributes.getInt("storage_order",0),Lt=st.attributes.getInts("dilations",[]);if(Tt!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(pt!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return Q({autoPad:at,ceilMode:pt,countIncludePad:!1,kernelShape:vt,strides:wt,pads:$t,storageOrder:Tt,dilations:Lt})},Kf=(st,at,pt,vt)=>{let[wt,$t]=Jf(st,vt,pt),Tt=`
      value = max(_X(x), value);
    `,Lt="",Ft=`
      ${Qf(st[0].dims,wt,Tt,Lt,"-1e5")}
    `;return{...at,output:{dims:$t,type:st[0].type,textureType:0},shaderSource:Ft}},Jf=(st,at,pt)=>{let vt=st[0].dims.slice(),wt=Object.hasOwnProperty.call(at,"dilations"),$t=at.kernelShape.slice(),Tt=at.strides.slice(),Lt=wt?at.dilations.slice():[],Ft=at.pads.slice();mr$1.adjustPoolAttributes(pt,vt,$t,Tt,Lt,Ft);let Ct=mr$1.computePoolOutputShape(pt,vt,Tt,Lt,$t,Ft,at.autoPad),Ht=Object.assign({},at);return wt?Object.assign(Ht,{kernelShape:$t,strides:Tt,pads:Ft,dilations:Lt,cacheKey:at.cacheKey}):Object.assign(Ht,{kernelShape:$t,strides:Tt,pads:Ft,cacheKey:at.cacheKey}),[Ht,Ct]},bb={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},zf={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},Zf=(st,at)=>(ao$1(at),[st.run({...zf,get:()=>Kf(at,zf,!0,bb)},at)]),ao$1=st=>{if(!st||st.length!==1)throw new Error("Pool ops requires 1 input.");if(st[0].type!=="float32"&&st[0].type!=="float64")throw new Error("Invalid input type.")},Qf=(st,at,pt,vt,wt)=>{let $t=st.length;if(at.kernelShape.length<=2){let Tt=at.kernelShape[at.kernelShape.length-1],Lt=at.strides[at.strides.length-1],Ft=at.pads[at.pads.length/2-1],Ct=at.pads[at.pads.length-1],Ht=st[$t-1],Gt="",jt="",qt="";if(Ft+Ct!==0?Gt=`
          for (int i = 0; i < ${Tt}; i++) {
            x[${$t} - 1] = indices[${$t} - 1] * ${Lt} - ${Ft} + i;
            if (x[${$t} - 1] < 0 || x[${$t} - 1] >= ${Ht}) {
              pad++;
              continue;
            }
            ${pt}
          }`:Gt=`
          for (int i = 0; i < ${Tt}; i++) {
            x[${$t} - 1] = indices[${$t} - 1] * ${Lt} - ${Ft} + i;
            ${pt}
          }`,at.kernelShape.length===2){let Kt=at.kernelShape[at.kernelShape.length-2],An=at.strides[at.strides.length-2],Sn=at.pads[at.pads.length/2-2],wn=at.pads[at.pads.length-2],In=st[$t-2];Sn+wn!==0?jt=`
            for (int j = 0; j < ${Kt}; j++) {
              x[${$t} - 2] = indices[${$t} - 2] * ${An} - ${Sn} + j;
              if (x[${$t} - 2] < 0 || x[${$t} - 2] >= ${In}) {
                pad+= ${Tt};
                continue;
              }
          `:jt=`
            for (int j = 0; j < ${Kt}; j++) {
              x[${$t} - 2] = indices[${$t} - 2] * ${An} - ${Sn} + j;
            `,qt=`
          }
        `}return`
        float process(int indices[${$t}]) {
          int x[${$t}];
          copyVec(indices, x);

          float value = ${wt};
          int pad = 0;
          ${jt}
          ${Gt}
          ${qt}
          ${vt}
          return value;
        }
      `}else{let Tt=U$1.size(at.kernelShape),Lt=U$1.computeStrides(at.kernelShape),Ft=Lt.length,Ct=at.pads.length,Ht=gb(Ft),Gt=io$1(st,"inputDims"),jt=io$1(at.pads,"pads"),qt=io$1(Lt,"kernelStrides"),Kt=io$1(at.strides,"strides"),An=at.pads.reduce((wn,In)=>wn+In),Sn="";return An?Sn=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${pt}
          }`:Sn=`
          }
          ${pt}
        `,`
        ${Ht}
        float process(int indices[${$t}]) {
          int x[${$t}];
          copyVec(indices, x);
          int offset[${Ft}];
          int pads[${Ct}];
          int inputDims[${$t}];
          int kernelStrides[${Ft}];
          int strides[${Ft}];
          ${jt}
          ${Gt}
          ${Kt}
          ${qt}

          float value = ${wt};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${Tt}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${$t} - ${Ft}; j < ${$t}; j++) {
              x[j] = indices[j] * strides[j - ${$t} + ${Ft}]
                + offset[j - ${$t} + ${Ft}] - pads[j - 2];
              ${Sn}
          }
          ${vt}

          return value;
        }
      `}},io$1=(st,at)=>{let pt="";for(let vt=0;vt<st.length;vt++)pt+=`
      ${at}[${vt}] = ${st[vt]};
    `;return pt},gb=st=>`
  void offsetToIndices(int offset, int[${st}] strides, out int[${st}] indices) {
    if (${st} == 0) {
      return;
    }
    for (int i = 0; i < ${st} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${st} - 1] = offset;
  }`}),vr,er,yb,Tb,tc,rc,nc$1,oc$1,ic$1,ac$1,sc$1,uc$1=L(()=>{Ue$1(),pn(),fe$1(),ae(),vr=(st,at,pt,vt,wt)=>{Tb(at);let $t={name:vt,inputNames:["A"],inputTypes:[0]};return[st.run({...$t,cacheHint:pt.cacheKey,get:()=>yb(st,at,pt,vt,wt,$t)},at)]},er=st=>{let at=st.attributes.getInts("axes",[]),pt=st.attributes.getInt("keepdims",1)===1;return Q({axes:at,keepDims:pt})},yb=(st,at,pt,vt,wt,$t)=>{let Tt=[],Lt=at[0].dims.length||1,Ft=[],Ct=U$1.normalizeAxes(pt.axes,at[0].dims.length),Ht=wt(at,Ct),Gt=Ht[1];for(let qt=0;qt<at[0].dims.length;qt++)Ct.indexOf(qt)>=0||Ct.length===0?(pt.keepDims&&Tt.push(1),Gt=`
          for(int j${qt} = 0; j${qt} < ${at[0].dims[qt]}; j${qt}++) {
            inputIdx[${qt}] = j${qt};
            ${Gt}
          }`):(Ft.push(`inputIdx[${qt}] = outputIdx[${Tt.length}];`),Tt.push(at[0].dims[qt]));let jt=`
      float process(int outputIdx[${Tt.length||1}]) {
        float value;                 // final result
        int inputIdx[${Lt}];      // addressing input data
        ${Ft.join(`
`)}
        ${Ht[0]}       // init ops for reduce max/min
        ${Gt}
        ${Ht[2]}       // final computation for reduce mean
        return value;
      }`;return{...$t,output:{dims:Tt,type:at[0].type,textureType:0},shaderSource:jt}},Tb=st=>{if(!st||st.length!==1)throw new Error("Reduce op requires 1 input.");if(Qt.indexOf(st[0].type)===-1)throw new Error("Invalid input type.")},tc=(st,at,pt)=>vr(st,at,pt,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),rc=(st,at,pt)=>vr(st,at,pt,"ReduceMean",(vt,wt)=>{let $t=1;for(let Tt=0;Tt<vt[0].dims.length;Tt++)(wt.indexOf(Tt)>=0||wt.length===0)&&($t*=vt[0].dims[Tt]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${$t}.;`]}),nc$1=(st,at,pt)=>vr(st,at,pt,"ReduceMax",(vt,wt)=>{let $t=[];for(let Tt=0;Tt<vt[0].dims.length;Tt++)(wt.indexOf(Tt)>=0||wt.length===0)&&$t.push(`inputIdx[${Tt}] = 0;`);return[`${$t.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),oc$1=(st,at,pt)=>vr(st,at,pt,"ReduceMin",(vt,wt)=>{let $t=[];for(let Tt=0;Tt<vt[0].dims.length;Tt++)(wt.indexOf(Tt)>=0||wt.length===0)&&$t.push(`inputIdx[${Tt}] = 0;`);return[`${$t.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),ic$1=(st,at,pt)=>vr(st,at,pt,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),ac$1=(st,at,pt)=>vr(st,at,pt,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),sc$1=(st,at,pt)=>vr(st,at,pt,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])}),lc$1,fc$1=L(()=>{fe$1(),lc$1=(st,at)=>{let pt=U$1.calculateReshapedDims(at[0].dims,at[1].integerData);return st.session.pack?[st.reshapePacked(at[0],pt)]:[st.reshapeUnpacked(at[0],pt)]}}),cc$1,ki,pc$1,dc$1,dn,xb,Bi$1,so$1,Ni=L(()=>{Ue$1(),we$1(),ae(),cc$1={name:"Upsample",inputNames:["X"],inputTypes:[0]},ki=(st,at,pt)=>(Bi$1(at,pt),[st.run({...cc$1,cacheHint:pt.cacheKey,get:()=>xb(st,at,pt)},at)]),pc$1=st=>dn(st,7),dc$1=st=>dn(st,9),dn=(st,at)=>{let pt=at>=10,vt=st.attributes.getString("mode","nearest");if(vt!=="nearest"&&vt!=="linear"&&(at<11||vt!=="cubic"))throw new Error(`unrecognized mode: ${vt}`);let wt=[];at<9&&(wt=st.attributes.getFloats("scales"),so$1(wt,vt,pt));let $t=st.attributes.getFloat("extrapolation_value",0),Tt=at>10?st.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(Tt)===-1)throw new Error(`coordinate_transform_mode '${Tt}' is not supported`);let Lt=Tt==="tf_crop_and_resize",Ft=Lt,Ct=vt==="nearest"&&at>=11?st.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(Ct)===-1)throw new Error(`nearest_mode '${Ct}' is not supported`);let Ht=st.attributes.getFloat("cubic_coeff_a",-.75),Gt=st.attributes.getInt("exclude_outside",0)!==0;if(Gt&&vt!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let jt=at<11?!0:vt==="nearest"&&Tt==="asymmetric"&&Ct==="floor",qt=0,Kt=0,An=0;return at>10?st.inputs.length>2?(qt=1,Kt=2,An=3):(Kt=1,An=2):at===9&&(Kt=1),Q({opset:at,isResize:pt,mode:vt,scales:wt,extrapolationValue:$t,coordinateTransformMode:Tt,useExtrapolation:Ft,needRoiInput:Lt,nearestMode:Ct,cubicCoefficientA:Ht,excludeOutside:Gt,useNearest2xOptimization:jt,roiInputIdx:qt,scalesInputIdx:Kt,sizesInputIdx:An})},xb=(st,at,pt)=>{let vt=H(st.session.backend.glContext.version),[wt,$t]=st.calculateTextureWidthAndHeight(at[0].dims,0),Tt=at[0].dims.map((An,Sn)=>Math.floor(An*pt.scales[Sn])),[Lt,Ft]=st.calculateTextureWidthAndHeight(Tt,0),Ct=Tt.length,Ht=new Array(Ct),Gt=new Array(Ct),jt=`
      int output_pitches[${Ct}];
      int input_pitches[${Ct}];
      `;for(let An=Ct-1;An>=0;An--)Ht[An]=An===Ct-1?1:Ht[An+1]*Tt[An+1],Gt[An]=An===Ct-1?1:Gt[An+1]*at[0].dims[An+1],jt+=`
        output_pitches[${An}] = ${Ht[An]};
        input_pitches[${An}] = ${Gt[An]};
        `;let qt=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${wt}, ${$t});
        float value = getColorAsFloat(${vt.texture2D}(X, coords));
        return value;
      }
      `,Kt=pt.mode==="nearest"?`
    ${qt}
    float process(int indices[${Ct}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${Lt}, ${Ft});

      ${jt}

      int d, m;
      for (int dim = 0; dim < ${Ct}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:Ct===4?`
    ${qt}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${Lt}, ${Ft});

      ${jt}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${at[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${qt}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${Lt}, ${Ft});

      ${jt}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${at[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...cc$1,output:{dims:Tt,type:at[0].type,textureType:0},shaderSource:Kt,variables:[{name:"scales",type:"int",arrayLength:pt.scales.length,data:pt.scales.map(An=>Math.ceil(An))}]}},Bi$1=(st,at)=>{if(!st||at.opset<9&&st.length!==1||at.opset>=9&&at.opset<11&&st.length!==2||at.opset>=11&&st.length<2)throw new Error("invalid inputs.");if(at.scales.length>0&&st[0].dims.length!==at.scales.length)throw new Error("Invalid input shape.");if(st[0].type==="string")throw new Error("Invalid input tensor types.")},so$1=(st,at,pt)=>{if(pt){for(let vt of st)if(vt<=0)throw new Error("Scale value should be greater than 0.")}else for(let vt of st)if(vt<1)throw new Error("Scale value should be greater than or equal to 1.");if((at==="linear"||at==="cubic")&&st.length!==2&&(st.length!==4||st[0]!==1||st[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${pt?"Resize":"Upsample"} opeartor.`)}}),Ri$1,Mi$1,hc,mc$1,wb,vb,_b,Ob,bc$1=L(()=>{we$1(),ae(),Bt$1(),Tr(),Ni(),Ri$1={name:"Resize",inputNames:["A"],inputTypes:[2]},Mi$1=(st,at,pt)=>(Bi$1(at,pt),[st.run({...Ri$1,cacheHint:pt.cacheKey,get:()=>wb(st,at,pt)},at)]),hc=st=>dn(st,10),mc$1=st=>dn(st,11),wb=(st,at,pt)=>{let vt=H(st.session.backend.glContext.version),[wt,$t]=vb(at,pt);if(wt.every(In=>In===1)&&pt.coordinateTransformMode!=="tf_crop_and_resize")return{...Ri$1,output:{dims:$t,type:at[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${vt.texture2D}(X, TexCoords);
                    ${vt.output} = v;
                }`};let Tt=$t.length;if(Tt<2)throw new Error(`output dimension should be at least 2, but got ${Tt}`);let Lt=$t[Tt-2],Ft=$t[Tt-1],Ct=at[0].dims;if(Tt!==Ct.length)throw new Error(`output dimension should match input ${Ct.length}, but got ${Tt}`);let Ht=Ct[Tt-2],Gt=Ct[Tt-1],jt=wt[Tt-2],qt=wt[Tt-1],Kt="";if(pt.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${pt.mode}'`);switch(pt.coordinateTransformMode){case"asymmetric":Kt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":Kt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":Kt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${Ft}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${Lt}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${Ft}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${Lt}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":Kt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${Ft}.0 - 1.0, ${Lt}.0 - 1.0, ${Ft}.0 - 1.0,
                            ${Lt}.0 - 1.0);
                        vec4 original = vec4(${Gt}.0 - 1.0, ${Ht}.0 - 1.0, ${Gt}.0 - 1.0,
                            ${Ht}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${pt.coordinateTransformMode}'`)}let An=Qe(Tt),Sn=Nt(),wn=`
            const vec2 inputWH = vec2(${Ht}.0, ${Gt}.0);
            const vec4 scaleWHWH = vec4(float(${jt}), float(${qt}), float(${jt}), float(${qt}));
            ${Sn}
            ${Kt}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${An} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${Lt-1};
                bool hasNextCol = rc.z < ${Ft-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${vt.output} = vec4(newValue);
            }
        `;return{...Ri$1,output:{dims:$t,type:at[0].type,textureType:2},hasMain:!0,shaderSource:wn}},vb=(st,at)=>{let pt=st[0].dims,vt=at.scales,wt;if(vt.length===0){let Tt=st[at.scalesInputIdx];if(Tt&&Tt.size!==0){if(st[at.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");vt=_b(Tt,at.mode,at.isResize)}else{let Lt=st[at.sizesInputIdx];if(!Lt||Lt.size===0)throw new Error("Either scales or sizes MUST be provided as input.");wt=Array.from(Lt.integerData),vt=Ob(wt,pt,at.mode,at.isResize)}}else if(st[at.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let $t=wt||pt.map((Tt,Lt)=>Math.floor(Tt*vt[Lt]));return[vt,$t]},_b=(st,at,pt)=>{let vt=Array.from(st.floatData);return so$1(vt,at,pt),vt},Ob=(st,at,pt,vt)=>{let wt=at.length,$t=new Array(wt);for(let Tt=0,Lt=wt;Tt<Lt;Tt++)if(at[Tt]===0){if(st[Tt]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");$t[Tt]=1}else $t[Tt]=st[Tt]/at[Tt];return so$1($t,pt,vt),$t}}),gc$1,Ib,yc$1=L(()=>{yr(),gc$1=(st,at)=>(Ib(at),[new $e([at[0].dims.length],"int32",void 0,void 0,new Int32Array(at[0].dims))]),Ib=st=>{if(!st||st.length!==1)throw new Error("Shape requires 1 input.")}}),Gi$1,Tc$1,xc$1,wc$1,Sb,vc$1,Ab,Pb,_c$1=L(()=>{Ue$1(),pn(),fe$1(),ae(),Gi$1={name:"Slice",inputNames:["A"],inputTypes:[0]},Tc$1=(st,at,pt)=>(Sb(at),[st.run({...Gi$1,cacheHint:pt.cacheKey,get:()=>wc$1(st,at[0],pt)},at)]),xc$1=st=>{let at=st.attributes.getInts("starts"),pt=st.attributes.getInts("ends"),vt=st.attributes.getInts("axes",[]);return Q({starts:at,ends:pt,axes:vt})},wc$1=(st,at,pt)=>{let vt=pt.axes.length===0?at.dims.slice(0).map((Ht,Gt)=>Gt):pt.axes,wt=U$1.normalizeAxes(vt,at.dims.length),$t=pt.starts.map((Ht,Gt)=>Ht>at.dims[wt[Gt]]-1?at.dims[wt[Gt]]:U$1.normalizeAxis(Ht,at.dims[wt[Gt]])),Tt=pt.ends.map((Ht,Gt)=>Ht>at.dims[wt[Gt]]-1?at.dims[wt[Gt]]:U$1.normalizeAxis(Ht,at.dims[wt[Gt]])),Lt=at.dims.slice(),Ft=[];for(let Ht=0;Ht<wt.length;Ht++)Lt[wt[Ht]]=Tt[Ht]-$t[Ht],$t[Ht]>0&&Ft.push(`outputIdx[${wt[Ht]}] += ${$t[Ht]};`);let Ct=`
      float process(int outputIdx[${Lt.length}]) {
        ${Ft.join(`
      `)}
        return _A(outputIdx);
      }`;return{...Gi$1,output:{dims:Lt,type:at.type,textureType:0},shaderSource:Ct}},Sb=st=>{if(!st||st.length!==1)throw new Error("Slice requires 1 input.");if(Qt.indexOf(st[0].type)===-1)throw new Error("Invalid input type.")},vc$1=(st,at)=>{Pb(at);let pt=Ab(st,at);return[st.run({...Gi$1,cacheHint:pt.cacheKey,get:()=>wc$1(st,at[0],pt)},[at[0]])]},Ab=(st,at)=>{if(!st.session.isInitializer(at[1].dataId)||!st.session.isInitializer(at[2].dataId)||at.length>=4&&!st.session.isInitializer(at[3].dataId)||at.length>=5&&!st.session.isInitializer(at[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(at.length>=5&&at[4].integerData.some(Tt=>Tt!==1))throw new Error("currently non-1 steps is not supported for Slice");let pt=Array.from(at[1].integerData),vt=Array.from(at[2].integerData),wt=at.length>=4?Array.from(at[3].integerData):[],$t=`${wt};${pt};${vt}`;return{starts:pt,ends:vt,axes:wt,cacheKey:$t}},Pb=st=>{if(!st||st.length<3||st.length>5)throw new Error("Invalid input number.");if(st[1].type!=="int32"||st[1].dims.length!==1)throw new Error("Invalid input type.");if(st[2].type!=="int32"||st[2].dims.length!==1)throw new Error("Invalid input type.");if(st.length>=4&&(st[3].type!=="int32"||st[3].dims.length!==1))throw new Error("Invalid input type.");if(st.length>=5&&(st[4].type!=="int32"||st[4].dims.length!==1))throw new Error("Invalid input type.")}}),Oc$1,Ic$1,Sc$1,Ac$1,Pc$1,Ec$1,Dc$1,Lc$1,Eb,Db,Lb,Cc$1,Fc$1=L(()=>{Ue$1(),fe$1(),we$1(),ae(),oo$1(),Oc$1={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},Ic$1={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},Sc$1={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},Ac$1=(st,at,pt)=>{Cc$1(at);let vt=at[0].dims.slice(),wt=U$1.normalizeAxis(pt.axis,vt.length),$t=U$1.sizeToDimension(vt,wt),Tt=U$1.sizeFromDimension(vt,wt);return Lc$1(st,at,pt,$t,Tt)},Pc$1=st=>Q({axis:st.attributes.getInt("axis",1)}),Ec$1=st=>Q({axis:st.attributes.getInt("axis",-1)}),Dc$1=(st,at,pt)=>{Cc$1(at);let vt=at[0].dims.slice(),wt=U$1.normalizeAxis(pt.axis,vt.length),$t=vt.length,Tt=wt!==$t-1,Lt=[],Ft=[],Ct=[],Ht;Tt&&(Ft=Array.from({length:$t}).map((Kt,An)=>An),Ft[wt]=$t-1,Ft[$t-1]=wt,Ft.map(Kt=>Lt.push(vt[Kt])),Ht=Q({perm:Ft}),Ct=wr(st,at,Ht));let Gt=Tt?U$1.sizeToDimension(Lt,$t-1):U$1.sizeToDimension(vt,$t-1),jt=Tt?U$1.sizeFromDimension(Lt,$t-1):U$1.sizeFromDimension(vt,$t-1),qt=Lc$1(st,Tt?Ct:at,pt,Gt,jt);return Tt?wr(st,qt,Ht):qt},Lc$1=(st,at,pt,vt,wt)=>{let $t=Eb(st,at[0],vt,wt,[vt]),Tt=st.run({...Oc$1,cacheHint:pt.cacheKey,get:()=>$t},at),Lt=Db(st,at[0],vt,wt,$t.output.dims,[vt]),Ft=st.run({...Ic$1,cacheHint:pt.cacheKey,get:()=>Lt},[at[0],Tt]),Ct=Lb(st,at[0],vt,wt,$t.output.dims,Lt.output.dims);return[st.run({...Sc$1,cacheHint:pt.cacheKey,get:()=>Ct},[at[0],Tt,Ft])]},Eb=(st,at,pt,vt,wt)=>{let[$t,Tt]=st.calculateTextureWidthAndHeight(at.dims,0),Lt=wt.length;if(pt<1||vt<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(wt.length!==1)throw new Error("Dimensionality of the output should be 1");if(wt[0]!==pt)throw new Error("Shape of the output should be equal to logical row count");let Ft=H(st.session.backend.glContext.version),Ct=`
      float process(int[${Lt}] indices) {
        int logical_row_start_offset = indices[0] * ${vt};

        float max = getColorAsFloat(${Ft.texture2D}(A, offsetToCoords(logical_row_start_offset, ${$t},
        ${Tt} )));
        for(int i=1; i<${vt}; ++i)
        {
          float current = getColorAsFloat(${Ft.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${$t}, ${Tt})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...Oc$1,output:{dims:wt,type:at.type,textureType:0},shaderSource:Ct}},Db=(st,at,pt,vt,wt,$t)=>{let[Tt,Lt]=st.calculateTextureWidthAndHeight(at.dims,0),Ft=$t.length;if(pt<1||vt<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if($t.length!==1)throw new Error("Dimensionality of the output should be 1");if($t[0]!==pt)throw new Error("Shape of the output should be equal to logical row count");if(wt.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(wt[0]!==pt)throw new Error("Shape of the intermediate results should be equal to logical row count");let Ct=H(st.session.backend.glContext.version),Ht=`
      float process(int[${Ft}] indices) {
        int logical_row_start_offset = indices[0] * ${vt};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${vt}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${Ct.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${Tt}, ${Lt}))) - max);
        }

        return norm_factor;
      }`;return{...Ic$1,output:{dims:$t,type:at.type,textureType:0},shaderSource:Ht}},Lb=(st,at,pt,vt,wt,$t)=>{let[Tt,Lt]=st.calculateTextureWidthAndHeight(at.dims,0),Ft=at.dims.length;if(pt<1||vt<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(wt.length!==1||$t.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(wt[0]!==pt||$t[0]!==pt)throw new Error("Shape of the intermediate results should be equal to logical row count");let Ct=`
      float process(int[${Ft}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${Tt}, ${Lt});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${vt};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...Sc$1,output:{dims:at.dims,type:at.type,textureType:0},shaderSource:Ct}},Cc$1=st=>{if(!st||st.length!==1)throw new Error("Softmax requires 1 input.");if(st[0].type!=="float32"&&st[0].type!=="float64")throw new Error("Invalid input type")}}),$c$1,kc$1,Bc$1,Cb,Fb,$b,Nc$1=L(()=>{Ue$1(),fe$1(),ae(),$c$1={name:"Split",inputNames:["A"],inputTypes:[0]},kc$1=(st,at,pt)=>{$b(at);let vt=U$1.normalizeAxis(pt.axis,at[0].dims.length),wt=Cb(st,at,vt,pt),$t=[];for(let Tt=0;Tt<wt;++Tt)$t.push(st.run({...$c$1,cacheHint:`${pt.cacheKey};${Tt}`,get:()=>Fb(st,at[0],pt,vt,Tt)},at));return $t},Bc$1=st=>{let at=st.attributes.getInt("axis",0),pt=st.attributes.getInts("split",[]),vt=st.outputs.length;return Q({axis:at,split:pt,numOutputs:vt})},Cb=(st,at,pt,vt)=>{let[,wt]=an$1.splitShape(at[0].dims,pt,vt.split,vt.numOutputs);return wt.length},Fb=(st,at,pt,vt,wt)=>{let[$t,Tt]=an$1.splitShape(at.dims,vt,pt.split,pt.numOutputs),Lt=Tt[wt],Ft=$t[wt],Ct=`
      float process(int indices[${Ft.length}]) {
        indices[${vt}] += ${Lt};
        return _A(indices);
      }
    `;return{...$c$1,cacheHint:`${pt.cacheKey}:${wt}`,output:{dims:Ft,type:at.type,textureType:0},shaderSource:Ct}},$b=st=>{if(!st||st.length!==1)throw new Error("Split requires one input.");if(st[0].type!=="int8"&&st[0].type!=="uint8"&&st[0].type!=="int16"&&st[0].type!=="uint16"&&st[0].type!=="int32"&&st[0].type!=="uint32"&&st[0].type!=="float32"&&st[0].type!=="float64"&&st[0].type!=="bool")throw new Error("Invalid input type.")}}),Ui$1,Rc$1,Mc$1,kb,Bb,Gc$1=L(()=>{fe$1(),Ui$1=(st,at,pt)=>{kb(at);let vt=U$1.squeezeShape(at[0].dims,pt);return[st.reshapeUnpacked(at[0],vt)]},Rc$1=(st,at)=>(Bb(at),Ui$1(st,[at[0]],Array.from(at[1].integerData))),Mc$1=st=>st.attributes.getInts("axes"),kb=st=>{if(!st||st.length!==1)throw new Error("Squeeze requires 1 input.");if(st[0].type==="string")throw new Error("invalid input tensor types.")},Bb=st=>{if(!st||st.length!==2)throw new Error("Squeeze requires 2 inputs.");if(st[1].type!=="int32")throw new Error("Invalid input type.")}}),Uc$1,Nb,Rb,zc$1=L(()=>{we$1(),ae(),Uc$1=(st,at)=>{Rb(at);let pt={name:"Sum",inputNames:at.map((vt,wt)=>`X${wt}`),inputTypes:new Array(at.length).fill(0)};return[st.run({...pt,get:()=>Nb(st,at,pt)},at)]},Nb=(st,at,pt)=>{let vt=H(st.session.backend.glContext.version),wt=at[0].dims.slice(),$t=`
      void main() {
        vec4 result = ${at.map((Tt,Lt)=>`${vt.texture2D}(X${Lt},TexCoords)`).join(" + ")};
        ${vt.output} = result;
      }
    `;return{...pt,output:{dims:wt,type:at[0].type,textureType:0},hasMain:!0,shaderSource:$t}},Rb=st=>{if(!st||st.length===0)throw new Error("Sum requires inputs.");let at=st[0].dims.length;for(let pt=1;pt<st.length;pt++){if(at!==st[pt].dims.length)throw new Error("Input shapes are mismatched.");for(let vt=0;vt<at;vt++)if(st[0].dims[vt]!==st[pt].dims[vt])throw new Error("Input shapes are not matched.")}if(st[0].type!=="float32"&&st[0].type!=="float64")throw new Error("Invalid input type.");for(let pt=1;pt<st.length;pt++)if(st[0].type!==st[pt].type)throw new Error("Input types are not matched.")}}),Vc$1,Mb,Gb,Wc$1=L(()=>{pn(),ae(),Vc$1=(st,at)=>{Gb(at);let pt={name:"Tile",inputNames:["A"],inputTypes:[0]};return[st.run({...pt,get:()=>Mb(st,at,pt)},at)]},Mb=(st,at,pt)=>{let vt=at[0].dims.slice(),wt=new Array(vt.length),$t=[];for(let Ft=0;Ft<vt.length;Ft++)wt[Ft]=vt[Ft]*at[1].numberData[Ft],$t.push(`inputIdx[${Ft}] = int(mod(float(outputIdx[${Ft}]), ${vt[Ft]}.));`);let Tt=wt.length,Lt=`
      float process(int outputIdx[${Tt}]) {
        int inputIdx[${Tt}];
        ${$t.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...pt,output:{dims:wt,type:at[0].type,textureType:0},shaderSource:Lt}},Gb=st=>{if(!st||st.length!==2)throw new Error("Tile requires 2 input.");if(st[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(st[1].dims[0]!==st[0].dims.length)throw new Error("Invalid input shape.");if(Qt.indexOf(st[0].type)===-1)throw new Error("Invalid input type.");if(st[1].type!=="int32"&&st[1].type!=="int16")throw new Error("Invalid repeat type.")}}),zi$1,Hc$1,qc$1,Ub,zb,jc$1=L(()=>{fe$1(),zi$1=(st,at,pt)=>{Ub(at);let vt=U$1.unsqueezeShape(at[0].dims,pt);return[st.reshapeUnpacked(at[0],vt)]},Hc$1=(st,at)=>(zb(at),zi$1(st,[at[0]],Array.from(at[1].integerData))),qc$1=st=>st.attributes.getInts("axes"),Ub=st=>{if(!st||st.length!==1)throw new Error("Unsqueeze requires 1 input.");if(st[0].type==="string")throw new Error("invalid input tensor types.")},zb=st=>{if(!st||st.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(st[1].type!=="int32")throw new Error("Invalid input type.")}}),Yc$1,Xc$1=L(()=>{ol$1(),gl$1(),xl$1(),Sl$1(),to$1(),ff$1(),bf(),Tf(),vf(),Sf(),Ef(),Ff(),Nf(),ro$1(),Uf(),ec(),uc$1(),fc$1(),bc$1(),yc$1(),_c$1(),Fc$1(),Nc$1(),Gc$1(),zc$1(),Wc$1(),oo$1(),Ii(),jc$1(),Ni(),Yc$1=[["Abs","","6+",Al$1],["Acos","","7+",Pl$1],["Add","","7+",il$1],["And","","7+",al$1],["Asin","","7+",El$1],["Atan","","7+",Dl$1],["AveragePool","","7+",Vf,Wf],["BatchNormalization","","7+",rl$1,nl$1],["Cast","","6+",yl$1,Tl$1],["Ceil","","6+",Fl$1],["Clip","","6-10",_i,Ll$1],["Clip","","11+",Cl$1],["Concat","","4+",_l$1,Il$1],["Conv","","1+",Li$1,Ci],["ConvTranspose","","1+",uf$1,lf$1],["Cos","","7+",$l$1],["Div","","7+",sl$1],["Dropout","","7+",Oi$1],["DepthToSpace","","1+",hf$1,mf$1],["Equal","","7+",ul$1],["Elu","","6+",kl$1,Bl$1],["Exp","","6+",Nl$1],["Flatten","","1+",gf,yf],["Floor","","6+",Rl$1],["FusedConv","com.microsoft","1+",Li$1,Ci],["Gather","","1+",xf,wf],["Gemm","","7-10",Fi$1,Of],["Gemm","","11+",Fi$1,If],["GlobalAveragePool","","1+",qf,jf],["GlobalMaxPool","","1+",Zf],["Greater","","7+",ll$1],["Identity","","1+",Oi$1],["ImageScaler","","1+",Af,Pf],["InstanceNormalization","","6+",Lf,Cf],["LeakyRelu","","6+",Ml$1,Gl$1],["Less","","7+",fl$1],["LRN","","1+",$f,kf],["Log","","6+",Ul$1],["MatMul","","1+",ef$1,tf$1],["MaxPool","","1+",Yf,Xf],["Mul","","7+",cl$1],["Neg","","6+",zl$1],["Not","","1+",Vl$1],["Or","","7+",pl$1],["Pad","","2-10",$i,Rf],["Pad","","11+",Mf,Gf],["Pow","","7+",dl$1],["PRelu","","7+",hl$1],["ReduceLogSum","","1+",ac$1,er],["ReduceMax","","1+",nc$1,er],["ReduceMean","","1+",rc,er],["ReduceMin","","1+",oc$1,er],["ReduceProd","","1+",ic$1,er],["ReduceSum","","1-12",tc,er],["ReduceSumSquare","","1+",sc$1,er],["Relu","","6+",Wl$1],["Reshape","","5+",lc$1],["Resize","","10",Mi$1,hc],["Resize","","11+",Mi$1,mc$1],["Shape","","1+",gc$1],["Sigmoid","","6+",Hl$1],["Sin","","7+",ql$1],["Slice","","10+",vc$1],["Slice","","1-9",Tc$1,xc$1],["Softmax","","1-12",Ac$1,Pc$1],["Softmax","","13+",Dc$1,Ec$1],["Split","","2-12",kc$1,Bc$1],["Sqrt","","6+",jl$1],["Squeeze","","1-12",Ui$1,Mc$1],["Squeeze","","13+",Rc$1],["Sub","","7+",ml$1],["Sum","","6+",Uc$1],["Tan","","7+",Yl$1],["Tanh","","6+",Xl$1],["Tile","","6+",Vc$1],["Transpose","","1+",wr,pf$1],["Upsample","","7-8",ki,pc$1],["Upsample","","9",ki,dc$1],["Unsqueeze","","1-12",zi$1,qc$1],["Unsqueeze","","13+",Hc$1],["Xor","","7+",bl$1]]});function Jc$1(st){let at={},pt;for(;(pt=Kc$1.exec(st))!==null;){let vt=pt[3].split(",").map(wt=>{let $t=wt.trim().split(" ");return $t&&$t.length===2?{type:$t[0],name:$t[1]}:null}).filter(wt=>wt!==null);at[pt[2]]={params:vt,body:pt[4]}}for(let vt in at){let wt=Vb.replace("__FUNC__",vt),$t=new RegExp(wt,"gm");for(;(pt=$t.exec(st))!==null;){let Tt=pt[1],Lt=pt[2],Ft=pt[3].split(","),Ct=Tt?`${Tt} ${Lt};`:"",Ht=at[vt].body,Gt="";at[vt].params.forEach((qt,Kt)=>{qt&&(Gt+=`${qt.type} ${qt.name} = ${Ft[Kt]};
`)}),Ht=`${Gt}
 ${Ht}`,Ht=Ht.replace("return",`${Lt} = `);let jt=`
      ${Ct}
      {
        ${Ht}
      }
      `;st=st.replace(pt[0],jt)}}return st=st.replace(Kc$1,""),st}var Kc$1,Vb,Zc$1=L(()=>{Kc$1=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,Vb="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"});function Mr(st,at){let pt=[],vt=[];for(let wt=0;wt<st.length;++wt)st[wt]!==1&&(pt.push(st[wt]),vt.push(wt));return{newShape:pt,keptDims:vt}}function qb(st){if(st.length===0)return 1;let at=st[0];for(let pt=1;pt<st.length;pt++)at*=st[pt];return at}function Qc$1(st){let at=Math.ceil(Math.sqrt(st));return[at,Math.ceil(st/at)]}var uo$1,Vi=L(()=>{lt$1(),fe$1(),uo$1=class{constructor(st){this.maxTextureSize=st}computeTextureWH(st,at){let pt=this.computeTexture(st,at);return at&&at.isPacked&&(pt[0]/=2,pt[1]/=2),at&&at.reverseWH?[pt[1],pt[0]]:pt}computeTexture(st,at){let pt=at&&at.isPacked;if(st.length===0)return pt?[2,2]:[1,1];let vt=this.maxTextureSize;if(at&&at.breakAxis!==void 0){let Tt=at.breakAxis>=st.length?1:st.slice(at.breakAxis).reduce((Ft,Ct)=>Ft*Ct),Lt=at.breakAxis<=0?1:st.slice(0,at.breakAxis).reduce((Ft,Ct)=>Ft*Ct);if(Tt>vt||Lt>vt)ce.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${st}, breakAxis:${at.breakAxis}`);else return[Tt,Lt]}let wt=st.slice(0);pt&&(vt=vt*2,wt=wt.map((Tt,Lt)=>Lt>=wt.length-2?wt[Lt]%2===0?wt[Lt]:wt[Lt]+1:wt[Lt]),wt.length===1&&(wt=[2,wt[0]])),wt.length!==2&&(wt=Mr(wt).newShape);let $t=qb(wt);return wt.length<=1&&$t<=vt?[1,$t]:wt.length===2&&wt[0]<=vt&&wt[1]<=vt?wt:wt.length===3&&wt[0]*wt[1]<=vt&&wt[2]<=vt?[wt[0]*wt[1],wt[2]]:wt.length===3&&wt[0]<=vt&&wt[1]*wt[2]<=vt?[wt[0],wt[1]*wt[2]]:wt.length===4&&wt[0]*wt[1]*wt[2]<=vt&&wt[3]<=vt?[wt[0]*wt[1]*wt[2],wt[3]]:wt.length===4&&wt[0]<=vt&&wt[1]*wt[2]*wt[3]<=vt?[wt[0],wt[1]*wt[2]*wt[3]]:pt?Qc$1($t/4).map(Tt=>Tt*2):Qc$1($t)}}}),lo$1,ep$1=L(()=>{fe$1(),Wt$1(),we$1(),Vi(),Bt$1(),lo$1=class extends dt{constructor(st){super(st)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let st="offsetToCoords";return{offsetToCoords:new R(`
      vec2 ${st}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){let st="coordsToOffset";return{coordsToOffset:new R(`
      int ${st}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let st=this.context.outputTextureLayout;return st.isPacked?this.getPackedOutputSamplingSnippet(st):this.getUnpackedOutputSamplingSnippet(st)}getPackedOutputSamplingSnippet(st){let at=st.unpackedShape,pt=[st.width,st.height],vt={},wt="getOutputCoords";switch(at.length){case 0:vt[wt]=this.getOutputScalarCoords();break;case 1:vt[wt]=this.getOutputPacked1DCoords(at,pt);break;case 2:vt[wt]=this.getOutputPacked2DCoords(at,pt);break;case 3:vt[wt]=this.getOutputPacked3DCoords(at,pt);break;default:vt[wt]=this.getOutputPackedNDCoords(at,pt)}let $t=`
      void setOutput(vec4 val) {
        ${H(this.context.glContext.version).output} = val;
      }
    `,Tt="floatTextureSetRGBA";return vt[Tt]=new R($t),vt}getUnpackedOutputSamplingSnippet(st){let at=st.unpackedShape,pt=[st.width,st.height],vt={},wt="getOutputCoords";switch(at.length){case 0:vt[wt]=this.getOutputScalarCoords();break;case 1:vt[wt]=this.getOutputUnpacked1DCoords(at,pt);break;case 2:vt[wt]=this.getOutputUnpacked2DCoords(at,pt);break;case 3:vt[wt]=this.getOutputUnpacked3DCoords(at,pt);break;case 4:vt[wt]=this.getOutputUnpacked4DCoords(at,pt);break;case 5:vt[wt]=this.getOutputUnpacked5DCoords(at,pt);break;case 6:vt[wt]=this.getOutputUnpacked6DCoords(at,pt);break;default:throw new Error(`Unsupported output dimensionality: ${at.length}`)}let $t=`
        void setOutput(float val) {
          ${H(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,Tt="floatTextureSetR";return vt[Tt]=new R($t),vt}getOutputScalarCoords(){return new R(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(st,at){let pt=at,vt="";return pt[0]===1?(vt=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${pt[1]}.0);
          }
        `,new R(vt)):pt[1]===1?(vt=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${pt[0]}.0);
          }
        `,new R(vt)):(vt=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${pt[0]}, ${pt[1]}));
          return 2 * (resTexRC.y * ${pt[0]} + resTexRC.x);
        }
      `,new R(vt))}getOutputPacked2DCoords(st,at){let pt="";if(hr$1.arraysEqual(st,at))return pt=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${at[0]}, ${at[1]}));
        }
      `,new R(pt);let vt=at,wt=Math.ceil(st[1]/2);return pt=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${vt[0]}, ${vt[1]}));

          int index = resTexRC.y * ${vt[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${wt}) * 2;
          int c = 2 * (index / ${wt});

          return ivec2(r, c);
        }
      `,new R(pt)}getOutputPacked3DCoords(st,at){let pt=[at[0],at[1]],vt=Math.ceil(st[2]/2),wt=vt*Math.ceil(st[1]/2),$t=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${pt[0]}, ${pt[1]}));
          int index = resTexRC.y * ${pt[0]} + resTexRC.x;

          int b = index / ${wt};
          index -= b * ${wt};

          // reverse r and c order for packed texture
          int r = imod(index, ${vt}) * 2;
          int c = 2 * (index / ${vt});

          return ivec3(b, r, c);
        }
      `;return new R($t)}getOutputPackedNDCoords(st,at){let pt=[at[0],at[1]],vt=Math.ceil(st[st.length-1]/2),wt=vt*Math.ceil(st[st.length-2]/2),$t=wt,Tt="",Lt="b, r, c";for(let Ct=2;Ct<st.length-1;Ct++)$t*=st[st.length-Ct-1],Tt=`
      int b${Ct} = index / ${$t};
      index -= b${Ct} * ${$t};
    `+Tt,Lt=`b${Ct}, `+Lt;let Ft=`
      ivec${st.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${pt[0]}, ${pt[1]}));
        int index = resTexRC.y * ${pt[0]} + resTexRC.x;

        ${Tt}

        int b = index / ${wt};
        index -= b * ${wt};

        // reverse r and c order for packed texture
        int r = imod(index, ${vt}) * 2;
        int c = 2 * (index / ${vt});

        return ivec${st.length}(${Lt});
      }
    `;return new R(Ft)}getOutputUnpacked1DCoords(st,at){let pt=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${at[0]}, ${at[1]}));
          return resTexRC.y * ${at[0]} + resTexRC.x;
        }
      `;return new R(pt)}getOutputUnpacked2DCoords(st,at){let pt=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${at[0]}, ${at[1]}));
          int index = resTexRC.y * ${at[0]} + resTexRC.x;
          int r = index / ${st[1]};
          int c = index - r * ${st[1]};
          return ivec2(r, c);
        }
      `;return new R(pt)}getOutputUnpacked3DCoords(st,at){let pt="",vt=st.length,wt=null;vt<2&&(wt=[]),wt=new Array(vt-1),wt[vt-2]=st[vt-1];for(let Lt=vt-3;Lt>=0;--Lt)wt[Lt]=wt[Lt+1]*st[Lt+1];let $t=["r","c","d"],Tt=wt.map((Lt,Ft)=>{let Ct=`int ${$t[Ft]} = index / ${Lt}`,Ht=Ft===wt.length-1?`int ${$t[Ft+1]} = index - ${$t[Ft]} * ${Lt}`:`index -= ${$t[Ft]} * ${Lt}`;return`${Ct}; ${Ht};`}).join("");return pt=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${at[0]}, ${at[1]}));
          int index = resTexRC.y * ${at[0]} + resTexRC.x;
          ${Tt}
          return ivec3(r, c, d);
        }
      `,new R(pt)}getOutputUnpacked4DCoords(st,at){let pt="",vt=st.length,wt=null;vt<2&&(wt=[]),wt=new Array(vt-1),wt[vt-2]=st[vt-1];for(let Lt=vt-3;Lt>=0;--Lt)wt[Lt]=wt[Lt+1]*st[Lt+1];let $t=["r","c","d","d2"],Tt=wt.map((Lt,Ft)=>{let Ct=`int ${$t[Ft]} = index / ${Lt}`,Ht=Ft===wt.length-1?`int ${$t[Ft+1]} = index - ${$t[Ft]} * ${Lt}`:`index -= ${$t[Ft]} * ${Lt}`;return`${Ct}; ${Ht};`}).join("");return pt=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${at[0]}, ${at[1]}));
          int index = resTexRC.y * ${at[0]} + resTexRC.x;
          ${Tt}
          return ivec4(r, c, d, d2);
        }
      `,new R(pt)}getOutputUnpacked5DCoords(st,at){let pt="",vt=st.length,wt=null;vt<2&&(wt=[]),wt=new Array(vt-1),wt[vt-2]=st[vt-1];for(let Lt=vt-3;Lt>=0;--Lt)wt[Lt]=wt[Lt+1]*st[Lt+1];let $t=["r","c","d","d2","d3"],Tt=wt.map((Lt,Ft)=>{let Ct=`int ${$t[Ft]} = index / ${Lt}`,Ht=Ft===wt.length-1?`int ${$t[Ft+1]} = index - ${$t[Ft]} * ${Lt}`:`index -= ${$t[Ft]} * ${Lt}`;return`${Ct}; ${Ht};`}).join("");return pt=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${at[0]}, ${at[1]}));
          int index = resTexRC.y * ${at[0]} + resTexRC.x;
          ${Tt}
          return ivec5(r, c, d, d2, d3);
        }
      `,new R(pt)}getOutputUnpacked6DCoords(st,at){let pt="",vt=st.length,wt=null;vt<2&&(wt=[]),wt=new Array(vt-1),wt[vt-2]=st[vt-1];for(let Lt=vt-3;Lt>=0;--Lt)wt[Lt]=wt[Lt+1]*st[Lt+1];let $t=["r","c","d","d2","d3","d4"],Tt=wt.map((Lt,Ft)=>{let Ct=`int ${$t[Ft]} = index / ${Lt}`,Ht=Ft===wt.length-1?`int ${$t[Ft+1]} = index - ${$t[Ft]} * ${Lt}`:`index -= ${$t[Ft]} * ${Lt}`;return`${Ct}; ${Ht};`}).join("");return pt=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${at[0]}, ${at[1]}));
         int index = resTexRC.y * ${at[0]} + resTexRC.x;
         ${Tt}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new R(pt)}getCommonUtilFuncs(){let st={},at="uvFromFlat";st[at]=new R(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),at="packedUVfrom1D",st[at]=new R(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),at="packedUVfrom2D",st[at]=new R(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),at="packedUVfrom3D",st[at]=new R(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),at="sampleTexture";let pt=H(this.context.glContext.version);return st[at]=new R(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${pt.texture2D}(textureSampler, uv).r;
        }`),st}getInputsSamplingSnippets(){let st={},at=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((pt,vt)=>{let wt=this.context.inputTextureLayouts[vt],$t=Yn$1(pt);wt.isPacked?st[$t]=this.getPackedSamplerFromInput($t,pt,wt):st[$t]=this.getUnpackedSamplerFromInput($t,pt,wt);let Tt=Gu$1(pt);wt.unpackedShape.length<=at.unpackedShape.length&&(wt.isPacked?st[Tt]=this.getPackedSamplerAtOutputCoords(Tt,wt,at,pt):st[Tt]=this.getUnpackedSamplerAtOutputCoords(Tt,wt,at,pt))}),st}getPackedSamplerAtOutputCoords(st,at,pt,vt){let wt=at.unpackedShape,$t=pt.unpackedShape,Tt=Yn$1(vt),Lt=wt.length,Ft=$t.length,Ct=Ze$1.getBroadcastDims(wt,$t),Ht=Qe(Ft),Gt=Ft-Lt,jt,qt=Dt$1();Lt===0?jt="":Ft<2&&Ct.length>=1?jt="coords = 0;":jt=Ct.map(rr=>`coords.${qt[rr+Gt]} = 0;`).join(`
`);let Kt="";Ft<2&&Lt>0?Kt="coords":Kt=wt.map((rr,Hr)=>`coords.${qt[Hr+Gt]}`).join(", ");let An="return outputValue;",Sn=U$1.size(wt)===1,wn=U$1.size($t)===1;if(Lt===1&&!Sn&&!wn)An=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(Sn&&!wn)Ft===1?An=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:An=`
          return vec4(outputValue.x);
        `;else if(Ct.length){let rr=Lt-2,Hr=Lt-1;Ct.indexOf(rr)>-1&&Ct.indexOf(Hr)>-1?An="return vec4(outputValue.x);":Ct.indexOf(rr)>-1?An="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":Ct.indexOf(Hr)>-1&&(An="return vec4(outputValue.xx, outputValue.zz);")}let In=`
        int lastDim = coords.${qt[Ft-1]};
        coords.${qt[Ft-1]} = coords.${qt[Ft-2]};
        coords.${qt[Ft-2]} = lastDim;
      `,tr=`
      vec4 ${st}() {
        ${Ht} coords = getOutputCoords();
        ${In}
        ${jt}
        vec4 outputValue = ${Tt}(${Kt});
        ${An}
      }
    `;return new R(tr,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(st,at,pt,vt){let wt=[pt.width,pt.height],$t=[at.width,at.height],Tt=at.unpackedShape.length,Lt=pt.unpackedShape.length,Ft=at.unpackedShape,Ct=pt.unpackedShape,Ht=Yn$1(vt);if(Tt===Lt&&hr$1.arraysEqual($t,wt)){let In=`
          float ${st}() {
            return sampleTexture(${vt}, TexCoords);
          }
        `;return new R(In,["coordinates.sampleTexture"])}let Gt=Qe(Lt),jt=Ze$1.getBroadcastDims(Ft,Ct),qt=Lt-Tt,Kt,An=Dt$1();Tt===0?Kt="":Lt<2&&jt.length>=1?Kt="coords = 0;":Kt=jt.map(In=>`coords.${An[In+qt]} = 0;`).join(`
`);let Sn="";Lt<2&&Tt>0?Sn="coords":Sn=at.unpackedShape.map((In,tr)=>`coords.${An[tr+qt]}`).join(", ");let wn=`
        float ${st}() {
          ${Gt} coords = getOutputCoords();
          ${Kt}
          return ${Ht}(${Sn});
        }
      `;return new R(wn,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(st,at,pt){switch(pt.unpackedShape.length){case 0:return this.getPackedSamplerScalar(st,at);case 1:return this.getPackedSampler1D(st,at,pt);case 2:return this.getPackedSampler2D(st,at,pt);case 3:return this.getPackedSampler3D(st,at,pt);default:return this.getPackedSamplerND(st,at,pt)}}getUnpackedSamplerFromInput(st,at,pt){let vt=pt.unpackedShape;switch(vt.length){case 0:return this.getUnpackedSamplerScalar(st,at,pt);case 1:return this.getUnpackedSampler1D(st,at,pt);case 2:return this.getUnpackedSampler2D(st,at,pt);case 3:return this.getUnpackedSampler3D(st,at,pt);case 4:return this.getUnpackedSampler4D(st,at,pt);case 5:return this.getUnpackedSampler5D(st,at,pt);case 6:return this.getUnpackedSampler6D(st,at,pt);default:throw new Error(`Unsupported dimension ${vt.length}-D`)}}getPackedSamplerScalar(st,at){let pt=H(this.context.glContext.version),vt=`
          vec4 ${st}() {
            return ${pt.texture2D}(${at}, halfCR);
          }
        `;return new R(vt)}getPackedSampler1D(st,at,pt){let vt=[pt.width,pt.height],wt=[vt[1],vt[0]],$t=H(this.context.glContext.version),Tt=`vec4 ${st}(int index) {
      vec2 uv = packedUVfrom1D(
      ${wt[0]}, ${wt[1]}, index);
      return ${$t.texture2D}(${at}, uv);
    }`;return new R(Tt,["coordinates.packedUVfrom1D"])}getPackedSampler2D(st,at,pt){let vt=pt.unpackedShape,wt=[pt.width,pt.height],$t=H(this.context.glContext.version),Tt=wt[0],Lt=wt[1];if(wt!=null&&hr$1.arraysEqual(vt,wt)){let Gt=`vec4 ${st}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${Lt}.0, ${Tt}.0);
        return ${$t.texture2D}(${at}, uv);
      }`;return new R(Gt)}let Ft=wt,Ct=Math.ceil(vt[1]/2),Ht=`vec4 ${st}(int row, int col) {
      vec2 uv = packedUVfrom2D(${Ft[1]}, ${Ft[0]}, ${Ct}, row, col);
      return ${$t.texture2D}(${at}, uv);
    }`;return new R(Ht,["coordinates.packedUVfrom2D"])}getPackedSampler3D(st,at,pt){let vt=pt.unpackedShape,wt=[pt.width,pt.height],$t=[wt[0],wt[1]],Tt=H(this.context.glContext.version);if(vt[0]===1){let jt=vt.slice(1),qt=[1,2],Kt=$r(vt,jt),An=["b","row","col"],Sn=JSON.parse(JSON.stringify(pt));Sn.unpackedShape=Kt;let wn=this.getPackedSamplerFromInput(st,at,Sn),In=`${wn.routineBody}
      vec4 ${st}(int b, int row, int col) {
        return ${st}(${kr$1(An,qt)});
      } `;return new R(In,wn.dependencies)}let Lt=$t[0],Ft=$t[1],Ct=Math.ceil(vt[2]/2),Ht=Ct*Math.ceil(vt[1]/2),Gt=`vec4 ${st}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${Ft}, ${Lt}, ${Ht}, ${Ct}, b, row, col);
      return ${Tt.texture2D}(${at}, uv);}`;return new R(Gt,["coordinates.packedUVfrom3D"])}getPackedSamplerND(st,at,pt){let vt=pt.unpackedShape,wt=vt.length,$t=[pt.width,pt.height],Tt=H(this.context.glContext.version),Lt=[$t[0],$t[1]],Ft=Lt[1],Ct=Lt[0],Ht=Math.ceil(vt[wt-1]/2),Gt=Ht*Math.ceil(vt[wt-2]/2),jt="int b, int row, int col",qt=`b * ${Gt} + (row / 2) * ${Ht} + (col / 2)`;for(let An=2;An<wt-1;An++)jt=`int b${An}, `+jt,Gt*=vt[wt-An-1],qt=`b${An} * ${Gt} + `+qt;let Kt=`vec4 ${st}(${jt}) {
      int index = ${qt};
      int texR = index / ${Ct};
      int texC = index - texR * ${Ct};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${Ct}, ${Ft});
      return ${Tt.texture2D}(${at}, uv);
    }`;return new R(Kt)}getUnpackedSamplerScalar(st,at,pt){let[vt,wt]=[pt.width,pt.height];if(vt===1&&wt===1){let Tt=`
          float ${st}() {
            return sampleTexture(${at}, halfCR);
          }
        `;return new R(Tt,["coordinates.sampleTexture"])}let $t=`
        float ${st}() {
          int offset_${at} = coordsToOffset(TexCoords, ${vt}, ${wt});
          vec2 uv = uvFromFlat(${vt}, ${wt}, offset_${at});
          return sampleTexture(${at}, uv);
        }
      `;return new R($t,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(st,at,pt){let vt=pt.width,wt=pt.height;if(wt===1&&vt===1){let Tt=`
        float ${st}(int index) {
          return sampleTexture(${at}, halfCR);
        }
      `;return new R(Tt,["coordinates.sampleTexture"])}if(wt===1){let Tt=`
          float ${st}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${vt}.0, 0.5);
            return sampleTexture(${at}, uv);
          }
        `;return new R(Tt,["coordinates.sampleTexture"])}if(vt===1){let Tt=`
          float ${st}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${wt}.0);
            return sampleTexture(${at}, uv);
          }
        `;return new R(Tt,["coordinates.sampleTexture"])}let $t=`
        float ${st}(int index) {
          vec2 uv = uvFromFlat(${vt}, ${wt}, index);
          return sampleTexture(${at}, uv);
        }
      `;return new R($t,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(st,at,pt){let vt=pt.unpackedShape,wt=[pt.height,pt.width];if(wt!=null&&hr$1.arraysEqual(vt,wt)){let Gt=wt[1],jt=wt[0],qt=`
          float ${st}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${Gt}.0, ${jt}.0);
            return sampleTexture(${at}, uv);
          }
        `;return new R(qt,["coordinates.sampleTexture"])}let{newShape:$t,keptDims:Tt}=Mr(vt),Lt=$t;if(Lt.length<vt.length){let Gt=$r(vt,Lt),jt=JSON.parse(JSON.stringify(pt));jt.unpackedShape=Gt;let qt=["col","row"],Kt=`
          ${this.getUnpackedSamplerFromInput(st,at,jt).routineBody}
          float ${st}(int row, int col) {
            return ${st}(${kr$1(qt,Tt)});
          }
        `;return new R(Kt,["coordinates.sampleTexture"])}let Ft=wt[1],Ct=wt[0];if(Ct===1){let Gt=`
          float ${st}(int row, int col) {
            int offset_${at} = coordsToOffset(TexCoords, ${Ft}, ${Ct});
            float index = dot(vec3(row, col, offset_${at}), vec3(${vt[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${Ft}.0);
            return sampleTexture(${at}, uv);
          }
        `;return new R(Gt,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(Ft===1){let Gt=`
          float ${st}(int row, int col) {
            int offset_${at} = coordsToOffset(TexCoords, ${Ft}, ${Ct});
            float index = dot(vec3(row, col, offset_${at}), vec3(${vt[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${Ct}.0, 0.5);
            return sampleTexture(${at}, uv);
          }
        `;return new R(Gt,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let Ht=`
        float ${st}(int row, int col) {
          int index = col * ${vt[1]} + row;
          vec2 uv = uvFromFlat(${Ft}, ${Ct}, index);
          return sampleTexture(${at}, uv);
        }
      `;return new R(Ht,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(st,at,pt){let vt=pt.unpackedShape,wt=vt[1]*vt[2],$t=vt[2],{newShape:Tt,keptDims:Lt}=Mr(vt),Ft=Tt;if(Ft.length<vt.length){let jt=$r(vt,Ft),qt=["batch","col","row"],Kt=JSON.parse(JSON.stringify(pt));Kt.unpackedShape=jt;let An=this.getUnpackedSamplerFromInput(st,at,Kt),Sn=Lt.reverse(),wn=`
          ${An.routineBody}
          float ${st}(int batch, int row, int col) {
            return ${st}(${kr$1(qt,Sn)});
          }
        `;return new R(wn,An.dependencies)}let Ct=pt.width,Ht=pt.height,Gt=`
          float ${st}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${wt} + col * ${$t} + row;
            vec2 uv = uvFromFlat(${Ct}, ${Ht}, index);
            return sampleTexture(${at}, uv);
          }
      `;return new R(Gt,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(st,at,pt){let vt=pt.unpackedShape,wt=vt[3],$t=vt[2]*wt,Tt=vt[1]*$t,Lt=pt.width,Ft=pt.height,Ct=`
        float ${st}(int row, int col, int depth, int depth2) {
          int index = row * ${Tt} + col * ${$t} +
              depth2 * ${wt} + depth;
          vec2 uv = uvFromFlat(${Lt}, ${Ft}, index);
          return sampleTexture(${at}, uv);
        }
      `;return new R(Ct,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(st,at,pt){let vt=pt.unpackedShape,wt=vt[4],$t=vt[3]*wt,Tt=vt[2]*$t,Lt=vt[1]*Tt,{newShape:Ft,keptDims:Ct}=Mr(vt);if(Ft.length<vt.length){let qt=$r(vt,Ft),Kt=["row","col","depth","depth2","depth3"],An=JSON.parse(JSON.stringify(pt));An.unpackedShape=qt;let Sn=`
          ${this.getUnpackedSamplerFromInput(st,at,An).routineBody}
          float ${st}(int row, int col, int depth, int depth2, int depth3) {
            return ${st}(${kr$1(Kt,Ct)});
          }
        `;return new R(Sn,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let Ht=pt.width,Gt=pt.height,jt=`
        float ${st}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${Lt} + col * ${Tt} + depth * ${$t} +
          depth3 * ${wt} + depth2;
          vec2 uv = uvFromFlat(${Ht}, ${Gt}, index);
          return sampleTexture(${at}, uv);
        }
      `;return new R(jt,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(st,at,pt){let vt=pt.unpackedShape,wt=vt[5],$t=vt[4]*wt,Tt=vt[3]*$t,Lt=vt[2]*Tt,Ft=vt[1]*Lt,{newShape:Ct,keptDims:Ht}=Mr(vt);if(Ct.length<vt.length){let Kt=$r(vt,Ct),An=["row","col","depth","depth2","depth3","depth4"],Sn=JSON.parse(JSON.stringify(pt));Sn.unpackedShape=Kt;let wn=`
            ${this.getUnpackedSamplerFromInput(st,at,Sn).routineBody}
            float ${st}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${st}(${kr$1(An,Ht)});
            }
          `;return new R(wn,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let Gt=pt.width,jt=pt.height,qt=`
          float ${st}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${Ft} + col * ${Lt} + depth * ${Tt} +
            depth2 * ${$t} + depth3 * ${wt} + depth4;
            vec2 uv = uvFromFlat(${Gt}, ${jt}, index);
            return sampleTexture(${at}, uv);
          }
        `;return new R(qt,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let st=this.context.outputTextureLayout,at=st.shape.length,pt=st.strides,vt=st.width,wt=st.height,$t=[];for(let Lt=0;Lt<at-1;++Lt)$t.push(`
        c[${Lt}] = offset / ${pt[Lt]};`),$t.push(`
        offset -= c[${Lt}] * ${pt[Lt]};`);$t.push(`
        c[${at-1}] = offset;`);let Tt=`
      void toVec(vec2 texCoords, out int c[${at}]) {
        int offset = coordsToOffset(texCoords, ${vt}, ${wt});
        ${$t.join("")}
      }
      void toVec(int offset, out int c[${at}]) {
        ${$t.join("")}
      }
    `;return{toVec:new R(Tt,["coordinates.coordsToOffset"])}}valueFrom(){let st={};return this.context.programInfo.inputNames.forEach((at,pt)=>{let vt=this.context.inputTextureLayouts[pt],wt=(vt.unpackedShape.length>0?vt.unpackedShape:vt.shape).length,$t=`_${at}`;st[$t]=new R(this.getValueFromSingle(at,wt,vt.width,vt.height,!1),[`shapeUtils.indicesToOffset${$t}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),$t=$t+"_T",st[$t]=new R(this.getValueFromSingle(at,wt,vt.width,vt.height,!0),[`shapeUtils.indicesToOffset${$t}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),st}getValueFromSingle(st,at,pt,vt,wt){let $t=`_${st}`;wt&&($t=$t+"_T");let Tt=H(this.context.glContext.version);return`
        float ${$t}(int m[${at}]) {
          int offset = indicesToOffset${$t}(m);
          vec2 coords = offsetToCoords(offset, ${pt}, ${vt});
          float value = getColorAsFloat(${Tt.texture2D}(${st}, coords));
          return value;
        }
        `}getPackedValueFrom(st,at,pt,vt,wt){let $t=`_${st}_Pack`;wt&&($t=$t+"_T");let Tt=H(this.context.glContext.version);return`
        vec4 ${$t}(int m[${at}]) {
          int offset = indicesToOffset_${st}(m);
          vec2 coords = offsetToCoords(offset, ${pt}, ${vt});
          return ${Tt.texture2D}(${st}, coords);
        }
        `}}}),fo$1,tp$1=L(()=>{Wt$1(),fo$1=class JS extends dt{constructor(at){super(at)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new R(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new R(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let at=JS.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new R(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${at}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let at=JS.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new R(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${at}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let at=new ArrayBuffer(4),pt=new Uint32Array(at),vt=new Uint8Array(at);if(pt[0]=3735928559,vt[0]===239)return!0;if(vt[0]===222)return!1;throw new Error("unknown endianness")}}}),co$1,rp$1=L(()=>{Wt$1(),we$1(),co$1=class extends dt{constructor(st){super(st)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let st=H(this.context.glContext.version);return{setFragColor:new R(`
        void setFragColor(float value) {
            ${st.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new R(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}}),po$1,np$1=L(()=>{Wt$1(),po$1=class _$ extends dt{constructor(at){super(at)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let at=this.context.outputTextureLayout.shape.length,pt={};return this.context.programInfo.inputNames.forEach((vt,wt)=>{let $t=this.context.inputTextureLayouts[wt].unpackedShape;if($t.length<=at){let Tt=$t.length,Lt=at-Tt,Ft=`bcastIndices_${vt}`,Ct="";for(let Gt=0;Gt<Tt;++Gt)Ct+=`
          realIndices[${Gt}] = int( mod(float(bcastedIndices[${Lt+Gt}]), ${$t[Gt]}.0) );
          `;let Ht=`
        void ${Ft} (int bcastedIndices[${at}], out int realIndices[${Tt}]) {
          ${Ct}
        }
        `;pt[Ft]=new R(Ht)}}),pt}bcastMatmulIndex(){let at=this.context.outputTextureLayout.shape.length,pt={};return this.context.programInfo.inputNames.forEach((vt,wt)=>{let $t=this.context.inputTextureLayouts[wt].shape;if(!($t.length<2||$t.length>at)){let Tt=$t.length,Lt=at-Tt,Ft=`bcastMatmulIndices_${vt}`,Ct="";for(let Gt=0;Gt<Tt-2;++Gt)Ct+=`
          realIndices[${Gt}] = int( mod(float(bcastedIndices[${Lt+Gt}]), ${$t[Gt]}.0) );
          `;let Ht=`
        void ${Ft}(int bcastedIndices[${at}], out int realIndices[${Tt}]) {
          ${Ct}
          realIndices[${Tt-1}] = bcastedIndices[${at-1}];
          realIndices[${Tt-2}] = bcastedIndices[${at-2}];
        }
        `;pt[Ft]=new R(Ht)}}),pt}indicesToOffset(){let at={};return this.context.programInfo.inputNames.forEach((pt,vt)=>{let wt=this.context.inputTextureLayouts[vt].shape,$t=this.context.inputTextureLayouts[vt].strides,Tt=wt.length,Lt=`indicesToOffset_${pt}`;at[Lt]=new R(_$.indexToOffsetSingle(Lt,Tt,$t)),Lt=`indicesToOffset_${pt}_T`,at[Lt]=new R(_$.indexToOffsetSingle(Lt,Tt,$t.slice().reverse()))}),at}static indexToOffsetSingle(at,pt,vt){let wt="";for(let $t=pt-1;$t>=0;--$t)wt+=`
        offset += indices[${$t}] * ${vt[$t]};
        `;return`
      int ${at}(int indices[${pt}]) {
        int offset = 0;
        ${wt}
        return offset;
      }
      `}offsetToIndices(){let at={};return this.context.programInfo.inputNames.forEach((pt,vt)=>{let wt=this.context.inputTextureLayouts[vt].shape,$t=this.context.inputTextureLayouts[vt].strides,Tt=wt.length,Lt=`offsetToIndices_${pt}`;at[Lt]=new R(_$.offsetToIndicesSingle(Lt,Tt,$t)),Lt=`offsetToIndices_${pt}_T`,at[Lt]=new R(_$.offsetToIndicesSingle(Lt,Tt,$t.slice().reverse()))}),at}static offsetToIndicesSingle(at,pt,vt){let wt=[];for(let $t=0;$t<pt-1;++$t)wt.push(`
      indices[${$t}] = offset / ${vt[$t]};`),wt.push(`
        offset -= indices[${$t}] * ${vt[$t]};`);return wt.push(`
      indices[${pt-1}] = offset;`),`
      void ${at}(int offset, out int indices[${pt}]) {
        ${wt.join("")}
      }
      `}incrementIndices(){let at={};return this.context.programInfo.inputNames.forEach((pt,vt)=>{let wt=this.context.inputTextureLayouts[vt].shape,$t=wt.length,Tt=`incrementIndices_${pt}`,Lt="";for(let Ct=0;Ct<$t;++Ct)Lt+=`
        shape[${Ct}] = ${wt[Ct]};`;let Ft=`
        void ${Tt}(int axis, out int indices[${$t}]) {
          int shape[${$t}];
          ${Lt};
          for(int i = ${$t} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;at[Tt]=new R(Ft)}),at}}}),ho$1,op$1=L(()=>{Wt$1(),ho$1=class extends dt{constructor(st){super(st)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let st=this.context.outputTextureLayout.shape.length,at={add:"+=",sub:"-=",mul:"*=",div:"/="},pt={};for(let vt in at){let wt=`${vt}Vec`,$t="";for(let Lt=0;Lt<st;++Lt)$t+=`
          dest[${Lt}] ${at[vt]} src[${Lt}];
          `;let Tt=`
        void ${wt}(int src[${st}], out int dest[${st}]) {
          ${$t}
        }
        `;pt[wt]=new R(Tt)}return pt}copyVec(){let st=this.context.outputTextureLayout.shape.length,at="";for(let vt=0;vt<st;++vt)at+=`
        dest[${vt}] = src[${vt}];
        `;let pt=`
      void copyVec(int src[${st}], out int dest[${st}]) {
        ${at}
      }
      `;return{copyVec:new R(pt)}}setVecItem(){let st=this.context.outputTextureLayout.shape.length,at=`
        if(index < 0)
            index =${st} + index;
        if (index == 0)
            m[0] = value;
        `;for(let vt=1;vt<st-1;++vt)at+=`
        else if (index == ${vt})
            m[${vt}] = value;
            `;at+=`
        else
            m[${st-1}] = value;
        `;let pt=`
      void setVecItem(out int m[${st}], int index, int value) {
        ${at}
      }
        `;return{setVecItem:new R(pt)}}getVecItem(){let st=this.context.outputTextureLayout.shape.length,at=`
        if(index < 0)
            index = ${st} + index;
        if (index == 0)
            return m[0];
      `;for(let vt=1;vt<st-1;++vt)at+=`
        else if (index == ${vt})
            return m[${vt}];
      `;at+=`
        else
            return m[${st-1}];
        `;let pt=`
      int getVecItem(int m[${st}], int index) {
        ${at}
      }
    `;return{getVecItem:new R(pt)}}}}),Wi$1,ip$1=L(()=>{ep$1(),tp$1(),rp$1(),np$1(),op$1(),Wi$1={encoding:fo$1,fragcolor:co$1,vec:ho$1,shapeUtils:po$1,coordinates:lo$1}}),mo$1,ap$1=L(()=>{Wt$1(),Zc$1(),ip$1(),we$1(),mo$1=class{constructor(st,at,pt,vt){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new Zn$1(st,at,pt,vt),Object.keys(Wi$1).forEach($t=>{let Tt=new Wi$1[$t](this.context);this.libs[$t]=Tt});let wt=this.glslLibRoutineDependencyGraph;for(let $t in this.libs){let Tt=this.libs[$t].getFunctions();for(let Lt in Tt){let Ft=$t+"."+Lt,Ct;wt[Ft]?(Ct=wt[Ft],Ct.routineBody=Tt[Lt].routineBody):(Ct=new cn(Ft,Tt[Lt].routineBody),wt[Ft]=Ct);let Ht=Tt[Lt].dependencies;if(Ht)for(let Gt=0;Gt<Ht.length;++Gt)if(wt[Ht[Gt]])Ct.addDependency(wt[Ht[Gt]]);else{let jt=new cn(Ht[Gt]);wt[Ht[Gt]]=jt,Ct.addDependency(jt)}}}}preprocess(){let st=this.context.programInfo,at=st.shaderSource;return this.context.programInfo.hasMain||(at=`${at}
      ${Mu$1(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),at=Jc$1(at),`${Ru$1(this.context.glContext.version)}
    ${this.getUniforms(st.inputNames,st.variables)}
    ${this.getImports(at)}
    ${at}`}getImports(st){let at=this.selectGlslLibRoutinesToBeIncluded(st);if(at.length===0)return"";let pt="";for(let vt=0;vt<at.length;++vt)if(at[vt].routineBody)pt+=at[vt].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${at[vt].name}`);return pt}selectGlslLibRoutinesToBeIncluded(st){let at=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(pt=>{let vt=pt.split(".")[1];st.indexOf(vt)!==-1&&at.push(this.glslLibRoutineDependencyGraph[pt])}),Qn$1.returnOrderedNodes(at)}getUniforms(st,at){let pt=[];if(st)for(let vt of st)pt.push(`uniform sampler2D ${vt};`);if(at)for(let vt of at)pt.push(`uniform ${vt.type} ${vt.name}${vt.arrayLength?`[${vt.arrayLength}]`:""};`);return pt.join(`
`)}}}),bo$1,sp$1=L(()=>{Ot$1(),lt$1(),ap$1(),we$1(),bo$1=class{constructor(st,at,pt){this.profiler=st,this.glContext=at,this.textureLayoutStrategy=pt,this.repo=new Map,this.attributesBound=!1}getArtifact(st){return this.repo.get(st)}setArtifact(st,at){this.repo.set(st,at)}run(st,at,pt){this.profiler.event("op",`ProgramManager.run ${st.programInfo.name??"unknown kernel"}`,()=>{let vt=this.glContext.gl,wt=st.program;vt.useProgram(wt);try{this.bindOutput(pt),this.attributesBound||this.bindAttributes(st.attribLocations),this.bindUniforms(st.uniformLocations,st.programInfo.variables??[],at)}catch($t){throw ce.error("ProgramManager",st.programInfo.shaderSource),$t}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(st=>this.glContext.deleteProgram(st.program))}build(st,at,pt){return this.profiler.event("backend","ProgramManager.build",()=>{let vt=new mo$1(this.glContext,st,at,pt),wt=vt.preprocess(),$t=this.compile(wt);return{programInfo:st,program:$t,uniformLocations:this.getUniformLocations($t,vt.context.programInfo.inputNames,vt.context.programInfo.variables),attribLocations:this.getAttribLocations($t)}})}compile(st){if(!this.vertexShader){ce.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let vt=Nu$1(this.glContext.version);this.vertexShader=this.glContext.compileShader(vt,this.glContext.gl.VERTEX_SHADER)}Z.debug&&ce.verbose("ProrgramManager",`FragShader:
${st}
`);let at=this.glContext.compileShader(st,this.glContext.gl.FRAGMENT_SHADER),pt=this.glContext.createProgram(this.vertexShader,at);return this.glContext.deleteShader(at),pt}bindOutput(st){let at=st.width,pt=st.height;ce.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${at}/${pt}, shape=${st.shape}, type=${st.tensor.type}`),this.glContext.attachFramebuffer(st.texture,at,pt)}bindAttributes(st){let at=st.position,pt=st.textureCoord;this.glContext.setVertexAttributes(at,pt),this.attributesBound=!0}bindUniforms(st,at,pt){var $t;let vt=this.glContext.gl,wt=0;for(let{name:Tt,type:Lt,location:Ft,arrayLength:Ct}of st){let Ht=($t=at.find(Gt=>Gt.name===Tt))==null?void 0:$t.data;if(Lt!=="sampler2D"&&!Ht)throw new Error(`variable '${Tt}' does not have data defined in program info`);switch(Lt){case"sampler2D":this.bindTexture(pt[wt],Ft,wt),wt++;break;case"float":Ct?vt.uniform1fv(Ft,Ht):vt.uniform1f(Ft,Ht);break;case"int":Ct?vt.uniform1iv(Ft,Ht):vt.uniform1i(Ft,Ht);break;default:throw new Error(`Uniform not implemented: ${Lt}`)}}}bindTexture(st,at,pt){this.glContext.bindTextureToUniform(st.texture,pt,at)}getAttribLocations(st){return{position:this.getAttribLocation(st,"position"),textureCoord:this.getAttribLocation(st,"textureCoord")}}getUniformLocations(st,at,pt){let vt=[];if(at)for(let wt of at)vt.push({name:wt,type:"sampler2D",location:this.getUniformLocation(st,wt)});if(pt)for(let wt of pt)vt.push({...wt,location:this.getUniformLocation(st,wt.name)});return vt}getUniformLocation(st,at){let pt=this.glContext.gl.getUniformLocation(st,at);if(pt===null)throw new Error(`Uniform ${at} not found.`);return pt}getAttribLocation(st,at){return this.glContext.gl.getAttribLocation(st,at)}}}),go$1,up$1=L(()=>{lt$1(),ln(),go$1=class{constructor(st,at,pt,vt){this.glContext=st,this.layoutStrategy=at,this.profiler=pt,this.config=vt,this.pendingRead=new Map,vt.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(st,at,pt,vt){let wt=this.toEncoderType(st),$t=this.glContext.getEncoder(wt,at.channels||1,vt);if(at.isPacked&&vt===1)throw new Error("not implemented");let Tt=at.width,Lt=at.height,Ft,Ct;if(this.config.reuseTextures){Ft=`${Tt}x${Lt}_${$t.format}_${$t.internalFormat}_${$t.textureType}`,Ct=this.inUseTextures.get(Ft),Ct||(Ct=[],this.inUseTextures.set(Ft,Ct));let Gt=this.idleTextures.get(Ft);if(Gt&&Gt.length>0){let jt=Gt.pop();return Ct.push(jt),vt===1&&this.glContext.updateTexture(jt,Tt,Lt,$t,this.toTextureData(st,pt)),jt}}ce.verbose("TextureManager",`Creating new texture of size ${at.width}x${at.height}`);let Ht=this.glContext.allocateTexture(Tt,Lt,$t,this.toTextureData(st,pt));return this.config.reuseTextures&&(Ct.push(Ht),this.textureLookup.set(Ht,Ft)),Ht}readTexture(st,at,pt){return pt||(pt=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let vt=st.shape.reduce(($t,Tt)=>$t*Tt)*pt,wt=this.glContext.readTexture(st.texture,st.width,st.height,vt,this.toEncoderType(at),pt);return this.toTensorData(at,wt)})}async readTextureAsync(st,at,pt){let vt=st.tensor.dataId;if(pt||(pt=1),this.pendingRead.has(vt)){let wt=this.pendingRead.get(vt);return new Promise($t=>wt==null?void 0:wt.push($t))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(vt,[]);let wt=st.shape.reduce((Ft,Ct)=>Ft*Ct)*pt;await this.glContext.createAndWaitForFence();let $t=this.glContext.readTexture(st.texture,st.width,st.height,wt,this.toEncoderType(at),pt),Tt=this.toTensorData(at,$t),Lt=this.pendingRead.get(vt);return this.pendingRead.delete(vt),Lt==null||Lt.forEach(Ft=>Ft(Tt)),Tt})}readUint8TextureAsFloat(st){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let at=st.shape.reduce((vt,wt)=>vt*wt),pt=this.glContext.readTexture(st.texture,st.width,st.height,at*4,"byte",4);return new Float32Array(pt.buffer,pt.byteOffset,at)})}releaseTexture(st,at){let pt;if(this.config.reuseTextures&&(pt=this.textureLookup.get(st.texture),pt)){at&&this.textureLookup.delete(pt);let vt=this.inUseTextures.get(pt);if(vt){let wt=vt.indexOf(st.texture);if(wt!==-1){vt.splice(wt,1);let $t=this.idleTextures.get(pt);$t||($t=[],this.idleTextures.set(pt,$t)),$t.push(st.texture)}}}(!pt||at)&&(ce.verbose("TextureManager",`Deleting texture of size ${st.width}x${st.height}`),this.glContext.deleteTexture(st.texture))}toTensorData(st,at){switch(st){case"int16":return at instanceof Int16Array?at:Int16Array.from(at);case"int32":return at instanceof Int32Array?at:Int32Array.from(at);case"int8":return at instanceof Int8Array?at:Int8Array.from(at);case"uint16":return at instanceof Uint16Array?at:Uint16Array.from(at);case"uint32":return at instanceof Uint32Array?at:Uint32Array.from(at);case"uint8":case"bool":return at instanceof Uint8Array?at:Uint8Array.from(at);case"float32":return at instanceof Float32Array?at:Float32Array.from(at);case"float64":return at instanceof Float64Array?at:Float64Array.from(at);default:throw new Error(`TensorData type ${st} is not supported`)}}toTextureData(st,at){if(at)return at instanceof Float32Array?at:new Float32Array(at)}toEncoderType(st){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}}),yo$1,lp$1=L(()=>{lt$1(),_s$1(),el$1(),Xc$1(),sp$1(),Vi(),up$1(),yo$1=class{constructor(st,at){this.backend=st,this.context=at,this.layoutStrategy=new uo$1(st.glContext.maxTextureSize),this.programManager=new bo$1(this.context.profiler,st.glContext,this.layoutStrategy),this.textureManager=new go$1(st.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:st.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=st.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new Jn$1(this)}onGraphInitialized(st){let at=st.getValues().filter(pt=>pt.from===-1&&pt.tensor).map(pt=>pt.tensor.dataId);this.initializers=new Set(at)}isInitializer(st){return this.initializers?this.initializers.has(st):!1}addInitializer(st){this.initializers.add(st)}getTextureData(st,at){return at?this.packedTextureDataCache.get(st):this.unpackedTextureDataCache.get(st)}setTextureData(st,at,pt=!1){ce.verbose("WebGLSessionHandler","Storing Texture data in cache"),pt?this.packedTextureDataCache.set(st,at):this.unpackedTextureDataCache.set(st,at)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(st=>this.textureManager.releaseTexture(st,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(st=>this.textureManager.releaseTexture(st,!0)),this.unpackedTextureDataCache=new Map}resolve(st,at,pt){let vt=vs$1(st,at,Yc$1);return{impl:vt.opImpl,context:vt.opInit?vt.opInit(st,pt):st}}}});function jb(st){let at=0;for(;at<st.length&&st[at]();++at);return at-1}var hn,fp$1=L(()=>{Ot$1(),ln(),ln(),Bt$1(),hn=class{constructor(st,at){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=st,this.version=at,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(st,at,pt,vt){let wt=this.gl,$t=wt.createTexture();wt.bindTexture(wt.TEXTURE_2D,$t),wt.texParameteri(wt.TEXTURE_2D,wt.TEXTURE_MIN_FILTER,wt.NEAREST),wt.texParameteri(wt.TEXTURE_2D,wt.TEXTURE_MAG_FILTER,wt.NEAREST),wt.texParameteri(wt.TEXTURE_2D,wt.TEXTURE_WRAP_S,wt.CLAMP_TO_EDGE),wt.texParameteri(wt.TEXTURE_2D,wt.TEXTURE_WRAP_T,wt.CLAMP_TO_EDGE);let Tt=vt?pt.encode(vt,st*at):null;return wt.texImage2D(wt.TEXTURE_2D,0,pt.internalFormat,st,at,0,pt.format,pt.textureType,Tt),this.checkError(),$t}updateTexture(st,at,pt,vt,wt){let $t=this.gl;$t.bindTexture($t.TEXTURE_2D,st);let Tt=vt.encode(wt,at*pt);$t.texSubImage2D($t.TEXTURE_2D,0,0,0,at,pt,vt.format,vt.textureType,Tt),this.checkError()}attachFramebuffer(st,at,pt){let vt=this.gl;vt.bindTexture(vt.TEXTURE_2D,st),vt.bindFramebuffer(vt.FRAMEBUFFER,this.framebuffer),vt.framebufferTexture2D(vt.FRAMEBUFFER,vt.COLOR_ATTACHMENT0,vt.TEXTURE_2D,st,0),this.checkError(),vt.viewport(0,0,at,pt),vt.scissor(0,0,at,pt)}readTexture(st,at,pt,vt,wt,$t){let Tt=this.gl;$t||($t=1),this.frameBufferBound||this.attachFramebuffer(st,at,pt);let Lt=this.getEncoder(wt,$t),Ft=Lt.allocate(at*pt);return Tt.bindTexture(Tt.TEXTURE_2D,st),Tt.framebufferTexture2D(Tt.FRAMEBUFFER,Tt.COLOR_ATTACHMENT0,Tt.TEXTURE_2D,st,0),Tt.readPixels(0,0,at,pt,Tt.RGBA,Lt.textureType,Ft),this.checkError(),Lt.decode(Ft,vt)}isFramebufferReady(){return!0}getActiveTexture(){let st=this.gl;return`TEXTURE${st.getParameter(this.gl.ACTIVE_TEXTURE)-st.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(st,at){let pt=this.gl;pt.vertexAttribPointer(st,3,pt.FLOAT,!1,20,0),pt.enableVertexAttribArray(st),at!==-1&&(pt.vertexAttribPointer(at,2,pt.FLOAT,!1,20,12),pt.enableVertexAttribArray(at)),this.checkError()}createProgram(st,at){let pt=this.gl,vt=pt.createProgram();return pt.attachShader(vt,st),pt.attachShader(vt,at),pt.linkProgram(vt),vt}compileShader(st,at){let pt=this.gl,vt=pt.createShader(at);if(!vt)throw new Error(`createShader() returned null with type ${at}`);if(pt.shaderSource(vt,st),pt.compileShader(vt),pt.getShaderParameter(vt,pt.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${pt.getShaderInfoLog(vt)}
Shader source:
${st}`);return vt}deleteShader(st){this.gl.deleteShader(st)}bindTextureToUniform(st,at,pt){let vt=this.gl;vt.activeTexture(vt.TEXTURE0+at),this.checkError(),vt.bindTexture(vt.TEXTURE_2D,st),this.checkError(),vt.uniform1i(pt,at),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(Z.debug){let st=this.gl,at=st.getError(),pt="";switch(at){case st.NO_ERROR:return;case st.INVALID_ENUM:pt="INVALID_ENUM";break;case st.INVALID_VALUE:pt="INVALID_VALUE";break;case st.INVALID_OPERATION:pt="INVALID_OPERATION";break;case st.INVALID_FRAMEBUFFER_OPERATION:pt="INVALID_FRAMEBUFFER_OPERATION";break;case st.OUT_OF_MEMORY:pt="OUT_OF_MEMORY";break;case st.CONTEXT_LOST_WEBGL:pt="CONTEXT_LOST_WEBGL";break;default:pt=`Unknown WebGL Error: ${at.toString(16)}`}throw new Error(pt)}}deleteTexture(st){this.gl.deleteTexture(st)}deleteProgram(st){this.gl.deleteProgram(st)}getEncoder(st,at,pt=0){if(this.version===2)return new Xn$1(this.gl,at);switch(st){case"float":return pt===1||this.isRenderFloat32Supported?new un(this.gl,at):new un(this.gl,at,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new Kn$1(this.gl,at);default:throw new Error(`Invalid dataType: ${st}`)}}clearActiveTextures(){let st=this.gl;for(let at=0;at<this.maxTextureImageUnits;++at)st.activeTexture(st.TEXTURE0+at),st.bindTexture(st.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let st=this.gl;st.bindFramebuffer(st.FRAMEBUFFER,null),st.deleteFramebuffer(this.framebuffer),st.bindBuffer(st.ARRAY_BUFFER,null),st.deleteBuffer(this.vertexbuffer),st.bindBuffer(st.ELEMENT_ARRAY_BUFFER,null),st.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let st=this.gl,at=st.createBuffer();if(!at)throw new Error("createBuffer() returned null");let pt=this.createDefaultGeometry();return st.bindBuffer(st.ARRAY_BUFFER,at),st.bufferData(st.ARRAY_BUFFER,pt,st.STATIC_DRAW),this.checkError(),at}createFramebuffer(){let st=this.gl.createFramebuffer();if(!st)throw new Error("createFramebuffer returned null");return st}queryVitalParameters(){let st=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=st.getParameter(st.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=st.getParameter(st.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let st=this.gl,at=st.createTexture();st.bindTexture(st.TEXTURE_2D,at);let pt=this.version===2?st.RGBA32F:st.RGBA;st.texImage2D(st.TEXTURE_2D,0,pt,1,1,0,st.RGBA,st.FLOAT,null);let vt=st.createFramebuffer();st.bindFramebuffer(st.FRAMEBUFFER,vt),st.framebufferTexture2D(st.FRAMEBUFFER,st.COLOR_ATTACHMENT0,st.TEXTURE_2D,at,0);let wt=st.checkFramebufferStatus(st.FRAMEBUFFER)===st.FRAMEBUFFER_COMPLETE;return st.bindTexture(st.TEXTURE_2D,null),st.bindFramebuffer(st.FRAMEBUFFER,null),st.deleteTexture(at),st.deleteFramebuffer(vt),wt}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let st=this.gl,at,pt,vt,wt,$t;try{at=st.createTexture(),pt=st.createFramebuffer(),st.bindTexture(st.TEXTURE_2D,at);let Tt=this.version===2?st.RGBA32F:st.RGBA;return st.texImage2D(st.TEXTURE_2D,0,Tt,1,1,0,st.RGBA,st.FLOAT,null),st.bindFramebuffer(st.FRAMEBUFFER,pt),st.framebufferTexture2D(st.FRAMEBUFFER,st.COLOR_ATTACHMENT0,st.TEXTURE_2D,at,0),st.enable(st.BLEND),vt=st.createShader(st.VERTEX_SHADER),!vt||(st.shaderSource(vt,"void main(){}"),st.compileShader(vt),wt=st.createShader(st.FRAGMENT_SHADER),!wt)||(st.shaderSource(wt,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),st.compileShader(wt),$t=st.createProgram(),!$t)?!1:(st.attachShader($t,vt),st.attachShader($t,wt),st.linkProgram($t),st.useProgram($t),st.drawArrays(st.POINTS,0,1),st.getError()===st.NO_ERROR)}finally{st.disable(st.BLEND),$t&&st.deleteProgram($t),vt&&st.deleteShader(vt),wt&&st.deleteShader(wt),pt&&(st.bindFramebuffer(st.FRAMEBUFFER,null),st.deleteFramebuffer(pt)),at&&(st.bindTexture(st.TEXTURE_2D,null),st.deleteTexture(at))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let st=this.gl,at=this.disjointTimerQueryWebgl2Extension,pt=st.createQuery();return st.beginQuery(at.TIME_ELAPSED_EXT,pt),pt}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let st=this.gl,at=this.disjointTimerQueryWebgl2Extension;st.endQuery(at.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(st){let at=!1,pt=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let vt=this.gl,wt=this.disjointTimerQueryWebgl2Extension;at=vt.getQueryParameter(st,vt.QUERY_RESULT_AVAILABLE),pt=vt.getParameter(wt.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return at&&!pt}getTimerResult(st){let at=0;if(this.version===2){let pt=this.gl;at=pt.getQueryParameter(st,pt.QUERY_RESULT),pt.deleteQuery(st)}else throw new Error("WebGL1 profiling currently not supported");return at/1e6}async waitForQueryAndGetTime(st){return await mi$1(()=>this.isTimerResultAvailable(st)),this.getTimerResult(st)}async createAndWaitForFence(){let st=this.createFence(this.gl);return this.pollFence(st)}createFence(st){let at,pt=st,vt=pt.fenceSync(pt.SYNC_GPU_COMMANDS_COMPLETE,0);return st.flush(),vt===null?at=()=>!0:at=()=>{let wt=pt.clientWaitSync(vt,0,0);return wt===pt.ALREADY_SIGNALED||wt===pt.CONDITION_SATISFIED},{query:vt,isFencePassed:at}}async pollFence(st){return new Promise(at=>{this.addItemToPoll(()=>st.isFencePassed(),()=>at())})}pollItems(){let st=jb(this.itemsToPoll.map(at=>at.isDoneFn));for(let at=0;at<=st;++at){let{resolveFn:pt}=this.itemsToPoll[at];pt()}this.itemsToPoll=this.itemsToPoll.slice(st+1)}async addItemToPoll(st,at){this.itemsToPoll.push({isDoneFn:st,resolveFn:at}),!(this.itemsToPoll.length>1)&&await mi$1(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function Hi$1(st){let at;if((!st||st==="webgl2")&&"webgl2"in Gr?at=Gr.webgl2:(!st||st==="webgl")&&"webgl"in Gr&&(at=Gr.webgl),!at)try{let vt=Xb();at=cp$1(vt,st)}catch{let vt=Yb();at=cp$1(vt,st)}st=st||at.version===1?"webgl":"webgl2";let pt=at.gl;return Gr[st]=at,pt.isContextLost()?(delete Gr[st],Hi$1(st)):(pt.disable(pt.DEPTH_TEST),pt.disable(pt.STENCIL_TEST),pt.disable(pt.BLEND),pt.disable(pt.DITHER),pt.disable(pt.POLYGON_OFFSET_FILL),pt.disable(pt.SAMPLE_COVERAGE),pt.enable(pt.SCISSOR_TEST),pt.enable(pt.CULL_FACE),pt.cullFace(pt.BACK),at)}function cp$1(st,at){let pt={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},vt,wt=pt;if((!at||at==="webgl2")&&(vt=st.getContext("webgl2",wt),vt))try{return new hn(vt,2)}catch($t){ce.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${$t}`)}if((!at||at==="webgl")&&(vt=st.getContext("webgl",wt)||st.getContext("experimental-webgl",wt),vt))try{return new hn(vt,1)}catch($t){ce.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${$t}`)}throw new Error("WebGL is not supported")}function Yb(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let st=document.createElement("canvas");return st.width=1,st.height=1,st}function Xb(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var Gr,pp$1=L(()=>{lt$1(),fp$1(),Gr={}}),To$1,dp$1=L(()=>{Ot$1(),lt$1(),lp$1(),pp$1(),To$1=class{get contextId(){return Z.webgl.contextId}set contextId(st){Z.webgl.contextId=st}get matmulMaxBatchSize(){return Z.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(st){Z.webgl.matmulMaxBatchSize=st}get textureCacheMode(){return Z.webgl.textureCacheMode}set textureCacheMode(st){Z.webgl.textureCacheMode=st}get pack(){return Z.webgl.pack}set pack(st){Z.webgl.pack=st}get async(){return Z.webgl.async}set async(st){Z.webgl.async=st}initialize(){try{return this.glContext=Hi$1(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),ce.setWithEnv(Z),Z.webgl.context||Object.defineProperty(Z.webgl,"context",{value:this.glContext.gl}),ce.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(st){return ce.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${st}`),!1}}createSessionHandler(st){return new yo$1(this,st)}dispose(){this.glContext.dispose()}}});async function qi$1(st){if(st){let at=typeof st=="string"?[st]:st;for(let pt of at){let vt=hp$1.get(pt);if(vt)return vt;let wt=await Jb(pt);if(wt)return wt}}else return qi$1(["webgl"]);throw new Error("no available backend to use")}async function Jb(st){let at=Kb;if(typeof at[st]<"u"&&Zb(at[st])){let pt=at[st],vt=pt.initialize();if(typeof vt=="object"&&"then"in vt&&(vt=await vt),vt)return hp$1.set(st,pt),pt}}function Zb(st){let at=st;return"initialize"in at&&typeof at.initialize=="function"&&"createSessionHandler"in at&&typeof at.createSessionHandler=="function"&&"dispose"in at&&typeof at.dispose=="function"}var hp$1,Kb,mp$1=L(()=>{dp$1(),hp$1=new Map,Kb={webgl:new To$1}}),ji$1,xo$1,bp=L(()=>{lt$1(),ji$1=class{constructor(st,at){this.op=st,this.node=at}},xo$1=class{constructor(st,at,pt){this.graph=st,this.profiler=pt,this.initialize(at)}initialize(st){this.profiler.event("session","ExecutionPlan.initialize",()=>{let at=this.graph.getNodes();if(at.length!==st.length)throw new Error("The size of nodes and OPs do not match.");this._ops=st.map((pt,vt)=>new ji$1(pt,at[vt])),this.reset(),this._starter=[],this._ops.forEach((pt,vt)=>{let wt=!0;for(let $t of pt.node.inputs)if(!this._values[$t]&&this.graph.getInputIndices().indexOf($t)===-1){wt=!1;break}wt&&this._starter.push(vt)})})}reset(){this._values=this.graph.getValues().map(st=>st.tensor)}async execute(st,at){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let pt=st.createInferenceHandler(),vt=this.graph.getInputIndices();if(at.length!==vt.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${at.length} expected: ${vt.length}`);at.forEach((Ct,Ht)=>{let Gt=vt[Ht];this._values[Gt]=Ct});let wt=this._starter.slice(0),$t=this.graph.getValues(),Tt=this.graph.getNodes(),Lt=0;for(;Lt<wt.length;){let Ct=wt[Lt++],Ht=this._ops[Ct],Gt=Ht.node.inputs.map(An=>this._values[An]);if(Gt.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${Ht.node}`);let jt=Gt;ce.verbose("ExecPlan",`Runing op:${Ht.node.name} (${jt.map((An,Sn)=>`'${Ht.node.inputs[Sn]}': ${An.type}[${An.dims.join(",")}]`).join(", ")})`);let qt=await this.profiler.event("node",Ht.node.name,async()=>Ht.op.impl(pt,jt,Ht.op.context));if(qt.length!==Ht.node.outputs.length)throw new Error("the size of output does not match model definition.");qt.forEach((An,Sn)=>{let wn=Ht.node.outputs[Sn];if(this._values[wn])throw new Error(`output [${wn}] already has value: op:${Ht.node.name}`);this._values[wn]=An});let Kt=new Set;qt.forEach((An,Sn)=>{let wn=Ht.node.outputs[Sn];for(let In of $t[wn].to){let tr=Tt[In],rr=!0;for(let Hr of tr.inputs)if(!this._values[Hr]){rr=!1;break}rr&&Kt.add(In)}}),wt.push(...Kt)}let Ft=[];for(let Ct=0;Ct<this.graph.getOutputIndices().length;Ct++){let Ht=this.graph.getOutputIndices()[Ct],Gt=this._values[Ht];if(Gt===void 0)throw new Error(`required output [${Ht}] does not have value`);Ht===0?await Gt.getData():Gt.data,Ft.push(Gt)}return ce.verbose("ExecPlan","disposing of inferenceHandler"),pt.dispose(),Ft})}}}),oe,bt,mn,gp$1=L(()=>{tn$1(),oe=Ar(Cr()),yr(),fe$1(),bt=V.experimental.fbs,mn=class b${constructor(at){if(this._attributes=new Map,at!=null){for(let pt of at)pt instanceof oe.onnx.AttributeProto?this._attributes.set(pt.name,[b$.getValue(pt),b$.getType(pt)]):pt instanceof bt.Attribute&&this._attributes.set(pt.name(),[b$.getValue(pt),b$.getType(pt)]);if(this._attributes.size<at.length)throw new Error("duplicated attribute names")}}set(at,pt,vt){this._attributes.set(at,[vt,pt])}delete(at){this._attributes.delete(at)}getFloat(at,pt){return this.get(at,"float",pt)}getInt(at,pt){return this.get(at,"int",pt)}getString(at,pt){return this.get(at,"string",pt)}getTensor(at,pt){return this.get(at,"tensor",pt)}getFloats(at,pt){return this.get(at,"floats",pt)}getInts(at,pt){return this.get(at,"ints",pt)}getStrings(at,pt){return this.get(at,"strings",pt)}getTensors(at,pt){return this.get(at,"tensors",pt)}get(at,pt,vt){let wt=this._attributes.get(at);if(wt===void 0){if(vt!==void 0)return vt;throw new Error(`required attribute not found: ${at}`)}if(wt[1]!==pt)throw new Error(`type mismatch: expected ${pt} but got ${wt[1]}`);return wt[0]}static getType(at){let pt=at instanceof oe.onnx.AttributeProto?at.type:at.type();switch(pt){case oe.onnx.AttributeProto.AttributeType.FLOAT:return"float";case oe.onnx.AttributeProto.AttributeType.INT:return"int";case oe.onnx.AttributeProto.AttributeType.STRING:return"string";case oe.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case oe.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case oe.onnx.AttributeProto.AttributeType.INTS:return"ints";case oe.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case oe.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${oe.onnx.AttributeProto.AttributeType[pt]}`)}}static getValue(at){let pt=at instanceof oe.onnx.AttributeProto?at.type:at.type();if(pt===oe.onnx.AttributeProto.AttributeType.GRAPH||pt===oe.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let vt=this.getValueNoCheck(at);if(pt===oe.onnx.AttributeProto.AttributeType.INT&&it.isLong(vt))return it.longToNumber(vt);if(pt===oe.onnx.AttributeProto.AttributeType.INTS){let wt=vt,$t=new Array(wt.length);for(let Tt=0;Tt<wt.length;Tt++){let Lt=wt[Tt];$t[Tt]=it.longToNumber(Lt)}return $t}if(pt===oe.onnx.AttributeProto.AttributeType.TENSOR)return at instanceof oe.onnx.AttributeProto?$e.fromProto(vt):$e.fromOrtTensor(vt);if(pt===oe.onnx.AttributeProto.AttributeType.TENSORS){if(at instanceof oe.onnx.AttributeProto)return vt.map(wt=>$e.fromProto(wt));if(at instanceof bt.Attribute)return vt.map(wt=>$e.fromOrtTensor(wt))}return pt===oe.onnx.AttributeProto.AttributeType.STRING&&at instanceof oe.onnx.AttributeProto?sn$1(vt):pt===oe.onnx.AttributeProto.AttributeType.STRINGS&&at instanceof oe.onnx.AttributeProto?vt.map(sn$1):vt}static getValueNoCheck(at){return at instanceof oe.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(at):this.getValueNoCheckFromOrtFormat(at)}static getValueNoCheckFromOnnxFormat(at){switch(at.type){case oe.onnx.AttributeProto.AttributeType.FLOAT:return at.f;case oe.onnx.AttributeProto.AttributeType.INT:return at.i;case oe.onnx.AttributeProto.AttributeType.STRING:return at.s;case oe.onnx.AttributeProto.AttributeType.TENSOR:return at.t;case oe.onnx.AttributeProto.AttributeType.GRAPH:return at.g;case oe.onnx.AttributeProto.AttributeType.FLOATS:return at.floats;case oe.onnx.AttributeProto.AttributeType.INTS:return at.ints;case oe.onnx.AttributeProto.AttributeType.STRINGS:return at.strings;case oe.onnx.AttributeProto.AttributeType.TENSORS:return at.tensors;case oe.onnx.AttributeProto.AttributeType.GRAPHS:return at.graphs;default:throw new Error(`unsupported attribute type: ${oe.onnx.AttributeProto.AttributeType[at.type]}`)}}static getValueNoCheckFromOrtFormat(at){switch(at.type()){case bt.AttributeType.FLOAT:return at.f();case bt.AttributeType.INT:return at.i();case bt.AttributeType.STRING:return at.s();case bt.AttributeType.TENSOR:return at.t();case bt.AttributeType.GRAPH:return at.g();case bt.AttributeType.FLOATS:return at.floatsArray();case bt.AttributeType.INTS:{let pt=[];for(let vt=0;vt<at.intsLength();vt++)pt.push(at.ints(vt));return pt}case bt.AttributeType.STRINGS:{let pt=[];for(let vt=0;vt<at.stringsLength();vt++)pt.push(at.strings(vt));return pt}case bt.AttributeType.TENSORS:{let pt=[];for(let vt=0;vt<at.tensorsLength();vt++)pt.push(at.tensors(vt));return pt}default:throw new Error(`unsupported attribute type: ${bt.AttributeType[at.type()]}`)}}}}),Xi$1,wo$1,Ki$1,Mt$1,vo$1,Yi$1,yp$1=L(()=>{gp$1(),tn$1(),Xi$1=Ar(Cr()),yr(),fe$1(),wo$1=V.experimental.fbs,Ki$1={from:(st,at)=>new Yi$1(st,at)},Mt$1=class{constructor(st){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,st&&(this.type=We$1.tensorValueTypeFromProto(st.type.tensorType))}get from(){return this._from}get to(){return this._to}},vo$1=class{constructor(st,at){st instanceof Xi$1.onnx.NodeProto?(this.name=st.name,this.opType=st.opType,this.attributes=new mn(st.attribute)):st instanceof wo$1.Node&&(this.name=at??st.name(),this.opType=st.opType(),this.attributes=new mn(We$1.tensorAttributesFromORTFormat(st))),this.inputs=[],this.outputs=[],this.executeNode=!0}},Yi$1=class{constructor(st,at){if(!st)throw new TypeError("graph is empty");this.buildGraph(st),this.transformGraph(at),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(st){if(st instanceof Xi$1.onnx.GraphProto)this.buildGraphFromOnnxFormat(st);else if(st instanceof wo$1.Graph)this.buildGraphFromOrtFormat(st);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(st){let at=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let pt=new Map;if(!st.input)throw new Error("missing information in graph: input");let vt=[];for(let wt of st.input){if(at.has(wt.name))throw new Error(`duplicated input name: ${wt.name}`);let $t=this._allData.push(new Mt$1(wt))-1;at.set(wt.name,$t),vt.push(wt.name)}if(!st.initializer)throw new Error("missing information in graph: initializer");for(let wt of st.initializer){let $t=at.get(wt.name);if($t===void 0){let Tt=new Mt$1;Tt.type={shape:{dims:We$1.tensorDimsFromProto(wt.dims)},tensorType:We$1.tensorDataTypeFromProto(wt.dataType)},$t=this._allData.push(Tt)-1,at.set(wt.name,$t)}this._allData[$t]._from=-1,this._allData[$t].tensor=$e.fromProto(wt)}for(let wt=0;wt<this._allData.length;wt++)this._allData[wt].tensor||(this._allInputIndices.push(wt),this._allInputNames.push(vt[wt]));if(!st.output)throw new Error("missing information in graph: output");for(let wt of st.output){if(at.has(wt.name))throw new Error(`duplicated output name: ${wt.name}`);let $t=this._allData.push(new Mt$1(wt))-1;at.set(wt.name,$t),this._allOutputIndices.push($t),this._allOutputNames.push(wt.name)}if(!st.node)throw new Error("missing information in graph: node");for(let wt of st.node){if(!wt.name)for(let Tt=0;;Tt++){let Lt=`unnamed_${wt.opType}_${Tt}`;if(!pt.has(Lt)){wt.name=Lt;break}}if(pt.has(wt.name))throw new Error(`duplicated node name: ${wt.name}`);let $t=this._nodes.push(new vo$1(wt))-1;pt.set(wt.name,$t)}for(let wt=0;wt<this._nodes.length;wt++){let $t=this._nodes[wt],Tt=st.node[wt];if(!Tt.output)throw new Error(`missing output for node: ${Tt.name}`);for(let Lt of Tt.output){let Ft=at.get(Lt);if(typeof Ft>"u"&&(Ft=this._allData.push(new Mt$1)-1,at.set(Lt,Ft)),$t.outputs.push(Ft),this._allData[Ft]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${Ft}`);if(this._allData[Ft]._from=wt,Tt.opType==="Constant"){if(!Tt.attribute||Tt.attribute.length!==1||!Tt.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!Tt.output||Tt.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");$t.outputs.pop(),$t.executeNode=!1,this._allData[Ft]._from=-1,this._allData[Ft].tensor=$e.fromProto(Tt.attribute[0].t)}}}for(let wt=0;wt<this._nodes.length;wt++){let $t=this._nodes[wt],Tt=st.node[wt];if(!Tt.input)throw new Error(`missing input for node: ${Tt.name}`);for(let Lt of Tt.input){let Ft=at.get(Lt);if(typeof Ft>"u"){if(Lt===""&&(Tt.input.length===3||Tt.input.length===4)&&Tt.opType==="Resize")continue;throw new Error(`unrecognized input '${Lt}' for node: ${Tt.name}`)}$t.inputs.push(Ft),this._allData[Ft]._to.push(wt)}}return!0}buildGraphFromOrtFormat(st){var wt,$t,Tt;let at=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let pt=new Map,vt=[];for(let Lt=0;Lt<st.inputsLength();Lt++){let Ft=st.inputs(Lt);if(at.has(Ft))throw new Error(`duplicated input name: ${Ft}`);for(let Ct=0;Ct<st.nodeArgsLength();Ct++)if(((wt=st.nodeArgs(Ct))==null?void 0:wt.name())===Ft){let Ht=new Mt$1;if(((Tt=($t=st.nodeArgs(Ct))==null?void 0:$t.type())==null?void 0:Tt.valueType())!==wo$1.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let Gt=st.nodeArgs(Ct).type().value(new wo$1.TensorTypeAndShape),jt=We$1.tensorDataTypeFromProto(Gt.elemType()),qt=Gt.shape(),Kt=[];for(let Sn=0;Sn<qt.dimLength();Sn++)Kt.push(it.longToNumber(qt.dim(Sn).value().dimValue()));Ht.type={shape:{dims:Kt},tensorType:jt};let An=this._allData.push(Ht)-1;at.set(Ft,An),vt.push(Ft)}}for(let Lt=0;Lt<st.initializersLength();Lt++){let Ft=st.initializers(Lt),Ct=at.get(Ft.name());if(Ct===void 0){let Ht=new Mt$1,Gt=We$1.tensorDimsFromORTFormat(Ft),jt=We$1.tensorDataTypeFromProto(Ft.dataType());Ht.type={shape:{dims:Gt},tensorType:jt},Ct=this._allData.push(Ht)-1,at.set(Ft.name(),Ct)}this._allData[Ct]._from=-1,this._allData[Ct].tensor=$e.fromOrtTensor(Ft)}for(let Lt=0;Lt<this._allData.length;Lt++)this._allData[Lt].tensor||(this._allInputIndices.push(Lt),this._allInputNames.push(vt[Lt]));for(let Lt=0;Lt<st.outputsLength();Lt++){let Ft=st.outputs(Lt);if(at.has(Ft))throw new Error(`duplicated output name: ${Ft}`);let Ct=this._allData.push(new Mt$1)-1;at.set(Ft,Ct),this._allOutputIndices.push(Ct),this._allOutputNames.push(Ft)}if(!st.nodes)throw new Error("missing information in graph: node");for(let Lt=0;Lt<st.nodesLength();Lt++){let Ft=st.nodes(Lt),Ct=Ft.name();if(!Ct)for(let Gt=0;Ct=`unnamed_${Ft.opType()}_${Gt}`,!!pt.has(Ct);Gt++);if(pt.has(Ct))throw new Error(`duplicated node name: ${Ct}`);let Ht=this._nodes.push(new vo$1(Ft,Ct))-1;pt.set(Ct,Ht)}for(let Lt=0;Lt<this._nodes.length;Lt++){let Ft=this._nodes[Lt],Ct=st.nodes(Lt);if(Ct==null)throw new Error(`No node exists at index ${Lt}`);if((Ct==null?void 0:Ct.outputsLength())===0)throw new Error(`missing output for node: ${Ct.name}`);for(let Ht=0;Ht<(Ct==null?void 0:Ct.outputsLength());Ht++){let Gt=Ct==null?void 0:Ct.outputs(Ht),jt=at.get(Gt);if(typeof jt>"u"&&(jt=this._allData.push(new Mt$1)-1,at.set(Gt,jt)),Ft.outputs.push(jt),this._allData[jt]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${jt}`);if(this._allData[jt]._from=Lt,Ct.opType()==="Constant"){if(Ct.attributesLength()!==1||!Ct.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(Ct.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");Ft.outputs.pop(),Ft.executeNode=!1,this._allData[jt]._from=-1,this._allData[jt].tensor=$e.fromOrtTensor(Ct.attributes(0).t())}}}for(let Lt=0;Lt<this._nodes.length;Lt++){let Ft=this._nodes[Lt],Ct=st.nodes(Lt);if(Ct.inputsLength()===0)throw new Error(`missing input for node: ${Ct.name}`);for(let Ht=0;Ht<Ct.inputsLength();Ht++){let Gt=Ct.inputs(Ht),jt=at.get(Gt);if(typeof jt>"u")throw new Error(`unrecognized input '${Gt}' for node: ${Ct.name()}`);Ft.inputs.push(jt),this._allData[jt]._to.push(Lt)}}}checkIsAcyclic(){let st=new Set;this._allInputIndices.forEach(vt=>{this._allData[vt]._to.forEach(wt=>{st.add(wt)})});let at=Array.from(st),pt=new Array(this._nodes.length).fill("white");for(;at.length>0;){let vt=at.pop();pt[vt]==="gray"?pt[vt]="black":(at.push(vt),pt[vt]="gray",this._nodes[vt].outputs.forEach(wt=>{let $t=this._allData[wt];if(typeof $t.tensor<"u")throw new Error("node outputs should not be initialized");if($t._from!==vt)throw new Error("from property of the Value object doesn't match index of Node being processed");$t._to.forEach(Tt=>{if(pt[Tt]==="gray")throw new Error("model graph is cyclic");pt[Tt]==="white"&&at.push(Tt)})}))}}transformGraph(st){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),st&&st.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let st=0,at=new Array(this._nodes.length,0),pt=0;for(let vt=0;vt<this._nodes.length;vt++)at[vt]=pt,this._nodes[vt].executeNode?(pt!==vt&&(this._nodes[pt]=this._nodes[vt]),pt++):this._nodes[vt].outputs.forEach(wt=>{this._allData[wt]._from=-2});this._nodes.splice(pt,this._nodes.length-pt);for(let vt=0;vt<this._allData.length;vt++){let wt=this._allData[vt];wt._from!==void 0&&wt._from!==-1&&wt._from!==-2&&(wt._from=at[wt._from]);for(let $t=0;$t<wt._to.length;$t++)if(wt._to[$t]>=0)wt._to[$t]=at[wt._to[$t]];else throw new Error("Trying to update a removed node")}st=0;for(let vt=0;vt<this._allData.length;vt++){if(this._allData[vt].from===-2&&this._allOutputIndices.indexOf(vt+st)===-1){st++,this._allData.splice(vt,1),vt--;continue}if(st>0){let wt=-1;this._allData[vt].from!==void 0&&this._allData[vt].from!==-1?(wt=this._nodes[this._allData[vt].from].outputs.indexOf(vt+st),wt!==-1&&(this._nodes[this._allData[vt].from].outputs[wt]=vt)):(wt=this._allInputIndices.indexOf(vt+st),wt!==-1&&(this._allInputIndices[wt]=vt)),this._allData[vt].to.forEach($t=>{wt=this._nodes[$t].inputs.indexOf(vt+st),wt!==-1&&(this._nodes[$t].inputs[wt]=vt)}),this._allData[vt].to.length===0&&(wt=this._allOutputIndices.indexOf(vt+st),wt!==-1&&(this._allOutputIndices[wt]=vt))}}}deleteNode(st){let at=this._nodes[st];if(at.outputs.length>1){for(let Tt=1;Tt<at.outputs.length;Tt++)if(this._allData[at.outputs[Tt]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}at.executeNode=!1;let pt=at.inputs[0],vt=at.outputs[0],wt=this._allData[vt].to;for(let Tt=0;Tt<at.inputs.length;Tt++){let Lt=this._allData[at.inputs[Tt]].to.indexOf(st);if(Lt===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[at.inputs[Tt]].to.splice(Lt,1)}this._allData[vt]._to=[];let $t=this._allOutputIndices.indexOf(vt);if($t!==-1&&(this._allOutputIndices[$t]=pt),wt&&wt.length>0)for(let Tt of wt){let Lt=this._nodes[Tt].inputs.indexOf(vt);if(Lt===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[Tt].inputs[Lt]=pt,this._allData[pt].to.push(Tt)}}removeAllDropoutNodes(){let st=0;for(let at of this._nodes){if(at.opType==="Dropout"){if(at.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(at.outputs.length!==1&&at.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(at.outputs.length===2&&this._allData[at.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(st)}st++}}removeAllIdentityNodes(){let st=0;for(let at of this._nodes)at.opType==="Identity"&&this.deleteNode(st),st++}isActivation(st){switch(st.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let st of this._nodes)if(st.opType==="Conv"){let at=this._allData[st.outputs[0]]._to;if(at.length===1&&this.isActivation(this._nodes[at[0]])){let pt=this._nodes[at[0]];if(pt.opType==="Clip")if(pt.inputs.length===1)try{st.attributes.set("activation_params","floats",[pt.attributes.getFloat("min"),pt.attributes.getFloat("max")])}catch{st.attributes.set("activation_params","floats",[br,gr$1])}else if(pt.inputs.length>=3&&this._allData[pt.inputs[1]].tensor!==void 0&&this._allData[pt.inputs[2]].tensor!==void 0)st.attributes.set("activation_params","floats",[this._allData[pt.inputs[1]].tensor.floatData[0],this._allData[pt.inputs[2]].tensor.floatData[0]]);else continue;st.attributes.set("activation","string",pt.opType),this.deleteNode(at[0])}}}}}),Tp$1,Qb,_o$1,xp$1=L(()=>{zn$1(),yp$1(),tn$1(),Tp$1=Ar(Cr()),fe$1(),Qb=V.experimental.fbs,_o$1=class{constructor(){}load(st,at,pt){let vt;if(!pt)try{this.loadFromOnnxFormat(st,at);return}catch(wt){if(pt!==void 0)throw wt;vt=wt}try{this.loadFromOrtFormat(st,at)}catch(wt){throw pt!==void 0?wt:new Error(`Failed to load model as ONNX format: ${vt}
as ORT format: ${wt}`)}}loadFromOnnxFormat(st,at){let pt=Tp$1.onnx.ModelProto.decode(st);if(it.longToNumber(pt.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=pt.opsetImport.map(vt=>({domain:vt.domain,version:it.longToNumber(vt.version)})),this._graph=Ki$1.from(pt.graph,at)}loadFromOrtFormat(st,at){let pt=new _.ByteBuffer(st),vt=Qb.InferenceSession.getRootAsInferenceSession(pt).model();if(it.longToNumber(vt.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let wt=0;wt<vt.opsetImportLength();wt++){let $t=vt.opsetImport(wt);this._opsets.push({domain:$t==null?void 0:$t.domain(),version:it.longToNumber($t.version())})}this._graph=Ki$1.from(vt.graph(),at)}get graph(){return this._graph}get opsets(){return this._opsets}}}),Oo,wp$1=L(()=>{mp$1(),bp(),lt$1(),xp$1(),Oo=class{constructor(st={}){this._initialized=!1,this.backendHint=st.backendHint,this.profiler=Gn$1.create(st.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(st,at,pt){await this.profiler.event("session","Session.loadModel",async()=>{let vt=await qi$1(this.backendHint);if(this.sessionHandler=vt.createSessionHandler(this.context),this._model=new _o$1,typeof st=="string"){let wt=st.endsWith(".ort");if(typeof process<"u"&&process.versions&&process.versions.node){let $t=await(void 0)(st);this.initialize($t,wt)}else{let $t=await(await fetch(st)).arrayBuffer();this.initialize(new Uint8Array($t),wt)}}else if(ArrayBuffer.isView(st))this.initialize(st);else{let wt=new Uint8Array(st,at||0,pt||st.byteLength);this.initialize(wt)}})}initialize(st,at){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let pt=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(st,pt,at),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new xo$1(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(st){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let at=this.normalizeAndValidateInputs(st),pt=await this._executionPlan.execute(this.sessionHandler,at);return this.createOutput(pt)})}normalizeAndValidateInputs(st){let at=this._model.graph.getInputNames();if(Array.isArray(st)){if(st.length!==at.length)throw new Error(`incorrect input array length: expected ${at.length} but got ${st.length}`)}else{if(st.size!==at.length)throw new Error(`incorrect input map size: expected ${at.length} but got ${st.size}`);let pt=new Array(st.size),vt=0;for(let wt=0;wt<at.length;++wt){let $t=st.get(at[wt]);if(!$t)throw new Error(`missing input tensor for: '${name}'`);pt[vt++]=$t}st=pt}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let pt=this._model.graph.getInputIndices(),vt=this._model.graph.getValues(),wt=new Array(pt.length);for(let $t=0;$t<pt.length;++$t){let Tt=vt[pt[$t]];wt[$t]=Tt.type.shape.dims,this.context.graphInputTypes.push(Tt.type.tensorType),this.context.graphInputDims.push(st[$t].dims)}this.validateInputTensorDims(wt,st,!0)}else this.validateInputTensorDims(this.context.graphInputDims,st,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,st),st}validateInputTensorTypes(st,at){for(let pt=0;pt<at.length;pt++){let vt=st[pt],wt=at[pt].type;if(vt!==wt)throw new Error(`input tensor[${pt}] check failed: expected type '${vt}' but got ${wt}`)}}validateInputTensorDims(st,at,pt){for(let vt=0;vt<at.length;vt++){let wt=st[vt],$t=at[vt].dims;if(!this.compareTensorDims(wt,$t,pt))throw new Error(`input tensor[${vt}] check failed: expected shape '[${wt.join(",")}]' but got [${$t.join(",")}]`)}}compareTensorDims(st,at,pt){if(st.length!==at.length)return!1;for(let vt=0;vt<st.length;++vt)if(st[vt]!==at[vt]&&(!pt||st[vt]!==0))return!1;return!0}createOutput(st){let at=this._model.graph.getOutputNames();if(st.length!==at.length)throw new Error("expected number of outputs do not match number of generated outputs");let pt=new Map;for(let vt=0;vt<at.length;++vt)pt.set(at[vt],st[vt]);return pt}initializeOps(st){let at=st.getNodes();this._ops=new Array(at.length);for(let pt=0;pt<at.length;pt++)this._ops[pt]=this.sessionHandler.resolve(at[pt],this._model.opsets,st)}}}),Io$1,vp$1=L(()=>{Ot$1(),yr(),Io$1=class{constructor(st){this.session=st,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(st,at,pt){let vt=new Map;for(let Tt in st)if(Object.hasOwnProperty.call(st,Tt)){let Lt=st[Tt];vt.set(Tt,new $e(Lt.dims,Lt.type,void 0,void 0,Lt.data))}let wt=await this.session.run(vt),$t={};return wt.forEach((Tt,Lt)=>{$t[Lt]=new Me(Tt.type,Tt.data,Tt.dims)}),$t}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}}),_p$1={};Sr(_p$1,{onnxjsBackend:()=>tg});var Ji$1,tg,Op$1=L(()=>{wp$1(),vp$1(),Ji$1=class{async init(){}async createInferenceSessionHandler(st,at){let pt=new Oo(at);return typeof st=="string"?await pt.loadModel(st):await pt.loadModel(st),new Io$1(pt)}},tg=new Ji$1}),Zi$1={};Sr(Zi$1,{createReadStream:()=>Ip$1,readFile:()=>rg,readFileSync:()=>ng});var rg,ng,Ip$1,Qi$1=L(()=>{rg=void 0,ng=void 0,Ip$1=void 0}),ea={};Sr(ea,{join:()=>og});var og,ta=L(()=>{og=void 0}),Pp$1=me((st,at)=>{var pt=(()=>{var wt;var vt=typeof document<"u"?(wt=document.currentScript)==null?void 0:wt.src:void 0;return typeof __filename<"u"&&(vt||(vt=__filename)),function($t={}){var Tt=$t,Lt,Ft,Ct=new Promise((o0,v0)=>{Lt=o0,Ft=v0}),Ht=Object.assign({},Tt),Gt="./this.program",jt=typeof window=="object",qt=typeof importScripts=="function",Kt=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",An="",Sn,wn,In;if(Kt){var tr=(Qi$1(),ar(Zi$1)),rr=(ta(),ar(ea));An=qt?rr.dirname(An)+"/":__dirname+"/",Sn=(o0,v0)=>(o0=P0(o0)?new URL(o0):rr.normalize(o0),tr.readFileSync(o0,v0?void 0:"utf8")),In=o0=>(o0=Sn(o0,!0),o0.buffer||(o0=new Uint8Array(o0)),o0),wn=(o0,v0,i0,k0=!0)=>{o0=P0(o0)?new URL(o0):rr.normalize(o0),tr.readFile(o0,k0?void 0:"utf8",($0,ty)=>{$0?i0($0):v0(k0?ty.buffer:ty)})},!Tt.thisProgram&&1<process.argv.length&&(Gt=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2)}else(jt||qt)&&(qt?An=self.location.href:typeof document<"u"&&document.currentScript&&(An=document.currentScript.src),vt&&(An=vt),An.startsWith("blob:")?An="":An=An.substr(0,An.replace(/[?#].*/,"").lastIndexOf("/")+1),Sn=o0=>{var v0=new XMLHttpRequest;return v0.open("GET",o0,!1),v0.send(null),v0.responseText},qt&&(In=o0=>{var v0=new XMLHttpRequest;return v0.open("GET",o0,!1),v0.responseType="arraybuffer",v0.send(null),new Uint8Array(v0.response)}),wn=(o0,v0,i0)=>{var k0=new XMLHttpRequest;k0.open("GET",o0,!0),k0.responseType="arraybuffer",k0.onload=()=>{k0.status==200||k0.status==0&&k0.response?v0(k0.response):i0()},k0.onerror=i0,k0.send(null)});var Hr=console.log.bind(console),qr=console.error.bind(console);Object.assign(Tt,Ht),Ht=null;var Zr,Bo=!1,Xo,Kr,ko,f0,x0;function l0(){var o0=Zr.buffer;Tt.HEAP8=Xo=new Int8Array(o0),Tt.HEAP16=new Int16Array(o0),Tt.HEAPU8=Kr=new Uint8Array(o0),Tt.HEAPU16=new Uint16Array(o0),Tt.HEAP32=ko=new Int32Array(o0),Tt.HEAPU32=f0=new Uint32Array(o0),Tt.HEAPF32=new Float32Array(o0),Tt.HEAPF64=x0=new Float64Array(o0)}var T0=[],t0=[],E0=[],n0=0,m0=null;function h0(o0){throw o0="Aborted("+o0+")",qr(o0),Bo=!0,o0=new WebAssembly.RuntimeError(o0+". Build with -sASSERTIONS for more info."),Ft(o0),o0}var a0=o0=>o0.startsWith("data:application/octet-stream;base64,"),P0=o0=>o0.startsWith("file://"),V0;if(V0="ort-wasm.wasm",!a0(V0)){var B0=V0;V0=Tt.locateFile?Tt.locateFile(B0,An):An+B0}function W0(o0){if(In)return In(o0);throw"both async and sync fetching of the wasm failed"}function K0(o0){if(jt||qt){if(typeof fetch=="function"&&!P0(o0))return fetch(o0,{credentials:"same-origin"}).then(v0=>{if(!v0.ok)throw`failed to load wasm binary file at '${o0}'`;return v0.arrayBuffer()}).catch(()=>W0(o0));if(wn)return new Promise((v0,i0)=>{wn(o0,k0=>v0(new Uint8Array(k0)),i0)})}return Promise.resolve().then(()=>W0(o0))}function Ty(o0,v0,i0){return K0(o0).then(k0=>WebAssembly.instantiate(k0,v0)).then(i0,k0=>{qr(`failed to asynchronously prepare wasm: ${k0}`),h0(k0)})}function $y(o0,v0){var i0=V0;return typeof WebAssembly.instantiateStreaming!="function"||a0(i0)||P0(i0)||Kt||typeof fetch!="function"?Ty(i0,o0,v0):fetch(i0,{credentials:"same-origin"}).then(k0=>WebAssembly.instantiateStreaming(k0,o0).then(v0,function($0){return qr(`wasm streaming compile failed: ${$0}`),qr("falling back to ArrayBuffer instantiation"),Ty(i0,o0,v0)}))}var My,Wy={798088:(o0,v0,i0,k0)=>{if(typeof Tt>"u"||!Tt.ya)return 1;if(o0=yy(o0>>>0),o0.startsWith("./")&&(o0=o0.substring(2)),o0=Tt.ya.get(o0),!o0)return 2;if(v0>>>=0,i0>>>=0,v0+i0>o0.byteLength)return 3;try{return Kr.set(o0.subarray(v0,v0+i0),k0>>>0>>>0),0}catch{return 4}}};class Ey{constructor(v0){this.wa=v0-24}}var _0=0,ay=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,J0=(o0,v0,i0)=>{v0>>>=0;var k0=v0+i0;for(i0=v0;o0[i0]&&!(i0>=k0);)++i0;if(16<i0-v0&&o0.buffer&&ay)return ay.decode(o0.subarray(v0,i0));for(k0="";v0<i0;){var $0=o0[v0++];if($0&128){var ty=o0[v0++]&63;if(($0&224)==192)k0+=String.fromCharCode(($0&31)<<6|ty);else{var my=o0[v0++]&63;$0=($0&240)==224?($0&15)<<12|ty<<6|my:($0&7)<<18|ty<<12|my<<6|o0[v0++]&63,65536>$0?k0+=String.fromCharCode($0):($0-=65536,k0+=String.fromCharCode(55296|$0>>10,56320|$0&1023))}}else k0+=String.fromCharCode($0)}return k0},yy=(o0,v0)=>(o0>>>=0)?J0(Kr,o0,v0):"",uy=o0=>{for(var v0=0,i0=0;i0<o0.length;++i0){var k0=o0.charCodeAt(i0);127>=k0?v0++:2047>=k0?v0+=2:55296<=k0&&57343>=k0?(v0+=4,++i0):v0+=3}return v0},Dy=(o0,v0,i0,k0)=>{if(i0>>>=0,!(0<k0))return 0;var $0=i0;k0=i0+k0-1;for(var ty=0;ty<o0.length;++ty){var my=o0.charCodeAt(ty);if(55296<=my&&57343>=my){var ev=o0.charCodeAt(++ty);my=65536+((my&1023)<<10)|ev&1023}if(127>=my){if(i0>=k0)break;v0[i0++>>>0]=my}else{if(2047>=my){if(i0+1>=k0)break;v0[i0++>>>0]=192|my>>6}else{if(65535>=my){if(i0+2>=k0)break;v0[i0++>>>0]=224|my>>12}else{if(i0+3>=k0)break;v0[i0++>>>0]=240|my>>18,v0[i0++>>>0]=128|my>>12&63}v0[i0++>>>0]=128|my>>6&63}v0[i0++>>>0]=128|my&63}}return v0[i0>>>0]=0,i0-$0},Fy=o0=>o0%4===0&&(o0%100!==0||o0%400===0),qy=[0,31,60,91,121,152,182,213,244,274,305,335],rv=[0,31,59,90,120,151,181,212,243,273,304,334],y0=[],r0={},M0=()=>{if(!G0){var o0={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:Gt||"./this.program"},v0;for(v0 in r0)r0[v0]===void 0?delete o0[v0]:o0[v0]=r0[v0];var i0=[];for(v0 in o0)i0.push(`${v0}=${o0[v0]}`);G0=i0}return G0},G0,sy=[null,[],[]],dy=[31,29,31,30,31,30,31,31,30,31,30,31],Vy=[31,28,31,30,31,30,31,31,30,31,30,31];function Xy(o0){var v0=Array(uy(o0)+1);return Dy(o0,v0,0,v0.length),v0}function hy(o0,v0,i0,k0){function $0(X0,Pv,Fv){for(X0=typeof X0=="number"?X0.toString():X0||"";X0.length<Pv;)X0=Fv[0]+X0;return X0}function ty(X0,Pv){return $0(X0,Pv,"0")}function my(X0,Pv){function Fv(g1){return 0>g1?-1:0<g1?1:0}var Jv;return(Jv=Fv(X0.getFullYear()-Pv.getFullYear()))===0&&(Jv=Fv(X0.getMonth()-Pv.getMonth()))===0&&(Jv=Fv(X0.getDate()-Pv.getDate())),Jv}function ev(X0){switch(X0.getDay()){case 0:return new Date(X0.getFullYear()-1,11,29);case 1:return X0;case 2:return new Date(X0.getFullYear(),0,3);case 3:return new Date(X0.getFullYear(),0,2);case 4:return new Date(X0.getFullYear(),0,1);case 5:return new Date(X0.getFullYear()-1,11,31);case 6:return new Date(X0.getFullYear()-1,11,30)}}function vv(X0){var Pv=X0.sa;for(X0=new Date(new Date(X0.ta+1900,0,1).getTime());0<Pv;){var Fv=X0.getMonth(),Jv=(Fy(X0.getFullYear())?dy:Vy)[Fv];if(Pv>Jv-X0.getDate())Pv-=Jv-X0.getDate()+1,X0.setDate(1),11>Fv?X0.setMonth(Fv+1):(X0.setMonth(0),X0.setFullYear(X0.getFullYear()+1));else{X0.setDate(X0.getDate()+Pv);break}}return Fv=new Date(X0.getFullYear()+1,0,4),Pv=ev(new Date(X0.getFullYear(),0,4)),Fv=ev(Fv),0>=my(Pv,X0)?0>=my(Fv,X0)?X0.getFullYear()+1:X0.getFullYear():X0.getFullYear()-1}o0>>>=0,v0>>>=0,i0>>>=0,k0>>>=0;var Tv=f0[k0+40>>>2>>>0];k0={Ba:ko[k0>>>2>>>0],Aa:ko[k0+4>>>2>>>0],ua:ko[k0+8>>>2>>>0],xa:ko[k0+12>>>2>>>0],va:ko[k0+16>>>2>>>0],ta:ko[k0+20>>>2>>>0],na:ko[k0+24>>>2>>>0],sa:ko[k0+28>>>2>>>0],Da:ko[k0+32>>>2>>>0],za:ko[k0+36>>>2>>>0],Ca:Tv?yy(Tv):""},i0=yy(i0),Tv={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var Rv in Tv)i0=i0.replace(new RegExp(Rv,"g"),Tv[Rv]);var Lv="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Yv="January February March April May June July August September October November December".split(" ");Tv={"%a":X0=>Lv[X0.na].substring(0,3),"%A":X0=>Lv[X0.na],"%b":X0=>Yv[X0.va].substring(0,3),"%B":X0=>Yv[X0.va],"%C":X0=>ty((X0.ta+1900)/100|0,2),"%d":X0=>ty(X0.xa,2),"%e":X0=>$0(X0.xa,2," "),"%g":X0=>vv(X0).toString().substring(2),"%G":vv,"%H":X0=>ty(X0.ua,2),"%I":X0=>(X0=X0.ua,X0==0?X0=12:12<X0&&(X0-=12),ty(X0,2)),"%j":X0=>{for(var Pv=0,Fv=0;Fv<=X0.va-1;Pv+=(Fy(X0.ta+1900)?dy:Vy)[Fv++]);return ty(X0.xa+Pv,3)},"%m":X0=>ty(X0.va+1,2),"%M":X0=>ty(X0.Aa,2),"%n":()=>`
`,"%p":X0=>0<=X0.ua&&12>X0.ua?"AM":"PM","%S":X0=>ty(X0.Ba,2),"%t":()=>"	","%u":X0=>X0.na||7,"%U":X0=>ty(Math.floor((X0.sa+7-X0.na)/7),2),"%V":X0=>{var Pv=Math.floor((X0.sa+7-(X0.na+6)%7)/7);if(2>=(X0.na+371-X0.sa-2)%7&&Pv++,Pv)Pv==53&&(Fv=(X0.na+371-X0.sa)%7,Fv==4||Fv==3&&Fy(X0.ta)||(Pv=1));else{Pv=52;var Fv=(X0.na+7-X0.sa-1)%7;(Fv==4||Fv==5&&Fy(X0.ta%400-1))&&Pv++}return ty(Pv,2)},"%w":X0=>X0.na,"%W":X0=>ty(Math.floor((X0.sa+7-(X0.na+6)%7)/7),2),"%y":X0=>(X0.ta+1900).toString().substring(2),"%Y":X0=>X0.ta+1900,"%z":X0=>{X0=X0.za;var Pv=0<=X0;return X0=Math.abs(X0)/60,(Pv?"+":"-")+("0000"+(X0/60*100+X0%60)).slice(-4)},"%Z":X0=>X0.Ca,"%%":()=>"%"},i0=i0.replace(/%%/g,"\0\0");for(Rv in Tv)i0.includes(Rv)&&(i0=i0.replace(new RegExp(Rv,"g"),Tv[Rv](k0)));return i0=i0.replace(/\0\0/g,"%"),Rv=Xy(i0),Rv.length>v0?0:(Xo.set(Rv,o0>>>0),Rv.length-1)}var Ly={a:function(o0,v0,i0){o0>>>=0;var k0=new Ey(o0);throw f0[k0.wa+16>>>2>>>0]=0,f0[k0.wa+4>>>2>>>0]=v0>>>0,f0[k0.wa+8>>>2>>>0]=i0>>>0,_0=o0,_0},e:function(){return 0},H:function(){},x:function(){},z:function(){},J:function(){return 0},F:function(){},A:function(){},E:function(){},g:function(){},y:function(){},v:function(){},G:function(){},w:function(){},k:()=>1,I:function(o0,v0,i0){return v0>>>=0,Kr.copyWithin(o0>>>0>>>0,v0>>>0,v0+(i0>>>0)>>>0)},n:function(o0,v0,i0){o0=v0+2097152>>>0<4194305-!!o0?(o0>>>0)+4294967296*v0:NaN,i0>>>=0,o0=new Date(1e3*o0),ko[i0>>>2>>>0]=o0.getUTCSeconds(),ko[i0+4>>>2>>>0]=o0.getUTCMinutes(),ko[i0+8>>>2>>>0]=o0.getUTCHours(),ko[i0+12>>>2>>>0]=o0.getUTCDate(),ko[i0+16>>>2>>>0]=o0.getUTCMonth(),ko[i0+20>>>2>>>0]=o0.getUTCFullYear()-1900,ko[i0+24>>>2>>>0]=o0.getUTCDay(),ko[i0+28>>>2>>>0]=(o0.getTime()-Date.UTC(o0.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(o0,v0,i0){o0=v0+2097152>>>0<4194305-!!o0?(o0>>>0)+4294967296*v0:NaN,i0>>>=0,o0=new Date(1e3*o0),ko[i0>>>2>>>0]=o0.getSeconds(),ko[i0+4>>>2>>>0]=o0.getMinutes(),ko[i0+8>>>2>>>0]=o0.getHours(),ko[i0+12>>>2>>>0]=o0.getDate(),ko[i0+16>>>2>>>0]=o0.getMonth(),ko[i0+20>>>2>>>0]=o0.getFullYear()-1900,ko[i0+24>>>2>>>0]=o0.getDay(),ko[i0+28>>>2>>>0]=(Fy(o0.getFullYear())?qy:rv)[o0.getMonth()]+o0.getDate()-1|0,ko[i0+36>>>2>>>0]=-(60*o0.getTimezoneOffset()),v0=new Date(o0.getFullYear(),6,1).getTimezoneOffset();var k0=new Date(o0.getFullYear(),0,1).getTimezoneOffset();ko[i0+32>>>2>>>0]=(v0!=k0&&o0.getTimezoneOffset()==Math.min(k0,v0))|0},p:function(o0){o0>>>=0;var v0=new Date(ko[o0+20>>>2>>>0]+1900,ko[o0+16>>>2>>>0],ko[o0+12>>>2>>>0],ko[o0+8>>>2>>>0],ko[o0+4>>>2>>>0],ko[o0>>>2>>>0],0),i0=ko[o0+32>>>2>>>0],k0=v0.getTimezoneOffset(),$0=new Date(v0.getFullYear(),6,1).getTimezoneOffset(),ty=new Date(v0.getFullYear(),0,1).getTimezoneOffset(),my=Math.min(ty,$0);return 0>i0?ko[o0+32>>>2>>>0]=+($0!=ty&&my==k0):0<i0!=(my==k0)&&($0=Math.max(ty,$0),v0.setTime(v0.getTime()+6e4*((0<i0?my:$0)-k0))),ko[o0+24>>>2>>>0]=v0.getDay(),ko[o0+28>>>2>>>0]=(Fy(v0.getFullYear())?qy:rv)[v0.getMonth()]+v0.getDate()-1|0,ko[o0>>>2>>>0]=v0.getSeconds(),ko[o0+4>>>2>>>0]=v0.getMinutes(),ko[o0+8>>>2>>>0]=v0.getHours(),ko[o0+12>>>2>>>0]=v0.getDate(),ko[o0+16>>>2>>>0]=v0.getMonth(),ko[o0+20>>>2>>>0]=v0.getYear(),o0=v0.getTime(),o0=isNaN(o0)?-1:o0/1e3,Sy((My=o0,1<=+Math.abs(My)?0<My?+Math.floor(My/4294967296)>>>0:~~+Math.ceil((My-+(~~My>>>0))/4294967296)>>>0:0)),o0>>>0},l:function(){return-52},m:function(){},t:function(o0,v0,i0,k0){i0>>>=0,k0>>>=0;var $0=new Date().getFullYear(),ty=new Date($0,0,1),my=new Date($0,6,1);$0=ty.getTimezoneOffset();var ev=my.getTimezoneOffset();f0[o0>>>0>>>2>>>0]=60*Math.max($0,ev),ko[v0>>>0>>>2>>>0]=+($0!=ev),o0=vv=>vv.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],ty=o0(ty),my=o0(my),ev<$0?(Dy(ty,Kr,i0,17),Dy(my,Kr,k0,17)):(Dy(ty,Kr,k0,17),Dy(my,Kr,i0,17))},d:()=>{h0("")},B:function(o0,v0,i0){o0>>>=0,v0>>>=0,i0>>>=0,y0.length=0;for(var k0;k0=Kr[v0++>>>0];){var $0=k0!=105;$0&=k0!=112,i0+=$0&&i0%8?4:0,y0.push(k0==112?f0[i0>>>2>>>0]:k0==105?ko[i0>>>2>>>0]:x0[i0>>>3>>>0]),i0+=$0?8:4}return Wy[o0](...y0)},h:()=>Date.now(),u:function(){return 4294901760},b:()=>performance.now(),s:function(o0){o0>>>=0;var v0=Kr.length;if(4294901760<o0)return!1;for(var i0=1;4>=i0;i0*=2){var k0=v0*(1+.2/i0);k0=Math.min(k0,o0+100663296);var $0=Math;k0=Math.max(o0,k0);e:{$0=($0.min.call($0,4294901760,k0+(65536-k0%65536)%65536)-Zr.buffer.byteLength+65535)/65536;try{Zr.grow($0),l0();var ty=1;break e}catch{}ty=void 0}if(ty)return!0}return!1},C:function(o0,v0){o0>>>=0,v0>>>=0;var i0=0;return M0().forEach((k0,$0)=>{var ty=v0+i0;for($0=f0[o0+4*$0>>>2>>>0]=ty,ty=0;ty<k0.length;++ty)Xo[$0++>>>0]=k0.charCodeAt(ty);Xo[$0>>>0]=0,i0+=k0.length+1}),0},D:function(o0,v0){o0>>>=0,v0>>>=0;var i0=M0();f0[o0>>>2>>>0]=i0.length;var k0=0;return i0.forEach($0=>k0+=$0.length+1),f0[v0>>>2>>>0]=k0,0},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(o0,v0,i0,k0){v0>>>=0,i0>>>=0,k0>>>=0;for(var $0=0,ty=0;ty<i0;ty++){var my=f0[v0>>>2>>>0],ev=f0[v0+4>>>2>>>0];v0+=8;for(var vv=0;vv<ev;vv++){var Tv=Kr[my+vv>>>0],Rv=sy[o0];Tv===0||Tv===10?((o0===1?Hr:qr)(J0(Rv,0)),Rv.length=0):Rv.push(Tv)}$0+=ev}return f0[k0>>>2>>>0]=$0,0},r:hy,c:function(o0,v0,i0,k0){return hy(o0>>>0,v0>>>0,i0>>>0,k0>>>0)}},Py=function(){function o0(i0){return Py=i0.exports,Py=C0(),Zr=Py.K,l0(),t0.unshift(Py.L),n0--,n0==0&&m0&&(i0=m0,m0=null,i0()),Py}var v0={a:Ly};if(n0++,Tt.instantiateWasm)try{return Tt.instantiateWasm(v0,o0)}catch(i0){qr(`Module.instantiateWasm callback failed with error: ${i0}`),Ft(i0)}return $y(v0,function(i0){o0(i0.instance)}).catch(Ft),{}}();Tt._OrtInit=(o0,v0)=>(Tt._OrtInit=Py.M)(o0,v0),Tt._OrtGetLastError=(o0,v0)=>(Tt._OrtGetLastError=Py.N)(o0,v0),Tt._OrtCreateSessionOptions=(o0,v0,i0,k0,$0,ty,my,ev,vv,Tv)=>(Tt._OrtCreateSessionOptions=Py.O)(o0,v0,i0,k0,$0,ty,my,ev,vv,Tv),Tt._OrtAppendExecutionProvider=(o0,v0)=>(Tt._OrtAppendExecutionProvider=Py.P)(o0,v0),Tt._OrtAddFreeDimensionOverride=(o0,v0,i0)=>(Tt._OrtAddFreeDimensionOverride=Py.Q)(o0,v0,i0),Tt._OrtAddSessionConfigEntry=(o0,v0,i0)=>(Tt._OrtAddSessionConfigEntry=Py.R)(o0,v0,i0),Tt._OrtReleaseSessionOptions=o0=>(Tt._OrtReleaseSessionOptions=Py.S)(o0),Tt._OrtCreateSession=(o0,v0,i0)=>(Tt._OrtCreateSession=Py.T)(o0,v0,i0),Tt._OrtReleaseSession=o0=>(Tt._OrtReleaseSession=Py.U)(o0),Tt._OrtGetInputOutputCount=(o0,v0,i0)=>(Tt._OrtGetInputOutputCount=Py.V)(o0,v0,i0),Tt._OrtGetInputName=(o0,v0)=>(Tt._OrtGetInputName=Py.W)(o0,v0),Tt._OrtGetOutputName=(o0,v0)=>(Tt._OrtGetOutputName=Py.X)(o0,v0),Tt._OrtFree=o0=>(Tt._OrtFree=Py.Y)(o0),Tt._OrtCreateTensor=(o0,v0,i0,k0,$0,ty)=>(Tt._OrtCreateTensor=Py.Z)(o0,v0,i0,k0,$0,ty),Tt._OrtGetTensorData=(o0,v0,i0,k0,$0)=>(Tt._OrtGetTensorData=Py._)(o0,v0,i0,k0,$0),Tt._OrtReleaseTensor=o0=>(Tt._OrtReleaseTensor=Py.$)(o0),Tt._OrtCreateRunOptions=(o0,v0,i0,k0)=>(Tt._OrtCreateRunOptions=Py.aa)(o0,v0,i0,k0),Tt._OrtAddRunConfigEntry=(o0,v0,i0)=>(Tt._OrtAddRunConfigEntry=Py.ba)(o0,v0,i0),Tt._OrtReleaseRunOptions=o0=>(Tt._OrtReleaseRunOptions=Py.ca)(o0),Tt._OrtCreateBinding=o0=>(Tt._OrtCreateBinding=Py.da)(o0),Tt._OrtBindInput=(o0,v0,i0)=>(Tt._OrtBindInput=Py.ea)(o0,v0,i0),Tt._OrtBindOutput=(o0,v0,i0,k0)=>(Tt._OrtBindOutput=Py.fa)(o0,v0,i0,k0),Tt._OrtClearBoundOutputs=o0=>(Tt._OrtClearBoundOutputs=Py.ga)(o0),Tt._OrtReleaseBinding=o0=>(Tt._OrtReleaseBinding=Py.ha)(o0),Tt._OrtRunWithBinding=(o0,v0,i0,k0,$0)=>(Tt._OrtRunWithBinding=Py.ia)(o0,v0,i0,k0,$0),Tt._OrtRun=(o0,v0,i0,k0,$0,ty,my,ev)=>(Tt._OrtRun=Py.ja)(o0,v0,i0,k0,$0,ty,my,ev),Tt._OrtEndProfiling=o0=>(Tt._OrtEndProfiling=Py.ka)(o0),Tt._malloc=o0=>(Tt._malloc=Py.la)(o0),Tt._free=o0=>(Tt._free=Py.ma)(o0);var Sy=o0=>(Sy=Py.oa)(o0),Ev=o0=>(Ev=Py.pa)(o0),Qy=o0=>(Qy=Py.qa)(o0),cy=()=>(cy=Py.ra)();function C0(){var o0=Py;o0=Object.assign({},o0);var v0=i0=>k0=>i0(k0)>>>0;return o0.la=v0(o0.la),o0.qa=v0(o0.qa),o0.ra=(i0=>()=>i0()>>>0)(o0.ra),o0}Tt.stackSave=()=>cy(),Tt.stackRestore=o0=>Ev(o0),Tt.stackAlloc=o0=>Qy(o0),Tt.UTF8ToString=yy,Tt.stringToUTF8=(o0,v0,i0)=>Dy(o0,Kr,v0,i0),Tt.lengthBytesUTF8=uy;var U0;m0=function o0(){U0||xy(),U0||(m0=o0)};function xy(){if(!(0<n0)){if(Tt.preRun)for(typeof Tt.preRun=="function"&&(Tt.preRun=[Tt.preRun]);Tt.preRun.length;){var o0=Tt.preRun.shift();T0.unshift(o0)}for(;0<T0.length;)T0.shift()(Tt);if(!(0<n0||U0||(U0=!0,Tt.calledRun=!0,Bo))){for(;0<t0.length;)t0.shift()(Tt);for(Lt(Tt);0<E0.length;)E0.shift()(Tt)}}}return xy(),Ct}})();typeof st=="object"&&typeof at=="object"?at.exports=pt:typeof define=="function"&&define.amd&&define([],()=>pt)}),Ep$1=me(()=>{}),Dp$1=me(()=>{}),Lp$1={};Sr(Lp$1,{cpus:()=>ig});var ig,Cp$1=L(()=>{ig=void 0}),kp$1=me((st,at)=>{var pt=(()=>{var wt;var vt=typeof document<"u"?(wt=document.currentScript)==null?void 0:wt.src:void 0;return typeof __filename<"u"&&(vt||(vt=__filename)),function($t={}){function Tt(){return E0.buffer!=a0.buffer&&K0(),a0}function Lt(){return E0.buffer!=a0.buffer&&K0(),P0}function Ft(){return E0.buffer!=a0.buffer&&K0(),V0}function Ct(){return E0.buffer!=a0.buffer&&K0(),B0}function Ht(){return E0.buffer!=a0.buffer&&K0(),W0}var Gt=$t,jt,qt,Kt=new Promise((No,ir)=>{jt=No,qt=ir}),An=Object.assign({},Gt),Sn="./this.program",wn=(No,ir)=>{throw ir},In=typeof window=="object",tr=typeof importScripts=="function",rr=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",Hr=Gt.ENVIRONMENT_IS_PTHREAD||!1,qr="";function Zr(No){return Gt.locateFile?Gt.locateFile(No,qr):qr+No}var Bo,Xo,Kr;if(rr){var ko=(Qi$1(),ar(Zi$1)),f0=(ta(),ar(ea));qr=tr?f0.dirname(qr)+"/":__dirname+"/",Bo=(No,ir)=>(No=uy(No)?new URL(No):f0.normalize(No),ko.readFileSync(No,ir?void 0:"utf8")),Kr=No=>(No=Bo(No,!0),No.buffer||(No=new Uint8Array(No)),No),Xo=(No,ir,jr,Ro=!0)=>{No=uy(No)?new URL(No):f0.normalize(No),ko.readFile(No,Ro?void 0:"utf8",(_g,d0)=>{_g?jr(_g):ir(Ro?d0.buffer:d0)})},!Gt.thisProgram&&1<process.argv.length&&(Sn=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),wn=(No,ir)=>{throw process.exitCode=No,ir},global.Worker=Ep$1().Worker}else(In||tr)&&(tr?qr=self.location.href:typeof document<"u"&&document.currentScript&&(qr=document.currentScript.src),typeof vt<"u"&&vt&&(qr=vt),qr.startsWith("blob:")?qr="":qr=qr.substr(0,qr.replace(/[?#].*/,"").lastIndexOf("/")+1),rr||(Bo=No=>{var ir=new XMLHttpRequest;return ir.open("GET",No,!1),ir.send(null),ir.responseText},tr&&(Kr=No=>{var ir=new XMLHttpRequest;return ir.open("GET",No,!1),ir.responseType="arraybuffer",ir.send(null),new Uint8Array(ir.response)}),Xo=(No,ir,jr)=>{var Ro=new XMLHttpRequest;Ro.open("GET",No,!0),Ro.responseType="arraybuffer",Ro.onload=()=>{Ro.status==200||Ro.status==0&&Ro.response?ir(Ro.response):jr()},Ro.onerror=jr,Ro.send(null)}));rr&&typeof performance>"u"&&(global.performance=Dp$1().performance);var x0=console.log.bind(console),l0=console.error.bind(console);rr&&(x0=(...No)=>ko.writeSync(1,No.join(" ")+`
`),l0=(...No)=>ko.writeSync(2,No.join(" ")+`
`));var T0=x0,t0=l0;Object.assign(Gt,An),An=null;var E0,n0,m0=!1,h0,a0,P0,V0,B0,W0;function K0(){var No=E0.buffer;Gt.HEAP8=a0=new Int8Array(No),Gt.HEAP16=new Int16Array(No),Gt.HEAPU8=P0=new Uint8Array(No),Gt.HEAPU16=new Uint16Array(No),Gt.HEAP32=V0=new Int32Array(No),Gt.HEAPU32=B0=new Uint32Array(No),Gt.HEAPF32=new Float32Array(No),Gt.HEAPF64=W0=new Float64Array(No)}var Ty=16777216;if(Hr)E0=Gt.wasmMemory;else if(Gt.wasmMemory)E0=Gt.wasmMemory;else if(E0=new WebAssembly.Memory({initial:Ty/65536,maximum:65536,shared:!0}),!(E0.buffer instanceof SharedArrayBuffer))throw t0("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),rr&&t0("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");K0(),Ty=E0.buffer.byteLength;var $y=[],My=[],Wy=[],Ey=0,_0=null;function ay(){if(Ey--,Ey==0&&_0){var No=_0;_0=null,No()}}function J0(No){throw No="Aborted("+No+")",t0(No),m0=!0,h0=1,No=new WebAssembly.RuntimeError(No+". Build with -sASSERTIONS for more info."),qt(No),No}var yy=No=>No.startsWith("data:application/octet-stream;base64,"),uy=No=>No.startsWith("file://"),Dy;Dy="ort-wasm-threaded.wasm",yy(Dy)||(Dy=Zr(Dy));function Fy(No){if(Kr)return Kr(No);throw"both async and sync fetching of the wasm failed"}function qy(No){if(In||tr){if(typeof fetch=="function"&&!uy(No))return fetch(No,{credentials:"same-origin"}).then(ir=>{if(!ir.ok)throw`failed to load wasm binary file at '${No}'`;return ir.arrayBuffer()}).catch(()=>Fy(No));if(Xo)return new Promise((ir,jr)=>{Xo(No,Ro=>ir(new Uint8Array(Ro)),jr)})}return Promise.resolve().then(()=>Fy(No))}function rv(No,ir,jr){return qy(No).then(Ro=>WebAssembly.instantiate(Ro,ir)).then(jr,Ro=>{t0(`failed to asynchronously prepare wasm: ${Ro}`),J0(Ro)})}function y0(No,ir){var jr=Dy;return typeof WebAssembly.instantiateStreaming!="function"||yy(jr)||uy(jr)||rr||typeof fetch!="function"?rv(jr,No,ir):fetch(jr,{credentials:"same-origin"}).then(Ro=>WebAssembly.instantiateStreaming(Ro,No).then(ir,function(_g){return t0(`wasm streaming compile failed: ${_g}`),t0("falling back to ArrayBuffer instantiation"),rv(jr,No,ir)}))}var r0,M0={799444:(No,ir,jr,Ro)=>{if(typeof Gt>"u"||!Gt.bb)return 1;if(No=ev(No>>>0),No.startsWith("./")&&(No=No.substring(2)),No=Gt.bb.get(No),!No)return 2;if(ir>>>=0,jr>>>=0,Ro>>>=0,ir+jr>No.byteLength)return 3;try{return Lt().set(No.subarray(ir,ir+jr),Ro>>>0),0}catch{return 4}}};function G0(No){this.name="ExitStatus",this.message=`Program terminated with exit(${No})`,this.status=No}var sy=No=>{No.terminate(),No.onmessage=()=>{}},dy=No=>{cy.Oa.length==0&&(Ev(),cy.Xa(cy.Oa[0]));var ir=cy.Oa.pop();if(!ir)return 6;cy.Pa.push(ir),cy.La[No.Na]=ir,ir.Na=No.Na;var jr={cmd:"run",start_routine:No.gb,arg:No.cb,pthread_ptr:No.Na};return rr&&ir.unref(),ir.postMessage(jr,No.mb),0},Vy=0,Xy=No=>{var ir=z1();return No=No(),x1(ir),No},hy=(No,ir,...jr)=>Xy(()=>{for(var Ro=jr.length,_g=m_(8*Ro),d0=_g>>>3,L0=0;L0<jr.length;L0++){var by=jr[L0];Ht()[d0+L0>>>0]=by}return n1(No,0,Ro,_g,ir)});function Ly(No){var ir;if(Hr)return hy(0,1,No);h0=No,0<Vy||(cy.hb(),(ir=Gt.onExit)==null||ir.call(Gt,No),m0=!0),wn(No,new G0(No))}var Py=No=>{if(h0=No,Hr)throw U0(No),"unwind";Ly(No)};function Sy(){for(var No=Gt.numThreads;No--;)Ev();$y.unshift(()=>{Ey++,Qy(()=>ay())})}function Ev(){var No=Zr("ort-wasm-threaded.worker.js");No=new Worker(No),cy.Oa.push(No)}function Qy(No){Hr?No():Promise.all(cy.Oa.map(cy.Xa)).then(No)}var cy={Oa:[],Pa:[],ab:[],La:{},Va(){Hr?(cy.receiveObjectTransfer=cy.fb,cy.threadInitTLS=cy.$a,cy.setExitStatus=cy.Za):Sy()},Za:No=>h0=No,pb:["$terminateWorker"],hb:()=>{for(var No of cy.Pa)sy(No);for(No of cy.Oa)sy(No);cy.Oa=[],cy.Pa=[],cy.La=[]},Ya:No=>{var ir=No.Na;delete cy.La[ir],cy.Oa.push(No),cy.Pa.splice(cy.Pa.indexOf(No),1),No.Na=0,m1(ir)},fb(){},$a(){cy.ab.forEach(No=>No())},Xa:No=>new Promise(ir=>{No.onmessage=d0=>{d0=d0.data;var L0=d0.cmd;if(d0.targetThread&&d0.targetThread!=Av()){var by=cy.La[d0.targetThread];by?by.postMessage(d0,d0.transferList):t0(`Internal error! Worker sent a message "${L0}" to target pthread ${d0.targetThread}, but that thread no longer exists!`)}else L0==="checkMailbox"?g0():L0==="spawnThread"?dy(d0):L0==="cleanupThread"?cy.Ya(cy.La[d0.thread]):L0==="killThread"?(d0=d0.thread,L0=cy.La[d0],delete cy.La[d0],sy(L0),m1(d0),cy.Pa.splice(cy.Pa.indexOf(L0),1),L0.Na=0):L0==="cancelThread"?cy.La[d0.thread].postMessage({cmd:"cancel"}):L0==="loaded"?(No.loaded=!0,rr&&!No.Na&&No.unref(),ir(No)):L0==="alert"?alert(`Thread ${d0.threadId}: ${d0.text}`):d0.target==="setimmediate"?No.postMessage(d0):L0==="callHandler"?Gt[d0.handler](...d0.args):L0&&t0(`worker sent an unknown command ${L0}`)},No.onerror=d0=>{throw t0(`worker sent an error! ${d0.filename}:${d0.lineno}: ${d0.message}`),d0},rr&&(No.on("message",d0=>No.onmessage({data:d0})),No.on("error",d0=>No.onerror(d0)));var jr=[],Ro=["onExit"],_g;for(_g of Ro)Gt.hasOwnProperty(_g)&&jr.push(_g);No.postMessage({cmd:"load",handlers:jr,urlOrBlob:Gt.mainScriptUrlOrBlob||vt,wasmMemory:E0,wasmModule:n0})})};Gt.PThread=cy;var C0=No=>{for(;0<No.length;)No.shift()(Gt)};Gt.establishStackSpace=()=>{var No=Av(),ir=Ct()[No+52>>>2>>>0];No=Ct()[No+56>>>2>>>0],d_(ir,ir-No),x1(ir)};function U0(No){if(Hr)return hy(1,0,No);Py(No)}var xy=[],o0;Gt.invokeEntryPoint=(No,ir)=>{Vy=0;var jr=xy[No];jr||(No>=xy.length&&(xy.length=No+1),xy[No]=jr=o0.get(No)),No=jr(ir),0<Vy?cy.Za(No):i1(No)};class v0{constructor(ir){this.Ua=ir-24}Va(ir,jr){Ct()[this.Ua+16>>>2>>>0]=0,Ct()[this.Ua+4>>>2>>>0]=ir,Ct()[this.Ua+8>>>2>>>0]=jr}}var i0=0;function k0(No,ir,jr,Ro){return Hr?hy(2,1,No,ir,jr,Ro):$0(No,ir,jr,Ro)}function $0(No,ir,jr,Ro){if(No>>>=0,ir>>>=0,jr>>>=0,Ro>>>=0,typeof SharedArrayBuffer>"u")return t0("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var _g=[];return Hr&&_g.length===0?k0(No,ir,jr,Ro):(No={gb:jr,Na:No,cb:Ro,mb:_g},Hr?(No.ob="spawnThread",postMessage(No,_g),0):dy(No))}var ty=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,my=(No,ir,jr)=>{ir>>>=0;var Ro=ir+jr;for(jr=ir;No[jr]&&!(jr>=Ro);)++jr;if(16<jr-ir&&No.buffer&&ty)return ty.decode(No.buffer instanceof SharedArrayBuffer?No.slice(ir,jr):No.subarray(ir,jr));for(Ro="";ir<jr;){var _g=No[ir++];if(_g&128){var d0=No[ir++]&63;if((_g&224)==192)Ro+=String.fromCharCode((_g&31)<<6|d0);else{var L0=No[ir++]&63;_g=(_g&240)==224?(_g&15)<<12|d0<<6|L0:(_g&7)<<18|d0<<12|L0<<6|No[ir++]&63,65536>_g?Ro+=String.fromCharCode(_g):(_g-=65536,Ro+=String.fromCharCode(55296|_g>>10,56320|_g&1023))}}else Ro+=String.fromCharCode(_g)}return Ro},ev=(No,ir)=>(No>>>=0)?my(Lt(),No,ir):"";function vv(No,ir,jr){return Hr?hy(3,1,No,ir,jr):0}function Tv(No,ir){if(Hr)return hy(4,1,No,ir)}var Rv=No=>{for(var ir=0,jr=0;jr<No.length;++jr){var Ro=No.charCodeAt(jr);127>=Ro?ir++:2047>=Ro?ir+=2:55296<=Ro&&57343>=Ro?(ir+=4,++jr):ir+=3}return ir},Lv=(No,ir,jr,Ro)=>{if(jr>>>=0,!(0<Ro))return 0;var _g=jr;Ro=jr+Ro-1;for(var d0=0;d0<No.length;++d0){var L0=No.charCodeAt(d0);if(55296<=L0&&57343>=L0){var by=No.charCodeAt(++d0);L0=65536+((L0&1023)<<10)|by&1023}if(127>=L0){if(jr>=Ro)break;ir[jr++>>>0]=L0}else{if(2047>=L0){if(jr+1>=Ro)break;ir[jr++>>>0]=192|L0>>6}else{if(65535>=L0){if(jr+2>=Ro)break;ir[jr++>>>0]=224|L0>>12}else{if(jr+3>=Ro)break;ir[jr++>>>0]=240|L0>>18,ir[jr++>>>0]=128|L0>>12&63}ir[jr++>>>0]=128|L0>>6&63}ir[jr++>>>0]=128|L0&63}}return ir[jr>>>0]=0,jr-_g},Yv=(No,ir,jr)=>Lv(No,Lt(),ir,jr);function X0(No,ir){if(Hr)return hy(5,1,No,ir)}function Pv(No,ir,jr){if(Hr)return hy(6,1,No,ir,jr)}function Fv(No,ir,jr){return Hr?hy(7,1,No,ir,jr):0}function Jv(No,ir){if(Hr)return hy(8,1,No,ir)}function g1(No,ir,jr){if(Hr)return hy(9,1,No,ir,jr)}function _v(No,ir,jr,Ro){if(Hr)return hy(10,1,No,ir,jr,Ro)}function Y1(No,ir,jr,Ro){if(Hr)return hy(11,1,No,ir,jr,Ro)}function c_(No,ir,jr,Ro){if(Hr)return hy(12,1,No,ir,jr,Ro)}function Qo(No){if(Hr)return hy(13,1,No)}function c0(No,ir){if(Hr)return hy(14,1,No,ir)}function D0(No,ir,jr){if(Hr)return hy(15,1,No,ir,jr)}function Go(No){No>>>=0,typeof Atomics.nb=="function"&&(Atomics.nb(Ft(),No>>>2,No).value.then(g0),No+=128,Atomics.store(Ft(),No>>>2,1))}Gt.__emscripten_thread_mailbox_await=Go;var g0=()=>{var No=Av();if(No&&(Go(No),No=S1,!m0))try{if(No(),!(0<Vy))try{Hr?i1(h0):Py(h0)}catch(ir){ir instanceof G0||ir=="unwind"||wn(1,ir)}}catch(ir){ir instanceof G0||ir=="unwind"||wn(1,ir)}};Gt.checkMailbox=g0;var b0=[],I0=No=>No%4===0&&(No%100!==0||No%400===0),A0=[0,31,60,91,121,152,182,213,244,274,305,335],Y0=[0,31,59,90,120,151,181,212,243,273,304,334];function ey(No,ir,jr,Ro,_g,d0,L0,by){return Hr?hy(16,1,No,ir,jr,Ro,_g,d0,L0,by):-52}function ny(No,ir,jr,Ro,_g,d0,L0){if(Hr)return hy(17,1,No,ir,jr,Ro,_g,d0,L0)}var ry=[],Ky={},wy=()=>{if(!Ry){var No={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:Sn||"./this.program"},ir;for(ir in Ky)Ky[ir]===void 0?delete No[ir]:No[ir]=Ky[ir];var jr=[];for(ir in No)jr.push(`${ir}=${No[ir]}`);Ry=jr}return Ry},Ry;function Hy(No,ir){if(Hr)return hy(18,1,No,ir);No>>>=0,ir>>>=0;var jr=0;return wy().forEach((Ro,_g)=>{var d0=ir+jr;for(_g=Ct()[No+4*_g>>>2>>>0]=d0,d0=0;d0<Ro.length;++d0)Tt()[_g++>>>0]=Ro.charCodeAt(d0);Tt()[_g>>>0]=0,jr+=Ro.length+1}),0}function uv(No,ir){if(Hr)return hy(19,1,No,ir);No>>>=0,ir>>>=0;var jr=wy();Ct()[No>>>2>>>0]=jr.length;var Ro=0;return jr.forEach(_g=>Ro+=_g.length+1),Ct()[ir>>>2>>>0]=Ro,0}function dv(No){return Hr?hy(20,1,No):52}function pv(No,ir,jr,Ro){return Hr?hy(21,1,No,ir,jr,Ro):52}function Zy(No,ir,jr,Ro,_g){return Hr?hy(22,1,No,ir,jr,Ro,_g):70}var By=[null,[],[]];function bv(No,ir,jr,Ro){if(Hr)return hy(23,1,No,ir,jr,Ro);ir>>>=0,jr>>>=0,Ro>>>=0;for(var _g=0,d0=0;d0<jr;d0++){var L0=Ct()[ir>>>2>>>0],by=Ct()[ir+4>>>2>>>0];ir+=8;for(var ky=0;ky<by;ky++){var Oy=Lt()[L0+ky>>>0],Uy=By[No];Oy===0||Oy===10?((No===1?T0:t0)(my(Uy,0)),Uy.length=0):Uy.push(Oy)}_g+=by}return Ct()[Ro>>>2>>>0]=_g,0}var fv=[31,29,31,30,31,30,31,31,30,31,30,31],xv=[31,28,31,30,31,30,31,31,30,31,30,31];function t1(No){var ir=Array(Rv(No)+1);return Lv(No,ir,0,ir.length),ir}var u1=(No,ir)=>{Tt().set(No,ir>>>0)};function c1(No,ir,jr,Ro){function _g(Q0,q0,Yy){for(Q0=typeof Q0=="number"?Q0.toString():Q0||"";Q0.length<q0;)Q0=Yy[0]+Q0;return Q0}function d0(Q0,q0){return _g(Q0,q0,"0")}function L0(Q0,q0){function Yy(Zv){return 0>Zv?-1:0<Zv?1:0}var av;return(av=Yy(Q0.getFullYear()-q0.getFullYear()))===0&&(av=Yy(Q0.getMonth()-q0.getMonth()))===0&&(av=Yy(Q0.getDate()-q0.getDate())),av}function by(Q0){switch(Q0.getDay()){case 0:return new Date(Q0.getFullYear()-1,11,29);case 1:return Q0;case 2:return new Date(Q0.getFullYear(),0,3);case 3:return new Date(Q0.getFullYear(),0,2);case 4:return new Date(Q0.getFullYear(),0,1);case 5:return new Date(Q0.getFullYear()-1,11,31);case 6:return new Date(Q0.getFullYear()-1,11,30)}}function ky(Q0){var q0=Q0.Qa;for(Q0=new Date(new Date(Q0.Ra+1900,0,1).getTime());0<q0;){var Yy=Q0.getMonth(),av=(I0(Q0.getFullYear())?fv:xv)[Yy];if(q0>av-Q0.getDate())q0-=av-Q0.getDate()+1,Q0.setDate(1),11>Yy?Q0.setMonth(Yy+1):(Q0.setMonth(0),Q0.setFullYear(Q0.getFullYear()+1));else{Q0.setDate(Q0.getDate()+q0);break}}return Yy=new Date(Q0.getFullYear()+1,0,4),q0=by(new Date(Q0.getFullYear(),0,4)),Yy=by(Yy),0>=L0(q0,Q0)?0>=L0(Yy,Q0)?Q0.getFullYear()+1:Q0.getFullYear():Q0.getFullYear()-1}No>>>=0,ir>>>=0,jr>>>=0,Ro>>>=0;var Oy=Ct()[Ro+40>>>2>>>0];Ro={kb:Ft()[Ro>>>2>>>0],jb:Ft()[Ro+4>>>2>>>0],Sa:Ft()[Ro+8>>>2>>>0],Wa:Ft()[Ro+12>>>2>>>0],Ta:Ft()[Ro+16>>>2>>>0],Ra:Ft()[Ro+20>>>2>>>0],Ma:Ft()[Ro+24>>>2>>>0],Qa:Ft()[Ro+28>>>2>>>0],qb:Ft()[Ro+32>>>2>>>0],ib:Ft()[Ro+36>>>2>>>0],lb:Oy?ev(Oy):""},jr=ev(jr),Oy={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var Uy in Oy)jr=jr.replace(new RegExp(Uy,"g"),Oy[Uy]);var hv="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Hv="January February March April May June July August September October November December".split(" ");Oy={"%a":Q0=>hv[Q0.Ma].substring(0,3),"%A":Q0=>hv[Q0.Ma],"%b":Q0=>Hv[Q0.Ta].substring(0,3),"%B":Q0=>Hv[Q0.Ta],"%C":Q0=>d0((Q0.Ra+1900)/100|0,2),"%d":Q0=>d0(Q0.Wa,2),"%e":Q0=>_g(Q0.Wa,2," "),"%g":Q0=>ky(Q0).toString().substring(2),"%G":ky,"%H":Q0=>d0(Q0.Sa,2),"%I":Q0=>(Q0=Q0.Sa,Q0==0?Q0=12:12<Q0&&(Q0-=12),d0(Q0,2)),"%j":Q0=>{for(var q0=0,Yy=0;Yy<=Q0.Ta-1;q0+=(I0(Q0.Ra+1900)?fv:xv)[Yy++]);return d0(Q0.Wa+q0,3)},"%m":Q0=>d0(Q0.Ta+1,2),"%M":Q0=>d0(Q0.jb,2),"%n":()=>`
`,"%p":Q0=>0<=Q0.Sa&&12>Q0.Sa?"AM":"PM","%S":Q0=>d0(Q0.kb,2),"%t":()=>"	","%u":Q0=>Q0.Ma||7,"%U":Q0=>d0(Math.floor((Q0.Qa+7-Q0.Ma)/7),2),"%V":Q0=>{var q0=Math.floor((Q0.Qa+7-(Q0.Ma+6)%7)/7);if(2>=(Q0.Ma+371-Q0.Qa-2)%7&&q0++,q0)q0==53&&(Yy=(Q0.Ma+371-Q0.Qa)%7,Yy==4||Yy==3&&I0(Q0.Ra)||(q0=1));else{q0=52;var Yy=(Q0.Ma+7-Q0.Qa-1)%7;(Yy==4||Yy==5&&I0(Q0.Ra%400-1))&&q0++}return d0(q0,2)},"%w":Q0=>Q0.Ma,"%W":Q0=>d0(Math.floor((Q0.Qa+7-(Q0.Ma+6)%7)/7),2),"%y":Q0=>(Q0.Ra+1900).toString().substring(2),"%Y":Q0=>Q0.Ra+1900,"%z":Q0=>{Q0=Q0.ib;var q0=0<=Q0;return Q0=Math.abs(Q0)/60,(q0?"+":"-")+("0000"+(Q0/60*100+Q0%60)).slice(-4)},"%Z":Q0=>Q0.lb,"%%":()=>"%"},jr=jr.replace(/%%/g,"\0\0");for(Uy in Oy)jr.includes(Uy)&&(jr=jr.replace(new RegExp(Uy,"g"),Oy[Uy](Ro)));return jr=jr.replace(/\0\0/g,"%"),Uy=t1(jr),Uy.length>ir?0:(u1(Uy,No),Uy.length-1)}cy.Va();var Gv=[Ly,U0,k0,vv,Tv,X0,Pv,Fv,Jv,g1,_v,Y1,c_,Qo,c0,D0,ey,ny,Hy,uv,dv,pv,Zy,bv],Ov={b:function(No,ir,jr){throw No>>>=0,new v0(No).Va(ir>>>0,jr>>>0),i0=No,i0},L:function(No){zy(No>>>0,!tr,1,!In,131072,!1),cy.$a()},j:function(No){No>>>=0,Hr?postMessage({cmd:"cleanupThread",thread:No}):cy.Ya(cy.La[No])},H:$0,h:vv,S:Tv,D:X0,F:Pv,T:Fv,Q:Jv,J:g1,P:_v,n:Y1,E:c_,B:Qo,R:c0,C:D0,p:()=>1,z:function(No,ir){No>>>=0,No==ir>>>0?setTimeout(g0):Hr?postMessage({targetThread:No,cmd:"checkMailbox"}):(No=cy.La[No])&&No.postMessage({cmd:"checkMailbox"})},I:function(No,ir,jr,Ro,_g){ir>>>=0,jr>>>=0,b0.length=Ro,_g=_g>>>0>>>3;for(var d0=0;d0<Ro;d0++)b0[d0]=Ht()[_g+d0>>>0];return No=ir?M0[ir]:Gv[No],cy.eb=jr,jr=No(...b0),cy.eb=0,jr},K:Go,o:function(No){rr&&cy.La[No>>>0].ref()},s:function(No,ir,jr){No=ir+2097152>>>0<4194305-!!No?(No>>>0)+4294967296*ir:NaN,jr>>>=0,No=new Date(1e3*No),Ft()[jr>>>2>>>0]=No.getUTCSeconds(),Ft()[jr+4>>>2>>>0]=No.getUTCMinutes(),Ft()[jr+8>>>2>>>0]=No.getUTCHours(),Ft()[jr+12>>>2>>>0]=No.getUTCDate(),Ft()[jr+16>>>2>>>0]=No.getUTCMonth(),Ft()[jr+20>>>2>>>0]=No.getUTCFullYear()-1900,Ft()[jr+24>>>2>>>0]=No.getUTCDay(),No=(No.getTime()-Date.UTC(No.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,Ft()[jr+28>>>2>>>0]=No},t:function(No,ir,jr){No=ir+2097152>>>0<4194305-!!No?(No>>>0)+4294967296*ir:NaN,jr>>>=0,No=new Date(1e3*No),Ft()[jr>>>2>>>0]=No.getSeconds(),Ft()[jr+4>>>2>>>0]=No.getMinutes(),Ft()[jr+8>>>2>>>0]=No.getHours(),Ft()[jr+12>>>2>>>0]=No.getDate(),Ft()[jr+16>>>2>>>0]=No.getMonth(),Ft()[jr+20>>>2>>>0]=No.getFullYear()-1900,Ft()[jr+24>>>2>>>0]=No.getDay(),ir=(I0(No.getFullYear())?A0:Y0)[No.getMonth()]+No.getDate()-1|0,Ft()[jr+28>>>2>>>0]=ir,Ft()[jr+36>>>2>>>0]=-(60*No.getTimezoneOffset()),ir=new Date(No.getFullYear(),6,1).getTimezoneOffset();var Ro=new Date(No.getFullYear(),0,1).getTimezoneOffset();No=(ir!=Ro&&No.getTimezoneOffset()==Math.min(Ro,ir))|0,Ft()[jr+32>>>2>>>0]=No},u:function(No){No>>>=0;var ir=new Date(Ft()[No+20>>>2>>>0]+1900,Ft()[No+16>>>2>>>0],Ft()[No+12>>>2>>>0],Ft()[No+8>>>2>>>0],Ft()[No+4>>>2>>>0],Ft()[No>>>2>>>0],0),jr=Ft()[No+32>>>2>>>0],Ro=ir.getTimezoneOffset(),_g=new Date(ir.getFullYear(),6,1).getTimezoneOffset(),d0=new Date(ir.getFullYear(),0,1).getTimezoneOffset(),L0=Math.min(d0,_g);return 0>jr?Ft()[No+32>>>2>>>0]=+(_g!=d0&&L0==Ro):0<jr!=(L0==Ro)&&(_g=Math.max(d0,_g),ir.setTime(ir.getTime()+6e4*((0<jr?L0:_g)-Ro))),Ft()[No+24>>>2>>>0]=ir.getDay(),jr=(I0(ir.getFullYear())?A0:Y0)[ir.getMonth()]+ir.getDate()-1|0,Ft()[No+28>>>2>>>0]=jr,Ft()[No>>>2>>>0]=ir.getSeconds(),Ft()[No+4>>>2>>>0]=ir.getMinutes(),Ft()[No+8>>>2>>>0]=ir.getHours(),Ft()[No+12>>>2>>>0]=ir.getDate(),Ft()[No+16>>>2>>>0]=ir.getMonth(),Ft()[No+20>>>2>>>0]=ir.getYear(),No=ir.getTime(),No=isNaN(No)?-1:No/1e3,J1((r0=No,1<=+Math.abs(r0)?0<r0?+Math.floor(r0/4294967296)>>>0:~~+Math.ceil((r0-+(~~r0>>>0))/4294967296)>>>0:0)),No>>>0},q:ey,r:ny,y:function(No,ir,jr,Ro){No>>>=0,ir>>>=0,jr>>>=0,Ro>>>=0;var _g=new Date().getFullYear(),d0=new Date(_g,0,1),L0=new Date(_g,6,1);_g=d0.getTimezoneOffset();var by=L0.getTimezoneOffset(),ky=Math.max(_g,by);Ct()[No>>>2>>>0]=60*ky,Ft()[ir>>>2>>>0]=+(_g!=by),No=Oy=>Oy.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],d0=No(d0),L0=No(L0),by<_g?(Yv(d0,jr,17),Yv(L0,Ro,17)):(Yv(d0,Ro,17),Yv(L0,jr,17))},c:()=>{J0("")},O:function(No,ir,jr){No>>>=0,ir>>>=0,jr>>>=0,ry.length=0;for(var Ro;Ro=Lt()[ir++>>>0];){var _g=Ro!=105;_g&=Ro!=112,jr+=_g&&jr%8?4:0,ry.push(Ro==112?Ct()[jr>>>2>>>0]:Ro==105?Ft()[jr>>>2>>>0]:Ht()[jr>>>3>>>0]),jr+=_g?8:4}return M0[No](...ry)},k:()=>{},i:()=>Date.now(),U:()=>{throw Vy+=1,"unwind"},A:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:()=>rr?(Cp$1(),ar(Lp$1)).cpus().length:navigator.hardwareConcurrency,x:function(No){No>>>=0;var ir=Lt().length;if(No<=ir||4294901760<No)return!1;for(var jr=1;4>=jr;jr*=2){var Ro=ir*(1+.2/jr);Ro=Math.min(Ro,No+100663296);var _g=Math;Ro=Math.max(No,Ro);e:{_g=(_g.min.call(_g,4294901760,Ro+(65536-Ro%65536)%65536)-E0.buffer.byteLength+65535)/65536;try{E0.grow(_g),K0();var d0=1;break e}catch{}d0=void 0}if(d0)return!0}return!1},M:Hy,N:uv,G:Py,g:dv,m:pv,v:Zy,l:bv,a:E0||Gt.wasmMemory,w:c1,d:function(No,ir,jr,Ro){return c1(No>>>0,ir>>>0,jr>>>0,Ro>>>0)}},jy=function(){function No(jr,Ro){return jy=jr.exports,jy=j1(),cy.ab.push(jy.ya),o0=jy.za,My.unshift(jy.V),n0=Ro,ay(),jy}var ir={a:Ov};if(Ey++,Gt.instantiateWasm)try{return Gt.instantiateWasm(ir,No)}catch(jr){t0(`Module.instantiateWasm callback failed with error: ${jr}`),qt(jr)}return y0(ir,function(jr){No(jr.instance,jr.module)}).catch(qt),{}}();Gt._OrtInit=(No,ir)=>(Gt._OrtInit=jy.W)(No,ir),Gt._OrtGetLastError=(No,ir)=>(Gt._OrtGetLastError=jy.X)(No,ir),Gt._OrtCreateSessionOptions=(No,ir,jr,Ro,_g,d0,L0,by,ky,Oy)=>(Gt._OrtCreateSessionOptions=jy.Y)(No,ir,jr,Ro,_g,d0,L0,by,ky,Oy),Gt._OrtAppendExecutionProvider=(No,ir)=>(Gt._OrtAppendExecutionProvider=jy.Z)(No,ir),Gt._OrtAddFreeDimensionOverride=(No,ir,jr)=>(Gt._OrtAddFreeDimensionOverride=jy._)(No,ir,jr),Gt._OrtAddSessionConfigEntry=(No,ir,jr)=>(Gt._OrtAddSessionConfigEntry=jy.$)(No,ir,jr),Gt._OrtReleaseSessionOptions=No=>(Gt._OrtReleaseSessionOptions=jy.aa)(No),Gt._OrtCreateSession=(No,ir,jr)=>(Gt._OrtCreateSession=jy.ba)(No,ir,jr),Gt._OrtReleaseSession=No=>(Gt._OrtReleaseSession=jy.ca)(No),Gt._OrtGetInputOutputCount=(No,ir,jr)=>(Gt._OrtGetInputOutputCount=jy.da)(No,ir,jr),Gt._OrtGetInputName=(No,ir)=>(Gt._OrtGetInputName=jy.ea)(No,ir),Gt._OrtGetOutputName=(No,ir)=>(Gt._OrtGetOutputName=jy.fa)(No,ir),Gt._OrtFree=No=>(Gt._OrtFree=jy.ga)(No),Gt._OrtCreateTensor=(No,ir,jr,Ro,_g,d0)=>(Gt._OrtCreateTensor=jy.ha)(No,ir,jr,Ro,_g,d0),Gt._OrtGetTensorData=(No,ir,jr,Ro,_g)=>(Gt._OrtGetTensorData=jy.ia)(No,ir,jr,Ro,_g),Gt._OrtReleaseTensor=No=>(Gt._OrtReleaseTensor=jy.ja)(No),Gt._OrtCreateRunOptions=(No,ir,jr,Ro)=>(Gt._OrtCreateRunOptions=jy.ka)(No,ir,jr,Ro),Gt._OrtAddRunConfigEntry=(No,ir,jr)=>(Gt._OrtAddRunConfigEntry=jy.la)(No,ir,jr),Gt._OrtReleaseRunOptions=No=>(Gt._OrtReleaseRunOptions=jy.ma)(No),Gt._OrtCreateBinding=No=>(Gt._OrtCreateBinding=jy.na)(No),Gt._OrtBindInput=(No,ir,jr)=>(Gt._OrtBindInput=jy.oa)(No,ir,jr),Gt._OrtBindOutput=(No,ir,jr,Ro)=>(Gt._OrtBindOutput=jy.pa)(No,ir,jr,Ro),Gt._OrtClearBoundOutputs=No=>(Gt._OrtClearBoundOutputs=jy.qa)(No),Gt._OrtReleaseBinding=No=>(Gt._OrtReleaseBinding=jy.ra)(No),Gt._OrtRunWithBinding=(No,ir,jr,Ro,_g)=>(Gt._OrtRunWithBinding=jy.sa)(No,ir,jr,Ro,_g),Gt._OrtRun=(No,ir,jr,Ro,_g,d0,L0,by)=>(Gt._OrtRun=jy.ta)(No,ir,jr,Ro,_g,d0,L0,by),Gt._OrtEndProfiling=No=>(Gt._OrtEndProfiling=jy.ua)(No);var Av=Gt._pthread_self=()=>(Av=Gt._pthread_self=jy.va)();Gt._malloc=No=>(Gt._malloc=jy.wa)(No),Gt._free=No=>(Gt._free=jy.xa)(No),Gt.__emscripten_tls_init=()=>(Gt.__emscripten_tls_init=jy.ya)();var zy=Gt.__emscripten_thread_init=(No,ir,jr,Ro,_g,d0)=>(zy=Gt.__emscripten_thread_init=jy.Aa)(No,ir,jr,Ro,_g,d0);Gt.__emscripten_thread_crashed=()=>(Gt.__emscripten_thread_crashed=jy.Ba)();var n1=(No,ir,jr,Ro,_g)=>(n1=jy.Ca)(No,ir,jr,Ro,_g),m1=No=>(m1=jy.Da)(No),i1=Gt.__emscripten_thread_exit=No=>(i1=Gt.__emscripten_thread_exit=jy.Ea)(No),S1=()=>(S1=jy.Fa)(),J1=No=>(J1=jy.Ga)(No),d_=(No,ir)=>(d_=jy.Ha)(No,ir),x1=No=>(x1=jy.Ia)(No),m_=No=>(m_=jy.Ja)(No),z1=()=>(z1=jy.Ka)();function j1(){var No=jy;No=Object.assign({},No);var ir=Ro=>()=>Ro()>>>0,jr=Ro=>_g=>Ro(_g)>>>0;return No.va=ir(No.va),No.wa=jr(No.wa),No.emscripten_main_runtime_thread_id=ir(No.emscripten_main_runtime_thread_id),No.Ja=jr(No.Ja),No.Ka=ir(No.Ka),No}Gt.wasmMemory=E0,Gt.stackSave=()=>z1(),Gt.stackRestore=No=>x1(No),Gt.stackAlloc=No=>m_(No),Gt.keepRuntimeAlive=()=>0<Vy,Gt.UTF8ToString=ev,Gt.stringToUTF8=Yv,Gt.lengthBytesUTF8=Rv,Gt.ExitStatus=G0,Gt.PThread=cy;var g_;_0=function No(){g_||q1(),g_||(_0=No)};function q1(){if(!(0<Ey))if(Hr)jt(Gt),Hr||C0(My),startWorker(Gt);else{if(Gt.preRun)for(typeof Gt.preRun=="function"&&(Gt.preRun=[Gt.preRun]);Gt.preRun.length;)$y.unshift(Gt.preRun.shift());C0($y),0<Ey||g_||(g_=!0,Gt.calledRun=!0,m0||(Hr||C0(My),jt(Gt),Hr||C0(Wy)))}}return q1(),Kt}})();typeof st=="object"&&typeof at=="object"?at.exports=pt:typeof define=="function"&&define.amd&&define([],()=>pt)}),Bp$1=me((st,at)=>{at.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(...e){var a=e.join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,a+`\n`);return}console.error(a)}function threadAlert(...e){var a=e.join(" ");postMessage({cmd:"alert",text:a,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,a)=>{var r=Module.wasmModule;Module.wasmModule=null;var t=new WebAssembly.Instance(r,e);return a(t)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let r=[];self.onmessage=t=>r.push(t),self.startWorker=t=>{Module=t,postMessage({cmd:"loaded"});for(let s of r)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const t of e.data.handlers)Module[t]=(...s)=>{postMessage({cmd:"callHandler",handler:t,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var a=URL.createObjectURL(e.data.urlOrBlob);importScripts(a),URL.revokeObjectURL(a)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(r){if(r!="unwind")throw r}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(r){throw Module.__emscripten_thread_crashed?.(),r}}self.onmessage=handleMessage;\n'}),Rp$1,sg,oa$1,ia$1,So$1,Np$1,ug,lg,fg,Mp$1,De$1,Ur=L(()=>{Rp$1=Pp$1(),sg=kp$1(),ia$1=!1,So$1=!1,Np$1=!1,ug=st=>{if(st===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+st+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+st+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},lg=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},fg=(st,at)=>st?at?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":at?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Mp$1=async st=>{if(ia$1)return Promise.resolve();if(So$1)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Np$1)throw new Error("previous call to 'initializeWebAssembly()' failed.");So$1=!0;let at=st.initTimeout,pt=st.numThreads,vt=st.simd,wt=ug(pt),$t=vt&&lg(),Tt=st.wasmPaths,Lt=typeof Tt=="string"?Tt:void 0,Ft=fg($t,wt),Ct=typeof Tt=="object"?Tt[Ft]:void 0,Ht=!1,Gt=[];if(at>0&&Gt.push(new Promise(jt=>{setTimeout(()=>{Ht=!0,jt()},at)})),Gt.push(new Promise((jt,qt)=>{let Kt=wt?sg:Rp$1,An={locateFile:(Sn,wn)=>wt&&Sn.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([Bp$1()],{type:"text/javascript"})):Sn.endsWith(".wasm")?Ct||(Lt??wn)+Ft:wn+Sn};if(wt)if(An.numThreads=pt,typeof Blob>"u")An.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let Sn=`var ortWasmThreaded=${Kt.toString()};`;An.mainScriptUrlOrBlob=new Blob([Sn],{type:"text/javascript"})}Kt(An).then(Sn=>{So$1=!1,ia$1=!0,oa$1=Sn,jt()},Sn=>{So$1=!1,Np$1=!0,qt(Sn)})})),await Promise.race(Gt),Ht)throw new Error(`WebAssembly backend initializing failed due to timeout: ${at}ms`)},De$1=()=>{if(ia$1&&oa$1)return oa$1;throw new Error("WebAssembly is not initialized yet.")}}),ve,bn,_e$1,Ao=L(()=>{Ur(),ve=(st,at)=>{let pt=De$1(),vt=pt.lengthBytesUTF8(st)+1,wt=pt._malloc(vt);return pt.stringToUTF8(st,wt,vt),at.push(wt),wt},bn=(st,at,pt,vt)=>{if(typeof st=="object"&&st!==null){if(pt.has(st))throw new Error("Circular reference in options");pt.add(st)}Object.entries(st).forEach(([wt,$t])=>{let Tt=at?at+wt:wt;if(typeof $t=="object")bn($t,Tt+".",pt,vt);else if(typeof $t=="string"||typeof $t=="number")vt(Tt,$t.toString());else if(typeof $t=="boolean")vt(Tt,$t?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof $t}`)})},_e$1=st=>{let at=De$1(),pt=at.stackSave();try{let vt=at.stackAlloc(8);at._OrtGetLastError(vt,vt+4);let wt=at.HEAP32[vt/4],$t=at.HEAPU32[vt/4+1],Tt=$t?at.UTF8ToString($t):"";throw new Error(`${st} ERROR_CODE: ${wt}, ERROR_MESSAGE: ${Tt}`)}finally{at.stackRestore(pt)}}}),Gp$1,Up$1=L(()=>{Ur(),Ao(),Gp$1=st=>{let at=De$1(),pt=0,vt=[],wt=st||{};try{if((st==null?void 0:st.logSeverityLevel)===void 0)wt.logSeverityLevel=2;else if(typeof st.logSeverityLevel!="number"||!Number.isInteger(st.logSeverityLevel)||st.logSeverityLevel<0||st.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${st.logSeverityLevel}`);if((st==null?void 0:st.logVerbosityLevel)===void 0)wt.logVerbosityLevel=0;else if(typeof st.logVerbosityLevel!="number"||!Number.isInteger(st.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${st.logVerbosityLevel}`);(st==null?void 0:st.terminate)===void 0&&(wt.terminate=!1);let $t=0;return(st==null?void 0:st.tag)!==void 0&&($t=ve(st.tag,vt)),pt=at._OrtCreateRunOptions(wt.logSeverityLevel,wt.logVerbosityLevel,!!wt.terminate,$t),pt===0&&_e$1("Can't create run options."),(st==null?void 0:st.extra)!==void 0&&bn(st.extra,"",new WeakSet,(Tt,Lt)=>{let Ft=ve(Tt,vt),Ct=ve(Lt,vt);at._OrtAddRunConfigEntry(pt,Ft,Ct)!==0&&_e$1(`Can't set a run config entry: ${Tt} - ${Lt}.`)}),[pt,vt]}catch($t){throw pt!==0&&at._OrtReleaseRunOptions(pt),vt.forEach(Tt=>at._free(Tt)),$t}}}),cg,pg,dg,hg,zp$1,Vp$1=L(()=>{Ur(),Ao(),cg=st=>{switch(st){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${st}`)}},pg=st=>{switch(st){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${st}`)}},dg=st=>{st.extra||(st.extra={}),st.extra.session||(st.extra.session={});let at=st.extra.session;at.use_ort_model_bytes_directly||(at.use_ort_model_bytes_directly="1"),st.executionProviders&&st.executionProviders.some(pt=>(typeof pt=="string"?pt:pt.name)==="webgpu")&&(st.enableMemPattern=!1)},hg=(st,at,pt)=>{for(let vt of at){let wt=typeof vt=="string"?vt:vt.name;switch(wt){case"webnn":if(wt="WEBNN",typeof vt!="string"){let Tt=vt;if(Tt!=null&&Tt.deviceType){let Lt=ve("deviceType",pt),Ft=ve(Tt.deviceType,pt);De$1()._OrtAddSessionConfigEntry(st,Lt,Ft)!==0&&_e$1(`Can't set a session config entry: 'deviceType' - ${Tt.deviceType}.`)}if(Tt!=null&&Tt.numThreads){let Lt=Tt.numThreads;(typeof Lt!="number"||!Number.isInteger(Lt)||Lt<0)&&(Lt=0);let Ft=ve("numThreads",pt),Ct=ve(Lt.toString(),pt);De$1()._OrtAddSessionConfigEntry(st,Ft,Ct)!==0&&_e$1(`Can't set a session config entry: 'numThreads' - ${Tt.numThreads}.`)}if(Tt!=null&&Tt.powerPreference){let Lt=ve("powerPreference",pt),Ft=ve(Tt.powerPreference,pt);De$1()._OrtAddSessionConfigEntry(st,Lt,Ft)!==0&&_e$1(`Can't set a session config entry: 'powerPreference' - ${Tt.powerPreference}.`)}}break;case"webgpu":if(wt="JS",typeof vt!="string"){let Tt=vt;if(Tt!=null&&Tt.preferredLayout){if(Tt.preferredLayout!=="NCHW"&&Tt.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${Tt.preferredLayout}`);let Lt=ve("preferredLayout",pt),Ft=ve(Tt.preferredLayout,pt);De$1()._OrtAddSessionConfigEntry(st,Lt,Ft)!==0&&_e$1(`Can't set a session config entry: 'preferredLayout' - ${Tt.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${wt}`)}let $t=ve(wt,pt);De$1()._OrtAppendExecutionProvider(st,$t)!==0&&_e$1(`Can't append execution provider: ${wt}.`)}},zp$1=st=>{let at=De$1(),pt=0,vt=[],wt=st||{};dg(wt);try{let $t=cg(wt.graphOptimizationLevel??"all"),Tt=pg(wt.executionMode??"sequential"),Lt=typeof wt.logId=="string"?ve(wt.logId,vt):0,Ft=wt.logSeverityLevel??2;if(!Number.isInteger(Ft)||Ft<0||Ft>4)throw new Error(`log serverity level is not valid: ${Ft}`);let Ct=wt.logVerbosityLevel??0;if(!Number.isInteger(Ct)||Ct<0||Ct>4)throw new Error(`log verbosity level is not valid: ${Ct}`);let Ht=typeof wt.optimizedModelFilePath=="string"?ve(wt.optimizedModelFilePath,vt):0;if(pt=at._OrtCreateSessionOptions($t,!!wt.enableCpuMemArena,!!wt.enableMemPattern,Tt,!!wt.enableProfiling,0,Lt,Ft,Ct,Ht),pt===0&&_e$1("Can't create session options."),wt.executionProviders&&hg(pt,wt.executionProviders,vt),wt.enableGraphCapture!==void 0){if(typeof wt.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${wt.enableGraphCapture}`);let Gt=ve("enableGraphCapture",vt),jt=ve(wt.enableGraphCapture.toString(),vt);at._OrtAddSessionConfigEntry(pt,Gt,jt)!==0&&_e$1(`Can't set a session config entry: 'enableGraphCapture' - ${wt.enableGraphCapture}.`)}if(wt.freeDimensionOverrides)for(let[Gt,jt]of Object.entries(wt.freeDimensionOverrides)){if(typeof Gt!="string")throw new Error(`free dimension override name must be a string: ${Gt}`);if(typeof jt!="number"||!Number.isInteger(jt)||jt<0)throw new Error(`free dimension override value must be a non-negative integer: ${jt}`);let qt=ve(Gt,vt);at._OrtAddFreeDimensionOverride(pt,qt,jt)!==0&&_e$1(`Can't set a free dimension override: ${Gt} - ${jt}.`)}return wt.extra!==void 0&&bn(wt.extra,"",new WeakSet,(Gt,jt)=>{let qt=ve(Gt,vt),Kt=ve(jt,vt);at._OrtAddSessionConfigEntry(pt,qt,Kt)!==0&&_e$1(`Can't set a session config entry: ${Gt} - ${jt}.`)}),[pt,vt]}catch($t){throw pt!==0&&at._OrtReleaseSessionOptions(pt),vt.forEach(Tt=>at._free(Tt)),$t}}}),aa$1,Wp$1,sa$1,Hp$1,qp$1,Po,jp$1,ua$1=L(()=>{aa$1=st=>{switch(st){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${st}`)}},Wp$1=st=>{switch(st){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${st}`)}},sa$1=st=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][st],Hp$1=st=>{switch(st){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${st}`)}},qp$1=st=>{switch(st){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${st}`)}},Po=st=>st==="float32"||st==="float16"||st==="int32"||st==="int64"||st==="uint32"||st==="uint8"||st==="bool",jp$1=st=>{switch(st){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${st}`)}}}),gn,la$1=L(()=>{gn=async st=>{if(typeof st=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(st))}catch(at){if(at.code==="ERR_FS_FILE_TOO_LARGE"){let pt=(void 0)(st),vt=[];for await(let wt of pt)vt.push(wt);return new Uint8Array(Buffer.concat(vt))}throw at}else{let at=await fetch(st);if(!at.ok)throw new Error(`failed to load external data file: ${st}`);let pt=at.headers.get("Content-Length"),vt=pt?parseInt(pt,10):0;if(vt<1073741824)return new Uint8Array(await at.arrayBuffer());{if(!at.body)throw new Error(`failed to load external data file: ${st}, no response body.`);let wt=at.body.getReader(),$t;try{$t=new ArrayBuffer(vt)}catch(Lt){if(Lt instanceof RangeError){let Ft=Math.ceil(vt/65536);$t=new WebAssembly.Memory({initial:Ft,maximum:Ft}).buffer}else throw Lt}let Tt=0;for(;;){let{done:Lt,value:Ft}=await wt.read();if(Lt)break;let Ct=Ft.byteLength;new Uint8Array($t,Tt,Ct).set(Ft),Tt+=Ct}return new Uint8Array($t,0,vt)}}else return st instanceof Blob?new Uint8Array(await st.arrayBuffer()):st instanceof Uint8Array?st:new Uint8Array(st)}}),mg,Xp$1,Kp$1,zr$1,bg,fa$1,Jp$1,Zp$1,Yp$1,Qp$1,ed$1,td$1,rd$1=L(()=>{Up$1(),Vp$1(),ua$1(),Ur(),Ao(),la$1(),mg=(st,at)=>{De$1()._OrtInit(st,at)!==0&&_e$1("Can't initialize onnxruntime.")},Xp$1=async st=>{mg(st.wasm.numThreads,qp$1(st.logLevel))},Kp$1=async(st,at)=>{},zr$1=new Map,bg=st=>{let at=De$1(),pt=at.stackSave();try{let vt=at.stackAlloc(8);return at._OrtGetInputOutputCount(st,vt,vt+4)!==0&&_e$1("Can't get session input/output count."),[at.HEAP32[vt/4],at.HEAP32[vt/4+1]]}finally{at.stackRestore(pt)}},fa$1=st=>{let at=De$1(),pt=at._malloc(st.byteLength);if(pt===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${st.byteLength}.`);return at.HEAPU8.set(st,pt),[pt,st.byteLength]},Jp$1=async(st,at)=>{var Ht;let pt,vt,wt=De$1();Array.isArray(st)?[pt,vt]=st:st.buffer===wt.HEAPU8.buffer?[pt,vt]=[st.byteOffset,st.byteLength]:[pt,vt]=fa$1(st);let $t=0,Tt=0,Lt=[],Ft=[],Ct=[];try{if([Tt,Lt]=zp$1(at),(at==null?void 0:at.externalData)&&wt.mountExternalData){let In=[];for(let tr of at.externalData){let rr=typeof tr=="string"?tr:tr.path;In.push(gn(typeof tr=="string"?tr:tr.data).then(Hr=>{wt.mountExternalData(rr,Hr)}))}await Promise.all(In)}$t=await wt._OrtCreateSession(pt,vt,Tt),$t===0&&_e$1("Can't create a session.");let[Gt,jt]=bg($t),qt=!!(at!=null&&at.enableGraphCapture),Kt=[],An=[],Sn=[];for(let In=0;In<Gt;In++){let tr=wt._OrtGetInputName($t,In);tr===0&&_e$1("Can't get an input name."),Ft.push(tr),Kt.push(wt.UTF8ToString(tr))}for(let In=0;In<jt;In++){let tr=wt._OrtGetOutputName($t,In);tr===0&&_e$1("Can't get an output name."),Ct.push(tr);let rr=wt.UTF8ToString(tr);An.push(rr)}return zr$1.set($t,[$t,Ft,Ct,null,qt,!1]),[$t,Kt,An]}catch(Gt){throw Ft.forEach(jt=>wt._OrtFree(jt)),Ct.forEach(jt=>wt._OrtFree(jt)),$t!==0&&wt._OrtReleaseSession($t),Gt}finally{wt._free(pt),Tt!==0&&wt._OrtReleaseSessionOptions(Tt),Lt.forEach(Gt=>wt._free(Gt)),(Ht=wt.unmountExternalData)==null||Ht.call(wt)}},Zp$1=st=>{var Ft;let at=De$1(),pt=zr$1.get(st);if(!pt)throw new Error(`cannot release session. invalid session id: ${st}`);let[vt,wt,$t,Tt,Lt]=pt;Tt&&(Lt&&at._OrtClearBoundOutputs(Tt.handle),at._OrtReleaseBinding(Tt.handle)),(Ft=at.jsepOnReleaseSession)==null||Ft.call(at,st),wt.forEach(Ct=>at._OrtFree(Ct)),$t.forEach(Ct=>at._OrtFree(Ct)),at._OrtReleaseSession(vt),zr$1.delete(st)},Yp$1=(st,at,pt,vt,wt,$t=!1)=>{if(!st){at.push(0);return}let Tt=De$1(),Lt=st[0],Ft=st[1],Ct=st[3],Ht,Gt;if(Lt==="string"&&Ct==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if($t&&Ct!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${wt} when enableGraphCapture is true.`);if(Ct==="gpu-buffer"){let Kt=st[2].gpuBuffer,An=sa$1(aa$1(Lt));Gt=Ft.reduce((wn,In)=>wn*In,1)*An;let Sn=Tt.jsepRegisterBuffer;if(!Sn)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');Ht=Sn(vt,wt,Kt,Gt)}else{let Kt=st[2];if(Array.isArray(Kt)){Gt=4*Kt.length,Ht=Tt._malloc(Gt),pt.push(Ht);let An=Ht/4;for(let Sn=0;Sn<Kt.length;Sn++){if(typeof Kt[Sn]!="string")throw new TypeError(`tensor data at index ${Sn} is not a string`);Tt.HEAPU32[An++]=ve(Kt[Sn],pt)}}else Gt=Kt.byteLength,Ht=Tt._malloc(Gt),pt.push(Ht),Tt.HEAPU8.set(new Uint8Array(Kt.buffer,Kt.byteOffset,Gt),Ht)}let jt=Tt.stackSave(),qt=Tt.stackAlloc(4*Ft.length);try{let Kt=qt/4;Ft.forEach(Sn=>Tt.HEAP32[Kt++]=Sn);let An=Tt._OrtCreateTensor(aa$1(Lt),Ht,Gt,qt,Ft.length,jp$1(Ct));An===0&&_e$1(`Can't create tensor for input/output. session=${vt}, index=${wt}.`),at.push(An)}finally{Tt.stackRestore(jt)}},Qp$1=async(st,at,pt,vt,wt,$t)=>{var Xo;let Tt=De$1(),Lt=zr$1.get(st);if(!Lt)throw new Error(`cannot run inference. invalid session id: ${st}`);let Ft=Lt[0],Ct=Lt[1],Ht=Lt[2],Gt=Lt[3],jt=Lt[4];Lt[5];let qt=at.length,Kt=vt.length,An=0,Sn=[],wn=[],In=[],tr=[],rr=Tt.stackSave(),Hr=Tt.stackAlloc(qt*4),qr=Tt.stackAlloc(qt*4),Zr=Tt.stackAlloc(Kt*4),Bo=Tt.stackAlloc(Kt*4);try{[An,Sn]=Gp$1($t);for(let t0=0;t0<qt;t0++)Yp$1(pt[t0],wn,tr,st,at[t0],jt);for(let t0=0;t0<Kt;t0++)Yp$1(wt[t0],In,tr,st,qt+vt[t0],jt);let Kr=Hr/4,ko=qr/4,f0=Zr/4,x0=Bo/4;for(let t0=0;t0<qt;t0++)Tt.HEAPU32[Kr++]=wn[t0],Tt.HEAPU32[ko++]=Ct[at[t0]];for(let t0=0;t0<Kt;t0++)Tt.HEAPU32[f0++]=In[t0],Tt.HEAPU32[x0++]=Ht[vt[t0]];(Xo=Tt.jsepOnRunStart)==null||Xo.call(Tt,Ft);let l0;l0=await Tt._OrtRun(Ft,qr,Hr,qt,Bo,Kt,Zr,An),l0!==0&&_e$1("failed to call OrtRun().");let T0=[];for(let t0=0;t0<Kt;t0++){let E0=Tt.HEAPU32[Zr/4+t0];if(E0===In[t0]){T0.push(wt[t0]);continue}let n0=Tt.stackSave(),m0=Tt.stackAlloc(4*4),h0=!1,a0,P0=0;try{Tt._OrtGetTensorData(E0,m0,m0+4,m0+8,m0+12)!==0&&_e$1(`Can't access output tensor data on index ${t0}.`);let V0=m0/4,B0=Tt.HEAPU32[V0++];P0=Tt.HEAPU32[V0++];let W0=Tt.HEAPU32[V0++],K0=Tt.HEAPU32[V0++],Ty=[];for(let Wy=0;Wy<K0;Wy++)Ty.push(Tt.HEAPU32[W0/4+Wy]);Tt._OrtFree(W0);let $y=Ty.reduce((Wy,Ey)=>Wy*Ey,1);a0=Wp$1(B0);let My=Gt==null?void 0:Gt.outputPreferredLocations[vt[t0]];if(a0==="string"){if(My==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Wy=[],Ey=P0/4;for(let _0=0;_0<$y;_0++){let ay=Tt.HEAPU32[Ey++],J0=_0===$y-1?void 0:Tt.HEAPU32[Ey]-ay;Wy.push(Tt.UTF8ToString(ay,J0))}T0.push([a0,Ty,Wy,"cpu"])}else if(My==="gpu-buffer"&&$y>0){let Wy=Tt.jsepGetBuffer;if(!Wy)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let Ey=Wy(P0),_0=sa$1(B0);if(_0===void 0||!Po(a0))throw new Error(`Unsupported data type: ${a0}`);h0=!0,T0.push([a0,Ty,{gpuBuffer:Ey,download:Tt.jsepCreateDownloader(Ey,$y*_0,a0),dispose:()=>{Tt._OrtReleaseTensor(E0)}},"gpu-buffer"])}else{let Wy=Hp$1(a0),Ey=new Wy($y);new Uint8Array(Ey.buffer,Ey.byteOffset,Ey.byteLength).set(Tt.HEAPU8.subarray(P0,P0+Ey.byteLength)),T0.push([a0,Ty,Ey,"cpu"])}}finally{Tt.stackRestore(n0),a0==="string"&&P0&&Tt._free(P0),h0||Tt._OrtReleaseTensor(E0)}}return Gt&&!jt&&(Tt._OrtClearBoundOutputs(Gt.handle),zr$1.set(st,[Ft,Ct,Ht,Gt,jt,!1])),T0}finally{Tt.stackRestore(rr),wn.forEach(Kr=>Tt._OrtReleaseTensor(Kr)),In.forEach(Kr=>Tt._OrtReleaseTensor(Kr)),tr.forEach(Kr=>Tt._free(Kr)),An!==0&&Tt._OrtReleaseRunOptions(An),Sn.forEach(Kr=>Tt._free(Kr))}},ed$1=st=>{let at=De$1(),pt=zr$1.get(st);if(!pt)throw new Error("invalid session id");let vt=pt[0],wt=at._OrtEndProfiling(vt);wt===0&&_e$1("Can't get an profile file name."),at._OrtFree(wt)},td$1=st=>{let at=[];for(let pt of st){let vt=pt[2];!Array.isArray(vt)&&"buffer"in vt&&at.push(vt.buffer)}return at}}),nd$1=me((st,at)=>{at.exports='/*!\n * ONNX Runtime Web v1.18.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var vt=Object.defineProperty;var qr=Object.getOwnPropertyDescriptor;var Vr=Object.getOwnPropertyNames;var Jr=Object.prototype.hasOwnProperty;var _t=(i,c)=>()=>(i&&(c=i(i=0)),c);var Ke=(i,c)=>()=>(c||i((c={exports:{}}).exports,c),c.exports),Et=(i,c)=>{for(var a in c)vt(i,a,{get:c[a],enumerable:!0})},Xr=(i,c,a,h)=>{if(c&&typeof c=="object"||typeof c=="function")for(let f of Vr(c))!Jr.call(i,f)&&f!==a&&vt(i,f,{get:()=>c[f],enumerable:!(h=qr(c,f))||h.enumerable});return i};var et=i=>Xr(vt({},"__esModule",{value:!0}),i);var St={};Et(St,{createReadStream:()=>lr,readFile:()=>Qr,readFileSync:()=>Zr});var Qr,Zr,lr,At=_t(()=>{Qr=void 0,Zr=void 0,lr=void 0});var Tt={};Et(Tt,{join:()=>Kr});var Kr,Mt=_t(()=>{Kr=void 0});var pr=Ke((dr,Ct)=>{"use strict";var cr=(()=>{var i=typeof document<"u"?document.currentScript?.src:void 0;return typeof __filename<"u"&&(i||=__filename),function(c={}){var a=c,h,f,w=new Promise((t,o)=>{h=t,f=o}),g=Object.assign({},a),s="./this.program",S=typeof window=="object",x=typeof importScripts=="function",H=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",A="",I,V,R;if(H){var B=(At(),et(St)),D=(Mt(),et(Tt));A=x?D.dirname(A)+"/":__dirname+"/",I=(t,o)=>(t=ce(t)?new URL(t):D.normalize(t),B.readFileSync(t,o?void 0:"utf8")),R=t=>(t=I(t,!0),t.buffer||(t=new Uint8Array(t)),t),V=(t,o,u,m=!0)=>{t=ce(t)?new URL(t):D.normalize(t),B.readFile(t,m?void 0:"utf8",(O,E)=>{O?u(O):o(m?E.buffer:E)})},!a.thisProgram&&1<process.argv.length&&(s=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2)}else(S||x)&&(x?A=self.location.href:typeof document<"u"&&document.currentScript&&(A=document.currentScript.src),i&&(A=i),A.startsWith("blob:")?A="":A=A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1),I=t=>{var o=new XMLHttpRequest;return o.open("GET",t,!1),o.send(null),o.responseText},x&&(R=t=>{var o=new XMLHttpRequest;return o.open("GET",t,!1),o.responseType="arraybuffer",o.send(null),new Uint8Array(o.response)}),V=(t,o,u)=>{var m=new XMLHttpRequest;m.open("GET",t,!0),m.responseType="arraybuffer",m.onload=()=>{m.status==200||m.status==0&&m.response?o(m.response):u()},m.onerror=u,m.send(null)});var T=console.log.bind(console),L=console.error.bind(console);Object.assign(a,g),g=null;var W,de=!1,pe,Z,_,J,Pe;function le(){var t=W.buffer;a.HEAP8=pe=new Int8Array(t),a.HEAP16=new Int16Array(t),a.HEAPU8=Z=new Uint8Array(t),a.HEAPU16=new Uint16Array(t),a.HEAP32=_=new Int32Array(t),a.HEAPU32=J=new Uint32Array(t),a.HEAPF32=new Float32Array(t),a.HEAPF64=Pe=new Float64Array(t)}var Ie=[],ne=[],X=[],we=0,me=null,F=null;function ie(t){throw t="Aborted("+t+")",L(t),de=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),f(t),t}var xe=t=>t.startsWith("data:application/octet-stream;base64,"),ce=t=>t.startsWith("file://"),be;if(be="ort-wasm.wasm",!xe(be)){var ae=be;be=a.locateFile?a.locateFile(ae,A):A+ae}function K(t){if(R)return R(t);throw"both async and sync fetching of the wasm failed"}function je(t){if(S||x){if(typeof fetch=="function"&&!ce(t))return fetch(t,{credentials:"same-origin"}).then(o=>{if(!o.ok)throw`failed to load wasm binary file at \'${t}\'`;return o.arrayBuffer()}).catch(()=>K(t));if(V)return new Promise((o,u)=>{V(t,m=>o(new Uint8Array(m)),u)})}return Promise.resolve().then(()=>K(t))}function Oe(t,o,u){return je(t).then(m=>WebAssembly.instantiate(m,o)).then(u,m=>{L(`failed to asynchronously prepare wasm: ${m}`),ie(m)})}function Ue(t,o){var u=be;return typeof WebAssembly.instantiateStreaming!="function"||xe(u)||ce(u)||H||typeof fetch!="function"?Oe(u,t,o):fetch(u,{credentials:"same-origin"}).then(m=>WebAssembly.instantiateStreaming(m,t).then(o,function(O){return L(`wasm streaming compile failed: ${O}`),L("falling back to ArrayBuffer instantiation"),Oe(u,t,o)}))}var ve,Ae={798088:(t,o,u,m)=>{if(typeof a>"u"||!a.ya)return 1;if(t=ue(t>>>0),t.startsWith("./")&&(t=t.substring(2)),t=a.ya.get(t),!t)return 2;if(o>>>=0,u>>>=0,o+u>t.byteLength)return 3;try{return Z.set(t.subarray(o,o+u),m>>>0>>>0),0}catch{return 4}}};class _e{constructor(o){this.wa=o-24}}var ge=0,Be=0,te=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,re=(t,o,u)=>{o>>>=0;var m=o+u;for(u=o;t[u]&&!(u>=m);)++u;if(16<u-o&&t.buffer&&te)return te.decode(t.subarray(o,u));for(m="";o<u;){var O=t[o++];if(O&128){var E=t[o++]&63;if((O&224)==192)m+=String.fromCharCode((O&31)<<6|E);else{var U=t[o++]&63;O=(O&240)==224?(O&15)<<12|E<<6|U:(O&7)<<18|E<<12|U<<6|t[o++]&63,65536>O?m+=String.fromCharCode(O):(O-=65536,m+=String.fromCharCode(55296|O>>10,56320|O&1023))}}else m+=String.fromCharCode(O)}return m},ue=(t,o)=>(t>>>=0)?re(Z,t,o):"",Ee=t=>{for(var o=0,u=0;u<t.length;++u){var m=t.charCodeAt(u);127>=m?o++:2047>=m?o+=2:55296<=m&&57343>=m?(o+=4,++u):o+=3}return o},Se=(t,o,u,m)=>{if(u>>>=0,!(0<m))return 0;var O=u;m=u+m-1;for(var E=0;E<t.length;++E){var U=t.charCodeAt(E);if(55296<=U&&57343>=U){var ee=t.charCodeAt(++E);U=65536+((U&1023)<<10)|ee&1023}if(127>=U){if(u>=m)break;o[u++>>>0]=U}else{if(2047>=U){if(u+1>=m)break;o[u++>>>0]=192|U>>6}else{if(65535>=U){if(u+2>=m)break;o[u++>>>0]=224|U>>12}else{if(u+3>=m)break;o[u++>>>0]=240|U>>18,o[u++>>>0]=128|U>>12&63}o[u++>>>0]=128|U>>6&63}o[u++>>>0]=128|U&63}}return o[u>>>0]=0,u-O},Le=t=>t%4===0&&(t%100!==0||t%400===0),ze=[0,31,60,91,121,152,182,213,244,274,305,335],rt=[0,31,59,90,120,151,181,212,243,273,304,334],Te=[],Ge={},ke=()=>{if(!We){var t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:s||"./this.program"},o;for(o in Ge)Ge[o]===void 0?delete t[o]:t[o]=Ge[o];var u=[];for(o in t)u.push(`${o}=${t[o]}`);We=u}return We},We,nt=[null,[],[]],De=[31,29,31,30,31,30,31,31,30,31,30,31],at=[31,28,31,30,31,30,31,31,30,31,30,31];function G(t){var o=Array(Ee(t)+1);return Se(t,o,0,o.length),o}function qe(t,o,u,m){function O(d,k,$){for(d=typeof d=="number"?d.toString():d||"";d.length<k;)d=$[0]+d;return d}function E(d,k){return O(d,k,"0")}function U(d,k){function $(Ze){return 0>Ze?-1:0<Ze?1:0}var Me;return(Me=$(d.getFullYear()-k.getFullYear()))===0&&(Me=$(d.getMonth()-k.getMonth()))===0&&(Me=$(d.getDate()-k.getDate())),Me}function ee(d){switch(d.getDay()){case 0:return new Date(d.getFullYear()-1,11,29);case 1:return d;case 2:return new Date(d.getFullYear(),0,3);case 3:return new Date(d.getFullYear(),0,2);case 4:return new Date(d.getFullYear(),0,1);case 5:return new Date(d.getFullYear()-1,11,31);case 6:return new Date(d.getFullYear()-1,11,30)}}function ye(d){var k=d.sa;for(d=new Date(new Date(d.ta+1900,0,1).getTime());0<k;){var $=d.getMonth(),Me=(Le(d.getFullYear())?De:at)[$];if(k>Me-d.getDate())k-=Me-d.getDate()+1,d.setDate(1),11>$?d.setMonth($+1):(d.setMonth(0),d.setFullYear(d.getFullYear()+1));else{d.setDate(d.getDate()+k);break}}return $=new Date(d.getFullYear()+1,0,4),k=ee(new Date(d.getFullYear(),0,4)),$=ee($),0>=U(k,d)?0>=U($,d)?d.getFullYear()+1:d.getFullYear():d.getFullYear()-1}t>>>=0,o>>>=0,u>>>=0,m>>>=0;var oe=J[m+40>>>2>>>0];m={Ba:_[m>>>2>>>0],Aa:_[m+4>>>2>>>0],ua:_[m+8>>>2>>>0],xa:_[m+12>>>2>>>0],va:_[m+16>>>2>>>0],ta:_[m+20>>>2>>>0],na:_[m+24>>>2>>>0],sa:_[m+28>>>2>>>0],Da:_[m+32>>>2>>>0],za:_[m+36>>>2>>>0],Ca:oe?ue(oe):""},u=ue(u),oe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var se in oe)u=u.replace(new RegExp(se,"g"),oe[se]);var Qe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Re="January February March April May June July August September October November December".split(" ");oe={"%a":d=>Qe[d.na].substring(0,3),"%A":d=>Qe[d.na],"%b":d=>Re[d.va].substring(0,3),"%B":d=>Re[d.va],"%C":d=>E((d.ta+1900)/100|0,2),"%d":d=>E(d.xa,2),"%e":d=>O(d.xa,2," "),"%g":d=>ye(d).toString().substring(2),"%G":ye,"%H":d=>E(d.ua,2),"%I":d=>(d=d.ua,d==0?d=12:12<d&&(d-=12),E(d,2)),"%j":d=>{for(var k=0,$=0;$<=d.va-1;k+=(Le(d.ta+1900)?De:at)[$++]);return E(d.xa+k,3)},"%m":d=>E(d.va+1,2),"%M":d=>E(d.Aa,2),"%n":()=>`\n`,"%p":d=>0<=d.ua&&12>d.ua?"AM":"PM","%S":d=>E(d.Ba,2),"%t":()=>"	","%u":d=>d.na||7,"%U":d=>E(Math.floor((d.sa+7-d.na)/7),2),"%V":d=>{var k=Math.floor((d.sa+7-(d.na+6)%7)/7);if(2>=(d.na+371-d.sa-2)%7&&k++,k)k==53&&($=(d.na+371-d.sa)%7,$==4||$==3&&Le(d.ta)||(k=1));else{k=52;var $=(d.na+7-d.sa-1)%7;($==4||$==5&&Le(d.ta%400-1))&&k++}return E(k,2)},"%w":d=>d.na,"%W":d=>E(Math.floor((d.sa+7-(d.na+6)%7)/7),2),"%y":d=>(d.ta+1900).toString().substring(2),"%Y":d=>d.ta+1900,"%z":d=>{d=d.za;var k=0<=d;return d=Math.abs(d)/60,(k?"+":"-")+("0000"+(d/60*100+d%60)).slice(-4)},"%Z":d=>d.Ca,"%%":()=>"%"},u=u.replace(/%%/g,"\\0\\0");for(se in oe)u.includes(se)&&(u=u.replace(new RegExp(se,"g"),oe[se](m)));return u=u.replace(/\\0\\0/g,"%"),se=G(u),se.length>o?0:(pe.set(se,t>>>0),se.length-1)}var Ve={a:function(t,o,u){t>>>=0;var m=new _e(t);throw J[m.wa+16>>>2>>>0]=0,J[m.wa+4>>>2>>>0]=o>>>0,J[m.wa+8>>>2>>>0]=u>>>0,ge=t,Be++,ge},e:function(){return 0},H:function(){},x:function(){},z:function(){},J:function(){return 0},F:function(){},A:function(){},E:function(){},g:function(){},y:function(){},v:function(){},G:function(){},w:function(){},k:()=>1,I:function(t,o,u){return o>>>=0,Z.copyWithin(t>>>0>>>0,o>>>0,o+(u>>>0)>>>0)},n:function(t,o,u){t=o+2097152>>>0<4194305-!!t?(t>>>0)+4294967296*o:NaN,u>>>=0,t=new Date(1e3*t),_[u>>>2>>>0]=t.getUTCSeconds(),_[u+4>>>2>>>0]=t.getUTCMinutes(),_[u+8>>>2>>>0]=t.getUTCHours(),_[u+12>>>2>>>0]=t.getUTCDate(),_[u+16>>>2>>>0]=t.getUTCMonth(),_[u+20>>>2>>>0]=t.getUTCFullYear()-1900,_[u+24>>>2>>>0]=t.getUTCDay(),_[u+28>>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(t,o,u){t=o+2097152>>>0<4194305-!!t?(t>>>0)+4294967296*o:NaN,u>>>=0,t=new Date(1e3*t),_[u>>>2>>>0]=t.getSeconds(),_[u+4>>>2>>>0]=t.getMinutes(),_[u+8>>>2>>>0]=t.getHours(),_[u+12>>>2>>>0]=t.getDate(),_[u+16>>>2>>>0]=t.getMonth(),_[u+20>>>2>>>0]=t.getFullYear()-1900,_[u+24>>>2>>>0]=t.getDay(),_[u+28>>>2>>>0]=(Le(t.getFullYear())?ze:rt)[t.getMonth()]+t.getDate()-1|0,_[u+36>>>2>>>0]=-(60*t.getTimezoneOffset()),o=new Date(t.getFullYear(),6,1).getTimezoneOffset();var m=new Date(t.getFullYear(),0,1).getTimezoneOffset();_[u+32>>>2>>>0]=(o!=m&&t.getTimezoneOffset()==Math.min(m,o))|0},p:function(t){t>>>=0;var o=new Date(_[t+20>>>2>>>0]+1900,_[t+16>>>2>>>0],_[t+12>>>2>>>0],_[t+8>>>2>>>0],_[t+4>>>2>>>0],_[t>>>2>>>0],0),u=_[t+32>>>2>>>0],m=o.getTimezoneOffset(),O=new Date(o.getFullYear(),6,1).getTimezoneOffset(),E=new Date(o.getFullYear(),0,1).getTimezoneOffset(),U=Math.min(E,O);return 0>u?_[t+32>>>2>>>0]=+(O!=E&&U==m):0<u!=(U==m)&&(O=Math.max(E,O),o.setTime(o.getTime()+6e4*((0<u?U:O)-m))),_[t+24>>>2>>>0]=o.getDay(),_[t+28>>>2>>>0]=(Le(o.getFullYear())?ze:rt)[o.getMonth()]+o.getDate()-1|0,_[t>>>2>>>0]=o.getSeconds(),_[t+4>>>2>>>0]=o.getMinutes(),_[t+8>>>2>>>0]=o.getHours(),_[t+12>>>2>>>0]=o.getDate(),_[t+16>>>2>>>0]=o.getMonth(),_[t+20>>>2>>>0]=o.getYear(),t=o.getTime(),t=isNaN(t)?-1:t/1e3,Je((ve=t,1<=+Math.abs(ve)?0<ve?+Math.floor(ve/4294967296)>>>0:~~+Math.ceil((ve-+(~~ve>>>0))/4294967296)>>>0:0)),t>>>0},l:function(){return-52},m:function(){},t:function(t,o,u,m){u>>>=0,m>>>=0;var O=new Date().getFullYear(),E=new Date(O,0,1),U=new Date(O,6,1);O=E.getTimezoneOffset();var ee=U.getTimezoneOffset();J[t>>>0>>>2>>>0]=60*Math.max(O,ee),_[o>>>0>>>2>>>0]=+(O!=ee),t=ye=>ye.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],E=t(E),U=t(U),ee<O?(Se(E,Z,u,17),Se(U,Z,m,17)):(Se(E,Z,m,17),Se(U,Z,u,17))},d:()=>{ie("")},B:function(t,o,u){t>>>=0,o>>>=0,u>>>=0,Te.length=0;for(var m;m=Z[o++>>>0];){var O=m!=105;O&=m!=112,u+=O&&u%8?4:0,Te.push(m==112?J[u>>>2>>>0]:m==105?_[u>>>2>>>0]:Pe[u>>>3>>>0]),u+=O?8:4}return Ae[t](...Te)},h:()=>Date.now(),u:function(){return 4294901760},b:()=>performance.now(),s:function(t){t>>>=0;var o=Z.length;if(4294901760<t)return!1;for(var u=1;4>=u;u*=2){var m=o*(1+.2/u);m=Math.min(m,t+100663296);var O=Math;m=Math.max(t,m);e:{O=(O.min.call(O,4294901760,m+(65536-m%65536)%65536)-W.buffer.byteLength+65535)/65536;try{W.grow(O),le();var E=1;break e}catch{}E=void 0}if(E)return!0}return!1},C:function(t,o){t>>>=0,o>>>=0;var u=0;return ke().forEach((m,O)=>{var E=o+u;for(O=J[t+4*O>>>2>>>0]=E,E=0;E<m.length;++E)pe[O++>>>0]=m.charCodeAt(E);pe[O>>>0]=0,u+=m.length+1}),0},D:function(t,o){t>>>=0,o>>>=0;var u=ke();J[t>>>2>>>0]=u.length;var m=0;return u.forEach(O=>m+=O.length+1),J[o>>>2>>>0]=m,0},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(t,o,u,m){o>>>=0,u>>>=0,m>>>=0;for(var O=0,E=0;E<u;E++){var U=J[o>>>2>>>0],ee=J[o+4>>>2>>>0];o+=8;for(var ye=0;ye<ee;ye++){var oe=Z[U+ye>>>0],se=nt[t];oe===0||oe===10?((t===1?T:L)(re(se,0)),se.length=0):se.push(oe)}O+=ee}return J[m>>>2>>>0]=O,0},r:qe,c:function(t,o,u,m){return qe(t>>>0,o>>>0,u>>>0,m>>>0)}},P=function(){function t(u){return P=u.exports,P=st(),W=P.K,le(),ne.unshift(P.L),we--,we==0&&(me!==null&&(clearInterval(me),me=null),F&&(u=F,F=null,u())),P}var o={a:Ve};if(we++,a.instantiateWasm)try{return a.instantiateWasm(o,t)}catch(u){L(`Module.instantiateWasm callback failed with error: ${u}`),f(u)}return Ue(o,function(u){t(u.instance)}).catch(f),{}}();a._OrtInit=(t,o)=>(a._OrtInit=P.M)(t,o),a._OrtGetLastError=(t,o)=>(a._OrtGetLastError=P.N)(t,o),a._OrtCreateSessionOptions=(t,o,u,m,O,E,U,ee,ye,oe)=>(a._OrtCreateSessionOptions=P.O)(t,o,u,m,O,E,U,ee,ye,oe),a._OrtAppendExecutionProvider=(t,o)=>(a._OrtAppendExecutionProvider=P.P)(t,o),a._OrtAddFreeDimensionOverride=(t,o,u)=>(a._OrtAddFreeDimensionOverride=P.Q)(t,o,u),a._OrtAddSessionConfigEntry=(t,o,u)=>(a._OrtAddSessionConfigEntry=P.R)(t,o,u),a._OrtReleaseSessionOptions=t=>(a._OrtReleaseSessionOptions=P.S)(t),a._OrtCreateSession=(t,o,u)=>(a._OrtCreateSession=P.T)(t,o,u),a._OrtReleaseSession=t=>(a._OrtReleaseSession=P.U)(t),a._OrtGetInputOutputCount=(t,o,u)=>(a._OrtGetInputOutputCount=P.V)(t,o,u),a._OrtGetInputName=(t,o)=>(a._OrtGetInputName=P.W)(t,o),a._OrtGetOutputName=(t,o)=>(a._OrtGetOutputName=P.X)(t,o),a._OrtFree=t=>(a._OrtFree=P.Y)(t),a._OrtCreateTensor=(t,o,u,m,O,E)=>(a._OrtCreateTensor=P.Z)(t,o,u,m,O,E),a._OrtGetTensorData=(t,o,u,m,O)=>(a._OrtGetTensorData=P._)(t,o,u,m,O),a._OrtReleaseTensor=t=>(a._OrtReleaseTensor=P.$)(t),a._OrtCreateRunOptions=(t,o,u,m)=>(a._OrtCreateRunOptions=P.aa)(t,o,u,m),a._OrtAddRunConfigEntry=(t,o,u)=>(a._OrtAddRunConfigEntry=P.ba)(t,o,u),a._OrtReleaseRunOptions=t=>(a._OrtReleaseRunOptions=P.ca)(t),a._OrtCreateBinding=t=>(a._OrtCreateBinding=P.da)(t),a._OrtBindInput=(t,o,u)=>(a._OrtBindInput=P.ea)(t,o,u),a._OrtBindOutput=(t,o,u,m)=>(a._OrtBindOutput=P.fa)(t,o,u,m),a._OrtClearBoundOutputs=t=>(a._OrtClearBoundOutputs=P.ga)(t),a._OrtReleaseBinding=t=>(a._OrtReleaseBinding=P.ha)(t),a._OrtRunWithBinding=(t,o,u,m,O)=>(a._OrtRunWithBinding=P.ia)(t,o,u,m,O),a._OrtRun=(t,o,u,m,O,E,U,ee)=>(a._OrtRun=P.ja)(t,o,u,m,O,E,U,ee),a._OrtEndProfiling=t=>(a._OrtEndProfiling=P.ka)(t),a._malloc=t=>(a._malloc=P.la)(t),a._free=t=>(a._free=P.ma)(t);var Je=t=>(Je=P.oa)(t),ot=t=>(ot=P.pa)(t),M=t=>(M=P.qa)(t),Ne=()=>(Ne=P.ra)();function st(){var t=P;t=Object.assign({},t);var o=u=>m=>u(m)>>>0;return t.la=o(t.la),t.qa=o(t.qa),t.ra=(u=>()=>u()>>>0)(t.ra),t}a.stackSave=()=>Ne(),a.stackRestore=t=>ot(t),a.stackAlloc=t=>M(t),a.UTF8ToString=ue,a.stringToUTF8=(t,o,u)=>Se(t,Z,o,u),a.lengthBytesUTF8=Ee;var Fe;F=function t(){Fe||Xe(),Fe||(F=t)};function Xe(){if(!(0<we)){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;){var t=a.preRun.shift();Ie.unshift(t)}for(;0<Ie.length;)Ie.shift()(a);if(!(0<we||Fe||(Fe=!0,a.calledRun=!0,de))){for(;0<ne.length;)ne.shift()(a);for(h(a);0<X.length;)X.shift()(a)}}}return Xe(),w}})();typeof dr=="object"&&typeof Ct=="object"?Ct.exports=cr:typeof define=="function"&&define.amd&&define([],()=>cr)});var mr=Ke(()=>{});var gr=Ke(()=>{});var hr={};Et(hr,{cpus:()=>en});var en,br=_t(()=>{en=void 0});var Or=Ke((wr,Dt)=>{"use strict";var yr=(()=>{var i=typeof document<"u"?document.currentScript?.src:void 0;return typeof __filename<"u"&&(i||=__filename),function(c={}){function a(){return X.buffer!=ie.buffer&&K(),ie}function h(){return X.buffer!=ie.buffer&&K(),xe}function f(){return X.buffer!=ie.buffer&&K(),ce}function w(){return X.buffer!=ie.buffer&&K(),be}function g(){return X.buffer!=ie.buffer&&K(),ae}var s=c,S,x,H=new Promise((e,r)=>{S=e,x=r}),A=Object.assign({},s),I="./this.program",V=(e,r)=>{throw r},R=typeof window=="object",B=typeof importScripts=="function",D=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",T=s.ENVIRONMENT_IS_PTHREAD||!1,L="";function W(e){return s.locateFile?s.locateFile(e,L):L+e}var de,pe,Z;if(D){var _=(At(),et(St)),J=(Mt(),et(Tt));L=B?J.dirname(L)+"/":__dirname+"/",de=(e,r)=>(e=ue(e)?new URL(e):J.normalize(e),_.readFileSync(e,r?void 0:"utf8")),Z=e=>(e=de(e,!0),e.buffer||(e=new Uint8Array(e)),e),pe=(e,r,n,l=!0)=>{e=ue(e)?new URL(e):J.normalize(e),_.readFile(e,l?void 0:"utf8",(y,b)=>{y?n(y):r(l?b.buffer:b)})},!s.thisProgram&&1<process.argv.length&&(I=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),V=(e,r)=>{throw process.exitCode=e,r},global.Worker=mr().Worker}else(R||B)&&(B?L=self.location.href:typeof document<"u"&&document.currentScript&&(L=document.currentScript.src),typeof i<"u"&&i&&(L=i),L.startsWith("blob:")?L="":L=L.substr(0,L.replace(/[?#].*/,"").lastIndexOf("/")+1),D||(de=e=>{var r=new XMLHttpRequest;return r.open("GET",e,!1),r.send(null),r.responseText},B&&(Z=e=>{var r=new XMLHttpRequest;return r.open("GET",e,!1),r.responseType="arraybuffer",r.send(null),new Uint8Array(r.response)}),pe=(e,r,n)=>{var l=new XMLHttpRequest;l.open("GET",e,!0),l.responseType="arraybuffer",l.onload=()=>{l.status==200||l.status==0&&l.response?r(l.response):n()},l.onerror=n,l.send(null)}));D&&typeof performance>"u"&&(global.performance=gr().performance);var Pe=console.log.bind(console),le=console.error.bind(console);D&&(Pe=(...e)=>_.writeSync(1,e.join(" ")+`\n`),le=(...e)=>_.writeSync(2,e.join(" ")+`\n`));var Ie=Pe,ne=le;Object.assign(s,A),A=null;var X,we,me=!1,F,ie,xe,ce,be,ae;function K(){var e=X.buffer;s.HEAP8=ie=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAPU8=xe=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAP32=ce=new Int32Array(e),s.HEAPU32=be=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=ae=new Float64Array(e)}var je=16777216;if(T)X=s.wasmMemory;else if(s.wasmMemory)X=s.wasmMemory;else if(X=new WebAssembly.Memory({initial:je/65536,maximum:65536,shared:!0}),!(X.buffer instanceof SharedArrayBuffer))throw ne("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),D&&ne("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");K(),je=X.buffer.byteLength;var Oe=[],Ue=[],ve=[],Ae=0,_e=null,ge=null;function Be(){if(Ae--,Ae==0&&(_e!==null&&(clearInterval(_e),_e=null),ge)){var e=ge;ge=null,e()}}function te(e){throw e="Aborted("+e+")",ne(e),me=!0,F=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),x(e),e}var re=e=>e.startsWith("data:application/octet-stream;base64,"),ue=e=>e.startsWith("file://"),Ee;Ee="ort-wasm-threaded.wasm",re(Ee)||(Ee=W(Ee));function Se(e){if(Z)return Z(e);throw"both async and sync fetching of the wasm failed"}function Le(e){if(R||B){if(typeof fetch=="function"&&!ue(e))return fetch(e,{credentials:"same-origin"}).then(r=>{if(!r.ok)throw`failed to load wasm binary file at \'${e}\'`;return r.arrayBuffer()}).catch(()=>Se(e));if(pe)return new Promise((r,n)=>{pe(e,l=>r(new Uint8Array(l)),n)})}return Promise.resolve().then(()=>Se(e))}function ze(e,r,n){return Le(e).then(l=>WebAssembly.instantiate(l,r)).then(n,l=>{ne(`failed to asynchronously prepare wasm: ${l}`),te(l)})}function rt(e,r){var n=Ee;return typeof WebAssembly.instantiateStreaming!="function"||re(n)||ue(n)||D||typeof fetch!="function"?ze(n,e,r):fetch(n,{credentials:"same-origin"}).then(l=>WebAssembly.instantiateStreaming(l,e).then(r,function(y){return ne(`wasm streaming compile failed: ${y}`),ne("falling back to ArrayBuffer instantiation"),ze(n,e,r)}))}var Te,Ge={799444:(e,r,n,l)=>{if(typeof s>"u"||!s.bb)return 1;if(e=ee(e>>>0),e.startsWith("./")&&(e=e.substring(2)),e=s.bb.get(e),!e)return 2;if(r>>>=0,n>>>=0,l>>>=0,r+n>e.byteLength)return 3;try{return h().set(e.subarray(r,r+n),l>>>0),0}catch{return 4}}};function ke(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var We=e=>{e.terminate(),e.onmessage=()=>{}},nt=e=>{M.Oa.length==0&&(Je(),M.Xa(M.Oa[0]));var r=M.Oa.pop();if(!r)return 6;M.Pa.push(r),M.La[e.Na]=r,r.Na=e.Na;var n={cmd:"run",start_routine:e.gb,arg:e.cb,pthread_ptr:e.Na};return D&&r.unref(),r.postMessage(n,e.mb),0},De=0,at=e=>{var r=Ot();return e=e(),ft(r),e},G=(e,r,...n)=>at(()=>{for(var l=n.length,y=wt(8*l),b=y>>>3,v=0;v<n.length;v++){var z=n[v];g()[b+v>>>0]=z}return rr(e,0,l,y,r)});function qe(e){if(T)return G(0,1,e);F=e,0<De||(M.hb(),s.onExit?.(e),me=!0),V(e,new ke(e))}var Ve=e=>{if(F=e,T)throw st(e),"unwind";qe(e)};function P(){for(var e=s.numThreads;e--;)Je();Oe.unshift(()=>{Ae++,ot(()=>Be())})}function Je(){var e=W("ort-wasm-threaded.worker.js");e=new Worker(e),M.Oa.push(e)}function ot(e){T?e():Promise.all(M.Oa.map(M.Xa)).then(e)}var M={Oa:[],Pa:[],ab:[],La:{},Va(){T?(M.receiveObjectTransfer=M.fb,M.threadInitTLS=M.$a,M.setExitStatus=M.Za):P()},Za:e=>F=e,pb:["$terminateWorker"],hb:()=>{for(var e of M.Pa)We(e);for(e of M.Oa)We(e);M.Oa=[],M.Pa=[],M.La=[]},Ya:e=>{var r=e.Na;delete M.La[r],M.Oa.push(e),M.Pa.splice(M.Pa.indexOf(e),1),e.Na=0,bt(r)},fb(){},$a(){M.ab.forEach(e=>e())},Xa:e=>new Promise(r=>{e.onmessage=b=>{b=b.data;var v=b.cmd;if(b.targetThread&&b.targetThread!=ut()){var z=M.La[b.targetThread];z?z.postMessage(b,b.transferList):ne(`Internal error! Worker sent a message "${v}" to target pthread ${b.targetThread}, but that thread no longer exists!`)}else v==="checkMailbox"?it():v==="spawnThread"?nt(b):v==="cleanupThread"?M.Ya(M.La[b.thread]):v==="killThread"?(b=b.thread,v=M.La[b],delete M.La[b],We(v),bt(b),M.Pa.splice(M.Pa.indexOf(v),1),v.Na=0):v==="cancelThread"?M.La[b.thread].postMessage({cmd:"cancel"}):v==="loaded"?(e.loaded=!0,D&&!e.Na&&e.unref(),r(e)):v==="alert"?alert(`Thread ${b.threadId}: ${b.text}`):b.target==="setimmediate"?e.postMessage(b):v==="callHandler"?s[b.handler](...b.args):v&&ne(`worker sent an unknown command ${v}`)},e.onerror=b=>{throw ne(`worker sent an error! ${b.filename}:${b.lineno}: ${b.message}`),b},D&&(e.on("message",b=>e.onmessage({data:b})),e.on("error",b=>e.onerror(b)));var n=[],l=["onExit"],y;for(y of l)s.hasOwnProperty(y)&&n.push(y);e.postMessage({cmd:"load",handlers:n,urlOrBlob:s.mainScriptUrlOrBlob||i,wasmMemory:X,wasmModule:we})})};s.PThread=M;var Ne=e=>{for(;0<e.length;)e.shift()(s)};s.establishStackSpace=()=>{var e=ut(),r=w()[e+52>>>2>>>0];e=w()[e+56>>>2>>>0],or(r,r-e),ft(r)};function st(e){if(T)return G(1,0,e);Ve(e)}var Fe=[],Xe;s.invokeEntryPoint=(e,r)=>{De=0;var n=Fe[e];n||(e>=Fe.length&&(Fe.length=e+1),Fe[e]=n=Xe.get(e)),e=n(r),0<De?M.Za(e):yt(e)};class t{constructor(r){this.Ua=r-24}Va(r,n){w()[this.Ua+16>>>2>>>0]=0,w()[this.Ua+4>>>2>>>0]=r,w()[this.Ua+8>>>2>>>0]=n}}var o=0,u=0;function m(e,r,n,l){return T?G(2,1,e,r,n,l):O(e,r,n,l)}function O(e,r,n,l){if(e>>>=0,r>>>=0,n>>>=0,l>>>=0,typeof SharedArrayBuffer>"u")return ne("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var y=[];return T&&y.length===0?m(e,r,n,l):(e={gb:n,Na:e,cb:l,mb:y},T?(e.ob="spawnThread",postMessage(e,y),0):nt(e))}var E=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,U=(e,r,n)=>{r>>>=0;var l=r+n;for(n=r;e[n]&&!(n>=l);)++n;if(16<n-r&&e.buffer&&E)return E.decode(e.buffer instanceof SharedArrayBuffer?e.slice(r,n):e.subarray(r,n));for(l="";r<n;){var y=e[r++];if(y&128){var b=e[r++]&63;if((y&224)==192)l+=String.fromCharCode((y&31)<<6|b);else{var v=e[r++]&63;y=(y&240)==224?(y&15)<<12|b<<6|v:(y&7)<<18|b<<12|v<<6|e[r++]&63,65536>y?l+=String.fromCharCode(y):(y-=65536,l+=String.fromCharCode(55296|y>>10,56320|y&1023))}}else l+=String.fromCharCode(y)}return l},ee=(e,r)=>(e>>>=0)?U(h(),e,r):"";function ye(e,r,n){return T?G(3,1,e,r,n):0}function oe(e,r){if(T)return G(4,1,e,r)}var se=e=>{for(var r=0,n=0;n<e.length;++n){var l=e.charCodeAt(n);127>=l?r++:2047>=l?r+=2:55296<=l&&57343>=l?(r+=4,++n):r+=3}return r},Qe=(e,r,n,l)=>{if(n>>>=0,!(0<l))return 0;var y=n;l=n+l-1;for(var b=0;b<e.length;++b){var v=e.charCodeAt(b);if(55296<=v&&57343>=v){var z=e.charCodeAt(++b);v=65536+((v&1023)<<10)|z&1023}if(127>=v){if(n>=l)break;r[n++>>>0]=v}else{if(2047>=v){if(n+1>=l)break;r[n++>>>0]=192|v>>6}else{if(65535>=v){if(n+2>=l)break;r[n++>>>0]=224|v>>12}else{if(n+3>=l)break;r[n++>>>0]=240|v>>18,r[n++>>>0]=128|v>>12&63}r[n++>>>0]=128|v>>6&63}r[n++>>>0]=128|v&63}}return r[n>>>0]=0,n-y},Re=(e,r,n)=>Qe(e,h(),r,n);function d(e,r){if(T)return G(5,1,e,r)}function k(e,r,n){if(T)return G(6,1,e,r,n)}function $(e,r,n){return T?G(7,1,e,r,n):0}function Me(e,r){if(T)return G(8,1,e,r)}function Ze(e,r,n){if(T)return G(9,1,e,r,n)}function Rt(e,r,n,l){if(T)return G(10,1,e,r,n,l)}function It(e,r,n,l){if(T)return G(11,1,e,r,n,l)}function Bt(e,r,n,l){if(T)return G(12,1,e,r,n,l)}function kt(e){if(T)return G(13,1,e)}function Wt(e,r){if(T)return G(14,1,e,r)}function Nt(e,r,n){if(T)return G(15,1,e,r,n)}function dt(e){e>>>=0,typeof Atomics.nb=="function"&&(Atomics.nb(f(),e>>>2,e).value.then(it),e+=128,Atomics.store(f(),e>>>2,1))}s.__emscripten_thread_mailbox_await=dt;var it=()=>{var e=ut();if(e&&(dt(e),e=nr,!me))try{if(e(),!(0<De))try{T?yt(F):Ve(F)}catch(r){r instanceof ke||r=="unwind"||V(1,r)}}catch(r){r instanceof ke||r=="unwind"||V(1,r)}};s.checkMailbox=it;var pt=[],$e=e=>e%4===0&&(e%100!==0||e%400===0),Ht=[0,31,60,91,121,152,182,213,244,274,305,335],Gt=[0,31,59,90,120,151,181,212,243,273,304,334];function $t(e,r,n,l,y,b,v,z){return T?G(16,1,e,r,n,l,y,b,v,z):-52}function Yt(e,r,n,l,y,b,v){if(T)return G(17,1,e,r,n,l,y,b,v)}var mt=[],gt={},jt=()=>{if(!ht){var e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:I||"./this.program"},r;for(r in gt)gt[r]===void 0?delete e[r]:e[r]=gt[r];var n=[];for(r in e)n.push(`${r}=${e[r]}`);ht=n}return ht},ht;function zt(e,r){if(T)return G(18,1,e,r);e>>>=0,r>>>=0;var n=0;return jt().forEach((l,y)=>{var b=r+n;for(y=w()[e+4*y>>>2>>>0]=b,b=0;b<l.length;++b)a()[y++>>>0]=l.charCodeAt(b);a()[y>>>0]=0,n+=l.length+1}),0}function qt(e,r){if(T)return G(19,1,e,r);e>>>=0,r>>>=0;var n=jt();w()[e>>>2>>>0]=n.length;var l=0;return n.forEach(y=>l+=y.length+1),w()[r>>>2>>>0]=l,0}function Vt(e){return T?G(20,1,e):52}function Jt(e,r,n,l){return T?G(21,1,e,r,n,l):52}function Xt(e,r,n,l,y){return T?G(22,1,e,r,n,l,y):70}var Hr=[null,[],[]];function Qt(e,r,n,l){if(T)return G(23,1,e,r,n,l);r>>>=0,n>>>=0,l>>>=0;for(var y=0,b=0;b<n;b++){var v=w()[r>>>2>>>0],z=w()[r+4>>>2>>>0];r+=8;for(var Ce=0;Ce<z;Ce++){var fe=h()[v+Ce>>>0],he=Hr[e];fe===0||fe===10?((e===1?Ie:ne)(U(he,0)),he.length=0):he.push(fe)}y+=z}return w()[l>>>2>>>0]=y,0}var Zt=[31,29,31,30,31,30,31,31,30,31,30,31],Kt=[31,28,31,30,31,30,31,31,30,31,30,31];function Gr(e){var r=Array(se(e)+1);return Qe(e,r,0,r.length),r}var $r=(e,r)=>{a().set(e,r>>>0)};function er(e,r,n,l){function y(p,N,q){for(p=typeof p=="number"?p.toString():p||"";p.length<N;)p=q[0]+p;return p}function b(p,N){return y(p,N,"0")}function v(p,N){function q(fr){return 0>fr?-1:0<fr?1:0}var He;return(He=q(p.getFullYear()-N.getFullYear()))===0&&(He=q(p.getMonth()-N.getMonth()))===0&&(He=q(p.getDate()-N.getDate())),He}function z(p){switch(p.getDay()){case 0:return new Date(p.getFullYear()-1,11,29);case 1:return p;case 2:return new Date(p.getFullYear(),0,3);case 3:return new Date(p.getFullYear(),0,2);case 4:return new Date(p.getFullYear(),0,1);case 5:return new Date(p.getFullYear()-1,11,31);case 6:return new Date(p.getFullYear()-1,11,30)}}function Ce(p){var N=p.Qa;for(p=new Date(new Date(p.Ra+1900,0,1).getTime());0<N;){var q=p.getMonth(),He=($e(p.getFullYear())?Zt:Kt)[q];if(N>He-p.getDate())N-=He-p.getDate()+1,p.setDate(1),11>q?p.setMonth(q+1):(p.setMonth(0),p.setFullYear(p.getFullYear()+1));else{p.setDate(p.getDate()+N);break}}return q=new Date(p.getFullYear()+1,0,4),N=z(new Date(p.getFullYear(),0,4)),q=z(q),0>=v(N,p)?0>=v(q,p)?p.getFullYear()+1:p.getFullYear():p.getFullYear()-1}e>>>=0,r>>>=0,n>>>=0,l>>>=0;var fe=w()[l+40>>>2>>>0];l={kb:f()[l>>>2>>>0],jb:f()[l+4>>>2>>>0],Sa:f()[l+8>>>2>>>0],Wa:f()[l+12>>>2>>>0],Ta:f()[l+16>>>2>>>0],Ra:f()[l+20>>>2>>>0],Ma:f()[l+24>>>2>>>0],Qa:f()[l+28>>>2>>>0],qb:f()[l+32>>>2>>>0],ib:f()[l+36>>>2>>>0],lb:fe?ee(fe):""},n=ee(n),fe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var he in fe)n=n.replace(new RegExp(he,"g"),fe[he]);var ir="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ur="January February March April May June July August September October November December".split(" ");fe={"%a":p=>ir[p.Ma].substring(0,3),"%A":p=>ir[p.Ma],"%b":p=>ur[p.Ta].substring(0,3),"%B":p=>ur[p.Ta],"%C":p=>b((p.Ra+1900)/100|0,2),"%d":p=>b(p.Wa,2),"%e":p=>y(p.Wa,2," "),"%g":p=>Ce(p).toString().substring(2),"%G":Ce,"%H":p=>b(p.Sa,2),"%I":p=>(p=p.Sa,p==0?p=12:12<p&&(p-=12),b(p,2)),"%j":p=>{for(var N=0,q=0;q<=p.Ta-1;N+=($e(p.Ra+1900)?Zt:Kt)[q++]);return b(p.Wa+N,3)},"%m":p=>b(p.Ta+1,2),"%M":p=>b(p.jb,2),"%n":()=>`\n`,"%p":p=>0<=p.Sa&&12>p.Sa?"AM":"PM","%S":p=>b(p.kb,2),"%t":()=>"	","%u":p=>p.Ma||7,"%U":p=>b(Math.floor((p.Qa+7-p.Ma)/7),2),"%V":p=>{var N=Math.floor((p.Qa+7-(p.Ma+6)%7)/7);if(2>=(p.Ma+371-p.Qa-2)%7&&N++,N)N==53&&(q=(p.Ma+371-p.Qa)%7,q==4||q==3&&$e(p.Ra)||(N=1));else{N=52;var q=(p.Ma+7-p.Qa-1)%7;(q==4||q==5&&$e(p.Ra%400-1))&&N++}return b(N,2)},"%w":p=>p.Ma,"%W":p=>b(Math.floor((p.Qa+7-(p.Ma+6)%7)/7),2),"%y":p=>(p.Ra+1900).toString().substring(2),"%Y":p=>p.Ra+1900,"%z":p=>{p=p.ib;var N=0<=p;return p=Math.abs(p)/60,(N?"+":"-")+("0000"+(p/60*100+p%60)).slice(-4)},"%Z":p=>p.lb,"%%":()=>"%"},n=n.replace(/%%/g,"\\0\\0");for(he in fe)n.includes(he)&&(n=n.replace(new RegExp(he,"g"),fe[he](l)));return n=n.replace(/\\0\\0/g,"%"),he=Gr(n),he.length>r?0:($r(he,e),he.length-1)}M.Va();var Yr=[qe,st,m,ye,oe,d,k,$,Me,Ze,Rt,It,Bt,kt,Wt,Nt,$t,Yt,zt,qt,Vt,Jt,Xt,Qt],jr={b:function(e,r,n){throw e>>>=0,new t(e).Va(r>>>0,n>>>0),o=e,u++,o},L:function(e){tr(e>>>0,!B,1,!R,131072,!1),M.$a()},j:function(e){e>>>=0,T?postMessage({cmd:"cleanupThread",thread:e}):M.Ya(M.La[e])},H:O,h:ye,S:oe,D:d,F:k,T:$,Q:Me,J:Ze,P:Rt,n:It,E:Bt,B:kt,R:Wt,C:Nt,p:()=>1,z:function(e,r){e>>>=0,e==r>>>0?setTimeout(it):T?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=M.La[e])&&e.postMessage({cmd:"checkMailbox"})},I:function(e,r,n,l,y){r>>>=0,n>>>=0,pt.length=l,y=y>>>0>>>3;for(var b=0;b<l;b++)pt[b]=g()[y+b>>>0];return e=r?Ge[r]:Yr[e],M.eb=n,n=e(...pt),M.eb=0,n},K:dt,o:function(e){D&&M.La[e>>>0].ref()},s:function(e,r,n){e=r+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*r:NaN,n>>>=0,e=new Date(1e3*e),f()[n>>>2>>>0]=e.getUTCSeconds(),f()[n+4>>>2>>>0]=e.getUTCMinutes(),f()[n+8>>>2>>>0]=e.getUTCHours(),f()[n+12>>>2>>>0]=e.getUTCDate(),f()[n+16>>>2>>>0]=e.getUTCMonth(),f()[n+20>>>2>>>0]=e.getUTCFullYear()-1900,f()[n+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,f()[n+28>>>2>>>0]=e},t:function(e,r,n){e=r+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*r:NaN,n>>>=0,e=new Date(1e3*e),f()[n>>>2>>>0]=e.getSeconds(),f()[n+4>>>2>>>0]=e.getMinutes(),f()[n+8>>>2>>>0]=e.getHours(),f()[n+12>>>2>>>0]=e.getDate(),f()[n+16>>>2>>>0]=e.getMonth(),f()[n+20>>>2>>>0]=e.getFullYear()-1900,f()[n+24>>>2>>>0]=e.getDay(),r=($e(e.getFullYear())?Ht:Gt)[e.getMonth()]+e.getDate()-1|0,f()[n+28>>>2>>>0]=r,f()[n+36>>>2>>>0]=-(60*e.getTimezoneOffset()),r=new Date(e.getFullYear(),6,1).getTimezoneOffset();var l=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=(r!=l&&e.getTimezoneOffset()==Math.min(l,r))|0,f()[n+32>>>2>>>0]=e},u:function(e){e>>>=0;var r=new Date(f()[e+20>>>2>>>0]+1900,f()[e+16>>>2>>>0],f()[e+12>>>2>>>0],f()[e+8>>>2>>>0],f()[e+4>>>2>>>0],f()[e>>>2>>>0],0),n=f()[e+32>>>2>>>0],l=r.getTimezoneOffset(),y=new Date(r.getFullYear(),6,1).getTimezoneOffset(),b=new Date(r.getFullYear(),0,1).getTimezoneOffset(),v=Math.min(b,y);return 0>n?f()[e+32>>>2>>>0]=+(y!=b&&v==l):0<n!=(v==l)&&(y=Math.max(b,y),r.setTime(r.getTime()+6e4*((0<n?v:y)-l))),f()[e+24>>>2>>>0]=r.getDay(),n=($e(r.getFullYear())?Ht:Gt)[r.getMonth()]+r.getDate()-1|0,f()[e+28>>>2>>>0]=n,f()[e>>>2>>>0]=r.getSeconds(),f()[e+4>>>2>>>0]=r.getMinutes(),f()[e+8>>>2>>>0]=r.getHours(),f()[e+12>>>2>>>0]=r.getDate(),f()[e+16>>>2>>>0]=r.getMonth(),f()[e+20>>>2>>>0]=r.getYear(),e=r.getTime(),e=isNaN(e)?-1:e/1e3,ar((Te=e,1<=+Math.abs(Te)?0<Te?+Math.floor(Te/4294967296)>>>0:~~+Math.ceil((Te-+(~~Te>>>0))/4294967296)>>>0:0)),e>>>0},q:$t,r:Yt,y:function(e,r,n,l){e>>>=0,r>>>=0,n>>>=0,l>>>=0;var y=new Date().getFullYear(),b=new Date(y,0,1),v=new Date(y,6,1);y=b.getTimezoneOffset();var z=v.getTimezoneOffset(),Ce=Math.max(y,z);w()[e>>>2>>>0]=60*Ce,f()[r>>>2>>>0]=+(y!=z),e=fe=>fe.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],b=e(b),v=e(v),z<y?(Re(b,n,17),Re(v,l,17)):(Re(b,l,17),Re(v,n,17))},c:()=>{te("")},O:function(e,r,n){e>>>=0,r>>>=0,n>>>=0,mt.length=0;for(var l;l=h()[r++>>>0];){var y=l!=105;y&=l!=112,n+=y&&n%8?4:0,mt.push(l==112?w()[n>>>2>>>0]:l==105?f()[n>>>2>>>0]:g()[n>>>3>>>0]),n+=y?8:4}return Ge[e](...mt)},k:()=>{},i:()=>Date.now(),U:()=>{throw De+=1,"unwind"},A:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:()=>D?(br(),et(hr)).cpus().length:navigator.hardwareConcurrency,x:function(e){e>>>=0;var r=h().length;if(e<=r||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var l=r*(1+.2/n);l=Math.min(l,e+100663296);var y=Math;l=Math.max(e,l);e:{y=(y.min.call(y,4294901760,l+(65536-l%65536)%65536)-X.buffer.byteLength+65535)/65536;try{X.grow(y),K();var b=1;break e}catch{}b=void 0}if(b)return!0}return!1},M:zt,N:qt,G:Ve,g:Vt,m:Jt,v:Xt,l:Qt,a:X||s.wasmMemory,w:er,d:function(e,r,n,l){return er(e>>>0,r>>>0,n>>>0,l>>>0)}},C=function(){function e(n,l){return C=n.exports,C=zr(),M.ab.push(C.ya),Xe=C.za,Ue.unshift(C.V),we=l,Be(),C}var r={a:jr};if(Ae++,s.instantiateWasm)try{return s.instantiateWasm(r,e)}catch(n){ne(`Module.instantiateWasm callback failed with error: ${n}`),x(n)}return rt(r,function(n){e(n.instance,n.module)}).catch(x),{}}();s._OrtInit=(e,r)=>(s._OrtInit=C.W)(e,r),s._OrtGetLastError=(e,r)=>(s._OrtGetLastError=C.X)(e,r),s._OrtCreateSessionOptions=(e,r,n,l,y,b,v,z,Ce,fe)=>(s._OrtCreateSessionOptions=C.Y)(e,r,n,l,y,b,v,z,Ce,fe),s._OrtAppendExecutionProvider=(e,r)=>(s._OrtAppendExecutionProvider=C.Z)(e,r),s._OrtAddFreeDimensionOverride=(e,r,n)=>(s._OrtAddFreeDimensionOverride=C._)(e,r,n),s._OrtAddSessionConfigEntry=(e,r,n)=>(s._OrtAddSessionConfigEntry=C.$)(e,r,n),s._OrtReleaseSessionOptions=e=>(s._OrtReleaseSessionOptions=C.aa)(e),s._OrtCreateSession=(e,r,n)=>(s._OrtCreateSession=C.ba)(e,r,n),s._OrtReleaseSession=e=>(s._OrtReleaseSession=C.ca)(e),s._OrtGetInputOutputCount=(e,r,n)=>(s._OrtGetInputOutputCount=C.da)(e,r,n),s._OrtGetInputName=(e,r)=>(s._OrtGetInputName=C.ea)(e,r),s._OrtGetOutputName=(e,r)=>(s._OrtGetOutputName=C.fa)(e,r),s._OrtFree=e=>(s._OrtFree=C.ga)(e),s._OrtCreateTensor=(e,r,n,l,y,b)=>(s._OrtCreateTensor=C.ha)(e,r,n,l,y,b),s._OrtGetTensorData=(e,r,n,l,y)=>(s._OrtGetTensorData=C.ia)(e,r,n,l,y),s._OrtReleaseTensor=e=>(s._OrtReleaseTensor=C.ja)(e),s._OrtCreateRunOptions=(e,r,n,l)=>(s._OrtCreateRunOptions=C.ka)(e,r,n,l),s._OrtAddRunConfigEntry=(e,r,n)=>(s._OrtAddRunConfigEntry=C.la)(e,r,n),s._OrtReleaseRunOptions=e=>(s._OrtReleaseRunOptions=C.ma)(e),s._OrtCreateBinding=e=>(s._OrtCreateBinding=C.na)(e),s._OrtBindInput=(e,r,n)=>(s._OrtBindInput=C.oa)(e,r,n),s._OrtBindOutput=(e,r,n,l)=>(s._OrtBindOutput=C.pa)(e,r,n,l),s._OrtClearBoundOutputs=e=>(s._OrtClearBoundOutputs=C.qa)(e),s._OrtReleaseBinding=e=>(s._OrtReleaseBinding=C.ra)(e),s._OrtRunWithBinding=(e,r,n,l,y)=>(s._OrtRunWithBinding=C.sa)(e,r,n,l,y),s._OrtRun=(e,r,n,l,y,b,v,z)=>(s._OrtRun=C.ta)(e,r,n,l,y,b,v,z),s._OrtEndProfiling=e=>(s._OrtEndProfiling=C.ua)(e);var ut=s._pthread_self=()=>(ut=s._pthread_self=C.va)();s._malloc=e=>(s._malloc=C.wa)(e),s._free=e=>(s._free=C.xa)(e),s.__emscripten_tls_init=()=>(s.__emscripten_tls_init=C.ya)();var tr=s.__emscripten_thread_init=(e,r,n,l,y,b)=>(tr=s.__emscripten_thread_init=C.Aa)(e,r,n,l,y,b);s.__emscripten_thread_crashed=()=>(s.__emscripten_thread_crashed=C.Ba)();var rr=(e,r,n,l,y)=>(rr=C.Ca)(e,r,n,l,y),bt=e=>(bt=C.Da)(e),yt=s.__emscripten_thread_exit=e=>(yt=s.__emscripten_thread_exit=C.Ea)(e),nr=()=>(nr=C.Fa)(),ar=e=>(ar=C.Ga)(e),or=(e,r)=>(or=C.Ha)(e,r),ft=e=>(ft=C.Ia)(e),wt=e=>(wt=C.Ja)(e),Ot=()=>(Ot=C.Ka)();function zr(){var e=C;e=Object.assign({},e);var r=l=>()=>l()>>>0,n=l=>y=>l(y)>>>0;return e.va=r(e.va),e.wa=n(e.wa),e.emscripten_main_runtime_thread_id=r(e.emscripten_main_runtime_thread_id),e.Ja=n(e.Ja),e.Ka=r(e.Ka),e}s.wasmMemory=X,s.stackSave=()=>Ot(),s.stackRestore=e=>ft(e),s.stackAlloc=e=>wt(e),s.keepRuntimeAlive=()=>0<De,s.UTF8ToString=ee,s.stringToUTF8=Re,s.lengthBytesUTF8=se,s.ExitStatus=ke,s.PThread=M;var lt;ge=function e(){lt||sr(),lt||(ge=e)};function sr(){if(!(0<Ae))if(T)S(s),T||Ne(Ue),startWorker(s);else{if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)Oe.unshift(s.preRun.shift());Ne(Oe),0<Ae||lt||(lt=!0,s.calledRun=!0,me||(T||Ne(Ue),S(s),T||Ne(ve)))}}return sr(),H}})();typeof wr=="object"&&typeof Dt=="object"?Dt.exports=yr:typeof define=="function"&&define.amd&&define([],()=>yr)});var vr=Ke((yn,tn)=>{tn.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(...e){var a=e.join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,a+`\\n`);return}console.error(a)}function threadAlert(...e){var a=e.join(" ");postMessage({cmd:"alert",text:a,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,a)=>{var r=Module.wasmModule;Module.wasmModule=null;var t=new WebAssembly.Instance(r,e);return a(t)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let r=[];self.onmessage=t=>r.push(t),self.startWorker=t=>{Module=t,postMessage({cmd:"loaded"});for(let s of r)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const t of e.data.handlers)Module[t]=(...s)=>{postMessage({cmd:"callHandler",handler:t,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var a=URL.createObjectURL(e.data.urlOrBlob);importScripts(a),URL.revokeObjectURL(a)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(r){if(r!="unwind")throw r}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(r){throw Module.__emscripten_thread_crashed?.(),r}}self.onmessage=handleMessage;\\n\'});var Er;Er=pr();var rn=Or(),Ft,Pt=!1,ct=!1,_r=!1,nn=i=>{if(i===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+i+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+i+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},an=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},on=(i,c)=>i?c?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":c?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Sr=async i=>{if(Pt)return Promise.resolve();if(ct)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(_r)throw new Error("previous call to \'initializeWebAssembly()\' failed.");ct=!0;let c=i.initTimeout,a=i.numThreads,h=i.simd,f=nn(a),w=h&&an(),g=i.wasmPaths,s=typeof g=="string"?g:void 0,S=on(w,f),x=typeof g=="object"?g[S]:void 0,H=!1,A=[];if(c>0&&A.push(new Promise(I=>{setTimeout(()=>{H=!0,I()},c)})),A.push(new Promise((I,V)=>{let R=f?rn:Er,B={locateFile:(D,T)=>f&&D.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([vr()],{type:"text/javascript"})):D.endsWith(".wasm")?x||(s??T)+S:T+D};if(f)if(B.numThreads=a,typeof Blob>"u")B.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let D=`var ortWasmThreaded=${R.toString()};`;B.mainScriptUrlOrBlob=new Blob([D],{type:"text/javascript"})}R(B).then(D=>{ct=!1,Pt=!0,Ft=D,I()},D=>{ct=!1,_r=!0,V(D)})})),await Promise.race(A),H)throw new Error(`WebAssembly backend initializing failed due to timeout: ${c}ms`)},Q=()=>{if(Pt&&Ft)return Ft;throw new Error("WebAssembly is not initialized yet.")};var Y=(i,c)=>{let a=Q(),h=a.lengthBytesUTF8(i)+1,f=a._malloc(h);return a.stringToUTF8(i,f,h),c.push(f),f},tt=(i,c,a,h)=>{if(typeof i=="object"&&i!==null){if(a.has(i))throw new Error("Circular reference in options");a.add(i)}Object.entries(i).forEach(([f,w])=>{let g=c?c+f:f;if(typeof w=="object")tt(w,g+".",a,h);else if(typeof w=="string"||typeof w=="number")h(g,w.toString());else if(typeof w=="boolean")h(g,w?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof w}`)})},j=i=>{let c=Q(),a=c.stackSave();try{let h=c.stackAlloc(8);c._OrtGetLastError(h,h+4);let f=c.HEAP32[h/4],w=c.HEAPU32[h/4+1],g=w?c.UTF8ToString(w):"";throw new Error(`${i} ERROR_CODE: ${f}, ERROR_MESSAGE: ${g}`)}finally{c.stackRestore(a)}};var Ar=i=>{let c=Q(),a=0,h=[],f=i||{};try{if(i?.logSeverityLevel===void 0)f.logSeverityLevel=2;else if(typeof i.logSeverityLevel!="number"||!Number.isInteger(i.logSeverityLevel)||i.logSeverityLevel<0||i.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${i.logSeverityLevel}`);if(i?.logVerbosityLevel===void 0)f.logVerbosityLevel=0;else if(typeof i.logVerbosityLevel!="number"||!Number.isInteger(i.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${i.logVerbosityLevel}`);i?.terminate===void 0&&(f.terminate=!1);let w=0;return i?.tag!==void 0&&(w=Y(i.tag,h)),a=c._OrtCreateRunOptions(f.logSeverityLevel,f.logVerbosityLevel,!!f.terminate,w),a===0&&j("Can\'t create run options."),i?.extra!==void 0&&tt(i.extra,"",new WeakSet,(g,s)=>{let S=Y(g,h),x=Y(s,h);c._OrtAddRunConfigEntry(a,S,x)!==0&&j(`Can\'t set a run config entry: ${g} - ${s}.`)}),[a,h]}catch(w){throw a!==0&&c._OrtReleaseRunOptions(a),h.forEach(g=>c._free(g)),w}};var sn=i=>{switch(i){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${i}`)}},un=i=>{switch(i){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${i}`)}},fn=i=>{i.extra||(i.extra={}),i.extra.session||(i.extra.session={});let c=i.extra.session;c.use_ort_model_bytes_directly||(c.use_ort_model_bytes_directly="1"),i.executionProviders&&i.executionProviders.some(a=>(typeof a=="string"?a:a.name)==="webgpu")&&(i.enableMemPattern=!1)},ln=(i,c,a)=>{for(let h of c){let f=typeof h=="string"?h:h.name;switch(f){case"webnn":if(f="WEBNN",typeof h!="string"){let g=h;if(g?.deviceType){let s=Y("deviceType",a),S=Y(g.deviceType,a);Q()._OrtAddSessionConfigEntry(i,s,S)!==0&&j(`Can\'t set a session config entry: \'deviceType\' - ${g.deviceType}.`)}if(g?.numThreads){let s=g.numThreads;(typeof s!="number"||!Number.isInteger(s)||s<0)&&(s=0);let S=Y("numThreads",a),x=Y(s.toString(),a);Q()._OrtAddSessionConfigEntry(i,S,x)!==0&&j(`Can\'t set a session config entry: \'numThreads\' - ${g.numThreads}.`)}if(g?.powerPreference){let s=Y("powerPreference",a),S=Y(g.powerPreference,a);Q()._OrtAddSessionConfigEntry(i,s,S)!==0&&j(`Can\'t set a session config entry: \'powerPreference\' - ${g.powerPreference}.`)}}break;case"webgpu":if(f="JS",typeof h!="string"){let g=h;if(g?.preferredLayout){if(g.preferredLayout!=="NCHW"&&g.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${g.preferredLayout}`);let s=Y("preferredLayout",a),S=Y(g.preferredLayout,a);Q()._OrtAddSessionConfigEntry(i,s,S)!==0&&j(`Can\'t set a session config entry: \'preferredLayout\' - ${g.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${f}`)}let w=Y(f,a);Q()._OrtAppendExecutionProvider(i,w)!==0&&j(`Can\'t append execution provider: ${f}.`)}},Tr=i=>{let c=Q(),a=0,h=[],f=i||{};fn(f);try{let w=sn(f.graphOptimizationLevel??"all"),g=un(f.executionMode??"sequential"),s=typeof f.logId=="string"?Y(f.logId,h):0,S=f.logSeverityLevel??2;if(!Number.isInteger(S)||S<0||S>4)throw new Error(`log serverity level is not valid: ${S}`);let x=f.logVerbosityLevel??0;if(!Number.isInteger(x)||x<0||x>4)throw new Error(`log verbosity level is not valid: ${x}`);let H=typeof f.optimizedModelFilePath=="string"?Y(f.optimizedModelFilePath,h):0;if(a=c._OrtCreateSessionOptions(w,!!f.enableCpuMemArena,!!f.enableMemPattern,g,!!f.enableProfiling,0,s,S,x,H),a===0&&j("Can\'t create session options."),f.executionProviders&&ln(a,f.executionProviders,h),f.enableGraphCapture!==void 0){if(typeof f.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${f.enableGraphCapture}`);let A=Y("enableGraphCapture",h),I=Y(f.enableGraphCapture.toString(),h);c._OrtAddSessionConfigEntry(a,A,I)!==0&&j(`Can\'t set a session config entry: \'enableGraphCapture\' - ${f.enableGraphCapture}.`)}if(f.freeDimensionOverrides)for(let[A,I]of Object.entries(f.freeDimensionOverrides)){if(typeof A!="string")throw new Error(`free dimension override name must be a string: ${A}`);if(typeof I!="number"||!Number.isInteger(I)||I<0)throw new Error(`free dimension override value must be a non-negative integer: ${I}`);let V=Y(A,h);c._OrtAddFreeDimensionOverride(a,V,I)!==0&&j(`Can\'t set a free dimension override: ${A} - ${I}.`)}return f.extra!==void 0&&tt(f.extra,"",new WeakSet,(A,I)=>{let V=Y(A,h),R=Y(I,h);c._OrtAddSessionConfigEntry(a,V,R)!==0&&j(`Can\'t set a session config entry: ${A} - ${I}.`)}),[a,h]}catch(w){throw a!==0&&c._OrtReleaseSessionOptions(a),h.forEach(g=>c._free(g)),w}};var xt=i=>{switch(i){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${i}`)}},Mr=i=>{switch(i){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${i}`)}},Ut=i=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][i],Cr=i=>{switch(i){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${i}`)}},Dr=i=>{switch(i){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${i}`)}},Fr=i=>i==="float32"||i==="float16"||i==="int32"||i==="int64"||i==="uint32"||i==="uint8"||i==="bool",Pr=i=>{switch(i){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${i}`)}};var xr=async i=>{if(typeof i=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(i))}catch(c){if(c.code==="ERR_FS_FILE_TOO_LARGE"){let a=(void 0)(i),h=[];for await(let f of a)h.push(f);return new Uint8Array(Buffer.concat(h))}throw c}else{let c=await fetch(i);if(!c.ok)throw new Error(`failed to load external data file: ${i}`);let a=c.headers.get("Content-Length"),h=a?parseInt(a,10):0;if(h<1073741824)return new Uint8Array(await c.arrayBuffer());{if(!c.body)throw new Error(`failed to load external data file: ${i}, no response body.`);let f=c.body.getReader(),w;try{w=new ArrayBuffer(h)}catch(s){if(s instanceof RangeError){let S=Math.ceil(h/65536);w=new WebAssembly.Memory({initial:S,maximum:S}).buffer}else throw s}let g=0;for(;;){let{done:s,value:S}=await f.read();if(s)break;let x=S.byteLength;new Uint8Array(w,g,x).set(S),g+=x}return new Uint8Array(w,0,h)}}else return i instanceof Blob?new Uint8Array(await i.arrayBuffer()):i instanceof Uint8Array?i:new Uint8Array(i)};var cn=(i,c)=>{Q()._OrtInit(i,c)!==0&&j("Can\'t initialize onnxruntime.")},Lr=async i=>{cn(i.wasm.numThreads,Dr(i.logLevel))},Rr=async(i,c)=>{},Ye=new Map,dn=i=>{let c=Q(),a=c.stackSave();try{let h=c.stackAlloc(8);return c._OrtGetInputOutputCount(i,h,h+4)!==0&&j("Can\'t get session input/output count."),[c.HEAP32[h/4],c.HEAP32[h/4+1]]}finally{c.stackRestore(a)}},Lt=i=>{let c=Q(),a=c._malloc(i.byteLength);if(a===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${i.byteLength}.`);return c.HEAPU8.set(i,a),[a,i.byteLength]},Ir=async(i,c)=>{let a,h,f=Q();Array.isArray(i)?[a,h]=i:i.buffer===f.HEAPU8.buffer?[a,h]=[i.byteOffset,i.byteLength]:[a,h]=Lt(i);let w=0,g=0,s=0,S=[],x=[],H=[];try{if([g,S]=Tr(c),c?.externalData&&f.mountExternalData){let L=[];for(let W of c.externalData){let de=typeof W=="string"?W:W.path;L.push(xr(typeof W=="string"?W:W.data).then(pe=>{f.mountExternalData(de,pe)}))}await Promise.all(L)}w=await f._OrtCreateSession(a,h,g),w===0&&j("Can\'t create a session.");let[A,I]=dn(w),V=!!c?.enableGraphCapture,R=[],B=[],D=[];for(let L=0;L<A;L++){let W=f._OrtGetInputName(w,L);W===0&&j("Can\'t get an input name."),x.push(W),R.push(f.UTF8ToString(W))}for(let L=0;L<I;L++){let W=f._OrtGetOutputName(w,L);W===0&&j("Can\'t get an output name."),H.push(W);let de=f.UTF8ToString(W);B.push(de)}let T=null;return Ye.set(w,[w,x,H,T,V,!1]),[w,R,B]}catch(A){throw x.forEach(I=>f._OrtFree(I)),H.forEach(I=>f._OrtFree(I)),s!==0&&f._OrtReleaseBinding(s),w!==0&&f._OrtReleaseSession(w),A}finally{f._free(a),g!==0&&f._OrtReleaseSessionOptions(g),S.forEach(A=>f._free(A)),f.unmountExternalData?.()}},Br=i=>{let c=Q(),a=Ye.get(i);if(!a)throw new Error(`cannot release session. invalid session id: ${i}`);let[h,f,w,g,s]=a;g&&(s&&c._OrtClearBoundOutputs(g.handle),c._OrtReleaseBinding(g.handle)),c.jsepOnReleaseSession?.(i),f.forEach(S=>c._OrtFree(S)),w.forEach(S=>c._OrtFree(S)),c._OrtReleaseSession(h),Ye.delete(i)},Ur=(i,c,a,h,f,w=!1)=>{if(!i){c.push(0);return}let g=Q(),s=i[0],S=i[1],x=i[3],H,A;if(s==="string"&&x==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(w&&x!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${f} when enableGraphCapture is true.`);if(x==="gpu-buffer"){let R=i[2].gpuBuffer,B=Ut(xt(s));A=S.reduce((T,L)=>T*L,1)*B;let D=g.jsepRegisterBuffer;if(!D)throw new Error(\'Tensor location "gpu-buffer" is not supported without using WebGPU.\');H=D(h,f,R,A)}else{let R=i[2];if(Array.isArray(R)){A=4*R.length,H=g._malloc(A),a.push(H);let B=H/4;for(let D=0;D<R.length;D++){if(typeof R[D]!="string")throw new TypeError(`tensor data at index ${D} is not a string`);g.HEAPU32[B++]=Y(R[D],a)}}else A=R.byteLength,H=g._malloc(A),a.push(H),g.HEAPU8.set(new Uint8Array(R.buffer,R.byteOffset,A),H)}let I=g.stackSave(),V=g.stackAlloc(4*S.length);try{let R=V/4;S.forEach(D=>g.HEAP32[R++]=D);let B=g._OrtCreateTensor(xt(s),H,A,V,S.length,Pr(x));B===0&&j(`Can\'t create tensor for input/output. session=${h}, index=${f}.`),c.push(B)}finally{g.stackRestore(I)}},kr=async(i,c,a,h,f,w)=>{let g=Q(),s=Ye.get(i);if(!s)throw new Error(`cannot run inference. invalid session id: ${i}`);let S=s[0],x=s[1],H=s[2],A=s[3],I=s[4],V=s[5],R=c.length,B=h.length,D=0,T=[],L=[],W=[],de=[],pe=g.stackSave(),Z=g.stackAlloc(R*4),_=g.stackAlloc(R*4),J=g.stackAlloc(B*4),Pe=g.stackAlloc(B*4);try{[D,T]=Ar(w);for(let F=0;F<R;F++)Ur(a[F],L,de,i,c[F],I);for(let F=0;F<B;F++)Ur(f[F],W,de,i,R+h[F],I);let le=Z/4,Ie=_/4,ne=J/4,X=Pe/4;for(let F=0;F<R;F++)g.HEAPU32[le++]=L[F],g.HEAPU32[Ie++]=x[c[F]];for(let F=0;F<B;F++)g.HEAPU32[ne++]=W[F],g.HEAPU32[X++]=H[h[F]];g.jsepOnRunStart?.(S);let we;we=await g._OrtRun(S,_,Z,R,Pe,B,J,D),we!==0&&j("failed to call OrtRun().");let me=[];for(let F=0;F<B;F++){let ie=g.HEAPU32[J/4+F];if(ie===W[F]){me.push(f[F]);continue}let xe=g.stackSave(),ce=g.stackAlloc(4*4),be=!1,ae,K=0;try{g._OrtGetTensorData(ie,ce,ce+4,ce+8,ce+12)!==0&&j(`Can\'t access output tensor data on index ${F}.`);let Oe=ce/4,Ue=g.HEAPU32[Oe++];K=g.HEAPU32[Oe++];let ve=g.HEAPU32[Oe++],Ae=g.HEAPU32[Oe++],_e=[];for(let te=0;te<Ae;te++)_e.push(g.HEAPU32[ve/4+te]);g._OrtFree(ve);let ge=_e.reduce((te,re)=>te*re,1);ae=Mr(Ue);let Be=A?.outputPreferredLocations[h[F]];if(ae==="string"){if(Be==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let te=[],re=K/4;for(let ue=0;ue<ge;ue++){let Ee=g.HEAPU32[re++],Se=ue===ge-1?void 0:g.HEAPU32[re]-Ee;te.push(g.UTF8ToString(Ee,Se))}me.push([ae,_e,te,"cpu"])}else if(Be==="gpu-buffer"&&ge>0){let te=g.jsepGetBuffer;if(!te)throw new Error(\'preferredLocation "gpu-buffer" is not supported without using WebGPU.\');let re=te(K),ue=Ut(Ue);if(ue===void 0||!Fr(ae))throw new Error(`Unsupported data type: ${ae}`);be=!0,me.push([ae,_e,{gpuBuffer:re,download:g.jsepCreateDownloader(re,ge*ue,ae),dispose:()=>{g._OrtReleaseTensor(ie)}},"gpu-buffer"])}else{let te=Cr(ae),re=new te(ge);new Uint8Array(re.buffer,re.byteOffset,re.byteLength).set(g.HEAPU8.subarray(K,K+re.byteLength)),me.push([ae,_e,re,"cpu"])}}finally{g.stackRestore(xe),ae==="string"&&K&&g._free(K),be||g._OrtReleaseTensor(ie)}}return A&&!I&&(g._OrtClearBoundOutputs(A.handle),Ye.set(i,[S,x,H,A,I,!1])),me}finally{g.stackRestore(pe),L.forEach(le=>g._OrtReleaseTensor(le)),W.forEach(le=>g._OrtReleaseTensor(le)),de.forEach(le=>g._free(le)),D!==0&&g._OrtReleaseRunOptions(D),T.forEach(le=>g._free(le))}},Wr=i=>{let c=Q(),a=Ye.get(i);if(!a)throw new Error("invalid session id");let h=a[0],f=c._OrtEndProfiling(h);f===0&&j("Can\'t get an profile file name."),c._OrtFree(f)},Nr=i=>{let c=[];for(let a of i){let h=a[2];!Array.isArray(h)&&"buffer"in h&&c.push(h.buffer)}return c};self.onmessage=i=>{let{type:c,in:a}=i.data;try{switch(c){case"init-wasm":Sr(a.wasm).then(()=>{Lr(a).then(()=>{postMessage({type:c})},h=>{postMessage({type:c,err:h})})},h=>{postMessage({type:c,err:h})});break;case"init-ep":{let{epName:h,env:f}=a;Rr(f,h).then(()=>{postMessage({type:c})},w=>{postMessage({type:c,err:w})});break}case"copy-from":{let{buffer:h}=a,f=Lt(h);postMessage({type:c,out:f});break}case"create":{let{model:h,options:f}=a;Ir(h,f).then(w=>{postMessage({type:c,out:w})},w=>{postMessage({type:c,err:w})});break}case"release":Br(a),postMessage({type:c});break;case"run":{let{sessionId:h,inputIndices:f,inputs:w,outputIndices:g,options:s}=a;kr(h,f,w,g,new Array(g.length).fill(null),s).then(S=>{S.some(x=>x[3]!=="cpu")?postMessage({type:c,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:c,out:S},Nr([...w,...S]))},S=>{postMessage({type:c,err:S})});break}case"end-profiling":Wr(a),postMessage({type:c});break;default:}}catch(h){postMessage({type:c,err:h})}};})();\n'}),_r,gt$1,yn,Do,Lo,ca$1,pa$1,Vr,Wr,Tg,Eo,od$1,id$1,ad$1,sd$1,ud$1,ld$1,fd$1,da$1=L(()=>{var st;Ot$1(),rd$1(),Ur(),_r=()=>!!Z.wasm.proxy&&typeof document<"u",yn=!1,Do=!1,Lo=!1,pa$1=new Map,Vr=(at,pt)=>{let vt=pa$1.get(at);vt?vt.push(pt):pa$1.set(at,[pt])},Wr=()=>{if(yn||!Do||Lo||!gt$1)throw new Error("worker not ready")},Tg=at=>{switch(at.data.type){case"init-wasm":yn=!1,at.data.err?(Lo=!0,ca$1[1](at.data.err)):(Do=!0,ca$1[0]());break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let pt=pa$1.get(at.data.type);at.data.err?pt.shift()[1](at.data.err):pt.shift()[0](at.data.out);break}}},Eo=typeof document<"u"?(st=document==null?void 0:document.currentScript)==null?void 0:st.src:void 0,od$1=async()=>{if(!Do){if(yn)throw new Error("multiple calls to 'initWasm()' detected.");if(Lo)throw new Error("previous call to 'initWasm()' failed.");if(yn=!0,_r())return Z.wasm.wasmPaths===void 0&&Eo&&Eo.indexOf("blob:")!==0&&(Z.wasm.wasmPaths=Eo.substr(0,+Eo.lastIndexOf("/")+1)),new Promise((at,pt)=>{gt$1==null||gt$1.terminate();let vt=URL.createObjectURL(new Blob([nd$1()],{type:"text/javascript"}));gt$1=new Worker(vt,{name:"ort-wasm-proxy-worker"}),gt$1.onerror=$t=>pt($t),gt$1.onmessage=Tg,URL.revokeObjectURL(vt),ca$1=[at,pt];let wt={type:"init-wasm",in:Z};gt$1.postMessage(wt)});try{await Mp$1(Z.wasm),await Xp$1(Z),Do=!0}catch(at){throw Lo=!0,at}finally{yn=!1}}},id$1=async at=>{if(_r())return Wr(),new Promise((pt,vt)=>{Vr("init-ep",[pt,vt]);let wt={type:"init-ep",in:{epName:at,env:Z}};gt$1.postMessage(wt)});await Kp$1(Z,at)},ad$1=async at=>_r()?(Wr(),new Promise((pt,vt)=>{Vr("copy-from",[pt,vt]);let wt={type:"copy-from",in:{buffer:at}};gt$1.postMessage(wt,[at.buffer])})):fa$1(at),sd$1=async(at,pt)=>{if(_r()){if(pt!=null&&pt.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Wr(),new Promise((vt,wt)=>{Vr("create",[vt,wt]);let $t={type:"create",in:{model:at,options:{...pt}}},Tt=[];at instanceof Uint8Array&&Tt.push(at.buffer),gt$1.postMessage($t,Tt)})}else return Jp$1(at,pt)},ud$1=async at=>{if(_r())return Wr(),new Promise((pt,vt)=>{Vr("release",[pt,vt]);let wt={type:"release",in:at};gt$1.postMessage(wt)});Zp$1(at)},ld$1=async(at,pt,vt,wt,$t,Tt)=>{if(_r()){if(vt.some(Lt=>Lt[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if($t.some(Lt=>Lt))throw new Error("pre-allocated output tensor is not supported for proxy.");return Wr(),new Promise((Lt,Ft)=>{Vr("run",[Lt,Ft]);let Ct=vt,Ht={type:"run",in:{sessionId:at,inputIndices:pt,inputs:Ct,outputIndices:wt,options:Tt}};gt$1.postMessage(Ht,td$1(Ct))})}else return Qp$1(at,pt,vt,wt,$t,Tt)},fd$1=async at=>{if(_r())return Wr(),new Promise((pt,vt)=>{Vr("end-profiling",[pt,vt]);let wt={type:"end-profiling",in:at};gt$1.postMessage(wt)});ed$1(at)}}),cd$1,xg,Co$1,pd$1=L(()=>{Ot$1(),da$1(),ua$1(),la$1(),cd$1=(st,at)=>{switch(st.location){case"cpu":return[st.type,st.dims,st.data,"cpu"];case"gpu-buffer":return[st.type,st.dims,{gpuBuffer:st.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${st.location} for ${at()}`)}},xg=st=>{switch(st[3]){case"cpu":return new Me(st[0],st[2],st[1]);case"gpu-buffer":{let at=st[0];if(!Po(at))throw new Error(`not supported data type: ${at} for deserializing GPU tensor`);let{gpuBuffer:pt,download:vt,dispose:wt}=st[2];return Me.fromGpuBuffer(pt,{dataType:at,dims:st[1],download:vt,dispose:wt})}default:throw new Error(`invalid data location: ${st[3]}`)}},Co$1=class{async fetchModelAndCopyToWasmMemory(st){return ad$1(await gn(st))}async loadModel(st,at){lr$1();let pt;typeof st=="string"?typeof process<"u"&&process.versions&&process.versions.node?pt=await gn(st):pt=await this.fetchModelAndCopyToWasmMemory(st):pt=st,[this.sessionId,this.inputNames,this.outputNames]=await sd$1(pt,at),fr$1()}async dispose(){return ud$1(this.sessionId)}async run(st,at,pt){lr$1();let vt=[],wt=[];Object.entries(st).forEach(Gt=>{let jt=Gt[0],qt=Gt[1],Kt=this.inputNames.indexOf(jt);if(Kt===-1)throw new Error(`invalid input '${jt}'`);vt.push(qt),wt.push(Kt)});let $t=[],Tt=[];Object.entries(at).forEach(Gt=>{let jt=Gt[0],qt=Gt[1],Kt=this.outputNames.indexOf(jt);if(Kt===-1)throw new Error(`invalid output '${jt}'`);$t.push(qt),Tt.push(Kt)});let Lt=vt.map((Gt,jt)=>cd$1(Gt,()=>`input "${this.inputNames[wt[jt]]}"`)),Ft=$t.map((Gt,jt)=>Gt?cd$1(Gt,()=>`output "${this.outputNames[Tt[jt]]}"`):null),Ct=await ld$1(this.sessionId,wt,Lt,Tt,Ft,pt),Ht={};for(let Gt=0;Gt<Ct.length;Gt++)Ht[this.outputNames[Tt[Gt]]]=$t[Gt]??xg(Ct[Gt]);return fr$1(),Ht}startProfiling(){}endProfiling(){fd$1(this.sessionId)}}}),wg,Fo,dd$1=L(()=>{Ot$1(),da$1(),pd$1(),wg=()=>{if((typeof Z.wasm.initTimeout!="number"||Z.wasm.initTimeout<0)&&(Z.wasm.initTimeout=0),typeof Z.wasm.simd!="boolean"&&(Z.wasm.simd=!0),typeof Z.wasm.proxy!="boolean"&&(Z.wasm.proxy=!1),typeof Z.wasm.trace!="boolean"&&(Z.wasm.trace=!1),typeof Z.wasm.numThreads!="number"||!Number.isInteger(Z.wasm.numThreads)||Z.wasm.numThreads<=0){(typeof self<"u"&&!self.crossOriginIsolated||typeof process<"u"&&process.versions&&process.versions.node)&&(Z.wasm.numThreads=1);let st=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;Z.wasm.numThreads=Math.min(4,Math.ceil((st||1)/2))}},Fo=class{async init(st){wg(),await od$1(),await id$1(st)}async createInferenceSessionHandler(st,at){let pt=new Co$1;return await pt.loadModel(st,at),Promise.resolve(pt)}}}),hd$1={};Sr(hd$1,{wasmBackend:()=>vg});var vg,md$1=L(()=>{dd$1(),vg=new Fo});Ot$1();Ot$1();Ot$1();var Ts$1="1.18.0",jO=qo;{let st=(Op$1(),ar(_p$1)).onnxjsBackend;Pr$1("webgl",st,-10)}{let st=(md$1(),ar(hd$1)).wasmBackend;Pr$1("cpu",st,10),Pr$1("wasm",st,10)}Object.defineProperty(Z.versions,"web",{value:Ts$1,enumerable:!0});/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/const ort_cpu=Object.freeze(Object.defineProperty({__proto__:null,get InferenceSession(){return Pd$1},get TRACE(){return ls$1},get TRACE_FUNC_BEGIN(){return lr$1},get TRACE_FUNC_END(){return fr$1},get Tensor(){return Me},get TrainingSession(){return Dd$1},default:jO,get env(){return Z},get registerBackend(){return Pr$1}},Symbol.toStringTag,{value:"Module"}));/*!
 * ONNX Runtime Web v1.18.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var Oi=Object.defineProperty,nc=Object.getOwnPropertyDescriptor,ic=Object.getOwnPropertyNames,oc=Object.prototype.hasOwnProperty,j=(st,at)=>()=>(st&&(at=st(st=0)),at),Er=(st,at)=>()=>(at||st((at={exports:{}}).exports,at),at.exports),kr=(st,at)=>{for(var pt in at)Oi(st,pt,{get:at[pt],enumerable:!0})},ac=(st,at,pt,vt)=>{if(at&&typeof at=="object"||typeof at=="function")for(let wt of ic(at))!oc.call(st,wt)&&wt!==pt&&Oi(st,wt,{get:()=>at[wt],enumerable:!(vt=nc(at,wt))||vt.enumerable});return st},sr=st=>ac(Oi({},"__esModule",{value:!0}),st),kn,ur,lr,sc,On,Pn=j(()=>{kn=new Map,ur=[],lr=(st,at,pt)=>{if(at&&typeof at.init=="function"&&typeof at.createInferenceSessionHandler=="function"){let vt=kn.get(st);if(vt===void 0)kn.set(st,{backend:at,priority:pt});else{if(vt.priority>pt)return;if(vt.priority===pt&&vt.backend!==at)throw new Error(`cannot register backend "${st}" using priority ${pt}`)}if(pt>=0){let wt=ur.indexOf(st);wt!==-1&&ur.splice(wt,1);for(let $t=0;$t<ur.length;$t++)if(kn.get(ur[$t]).priority<=pt){ur.splice($t,0,st);return}ur.push(st)}return}throw new TypeError("not a valid backend")},sc=async st=>{let at=kn.get(st);if(!at)return"backend not found.";if(at.initialized)return at.backend;if(at.aborted)return at.error;{let pt=!!at.initPromise;try{return pt||(at.initPromise=at.backend.init(st)),await at.initPromise,at.initialized=!0,at.backend}catch(vt){return pt||(at.error=`${vt}`,at.aborted=!0),at.error}finally{delete at.initPromise}}},On=async st=>{let at=st.executionProviders||[],pt=at.map(Ft=>typeof Ft=="string"?Ft:Ft.name),vt=pt.length===0?ur:pt,wt,$t=[],Tt=new Set;for(let Ft of vt){let Ct=await sc(Ft);typeof Ct=="string"?$t.push({name:Ft,err:Ct}):(wt||(wt=Ct),wt===Ct&&Tt.add(Ft))}if(!wt)throw new Error(`no available backend found. ERR: ${$t.map(Ft=>`[${Ft.name}] ${Ft.err}`).join(", ")}`);for(let{name:Ft,err:Ct}of $t)pt.includes(Ft)&&console.warn(`removing requested execution provider "${Ft}" from session options because it is not available: ${Ct}`);let Lt=at.filter(Ft=>Tt.has(typeof Ft=="string"?Ft:Ft.name));return[wt,new Proxy(st,{get:(Ft,Ct)=>Ct==="executionProviders"?Lt:Reflect.get(Ft,Ct)})]}}),ra=j(()=>{Pn()}),na,ia=j(()=>{na="1.18.0"}),oa,gt,Pi=j(()=>{ia(),oa="warning",gt={wasm:{},webgl:{},webgpu:{},versions:{common:na},set logLevel(st){if(st!==void 0){if(typeof st!="string"||["verbose","info","warning","error","fatal"].indexOf(st)===-1)throw new Error(`Unsupported logging level: ${st}`);oa=st}},get logLevel(){return oa}},Object.defineProperty(gt,"logLevel",{enumerable:!0})}),ke,aa=j(()=>{Pi(),ke=gt}),sa,ua,la=j(()=>{sa=(st,at)=>{let pt=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);pt.width=st.dims[3],pt.height=st.dims[2];let vt=pt.getContext("2d");if(vt!=null){let wt,$t;(at==null?void 0:at.tensorLayout)!==void 0&&at.tensorLayout==="NHWC"?(wt=st.dims[2],$t=st.dims[3]):(wt=st.dims[3],$t=st.dims[2]);let Tt=(at==null?void 0:at.format)!==void 0?at.format:"RGB",Lt=at==null?void 0:at.norm,Ft,Ct;Lt===void 0||Lt.mean===void 0?Ft=[255,255,255,255]:typeof Lt.mean=="number"?Ft=[Lt.mean,Lt.mean,Lt.mean,Lt.mean]:(Ft=[Lt.mean[0],Lt.mean[1],Lt.mean[2],0],Lt.mean[3]!==void 0&&(Ft[3]=Lt.mean[3])),Lt===void 0||Lt.bias===void 0?Ct=[0,0,0,0]:typeof Lt.bias=="number"?Ct=[Lt.bias,Lt.bias,Lt.bias,Lt.bias]:(Ct=[Lt.bias[0],Lt.bias[1],Lt.bias[2],0],Lt.bias[3]!==void 0&&(Ct[3]=Lt.bias[3]));let Ht=$t*wt,Gt=0,jt=Ht,qt=Ht*2,Kt=-1;Tt==="RGBA"?(Gt=0,jt=Ht,qt=Ht*2,Kt=Ht*3):Tt==="RGB"?(Gt=0,jt=Ht,qt=Ht*2):Tt==="RBG"&&(Gt=0,qt=Ht,jt=Ht*2);for(let An=0;An<$t;An++)for(let Sn=0;Sn<wt;Sn++){let wn=(st.data[Gt++]-Ct[0])*Ft[0],In=(st.data[jt++]-Ct[1])*Ft[1],tr=(st.data[qt++]-Ct[2])*Ft[2],rr=Kt===-1?255:(st.data[Kt++]-Ct[3])*Ft[3];vt.fillStyle="rgba("+wn+","+In+","+tr+","+rr+")",vt.fillRect(Sn,An,1,1)}if("toDataURL"in pt)return pt.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},ua=(st,at)=>{let pt=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),vt;if(pt!=null){let wt,$t,Tt;(at==null?void 0:at.tensorLayout)!==void 0&&at.tensorLayout==="NHWC"?(wt=st.dims[2],$t=st.dims[1],Tt=st.dims[3]):(wt=st.dims[3],$t=st.dims[2],Tt=st.dims[1]);let Lt=at!==void 0&&at.format!==void 0?at.format:"RGB",Ft=at==null?void 0:at.norm,Ct,Ht;Ft===void 0||Ft.mean===void 0?Ct=[255,255,255,255]:typeof Ft.mean=="number"?Ct=[Ft.mean,Ft.mean,Ft.mean,Ft.mean]:(Ct=[Ft.mean[0],Ft.mean[1],Ft.mean[2],255],Ft.mean[3]!==void 0&&(Ct[3]=Ft.mean[3])),Ft===void 0||Ft.bias===void 0?Ht=[0,0,0,0]:typeof Ft.bias=="number"?Ht=[Ft.bias,Ft.bias,Ft.bias,Ft.bias]:(Ht=[Ft.bias[0],Ft.bias[1],Ft.bias[2],0],Ft.bias[3]!==void 0&&(Ht[3]=Ft.bias[3]));let Gt=$t*wt;if(at!==void 0&&(at.format!==void 0&&Tt===4&&at.format!=="RGBA"||Tt===3&&at.format!=="RGB"&&at.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let jt=4,qt=0,Kt=1,An=2,Sn=3,wn=0,In=Gt,tr=Gt*2,rr=-1;Lt==="RGBA"?(wn=0,In=Gt,tr=Gt*2,rr=Gt*3):Lt==="RGB"?(wn=0,In=Gt,tr=Gt*2):Lt==="RBG"&&(wn=0,tr=Gt,In=Gt*2),vt=pt.createImageData(wt,$t);for(let Hr=0;Hr<$t*wt;qt+=jt,Kt+=jt,An+=jt,Sn+=jt,Hr++)vt.data[qt]=(st.data[wn++]-Ht[0])*Ct[0],vt.data[Kt]=(st.data[In++]-Ht[1])*Ct[1],vt.data[An]=(st.data[tr++]-Ht[2])*Ct[2],vt.data[Sn]=rr===-1?255:(st.data[rr++]-Ht[3])*Ct[3]}else throw new Error("Can not access image data");return vt}}),Ri,da,ca,pa,ma,fa=j(()=>{Rn(),Ri=(st,at)=>{if(st===void 0)throw new Error("Image buffer must be defined");if(at.height===void 0||at.width===void 0)throw new Error("Image height and width must be defined");if(at.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:pt,width:vt}=at,wt=at.norm??{mean:255,bias:0},$t,Tt;typeof wt.mean=="number"?$t=[wt.mean,wt.mean,wt.mean,wt.mean]:$t=[wt.mean[0],wt.mean[1],wt.mean[2],wt.mean[3]??255],typeof wt.bias=="number"?Tt=[wt.bias,wt.bias,wt.bias,wt.bias]:Tt=[wt.bias[0],wt.bias[1],wt.bias[2],wt.bias[3]??0];let Lt=at.format!==void 0?at.format:"RGBA",Ft=at.tensorFormat!==void 0&&at.tensorFormat!==void 0?at.tensorFormat:"RGB",Ct=pt*vt,Ht=Ft==="RGBA"?new Float32Array(Ct*4):new Float32Array(Ct*3),Gt=4,jt=0,qt=1,Kt=2,An=3,Sn=0,wn=Ct,In=Ct*2,tr=-1;Lt==="RGB"&&(Gt=3,jt=0,qt=1,Kt=2,An=-1),Ft==="RGBA"?tr=Ct*3:Ft==="RBG"?(Sn=0,In=Ct,wn=Ct*2):Ft==="BGR"&&(In=0,wn=Ct,Sn=Ct*2);for(let rr=0;rr<Ct;rr++,jt+=Gt,Kt+=Gt,qt+=Gt,An+=Gt)Ht[Sn++]=(st[jt]+Tt[0])/$t[0],Ht[wn++]=(st[qt]+Tt[1])/$t[1],Ht[In++]=(st[Kt]+Tt[2])/$t[2],tr!==-1&&An!==-1&&(Ht[tr++]=(st[An]+Tt[3])/$t[3]);return Ft==="RGBA"?new ot("float32",Ht,[1,4,pt,vt]):new ot("float32",Ht,[1,3,pt,vt])},da=async(st,at)=>{let pt=typeof HTMLImageElement<"u"&&st instanceof HTMLImageElement,vt=typeof ImageData<"u"&&st instanceof ImageData,wt=typeof ImageBitmap<"u"&&st instanceof ImageBitmap,$t=typeof st=="string",Tt,Lt=at??{},Ft=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},Ct=Ht=>Ht instanceof HTMLCanvasElement||Ht instanceof OffscreenCanvas?Ht.getContext("2d"):null;if(pt){let Ht=Ft();Ht.width=st.width,Ht.height=st.height;let Gt=Ct(Ht);if(Gt!=null){let jt=st.height,qt=st.width;if(at!==void 0&&at.resizedHeight!==void 0&&at.resizedWidth!==void 0&&(jt=at.resizedHeight,qt=at.resizedWidth),at!==void 0){if(Lt=at,at.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");Lt.tensorFormat="RGBA",Lt.height=jt,Lt.width=qt}else Lt.tensorFormat="RGBA",Lt.height=jt,Lt.width=qt;Gt.drawImage(st,0,0),Tt=Gt.getImageData(0,0,qt,jt).data}else throw new Error("Can not access image data")}else if(vt){let Ht,Gt;if(at!==void 0&&at.resizedWidth!==void 0&&at.resizedHeight!==void 0?(Ht=at.resizedHeight,Gt=at.resizedWidth):(Ht=st.height,Gt=st.width),at!==void 0&&(Lt=at),Lt.format="RGBA",Lt.height=Ht,Lt.width=Gt,at!==void 0){let jt=Ft();jt.width=Gt,jt.height=Ht;let qt=Ct(jt);if(qt!=null)qt.putImageData(st,0,0),Tt=qt.getImageData(0,0,Gt,Ht).data;else throw new Error("Can not access image data")}else Tt=st.data}else if(wt){if(at===void 0)throw new Error("Please provide image config with format for Imagebitmap");let Ht=Ft();Ht.width=st.width,Ht.height=st.height;let Gt=Ct(Ht);if(Gt!=null){let jt=st.height,qt=st.width;return Gt.drawImage(st,0,0,qt,jt),Tt=Gt.getImageData(0,0,qt,jt).data,Lt.height=jt,Lt.width=qt,Ri(Tt,Lt)}else throw new Error("Can not access image data")}else{if($t)return new Promise((Ht,Gt)=>{let jt=Ft(),qt=Ct(jt);if(!st||!qt)return Gt();let Kt=new Image;Kt.crossOrigin="Anonymous",Kt.src=st,Kt.onload=()=>{jt.width=Kt.width,jt.height=Kt.height,qt.drawImage(Kt,0,0,jt.width,jt.height);let An=qt.getImageData(0,0,jt.width,jt.height);Lt.height=jt.height,Lt.width=jt.width,Ht(Ri(An.data,Lt))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(Tt!==void 0)return Ri(Tt,Lt);throw new Error("Input data provided is not supported - aborted tensor creation")},ca=(st,at)=>{let{width:pt,height:vt,download:wt,dispose:$t}=at,Tt=[1,vt,pt,4];return new ot({location:"texture",type:"float32",texture:st,dims:Tt,download:wt,dispose:$t})},pa=(st,at)=>{let{dataType:pt,dims:vt,download:wt,dispose:$t}=at;return new ot({location:"gpu-buffer",type:pt??"float32",gpuBuffer:st,dims:vt,download:wt,dispose:$t})},ma=(st,at,pt)=>new ot({location:"cpu-pinned",type:st,data:at,dims:pt??[at.length]})}),dr,Qr,ha,ga,ya=j(()=>{dr=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Qr=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),ha=!1,ga=()=>{if(!ha){ha=!0;let st=typeof BigInt64Array<"u"&&BigInt64Array.from,at=typeof BigUint64Array<"u"&&BigUint64Array.from,pt=typeof Float16Array<"u"&&Float16Array.from;st&&(dr.set("int64",BigInt64Array),Qr.set(BigInt64Array,"int64")),at&&(dr.set("uint64",BigUint64Array),Qr.set(BigUint64Array,"uint64")),pt?(dr.set("float16",Float16Array),Qr.set(Float16Array,"float16")):dr.set("float16",Uint16Array)}}}),ba,va,wa=j(()=>{Rn(),ba=st=>{let at=1;for(let pt=0;pt<st.length;pt++){let vt=st[pt];if(typeof vt!="number"||!Number.isSafeInteger(vt))throw new TypeError(`dims[${pt}] must be an integer, got: ${vt}`);if(vt<0)throw new RangeError(`dims[${pt}] must be a non-negative integer, got: ${vt}`);at*=vt}return at},va=(st,at)=>{switch(st.location){case"cpu":return new ot(st.type,st.data,at);case"cpu-pinned":return new ot({location:"cpu-pinned",data:st.data,type:st.type,dims:at});case"texture":return new ot({location:"texture",texture:st.texture,type:st.type,dims:at});case"gpu-buffer":return new ot({location:"gpu-buffer",gpuBuffer:st.gpuBuffer,type:st.type,dims:at});default:throw new Error(`tensorReshape: tensor location ${st.location} is not supported`)}}}),ot,Rn=j(()=>{la(),fa(),ya(),wa(),ot=class{constructor(st,at,pt){ga();let vt,wt;if(typeof st=="object"&&"location"in st)switch(this.dataLocation=st.location,vt=st.type,wt=st.dims,st.location){case"cpu-pinned":{let Tt=dr.get(vt);if(!Tt)throw new TypeError(`unsupported type "${vt}" to create tensor from pinned buffer`);if(!(st.data instanceof Tt))throw new TypeError(`buffer should be of type ${Tt.name}`);this.cpuData=st.data;break}case"texture":{if(vt!=="float32")throw new TypeError(`unsupported type "${vt}" to create tensor from texture`);this.gpuTextureData=st.texture,this.downloader=st.download,this.disposer=st.dispose;break}case"gpu-buffer":{if(vt!=="float32"&&vt!=="float16"&&vt!=="int32"&&vt!=="int64"&&vt!=="uint32"&&vt!=="uint8"&&vt!=="bool")throw new TypeError(`unsupported type "${vt}" to create tensor from gpu buffer`);this.gpuBufferData=st.gpuBuffer,this.downloader=st.download,this.disposer=st.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let Tt,Lt;if(typeof st=="string")if(vt=st,Lt=pt,st==="string"){if(!Array.isArray(at))throw new TypeError("A string tensor's data must be a string array.");Tt=at}else{let Ft=dr.get(st);if(Ft===void 0)throw new TypeError(`Unsupported tensor type: ${st}.`);if(Array.isArray(at)){if(st==="float16"&&Ft===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");st==="uint64"||st==="int64"?Tt=Ft.from(at,BigInt):Tt=Ft.from(at)}else if(at instanceof Ft)Tt=at;else throw new TypeError(`A ${vt} tensor's data must be type of ${Ft}`)}else if(Lt=at,Array.isArray(st)){if(st.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let Ft=typeof st[0];if(Ft==="string")vt="string",Tt=st;else if(Ft==="boolean")vt="bool",Tt=Uint8Array.from(st);else throw new TypeError(`Invalid element type of data array: ${Ft}.`)}else{let Ft=Qr.get(st.constructor);if(Ft===void 0)throw new TypeError(`Unsupported type for tensor data: ${st.constructor}.`);vt=Ft,Tt=st}if(Lt===void 0)Lt=[Tt.length];else if(!Array.isArray(Lt))throw new TypeError("A tensor's dims must be a number array");wt=Lt,this.cpuData=Tt,this.dataLocation="cpu"}let $t=ba(wt);if(this.cpuData&&$t!==this.cpuData.length)throw new Error(`Tensor's size(${$t}) does not match data length(${this.cpuData.length}).`);this.type=vt,this.dims=wt,this.size=$t}static async fromImage(st,at){return da(st,at)}static fromTexture(st,at){return ca(st,at)}static fromGpuBuffer(st,at){return pa(st,at)}static fromPinnedBuffer(st,at,pt){return ma(st,at,pt)}toDataURL(st){return sa(this,st)}toImageData(st){return ua(this,st)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(st){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let at=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=at,st&&this.disposer&&(this.disposer(),this.disposer=void 0),at}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(st){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return va(this,st)}}}),tt,zn=j(()=>{Rn(),tt=ot}),Bn,$a,yt,ut,zi=j(()=>{Pi(),Bn=(st,at)=>{(typeof gt.trace>"u"?!gt.wasm.trace:!gt.trace)||console.timeStamp(`${st}::ORT::${at}`)},$a=(st,at)=>{var wt;let pt=((wt=new Error().stack)==null?void 0:wt.split(/\r\n|\r|\n/g))||[],vt=!1;for(let $t=0;$t<pt.length;$t++){if(vt&&!pt[$t].includes("TRACE_FUNC")){let Tt=`FUNC_${st}::${pt[$t].trim().split(" ")[1]}`;at&&(Tt+=`::${at}`),Bn("CPU",Tt);return}pt[$t].includes("TRACE_FUNC")&&(vt=!0)}},yt=st=>{(typeof gt.trace>"u"?!gt.wasm.trace:!gt.trace)||$a("BEGIN",st)},ut=st=>{(typeof gt.trace>"u"?!gt.wasm.trace:!gt.trace)||$a("END",st)}}),Dn,_a=j(()=>{Pn(),zn(),zi(),Dn=class ZE{constructor(at){this.handler=at}async run(at,pt,vt){yt();let wt={},$t={};if(typeof at!="object"||at===null||at instanceof tt||Array.isArray(at))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let Tt=!0;if(typeof pt=="object"){if(pt===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(pt instanceof tt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(pt)){if(pt.length===0)throw new TypeError("'fetches' cannot be an empty array.");Tt=!1;for(let Ct of pt){if(typeof Ct!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(Ct)===-1)throw new RangeError(`'fetches' contains invalid output name: ${Ct}.`);wt[Ct]=null}if(typeof vt=="object"&&vt!==null)$t=vt;else if(typeof vt<"u")throw new TypeError("'options' must be an object.")}else{let Ct=!1,Ht=Object.getOwnPropertyNames(pt);for(let Gt of this.outputNames)if(Ht.indexOf(Gt)!==-1){let jt=pt[Gt];(jt===null||jt instanceof tt)&&(Ct=!0,Tt=!1,wt[Gt]=jt)}if(Ct){if(typeof vt=="object"&&vt!==null)$t=vt;else if(typeof vt<"u")throw new TypeError("'options' must be an object.")}else $t=pt}}else if(typeof pt<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let Ct of this.inputNames)if(typeof at[Ct]>"u")throw new Error(`input '${Ct}' is missing in 'feeds'.`);if(Tt)for(let Ct of this.outputNames)wt[Ct]=null;let Lt=await this.handler.run(at,wt,$t),Ft={};for(let Ct in Lt)if(Object.hasOwnProperty.call(Lt,Ct)){let Ht=Lt[Ct];Ht instanceof tt?Ft[Ct]=Ht:Ft[Ct]=new tt(Ht.type,Ht.data,Ht.dims)}return ut(),Ft}async release(){return this.handler.dispose()}static async create(at,pt,vt,wt){yt();let $t,Tt={};if(typeof at=="string"){if($t=at,typeof pt=="object"&&pt!==null)Tt=pt;else if(typeof pt<"u")throw new TypeError("'options' must be an object.")}else if(at instanceof Uint8Array){if($t=at,typeof pt=="object"&&pt!==null)Tt=pt;else if(typeof pt<"u")throw new TypeError("'options' must be an object.")}else if(at instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&at instanceof SharedArrayBuffer){let Ht=at,Gt=0,jt=at.byteLength;if(typeof pt=="object"&&pt!==null)Tt=pt;else if(typeof pt=="number"){if(Gt=pt,!Number.isSafeInteger(Gt))throw new RangeError("'byteOffset' must be an integer.");if(Gt<0||Gt>=Ht.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${Ht.byteLength}).`);if(jt=at.byteLength-Gt,typeof vt=="number"){if(jt=vt,!Number.isSafeInteger(jt))throw new RangeError("'byteLength' must be an integer.");if(jt<=0||Gt+jt>Ht.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${Ht.byteLength-Gt}].`);if(typeof wt=="object"&&wt!==null)Tt=wt;else if(typeof wt<"u")throw new TypeError("'options' must be an object.")}else if(typeof vt<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof pt<"u")throw new TypeError("'options' must be an object.");$t=new Uint8Array(Ht,Gt,jt)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[Lt,Ft]=await On(Tt),Ct=await Lt.createInferenceSessionHandler($t,Ft);return ut(),new ZE(Ct)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),uc,xa=j(()=>{_a(),uc=Dn}),Sa=j(()=>{}),Ca=j(()=>{}),Ia=j(()=>{}),Ta=j(()=>{}),lc,Mn,Aa=j(()=>{Pn(),zn(),lc="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",Mn=class XE{constructor(at,pt,vt){this.handler=at,this.hasOptimizerModel=pt,this.hasEvalModel=vt}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(at,pt){let vt=at.evalModel||"",wt=at.optimizerModel||"",$t=pt||{},[Tt,Lt]=await On($t);if(Tt.createTrainingSessionHandler){let Ft=await Tt.createTrainingSessionHandler(at.checkpointState,at.trainModel,vt,wt,Lt);return new XE(Ft,!!at.optimizerModel,!!at.evalModel)}else throw new Error(lc)}typeNarrowingForRunStep(at,pt,vt,wt,$t){let Tt={},Lt={};if(typeof vt!="object"||vt===null||vt instanceof tt||Array.isArray(vt))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let Ft=!0;if(typeof wt=="object"){if(wt===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(wt instanceof tt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(wt)){if(wt.length===0)throw new TypeError("'fetches' cannot be an empty array.");Ft=!1;for(let Ct of wt){if(typeof Ct!="string")throw new TypeError("'fetches' must be a string array or an object.");if(pt.indexOf(Ct)===-1)throw new RangeError(`'fetches' contains invalid output name: ${Ct}.`);Tt[Ct]=null}if(typeof $t=="object"&&$t!==null)Lt=$t;else if(typeof $t<"u")throw new TypeError("'options' must be an object.")}else{let Ct=!1,Ht=Object.getOwnPropertyNames(wt);for(let Gt of pt)if(Ht.indexOf(Gt)!==-1){let jt=wt[Gt];(jt===null||jt instanceof tt)&&(Ct=!0,Ft=!1,Tt[Gt]=jt)}if(Ct){if(typeof $t=="object"&&$t!==null)Lt=$t;else if(typeof $t<"u")throw new TypeError("'options' must be an object.")}else Lt=wt}}else if(typeof wt<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let Ct of at)if(typeof vt[Ct]>"u")throw new Error(`input '${Ct}' is missing in 'feeds'.`);if(Ft)for(let Ct of pt)Tt[Ct]=null;return[Tt,Lt]}convertHandlerReturnTypeToMapOfTensors(at){let pt={};for(let vt in at)if(Object.hasOwnProperty.call(at,vt)){let wt=at[vt];wt instanceof tt?pt[vt]=wt:pt[vt]=new tt(wt.type,wt.data,wt.dims)}return pt}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(at,pt,vt){let[wt,$t]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,at,pt,vt),Tt=await this.handler.runTrainStep(at,wt,$t);return this.convertHandlerReturnTypeToMapOfTensors(Tt)}async runOptimizerStep(at){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(at||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(at,pt,vt){if(this.hasEvalModel){let[wt,$t]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,at,pt,vt),Tt=await this.handler.runEvalStep(at,wt,$t);return this.convertHandlerReturnTypeToMapOfTensors(Tt)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(at=!0){return this.handler.getParametersSize(at)}async loadParametersBuffer(at,pt=!0){let vt=await this.getParametersSize(pt);if(at.length!==4*vt)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(at,pt)}async getContiguousParameters(at=!0){return this.handler.getContiguousParameters(at)}async release(){return this.handler.dispose()}}}),dc,Ea=j(()=>{Aa(),dc=Mn}),Bi={};kr(Bi,{InferenceSession:()=>uc,TRACE:()=>Bn,TRACE_FUNC_BEGIN:()=>yt,TRACE_FUNC_END:()=>ut,Tensor:()=>tt,TrainingSession:()=>dc,env:()=>ke,registerBackend:()=>lr});var _t=j(()=>{ra(),aa(),xa(),zn(),Sa(),Ca(),zi(),Ia(),Ta(),Ea()}),Di={};kr(Di,{createReadStream:()=>Oa,readFile:()=>cc,readFileSync:()=>pc});var cc,pc,Oa,Mi=j(()=>{cc=void 0,pc=void 0,Oa=void 0}),Ui={};kr(Ui,{join:()=>mc});var mc,Wi=j(()=>{mc=void 0}),za=Er((st,at)=>{var pt=(()=>{var wt;var vt=typeof document<"u"?(wt=document.currentScript)==null?void 0:wt.src:void 0;return typeof __filename<"u"&&(vt||(vt=__filename)),function($t={}){var Tt=$t,Lt,Ft,Ct=new Promise((ir,jr)=>{Lt=ir,Ft=jr});Tt.mountExternalData=(ir,jr)=>{(Tt.eb||(Tt.eb=new Map)).set(ir,jr)},Tt.unmountExternalData=()=>{delete Tt.eb};let Ht=()=>{let ir=(Ro,_g,d0)=>(...L0)=>{let by=Jv,ky=_g==null?void 0:_g();L0=Ro(...L0);let Oy=_g==null?void 0:_g();return ky!==Oy&&(Ro=Oy,d0(ky),_g=d0=null),Jv!=by?Go():L0},jr=Ro=>async(..._g)=>{var d0;try{if(Tt.cb)throw Error("Session already started");let L0=Tt.cb={xb:_g[0],errors:[]},by=await Ro(..._g);if(Tt.cb!==L0)throw Error("Session mismatch");(d0=Tt.kb)==null||d0.flush();let ky=L0.errors;if(0<ky.length){let Oy=await Promise.all(ky);if(Oy=Oy.filter(Uy=>Uy),0<Oy.length)throw Error(Oy.join(`
`))}return by}finally{Tt.cb=null}};Tt._OrtCreateSession=ir(Tt._OrtCreateSession,()=>Tt._OrtCreateSession,Ro=>Tt._OrtCreateSession=Ro),Tt._OrtRun=jr(ir(Tt._OrtRun,()=>Tt._OrtRun,Ro=>Tt._OrtRun=Ro)),Tt._OrtRunWithBinding=jr(ir(Tt._OrtRunWithBinding,()=>Tt._OrtRunWithBinding,Ro=>Tt._OrtRunWithBinding=Ro)),Tt._OrtBindInput=ir(Tt._OrtBindInput,()=>Tt._OrtBindInput,Ro=>Tt._OrtBindInput=Ro),Ht=void 0};Tt.jsepInit=(ir,jr)=>{if(Ht==null||Ht(),ir==="webgpu"){[Tt.kb,Tt.pb,Tt.tb,Tt.lb,Tt.sb,Tt.Ra,Tt.ub,Tt.wb,Tt.qb,Tt.rb,Tt.vb]=jr;let Ro=Tt.kb;Tt.jsepRegisterBuffer=(_g,d0,L0,by)=>Ro.registerBuffer(_g,d0,L0,by),Tt.jsepGetBuffer=_g=>Ro.getBuffer(_g),Tt.jsepCreateDownloader=(_g,d0,L0)=>Ro.createDownloader(_g,d0,L0),Tt.jsepOnReleaseSession=_g=>{Ro.onReleaseSession(_g)},Tt.jsepOnRunStart=_g=>Ro.onRunStart(_g)}};var Gt=Object.assign({},Tt),jt="./this.program",qt=(ir,jr)=>{throw jr},Kt=typeof window=="object",An=typeof importScripts=="function",Sn=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",wn="",In,tr,rr;if(Sn){var Hr=(Mi(),sr(Di)),qr=(Wi(),sr(Ui));wn=An?qr.dirname(wn)+"/":__dirname+"/",In=(ir,jr)=>(ir=Wy(ir)?new URL(ir):qr.normalize(ir),Hr.readFileSync(ir,jr?void 0:"utf8")),rr=ir=>(ir=In(ir,!0),ir.buffer||(ir=new Uint8Array(ir)),ir),tr=(ir,jr,Ro,_g=!0)=>{ir=Wy(ir)?new URL(ir):qr.normalize(ir),Hr.readFile(ir,_g?void 0:"utf8",(d0,L0)=>{d0?Ro(d0):jr(_g?L0.buffer:L0)})},!Tt.thisProgram&&1<process.argv.length&&(jt=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),qt=(ir,jr)=>{throw process.exitCode=ir,jr}}else(Kt||An)&&(An?wn=self.location.href:typeof document<"u"&&document.currentScript&&(wn=document.currentScript.src),vt&&(wn=vt),wn.startsWith("blob:")?wn="":wn=wn.substr(0,wn.replace(/[?#].*/,"").lastIndexOf("/")+1),In=ir=>{var jr=new XMLHttpRequest;return jr.open("GET",ir,!1),jr.send(null),jr.responseText},An&&(rr=ir=>{var jr=new XMLHttpRequest;return jr.open("GET",ir,!1),jr.responseType="arraybuffer",jr.send(null),new Uint8Array(jr.response)}),tr=(ir,jr,Ro)=>{var _g=new XMLHttpRequest;_g.open("GET",ir,!0),_g.responseType="arraybuffer",_g.onload=()=>{_g.status==200||_g.status==0&&_g.response?jr(_g.response):Ro()},_g.onerror=Ro,_g.send(null)});var Zr=console.log.bind(console),Bo=console.error.bind(console);Object.assign(Tt,Gt),Gt=null;var Xo,Kr=!1,ko,f0,x0,l0,T0,t0,E0,n0,m0,h0,a0;function P0(){var ir=Xo.buffer;Tt.HEAP8=f0=new Int8Array(ir),Tt.HEAP16=l0=new Int16Array(ir),Tt.HEAPU8=x0=new Uint8Array(ir),Tt.HEAPU16=T0=new Uint16Array(ir),Tt.HEAP32=t0=new Int32Array(ir),Tt.HEAPU32=E0=new Uint32Array(ir),Tt.HEAPF32=n0=new Float32Array(ir),Tt.HEAPF64=a0=new Float64Array(ir),Tt.HEAP64=m0=new BigInt64Array(ir),Tt.HEAPU64=h0=new BigUint64Array(ir)}var V0=[],B0=[],W0=[],K0=0,Ty=null;function $y(ir){throw ir="Aborted("+ir+")",Bo(ir),Kr=!0,ko=1,ir=new WebAssembly.RuntimeError(ir+". Build with -sASSERTIONS for more info."),Ft(ir),ir}var My=ir=>ir.startsWith("data:application/octet-stream;base64,"),Wy=ir=>ir.startsWith("file://"),Ey;if(Ey="ort-wasm-simd.wasm",!My(Ey)){var _0=Ey;Ey=Tt.locateFile?Tt.locateFile(_0,wn):wn+_0}function ay(ir){if(rr)return rr(ir);throw"both async and sync fetching of the wasm failed"}function J0(ir){if(Kt||An){if(typeof fetch=="function"&&!Wy(ir))return fetch(ir,{credentials:"same-origin"}).then(jr=>{if(!jr.ok)throw`failed to load wasm binary file at '${ir}'`;return jr.arrayBuffer()}).catch(()=>ay(ir));if(tr)return new Promise((jr,Ro)=>{tr(ir,_g=>jr(new Uint8Array(_g)),Ro)})}return Promise.resolve().then(()=>ay(ir))}function yy(ir,jr,Ro){return J0(ir).then(_g=>WebAssembly.instantiate(_g,jr)).then(Ro,_g=>{Bo(`failed to asynchronously prepare wasm: ${_g}`),$y(_g)})}function uy(ir,jr){var Ro=Ey;return typeof WebAssembly.instantiateStreaming!="function"||My(Ro)||Wy(Ro)||Sn||typeof fetch!="function"?yy(Ro,ir,jr):fetch(Ro,{credentials:"same-origin"}).then(_g=>WebAssembly.instantiateStreaming(_g,ir).then(jr,function(d0){return Bo(`wasm streaming compile failed: ${d0}`),Bo("falling back to ArrayBuffer instantiation"),yy(Ro,ir,jr)}))}var Dy={824920:(ir,jr,Ro,_g)=>{if(typeof Tt>"u"||!Tt.eb)return 1;if(ir=M0(ir>>>0),ir.startsWith("./")&&(ir=ir.substring(2)),ir=Tt.eb.get(ir),!ir)return 2;if(jr>>>=0,Ro>>>=0,jr+Ro>ir.byteLength)return 3;try{return x0.set(ir.subarray(jr,jr+Ro),_g>>>0>>>0),0}catch{return 4}},825421:()=>{Tt.qb()},825452:()=>{Tt.rb()},825481:()=>{Tt.vb()},825506:ir=>Tt.pb(ir),825539:ir=>Tt.tb(ir),825571:(ir,jr,Ro)=>{Tt.lb(ir,jr,Ro,!0)},825610:(ir,jr,Ro)=>{Tt.lb(ir,jr,Ro)},825643:ir=>{Tt.Ra("Abs",ir,void 0)},825694:ir=>{Tt.Ra("Neg",ir,void 0)},825745:ir=>{Tt.Ra("Floor",ir,void 0)},825798:ir=>{Tt.Ra("Ceil",ir,void 0)},825850:ir=>{Tt.Ra("Reciprocal",ir,void 0)},825908:ir=>{Tt.Ra("Sqrt",ir,void 0)},825960:ir=>{Tt.Ra("Exp",ir,void 0)},826011:ir=>{Tt.Ra("Erf",ir,void 0)},826062:ir=>{Tt.Ra("Sigmoid",ir,void 0)},826117:(ir,jr,Ro)=>{Tt.Ra("HardSigmoid",ir,{alpha:jr,beta:Ro})},826196:ir=>{Tt.Ra("Log",ir,void 0)},826247:ir=>{Tt.Ra("Sin",ir,void 0)},826298:ir=>{Tt.Ra("Cos",ir,void 0)},826349:ir=>{Tt.Ra("Tan",ir,void 0)},826400:ir=>{Tt.Ra("Asin",ir,void 0)},826452:ir=>{Tt.Ra("Acos",ir,void 0)},826504:ir=>{Tt.Ra("Atan",ir,void 0)},826556:ir=>{Tt.Ra("Sinh",ir,void 0)},826608:ir=>{Tt.Ra("Cosh",ir,void 0)},826660:ir=>{Tt.Ra("Asinh",ir,void 0)},826713:ir=>{Tt.Ra("Acosh",ir,void 0)},826766:ir=>{Tt.Ra("Atanh",ir,void 0)},826819:ir=>{Tt.Ra("Tanh",ir,void 0)},826871:ir=>{Tt.Ra("Not",ir,void 0)},826922:(ir,jr,Ro)=>{Tt.Ra("Clip",ir,{min:jr,max:Ro})},826991:ir=>{Tt.Ra("Clip",ir,void 0)},827043:(ir,jr)=>{Tt.Ra("Elu",ir,{alpha:jr})},827101:ir=>{Tt.Ra("Relu",ir,void 0)},827153:(ir,jr)=>{Tt.Ra("LeakyRelu",ir,{alpha:jr})},827217:(ir,jr)=>{Tt.Ra("ThresholdedRelu",ir,{alpha:jr})},827287:(ir,jr)=>{Tt.Ra("Cast",ir,{to:jr})},827345:ir=>{Tt.Ra("Add",ir,void 0)},827396:ir=>{Tt.Ra("Sub",ir,void 0)},827447:ir=>{Tt.Ra("Mul",ir,void 0)},827498:ir=>{Tt.Ra("Div",ir,void 0)},827549:ir=>{Tt.Ra("Pow",ir,void 0)},827600:ir=>{Tt.Ra("Equal",ir,void 0)},827653:ir=>{Tt.Ra("Greater",ir,void 0)},827708:ir=>{Tt.Ra("GreaterOrEqual",ir,void 0)},827770:ir=>{Tt.Ra("Less",ir,void 0)},827822:ir=>{Tt.Ra("LessOrEqual",ir,void 0)},827881:(ir,jr,Ro,_g,d0)=>{Tt.Ra("ReduceMean",ir,{keepDims:!!jr,noopWithEmptyAxes:!!Ro,axes:_g?Array.from(t0.subarray(_g>>>0,d0>>>0)):[]})},828040:(ir,jr,Ro,_g,d0)=>{Tt.Ra("ReduceMax",ir,{keepDims:!!jr,noopWithEmptyAxes:!!Ro,axes:_g?Array.from(t0.subarray(_g>>>0,d0>>>0)):[]})},828198:(ir,jr,Ro,_g,d0)=>{Tt.Ra("ReduceMin",ir,{keepDims:!!jr,noopWithEmptyAxes:!!Ro,axes:_g?Array.from(t0.subarray(_g>>>0,d0>>>0)):[]})},828356:(ir,jr,Ro,_g,d0)=>{Tt.Ra("ReduceProd",ir,{keepDims:!!jr,noopWithEmptyAxes:!!Ro,axes:_g?Array.from(t0.subarray(_g>>>0,d0>>>0)):[]})},828515:(ir,jr,Ro,_g,d0)=>{Tt.Ra("ReduceSum",ir,{keepDims:!!jr,noopWithEmptyAxes:!!Ro,axes:_g?Array.from(t0.subarray(_g>>>0,d0>>>0)):[]})},828673:(ir,jr,Ro,_g,d0)=>{Tt.Ra("ReduceL1",ir,{keepDims:!!jr,noopWithEmptyAxes:!!Ro,axes:_g?Array.from(t0.subarray(_g>>>0,d0>>>0)):[]})},828830:(ir,jr,Ro,_g,d0)=>{Tt.Ra("ReduceL2",ir,{keepDims:!!jr,noopWithEmptyAxes:!!Ro,axes:_g?Array.from(t0.subarray(_g>>>0,d0>>>0)):[]})},828987:(ir,jr,Ro,_g,d0)=>{Tt.Ra("ReduceLogSum",ir,{keepDims:!!jr,noopWithEmptyAxes:!!Ro,axes:_g?Array.from(t0.subarray(_g>>>0,d0>>>0)):[]})},829148:(ir,jr,Ro,_g,d0)=>{Tt.Ra("ReduceSumSquare",ir,{keepDims:!!jr,noopWithEmptyAxes:!!Ro,axes:_g?Array.from(t0.subarray(_g>>>0,d0>>>0)):[]})},829312:(ir,jr,Ro,_g,d0)=>{Tt.Ra("ReduceLogSumExp",ir,{keepDims:!!jr,noopWithEmptyAxes:!!Ro,axes:_g?Array.from(t0.subarray(_g>>>0,d0>>>0)):[]})},829476:ir=>{Tt.Ra("Where",ir,void 0)},829529:(ir,jr,Ro)=>{Tt.Ra("Transpose",ir,{perm:jr?Array.from(t0.subarray(jr>>>0,Ro>>>0)):[]})},829637:(ir,jr,Ro,_g)=>{Tt.Ra("DepthToSpace",ir,{blocksize:jr,mode:M0(Ro),format:_g?"NHWC":"NCHW"})},829770:(ir,jr,Ro,_g)=>{Tt.Ra("DepthToSpace",ir,{blocksize:jr,mode:M0(Ro),format:_g?"NHWC":"NCHW"})},829903:(ir,jr,Ro,_g,d0,L0,by,ky,Oy,Uy,hv,Hv,Q0,q0,Yy)=>{Tt.Ra("ConvTranspose",ir,{format:Oy?"NHWC":"NCHW",autoPad:jr,dilations:[Ro],group:_g,kernelShape:[d0],pads:[L0,by],strides:[ky],wIsConst:()=>!!f0[Uy>>>0],outputPadding:hv?Array.from(t0.subarray(hv>>>0,Hv>>>0)):[],outputShape:Q0?Array.from(t0.subarray(Q0>>>0,q0>>>0)):[],activation:M0(Yy)})},830304:(ir,jr,Ro,_g,d0,L0,by,ky,Oy,Uy,hv,Hv,Q0,q0)=>{Tt.Ra("ConvTranspose",ir,{format:ky?"NHWC":"NCHW",autoPad:jr,dilations:Array.from(t0.subarray(Ro>>>0,(Ro>>>0)+2>>>0)),group:_g,kernelShape:Array.from(t0.subarray(d0>>>0,(d0>>>0)+2>>>0)),pads:Array.from(t0.subarray(L0>>>0,(L0>>>0)+4>>>0)),strides:Array.from(t0.subarray(by>>>0,(by>>>0)+2>>>0)),wIsConst:()=>!!f0[Oy>>>0],outputPadding:Uy?Array.from(t0.subarray(Uy>>>0,hv>>>0)):[],outputShape:Hv?Array.from(t0.subarray(Hv>>>0,Q0>>>0)):[],activation:M0(q0)})},830869:(ir,jr,Ro,_g,d0,L0,by,ky,Oy,Uy,hv,Hv,Q0,q0,Yy)=>{Tt.Ra("ConvTranspose",ir,{format:Oy?"NHWC":"NCHW",autoPad:jr,dilations:[Ro],group:_g,kernelShape:[d0],pads:[L0,by],strides:[ky],wIsConst:()=>!!f0[Uy>>>0],outputPadding:hv?Array.from(t0.subarray(hv>>>0,Hv>>>0)):[],outputShape:Q0?Array.from(t0.subarray(Q0>>>0,q0>>>0)):[],activation:M0(Yy)})},831270:(ir,jr,Ro,_g,d0,L0,by,ky,Oy,Uy,hv,Hv,Q0,q0)=>{Tt.Ra("ConvTranspose",ir,{format:ky?"NHWC":"NCHW",autoPad:jr,dilations:Array.from(t0.subarray(Ro>>>0,(Ro>>>0)+2>>>0)),group:_g,kernelShape:Array.from(t0.subarray(d0>>>0,(d0>>>0)+2>>>0)),pads:Array.from(t0.subarray(L0>>>0,(L0>>>0)+4>>>0)),strides:Array.from(t0.subarray(by>>>0,(by>>>0)+2>>>0)),wIsConst:()=>!!f0[Oy>>>0],outputPadding:Uy?Array.from(t0.subarray(Uy>>>0,hv>>>0)):[],outputShape:Hv?Array.from(t0.subarray(Hv>>>0,Q0>>>0)):[],activation:M0(q0)})},831835:(ir,jr)=>{Tt.Ra("GlobalAveragePool",ir,{format:jr?"NHWC":"NCHW"})},831926:(ir,jr,Ro,_g,d0,L0,by,ky,Oy,Uy,hv,Hv,Q0,q0,Yy,av)=>{Tt.Ra("AveragePool",ir,{format:av?"NHWC":"NCHW",auto_pad:jr,ceil_mode:Ro,count_include_pad:_g,storage_order:d0,dilations:[L0,by],kernel_shape:[ky,Oy],pads:[Uy,hv,Hv,Q0],strides:[q0,Yy]})},832210:(ir,jr)=>{Tt.Ra("GlobalAveragePool",ir,{format:jr?"NHWC":"NCHW"})},832301:(ir,jr,Ro,_g,d0,L0,by,ky,Oy,Uy,hv,Hv,Q0,q0,Yy,av)=>{Tt.Ra("AveragePool",ir,{format:av?"NHWC":"NCHW",auto_pad:jr,ceil_mode:Ro,count_include_pad:_g,storage_order:d0,dilations:[L0,by],kernel_shape:[ky,Oy],pads:[Uy,hv,Hv,Q0],strides:[q0,Yy]})},832585:(ir,jr)=>{Tt.Ra("GlobalMaxPool",ir,{format:jr?"NHWC":"NCHW"})},832672:(ir,jr,Ro,_g,d0,L0,by,ky,Oy,Uy,hv,Hv,Q0,q0,Yy,av)=>{Tt.Ra("MaxPool",ir,{format:av?"NHWC":"NCHW",auto_pad:jr,ceil_mode:Ro,count_include_pad:_g,storage_order:d0,dilations:[L0,by],kernel_shape:[ky,Oy],pads:[Uy,hv,Hv,Q0],strides:[q0,Yy]})},832952:(ir,jr)=>{Tt.Ra("GlobalMaxPool",ir,{format:jr?"NHWC":"NCHW"})},833039:(ir,jr,Ro,_g,d0,L0,by,ky,Oy,Uy,hv,Hv,Q0,q0,Yy,av)=>{Tt.Ra("MaxPool",ir,{format:av?"NHWC":"NCHW",auto_pad:jr,ceil_mode:Ro,count_include_pad:_g,storage_order:d0,dilations:[L0,by],kernel_shape:[ky,Oy],pads:[Uy,hv,Hv,Q0],strides:[q0,Yy]})},833319:(ir,jr,Ro,_g,d0)=>{Tt.Ra("Gemm",ir,{alpha:jr,beta:Ro,transA:_g,transB:d0})},833423:ir=>{Tt.Ra("MatMul",ir,void 0)},833477:(ir,jr,Ro,_g)=>{Tt.Ra("ArgMax",ir,{keepDims:!!jr,selectLastIndex:!!Ro,axis:_g})},833585:(ir,jr,Ro,_g)=>{Tt.Ra("ArgMin",ir,{keepDims:!!jr,selectLastIndex:!!Ro,axis:_g})},833693:(ir,jr)=>{Tt.Ra("Softmax",ir,{axis:jr})},833756:(ir,jr)=>{Tt.Ra("Concat",ir,{axis:jr})},833816:(ir,jr,Ro,_g,d0)=>{Tt.Ra("Split",ir,{axis:jr,numOutputs:Ro,splitSizes:_g?Array.from(t0.subarray(_g>>>0,d0>>>0)):[]})},833956:ir=>{Tt.Ra("Expand",ir,void 0)},834010:(ir,jr)=>{Tt.Ra("Gather",ir,{axis:Number(jr)})},834081:(ir,jr)=>{Tt.Ra("GatherElements",ir,{axis:Number(jr)})},834160:(ir,jr,Ro,_g,d0,L0,by,ky,Oy,Uy,hv)=>{Tt.Ra("Resize",ir,{antialias:jr,axes:Ro?Array.from(t0.subarray(Ro>>>0,_g>>>0)):[],coordinateTransformMode:M0(d0),cubicCoeffA:L0,excludeOutside:by,extrapolationValue:ky,keepAspectRatioPolicy:M0(Oy),mode:M0(Uy),nearestMode:M0(hv)})},834506:(ir,jr,Ro,_g,d0,L0,by)=>{Tt.Ra("Slice",ir,{starts:jr?Array.from(t0.subarray(jr>>>0,Ro>>>0)):[],ends:_g?Array.from(t0.subarray(_g>>>0,d0>>>0)):[],axes:L0?Array.from(t0.subarray(L0>>>0,by>>>0)):[]})},834722:ir=>{Tt.Ra("Tile",ir,void 0)},834774:(ir,jr,Ro,_g)=>{Tt.Ra("LayerNormalization",ir,{axis:jr,epsilon:Ro,simplified:!!_g})},834885:(ir,jr,Ro)=>{Tt.Ra("InstanceNormalization",ir,{epsilon:jr,format:Ro?"NHWC":"NCHW"})},834999:(ir,jr,Ro)=>{Tt.Ra("InstanceNormalization",ir,{epsilon:jr,format:Ro?"NHWC":"NCHW"})},835113:ir=>{Tt.Ra("Range",ir,void 0)},835166:(ir,jr)=>{Tt.Ra("Einsum",ir,{equation:M0(jr)})},835247:(ir,jr,Ro,_g,d0)=>{Tt.Ra("Pad",ir,{mode:jr,value:Ro,pads:_g?Array.from(t0.subarray(_g>>>0,d0>>>0)):[]})},835374:(ir,jr,Ro,_g,d0,L0)=>{Tt.Ra("BatchNormalization",ir,{epsilon:jr,momentum:Ro,spatial:!!d0,trainingMode:!!_g,format:L0?"NHWC":"NCHW"})},835543:(ir,jr,Ro,_g,d0,L0)=>{Tt.Ra("BatchNormalization",ir,{epsilon:jr,momentum:Ro,spatial:!!d0,trainingMode:!!_g,format:L0?"NHWC":"NCHW"})},835712:(ir,jr,Ro)=>{Tt.Ra("CumSum",ir,{exclusive:Number(jr),reverse:Number(Ro)})},835809:(ir,jr,Ro,_g,d0,L0,by,ky,Oy)=>{Tt.Ra("Attention",ir,{numHeads:jr,isUnidirectional:Ro,maskFilterValue:_g,scale:d0,doRotary:L0,qkvHiddenSizes:by?Array.from(t0.subarray(Number(ky)>>>0,Number(ky)+by>>>0)):[],pastPresentShareBuffer:!!Oy})},836081:ir=>{Tt.Ra("BiasAdd",ir,void 0)},836136:ir=>{Tt.Ra("BiasSplitGelu",ir,void 0)},836197:ir=>{Tt.Ra("FastGelu",ir,void 0)},836253:(ir,jr,Ro,_g,d0,L0,by,ky,Oy,Uy,hv,Hv,Q0)=>{Tt.Ra("Conv",ir,{format:Oy?"NHWC":"NCHW",auto_pad:jr,dilations:[Ro],group:_g,kernel_shape:[d0],pads:L0?Array.from(t0.subarray(L0>>>0,by>>>0)):[],strides:[ky],w_is_const:()=>!!f0[Uy>>>0],activation:M0(hv),activation_params:Hv?Array.from(n0.subarray(Hv>>>0,Q0>>>0)):[]})},836623:(ir,jr,Ro,_g,d0,L0,by,ky,Oy,Uy,hv,Hv,Q0,q0,Yy,av)=>{Tt.Ra("Conv",ir,{format:Hv?"NHWC":"NCHW",auto_pad:jr,dilations:[Ro,_g],group:d0,kernel_shape:[L0,by],pads:ky?Array.from(t0.subarray(ky>>>0,Oy>>>0)):[],strides:[Uy,hv],w_is_const:()=>!!f0[Q0>>>0],activation:M0(q0),activation_params:Yy?Array.from(n0.subarray(Yy>>>0,av>>>0)):[]})},837014:ir=>{Tt.Ra("Gelu",ir,void 0)},837066:(ir,jr,Ro,_g,d0,L0)=>{Tt.Ra("MatMulNBits",ir,{k:jr,n:Ro,accuracyLevel:_g,bits:d0,blockSize:L0})},837193:(ir,jr,Ro,_g,d0,L0)=>{Tt.Ra("MultiHeadAttention",ir,{numHeads:jr,isUnidirectional:Ro,maskFilterValue:_g,scale:d0,doRotary:L0})},837352:(ir,jr,Ro,_g,d0)=>{Tt.Ra("RotaryEmbedding",ir,{interleaved:!!jr,numHeads:Ro,rotaryEmbeddingDim:_g,scale:d0})},837491:(ir,jr,Ro)=>{Tt.Ra("SkipLayerNormalization",ir,{epsilon:jr,simplified:!!Ro})},837593:(ir,jr,Ro)=>{Tt.Ra("SkipLayerNormalization",ir,{epsilon:jr,simplified:!!Ro})},837695:(ir,jr,Ro,_g)=>{Tt.Ra("LayerNormalization",ir,{axis:jr,epsilon:Ro,simplified:!!_g})},837806:ir=>{Tt.ub(ir)},837840:(ir,jr)=>Tt.wb(ir,jr,Tt.cb.xb,Tt.cb.errors)};function Fy(ir){this.name="ExitStatus",this.message=`Program terminated with exit(${ir})`,this.status=ir}class qy{constructor(jr){this.hb=jr-24}}var rv=0,y0=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,r0=(ir,jr,Ro)=>{jr>>>=0;var _g=jr+Ro;for(Ro=jr;ir[Ro]&&!(Ro>=_g);)++Ro;if(16<Ro-jr&&ir.buffer&&y0)return y0.decode(ir.subarray(jr,Ro));for(_g="";jr<Ro;){var d0=ir[jr++];if(d0&128){var L0=ir[jr++]&63;if((d0&224)==192)_g+=String.fromCharCode((d0&31)<<6|L0);else{var by=ir[jr++]&63;d0=(d0&240)==224?(d0&15)<<12|L0<<6|by:(d0&7)<<18|L0<<12|by<<6|ir[jr++]&63,65536>d0?_g+=String.fromCharCode(d0):(d0-=65536,_g+=String.fromCharCode(55296|d0>>10,56320|d0&1023))}}else _g+=String.fromCharCode(d0)}return _g},M0=(ir,jr)=>(ir>>>=0)?r0(x0,ir,jr):"",G0=ir=>{for(var jr=0,Ro=0;Ro<ir.length;++Ro){var _g=ir.charCodeAt(Ro);127>=_g?jr++:2047>=_g?jr+=2:55296<=_g&&57343>=_g?(jr+=4,++Ro):jr+=3}return jr},sy=(ir,jr,Ro,_g)=>{if(Ro>>>=0,!(0<_g))return 0;var d0=Ro;_g=Ro+_g-1;for(var L0=0;L0<ir.length;++L0){var by=ir.charCodeAt(L0);if(55296<=by&&57343>=by){var ky=ir.charCodeAt(++L0);by=65536+((by&1023)<<10)|ky&1023}if(127>=by){if(Ro>=_g)break;jr[Ro++>>>0]=by}else{if(2047>=by){if(Ro+1>=_g)break;jr[Ro++>>>0]=192|by>>6}else{if(65535>=by){if(Ro+2>=_g)break;jr[Ro++>>>0]=224|by>>12}else{if(Ro+3>=_g)break;jr[Ro++>>>0]=240|by>>18,jr[Ro++>>>0]=128|by>>12&63}jr[Ro++>>>0]=128|by>>6&63}jr[Ro++>>>0]=128|by&63}}return jr[Ro>>>0]=0,Ro-d0},dy,Vy=ir=>{for(var jr="";x0[ir>>>0];)jr+=dy[x0[ir++>>>0]];return jr},Xy={},hy={},Ly;function Py(ir,jr,Ro={}){var _g=jr.name;if(!ir)throw new Ly(`type "${_g}" must have a positive integer typeid pointer`);if(hy.hasOwnProperty(ir)){if(Ro.nb)return;throw new Ly(`Cannot register type '${_g}' twice`)}hy[ir]=jr,Xy.hasOwnProperty(ir)&&(jr=Xy[ir],delete Xy[ir],jr.forEach(d0=>d0()))}function Sy(ir,jr,Ro={}){if(!("argPackAdvance"in jr))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Py(ir,jr,Ro)}var Ev=(ir,jr,Ro)=>{switch(jr){case 1:return Ro?_g=>f0[_g>>>0]:_g=>x0[_g>>>0];case 2:return Ro?_g=>l0[_g>>>1>>>0]:_g=>T0[_g>>>1>>>0];case 4:return Ro?_g=>t0[_g>>>2>>>0]:_g=>E0[_g>>>2>>>0];case 8:return Ro?_g=>m0[_g>>>3]:_g=>h0[_g>>>3];default:throw new TypeError(`invalid integer width (${jr}): ${ir}`)}},Qy=[],cy=[];function C0(ir){ir>>>=0,9<ir&&--cy[ir+1]===0&&(cy[ir]=void 0,Qy.push(ir))}var U0=ir=>{if(!ir)throw new Ly("Cannot use deleted val. handle = "+ir);return cy[ir]},xy=ir=>{switch(ir){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let jr=Qy.pop()||cy.length;return cy[jr]=ir,cy[jr+1]=1,jr}};function o0(ir){return this.fromWireType(E0[ir>>>2>>>0])}var v0={name:"emscripten::val",fromWireType:ir=>{var jr=U0(ir);return C0(ir),jr},toWireType:(ir,jr)=>xy(jr),argPackAdvance:8,readValueFromPointer:o0,bb:null},i0=(ir,jr)=>{switch(jr){case 4:return function(Ro){return this.fromWireType(n0[Ro>>>2>>>0])};case 8:return function(Ro){return this.fromWireType(a0[Ro>>>3>>>0])};default:throw new TypeError(`invalid float width (${jr}): ${ir}`)}},k0=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,$0=(ir,jr)=>{for(var Ro=ir>>1,_g=Ro+jr/2;!(Ro>=_g)&&T0[Ro>>>0];)++Ro;if(Ro<<=1,32<Ro-ir&&k0)return k0.decode(x0.subarray(ir>>>0,Ro>>>0));for(Ro="",_g=0;!(_g>=jr/2);++_g){var d0=l0[ir+2*_g>>>1>>>0];if(d0==0)break;Ro+=String.fromCharCode(d0)}return Ro},ty=(ir,jr,Ro)=>{if(Ro??(Ro=2147483647),2>Ro)return 0;Ro-=2;var _g=jr;Ro=Ro<2*ir.length?Ro/2:ir.length;for(var d0=0;d0<Ro;++d0)l0[jr>>>1>>>0]=ir.charCodeAt(d0),jr+=2;return l0[jr>>>1>>>0]=0,jr-_g},my=ir=>2*ir.length,ev=(ir,jr)=>{for(var Ro=0,_g="";!(Ro>=jr/4);){var d0=t0[ir+4*Ro>>>2>>>0];if(d0==0)break;++Ro,65536<=d0?(d0-=65536,_g+=String.fromCharCode(55296|d0>>10,56320|d0&1023)):_g+=String.fromCharCode(d0)}return _g},vv=(ir,jr,Ro)=>{if(jr>>>=0,Ro??(Ro=2147483647),4>Ro)return 0;var _g=jr;Ro=_g+Ro-4;for(var d0=0;d0<ir.length;++d0){var L0=ir.charCodeAt(d0);if(55296<=L0&&57343>=L0){var by=ir.charCodeAt(++d0);L0=65536+((L0&1023)<<10)|by&1023}if(t0[jr>>>2>>>0]=L0,jr+=4,jr+4>Ro)break}return t0[jr>>>2>>>0]=0,jr-_g},Tv=ir=>{for(var jr=0,Ro=0;Ro<ir.length;++Ro){var _g=ir.charCodeAt(Ro);55296<=_g&&57343>=_g&&++Ro,jr+=4}return jr},Rv=(ir,jr)=>{var Ro=hy[ir];if(Ro===void 0)throw ir=n1(ir),Ro=Vy(ir),i1(ir),new Ly(`${jr} has unknown type ${Ro}`);return Ro},Lv=(ir,jr,Ro)=>{var _g=[];return ir=ir.toWireType(_g,Ro),_g.length&&(E0[jr>>>2>>>0]=xy(_g)),ir},Yv=ir=>{try{ir()}catch(jr){$y(jr)}},X0=ir=>{var jr;if(!Kr)try{ir();try{ko=ko=ir=ko,(jr=Tt.onExit)==null||jr.call(Tt,ir),Kr=!0,qt(ir,new Fy(ir))}catch(Ro){Ro instanceof Fy||Ro=="unwind"||qt(1,Ro)}}catch(Ro){Ro instanceof Fy||Ro=="unwind"||qt(1,Ro)}};function Pv(){var ir=zy,jr={};for(let[Ro,_g]of Object.entries(ir))jr[Ro]=typeof _g=="function"?(...d0)=>{_v.push(Ro);try{return _g(...d0)}finally{Kr||(_v.pop(),Jv&&Fv===1&&_v.length===0&&(Fv=0,Yv(m_),typeof Fibers<"u"&&Fibers.Db()))}}:_g;return jr}var Fv=0,Jv=null,g1=0,_v=[],Y1={},c_={},Qo=0,c0=null,D0=[];function Go(){return new Promise((ir,jr)=>{c0={resolve:ir,reject:jr}})}function g0(){var ir=m1(65548),jr=ir+12;E0[ir>>>2>>>0]=jr,E0[ir+4>>>2>>>0]=jr+65536,jr=_v[0];var Ro=Y1[jr];return Ro===void 0&&(Ro=Qo++,Y1[jr]=Ro,c_[Ro]=jr),t0[ir+8>>>2>>>0]=Ro,ir}function b0(ir){if(!Kr){if(Fv===0){var jr=!1,Ro=!1;ir((_g=0)=>{if(!Kr&&(g1=_g,jr=!0,Ro)){Fv=2,Yv(()=>z1(Jv)),typeof Browser<"u"&&Browser.ib.mb&&Browser.ib.resume(),_g=!1;try{var d0=(0,zy[c_[t0[Jv+8>>>2>>>0]]])()}catch(ky){d0=ky,_g=!0}var L0=!1;if(!Jv){var by=c0;by&&(c0=null,(_g?by.reject:by.resolve)(d0),L0=!0)}if(_g&&!L0)throw d0}}),Ro=!0,jr||(Fv=1,Jv=g0(),typeof Browser<"u"&&Browser.ib.mb&&Browser.ib.pause(),Yv(()=>x1(Jv)))}else Fv===2?(Fv=0,Yv(j1),i1(Jv),Jv=null,D0.forEach(X0)):$y(`invalid state: ${Fv}`);return g1}}function I0(ir){return b0(jr=>{ir().then(jr)})}var A0=[],Y0={},ey=ir=>{var jr=Y0[ir];return jr===void 0?Vy(ir):jr},ny=()=>typeof globalThis=="object"?globalThis:Function("return this")(),ry=ir=>{var jr=A0.length;return A0.push(ir),jr},Ky=(ir,jr)=>{for(var Ro=Array(ir),_g=0;_g<ir;++_g)Ro[_g]=Rv(E0[jr+4*_g>>>2>>>0],"parameter "+_g);return Ro},wy=(ir,jr)=>Object.defineProperty(jr,"name",{value:ir});function Ry(ir){var jr=Function;if(!(jr instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof jr} which is not a function`);var Ro=wy(jr.name||"unknownFunctionName",function(){});return Ro.prototype=jr.prototype,Ro=new Ro,ir=jr.apply(Ro,ir),ir instanceof Object?ir:Ro}var Hy=ir=>ir%4===0&&(ir%100!==0||ir%400===0),uv=[0,31,60,91,121,152,182,213,244,274,305,335],dv=[0,31,59,90,120,151,181,212,243,273,304,334],pv=[],Zy=(ir,jr)=>{pv.length=0;for(var Ro;Ro=x0[ir++>>>0];){var _g=Ro!=105;_g&=Ro!=112,jr+=_g&&jr%8?4:0,pv.push(Ro==112?E0[jr>>>2>>>0]:Ro==106?m0[jr>>>3]:Ro==105?t0[jr>>>2>>>0]:a0[jr>>>3>>>0]),jr+=_g?8:4}return pv},By={},bv=()=>{if(!fv){var ir={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:jt||"./this.program"},jr;for(jr in By)By[jr]===void 0?delete ir[jr]:ir[jr]=By[jr];var Ro=[];for(jr in ir)Ro.push(`${jr}=${ir[jr]}`);fv=Ro}return fv},fv,xv=[null,[],[]],t1=[31,29,31,30,31,30,31,31,30,31,30,31],u1=[31,28,31,30,31,30,31,31,30,31,30,31];function c1(ir){var jr=Array(G0(ir)+1);return sy(ir,jr,0,jr.length),jr}function Gv(ir,jr,Ro,_g){function d0(q0,Yy,av){for(q0=typeof q0=="number"?q0.toString():q0||"";q0.length<Yy;)q0=av[0]+q0;return q0}function L0(q0,Yy){return d0(q0,Yy,"0")}function by(q0,Yy){function av(M1){return 0>M1?-1:0<M1?1:0}var Zv;return(Zv=av(q0.getFullYear()-Yy.getFullYear()))===0&&(Zv=av(q0.getMonth()-Yy.getMonth()))===0&&(Zv=av(q0.getDate()-Yy.getDate())),Zv}function ky(q0){switch(q0.getDay()){case 0:return new Date(q0.getFullYear()-1,11,29);case 1:return q0;case 2:return new Date(q0.getFullYear(),0,3);case 3:return new Date(q0.getFullYear(),0,2);case 4:return new Date(q0.getFullYear(),0,1);case 5:return new Date(q0.getFullYear()-1,11,31);case 6:return new Date(q0.getFullYear()-1,11,30)}}function Oy(q0){var Yy=q0.$a;for(q0=new Date(new Date(q0.ab+1900,0,1).getTime());0<Yy;){var av=q0.getMonth(),Zv=(Hy(q0.getFullYear())?t1:u1)[av];if(Yy>Zv-q0.getDate())Yy-=Zv-q0.getDate()+1,q0.setDate(1),11>av?q0.setMonth(av+1):(q0.setMonth(0),q0.setFullYear(q0.getFullYear()+1));else{q0.setDate(q0.getDate()+Yy);break}}return av=new Date(q0.getFullYear()+1,0,4),Yy=ky(new Date(q0.getFullYear(),0,4)),av=ky(av),0>=by(Yy,q0)?0>=by(av,q0)?q0.getFullYear()+1:q0.getFullYear():q0.getFullYear()-1}ir>>>=0,jr>>>=0,Ro>>>=0,_g>>>=0;var Uy=E0[_g+40>>>2>>>0];_g={Ab:t0[_g>>>2>>>0],zb:t0[_g+4>>>2>>>0],fb:t0[_g+8>>>2>>>0],jb:t0[_g+12>>>2>>>0],gb:t0[_g+16>>>2>>>0],ab:t0[_g+20>>>2>>>0],Va:t0[_g+24>>>2>>>0],$a:t0[_g+28>>>2>>>0],Cb:t0[_g+32>>>2>>>0],yb:t0[_g+36>>>2>>>0],Bb:Uy?M0(Uy):""},Ro=M0(Ro),Uy={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var hv in Uy)Ro=Ro.replace(new RegExp(hv,"g"),Uy[hv]);var Hv="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Q0="January February March April May June July August September October November December".split(" ");Uy={"%a":q0=>Hv[q0.Va].substring(0,3),"%A":q0=>Hv[q0.Va],"%b":q0=>Q0[q0.gb].substring(0,3),"%B":q0=>Q0[q0.gb],"%C":q0=>L0((q0.ab+1900)/100|0,2),"%d":q0=>L0(q0.jb,2),"%e":q0=>d0(q0.jb,2," "),"%g":q0=>Oy(q0).toString().substring(2),"%G":Oy,"%H":q0=>L0(q0.fb,2),"%I":q0=>(q0=q0.fb,q0==0?q0=12:12<q0&&(q0-=12),L0(q0,2)),"%j":q0=>{for(var Yy=0,av=0;av<=q0.gb-1;Yy+=(Hy(q0.ab+1900)?t1:u1)[av++]);return L0(q0.jb+Yy,3)},"%m":q0=>L0(q0.gb+1,2),"%M":q0=>L0(q0.zb,2),"%n":()=>`
`,"%p":q0=>0<=q0.fb&&12>q0.fb?"AM":"PM","%S":q0=>L0(q0.Ab,2),"%t":()=>"	","%u":q0=>q0.Va||7,"%U":q0=>L0(Math.floor((q0.$a+7-q0.Va)/7),2),"%V":q0=>{var Yy=Math.floor((q0.$a+7-(q0.Va+6)%7)/7);if(2>=(q0.Va+371-q0.$a-2)%7&&Yy++,Yy)Yy==53&&(av=(q0.Va+371-q0.$a)%7,av==4||av==3&&Hy(q0.ab)||(Yy=1));else{Yy=52;var av=(q0.Va+7-q0.$a-1)%7;(av==4||av==5&&Hy(q0.ab%400-1))&&Yy++}return L0(Yy,2)},"%w":q0=>q0.Va,"%W":q0=>L0(Math.floor((q0.$a+7-(q0.Va+6)%7)/7),2),"%y":q0=>(q0.ab+1900).toString().substring(2),"%Y":q0=>q0.ab+1900,"%z":q0=>{q0=q0.yb;var Yy=0<=q0;return q0=Math.abs(q0)/60,(Yy?"+":"-")+("0000"+(q0/60*100+q0%60)).slice(-4)},"%Z":q0=>q0.Bb,"%%":()=>"%"},Ro=Ro.replace(/%%/g,"\0\0");for(hv in Uy)Ro.includes(hv)&&(Ro=Ro.replace(new RegExp(hv,"g"),Uy[hv](_g)));return Ro=Ro.replace(/\0\0/g,"%"),hv=c1(Ro),hv.length>jr?0:(f0.set(hv,ir>>>0),hv.length-1)}for(var Ov=Array(256),jy=0;256>jy;++jy)Ov[jy]=String.fromCharCode(jy);dy=Ov,Ly=Tt.BindingError=class extends Error{constructor(ir){super(ir),this.name="BindingError"}},Tt.InternalError=class extends Error{constructor(ir){super(ir),this.name="InternalError"}},cy.push(0,1,void 0,1,null,1,!0,1,!1,1),Tt.count_emval_handles=()=>cy.length/2-5-Qy.length;var Av={ia:function(ir,jr,Ro){return I0(async()=>{await Tt.sb(ir,jr,Ro)})},a:function(ir,jr,Ro){ir>>>=0;var _g=new qy(ir);throw E0[_g.hb+16>>>2>>>0]=0,E0[_g.hb+4>>>2>>>0]=jr>>>0,E0[_g.hb+8>>>2>>>0]=Ro>>>0,rv=ir,rv},y:function(){return 0},ea:function(){},R:function(){},T:function(){},ga:function(){return 0},ca:function(){},Z:function(){},ba:function(){},G:function(){},S:function(){},P:function(){},da:function(){},Q:function(){},C:function(ir,jr,Ro){jr=Vy(jr>>>0),Sy(ir>>>0,{name:jr,fromWireType:_g=>_g,toWireType:function(_g,d0){if(typeof d0!="bigint"&&typeof d0!="number")throw d0===null?d0="null":(_g=typeof d0,d0=_g==="object"||_g==="array"||_g==="function"?d0.toString():""+d0),new TypeError(`Cannot convert "${d0}" to ${this.name}`);return typeof d0=="number"&&(d0=BigInt(d0)),d0},argPackAdvance:8,readValueFromPointer:Ev(jr,Ro>>>0,jr.indexOf("u")==-1),bb:null})},K:function(ir,jr,Ro,_g){jr=Vy(jr>>>0),Sy(ir>>>0,{name:jr,fromWireType:function(d0){return!!d0},toWireType:function(d0,L0){return L0?Ro:_g},argPackAdvance:8,readValueFromPointer:function(d0){return this.fromWireType(x0[d0>>>0])},bb:null})},J:function(ir){return Sy(ir>>>0,v0)},B:function(ir,jr,Ro){jr=Vy(jr>>>0),Sy(ir>>>0,{name:jr,fromWireType:_g=>_g,toWireType:(_g,d0)=>d0,argPackAdvance:8,readValueFromPointer:i0(jr,Ro>>>0),bb:null})},s:function(ir,jr,Ro,_g,d0){if(ir>>>=0,Ro>>>=0,jr=Vy(jr>>>0),d0===-1&&(d0=4294967295),d0=ky=>ky,_g===0){var L0=32-8*Ro;d0=ky=>ky<<L0>>>L0}var by=jr.includes("unsigned")?function(ky,Oy){return Oy>>>0}:function(ky,Oy){return Oy};Sy(ir,{name:jr,fromWireType:d0,toWireType:by,argPackAdvance:8,readValueFromPointer:Ev(jr,Ro,_g!==0),bb:null})},o:function(ir,jr,Ro){function _g(L0){return new d0(f0.buffer,E0[L0+4>>>2>>>0],E0[L0>>>2>>>0])}var d0=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][jr];Ro=Vy(Ro>>>0),Sy(ir>>>0,{name:Ro,fromWireType:_g,argPackAdvance:8,readValueFromPointer:_g},{nb:!0})},D:function(ir,jr){jr=Vy(jr>>>0);var Ro=jr==="std::string";Sy(ir>>>0,{name:jr,fromWireType:function(_g){var d0=E0[_g>>>2>>>0],L0=_g+4;if(Ro)for(var by=L0,ky=0;ky<=d0;++ky){var Oy=L0+ky;if(ky==d0||x0[Oy>>>0]==0){if(by=M0(by,Oy-by),Uy===void 0)var Uy=by;else Uy+="\0",Uy+=by;by=Oy+1}}else{for(Uy=Array(d0),ky=0;ky<d0;++ky)Uy[ky]=String.fromCharCode(x0[L0+ky>>>0]);Uy=Uy.join("")}return i1(_g),Uy},toWireType:function(_g,d0){d0 instanceof ArrayBuffer&&(d0=new Uint8Array(d0));var L0=typeof d0=="string";if(!(L0||d0 instanceof Uint8Array||d0 instanceof Uint8ClampedArray||d0 instanceof Int8Array))throw new Ly("Cannot pass non-string to std::string");var by=Ro&&L0?G0(d0):d0.length,ky=m1(4+by+1),Oy=ky+4;if(E0[ky>>>2>>>0]=by,Ro&&L0)sy(d0,x0,Oy,by+1);else if(L0)for(L0=0;L0<by;++L0){var Uy=d0.charCodeAt(L0);if(255<Uy)throw i1(Oy),new Ly("String has UTF-16 code units that do not fit in 8 bits");x0[Oy+L0>>>0]=Uy}else for(L0=0;L0<by;++L0)x0[Oy+L0>>>0]=d0[L0];return _g!==null&&_g.push(i1,ky),ky},argPackAdvance:8,readValueFromPointer:o0,bb(_g){i1(_g)}})},x:function(ir,jr,Ro){if(jr>>>=0,Ro>>>=0,Ro=Vy(Ro),jr===2)var _g=$0,d0=ty,L0=my,by=ky=>T0[ky>>>1>>>0];else jr===4&&(_g=ev,d0=vv,L0=Tv,by=ky=>E0[ky>>>2>>>0]);Sy(ir>>>0,{name:Ro,fromWireType:ky=>{for(var Oy=E0[ky>>>2>>>0],Uy,hv=ky+4,Hv=0;Hv<=Oy;++Hv){var Q0=ky+4+Hv*jr;(Hv==Oy||by(Q0)==0)&&(hv=_g(hv,Q0-hv),Uy===void 0?Uy=hv:(Uy+="\0",Uy+=hv),hv=Q0+jr)}return i1(ky),Uy},toWireType:(ky,Oy)=>{if(typeof Oy!="string")throw new Ly(`Cannot pass non-string to C++ string type ${Ro}`);var Uy=L0(Oy),hv=m1(4+Uy+jr);return E0[hv>>>2>>>0]=Uy/jr,d0(Oy,hv+4,Uy+jr),ky!==null&&ky.push(i1,hv),hv},argPackAdvance:8,readValueFromPointer:o0,bb(ky){i1(ky)}})},L:function(ir,jr){jr=Vy(jr>>>0),Sy(ir>>>0,{ob:!0,name:jr,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},ha:()=>1,u:function(ir,jr,Ro){return jr>>>=0,Ro>>>=0,ir=U0(ir>>>0),jr=Rv(jr,"emval::as"),Lv(jr,Ro,ir)},w:function(ir){return ir>>>=0,I0(()=>(ir=U0(ir),ir.then(xy)))},n:function(ir,jr,Ro,_g){return Ro>>>=0,_g>>>=0,ir=A0[ir>>>0],jr=U0(jr>>>0),ir(null,jr,Ro,_g)},j:function(ir,jr,Ro,_g,d0){return Ro>>>=0,_g>>>=0,d0>>>=0,ir=A0[ir>>>0],jr=U0(jr>>>0),Ro=ey(Ro),ir(jr,jr[Ro],_g,d0)},b:C0,A:function(ir,jr){return jr>>>=0,ir=U0(ir>>>0),jr=U0(jr),ir==jr},m:function(ir){return ir>>>=0,ir===0?xy(ny()):(ir=ey(ir),xy(ny()[ir]))},i:function(ir,jr,Ro){jr=Ky(ir,jr>>>0);var _g=jr.shift();ir--;var d0=`return function (obj, func, destructorsRef, args) {
`,L0=0,by=[];Ro===0&&by.push("obj");for(var ky=["retType"],Oy=[_g],Uy=0;Uy<ir;++Uy)by.push("arg"+Uy),ky.push("argType"+Uy),Oy.push(jr[Uy]),d0+=`  var arg${Uy} = argType${Uy}.readValueFromPointer(args${L0?"+"+L0:""});
`,L0+=jr[Uy].argPackAdvance;return d0+=`  var rv = ${Ro===1?"new func":"func.call"}(${by.join(", ")});
`,_g.ob||(ky.push("emval_returnValue"),Oy.push(Lv),d0+=`  return emval_returnValue(retType, destructorsRef, rv);
`),ky.push(d0+`};
`),ir=Ry(ky)(...Oy),Ro=`methodCaller<(${jr.map(hv=>hv.name).join(", ")}) => ${_g.name}>`,ry(wy(Ro,ir))},r:function(ir,jr){return jr>>>=0,ir=U0(ir>>>0),jr=U0(jr),xy(ir[jr])},e:function(ir){ir>>>=0,9<ir&&(cy[ir+1]+=1)},t:function(){return xy([])},l:function(ir){ir=U0(ir>>>0);for(var jr=Array(ir.length),Ro=0;Ro<ir.length;Ro++)jr[Ro]=ir[Ro];return xy(jr)},f:function(ir){return xy(ey(ir>>>0))},k:function(){return xy({})},h:function(ir){ir>>>=0;for(var jr=U0(ir);jr.length;){var Ro=jr.pop();jr.pop()(Ro)}C0(ir)},g:function(ir,jr,Ro){jr>>>=0,Ro>>>=0,ir=U0(ir>>>0),jr=U0(jr),Ro=U0(Ro),ir[jr]=Ro},c:function(ir,jr){return jr>>>=0,ir=Rv(ir>>>0,"_emval_take_value"),ir=ir.readValueFromPointer(jr),xy(ir)},W:function(ir,jr){ir=-9007199254740992>ir||9007199254740992<ir?NaN:Number(ir),jr>>>=0,ir=new Date(1e3*ir),t0[jr>>>2>>>0]=ir.getUTCSeconds(),t0[jr+4>>>2>>>0]=ir.getUTCMinutes(),t0[jr+8>>>2>>>0]=ir.getUTCHours(),t0[jr+12>>>2>>>0]=ir.getUTCDate(),t0[jr+16>>>2>>>0]=ir.getUTCMonth(),t0[jr+20>>>2>>>0]=ir.getUTCFullYear()-1900,t0[jr+24>>>2>>>0]=ir.getUTCDay(),t0[jr+28>>>2>>>0]=(ir.getTime()-Date.UTC(ir.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},X:function(ir,jr){ir=-9007199254740992>ir||9007199254740992<ir?NaN:Number(ir),jr>>>=0,ir=new Date(1e3*ir),t0[jr>>>2>>>0]=ir.getSeconds(),t0[jr+4>>>2>>>0]=ir.getMinutes(),t0[jr+8>>>2>>>0]=ir.getHours(),t0[jr+12>>>2>>>0]=ir.getDate(),t0[jr+16>>>2>>>0]=ir.getMonth(),t0[jr+20>>>2>>>0]=ir.getFullYear()-1900,t0[jr+24>>>2>>>0]=ir.getDay(),t0[jr+28>>>2>>>0]=(Hy(ir.getFullYear())?uv:dv)[ir.getMonth()]+ir.getDate()-1|0,t0[jr+36>>>2>>>0]=-(60*ir.getTimezoneOffset());var Ro=new Date(ir.getFullYear(),6,1).getTimezoneOffset(),_g=new Date(ir.getFullYear(),0,1).getTimezoneOffset();t0[jr+32>>>2>>>0]=(Ro!=_g&&ir.getTimezoneOffset()==Math.min(_g,Ro))|0},Y:function(ir){ir>>>=0;var jr=new Date(t0[ir+20>>>2>>>0]+1900,t0[ir+16>>>2>>>0],t0[ir+12>>>2>>>0],t0[ir+8>>>2>>>0],t0[ir+4>>>2>>>0],t0[ir>>>2>>>0],0),Ro=t0[ir+32>>>2>>>0],_g=jr.getTimezoneOffset(),d0=new Date(jr.getFullYear(),6,1).getTimezoneOffset(),L0=new Date(jr.getFullYear(),0,1).getTimezoneOffset(),by=Math.min(L0,d0);return 0>Ro?t0[ir+32>>>2>>>0]=+(d0!=L0&&by==_g):0<Ro!=(by==_g)&&(d0=Math.max(L0,d0),jr.setTime(jr.getTime()+6e4*((0<Ro?by:d0)-_g))),t0[ir+24>>>2>>>0]=jr.getDay(),t0[ir+28>>>2>>>0]=(Hy(jr.getFullYear())?uv:dv)[jr.getMonth()]+jr.getDate()-1|0,t0[ir>>>2>>>0]=jr.getSeconds(),t0[ir+4>>>2>>>0]=jr.getMinutes(),t0[ir+8>>>2>>>0]=jr.getHours(),t0[ir+12>>>2>>>0]=jr.getDate(),t0[ir+16>>>2>>>0]=jr.getMonth(),t0[ir+20>>>2>>>0]=jr.getYear(),ir=jr.getTime(),BigInt(isNaN(ir)?-1:ir/1e3)},U:function(){return-52},V:function(){},N:function(ir,jr,Ro,_g){Ro>>>=0,_g>>>=0;var d0=new Date().getFullYear(),L0=new Date(d0,0,1),by=new Date(d0,6,1);d0=L0.getTimezoneOffset();var ky=by.getTimezoneOffset();E0[ir>>>0>>>2>>>0]=60*Math.max(d0,ky),t0[jr>>>0>>>2>>>0]=+(d0!=ky),ir=Oy=>Oy.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],L0=ir(L0),by=ir(by),ky<d0?(sy(L0,x0,Ro,17),sy(by,x0,_g,17)):(sy(L0,x0,_g,17),sy(by,x0,Ro,17))},v:()=>{$y("")},d:function(ir,jr,Ro){return ir>>>=0,jr=Zy(jr>>>0,Ro>>>0),Dy[ir](...jr)},I:function(ir,jr,Ro){return ir>>>=0,jr=Zy(jr>>>0,Ro>>>0),Dy[ir](...jr)},H:()=>Date.now(),O:function(){return 4294901760},q:()=>performance.now(),M:function(ir){ir>>>=0;var jr=x0.length;if(4294901760<ir)return!1;for(var Ro=1;4>=Ro;Ro*=2){var _g=jr*(1+.2/Ro);_g=Math.min(_g,ir+100663296);var d0=Math;_g=Math.max(ir,_g);e:{d0=(d0.min.call(d0,4294901760,_g+(65536-_g%65536)%65536)-Xo.buffer.byteLength+65535)/65536;try{Xo.grow(d0),P0();var L0=1;break e}catch{}L0=void 0}if(L0)return!0}return!1},$:function(ir,jr){ir>>>=0,jr>>>=0;var Ro=0;return bv().forEach((_g,d0)=>{var L0=jr+Ro;for(d0=E0[ir+4*d0>>>2>>>0]=L0,L0=0;L0<_g.length;++L0)f0[d0++>>>0]=_g.charCodeAt(L0);f0[d0>>>0]=0,Ro+=_g.length+1}),0},aa:function(ir,jr){ir>>>=0,jr>>>=0;var Ro=bv();E0[ir>>>2>>>0]=Ro.length;var _g=0;return Ro.forEach(d0=>_g+=d0.length+1),E0[jr>>>2>>>0]=_g,0},z:()=>52,F:function(){return 52},_:function(){return 70},E:function(ir,jr,Ro,_g){jr>>>=0,Ro>>>=0,_g>>>=0;for(var d0=0,L0=0;L0<Ro;L0++){var by=E0[jr>>>2>>>0],ky=E0[jr+4>>>2>>>0];jr+=8;for(var Oy=0;Oy<ky;Oy++){var Uy=x0[by+Oy>>>0],hv=xv[ir];Uy===0||Uy===10?((ir===1?Zr:Bo)(r0(hv,0)),hv.length=0):hv.push(Uy)}d0+=ky}return E0[_g>>>2>>>0]=d0,0},fa:Gv,p:function(ir,jr,Ro,_g){return Gv(ir>>>0,jr>>>0,Ro>>>0,_g>>>0)}},zy=function(){function ir(Ro){return zy=Ro.exports,zy=Pv(),zy=g_(),Xo=zy.ja,P0(),B0.unshift(zy.ka),K0--,K0==0&&Ty&&(Ro=Ty,Ty=null,Ro()),zy}var jr={a:Av};if(K0++,Tt.instantiateWasm)try{return Tt.instantiateWasm(jr,ir)}catch(Ro){Bo(`Module.instantiateWasm callback failed with error: ${Ro}`),Ft(Ro)}return uy(jr,function(Ro){ir(Ro.instance)}).catch(Ft),{}}(),n1=ir=>(n1=zy.la)(ir);Tt._OrtInit=(ir,jr)=>(Tt._OrtInit=zy.ma)(ir,jr),Tt._OrtGetLastError=(ir,jr)=>(Tt._OrtGetLastError=zy.na)(ir,jr),Tt._OrtCreateSessionOptions=(ir,jr,Ro,_g,d0,L0,by,ky,Oy,Uy)=>(Tt._OrtCreateSessionOptions=zy.oa)(ir,jr,Ro,_g,d0,L0,by,ky,Oy,Uy),Tt._OrtAppendExecutionProvider=(ir,jr)=>(Tt._OrtAppendExecutionProvider=zy.pa)(ir,jr),Tt._OrtAddFreeDimensionOverride=(ir,jr,Ro)=>(Tt._OrtAddFreeDimensionOverride=zy.qa)(ir,jr,Ro),Tt._OrtAddSessionConfigEntry=(ir,jr,Ro)=>(Tt._OrtAddSessionConfigEntry=zy.ra)(ir,jr,Ro),Tt._OrtReleaseSessionOptions=ir=>(Tt._OrtReleaseSessionOptions=zy.sa)(ir),Tt._OrtCreateSession=(ir,jr,Ro)=>(Tt._OrtCreateSession=zy.ta)(ir,jr,Ro),Tt._OrtReleaseSession=ir=>(Tt._OrtReleaseSession=zy.ua)(ir),Tt._OrtGetInputOutputCount=(ir,jr,Ro)=>(Tt._OrtGetInputOutputCount=zy.va)(ir,jr,Ro),Tt._OrtGetInputName=(ir,jr)=>(Tt._OrtGetInputName=zy.wa)(ir,jr),Tt._OrtGetOutputName=(ir,jr)=>(Tt._OrtGetOutputName=zy.xa)(ir,jr),Tt._OrtFree=ir=>(Tt._OrtFree=zy.ya)(ir),Tt._OrtCreateTensor=(ir,jr,Ro,_g,d0,L0)=>(Tt._OrtCreateTensor=zy.za)(ir,jr,Ro,_g,d0,L0),Tt._OrtGetTensorData=(ir,jr,Ro,_g,d0)=>(Tt._OrtGetTensorData=zy.Aa)(ir,jr,Ro,_g,d0),Tt._OrtReleaseTensor=ir=>(Tt._OrtReleaseTensor=zy.Ba)(ir),Tt._OrtCreateRunOptions=(ir,jr,Ro,_g)=>(Tt._OrtCreateRunOptions=zy.Ca)(ir,jr,Ro,_g),Tt._OrtAddRunConfigEntry=(ir,jr,Ro)=>(Tt._OrtAddRunConfigEntry=zy.Da)(ir,jr,Ro),Tt._OrtReleaseRunOptions=ir=>(Tt._OrtReleaseRunOptions=zy.Ea)(ir),Tt._OrtCreateBinding=ir=>(Tt._OrtCreateBinding=zy.Fa)(ir),Tt._OrtBindInput=(ir,jr,Ro)=>(Tt._OrtBindInput=zy.Ga)(ir,jr,Ro),Tt._OrtBindOutput=(ir,jr,Ro,_g)=>(Tt._OrtBindOutput=zy.Ha)(ir,jr,Ro,_g),Tt._OrtClearBoundOutputs=ir=>(Tt._OrtClearBoundOutputs=zy.Ia)(ir),Tt._OrtReleaseBinding=ir=>(Tt._OrtReleaseBinding=zy.Ja)(ir),Tt._OrtRunWithBinding=(ir,jr,Ro,_g,d0)=>(Tt._OrtRunWithBinding=zy.Ka)(ir,jr,Ro,_g,d0),Tt._OrtRun=(ir,jr,Ro,_g,d0,L0,by,ky)=>(Tt._OrtRun=zy.La)(ir,jr,Ro,_g,d0,L0,by,ky),Tt._OrtEndProfiling=ir=>(Tt._OrtEndProfiling=zy.Ma)(ir),Tt._JsepOutput=(ir,jr,Ro)=>(Tt._JsepOutput=zy.Na)(ir,jr,Ro),Tt._JsepGetNodeName=ir=>(Tt._JsepGetNodeName=zy.Oa)(ir);var m1=Tt._malloc=ir=>(m1=Tt._malloc=zy.Pa)(ir),i1=Tt._free=ir=>(i1=Tt._free=zy.Qa)(ir),S1=ir=>(S1=zy.Sa)(ir),J1=ir=>(J1=zy.Ta)(ir),d_=()=>(d_=zy.Ua)(),x1=ir=>(x1=zy.Wa)(ir),m_=()=>(m_=zy.Xa)(),z1=ir=>(z1=zy.Ya)(ir),j1=()=>(j1=zy.Za)();Tt.___start_em_js=837952,Tt.___stop_em_js=838113;function g_(){var ir=zy;ir=Object.assign({},ir);var jr=Ro=>_g=>Ro(_g)>>>0;return ir.la=jr(ir.la),ir.Pa=jr(ir.Pa),ir.Ta=jr(ir.Ta),ir.Ua=(Ro=>()=>Ro()>>>0)(ir.Ua),ir}Tt.stackSave=()=>d_(),Tt.stackRestore=ir=>S1(ir),Tt.stackAlloc=ir=>J1(ir),Tt.UTF8ToString=M0,Tt.stringToUTF8=(ir,jr,Ro)=>sy(ir,x0,jr,Ro),Tt.lengthBytesUTF8=G0;var q1;Ty=function ir(){q1||No(),q1||(Ty=ir)};function No(){if(!(0<K0)){if(Tt.preRun)for(typeof Tt.preRun=="function"&&(Tt.preRun=[Tt.preRun]);Tt.preRun.length;){var ir=Tt.preRun.shift();V0.unshift(ir)}for(;0<V0.length;)V0.shift()(Tt);if(!(0<K0||q1||(q1=!0,Tt.calledRun=!0,Kr))){for(;0<B0.length;)B0.shift()(Tt);for(Lt(Tt);0<W0.length;)W0.shift()(Tt)}}}return No(),Ct}})();typeof st=="object"&&typeof at=="object"?at.exports=pt:typeof define=="function"&&define.amd&&define([],()=>pt)}),Ba=Er(()=>{}),Da=Er(()=>{}),Ma={};kr(Ma,{cpus:()=>fc});var fc,Ua=j(()=>{fc=void 0}),Va=Er((st,at)=>{var pt=(()=>{var wt;var vt=typeof document<"u"?(wt=document.currentScript)==null?void 0:wt.src:void 0;return typeof __filename<"u"&&(vt||(vt=__filename)),function($t={}){function Tt(){return a0.buffer!=W0.buffer&&yy(),W0}function Lt(){return a0.buffer!=W0.buffer&&yy(),K0}function Ft(){return a0.buffer!=W0.buffer&&yy(),Ty}function Ct(){return a0.buffer!=W0.buffer&&yy(),$y}function Ht(){return a0.buffer!=W0.buffer&&yy(),My}function Gt(){return a0.buffer!=W0.buffer&&yy(),Wy}function jt(){return a0.buffer!=W0.buffer&&yy(),Ey}function qt(){return a0.buffer!=W0.buffer&&yy(),J0}var Kt=$t,An,Sn,wn=new Promise((Ir,Yr)=>{An=Ir,Sn=Yr});Kt.mountExternalData=(Ir,Yr)=>{(Kt.Db||(Kt.Db=new Map)).set(Ir,Yr)},Kt.unmountExternalData=()=>{delete Kt.Db};let In=()=>{let Ir=(zo,s0,w0)=>(...O0)=>{let fy=j1,Iy=s0==null?void 0:s0();O0=zo(...O0);let sv=s0==null?void 0:s0();return Iy!==sv&&(zo=sv,w0(Iy),s0=w0=null),j1!=fy?d0():O0},Yr=zo=>async(...s0)=>{var w0;try{if(Kt.Cb)throw Error("Session already started");let O0=Kt.Cb={ec:s0[0],errors:[]},fy=await zo(...s0);if(Kt.Cb!==O0)throw Error("Session mismatch");(w0=Kt.Kb)==null||w0.flush();let Iy=O0.errors;if(0<Iy.length){let sv=await Promise.all(Iy);if(sv=sv.filter(Jy=>Jy),0<sv.length)throw Error(sv.join(`
`))}return fy}finally{Kt.Cb=null}};Kt._OrtCreateSession=Ir(Kt._OrtCreateSession,()=>Kt._OrtCreateSession,zo=>Kt._OrtCreateSession=zo),Kt._OrtRun=Yr(Ir(Kt._OrtRun,()=>Kt._OrtRun,zo=>Kt._OrtRun=zo)),Kt._OrtRunWithBinding=Yr(Ir(Kt._OrtRunWithBinding,()=>Kt._OrtRunWithBinding,zo=>Kt._OrtRunWithBinding=zo)),Kt._OrtBindInput=Ir(Kt._OrtBindInput,()=>Kt._OrtBindInput,zo=>Kt._OrtBindInput=zo),In=void 0};Kt.jsepInit=(Ir,Yr)=>{if(In==null||In(),Ir==="webgpu"){[Kt.Kb,Kt.Wb,Kt.$b,Kt.Lb,Kt.Zb,Kt.ob,Kt.ac,Kt.cc,Kt.Xb,Kt.Yb,Kt.bc]=Yr;let zo=Kt.Kb;Kt.jsepRegisterBuffer=(s0,w0,O0,fy)=>zo.registerBuffer(s0,w0,O0,fy),Kt.jsepGetBuffer=s0=>zo.getBuffer(s0),Kt.jsepCreateDownloader=(s0,w0,O0)=>zo.createDownloader(s0,w0,O0),Kt.jsepOnReleaseSession=s0=>{zo.onReleaseSession(s0)},Kt.jsepOnRunStart=s0=>zo.onRunStart(s0)}};var tr=Object.assign({},Kt),rr="./this.program",Hr=(Ir,Yr)=>{throw Yr},qr=typeof window=="object",Zr=typeof importScripts=="function",Bo=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",Xo=Kt.ENVIRONMENT_IS_PTHREAD||!1,Kr="";function ko(Ir){return Kt.locateFile?Kt.locateFile(Ir,Kr):Kr+Ir}var f0,x0,l0;if(Bo){var T0=(Mi(),sr(Di)),t0=(Wi(),sr(Ui));Kr=Zr?t0.dirname(Kr)+"/":__dirname+"/",f0=(Ir,Yr)=>(Ir=sy(Ir)?new URL(Ir):t0.normalize(Ir),T0.readFileSync(Ir,Yr?void 0:"utf8")),l0=Ir=>(Ir=f0(Ir,!0),Ir.buffer||(Ir=new Uint8Array(Ir)),Ir),x0=(Ir,Yr,zo,s0=!0)=>{Ir=sy(Ir)?new URL(Ir):t0.normalize(Ir),T0.readFile(Ir,s0?void 0:"utf8",(w0,O0)=>{w0?zo(w0):Yr(s0?O0.buffer:O0)})},!Kt.thisProgram&&1<process.argv.length&&(rr=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),Hr=(Ir,Yr)=>{throw process.exitCode=Ir,Yr},global.Worker=Ba().Worker}else(qr||Zr)&&(Zr?Kr=self.location.href:typeof document<"u"&&document.currentScript&&(Kr=document.currentScript.src),typeof vt<"u"&&vt&&(Kr=vt),Kr.startsWith("blob:")?Kr="":Kr=Kr.substr(0,Kr.replace(/[?#].*/,"").lastIndexOf("/")+1),Bo||(f0=Ir=>{var Yr=new XMLHttpRequest;return Yr.open("GET",Ir,!1),Yr.send(null),Yr.responseText},Zr&&(l0=Ir=>{var Yr=new XMLHttpRequest;return Yr.open("GET",Ir,!1),Yr.responseType="arraybuffer",Yr.send(null),new Uint8Array(Yr.response)}),x0=(Ir,Yr,zo)=>{var s0=new XMLHttpRequest;s0.open("GET",Ir,!0),s0.responseType="arraybuffer",s0.onload=()=>{s0.status==200||s0.status==0&&s0.response?Yr(s0.response):zo()},s0.onerror=zo,s0.send(null)}));Bo&&typeof performance>"u"&&(global.performance=Da().performance);var E0=console.log.bind(console),n0=console.error.bind(console);Bo&&(E0=(...Ir)=>T0.writeSync(1,Ir.join(" ")+`
`),n0=(...Ir)=>T0.writeSync(2,Ir.join(" ")+`
`));var m0=E0,h0=n0;Object.assign(Kt,tr),tr=null;var a0,P0,V0=!1,B0,W0,K0,Ty,$y,My,Wy,Ey,_0,ay,J0;function yy(){var Ir=a0.buffer;Kt.HEAP8=W0=new Int8Array(Ir),Kt.HEAP16=Ty=new Int16Array(Ir),Kt.HEAPU8=K0=new Uint8Array(Ir),Kt.HEAPU16=$y=new Uint16Array(Ir),Kt.HEAP32=My=new Int32Array(Ir),Kt.HEAPU32=Wy=new Uint32Array(Ir),Kt.HEAPF32=Ey=new Float32Array(Ir),Kt.HEAPF64=J0=new Float64Array(Ir),Kt.HEAP64=_0=new BigInt64Array(Ir),Kt.HEAPU64=ay=new BigUint64Array(Ir)}var uy=16777216;if(Xo)a0=Kt.wasmMemory;else if(Kt.wasmMemory)a0=Kt.wasmMemory;else if(a0=new WebAssembly.Memory({initial:uy/65536,maximum:65536,shared:!0}),!(a0.buffer instanceof SharedArrayBuffer))throw h0("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Bo&&h0("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");yy(),uy=a0.buffer.byteLength;var Dy=[],Fy=[],qy=[],rv=0,y0=null;function r0(){if(rv--,rv==0&&y0){var Ir=y0;y0=null,Ir()}}function M0(Ir){throw Ir="Aborted("+Ir+")",h0(Ir),V0=!0,B0=1,Ir=new WebAssembly.RuntimeError(Ir+". Build with -sASSERTIONS for more info."),Sn(Ir),Ir}var G0=Ir=>Ir.startsWith("data:application/octet-stream;base64,"),sy=Ir=>Ir.startsWith("file://"),dy;dy="ort-wasm-simd-threaded.wasm",G0(dy)||(dy=ko(dy));function Vy(Ir){if(l0)return l0(Ir);throw"both async and sync fetching of the wasm failed"}function Xy(Ir){if(qr||Zr){if(typeof fetch=="function"&&!sy(Ir))return fetch(Ir,{credentials:"same-origin"}).then(Yr=>{if(!Yr.ok)throw`failed to load wasm binary file at '${Ir}'`;return Yr.arrayBuffer()}).catch(()=>Vy(Ir));if(x0)return new Promise((Yr,zo)=>{x0(Ir,s0=>Yr(new Uint8Array(s0)),zo)})}return Promise.resolve().then(()=>Vy(Ir))}function hy(Ir,Yr,zo){return Xy(Ir).then(s0=>WebAssembly.instantiate(s0,Yr)).then(zo,s0=>{h0(`failed to asynchronously prepare wasm: ${s0}`),M0(s0)})}function Ly(Ir,Yr){var zo=dy;return typeof WebAssembly.instantiateStreaming!="function"||G0(zo)||sy(zo)||Bo||typeof fetch!="function"?hy(zo,Ir,Yr):fetch(zo,{credentials:"same-origin"}).then(s0=>WebAssembly.instantiateStreaming(s0,Ir).then(Yr,function(w0){return h0(`wasm streaming compile failed: ${w0}`),h0("falling back to ArrayBuffer instantiation"),hy(zo,Ir,Yr)}))}var Py={826468:(Ir,Yr,zo,s0)=>{if(typeof Kt>"u"||!Kt.Db)return 1;if(Ir=X0(Ir>>>0),Ir.startsWith("./")&&(Ir=Ir.substring(2)),Ir=Kt.Db.get(Ir),!Ir)return 2;if(Yr>>>=0,zo>>>=0,s0>>>=0,Yr+zo>Ir.byteLength)return 3;try{return Lt().set(Ir.subarray(Yr,Yr+zo),s0>>>0),0}catch{return 4}},826969:()=>{Kt.Xb()},827e3:()=>{Kt.Yb()},827029:()=>{Kt.bc()},827054:Ir=>Kt.Wb(Ir),827087:Ir=>Kt.$b(Ir),827119:(Ir,Yr,zo)=>{Kt.Lb(Ir,Yr,zo,!0)},827158:(Ir,Yr,zo)=>{Kt.Lb(Ir,Yr,zo)},827191:Ir=>{Kt.ob("Abs",Ir,void 0)},827242:Ir=>{Kt.ob("Neg",Ir,void 0)},827293:Ir=>{Kt.ob("Floor",Ir,void 0)},827346:Ir=>{Kt.ob("Ceil",Ir,void 0)},827398:Ir=>{Kt.ob("Reciprocal",Ir,void 0)},827456:Ir=>{Kt.ob("Sqrt",Ir,void 0)},827508:Ir=>{Kt.ob("Exp",Ir,void 0)},827559:Ir=>{Kt.ob("Erf",Ir,void 0)},827610:Ir=>{Kt.ob("Sigmoid",Ir,void 0)},827665:(Ir,Yr,zo)=>{Kt.ob("HardSigmoid",Ir,{alpha:Yr,beta:zo})},827744:Ir=>{Kt.ob("Log",Ir,void 0)},827795:Ir=>{Kt.ob("Sin",Ir,void 0)},827846:Ir=>{Kt.ob("Cos",Ir,void 0)},827897:Ir=>{Kt.ob("Tan",Ir,void 0)},827948:Ir=>{Kt.ob("Asin",Ir,void 0)},828e3:Ir=>{Kt.ob("Acos",Ir,void 0)},828052:Ir=>{Kt.ob("Atan",Ir,void 0)},828104:Ir=>{Kt.ob("Sinh",Ir,void 0)},828156:Ir=>{Kt.ob("Cosh",Ir,void 0)},828208:Ir=>{Kt.ob("Asinh",Ir,void 0)},828261:Ir=>{Kt.ob("Acosh",Ir,void 0)},828314:Ir=>{Kt.ob("Atanh",Ir,void 0)},828367:Ir=>{Kt.ob("Tanh",Ir,void 0)},828419:Ir=>{Kt.ob("Not",Ir,void 0)},828470:(Ir,Yr,zo)=>{Kt.ob("Clip",Ir,{min:Yr,max:zo})},828539:Ir=>{Kt.ob("Clip",Ir,void 0)},828591:(Ir,Yr)=>{Kt.ob("Elu",Ir,{alpha:Yr})},828649:Ir=>{Kt.ob("Relu",Ir,void 0)},828701:(Ir,Yr)=>{Kt.ob("LeakyRelu",Ir,{alpha:Yr})},828765:(Ir,Yr)=>{Kt.ob("ThresholdedRelu",Ir,{alpha:Yr})},828835:(Ir,Yr)=>{Kt.ob("Cast",Ir,{to:Yr})},828893:Ir=>{Kt.ob("Add",Ir,void 0)},828944:Ir=>{Kt.ob("Sub",Ir,void 0)},828995:Ir=>{Kt.ob("Mul",Ir,void 0)},829046:Ir=>{Kt.ob("Div",Ir,void 0)},829097:Ir=>{Kt.ob("Pow",Ir,void 0)},829148:Ir=>{Kt.ob("Equal",Ir,void 0)},829201:Ir=>{Kt.ob("Greater",Ir,void 0)},829256:Ir=>{Kt.ob("GreaterOrEqual",Ir,void 0)},829318:Ir=>{Kt.ob("Less",Ir,void 0)},829370:Ir=>{Kt.ob("LessOrEqual",Ir,void 0)},829429:(Ir,Yr,zo,s0,w0)=>{Kt.ob("ReduceMean",Ir,{keepDims:!!Yr,noopWithEmptyAxes:!!zo,axes:s0?Array.from(Ht().subarray(s0>>>0,w0>>>0)):[]})},829588:(Ir,Yr,zo,s0,w0)=>{Kt.ob("ReduceMax",Ir,{keepDims:!!Yr,noopWithEmptyAxes:!!zo,axes:s0?Array.from(Ht().subarray(s0>>>0,w0>>>0)):[]})},829746:(Ir,Yr,zo,s0,w0)=>{Kt.ob("ReduceMin",Ir,{keepDims:!!Yr,noopWithEmptyAxes:!!zo,axes:s0?Array.from(Ht().subarray(s0>>>0,w0>>>0)):[]})},829904:(Ir,Yr,zo,s0,w0)=>{Kt.ob("ReduceProd",Ir,{keepDims:!!Yr,noopWithEmptyAxes:!!zo,axes:s0?Array.from(Ht().subarray(s0>>>0,w0>>>0)):[]})},830063:(Ir,Yr,zo,s0,w0)=>{Kt.ob("ReduceSum",Ir,{keepDims:!!Yr,noopWithEmptyAxes:!!zo,axes:s0?Array.from(Ht().subarray(s0>>>0,w0>>>0)):[]})},830221:(Ir,Yr,zo,s0,w0)=>{Kt.ob("ReduceL1",Ir,{keepDims:!!Yr,noopWithEmptyAxes:!!zo,axes:s0?Array.from(Ht().subarray(s0>>>0,w0>>>0)):[]})},830378:(Ir,Yr,zo,s0,w0)=>{Kt.ob("ReduceL2",Ir,{keepDims:!!Yr,noopWithEmptyAxes:!!zo,axes:s0?Array.from(Ht().subarray(s0>>>0,w0>>>0)):[]})},830535:(Ir,Yr,zo,s0,w0)=>{Kt.ob("ReduceLogSum",Ir,{keepDims:!!Yr,noopWithEmptyAxes:!!zo,axes:s0?Array.from(Ht().subarray(s0>>>0,w0>>>0)):[]})},830696:(Ir,Yr,zo,s0,w0)=>{Kt.ob("ReduceSumSquare",Ir,{keepDims:!!Yr,noopWithEmptyAxes:!!zo,axes:s0?Array.from(Ht().subarray(s0>>>0,w0>>>0)):[]})},830860:(Ir,Yr,zo,s0,w0)=>{Kt.ob("ReduceLogSumExp",Ir,{keepDims:!!Yr,noopWithEmptyAxes:!!zo,axes:s0?Array.from(Ht().subarray(s0>>>0,w0>>>0)):[]})},831024:Ir=>{Kt.ob("Where",Ir,void 0)},831077:(Ir,Yr,zo)=>{Kt.ob("Transpose",Ir,{perm:Yr?Array.from(Ht().subarray(Yr>>>0,zo>>>0)):[]})},831185:(Ir,Yr,zo,s0)=>{Kt.ob("DepthToSpace",Ir,{blocksize:Yr,mode:X0(zo),format:s0?"NHWC":"NCHW"})},831318:(Ir,Yr,zo,s0)=>{Kt.ob("DepthToSpace",Ir,{blocksize:Yr,mode:X0(zo),format:s0?"NHWC":"NCHW"})},831451:(Ir,Yr,zo,s0,w0,O0,fy,Iy,sv,Jy,wv,a1,r1,iy,Mv)=>{Kt.ob("ConvTranspose",Ir,{format:sv?"NHWC":"NCHW",autoPad:Yr,dilations:[zo],group:s0,kernelShape:[w0],pads:[O0,fy],strides:[Iy],wIsConst:()=>!!Tt()[Jy>>>0],outputPadding:wv?Array.from(Ht().subarray(wv>>>0,a1>>>0)):[],outputShape:r1?Array.from(Ht().subarray(r1>>>0,iy>>>0)):[],activation:X0(Mv)})},831852:(Ir,Yr,zo,s0,w0,O0,fy,Iy,sv,Jy,wv,a1,r1,iy)=>{Kt.ob("ConvTranspose",Ir,{format:Iy?"NHWC":"NCHW",autoPad:Yr,dilations:Array.from(Ht().subarray(zo>>>0,(zo>>>0)+2>>>0)),group:s0,kernelShape:Array.from(Ht().subarray(w0>>>0,(w0>>>0)+2>>>0)),pads:Array.from(Ht().subarray(O0>>>0,(O0>>>0)+4>>>0)),strides:Array.from(Ht().subarray(fy>>>0,(fy>>>0)+2>>>0)),wIsConst:()=>!!Tt()[sv>>>0],outputPadding:Jy?Array.from(Ht().subarray(Jy>>>0,wv>>>0)):[],outputShape:a1?Array.from(Ht().subarray(a1>>>0,r1>>>0)):[],activation:X0(iy)})},832417:(Ir,Yr,zo,s0,w0,O0,fy,Iy,sv,Jy,wv,a1,r1,iy,Mv)=>{Kt.ob("ConvTranspose",Ir,{format:sv?"NHWC":"NCHW",autoPad:Yr,dilations:[zo],group:s0,kernelShape:[w0],pads:[O0,fy],strides:[Iy],wIsConst:()=>!!Tt()[Jy>>>0],outputPadding:wv?Array.from(Ht().subarray(wv>>>0,a1>>>0)):[],outputShape:r1?Array.from(Ht().subarray(r1>>>0,iy>>>0)):[],activation:X0(Mv)})},832818:(Ir,Yr,zo,s0,w0,O0,fy,Iy,sv,Jy,wv,a1,r1,iy)=>{Kt.ob("ConvTranspose",Ir,{format:Iy?"NHWC":"NCHW",autoPad:Yr,dilations:Array.from(Ht().subarray(zo>>>0,(zo>>>0)+2>>>0)),group:s0,kernelShape:Array.from(Ht().subarray(w0>>>0,(w0>>>0)+2>>>0)),pads:Array.from(Ht().subarray(O0>>>0,(O0>>>0)+4>>>0)),strides:Array.from(Ht().subarray(fy>>>0,(fy>>>0)+2>>>0)),wIsConst:()=>!!Tt()[sv>>>0],outputPadding:Jy?Array.from(Ht().subarray(Jy>>>0,wv>>>0)):[],outputShape:a1?Array.from(Ht().subarray(a1>>>0,r1>>>0)):[],activation:X0(iy)})},833383:(Ir,Yr)=>{Kt.ob("GlobalAveragePool",Ir,{format:Yr?"NHWC":"NCHW"})},833474:(Ir,Yr,zo,s0,w0,O0,fy,Iy,sv,Jy,wv,a1,r1,iy,Mv,Qv)=>{Kt.ob("AveragePool",Ir,{format:Qv?"NHWC":"NCHW",auto_pad:Yr,ceil_mode:zo,count_include_pad:s0,storage_order:w0,dilations:[O0,fy],kernel_shape:[Iy,sv],pads:[Jy,wv,a1,r1],strides:[iy,Mv]})},833758:(Ir,Yr)=>{Kt.ob("GlobalAveragePool",Ir,{format:Yr?"NHWC":"NCHW"})},833849:(Ir,Yr,zo,s0,w0,O0,fy,Iy,sv,Jy,wv,a1,r1,iy,Mv,Qv)=>{Kt.ob("AveragePool",Ir,{format:Qv?"NHWC":"NCHW",auto_pad:Yr,ceil_mode:zo,count_include_pad:s0,storage_order:w0,dilations:[O0,fy],kernel_shape:[Iy,sv],pads:[Jy,wv,a1,r1],strides:[iy,Mv]})},834133:(Ir,Yr)=>{Kt.ob("GlobalMaxPool",Ir,{format:Yr?"NHWC":"NCHW"})},834220:(Ir,Yr,zo,s0,w0,O0,fy,Iy,sv,Jy,wv,a1,r1,iy,Mv,Qv)=>{Kt.ob("MaxPool",Ir,{format:Qv?"NHWC":"NCHW",auto_pad:Yr,ceil_mode:zo,count_include_pad:s0,storage_order:w0,dilations:[O0,fy],kernel_shape:[Iy,sv],pads:[Jy,wv,a1,r1],strides:[iy,Mv]})},834500:(Ir,Yr)=>{Kt.ob("GlobalMaxPool",Ir,{format:Yr?"NHWC":"NCHW"})},834587:(Ir,Yr,zo,s0,w0,O0,fy,Iy,sv,Jy,wv,a1,r1,iy,Mv,Qv)=>{Kt.ob("MaxPool",Ir,{format:Qv?"NHWC":"NCHW",auto_pad:Yr,ceil_mode:zo,count_include_pad:s0,storage_order:w0,dilations:[O0,fy],kernel_shape:[Iy,sv],pads:[Jy,wv,a1,r1],strides:[iy,Mv]})},834867:(Ir,Yr,zo,s0,w0)=>{Kt.ob("Gemm",Ir,{alpha:Yr,beta:zo,transA:s0,transB:w0})},834971:Ir=>{Kt.ob("MatMul",Ir,void 0)},835025:(Ir,Yr,zo,s0)=>{Kt.ob("ArgMax",Ir,{keepDims:!!Yr,selectLastIndex:!!zo,axis:s0})},835133:(Ir,Yr,zo,s0)=>{Kt.ob("ArgMin",Ir,{keepDims:!!Yr,selectLastIndex:!!zo,axis:s0})},835241:(Ir,Yr)=>{Kt.ob("Softmax",Ir,{axis:Yr})},835304:(Ir,Yr)=>{Kt.ob("Concat",Ir,{axis:Yr})},835364:(Ir,Yr,zo,s0,w0)=>{Kt.ob("Split",Ir,{axis:Yr,numOutputs:zo,splitSizes:s0?Array.from(Ht().subarray(s0>>>0,w0>>>0)):[]})},835504:Ir=>{Kt.ob("Expand",Ir,void 0)},835558:(Ir,Yr)=>{Kt.ob("Gather",Ir,{axis:Number(Yr)})},835629:(Ir,Yr)=>{Kt.ob("GatherElements",Ir,{axis:Number(Yr)})},835708:(Ir,Yr,zo,s0,w0,O0,fy,Iy,sv,Jy,wv)=>{Kt.ob("Resize",Ir,{antialias:Yr,axes:zo?Array.from(Ht().subarray(zo>>>0,s0>>>0)):[],coordinateTransformMode:X0(w0),cubicCoeffA:O0,excludeOutside:fy,extrapolationValue:Iy,keepAspectRatioPolicy:X0(sv),mode:X0(Jy),nearestMode:X0(wv)})},836054:(Ir,Yr,zo,s0,w0,O0,fy)=>{Kt.ob("Slice",Ir,{starts:Yr?Array.from(Ht().subarray(Yr>>>0,zo>>>0)):[],ends:s0?Array.from(Ht().subarray(s0>>>0,w0>>>0)):[],axes:O0?Array.from(Ht().subarray(O0>>>0,fy>>>0)):[]})},836270:Ir=>{Kt.ob("Tile",Ir,void 0)},836322:(Ir,Yr,zo,s0)=>{Kt.ob("LayerNormalization",Ir,{axis:Yr,epsilon:zo,simplified:!!s0})},836433:(Ir,Yr,zo)=>{Kt.ob("InstanceNormalization",Ir,{epsilon:Yr,format:zo?"NHWC":"NCHW"})},836547:(Ir,Yr,zo)=>{Kt.ob("InstanceNormalization",Ir,{epsilon:Yr,format:zo?"NHWC":"NCHW"})},836661:Ir=>{Kt.ob("Range",Ir,void 0)},836714:(Ir,Yr)=>{Kt.ob("Einsum",Ir,{equation:X0(Yr)})},836795:(Ir,Yr,zo,s0,w0)=>{Kt.ob("Pad",Ir,{mode:Yr,value:zo,pads:s0?Array.from(Ht().subarray(s0>>>0,w0>>>0)):[]})},836922:(Ir,Yr,zo,s0,w0,O0)=>{Kt.ob("BatchNormalization",Ir,{epsilon:Yr,momentum:zo,spatial:!!w0,trainingMode:!!s0,format:O0?"NHWC":"NCHW"})},837091:(Ir,Yr,zo,s0,w0,O0)=>{Kt.ob("BatchNormalization",Ir,{epsilon:Yr,momentum:zo,spatial:!!w0,trainingMode:!!s0,format:O0?"NHWC":"NCHW"})},837260:(Ir,Yr,zo)=>{Kt.ob("CumSum",Ir,{exclusive:Number(Yr),reverse:Number(zo)})},837357:(Ir,Yr,zo,s0,w0,O0,fy,Iy,sv)=>{Kt.ob("Attention",Ir,{numHeads:Yr,isUnidirectional:zo,maskFilterValue:s0,scale:w0,doRotary:O0,qkvHiddenSizes:fy?Array.from(Ht().subarray(Number(Iy)>>>0,Number(Iy)+fy>>>0)):[],pastPresentShareBuffer:!!sv})},837629:Ir=>{Kt.ob("BiasAdd",Ir,void 0)},837684:Ir=>{Kt.ob("BiasSplitGelu",Ir,void 0)},837745:Ir=>{Kt.ob("FastGelu",Ir,void 0)},837801:(Ir,Yr,zo,s0,w0,O0,fy,Iy,sv,Jy,wv,a1,r1)=>{Kt.ob("Conv",Ir,{format:sv?"NHWC":"NCHW",auto_pad:Yr,dilations:[zo],group:s0,kernel_shape:[w0],pads:O0?Array.from(Ht().subarray(O0>>>0,fy>>>0)):[],strides:[Iy],w_is_const:()=>!!Tt()[Jy>>>0],activation:X0(wv),activation_params:a1?Array.from(jt().subarray(a1>>>0,r1>>>0)):[]})},838171:(Ir,Yr,zo,s0,w0,O0,fy,Iy,sv,Jy,wv,a1,r1,iy,Mv,Qv)=>{Kt.ob("Conv",Ir,{format:a1?"NHWC":"NCHW",auto_pad:Yr,dilations:[zo,s0],group:w0,kernel_shape:[O0,fy],pads:Iy?Array.from(Ht().subarray(Iy>>>0,sv>>>0)):[],strides:[Jy,wv],w_is_const:()=>!!Tt()[r1>>>0],activation:X0(iy),activation_params:Mv?Array.from(jt().subarray(Mv>>>0,Qv>>>0)):[]})},838562:Ir=>{Kt.ob("Gelu",Ir,void 0)},838614:(Ir,Yr,zo,s0,w0,O0)=>{Kt.ob("MatMulNBits",Ir,{k:Yr,n:zo,accuracyLevel:s0,bits:w0,blockSize:O0})},838741:(Ir,Yr,zo,s0,w0,O0)=>{Kt.ob("MultiHeadAttention",Ir,{numHeads:Yr,isUnidirectional:zo,maskFilterValue:s0,scale:w0,doRotary:O0})},838900:(Ir,Yr,zo,s0,w0)=>{Kt.ob("RotaryEmbedding",Ir,{interleaved:!!Yr,numHeads:zo,rotaryEmbeddingDim:s0,scale:w0})},839039:(Ir,Yr,zo)=>{Kt.ob("SkipLayerNormalization",Ir,{epsilon:Yr,simplified:!!zo})},839141:(Ir,Yr,zo)=>{Kt.ob("SkipLayerNormalization",Ir,{epsilon:Yr,simplified:!!zo})},839243:(Ir,Yr,zo,s0)=>{Kt.ob("LayerNormalization",Ir,{axis:Yr,epsilon:zo,simplified:!!s0})},839354:Ir=>{Kt.ac(Ir)},839388:(Ir,Yr)=>Kt.cc(Ir,Yr,Kt.Cb.ec,Kt.Cb.errors)};function Sy(Ir){this.name="ExitStatus",this.message=`Program terminated with exit(${Ir})`,this.status=Ir}var Ev=Ir=>{Ir.terminate(),Ir.onmessage=()=>{}},Qy=Ir=>{$0.xb.length==0&&(i0(),$0.Mb($0.xb[0]));var Yr=$0.xb.pop();if(!Yr)return 6;$0.yb.push(Yr),$0.ub[Ir.wb]=Yr,Yr.wb=Ir.wb;var zo={cmd:"run",start_routine:Ir.fc,arg:Ir.Rb,pthread_ptr:Ir.wb};return Bo&&Yr.unref(),Yr.postMessage(zo,Ir.mc),0},cy=0,C0=Ir=>{var Yr=Y_();return Ir=Ir(),U_(Yr),Ir},U0=(Ir,Yr,...zo)=>C0(()=>{for(var s0=2*zo.length,w0=p_(8*s0),O0=w0>>>3,fy=0;fy<zo.length;fy++){var Iy=zo[fy];typeof Iy=="bigint"?(_0[O0+2*fy]=1n,_0[O0+2*fy+1]=Iy):(_0[O0+2*fy]=0n,qt()[O0+2*fy+1>>>0]=Iy)}return Sx(Ir,0,s0,w0,Yr)});function xy(Ir){var Yr;if(Xo)return U0(0,1,Ir);B0=Ir,0<cy||($0.hc(),(Yr=Kt.onExit)==null||Yr.call(Kt,Ir),V0=!0),Hr(Ir,new Sy(Ir))}var o0=Ir=>{if(B0=Ir,Xo)throw my(Ir),"unwind";xy(Ir)};function v0(){for(var Ir=Kt.numThreads;Ir--;)i0();Dy.unshift(()=>{rv++,k0(()=>r0())})}function i0(){var Ir=ko("ort-wasm-simd-threaded.worker.js");Ir=new Worker(Ir),$0.xb.push(Ir)}function k0(Ir){Xo?Ir():Promise.all($0.xb.map($0.Mb)).then(Ir)}var $0={xb:[],yb:[],Qb:[],ub:{},Gb(){Xo?($0.receiveObjectTransfer=$0.dc,$0.threadInitTLS=$0.Pb,$0.setExitStatus=$0.Ob):v0()},Ob:Ir=>B0=Ir,pc:["$terminateWorker"],hc:()=>{for(var Ir of $0.yb)Ev(Ir);for(Ir of $0.xb)Ev(Ir);$0.xb=[],$0.yb=[],$0.ub=[]},Nb:Ir=>{var Yr=Ir.wb;delete $0.ub[Yr],$0.xb.push(Ir),$0.yb.splice($0.yb.indexOf(Ir),1),Ir.wb=0,Ex(Yr)},dc(){},Pb(){$0.Qb.forEach(Ir=>Ir())},Mb:Ir=>new Promise(Yr=>{Ir.onmessage=O0=>{O0=O0.data;var fy=O0.cmd;if(O0.targetThread&&O0.targetThread!=f1()){var Iy=$0.ub[O0.targetThread];Iy?Iy.postMessage(O0,O0.transferList):h0(`Internal error! Worker sent a message "${fy}" to target pthread ${O0.targetThread}, but that thread no longer exists!`)}else fy==="checkMailbox"?i1():fy==="spawnThread"?Qy(O0):fy==="cleanupThread"?$0.Nb($0.ub[O0.thread]):fy==="killThread"?(O0=O0.thread,fy=$0.ub[O0],delete $0.ub[O0],Ev(fy),Ex(O0),$0.yb.splice($0.yb.indexOf(fy),1),fy.wb=0):fy==="cancelThread"?$0.ub[O0.thread].postMessage({cmd:"cancel"}):fy==="loaded"?(Ir.loaded=!0,Bo&&!Ir.wb&&Ir.unref(),Yr(Ir)):fy==="alert"?alert(`Thread ${O0.threadId}: ${O0.text}`):O0.target==="setimmediate"?Ir.postMessage(O0):fy==="callHandler"?Kt[O0.handler](...O0.args):fy&&h0(`worker sent an unknown command ${fy}`)},Ir.onerror=O0=>{throw h0(`worker sent an error! ${O0.filename}:${O0.lineno}: ${O0.message}`),O0},Bo&&(Ir.on("message",O0=>Ir.onmessage({data:O0})),Ir.on("error",O0=>Ir.onerror(O0)));var zo=[],s0=["onExit"],w0;for(w0 of s0)Kt.hasOwnProperty(w0)&&zo.push(w0);Ir.postMessage({cmd:"load",handlers:zo,urlOrBlob:Kt.mainScriptUrlOrBlob||vt,wasmMemory:a0,wasmModule:P0})})};Kt.PThread=$0;var ty=Ir=>{for(;0<Ir.length;)Ir.shift()(Kt)};Kt.establishStackSpace=()=>{var Ir=f1(),Yr=Gt()[Ir+52>>>2>>>0];Ir=Gt()[Ir+56>>>2>>>0],dw(Yr,Yr-Ir),U_(Yr)};function my(Ir){if(Xo)return U0(1,0,Ir);o0(Ir)}Kt.invokeEntryPoint=(Ir,Yr)=>{cy=0,Ir=Tx(Ir,Yr),0<cy?$0.Ob(Ir):cw(Ir)};class ev{constructor(Yr){this.Ib=Yr-24}Gb(Yr,zo){Gt()[this.Ib+16>>>2>>>0]=0,Gt()[this.Ib+4>>>2>>>0]=Yr,Gt()[this.Ib+8>>>2>>>0]=zo}}var vv=0;function Tv(Ir,Yr,zo,s0){return Xo?U0(2,1,Ir,Yr,zo,s0):Rv(Ir,Yr,zo,s0)}function Rv(Ir,Yr,zo,s0){if(Ir>>>=0,Yr>>>=0,zo>>>=0,s0>>>=0,typeof SharedArrayBuffer>"u")return h0("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var w0=[];return Xo&&w0.length===0?Tv(Ir,Yr,zo,s0):(Ir={fc:zo,wb:Ir,Rb:s0,mc:w0},Xo?(Ir.oc="spawnThread",postMessage(Ir,w0),0):Qy(Ir))}var Lv=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Yv=(Ir,Yr,zo)=>{Yr>>>=0;var s0=Yr+zo;for(zo=Yr;Ir[zo]&&!(zo>=s0);)++zo;if(16<zo-Yr&&Ir.buffer&&Lv)return Lv.decode(Ir.buffer instanceof SharedArrayBuffer?Ir.slice(Yr,zo):Ir.subarray(Yr,zo));for(s0="";Yr<zo;){var w0=Ir[Yr++];if(w0&128){var O0=Ir[Yr++]&63;if((w0&224)==192)s0+=String.fromCharCode((w0&31)<<6|O0);else{var fy=Ir[Yr++]&63;w0=(w0&240)==224?(w0&15)<<12|O0<<6|fy:(w0&7)<<18|O0<<12|fy<<6|Ir[Yr++]&63,65536>w0?s0+=String.fromCharCode(w0):(w0-=65536,s0+=String.fromCharCode(55296|w0>>10,56320|w0&1023))}}else s0+=String.fromCharCode(w0)}return s0},X0=(Ir,Yr)=>(Ir>>>=0)?Yv(Lt(),Ir,Yr):"";function Pv(Ir,Yr,zo){return Xo?U0(3,1,Ir,Yr,zo):0}function Fv(Ir,Yr){if(Xo)return U0(4,1,Ir,Yr)}var Jv=Ir=>{for(var Yr=0,zo=0;zo<Ir.length;++zo){var s0=Ir.charCodeAt(zo);127>=s0?Yr++:2047>=s0?Yr+=2:55296<=s0&&57343>=s0?(Yr+=4,++zo):Yr+=3}return Yr},g1=(Ir,Yr,zo,s0)=>{if(zo>>>=0,!(0<s0))return 0;var w0=zo;s0=zo+s0-1;for(var O0=0;O0<Ir.length;++O0){var fy=Ir.charCodeAt(O0);if(55296<=fy&&57343>=fy){var Iy=Ir.charCodeAt(++O0);fy=65536+((fy&1023)<<10)|Iy&1023}if(127>=fy){if(zo>=s0)break;Yr[zo++>>>0]=fy}else{if(2047>=fy){if(zo+1>=s0)break;Yr[zo++>>>0]=192|fy>>6}else{if(65535>=fy){if(zo+2>=s0)break;Yr[zo++>>>0]=224|fy>>12}else{if(zo+3>=s0)break;Yr[zo++>>>0]=240|fy>>18,Yr[zo++>>>0]=128|fy>>12&63}Yr[zo++>>>0]=128|fy>>6&63}Yr[zo++>>>0]=128|fy&63}}return Yr[zo>>>0]=0,zo-w0},_v=(Ir,Yr,zo)=>g1(Ir,Lt(),Yr,zo);function Y1(Ir,Yr){if(Xo)return U0(5,1,Ir,Yr)}function c_(Ir,Yr,zo){if(Xo)return U0(6,1,Ir,Yr,zo)}function Qo(Ir,Yr,zo){return Xo?U0(7,1,Ir,Yr,zo):0}function c0(Ir,Yr){if(Xo)return U0(8,1,Ir,Yr)}function D0(Ir,Yr,zo){if(Xo)return U0(9,1,Ir,Yr,zo)}function Go(Ir,Yr,zo,s0){if(Xo)return U0(10,1,Ir,Yr,zo,s0)}function g0(Ir,Yr,zo,s0){if(Xo)return U0(11,1,Ir,Yr,zo,s0)}function b0(Ir,Yr,zo,s0){if(Xo)return U0(12,1,Ir,Yr,zo,s0)}function I0(Ir){if(Xo)return U0(13,1,Ir)}function A0(Ir,Yr){if(Xo)return U0(14,1,Ir,Yr)}function Y0(Ir,Yr,zo){if(Xo)return U0(15,1,Ir,Yr,zo)}var ey,ny=Ir=>{for(var Yr="";Lt()[Ir>>>0];)Yr+=ey[Lt()[Ir++>>>0]];return Yr},ry={},Ky={},wy;function Ry(Ir,Yr,zo={}){var s0=Yr.name;if(!Ir)throw new wy(`type "${s0}" must have a positive integer typeid pointer`);if(Ky.hasOwnProperty(Ir)){if(zo.Ub)return;throw new wy(`Cannot register type '${s0}' twice`)}Ky[Ir]=Yr,ry.hasOwnProperty(Ir)&&(Yr=ry[Ir],delete ry[Ir],Yr.forEach(w0=>w0()))}function Hy(Ir,Yr,zo={}){if(!("argPackAdvance"in Yr))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Ry(Ir,Yr,zo)}var uv=(Ir,Yr,zo)=>{switch(Yr){case 1:return zo?s0=>Tt()[s0>>>0]:s0=>Lt()[s0>>>0];case 2:return zo?s0=>Ft()[s0>>>1>>>0]:s0=>Ct()[s0>>>1>>>0];case 4:return zo?s0=>Ht()[s0>>>2>>>0]:s0=>Gt()[s0>>>2>>>0];case 8:return zo?s0=>_0[s0>>>3]:s0=>ay[s0>>>3];default:throw new TypeError(`invalid integer width (${Yr}): ${Ir}`)}},dv=[],pv=[];function Zy(Ir){Ir>>>=0,9<Ir&&--pv[Ir+1]===0&&(pv[Ir]=void 0,dv.push(Ir))}var By=Ir=>{if(!Ir)throw new wy("Cannot use deleted val. handle = "+Ir);return pv[Ir]},bv=Ir=>{switch(Ir){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let Yr=dv.pop()||pv.length;return pv[Yr]=Ir,pv[Yr+1]=1,Yr}};function fv(Ir){return this.fromWireType(Gt()[Ir>>>2>>>0])}var xv={name:"emscripten::val",fromWireType:Ir=>{var Yr=By(Ir);return Zy(Ir),Yr},toWireType:(Ir,Yr)=>bv(Yr),argPackAdvance:8,readValueFromPointer:fv,Bb:null},t1=(Ir,Yr)=>{switch(Yr){case 4:return function(zo){return this.fromWireType(jt()[zo>>>2>>>0])};case 8:return function(zo){return this.fromWireType(qt()[zo>>>3>>>0])};default:throw new TypeError(`invalid float width (${Yr}): ${Ir}`)}},u1=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,c1=(Ir,Yr)=>{for(var zo=Ir>>1,s0=zo+Yr/2;!(zo>=s0)&&Ct()[zo>>>0];)++zo;if(zo<<=1,32<zo-Ir&&u1)return u1.decode(Lt().slice(Ir,zo));for(zo="",s0=0;!(s0>=Yr/2);++s0){var w0=Ft()[Ir+2*s0>>>1>>>0];if(w0==0)break;zo+=String.fromCharCode(w0)}return zo},Gv=(Ir,Yr,zo)=>{if(zo??(zo=2147483647),2>zo)return 0;zo-=2;var s0=Yr;zo=zo<2*Ir.length?zo/2:Ir.length;for(var w0=0;w0<zo;++w0){var O0=Ir.charCodeAt(w0);Ft()[Yr>>>1>>>0]=O0,Yr+=2}return Ft()[Yr>>>1>>>0]=0,Yr-s0},Ov=Ir=>2*Ir.length,jy=(Ir,Yr)=>{for(var zo=0,s0="";!(zo>=Yr/4);){var w0=Ht()[Ir+4*zo>>>2>>>0];if(w0==0)break;++zo,65536<=w0?(w0-=65536,s0+=String.fromCharCode(55296|w0>>10,56320|w0&1023)):s0+=String.fromCharCode(w0)}return s0},Av=(Ir,Yr,zo)=>{if(Yr>>>=0,zo??(zo=2147483647),4>zo)return 0;var s0=Yr;zo=s0+zo-4;for(var w0=0;w0<Ir.length;++w0){var O0=Ir.charCodeAt(w0);if(55296<=O0&&57343>=O0){var fy=Ir.charCodeAt(++w0);O0=65536+((O0&1023)<<10)|fy&1023}if(Ht()[Yr>>>2>>>0]=O0,Yr+=4,Yr+4>zo)break}return Ht()[Yr>>>2>>>0]=0,Yr-s0},zy=Ir=>{for(var Yr=0,zo=0;zo<Ir.length;++zo){var s0=Ir.charCodeAt(zo);55296<=s0&&57343>=s0&&++zo,Yr+=4}return Yr},n1=Ir=>{if(!V0)try{if(Ir(),!(0<cy))try{Xo?cw(B0):o0(B0)}catch(Yr){Yr instanceof Sy||Yr=="unwind"||Hr(1,Yr)}}catch(Yr){Yr instanceof Sy||Yr=="unwind"||Hr(1,Yr)}};function m1(Ir){Ir>>>=0,typeof Atomics.nc=="function"&&(Atomics.nc(Ht(),Ir>>>2,Ir).value.then(i1),Ir+=128,Atomics.store(Ht(),Ir>>>2,1))}Kt.__emscripten_thread_mailbox_await=m1;var i1=()=>{var Ir=f1();Ir&&(m1(Ir),n1(Nw))};Kt.checkMailbox=i1;var S1=[],J1=(Ir,Yr)=>{var zo=Ky[Ir];if(zo===void 0)throw Ir=fx(Ir),zo=ny(Ir),f_(Ir),new wy(`${Yr} has unknown type ${zo}`);return zo},d_=(Ir,Yr,zo)=>{var s0=[];return Ir=Ir.toWireType(s0,zo),s0.length&&(Gt()[Yr>>>2>>>0]=bv(s0)),Ir},x1=Ir=>{try{Ir()}catch(Yr){M0(Yr)}};function m_(){var Ir=ov,Yr={};for(let[zo,s0]of Object.entries(Ir))Yr[zo]=typeof s0=="function"?(...w0)=>{q1.push(zo);try{return s0(...w0)}finally{V0||(q1.pop(),j1&&z1===1&&q1.length===0&&(z1=0,cy+=1,x1(K1),typeof Fibers<"u"&&Fibers.rc()))}}:s0;return Yr}var z1=0,j1=null,g_=0,q1=[],No={},ir={},jr=0,Ro=null,_g=[];function d0(){return new Promise((Ir,Yr)=>{Ro={resolve:Ir,reject:Yr}})}function L0(){var Ir=Q1(65548),Yr=Ir+12;Gt()[Ir>>>2>>>0]=Yr,Gt()[Ir+4>>>2>>>0]=Yr+65536,Yr=q1[0];var zo=No[Yr];return zo===void 0&&(zo=jr++,No[Yr]=zo,ir[zo]=Yr),Yr=zo,Ht()[Ir+8>>>2>>>0]=Yr,Ir}function by(){var Ir=Ht()[j1+8>>>2>>>0];return Ir=ov[ir[Ir]],--cy,Ir()}function ky(Ir){if(!V0){if(z1===0){var Yr=!1,zo=!1;Ir((s0=0)=>{if(!V0&&(g_=s0,Yr=!0,zo)){z1=2,x1(()=>Z1(j1)),typeof Browser<"u"&&Browser.Hb.Tb&&Browser.Hb.resume(),s0=!1;try{var w0=by()}catch(Iy){w0=Iy,s0=!0}var O0=!1;if(!j1){var fy=Ro;fy&&(Ro=null,(s0?fy.reject:fy.resolve)(w0),O0=!0)}if(s0&&!O0)throw w0}}),zo=!0,Yr||(z1=1,j1=L0(),typeof Browser<"u"&&Browser.Hb.Tb&&Browser.Hb.pause(),x1(()=>Ax(j1)))}else z1===2?(z1=0,x1(z_),f_(j1),j1=null,_g.forEach(n1)):M0(`invalid state: ${z1}`);return g_}}function Oy(Ir){return ky(Yr=>{Ir().then(Yr)})}var Uy=[],hv={},Hv=Ir=>{var Yr=hv[Ir];return Yr===void 0?ny(Ir):Yr},Q0=()=>typeof globalThis=="object"?globalThis:Function("return this")(),q0=Ir=>{var Yr=Uy.length;return Uy.push(Ir),Yr},Yy=(Ir,Yr)=>{for(var zo=Array(Ir),s0=0;s0<Ir;++s0)zo[s0]=J1(Gt()[Yr+4*s0>>>2>>>0],"parameter "+s0);return zo},av=(Ir,Yr)=>Object.defineProperty(Yr,"name",{value:Ir});function Zv(Ir){var Yr=Function;if(!(Yr instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof Yr} which is not a function`);var zo=av(Yr.name||"unknownFunctionName",function(){});return zo.prototype=Yr.prototype,zo=new zo,Ir=Yr.apply(zo,Ir),Ir instanceof Object?Ir:zo}var M1=Ir=>Ir%4===0&&(Ir%100!==0||Ir%400===0),R_=[0,31,60,91,121,152,182,213,244,274,305,335],Gx=[0,31,59,90,120,151,181,212,243,273,304,334];function sw(Ir,Yr,zo,s0,w0,O0,fy){return Xo?U0(16,1,Ir,Yr,zo,s0,w0,O0,fy):-52}function Ow(Ir,Yr,zo,s0,w0,O0){if(Xo)return U0(17,1,Ir,Yr,zo,s0,w0,O0)}var Dw=[],y_=(Ir,Yr)=>{Dw.length=0;for(var zo;zo=Lt()[Ir++>>>0];){var s0=zo!=105;s0&=zo!=112,Yr+=s0&&Yr%8?4:0,Dw.push(zo==112?Gt()[Yr>>>2>>>0]:zo==106?_0[Yr>>>3]:zo==105?Ht()[Yr>>>2>>>0]:qt()[Yr>>>3>>>0]),Yr+=s0?8:4}return Dw},Bw={},_1=()=>{if(!Vx){var Ir={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:rr||"./this.program"},Yr;for(Yr in Bw)Bw[Yr]===void 0?delete Ir[Yr]:Ir[Yr]=Bw[Yr];var zo=[];for(Yr in Ir)zo.push(`${Yr}=${Ir[Yr]}`);Vx=zo}return Vx},Vx;function I1(Ir,Yr){if(Xo)return U0(18,1,Ir,Yr);Ir>>>=0,Yr>>>=0;var zo=0;return _1().forEach((s0,w0)=>{var O0=Yr+zo;for(w0=Gt()[Ir+4*w0>>>2>>>0]=O0,O0=0;O0<s0.length;++O0)Tt()[w0++>>>0]=s0.charCodeAt(O0);Tt()[w0>>>0]=0,zo+=s0.length+1}),0}function wx(Ir,Yr){if(Xo)return U0(19,1,Ir,Yr);Ir>>>=0,Yr>>>=0;var zo=_1();Gt()[Ir>>>2>>>0]=zo.length;var s0=0;return zo.forEach(w0=>s0+=w0.length+1),Gt()[Yr>>>2>>>0]=s0,0}function cx(Ir){return Xo?U0(20,1,Ir):52}function R1(Ir,Yr,zo,s0){return Xo?U0(21,1,Ir,Yr,zo,s0):52}function Hx(Ir,Yr,zo,s0){return Xo?U0(22,1,Ir,Yr,zo,s0):70}var lw=[null,[],[]];function uw(Ir,Yr,zo,s0){if(Xo)return U0(23,1,Ir,Yr,zo,s0);Yr>>>=0,zo>>>=0,s0>>>=0;for(var w0=0,O0=0;O0<zo;O0++){var fy=Gt()[Yr>>>2>>>0],Iy=Gt()[Yr+4>>>2>>>0];Yr+=8;for(var sv=0;sv<Iy;sv++){var Jy=Lt()[fy+sv>>>0],wv=lw[Ir];Jy===0||Jy===10?((Ir===1?m0:h0)(Yv(wv,0)),wv.length=0):wv.push(Jy)}w0+=Iy}return Gt()[s0>>>2>>>0]=w0,0}var Wx=[31,29,31,30,31,30,31,31,30,31,30,31],jx=[31,28,31,30,31,30,31,31,30,31,30,31];function dx(Ir){var Yr=Array(Jv(Ir)+1);return g1(Ir,Yr,0,Yr.length),Yr}var y1=(Ir,Yr)=>{Tt().set(Ir,Yr>>>0)};function x_(Ir,Yr,zo,s0){function w0(iy,Mv,Qv){for(iy=typeof iy=="number"?iy.toString():iy||"";iy.length<Mv;)iy=Qv[0]+iy;return iy}function O0(iy,Mv){return w0(iy,Mv,"0")}function fy(iy,Mv){function Qv(__){return 0>__?-1:0<__?1:0}var v_;return(v_=Qv(iy.getFullYear()-Mv.getFullYear()))===0&&(v_=Qv(iy.getMonth()-Mv.getMonth()))===0&&(v_=Qv(iy.getDate()-Mv.getDate())),v_}function Iy(iy){switch(iy.getDay()){case 0:return new Date(iy.getFullYear()-1,11,29);case 1:return iy;case 2:return new Date(iy.getFullYear(),0,3);case 3:return new Date(iy.getFullYear(),0,2);case 4:return new Date(iy.getFullYear(),0,1);case 5:return new Date(iy.getFullYear()-1,11,31);case 6:return new Date(iy.getFullYear()-1,11,30)}}function sv(iy){var Mv=iy.zb;for(iy=new Date(new Date(iy.Ab+1900,0,1).getTime());0<Mv;){var Qv=iy.getMonth(),v_=(M1(iy.getFullYear())?Wx:jx)[Qv];if(Mv>v_-iy.getDate())Mv-=v_-iy.getDate()+1,iy.setDate(1),11>Qv?iy.setMonth(Qv+1):(iy.setMonth(0),iy.setFullYear(iy.getFullYear()+1));else{iy.setDate(iy.getDate()+Mv);break}}return Qv=new Date(iy.getFullYear()+1,0,4),Mv=Iy(new Date(iy.getFullYear(),0,4)),Qv=Iy(Qv),0>=fy(Mv,iy)?0>=fy(Qv,iy)?iy.getFullYear()+1:iy.getFullYear():iy.getFullYear()-1}Ir>>>=0,Yr>>>=0,zo>>>=0,s0>>>=0;var Jy=Gt()[s0+40>>>2>>>0];s0={kc:Ht()[s0>>>2>>>0],jc:Ht()[s0+4>>>2>>>0],Eb:Ht()[s0+8>>>2>>>0],Jb:Ht()[s0+12>>>2>>>0],Fb:Ht()[s0+16>>>2>>>0],Ab:Ht()[s0+20>>>2>>>0],vb:Ht()[s0+24>>>2>>>0],zb:Ht()[s0+28>>>2>>>0],qc:Ht()[s0+32>>>2>>>0],ic:Ht()[s0+36>>>2>>>0],lc:Jy?X0(Jy):""},zo=X0(zo),Jy={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var wv in Jy)zo=zo.replace(new RegExp(wv,"g"),Jy[wv]);var a1="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),r1="January February March April May June July August September October November December".split(" ");Jy={"%a":iy=>a1[iy.vb].substring(0,3),"%A":iy=>a1[iy.vb],"%b":iy=>r1[iy.Fb].substring(0,3),"%B":iy=>r1[iy.Fb],"%C":iy=>O0((iy.Ab+1900)/100|0,2),"%d":iy=>O0(iy.Jb,2),"%e":iy=>w0(iy.Jb,2," "),"%g":iy=>sv(iy).toString().substring(2),"%G":sv,"%H":iy=>O0(iy.Eb,2),"%I":iy=>(iy=iy.Eb,iy==0?iy=12:12<iy&&(iy-=12),O0(iy,2)),"%j":iy=>{for(var Mv=0,Qv=0;Qv<=iy.Fb-1;Mv+=(M1(iy.Ab+1900)?Wx:jx)[Qv++]);return O0(iy.Jb+Mv,3)},"%m":iy=>O0(iy.Fb+1,2),"%M":iy=>O0(iy.jc,2),"%n":()=>`
`,"%p":iy=>0<=iy.Eb&&12>iy.Eb?"AM":"PM","%S":iy=>O0(iy.kc,2),"%t":()=>"	","%u":iy=>iy.vb||7,"%U":iy=>O0(Math.floor((iy.zb+7-iy.vb)/7),2),"%V":iy=>{var Mv=Math.floor((iy.zb+7-(iy.vb+6)%7)/7);if(2>=(iy.vb+371-iy.zb-2)%7&&Mv++,Mv)Mv==53&&(Qv=(iy.vb+371-iy.zb)%7,Qv==4||Qv==3&&M1(iy.Ab)||(Mv=1));else{Mv=52;var Qv=(iy.vb+7-iy.zb-1)%7;(Qv==4||Qv==5&&M1(iy.Ab%400-1))&&Mv++}return O0(Mv,2)},"%w":iy=>iy.vb,"%W":iy=>O0(Math.floor((iy.zb+7-(iy.vb+6)%7)/7),2),"%y":iy=>(iy.Ab+1900).toString().substring(2),"%Y":iy=>iy.Ab+1900,"%z":iy=>{iy=iy.ic;var Mv=0<=iy;return iy=Math.abs(iy)/60,(Mv?"+":"-")+("0000"+(iy/60*100+iy%60)).slice(-4)},"%Z":iy=>iy.lc,"%%":()=>"%"},zo=zo.replace(/%%/g,"\0\0");for(wv in Jy)zo.includes(wv)&&(zo=zo.replace(new RegExp(wv,"g"),Jy[wv](s0)));return zo=zo.replace(/\0\0/g,"%"),wv=dx(zo),wv.length>Yr?0:(y1(wv,Ir),wv.length-1)}$0.Gb();for(var w1=Array(256),$x=0;256>$x;++$x)w1[$x]=String.fromCharCode($x);ey=w1,wy=Kt.BindingError=class extends Error{constructor(Ir){super(Ir),this.name="BindingError"}},Kt.InternalError=class extends Error{constructor(Ir){super(Ir),this.name="InternalError"}},pv.push(0,1,void 0,1,null,1,!0,1,!1,1),Kt.count_emval_handles=()=>pv.length/2-5-dv.length;var kw=[xy,my,Tv,Pv,Fv,Y1,c_,Qo,c0,D0,Go,g0,b0,I0,A0,Y0,sw,Ow,I1,wx,cx,R1,Hx,uw],G1={ua:function(Ir,Yr,zo){return Oy(async()=>{await Kt.Zb(Ir,Yr,zo)})},b:function(Ir,Yr,zo){throw Ir>>>=0,new ev(Ir).Gb(Yr>>>0,zo>>>0),vv=Ir,vv},ia:function(Ir){Lw(Ir>>>0,!Zr,1,!qr,131072,!1),$0.Pb()},G:function(Ir){Ir>>>=0,Xo?postMessage({cmd:"cleanupThread",thread:Ir}):$0.Nb($0.ub[Ir])},_:Rv,A:Pv,pa:Fv,W:Y1,Y:c_,qa:Qo,na:c0,fa:D0,ma:Go,K:g0,X:b0,U:I0,oa:A0,V:Y0,E:function(Ir,Yr,zo){Ir>>>=0,zo>>>=0,Yr=ny(Yr>>>0),Hy(Ir,{name:Yr,fromWireType:s0=>s0,toWireType:function(s0,w0){if(typeof w0!="bigint"&&typeof w0!="number")throw w0===null?w0="null":(s0=typeof w0,w0=s0==="object"||s0==="array"||s0==="function"?w0.toString():""+w0),new TypeError(`Cannot convert "${w0}" to ${this.name}`);return typeof w0=="number"&&(w0=BigInt(w0)),w0},argPackAdvance:8,readValueFromPointer:uv(Yr,zo,Yr.indexOf("u")==-1),Bb:null})},O:function(Ir,Yr,zo,s0){Ir>>>=0,Yr=ny(Yr>>>0),Hy(Ir,{name:Yr,fromWireType:function(w0){return!!w0},toWireType:function(w0,O0){return O0?zo:s0},argPackAdvance:8,readValueFromPointer:function(w0){return this.fromWireType(Lt()[w0>>>0])},Bb:null})},N:function(Ir){return Hy(Ir>>>0,xv)},D:function(Ir,Yr,zo){Ir>>>=0,zo>>>=0,Yr=ny(Yr>>>0),Hy(Ir,{name:Yr,fromWireType:s0=>s0,toWireType:(s0,w0)=>w0,argPackAdvance:8,readValueFromPointer:t1(Yr,zo),Bb:null})},t:function(Ir,Yr,zo,s0,w0){if(Ir>>>=0,zo>>>=0,Yr=ny(Yr>>>0),w0===-1&&(w0=4294967295),w0=Iy=>Iy,s0===0){var O0=32-8*zo;w0=Iy=>Iy<<O0>>>O0}var fy=Yr.includes("unsigned")?function(Iy,sv){return sv>>>0}:function(Iy,sv){return sv};Hy(Ir,{name:Yr,fromWireType:w0,toWireType:fy,argPackAdvance:8,readValueFromPointer:uv(Yr,zo,s0!==0),Bb:null})},p:function(Ir,Yr,zo){function s0(O0){var fy=Gt()[O0>>>2>>>0];return O0=Gt()[O0+4>>>2>>>0],new w0(Tt().buffer,O0,fy)}Ir>>>=0;var w0=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][Yr];zo=ny(zo>>>0),Hy(Ir,{name:zo,fromWireType:s0,argPackAdvance:8,readValueFromPointer:s0},{Ub:!0})},F:function(Ir,Yr){Ir>>>=0,Yr=ny(Yr>>>0);var zo=Yr==="std::string";Hy(Ir,{name:Yr,fromWireType:function(s0){var w0=Gt()[s0>>>2>>>0],O0=s0+4;if(zo)for(var fy=O0,Iy=0;Iy<=w0;++Iy){var sv=O0+Iy;if(Iy==w0||Lt()[sv>>>0]==0){if(fy=X0(fy,sv-fy),Jy===void 0)var Jy=fy;else Jy+="\0",Jy+=fy;fy=sv+1}}else{for(Jy=Array(w0),Iy=0;Iy<w0;++Iy)Jy[Iy]=String.fromCharCode(Lt()[O0+Iy>>>0]);Jy=Jy.join("")}return f_(s0),Jy},toWireType:function(s0,w0){w0 instanceof ArrayBuffer&&(w0=new Uint8Array(w0));var O0=typeof w0=="string";if(!(O0||w0 instanceof Uint8Array||w0 instanceof Uint8ClampedArray||w0 instanceof Int8Array))throw new wy("Cannot pass non-string to std::string");var fy=zo&&O0?Jv(w0):w0.length,Iy=Q1(4+fy+1),sv=Iy+4;if(Gt()[Iy>>>2>>>0]=fy,zo&&O0)_v(w0,sv,fy+1);else if(O0)for(O0=0;O0<fy;++O0){var Jy=w0.charCodeAt(O0);if(255<Jy)throw f_(sv),new wy("String has UTF-16 code units that do not fit in 8 bits");Lt()[sv+O0>>>0]=Jy}else for(O0=0;O0<fy;++O0)Lt()[sv+O0>>>0]=w0[O0];return s0!==null&&s0.push(f_,Iy),Iy},argPackAdvance:8,readValueFromPointer:fv,Bb(s0){f_(s0)}})},z:function(Ir,Yr,zo){if(Ir>>>=0,Yr>>>=0,zo>>>=0,zo=ny(zo),Yr===2)var s0=c1,w0=Gv,O0=Ov,fy=Iy=>Ct()[Iy>>>1>>>0];else Yr===4&&(s0=jy,w0=Av,O0=zy,fy=Iy=>Gt()[Iy>>>2>>>0]);Hy(Ir,{name:zo,fromWireType:Iy=>{for(var sv=Gt()[Iy>>>2>>>0],Jy,wv=Iy+4,a1=0;a1<=sv;++a1){var r1=Iy+4+a1*Yr;(a1==sv||fy(r1)==0)&&(wv=s0(wv,r1-wv),Jy===void 0?Jy=wv:(Jy+="\0",Jy+=wv),wv=r1+Yr)}return f_(Iy),Jy},toWireType:(Iy,sv)=>{if(typeof sv!="string")throw new wy(`Cannot pass non-string to C++ string type ${zo}`);var Jy=O0(sv),wv=Q1(4+Jy+Yr);return Gt()[wv>>>2>>>0]=Jy/Yr,w0(sv,wv+4,Jy+Yr),Iy!==null&&Iy.push(f_,wv),wv},argPackAdvance:8,readValueFromPointer:fv,Bb(Iy){f_(Iy)}})},P:function(Ir,Yr){Ir>>>=0,Yr=ny(Yr>>>0),Hy(Ir,{Vb:!0,name:Yr,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},ta:()=>1,S:function(Ir,Yr){Ir>>>=0,Ir==Yr>>>0?setTimeout(i1):Xo?postMessage({targetThread:Ir,cmd:"checkMailbox"}):(Ir=$0.ub[Ir])&&Ir.postMessage({cmd:"checkMailbox"})},$:function(Ir,Yr,zo,s0,w0){Yr>>>=0,zo>>>=0,s0/=2,S1.length=s0,w0=w0>>>0>>>3;for(var O0=0;O0<s0;O0++)S1[O0]=_0[w0+2*O0]?_0[w0+2*O0+1]:qt()[w0+2*O0+1>>>0];return Ir=Yr?Py[Yr]:kw[Ir],$0.Sb=zo,zo=Ir(...S1),$0.Sb=0,zo},ha:m1,sa:function(Ir){Bo&&$0.ub[Ir>>>0].ref()},w:function(Ir,Yr,zo){return Yr>>>=0,zo>>>=0,Ir=By(Ir>>>0),Yr=J1(Yr,"emval::as"),d_(Yr,zo,Ir)},y:function(Ir){return Ir>>>=0,Oy(()=>(Ir=By(Ir),Ir.then(bv)))},o:function(Ir,Yr,zo,s0){return zo>>>=0,s0>>>=0,Ir=Uy[Ir>>>0],Yr=By(Yr>>>0),Ir(null,Yr,zo,s0)},k:function(Ir,Yr,zo,s0,w0){return zo>>>=0,s0>>>=0,w0>>>=0,Ir=Uy[Ir>>>0],Yr=By(Yr>>>0),zo=Hv(zo),Ir(Yr,Yr[zo],s0,w0)},c:Zy,C:function(Ir,Yr){return Yr>>>=0,Ir=By(Ir>>>0),Yr=By(Yr),Ir==Yr},n:function(Ir){return Ir>>>=0,Ir===0?bv(Q0()):(Ir=Hv(Ir),bv(Q0()[Ir]))},j:function(Ir,Yr,zo){Yr=Yy(Ir,Yr>>>0);var s0=Yr.shift();Ir--;var w0=`return function (obj, func, destructorsRef, args) {
`,O0=0,fy=[];zo===0&&fy.push("obj");for(var Iy=["retType"],sv=[s0],Jy=0;Jy<Ir;++Jy)fy.push("arg"+Jy),Iy.push("argType"+Jy),sv.push(Yr[Jy]),w0+=`  var arg${Jy} = argType${Jy}.readValueFromPointer(args${O0?"+"+O0:""});
`,O0+=Yr[Jy].argPackAdvance;return w0+=`  var rv = ${zo===1?"new func":"func.call"}(${fy.join(", ")});
`,s0.Vb||(Iy.push("emval_returnValue"),sv.push(d_),w0+=`  return emval_returnValue(retType, destructorsRef, rv);
`),Iy.push(w0+`};
`),Ir=Zv(Iy)(...sv),zo=`methodCaller<(${Yr.map(wv=>wv.name).join(", ")}) => ${s0.name}>`,q0(av(zo,Ir))},s:function(Ir,Yr){return Yr>>>=0,Ir=By(Ir>>>0),Yr=By(Yr),bv(Ir[Yr])},d:function(Ir){Ir>>>=0,9<Ir&&(pv[Ir+1]+=1)},v:function(){return bv([])},m:function(Ir){Ir=By(Ir>>>0);for(var Yr=Array(Ir.length),zo=0;zo<Ir.length;zo++)Yr[zo]=Ir[zo];return bv(Yr)},g:function(Ir){return bv(Hv(Ir>>>0))},l:function(){return bv({})},i:function(Ir){Ir>>>=0;for(var Yr=By(Ir);Yr.length;){var zo=Yr.pop();Yr.pop()(zo)}Zy(Ir)},h:function(Ir,Yr,zo){Yr>>>=0,zo>>>=0,Ir=By(Ir>>>0),Yr=By(Yr),zo=By(zo),Ir[Yr]=zo},e:function(Ir,Yr){return Yr>>>=0,Ir=J1(Ir>>>0,"_emval_take_value"),Ir=Ir.readValueFromPointer(Yr),bv(Ir)},ca:function(Ir,Yr){Ir=-9007199254740992>Ir||9007199254740992<Ir?NaN:Number(Ir),Yr>>>=0,Ir=new Date(1e3*Ir),Ht()[Yr>>>2>>>0]=Ir.getUTCSeconds(),Ht()[Yr+4>>>2>>>0]=Ir.getUTCMinutes(),Ht()[Yr+8>>>2>>>0]=Ir.getUTCHours(),Ht()[Yr+12>>>2>>>0]=Ir.getUTCDate(),Ht()[Yr+16>>>2>>>0]=Ir.getUTCMonth(),Ht()[Yr+20>>>2>>>0]=Ir.getUTCFullYear()-1900,Ht()[Yr+24>>>2>>>0]=Ir.getUTCDay(),Ir=(Ir.getTime()-Date.UTC(Ir.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,Ht()[Yr+28>>>2>>>0]=Ir},da:function(Ir,Yr){Ir=-9007199254740992>Ir||9007199254740992<Ir?NaN:Number(Ir),Yr>>>=0,Ir=new Date(1e3*Ir),Ht()[Yr>>>2>>>0]=Ir.getSeconds(),Ht()[Yr+4>>>2>>>0]=Ir.getMinutes(),Ht()[Yr+8>>>2>>>0]=Ir.getHours(),Ht()[Yr+12>>>2>>>0]=Ir.getDate(),Ht()[Yr+16>>>2>>>0]=Ir.getMonth(),Ht()[Yr+20>>>2>>>0]=Ir.getFullYear()-1900,Ht()[Yr+24>>>2>>>0]=Ir.getDay();var zo=(M1(Ir.getFullYear())?R_:Gx)[Ir.getMonth()]+Ir.getDate()-1|0;Ht()[Yr+28>>>2>>>0]=zo,Ht()[Yr+36>>>2>>>0]=-(60*Ir.getTimezoneOffset()),zo=new Date(Ir.getFullYear(),6,1).getTimezoneOffset();var s0=new Date(Ir.getFullYear(),0,1).getTimezoneOffset();Ir=(zo!=s0&&Ir.getTimezoneOffset()==Math.min(s0,zo))|0,Ht()[Yr+32>>>2>>>0]=Ir},ea:function(Ir){Ir>>>=0;var Yr=new Date(Ht()[Ir+20>>>2>>>0]+1900,Ht()[Ir+16>>>2>>>0],Ht()[Ir+12>>>2>>>0],Ht()[Ir+8>>>2>>>0],Ht()[Ir+4>>>2>>>0],Ht()[Ir>>>2>>>0],0),zo=Ht()[Ir+32>>>2>>>0],s0=Yr.getTimezoneOffset(),w0=new Date(Yr.getFullYear(),6,1).getTimezoneOffset(),O0=new Date(Yr.getFullYear(),0,1).getTimezoneOffset(),fy=Math.min(O0,w0);return 0>zo?Ht()[Ir+32>>>2>>>0]=+(w0!=O0&&fy==s0):0<zo!=(fy==s0)&&(w0=Math.max(O0,w0),Yr.setTime(Yr.getTime()+6e4*((0<zo?fy:w0)-s0))),Ht()[Ir+24>>>2>>>0]=Yr.getDay(),zo=(M1(Yr.getFullYear())?R_:Gx)[Yr.getMonth()]+Yr.getDate()-1|0,Ht()[Ir+28>>>2>>>0]=zo,Ht()[Ir>>>2>>>0]=Yr.getSeconds(),Ht()[Ir+4>>>2>>>0]=Yr.getMinutes(),Ht()[Ir+8>>>2>>>0]=Yr.getHours(),Ht()[Ir+12>>>2>>>0]=Yr.getDate(),Ht()[Ir+16>>>2>>>0]=Yr.getMonth(),Ht()[Ir+20>>>2>>>0]=Yr.getYear(),Ir=Yr.getTime(),BigInt(isNaN(Ir)?-1:Ir/1e3)},aa:sw,ba:Ow,R:function(Ir,Yr,zo,s0){Ir>>>=0,Yr>>>=0,zo>>>=0,s0>>>=0;var w0=new Date().getFullYear(),O0=new Date(w0,0,1),fy=new Date(w0,6,1);w0=O0.getTimezoneOffset();var Iy=fy.getTimezoneOffset(),sv=Math.max(w0,Iy);Gt()[Ir>>>2>>>0]=60*sv,Ht()[Yr>>>2>>>0]=+(w0!=Iy),Ir=Jy=>Jy.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],O0=Ir(O0),fy=Ir(fy),Iy<w0?(_v(O0,zo,17),_v(fy,s0,17)):(_v(O0,s0,17),_v(fy,zo,17))},q:()=>{M0("")},f:function(Ir,Yr,zo){return Ir>>>=0,Yr=y_(Yr>>>0,zo>>>0),Py[Ir](...Yr)},M:function(Ir,Yr,zo){return Ir>>>=0,Yr=y_(Yr>>>0,zo>>>0),Py[Ir](...Yr)},H:()=>{},L:()=>Date.now(),ra:()=>{throw cy+=1,"unwind"},T:function(){return 4294901760},u:()=>performance.timeOrigin+performance.now(),x:()=>Bo?(Ua(),sr(Ma)).cpus().length:navigator.hardwareConcurrency,Q:function(Ir){Ir>>>=0;var Yr=Lt().length;if(Ir<=Yr||4294901760<Ir)return!1;for(var zo=1;4>=zo;zo*=2){var s0=Yr*(1+.2/zo);s0=Math.min(s0,Ir+100663296);var w0=Math;s0=Math.max(Ir,s0);e:{w0=(w0.min.call(w0,4294901760,s0+(65536-s0%65536)%65536)-a0.buffer.byteLength+65535)/65536;try{a0.grow(w0),yy();var O0=1;break e}catch{}O0=void 0}if(O0)return!0}return!1},ja:I1,la:wx,Z:o0,B:cx,J:R1,ga:Hx,I:uw,a:a0||Kt.wasmMemory,ka:x_,r:function(Ir,Yr,zo,s0){return x_(Ir>>>0,Yr>>>0,zo>>>0,s0>>>0)}},ov=function(){function Ir(zo,s0){return ov=zo.exports,ov=m_(),ov=G_(),$0.Qb.push(ov.cb),Fy.unshift(ov.va),P0=s0,r0(),ov}var Yr={a:G1};if(rv++,Kt.instantiateWasm)try{return Kt.instantiateWasm(Yr,Ir)}catch(zo){h0(`Module.instantiateWasm callback failed with error: ${zo}`),Sn(zo)}return Ly(Yr,function(zo){Ir(zo.instance,zo.module)}).catch(Sn),{}}(),fx=Ir=>(fx=ov.wa)(Ir);Kt.__embind_initialize_bindings=()=>(Kt.__embind_initialize_bindings=ov.xa)(),Kt._OrtInit=(Ir,Yr)=>(Kt._OrtInit=ov.ya)(Ir,Yr),Kt._OrtGetLastError=(Ir,Yr)=>(Kt._OrtGetLastError=ov.za)(Ir,Yr),Kt._OrtCreateSessionOptions=(Ir,Yr,zo,s0,w0,O0,fy,Iy,sv,Jy)=>(Kt._OrtCreateSessionOptions=ov.Aa)(Ir,Yr,zo,s0,w0,O0,fy,Iy,sv,Jy),Kt._OrtAppendExecutionProvider=(Ir,Yr)=>(Kt._OrtAppendExecutionProvider=ov.Ba)(Ir,Yr),Kt._OrtAddFreeDimensionOverride=(Ir,Yr,zo)=>(Kt._OrtAddFreeDimensionOverride=ov.Ca)(Ir,Yr,zo),Kt._OrtAddSessionConfigEntry=(Ir,Yr,zo)=>(Kt._OrtAddSessionConfigEntry=ov.Da)(Ir,Yr,zo),Kt._OrtReleaseSessionOptions=Ir=>(Kt._OrtReleaseSessionOptions=ov.Ea)(Ir),Kt._OrtCreateSession=(Ir,Yr,zo)=>(Kt._OrtCreateSession=ov.Fa)(Ir,Yr,zo),Kt._OrtReleaseSession=Ir=>(Kt._OrtReleaseSession=ov.Ga)(Ir),Kt._OrtGetInputOutputCount=(Ir,Yr,zo)=>(Kt._OrtGetInputOutputCount=ov.Ha)(Ir,Yr,zo),Kt._OrtGetInputName=(Ir,Yr)=>(Kt._OrtGetInputName=ov.Ia)(Ir,Yr),Kt._OrtGetOutputName=(Ir,Yr)=>(Kt._OrtGetOutputName=ov.Ja)(Ir,Yr),Kt._OrtFree=Ir=>(Kt._OrtFree=ov.Ka)(Ir),Kt._OrtCreateTensor=(Ir,Yr,zo,s0,w0,O0)=>(Kt._OrtCreateTensor=ov.La)(Ir,Yr,zo,s0,w0,O0),Kt._OrtGetTensorData=(Ir,Yr,zo,s0,w0)=>(Kt._OrtGetTensorData=ov.Ma)(Ir,Yr,zo,s0,w0),Kt._OrtReleaseTensor=Ir=>(Kt._OrtReleaseTensor=ov.Na)(Ir),Kt._OrtCreateRunOptions=(Ir,Yr,zo,s0)=>(Kt._OrtCreateRunOptions=ov.Oa)(Ir,Yr,zo,s0),Kt._OrtAddRunConfigEntry=(Ir,Yr,zo)=>(Kt._OrtAddRunConfigEntry=ov.Pa)(Ir,Yr,zo),Kt._OrtReleaseRunOptions=Ir=>(Kt._OrtReleaseRunOptions=ov.Qa)(Ir),Kt._OrtCreateBinding=Ir=>(Kt._OrtCreateBinding=ov.Ra)(Ir),Kt._OrtBindInput=(Ir,Yr,zo)=>(Kt._OrtBindInput=ov.Sa)(Ir,Yr,zo),Kt._OrtBindOutput=(Ir,Yr,zo,s0)=>(Kt._OrtBindOutput=ov.Ta)(Ir,Yr,zo,s0),Kt._OrtClearBoundOutputs=Ir=>(Kt._OrtClearBoundOutputs=ov.Ua)(Ir),Kt._OrtReleaseBinding=Ir=>(Kt._OrtReleaseBinding=ov.Va)(Ir),Kt._OrtRunWithBinding=(Ir,Yr,zo,s0,w0)=>(Kt._OrtRunWithBinding=ov.Wa)(Ir,Yr,zo,s0,w0),Kt._OrtRun=(Ir,Yr,zo,s0,w0,O0,fy,Iy)=>(Kt._OrtRun=ov.Xa)(Ir,Yr,zo,s0,w0,O0,fy,Iy),Kt._OrtEndProfiling=Ir=>(Kt._OrtEndProfiling=ov.Ya)(Ir),Kt._JsepOutput=(Ir,Yr,zo)=>(Kt._JsepOutput=ov.Za)(Ir,Yr,zo),Kt._JsepGetNodeName=Ir=>(Kt._JsepGetNodeName=ov._a)(Ir);var f1=Kt._pthread_self=()=>(f1=Kt._pthread_self=ov.$a)(),Q1=Kt._malloc=Ir=>(Q1=Kt._malloc=ov.ab)(Ir),f_=Kt._free=Ir=>(f_=Kt._free=ov.bb)(Ir);Kt.__emscripten_tls_init=()=>(Kt.__emscripten_tls_init=ov.cb)();var Lw=Kt.__emscripten_thread_init=(Ir,Yr,zo,s0,w0,O0)=>(Lw=Kt.__emscripten_thread_init=ov.eb)(Ir,Yr,zo,s0,w0,O0);Kt.__emscripten_thread_crashed=()=>(Kt.__emscripten_thread_crashed=ov.fb)();var Sx=(Ir,Yr,zo,s0,w0)=>(Sx=ov.gb)(Ir,Yr,zo,s0,w0),Ex=Ir=>(Ex=ov.hb)(Ir),cw=Kt.__emscripten_thread_exit=Ir=>(cw=Kt.__emscripten_thread_exit=ov.ib)(Ir),Nw=()=>(Nw=ov.jb)(),dw=(Ir,Yr)=>(dw=ov.kb)(Ir,Yr),U_=Ir=>(U_=ov.lb)(Ir),p_=Ir=>(p_=ov.mb)(Ir),Y_=()=>(Y_=ov.nb)(),Tx=Kt.dynCall_ii=(Ir,Yr)=>(Tx=Kt.dynCall_ii=ov.pb)(Ir,Yr),Ax=Ir=>(Ax=ov.qb)(Ir),K1=()=>(K1=ov.rb)(),Z1=Ir=>(Z1=ov.sb)(Ir),z_=()=>(z_=ov.tb)();Kt.___start_em_js=839500,Kt.___stop_em_js=839661;function G_(){var Ir=ov;Ir=Object.assign({},Ir);var Yr=s0=>w0=>s0(w0)>>>0,zo=s0=>()=>s0()>>>0;return Ir.wa=Yr(Ir.wa),Ir.$a=zo(Ir.$a),Ir.ab=Yr(Ir.ab),Ir.emscripten_main_runtime_thread_id=zo(Ir.emscripten_main_runtime_thread_id),Ir.mb=Yr(Ir.mb),Ir.nb=zo(Ir.nb),Ir}Kt.wasmMemory=a0,Kt.stackSave=()=>Y_(),Kt.stackRestore=Ir=>U_(Ir),Kt.stackAlloc=Ir=>p_(Ir),Kt.keepRuntimeAlive=()=>0<cy,Kt.UTF8ToString=X0,Kt.stringToUTF8=_v,Kt.lengthBytesUTF8=Jv,Kt.ExitStatus=Sy,Kt.PThread=$0;var e_;y0=function Ir(){e_||P_(),e_||(y0=Ir)};function P_(){if(!(0<rv))if(Xo)An(Kt),Xo||ty(Fy),startWorker(Kt);else{if(Kt.preRun)for(typeof Kt.preRun=="function"&&(Kt.preRun=[Kt.preRun]);Kt.preRun.length;)Dy.unshift(Kt.preRun.shift());ty(Dy),0<rv||e_||(e_=!0,Kt.calledRun=!0,V0||(Xo||ty(Fy),An(Kt),Xo||ty(qy)))}}return P_(),wn}})();typeof st=="object"&&typeof at=="object"?at.exports=pt:typeof define=="function"&&define.amd&&define([],()=>pt)}),Ha=Er((st,at)=>{at.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(...e){var a=e.join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,a+`\n`);return}console.error(a)}function threadAlert(...e){var a=e.join(" ");postMessage({cmd:"alert",text:a,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,a)=>{var r=Module.wasmModule;Module.wasmModule=null;var t=new WebAssembly.Instance(r,e);return a(t)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let r=[];self.onmessage=t=>r.push(t),self.startWorker=t=>{Module=t,postMessage({cmd:"loaded"});for(let s of r)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const t of e.data.handlers)Module[t]=(...s)=>{postMessage({cmd:"callHandler",handler:t,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var a=URL.createObjectURL(e.data.urlOrBlob);importScripts(a),URL.revokeObjectURL(a)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(r){if(r!="unwind")throw r}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(r){throw Module.__emscripten_thread_crashed?.(),r}}self.onmessage=handleMessage;\n'}),La,gc,Hi,Gi,Un,Ga,yc,bc,vc,Fa,Fe,Or=j(()=>{La=za(),gc=Va(),Gi=!1,Un=!1,Ga=!1,yc=st=>{if(st===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+st+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+st+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},bc=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},vc=(st,at)=>st?at?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":at?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Fa=async st=>{if(Gi)return Promise.resolve();if(Un)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Ga)throw new Error("previous call to 'initializeWebAssembly()' failed.");Un=!0;let at=st.initTimeout,pt=st.numThreads,vt=st.simd,wt=yc(pt),$t=vt&&bc(),Tt=st.wasmPaths,Lt=typeof Tt=="string"?Tt:void 0,Ft=vc($t,wt),Ct=typeof Tt=="object"?Tt[Ft]:void 0,Ht=!1,Gt=[];if(at>0&&Gt.push(new Promise(jt=>{setTimeout(()=>{Ht=!0,jt()},at)})),Gt.push(new Promise((jt,qt)=>{let Kt=wt?gc:La,An={locateFile:(Sn,wn)=>{if(wt&&Sn.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Ha()],{type:"text/javascript"}));if(Sn.endsWith(".wasm")){if(Ct)return Ct;let In=Lt??wn;return Ft==="ort-wasm-simd.wasm"?In+"ort-wasm-simd.jsep.wasm":Ft==="ort-wasm-simd-threaded.wasm"?In+"ort-wasm-simd-threaded.jsep.wasm":In+Ft}return wn+Sn}};if(wt)if(An.numThreads=pt,typeof Blob>"u")An.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let Sn=`var ortWasmThreaded=${Kt.toString()};`;An.mainScriptUrlOrBlob=new Blob([Sn],{type:"text/javascript"})}Kt(An).then(Sn=>{Un=!1,Gi=!0,Hi=Sn,jt()},Sn=>{Un=!1,Ga=!0,qt(Sn)})})),await Promise.race(Gt),Ht)throw new Error(`WebAssembly backend initializing failed due to timeout: ${at}ms`)},Fe=()=>{if(Gi&&Hi)return Hi;throw new Error("WebAssembly is not initialized yet.")}}),qe,Jr,We,Wn=j(()=>{Or(),qe=(st,at)=>{let pt=Fe(),vt=pt.lengthBytesUTF8(st)+1,wt=pt._malloc(vt);return pt.stringToUTF8(st,wt,vt),at.push(wt),wt},Jr=(st,at,pt,vt)=>{if(typeof st=="object"&&st!==null){if(pt.has(st))throw new Error("Circular reference in options");pt.add(st)}Object.entries(st).forEach(([wt,$t])=>{let Tt=at?at+wt:wt;if(typeof $t=="object")Jr($t,Tt+".",pt,vt);else if(typeof $t=="string"||typeof $t=="number")vt(Tt,$t.toString());else if(typeof $t=="boolean")vt(Tt,$t?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof $t}`)})},We=st=>{let at=Fe(),pt=at.stackSave();try{let vt=at.stackAlloc(8);at._OrtGetLastError(vt,vt+4);let wt=at.HEAP32[vt/4],$t=at.HEAPU32[vt/4+1],Tt=$t?at.UTF8ToString($t):"";throw new Error(`${st} ERROR_CODE: ${wt}, ERROR_MESSAGE: ${Tt}`)}finally{at.stackRestore(pt)}}}),qa,ja=j(()=>{Or(),Wn(),qa=st=>{let at=Fe(),pt=0,vt=[],wt=st||{};try{if((st==null?void 0:st.logSeverityLevel)===void 0)wt.logSeverityLevel=2;else if(typeof st.logSeverityLevel!="number"||!Number.isInteger(st.logSeverityLevel)||st.logSeverityLevel<0||st.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${st.logSeverityLevel}`);if((st==null?void 0:st.logVerbosityLevel)===void 0)wt.logVerbosityLevel=0;else if(typeof st.logVerbosityLevel!="number"||!Number.isInteger(st.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${st.logVerbosityLevel}`);(st==null?void 0:st.terminate)===void 0&&(wt.terminate=!1);let $t=0;return(st==null?void 0:st.tag)!==void 0&&($t=qe(st.tag,vt)),pt=at._OrtCreateRunOptions(wt.logSeverityLevel,wt.logVerbosityLevel,!!wt.terminate,$t),pt===0&&We("Can't create run options."),(st==null?void 0:st.extra)!==void 0&&Jr(st.extra,"",new WeakSet,(Tt,Lt)=>{let Ft=qe(Tt,vt),Ct=qe(Lt,vt);at._OrtAddRunConfigEntry(pt,Ft,Ct)!==0&&We(`Can't set a run config entry: ${Tt} - ${Lt}.`)}),[pt,vt]}catch($t){throw pt!==0&&at._OrtReleaseRunOptions(pt),vt.forEach(Tt=>at._free(Tt)),$t}}}),wc,$c,_c,xc,Ka,Ya=j(()=>{Or(),Wn(),wc=st=>{switch(st){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${st}`)}},$c=st=>{switch(st){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${st}`)}},_c=st=>{st.extra||(st.extra={}),st.extra.session||(st.extra.session={});let at=st.extra.session;at.use_ort_model_bytes_directly||(at.use_ort_model_bytes_directly="1"),st.executionProviders&&st.executionProviders.some(pt=>(typeof pt=="string"?pt:pt.name)==="webgpu")&&(st.enableMemPattern=!1)},xc=(st,at,pt)=>{for(let vt of at){let wt=typeof vt=="string"?vt:vt.name;switch(wt){case"webnn":if(wt="WEBNN",typeof vt!="string"){let Tt=vt;if(Tt!=null&&Tt.deviceType){let Lt=qe("deviceType",pt),Ft=qe(Tt.deviceType,pt);Fe()._OrtAddSessionConfigEntry(st,Lt,Ft)!==0&&We(`Can't set a session config entry: 'deviceType' - ${Tt.deviceType}.`)}if(Tt!=null&&Tt.numThreads){let Lt=Tt.numThreads;(typeof Lt!="number"||!Number.isInteger(Lt)||Lt<0)&&(Lt=0);let Ft=qe("numThreads",pt),Ct=qe(Lt.toString(),pt);Fe()._OrtAddSessionConfigEntry(st,Ft,Ct)!==0&&We(`Can't set a session config entry: 'numThreads' - ${Tt.numThreads}.`)}if(Tt!=null&&Tt.powerPreference){let Lt=qe("powerPreference",pt),Ft=qe(Tt.powerPreference,pt);Fe()._OrtAddSessionConfigEntry(st,Lt,Ft)!==0&&We(`Can't set a session config entry: 'powerPreference' - ${Tt.powerPreference}.`)}}break;case"webgpu":if(wt="JS",typeof vt!="string"){let Tt=vt;if(Tt!=null&&Tt.preferredLayout){if(Tt.preferredLayout!=="NCHW"&&Tt.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${Tt.preferredLayout}`);let Lt=qe("preferredLayout",pt),Ft=qe(Tt.preferredLayout,pt);Fe()._OrtAddSessionConfigEntry(st,Lt,Ft)!==0&&We(`Can't set a session config entry: 'preferredLayout' - ${Tt.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${wt}`)}let $t=qe(wt,pt);Fe()._OrtAppendExecutionProvider(st,$t)!==0&&We(`Can't append execution provider: ${wt}.`)}},Ka=st=>{let at=Fe(),pt=0,vt=[],wt=st||{};_c(wt);try{let $t=wc(wt.graphOptimizationLevel??"all"),Tt=$c(wt.executionMode??"sequential"),Lt=typeof wt.logId=="string"?qe(wt.logId,vt):0,Ft=wt.logSeverityLevel??2;if(!Number.isInteger(Ft)||Ft<0||Ft>4)throw new Error(`log serverity level is not valid: ${Ft}`);let Ct=wt.logVerbosityLevel??0;if(!Number.isInteger(Ct)||Ct<0||Ct>4)throw new Error(`log verbosity level is not valid: ${Ct}`);let Ht=typeof wt.optimizedModelFilePath=="string"?qe(wt.optimizedModelFilePath,vt):0;if(pt=at._OrtCreateSessionOptions($t,!!wt.enableCpuMemArena,!!wt.enableMemPattern,Tt,!!wt.enableProfiling,0,Lt,Ft,Ct,Ht),pt===0&&We("Can't create session options."),wt.executionProviders&&xc(pt,wt.executionProviders,vt),wt.enableGraphCapture!==void 0){if(typeof wt.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${wt.enableGraphCapture}`);let Gt=qe("enableGraphCapture",vt),jt=qe(wt.enableGraphCapture.toString(),vt);at._OrtAddSessionConfigEntry(pt,Gt,jt)!==0&&We(`Can't set a session config entry: 'enableGraphCapture' - ${wt.enableGraphCapture}.`)}if(wt.freeDimensionOverrides)for(let[Gt,jt]of Object.entries(wt.freeDimensionOverrides)){if(typeof Gt!="string")throw new Error(`free dimension override name must be a string: ${Gt}`);if(typeof jt!="number"||!Number.isInteger(jt)||jt<0)throw new Error(`free dimension override value must be a non-negative integer: ${jt}`);let qt=qe(Gt,vt);at._OrtAddFreeDimensionOverride(pt,qt,jt)!==0&&We(`Can't set a free dimension override: ${Gt} - ${jt}.`)}return wt.extra!==void 0&&Jr(wt.extra,"",new WeakSet,(Gt,jt)=>{let qt=qe(Gt,vt),Kt=qe(jt,vt);at._OrtAddSessionConfigEntry(pt,qt,Kt)!==0&&We(`Can't set a session config entry: ${Gt} - ${jt}.`)}),[pt,vt]}catch($t){throw pt!==0&&at._OrtReleaseSessionOptions(pt),vt.forEach(Tt=>at._free(Tt)),$t}}}),Li,Yt,cr,Nn,en,Vn,Fi,ye=j(()=>{Li=st=>{switch(st){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${st}`)}},Yt=st=>{switch(st){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${st}`)}},cr=st=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][st],Nn=st=>{switch(st){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${st}`)}},en=st=>{switch(st){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${st}`)}},Vn=st=>st==="float32"||st==="float16"||st==="int32"||st==="int64"||st==="uint32"||st==="uint8"||st==="bool",Fi=st=>{switch(st){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${st}`)}}}),tn,qi=j(()=>{tn=async st=>{if(typeof st=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(st))}catch(at){if(at.code==="ERR_FS_FILE_TOO_LARGE"){let pt=(void 0)(st),vt=[];for await(let wt of pt)vt.push(wt);return new Uint8Array(Buffer.concat(vt))}throw at}else{let at=await fetch(st);if(!at.ok)throw new Error(`failed to load external data file: ${st}`);let pt=at.headers.get("Content-Length"),vt=pt?parseInt(pt,10):0;if(vt<1073741824)return new Uint8Array(await at.arrayBuffer());{if(!at.body)throw new Error(`failed to load external data file: ${st}, no response body.`);let wt=at.body.getReader(),$t;try{$t=new ArrayBuffer(vt)}catch(Lt){if(Lt instanceof RangeError){let Ft=Math.ceil(vt/65536);$t=new WebAssembly.Memory({initial:Ft,maximum:Ft}).buffer}else throw Lt}let Tt=0;for(;;){let{done:Lt,value:Ft}=await wt.read();if(Lt)break;let Ct=Ft.byteLength;new Uint8Array($t,Tt,Ct).set(Ft),Tt+=Ct}return new Uint8Array($t,0,vt)}}else return st instanceof Blob?new Uint8Array(await st.arrayBuffer()):st instanceof Uint8Array?st:new Uint8Array(st)}}),Sc,Cc,Xa,Za,Qa,Ic,Ne,Xt=j(()=>{ye(),Sc=["V","I","W","E","F"],Cc=(st,at)=>{console.log(`[${Sc[st]},${new Date().toISOString()}]${at}`)},Qa=(st,at)=>{Xa=st,Za=at},Ic=(st,at)=>{let pt=en(st),vt=en(Xa);pt>=vt&&Cc(pt,typeof at=="function"?at():at)},Ne=(...st)=>{Za&&Ic(...st)}}),Ja,es=j(()=>{ye(),Ja=(st,at)=>new(Nn(at))(st)}),Hn=j(()=>{}),ts,ji,Ki,Tc,Ac,rs,Xi,Yi,is,os=j(()=>{Xt(),Hn(),ts=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),ji=[],Ki=st=>Math.ceil(st/16)*16,Tc=st=>{for(let at=0;at<ji.length;at++){let pt=ji[at];if(st<=pt)return pt}return Math.ceil(st/16)*16},Ac=1,rs=()=>Ac++,Xi=async(st,at,pt,vt)=>{let wt=Ki(pt),$t=st.device.createBuffer({size:wt,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let Tt=st.getCommandEncoder();st.endComputePass(),Tt.copyBufferToBuffer(at,0,$t,0,wt),st.flush(),await $t.mapAsync(GPUMapMode.READ);let Lt=$t.getMappedRange();if(vt){let Ft=vt();return Ft.set(new Uint8Array(Lt,0,pt)),Ft}else return new Uint8Array(Lt.slice(0,pt))}finally{$t.destroy()}},Yi=class{constructor(st){this.backend=st,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map,this.capturedPendingBuffers=new Map;for(let[at]of ts)ji.push(at),this.freeBuffers.set(at,[]),this.freeUniformBuffers.set(at,[])}upload(st,at){let pt=at.buffer,vt=at.byteOffset,wt=at.byteLength,$t=Ki(wt),Tt=this.storageCache.get(st);if(!Tt)throw new Error("gpu data for uploading does not exist");if(Tt.originalSize!==wt)throw new Error(`inconsistent data size. gpu data size=${Tt.originalSize}, data size=${wt}`);let Lt=this.backend.device.createBuffer({mappedAtCreation:!0,size:$t,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),Ft=Lt.getMappedRange();new Uint8Array(Ft).set(new Uint8Array(pt,vt,wt)),Lt.unmap();let Ct=this.backend.getCommandEncoder();this.backend.endComputePass(),Ct.copyBufferToBuffer(Lt,0,Tt.gpuData.buffer,0,$t),Ne("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${st})`),this.buffersForUploadingPending.push(Lt)}memcpy(st,at){let pt=this.storageCache.get(st);if(!pt)throw new Error("source gpu data for memcpy does not exist");let vt=this.storageCache.get(at);if(!vt)throw new Error("destination gpu data for memcpy does not exist");if(pt.originalSize!==vt.originalSize)throw new Error("inconsistent source and destination gpu data size");let wt=Ki(pt.originalSize),$t=this.backend.getCommandEncoder();this.backend.endComputePass(),$t.copyBufferToBuffer(pt.gpuData.buffer,0,vt.gpuData.buffer,0,wt)}registerExternalBuffer(st,at,pt){let vt;if(pt){if(vt=this.externalBuffers.get(pt),vt===void 0)throw new Error("previous buffer is not registered");if(st===pt)return Ne("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${at}) => id=${vt}, buffer is the same, skip.`),vt;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);this.externalBuffers.delete(pt)}else vt=rs();return this.storageCache.set(vt,{gpuData:{id:vt,type:0,buffer:st},originalSize:at}),this.externalBuffers.set(st,vt),Ne("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${at}) => id=${vt}, registered.`),vt}unregisterExternalBuffer(st){let at=this.externalBuffers.get(st);at!==void 0&&(this.storageCache.delete(at),this.externalBuffers.delete(st),Ne("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${at}`))}create(st,at=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let pt=Tc(st),vt,wt=(at&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,$t=(at&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(wt||$t){let Lt=(wt?this.freeBuffers:this.freeUniformBuffers).get(pt);Lt?Lt.length>0?vt=Lt.pop():vt=this.backend.device.createBuffer({size:pt,usage:at}):vt=this.backend.device.createBuffer({size:pt,usage:at})}else vt=this.backend.device.createBuffer({size:pt,usage:at});let Tt={id:rs(),type:0,buffer:vt};return this.storageCache.set(Tt.id,{gpuData:Tt,originalSize:st}),Ne("verbose",()=>`[WebGPU] GpuDataManager.create(size=${st}) => id=${Tt.id}`),Tt}get(st){var at;return(at=this.storageCache.get(st))==null?void 0:at.gpuData}release(st){let at=this.storageCache.get(st);if(!at)throw new Error("releasing data does not exist");return Ne("verbose",()=>`[WebGPU] GpuDataManager.release(id=${st}), gpuDataId=${at.gpuData.id}`),this.storageCache.delete(st),this.buffersPending.push(at.gpuData.buffer),at.originalSize}async download(st,at){let pt=this.storageCache.get(st);if(!pt)throw new Error("data does not exist");await Xi(this.backend,pt.gpuData.buffer,pt.originalSize,at)}refreshPendingBuffers(){for(let st of this.buffersForUploadingPending)st.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let st of this.buffersPending){let at=ts.get(st.size);if((st.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let pt=this.freeBuffers.get(st.size)||[];at===void 0||pt.length>=at?st.destroy():pt.push(st)}else if((st.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let pt=this.freeUniformBuffers.get(st.size)||[];at===void 0||pt.length>=at?st.destroy():pt.push(st)}else st.destroy()}this.buffersPending=[]}else{let st=this.capturedPendingBuffers.get(this.backend.currentSessionId);st||(st=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,st));for(let at of this.buffersPending)st.push(at);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(st=>{st.forEach(at=>{at.destroy()})}),this.freeUniformBuffers.forEach(st=>{st.forEach(at=>{at.destroy()})}),this.storageCache.forEach(st=>{st.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(st=>{st.forEach(at=>{at.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onReleaseSession(st){let at=this.capturedPendingBuffers.get(st);at&&(at.forEach(pt=>{pt.destroy()}),this.capturedPendingBuffers.delete(st))}},is=(...st)=>new Yi(...st)}),Zi,we,Ze=j(()=>{Zi=class{constructor(st){Object.assign(this,st)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(st=>`${this[st]}`).join(";")),this.key}},we=st=>new Zi(st)}),Qi,zt,M,pr,Gn,Ln,Fn,xe=j(()=>{Qi=class{static calcMatMulShape(st,at){return st[1]!==at[0]?void 0:[st[0],at[1]]}},zt=class{static calcShape(st,at,pt=!1){let vt=st.length,wt=at.length;if(vt===0)return at;if(wt===0)return st;let $t=Math.max(st.length,at.length),Tt=new Array($t);if(pt){if(vt<2||wt<2)return;let Lt=Qi.calcMatMulShape([st[vt-2],st[vt-1]],[at[wt-2],at[wt-1]]);if(Lt===void 0)return;[Tt[$t-2],Tt[$t-1]]=Lt}for(let Lt=pt?3:1;Lt<=$t;Lt++){let Ft=vt-Lt<0?1:st[vt-Lt],Ct=wt-Lt<0?1:at[wt-Lt];if(Ft!==Ct&&Ft>1&&Ct>1)return;let Ht=Math.max(Ft,Ct);if(Ft&&Ct)Tt[$t-Lt]=Math.max(Ft,Ct);else{if(Ht>1)return;Tt[$t-Lt]=0}}return Tt}static isValidBroadcast(st,at){let pt=st.length,vt=at.length;if(pt>vt)return!1;for(let wt=1;wt<=pt;wt++)if(st[pt-wt]!==1&&st[pt-wt]!==at[vt-wt])return!1;return!0}},M=class vS{static size(at){return vS.getSizeFromDimensionRange(at,0,at.length)}static convertShape(at,pt=4){let vt=at.length;if(vt===0)return[];let wt=new Array(vt),$t=vt-1;for(;$t>=0;){if(at[$t]%pt===0){wt[$t]=at[$t]/pt;break}if(pt%at[$t]!==0)throw new Error("cannot convert shape");wt[$t]=1,pt/=at[$t],$t--}for($t--;$t>=0;$t--)wt[$t]=at[$t];return wt}static sizeFromDimension(at,pt){if(pt<0||pt>at.length)throw new Error(`invalid dimension of ${pt} for sizeFromDimension as Tensor has ${at.length} dimensions.`);return vS.getSizeFromDimensionRange(at,pt,at.length)}static sizeToDimension(at,pt){if(pt<0||pt>at.length)throw new Error(`invalid dimension of ${pt} for sizeToDimension as Tensor has ${at.length} dimensions.`);return vS.getSizeFromDimensionRange(at,0,pt)}static getSizeFromDimensionRange(at,pt,vt){let wt=1;for(let $t=pt;$t<vt;$t++){if(at[$t]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");wt*=at[$t]}return wt}static computeStrides(at){let pt=at.length;if(pt===0)return[];if(pt===1)return[1];let vt=new Array(pt);vt[pt-1]=1,vt[pt-2]=at[pt-1];for(let wt=pt-3;wt>=0;--wt)vt[wt]=vt[wt+1]*at[wt+1];return vt}static normalizeAxis(at,pt){if(at<-pt&&at>=pt)throw new Error("unsupported axis for this operation.");return at<0?at+pt:at}static normalizeAxes(at,pt){return at.map(vt=>this.normalizeAxis(vt,pt??at.length))}static sortBasedOnPerm(at,pt){return pt?pt.map(vt=>at[vt]):at.slice().reverse()}static padShape(at,pt){let vt=at.length;return at.map((wt,$t)=>wt+pt[$t]+pt[$t+vt])}static areEqual(at,pt){return at.length!==pt.length?!1:at.every((vt,wt)=>vt===pt[wt])}},pr=class x${static adjustPoolAttributes(at,pt,vt,wt,$t,Tt){if(!at&&vt.length!==pt.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(at)for(let Lt=0;Lt<pt.length-2;Lt++)Lt>=vt.length?vt.push(pt[Lt+2]):vt[Lt]=pt[Lt+2];for(let Lt=0;Lt<vt.length;Lt++)if(Lt<wt.length){if(wt[Lt]<0)throw new Error("strides should be greater than or equal to 1")}else wt.push(1);for(let Lt=0;Lt<vt.length;Lt++)if(Lt<$t.length){if($t[Lt]<0)throw new Error("dilations should be greater than or equal to 1")}else $t.push(1);for(let Lt=0;Lt<vt.length*2;Lt++)if(Lt<Tt.length){if(Tt[Lt]<0)throw new Error("pad should be greater than or equal to 1")}else Tt.push(0);for(let Lt=0;Lt<vt.length;Lt++){if(vt[Lt]<=0)throw new Error("kernel shapes need to be greater than 0");if(Tt[Lt]>=vt[Lt]||Tt[Lt+vt.length]>=vt[Lt])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(at,pt,vt,wt,$t,Tt,Lt){if(Lt){if($t.length!==2*(at.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(pt.length!==at.length-2)throw new Error("length of strides should be the length of data dimensions");if(wt.length!==at.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let Ft=0;Ft<at.length-2;Ft++)x$.adjustPadAndReturnShape(at[Ft+(Tt?1:2)],pt[Ft],vt[Ft],wt[Ft],$t,Ft,Ft+at.length-2,Lt)}}static computePoolOutputShape(at,pt,vt,wt,$t,Tt,Lt){if(pt.length<=0)throw new Error("input shape must be of size greater than 0");let Ft=[pt[0],pt[1]];return x$.computeShapeHelper(at,pt,Ft,vt,wt,$t,Tt,Lt),Ft}static computeConvOutputShape(at,pt,vt,wt,$t,Tt,Lt){if(at.length<=0||pt.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let Ft=[at[0],pt[0]];return x$.computeShapeHelper(!1,at,Ft,vt,wt,$t,Tt,Lt),Ft}static computeShapeHelper(at,pt,vt,wt,$t,Tt,Lt,Ft){if(at)for(let Ct=0;Ct<pt.length-2;Ct++)vt.push(1);else for(let Ct=0;Ct<pt.length-2;Ct++)vt.push(x$.adjustPadAndReturnShape(pt[Ct+2],wt[Ct],$t[Ct],Tt[Ct],Lt,Ct,Ct+pt.length-2,Ft))}static adjustPadAndReturnShape(at,pt,vt,wt,$t,Tt,Lt,Ft){let Ct=vt*(wt-1)+1;if(Ft&&Ft!=="NOTSET")switch(Ft){case"VALID":return $t[Tt]=0,$t[Lt]=0,Math.floor((at-Ct)/pt+1);case"SAME_LOWER":case"SAME_UPPER":if(vt!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let Ht=((at+pt-1)/pt-1)*pt+wt-at;return $t[Tt]=Math.floor(Ft==="SAME_LOWER"?(Ht+1)/2:Ht/2),$t[Lt]=Ht-$t[Tt],Math.floor((at+Ht-wt)/pt+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((at+$t[Tt]+$t[Lt]-Ct)/pt+1)}},Gn=class{static getShapeOfGemmResult(st,at,pt,vt,wt){if(st.length!==2||pt.length!==2)throw new Error("shape need to be of size 2");let $t,Tt,Lt;at?($t=st[1],Tt=st[0]):($t=st[0],Tt=st[1]);let Ft=-1;if(vt?(Lt=pt[0],Ft=1):(Lt=pt[1],Ft=0),pt[Ft]!==Tt)throw new Error("dimension mismatch");if($t<=0||Lt<=0||Tt<=0)throw new Error("invalid shape specified");if(wt&&!zt.isValidBroadcast(wt,[$t,Lt]))throw new Error("gemm: invalid bias shape for broadcast");return[$t,Lt,Tt]}},Ln=-34028234663852886e22,Fn=34028234663852886e22}),mr,eo,De,rt,X,Ue,At,fr,Et,fe,to,U,K,qn,Ji,as,Pr,_e=j(()=>{ye(),xe(),mr=64,eo=(st,at)=>{if(at===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(st){case 10:return at>1?`vec${at}<f16>`:"f16";case 1:return at>1?`vec${at}<f32>`:"f32";case 6:return at>1?`vec${at}<i32>`:"i32";case 12:return at>1?`vec${at}<u32>`:"u32";case 7:if(at>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(at>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(at!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${st}`)}},De=(st,at=1)=>{let pt=eo(st,at);return typeof pt=="string"?pt:pt[0]},rt=(st,at=1)=>{let pt=eo(st,at);return typeof pt=="string"?pt:pt[1]},X=(...st)=>{let at=[];return st.forEach(pt=>{pt.length!==0&&at.push({type:12,data:pt},{type:12,data:M.computeStrides(pt)})}),at},Ue=st=>st%4===0?4:st%2===0?2:1,At=(st="f32",at,pt="0")=>!at||at===1?`${st}(${pt})`:`vec${at}<${st}>(${pt})`,fr=(st,at,pt)=>st==="f32"?pt:at===1?`f32(${pt})`:`vec${at}<f32>(${pt})`,Et=(st,at)=>at===4?`(${st}.x + ${st}.y + ${st}.z + ${st}.w)`:at===2?`(${st}.x + ${st}.y)`:at===3?`(${st}.x + ${st}.y + ${st}.z)`:st,fe=(st,at,pt,vt)=>st.startsWith("uniforms.")&&pt>4?typeof at=="string"?vt==="f16"?`${st}[(${at}) / 8][(${at}) % 8 / 4][(${at}) % 8 % 4]`:`${st}[(${at}) / 4][(${at}) % 4]`:vt==="f16"?`${st}[${Math.floor(at/8)}][${Math.floor(at%8/4)}][${at%8%4}]`:`${st}[${Math.floor(at/4)}][${at%4}]`:pt>1?`${st}[${at}]`:st,to=(st,at,pt,vt,wt)=>{let $t=typeof pt=="number",Tt=$t?pt:pt.length,Lt=[...new Array(Tt).keys()],Ft=Tt<2?"u32":Tt<=4?`vec${Tt}<u32>`:`array<u32, ${Tt}>`,Ct=eo(at,wt),Ht=typeof Ct=="string"?Ct:Ct[1],Gt=typeof Ct=="string"?Ct:Ct[0],jt={indices:Ft,value:Ht,storage:Gt,tensor:at},qt=a0=>typeof a0=="string"?a0:`${a0}u`,Kt={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},An=$t?"uniforms.":"",Sn=`${An}${st}_shape`,wn=`${An}${st}_strides`,In="";for(let a0=0;a0<Tt-1;a0++)In+=`
    let dim${a0} = current / ${fe(wn,a0,Tt)};
    let rest${a0} = current % ${fe(wn,a0,Tt)};
    indices[${a0}] = dim${a0};
    current = rest${a0};
    `;In+=`indices[${Tt-1}] = current;`;let tr=Tt<2?"":`
  fn o2i_${st}(offset: u32) -> ${jt.indices} {
    var indices: ${jt.indices};
    var current = offset;
    ${In}
    return indices;
  }`,rr=a0=>(Kt.offsetToIndices=!0,Tt<2?a0:`o2i_${st}(${a0})`),Hr=[];if(Tt>=2)for(let a0=Tt-1;a0>=0;a0--)Hr.push(`${fe(wn,a0,Tt)} * (indices[${a0}])`);let qr=Tt<2?"":`
  fn i2o_${st}(indices: ${jt.indices}) -> u32 {
    return ${Hr.join("+")};
  }`,Zr=a0=>(Kt.indicesToOffset=!0,Tt<2?a0:`i2o_${st}(${a0})`),Bo=(...a0)=>Tt===0?"0u":`${jt.indices}(${a0.map(qt).join(",")})`,Xo=(a0,P0)=>Tt<2?`${a0}`:`${fe(a0,P0,Tt)}`,Kr=(a0,P0,V0)=>Tt<2?`${a0}=${V0};`:`${fe(a0,P0,Tt)}=${V0};`,ko={},f0=(a0,P0)=>{Kt.broadcastedIndicesToOffset=!0;let V0=`${P0.name}broadcastedIndicesTo${st}Offset`;if(V0 in ko)return`${V0}(${a0})`;let B0=[];for(let W0=Tt-1;W0>=0;W0--){let K0=P0.indicesGet("outputIndices",W0+P0.rank-Tt);B0.push(`${Xo(wn,W0)} * (${K0} % ${Xo(Sn,W0)})`)}return ko[V0]=`fn ${V0}(outputIndices: ${P0.type.indices}) -> u32 {
             return ${B0.length>0?B0.join("+"):"0u"};
           }`,`${V0}(${a0})`},x0=(a0,P0)=>(()=>{if(jt.storage===jt.value)return`${st}[${a0}]=${P0};`;if(jt.storage==="vec2<u32>"&&jt.value==="i32")return`${st}[${a0}]=vec2<u32>(u32(${P0}), select(0u, 0xFFFFFFFFu, ${P0} < 0));`;if(jt.storage==="vec2<u32>"&&jt.value==="u32")return`${st}[${a0}]=vec2<u32>(u32(${P0}), 0u);`;if(jt.storage==="u32"&&jt.value==="vec4<bool>")return`${st}[${a0}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${P0}));`;throw new Error(`not supported combination of storage type ${jt.storage} and value type ${jt.value} yet`)})(),l0=a0=>(()=>{if(jt.storage===jt.value)return`${st}[${a0}]`;if(jt.storage==="vec2<u32>"&&jt.value==="i32")return`i32(${st}[${a0}].x)`;if(jt.storage==="vec2<u32>"&&jt.value==="u32")return`u32(${st}[${a0}].x)`;if(jt.storage==="u32"&&jt.value==="vec4<bool>")return`vec4<bool>(bool(${st}[${a0}] & 0xFFu), bool(${st}[${a0}] & 0xFF00u), bool(${st}[${a0}] & 0xFF0000u), bool(${st}[${a0}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${jt.storage} and value type ${jt.value} yet`)})(),T0=Tt<2?"":`
  fn get_${st}ByIndices(indices: ${jt.indices}) -> ${Ht} {
    return ${l0(`i2o_${st}(indices)`)};
  }`,t0=Tt<2?"":(()=>{let a0=Lt.map(V0=>`d${V0}: u32`).join(", "),P0=Lt.map(V0=>`d${V0}`).join(", ");return`
  fn get_${st}(${a0}) -> ${Ht} {
    return get_${st}ByIndices(${Bo(P0)});
  }`})(),E0=(...a0)=>{if(a0.length!==Tt)throw new Error(`indices length must be ${Tt}`);let P0=a0.map(qt).join(",");return Tt===0?l0("0u"):Tt===1?l0(P0[0]):(Kt.get=!0,Kt.getByIndices=!0,Kt.indicesToOffset=!0,`get_${st}(${P0})`)},n0=a0=>Tt<2?l0(a0):(Kt.getByIndices=!0,Kt.indicesToOffset=!0,`get_${st}ByIndices(${a0})`),m0=Tt<2?"":`
  fn set_${st}ByIndices(indices: ${jt.indices}, value: ${Ht}) {
    ${x0(`i2o_${st}(indices)`,"value")}
  }`,h0=Tt<2?"":(()=>{let a0=Lt.map(V0=>`d${V0}: u32`).join(", "),P0=Lt.map(V0=>`d${V0}`).join(", ");return`
  fn set_${st}(${a0}, value: ${Ht}) {
    set_${st}ByIndices(${Bo(P0)}, value);
  }`})();return{impl:()=>{let a0=[],P0=!1;return Kt.offsetToIndices&&(a0.push(tr),P0=!0),Kt.indicesToOffset&&(a0.push(qr),P0=!0),Kt.broadcastedIndicesToOffset&&(Object.values(ko).forEach(V0=>a0.push(V0)),P0=!0),Kt.set&&(a0.push(h0),P0=!0),Kt.setByIndices&&(a0.push(m0),P0=!0),Kt.get&&(a0.push(t0),P0=!0),Kt.getByIndices&&(a0.push(T0),P0=!0),!$t&&P0&&a0.unshift(`const ${Sn} = ${jt.indices}(${pt.join(",")});`,`const ${wn} = ${jt.indices}(${M.computeStrides(pt).join(",")});`),a0.join(`
`)},type:jt,offsetToIndices:rr,indicesToOffset:Zr,broadcastedIndicesToOffset:f0,indices:Bo,indicesGet:Xo,indicesSet:Kr,set:(...a0)=>{if(a0.length!==Tt+1)throw new Error(`indices length must be ${Tt}`);let P0=a0[Tt];if(typeof P0!="string")throw new Error("value must be string");let V0=a0.slice(0,Tt).map(qt).join(",");return Tt===0?x0("0u",P0):Tt===1?x0(V0[0],P0):(Kt.set=!0,Kt.setByIndices=!0,Kt.indicesToOffset=!0,`set_${st}(${V0}, ${P0})`)},setByOffset:x0,setByIndices:(a0,P0)=>Tt<2?x0(a0,P0):(Kt.setByIndices=!0,Kt.indicesToOffset=!0,`set_${st}ByIndices(${a0}, ${P0});`),get:E0,getByOffset:l0,getByIndices:n0,usage:vt,name:st,strides:wn,shape:Sn,rank:Tt}},U=(st,at,pt,vt=1)=>to(st,at,pt,"input",vt),K=(st,at,pt,vt=1)=>to(st,at,pt,"output",vt),qn=(st,at,pt,vt=1)=>to(st,at,pt,"internal",vt),Ji=class{constructor(st,at){this.normalizedDispatchGroup=st,this.limits=at,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(st){return`if (global_idx >= ${typeof st=="number"?`${st}u`:st}) { return; }`}mainStart(st=mr){let at=typeof st=="number"?st:st[0],pt=typeof st=="number"?1:st[1],vt=typeof st=="number"?1:st[2];if(at>this.limits.maxComputeWorkgroupSizeX||pt>this.limits.maxComputeWorkgroupSizeY||vt>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${at}, ${pt}, ${vt}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(at*pt*vt>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${at}, ${pt}, ${vt}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let wt=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,$t=wt?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,Tt=wt?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${at*pt*vt}u + local_idx;`;return`@compute @workgroup_size(${at}, ${pt}, ${vt})
  fn main(${$t}) {
    ${Tt}
  `}appendVariableUniforms(st){st.rank!==0&&(st.shape.startsWith("uniforms.")&&this.uniforms.push({name:st.shape.replace("uniforms.",""),type:"u32",length:st.rank}),st.strides.startsWith("uniforms.")&&this.uniforms.push({name:st.strides.replace("uniforms.",""),type:"u32",length:st.rank}))}declareVariable(st,at){if(st.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(st),this.appendVariableUniforms(st);let pt=st.usage==="input"?"read":"read_write",vt=st.type.storage;return`@group(0) @binding(${at}) var<storage, ${pt}> ${st.name}: array<${vt}>;`}declareVariables(...st){return st.map(at=>this.declareVariable(at,this.variableIndex++)).join(`
`)}registerInternalVariable(st){if(st.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(st),this.appendVariableUniforms(st)}registerInternalVariables(...st){return st.forEach(at=>this.registerInternalVariable(at)),this}registerUniform(st,at,pt=1){return this.uniforms.push({name:st,type:at,length:pt}),this}registerUniforms(st){return this.uniforms=this.uniforms.concat(st),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let st=[];for(let{name:at,type:pt,length:vt}of this.uniforms)if(vt&&vt>4)pt==="f16"?st.push(`@align(16) ${at}:array<mat2x4<${pt}>, ${Math.ceil(vt/8)}>`):st.push(`${at}:array<vec4<${pt}>, ${Math.ceil(vt/4)}>`);else{let wt=vt==null||vt===1?pt:`vec${vt}<${pt}>`;st.push(`${at}:${wt}`)}return`
      struct Uniforms { ${st.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(st=>st.impl()).join(`
`)+this.internalVariables.map(st=>st.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let st=at=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(at)];return this.uniforms.map(at=>[st(at.type),at.length??1])}},as=(st,at)=>new Ji(st,at),Pr=(st,at)=>{let pt=st.length,vt=[];for(let wt=0;wt<pt;wt++){let $t=pt-1-wt,Tt=st[$t]||1;(at[at.length-1-wt]||1)>1&&Tt===1&&vt.unshift($t)}return vt}}),Ec,ss,kc,Oc,xt,us,ls,Rr=j(()=>{ye(),xe(),Ze(),_e(),Ec=st=>{if(!st||st.length!==1)throw new Error("Transpose requires 1 input.")},ss=(st,at)=>at&&at.length!==st?[...new Array(st).keys()].reverse():at,kc=(st,at)=>M.sortBasedOnPerm(st,ss(st.length,at)),Oc=(st,at,pt,vt)=>{let wt=[];wt.push(`fn perm(i: ${vt.type.indices}) -> ${pt.type.indices} {
    var a: ${pt.type.indices};`);for(let $t=0;$t<at;++$t)wt.push(pt.indicesSet("a",st[$t],`i[${$t}]`));return wt.push("return a;}"),wt.join(`
`)},xt=(st,at)=>{let pt=st.dataType,vt=st.dims.length,wt=ss(vt,at),$t=kc(st.dims,wt),Tt=K("output",pt,$t.length),Lt=U("a",pt,vt),Ft=Ct=>`
  ${Ct.registerUniform("output_size","u32").declareVariables(Lt,Tt)}

  ${Oc(wt,vt,Lt,Tt)}

  ${Ct.mainStart()}
    ${Ct.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${Tt.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${Tt.setByOffset("global_idx",Lt.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${at}`,inputDependencies:["rank"]},getRunData:Ct=>{let Ht=M.size($t);return{outputs:[{dims:$t,dataType:Ct[0].dataType}],dispatchGroup:{x:Math.ceil(Ht/64)},programUniforms:[{type:12,data:Ht},...X(Ct[0].dims,$t)]}},getShaderSource:Ft}},us=(st,at)=>{Ec(st.inputs),st.compute(xt(st.inputs[0],at.perm))},ls=st=>we({perm:st.perm})}),Pc,Rc,zc,Bc,Dc,Mc,Uc,Wc,Nc,Vc,Bt,ds,cs,ps,ms,fs,hs,gs,ys,bs,vs,ws=j(()=>{ye(),xe(),_e(),jn(),Rr(),Pc={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Rc={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},zc={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Bc={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Dc=(st,at)=>{let pt=[];for(let vt=at-st;vt<at;++vt)pt.push(vt);return pt},Mc=(st,at)=>{let pt=[],vt=st.length;for(let $t=0;$t<vt;$t++)at.indexOf($t)===-1&&pt.push(st[$t]);let wt=at.map($t=>st[$t]);return[pt,wt]},Uc=(st,at)=>{let pt=st.length+at.length,vt=[],wt=0;for(let $t=0;$t<pt;$t++)at.indexOf($t)===-1?vt.push(st[wt++]):vt.push(1);return vt},Wc=(st,at)=>{for(let pt=0;pt<st.length;++pt)if(st[st.length-pt-1]!==at-1-pt)return!1;return!0},Nc=(st,at)=>{let pt=[];if(!Wc(st,at)){for(let vt=0;vt<at;++vt)st.indexOf(vt)===-1&&pt.push(vt);st.forEach(vt=>pt.push(vt))}return pt},Vc=(st,at,pt,vt,wt,$t,Tt)=>{let Lt=pt[0].dims,Ft=M.size($t),Ct=M.size(Tt),Ht=U("_A",pt[0].dataType,Lt),Gt=K("output",wt,$t),jt=32,qt=`
          var<workgroup> aBestValues : array<f32, ${jt}>;
       `;return{name:st,shaderCache:at,getShaderSource:Kt=>`
        ${Kt.registerUniform("reduceSize","u32").declareVariables(Ht,Gt)}
        ${qt}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${Kt.mainStart(jt)}

          let outputIndex = global_idx / ${jt};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${zc[vt]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${jt}) {
           let candidate = f32(${Ht.getByOffset("offset + k")});
           bestValue = ${Pc[vt]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${jt}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${Rc[vt]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${Gt.setByOffset("outputIndex",`${vt==="mean"?`${Gt.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${Gt.type.storage}(${Bc[vt]})`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:$t,dataType:wt}],dispatchGroup:{x:Ft},programUniforms:[{type:12,data:Ct}]})}},Bt=(st,at,pt,vt)=>{let wt=st.inputs.length===1?pt:ro(st.inputs,pt),$t=wt.axes;$t.length===0&&!wt.noopWithEmptyAxes&&($t=st.inputs[0].dims.map((qt,Kt)=>Kt));let Tt=M.normalizeAxes($t,st.inputs[0].dims.length),Lt=Tt,Ft=st.inputs[0],Ct=Nc(Lt,st.inputs[0].dims.length);Ct.length>0&&(Ft=st.compute(xt(st.inputs[0],Ct),{inputs:[0],outputs:[-1]})[0],Lt=Dc(Lt.length,Ft.dims.length));let[Ht,Gt]=Mc(Ft.dims,Lt),jt=Ht;wt.keepDims&&(jt=Uc(Ht,Tt)),st.compute(Vc(at,{hint:wt.cacheKey,inputDependencies:["type"]},[Ft],vt,st.inputs[0].dataType,jt,Gt),{inputs:[Ft]})},ds=(st,at)=>{Bt(st,"ReduceMeanShared",at,"mean")},cs=(st,at)=>{Bt(st,"ReduceL1Shared",at,"l1")},ps=(st,at)=>{Bt(st,"ReduceL2Shared",at,"l2")},ms=(st,at)=>{Bt(st,"ReduceLogSumExpShared",at,"logSumExp")},fs=(st,at)=>{Bt(st,"ReduceMaxShared",at,"max")},hs=(st,at)=>{Bt(st,"ReduceMinShared",at,"min")},gs=(st,at)=>{Bt(st,"ReduceProdShared",at,"prod")},ys=(st,at)=>{Bt(st,"ReduceSumShared",at,"sum")},bs=(st,at)=>{Bt(st,"ReduceSumSquareShared",at,"sumSquare")},vs=(st,at)=>{Bt(st,"ReduceLogSumShared",at,"logSum")}}),Dt,Hc,Kn,ro,Mt,Gc,Lc,Fc,qc,jc,Kc,Yc,Xc,Zc,Qc,Ut,$s,_s,xs,Ss,Cs,Is,Ts,As,Es,ks,jn=j(()=>{ye(),xe(),Ze(),_e(),ws(),Dt=st=>{if(!st||st.length===0||st.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(st.length===2&&st[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Hc=st=>["","",`var value = ${st.getByIndices("input_indices")};`,""],Kn=(st,at,pt,vt,wt,$t,Tt=!1,Lt=!1)=>{let Ft=[],Ct=pt[0].dims,Ht=Ct.length,Gt=M.normalizeAxes(wt,Ht),jt=!Lt&&Gt.length===0;Ct.forEach((An,Sn)=>{jt||Gt.indexOf(Sn)>=0?Tt&&Ft.push(1):Ft.push(An)});let qt=Ft.length,Kt=M.size(Ft);return{name:st,shaderCache:at,getShaderSource:An=>{let Sn=[],wn=U("_A",pt[0].dataType,Ht),In=K("output",$t,qt),tr=vt(wn,In,Gt),rr=tr[2];for(let Hr=0,qr=0;Hr<Ht;Hr++)jt||Gt.indexOf(Hr)>=0?(Tt&&qr++,rr=`for(var j${Hr}: u32 = 0; j${Hr} < ${Ct[Hr]}; j${Hr}++) {
                  ${tr[2].includes("last_index")?`let last_index = j${Hr};`:""}
                  ${wn.indicesSet("input_indices",Hr,`j${Hr}`)}
                  ${rr}
                }`):(Sn.push(`${wn.indicesSet("input_indices",Hr,In.indicesGet("output_indices",qr))};`),qr++);return`

        ${An.registerUniform("output_size","u32").declareVariables(wn,In)}

        ${An.mainStart()}
          ${An.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${wn.type.indices};
          let output_indices = ${In.offsetToIndices("global_idx")};

          ${Sn.join(`
`)}
          ${tr[0]}       // init ops for reduce max/min
          ${tr[1]}
          ${rr}
          ${tr[3]}
          ${tr.length===4?In.setByOffset("global_idx","value"):tr.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:Ft,dataType:$t}],dispatchGroup:{x:Math.ceil(Kt/64)},programUniforms:[{type:12,data:Kt},...X(Ct,Ft)]})}},ro=(st,at)=>{let pt=[];return st[1].dims[0]>0&&st[1].getBigInt64Array().forEach(vt=>pt.push(Number(vt))),we({axes:pt,keepDims:at.keepDims,noopWithEmptyAxes:at.noopWithEmptyAxes})},Mt=(st,at,pt,vt)=>{let wt=st.inputs,$t=wt.length===1?pt:ro(wt,pt);st.compute(Kn(at,{hint:$t.cacheKey,inputDependencies:["rank"]},[wt[0]],$t.noopWithEmptyAxes&&$t.axes.length===0?Hc:vt,$t.axes,wt[0].dataType,$t.keepDims,$t.noopWithEmptyAxes),{inputs:[0]})},Gc=(st,at)=>{Dt(st.inputs),Mt(st,"ReduceLogSum",at,(pt,vt)=>[`var value = ${vt.type.storage}(0);`,"",`value += ${pt.getByIndices("input_indices")};`,"value = log(value);"])},Lc=(st,at)=>{Dt(st.inputs),Mt(st,"ReduceL1",at,(pt,vt)=>[`var value = ${vt.type.storage}(0);`,"",`value += abs(${pt.getByIndices("input_indices")});`,""])},Fc=(st,at)=>{Dt(st.inputs),Mt(st,"ReduceL2",at,(pt,vt)=>[`var t = ${vt.type.value}(0); var value = ${vt.type.value}(0);`,"",`t = ${pt.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},qc=(st,at)=>{Dt(st.inputs),Mt(st,"ReduceLogSumExp",at,(pt,vt)=>[`var value = ${vt.type.storage}(0);`,"",`value += exp(${pt.getByIndices("input_indices")});`,"value = log(value);"])},jc=(st,at)=>{Dt(st.inputs),Mt(st,"ReduceMax",at,(pt,vt,wt)=>{let $t=[];for(let Tt=0;Tt<pt.rank;Tt++)(wt.indexOf(Tt)>=0||wt.length===0)&&$t.push(pt.indicesSet("input_indices",Tt,0));return[`${$t.join(`
`)}`,`var value = ${pt.getByIndices("input_indices")};`,`value = max(value, ${pt.getByIndices("input_indices")});`,""]})},Kc=(st,at)=>{Dt(st.inputs),Mt(st,"ReduceMean",at,(pt,vt,wt)=>{let $t=1;for(let Tt=0;Tt<pt.rank;Tt++)(wt.indexOf(Tt)>=0||wt.length===0)&&($t*=st.inputs[0].dims[Tt]);return["var sum = f32(0);","",`sum += f32(${pt.getByIndices("input_indices")});`,`let value = ${vt.type.value}(sum / ${$t});`]})},Yc=(st,at)=>{Dt(st.inputs),Mt(st,"ReduceMin",at,(pt,vt,wt)=>{let $t=[];for(let Tt=0;Tt<pt.rank;Tt++)(wt.indexOf(Tt)>=0||wt.length===0)&&$t.push(`input_indices[${Tt}] = 0;`);return[`${$t.join(`
`)}`,`var value = ${pt.getByIndices("input_indices")};`,`value = min(value, ${pt.getByIndices("input_indices")});`,""]})},Xc=(st,at)=>{Dt(st.inputs),Mt(st,"ReduceProd",at,(pt,vt)=>[`var value = ${vt.type.storage}(1);`,"",`value *= ${pt.getByIndices("input_indices")};`,""])},Zc=(st,at)=>{Dt(st.inputs),Mt(st,"ReduceSum",at,(pt,vt)=>[`var value = ${vt.type.storage}(0);`,"",`value += ${pt.getByIndices("input_indices")};`,""])},Qc=(st,at)=>{Dt(st.inputs),Mt(st,"ReduceSumSquare",at,(pt,vt)=>[`var t = ${vt.type.value}(0); var value = ${vt.type.value}(0);`,"",`t = ${pt.getByIndices("input_indices")}; value += t * t;`,""])},Ut=(st,at,pt)=>{if(at.length===0)return pt;let vt=1,wt=1;for(let $t=0;$t<at.length;$t++)at.indexOf($t)===-1?vt*=st[$t]:wt*=st[$t];return wt<32&&vt>1024},$s=(st,at)=>{Ut(st.inputs[0].dims,at.axes,at.noopWithEmptyAxes)?Kc(st,at):ds(st,at)},_s=(st,at)=>{Ut(st.inputs[0].dims,at.axes,at.noopWithEmptyAxes)?Lc(st,at):cs(st,at)},xs=(st,at)=>{Ut(st.inputs[0].dims,at.axes,at.noopWithEmptyAxes)?Fc(st,at):ps(st,at)},Ss=(st,at)=>{Ut(st.inputs[0].dims,at.axes,at.noopWithEmptyAxes)?qc(st,at):ms(st,at)},Cs=(st,at)=>{Ut(st.inputs[0].dims,at.axes,at.noopWithEmptyAxes)?jc(st,at):fs(st,at)},Is=(st,at)=>{Ut(st.inputs[0].dims,at.axes,at.noopWithEmptyAxes)?Yc(st,at):hs(st,at)},Ts=(st,at)=>{Ut(st.inputs[0].dims,at.axes,at.noopWithEmptyAxes)?Xc(st,at):gs(st,at)},As=(st,at)=>{Ut(st.inputs[0].dims,at.axes,at.noopWithEmptyAxes)?Zc(st,at):ys(st,at)},Es=(st,at)=>{Ut(st.inputs[0].dims,at.axes,at.noopWithEmptyAxes)?Qc(st,at):bs(st,at)},ks=(st,at)=>{Ut(st.inputs[0].dims,at.axes,at.noopWithEmptyAxes)?Gc(st,at):vs(st,at)}}),Os,Ps,Rs,no,zs=j(()=>{ye(),Ze(),jn(),Os=st=>{if(!st||st.length===0||st.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(st[0].dataType!==1)throw new Error("Invalid input type.")},Ps=(st,at)=>{Os(st.inputs);let pt=(vt,wt,$t)=>{let Tt=[];for(let Lt=0;Lt<vt.rank;Lt++)($t.indexOf(Lt)>=0||$t.length===0)&&Tt.push(`input_indices[${Lt}] = 0;`);return[`${Tt.join(`
`)}`,`var value = ${vt.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${vt.getByIndices("input_indices")} ${at.selectLastIndex>0?"<=":"<"} value) {
         value = ${vt.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",wt.setByOffset("global_idx","best_index")]};st.compute(Kn("ArgMin",{hint:at.cacheKey,inputDependencies:["rank"]},[st.inputs[0]],pt,[at.axis],7,at.keepDims),{inputs:[0]})},Rs=(st,at)=>{Os(st.inputs);let pt=(vt,wt,$t)=>{let Tt=[];for(let Lt=0;Lt<vt.rank;Lt++)($t.indexOf(Lt)>=0||$t.length===0)&&Tt.push(`input_indices[${Lt}] = 0;`);return[`${Tt.join(`
`)}`,`var value = ${vt.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${vt.getByIndices("input_indices")} ${at.selectLastIndex>0?">=":">"} value) {
         value = ${vt.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",wt.setByOffset("global_idx","best_index")]};st.compute(Kn("argMax",{hint:at.cacheKey,inputDependencies:["rank"]},[st.inputs[0]],pt,[at.axis],7,at.keepDims),{inputs:[0]})},no=st=>we(st)}),Jc,ep,tp,Yn,Bs,Ds,io=j(()=>{ye(),xe(),Ze(),_e(),Jc=(st,at)=>{if(!st||st.length<1)throw new Error("too few inputs");let pt=0,vt=st[pt],wt=vt.dataType,$t=vt.dims.length;st.forEach((Tt,Lt)=>{if(Lt!==pt){if(Tt.dataType!==wt)throw new Error("input tensors should be one type");if(Tt.dims.length!==$t)throw new Error("input tensors should have the same shape");Tt.dims.forEach((Ft,Ct)=>{if(Ct!==at&&Ft!==vt.dims[Ct])throw new Error("non concat dimensions must match")})}})},ep=(st,at)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${st}u>(${at});
    for (var i: u32 = 0u; i < ${st}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${st}u;
  }`,tp=(st,at)=>{let pt=st.length,vt=[];for(let wt=0;wt<pt;++wt){let $t=at.setByOffset("global_idx",st[wt].getByIndices("indices"));pt===1?vt.push($t):wt===0?vt.push(`if (inputIndex == ${wt}u) { ${$t} }`):wt===pt-1?vt.push(`else { ${$t} }`):vt.push(`else if (inputIndex == ${wt}) { ${$t} }`)}return vt.join(`
`)},Yn=(st,at,pt,vt)=>{let wt=M.size(pt),$t=new Array(st.length),Tt=new Array(st.length),Lt=0,Ft=[],Ct=[],Ht=[{type:12,data:wt}];for(let An=0;An<st.length;++An)Lt+=st[An].dims[at],$t[An]=Lt,Ct.push(st[An].dims.length),Tt[An]=U(`input${An}`,vt,Ct[An]),Ft.push("rank"),Ht.push({type:12,data:$t[An]});for(let An=0;An<st.length;++An)Ht.push(...X(st[An].dims));Ht.push(...X(pt));let Gt=K("output",vt,pt.length),jt=Gt.indicesGet("indices",at),qt=Array.from(Array($t.length).keys()).map(An=>`uniforms.sizeInConcatAxis${An}`).join(","),Kt=An=>`

  ${(()=>{An.registerUniform("outputSize","u32");for(let Sn=0;Sn<st.length;Sn++)An.registerUniform(`sizeInConcatAxis${Sn}`,"u32");return An.declareVariables(...Tt,Gt)})()}

  ${ep($t.length,qt)}

  ${An.mainStart()}
    ${An.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${Gt.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${jt});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${$t.length}u>(${qt});
      ${jt} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${tp(Tt,Gt)}
  }`;return{name:"Concat",shaderCache:{hint:`${at}`,inputDependencies:Ft},getRunData:()=>({outputs:[{dims:pt,dataType:vt}],dispatchGroup:{x:Math.ceil(wt/64)},programUniforms:Ht}),getShaderSource:Kt}},Bs=(st,at)=>{let pt=st.inputs,vt=pt[0].dims,wt=M.normalizeAxis(at.axis,vt.length);Jc(pt,wt);let $t=vt.slice();$t[wt]=pt.reduce((Lt,Ft)=>Lt+(Ft.dims.length>wt?Ft.dims[wt]:0),0);let Tt=pt.filter(Lt=>M.size(Lt.dims)>0);st.compute(Yn(Tt,wt,$t,pt[0].dataType),{inputs:Tt})},Ds=st=>we({axis:st.axis})}),rp,np,ip,op,Xn,ap,Ms,oo=j(()=>{ye(),Hn(),_e(),io(),rp=(st,at)=>{let pt=st[0],vt=st[1],wt=st[2],$t=st[3],Tt=st[4],Lt=st[5];if(Tt&&Lt)throw new Error("Attention cannot have both past and relative_position_bias");if(pt.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let Ft=pt.dims[0],Ct=pt.dims[1],Ht=pt.dims[2];if(wt.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(vt.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(vt.dims[0]!==Ht)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(wt.dims[0]!==vt.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let Gt=wt.dims[0]/3,jt=Gt,qt=jt;if(at.qkvHiddenSizes.length>0){if(at.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let tr of at.qkvHiddenSizes)if(tr%at.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");Gt=at.qkvHiddenSizes[0],jt=at.qkvHiddenSizes[1],qt=at.qkvHiddenSizes[2]}let Kt=Ct;if(Gt!==jt)throw new Error("qkv_hidden_sizes first element should be same as the second");if(wt.dims[0]!==Gt+jt+qt)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let An=0;if(Tt){if(jt!==qt)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(Tt.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(Tt.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(Tt.dims[1]!==Ft)throw new Error('Input "past" second dimension must be batch_size');if(Tt.dims[2]!==at.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(Tt.dims[4]!==jt/at.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');at.pastPresentShareBuffer||(An=Tt.dims[3])}let Sn=Kt+An,wn=-1,In=0;if($t)throw new Error("Mask not supported");if(Tt)throw new Error("past is not supported");return{batchSize:Ft,sequenceLength:Ct,pastSequenceLength:An,kvSequenceLength:Kt,totalSequenceLength:Sn,maxSequenceLength:wn,inputHiddenSize:Ht,hiddenSize:Gt,vHiddenSize:qt,headSize:Math.floor(Gt/at.numHeads),vHeadSize:Math.floor(qt/at.numHeads),numHeads:at.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:at.maskFilterValue,maskType:In,scale:at.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},np=(st,at,pt,vt)=>{let wt=Ue(vt),$t=64,Tt=vt/wt;Tt<$t?$t=1:Tt/8<64&&($t=Math.ceil(Tt/8));let Lt=Math.ceil(vt/wt/$t),Ft=[{type:at.dataType,data:1/vt},{type:12,data:Tt},{type:12,data:Lt}],Ct=De(at.dataType,wt),Ht=rt(1,wt),Gt=jt=>{let qt=K("x",at.dataType,at.dims,wt),Kt=[{name:"d_inv",type:rt(at.dataType)},{name:"d_comp",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${$t}>;
  var<workgroup> thread_sum: array<f32, ${$t}>;
  ${jt.registerUniforms(Kt).declareVariables(qt)}
  ${jt.mainStart([$t,1,1])}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = workgroup_id.x * uniforms.d_comp + local_offset;

    var thread_max_vector = ${Ht}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      thread_max_vector = max(${Ht}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(wt){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${wt}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${$t}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${Ht}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      sum_vector += exp(${Ht}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(wt){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${wt}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${$t}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        x[offset + i] = ${qt.type.value}(uniforms.d_inv);
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        var f32input = ${Ht}(x[offset + i]);
        x[offset + i] = ${qt.type.value}(exp(f32input - max_value) / sum);
      }
    }
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${$t};${Ct};${wt}`},getShaderSource:Gt,getRunData:()=>({outputs:[],dispatchGroup:{x:pt},programUniforms:Ft})}},ip=(st,at,pt,vt,wt,$t,Tt)=>{let Lt=Tt+wt.kvSequenceLength,Ft=[wt.batchSize,wt.numHeads,wt.sequenceLength,Lt],Ct=$t.scale===0?1/Math.sqrt(wt.headSize):$t.scale,Ht=Ue(wt.headSize),Gt=wt.headSize/Ht,jt=12,qt={x:Math.ceil(Lt/jt),y:Math.ceil(wt.sequenceLength/jt),z:wt.batchSize*wt.numHeads},Kt=[{type:12,data:wt.sequenceLength},{type:12,data:Gt},{type:12,data:Lt},{type:12,data:wt.numHeads},{type:1,data:Ct}],An=vt?["type","type","type"]:["type","type"],Sn=wn=>{let In=U("q",at.dataType,at.dims,Ht),tr=U("key",pt.dataType,pt.dims,Ht),rr=[In,tr];vt&&rr.push(U("relative_position_bias",vt.dataType,vt.dims));let Hr=K("output",at.dataType,Ft),qr=rt(1,Ht),Zr=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"alpha",type:"f32"}];return`
  const TILE_SIZE = ${jt}u;

  var<workgroup> tileQ: array<${In.type.storage}, ${jt*jt}>;
  var<workgroup> tileK: array<${In.type.storage}, ${jt*jt}>;
  ${wn.registerUniforms(Zr).declareVariables(...rr,Hr)}
  ${wn.mainStart([jt,jt,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;
    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;

    var value = ${qr}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
        value += ${qr}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * uniforms.M * uniforms.N;
    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(Ht){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${Ht}`)}})()};
        output[outputIdx] = ${Hr.type.value} (sum * uniforms.alpha) + ${vt?"relative_position_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${Ht}`,inputDependencies:An},getRunData:()=>({outputs:[{dims:Ft,dataType:at.dataType,gpuDataType:0}],dispatchGroup:qt,programUniforms:Kt}),getShaderSource:Sn}},op=(st,at,pt,vt,wt)=>{let $t=wt+vt.kvSequenceLength,Tt=[vt.batchSize,vt.sequenceLength,vt.vHiddenSize],Lt=12,Ft={x:Math.ceil(vt.vHeadSize/Lt),y:Math.ceil(vt.sequenceLength/Lt),z:vt.batchSize*vt.numHeads},Ct=[{type:12,data:vt.sequenceLength},{type:12,data:$t},{type:12,data:vt.vHeadSize},{type:12,data:vt.numHeads},{type:12,data:vt.vHiddenSize}];return{name:"AttentionScore",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:Tt,dataType:at.dataType,gpuDataType:0}],dispatchGroup:Ft,programUniforms:Ct}),getShaderSource:Ht=>{let Gt=U("probs",at.dataType,at.dims),jt=U("v",pt.dataType,pt.dims),qt=K("output",at.dataType,Tt),Kt=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"}];return`
  const TILE_SIZE = ${Lt}u;
  var<workgroup> tileQ: array<${Gt.type.value}, ${Lt*Lt}>;
  var<workgroup> tileK: array<${Gt.type.value}, ${Lt*Lt}>;
  ${Ht.registerUniforms(Kt).declareVariables(Gt,jt,qt)}
  ${Ht.mainStart([Lt,Lt,1])}
   let headIdx = workgroup_id.z;
   let m = global_id.y;
   let n = global_id.x;

   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;
   let offsetB = headIdx * (uniforms.N * uniforms.K) + n;

   var value = ${Gt.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
     if (m < uniforms.M && w + local_id.x < uniforms.K) {
       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
     }
     if (n < uniforms.N && w + local_id.y < uniforms.K) {
       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * uniforms.N];
     }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + currentBatchHeadNumber * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`}}},Xn=(st,at,pt,vt,wt,$t,Tt,Lt,Ft,Ct,Ht)=>{let Gt=st.outputCount>1,jt=st.outputCount>2,qt=Gt&&jt?Ct.pastSequenceLength:0,Kt=qt+Ct.kvSequenceLength,An=[Ct.batchSize,Ct.numHeads,Kt,Ct.headSize],Sn=Tt?[Tt,pt]:[pt],wn=Gt?st.compute(Yn(Sn,2,An,pt.dataType),{inputs:Sn,outputs:[1]})[0]:pt,In=[Ct.batchSize,Ct.numHeads,Kt,Ct.headSize],tr=Lt?[Lt,vt]:[vt],rr=jt?st.compute(Yn(tr,2,In,vt.dataType),{inputs:tr,outputs:[2]})[0]:vt,Hr=[at,wn];Ft&&Hr.push(Ft);let qr=st.compute(ip(st,at,wn,Ft,Ct,Ht,qt),{inputs:Hr,outputs:[-1]})[0];st.compute(np(st,qr,Ct.batchSize*Ct.numHeads*Ct.sequenceLength,Kt),{inputs:[qr],outputs:[]});let Zr=[qr,rr];st.compute(op(st,qr,rr,Ct,qt),{inputs:Zr,outputs:[0]})},ap=(st,at)=>{let pt=[at.batchSize,at.numHeads,at.sequenceLength,at.headSize],vt=at.sequenceLength,wt=at.inputHiddenSize,$t=at.headSize,Tt=12,Lt={x:Math.ceil(at.headSize/Tt),y:Math.ceil(at.sequenceLength/Tt),z:at.batchSize*at.numHeads},Ft=[st.inputs[0],st.inputs[1],st.inputs[2]],Ct=[{type:12,data:vt},{type:12,data:wt},{type:12,data:$t},{type:12,data:at.numHeads},{type:12,data:at.headSize},{type:12,data:at.hiddenSize},{type:12,data:at.hiddenSize+at.hiddenSize+at.vHiddenSize}],Ht=Gt=>{let jt=K("output_q",Ft[0].dataType,pt),qt=K("output_k",Ft[0].dataType,pt),Kt=K("output_v",Ft[0].dataType,pt),An=U("input",Ft[0].dataType,Ft[0].dims),Sn=U("weight",Ft[1].dataType,Ft[1].dims),wn=U("bias",Ft[2].dataType,Ft[2].dims),In=An.type.storage,tr=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${Tt}u;
  var<workgroup> tileInput: array<${In}, ${Tt*Tt}>;
  var<workgroup> tileWeightQ: array<${In}, ${Tt*Tt}>;
  var<workgroup> tileWeightK: array<${In}, ${Tt*Tt}>;
  var<workgroup> tileWeightV: array<${In}, ${Tt*Tt}>;
  ${Gt.registerUniforms(tr).declareVariables(An,Sn,wn,jt,qt,Kt)}
  ${Gt.mainStart([Tt,Tt,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${In}(0);
    var valueK = ${In}(0);
    var valueV = ${In}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return st.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:pt,dataType:st.inputs[0].dataType,gpuDataType:0},{dims:pt,dataType:st.inputs[0].dataType,gpuDataType:0},{dims:pt,dataType:st.inputs[0].dataType,gpuDataType:0}],dispatchGroup:Lt,programUniforms:Ct}),getShaderSource:Ht},{inputs:Ft,outputs:[-1,-1,-1]})},Ms=(st,at)=>{let pt=rp(st.inputs,at),[vt,wt,$t]=ap(st,pt);return Xn(st,vt,wt,$t,st.inputs[4],void 0,void 0,void 0,st.inputs[5],pt,at)}}),sp,up,lp,Us,Ws=j(()=>{_t(),ye(),xe(),Ze(),_e(),sp=(st,at)=>{if(!st||st.length!==5)throw new Error("BatchNormalization requires 5 inputs");let pt=(vt,wt,$t)=>{let Tt=wt.length;if(Tt!==vt.length)throw new Error(`${$t}: num dimensions != ${Tt}`);wt.forEach((Lt,Ft)=>{if(Lt!==vt[Ft])throw new Error(`${$t}: dim[${Ft}] do not match`)})};if(st[0].dims.length>1){let vt=at.format==="NHWC"?at.spatial?st[0].dims.slice(-1):st[0].dims.slice(-1).concat(st[0].dims.slice(1,st[0].dims.length-1)):st[0].dims.slice(1,at.spatial?2:void 0);pt(st[1].dims,vt,"Invalid input scale"),pt(st[2].dims,vt,"Invalid input B"),pt(st[3].dims,vt,"Invalid input mean"),pt(st[4].dims,vt,"Invalid input var")}else pt(st[1].dims,[1],"Invalid input scale"),pt(st[2].dims,[1],"Invalid input B"),pt(st[3].dims,[1],"Invalid input mean"),pt(st[4].dims,[1],"Invalid input var")},up=(st,at)=>{let{epsilon:pt,spatial:vt,format:wt}=at,$t=st[0].dims,Tt=vt?Ue($t[$t.length-1]):1,Lt=wt==="NHWC"&&$t.length>1?Tt:1,Ft=M.size($t)/Tt,Ct=vt,Ht=Ct?$t.length:$t,Gt=U("x",st[0].dataType,st[0].dims,Tt),jt=U("scale",st[1].dataType,st[1].dims,Lt),qt=U("bias",st[2].dataType,st[2].dims,Lt),Kt=U("inputMean",st[3].dataType,st[3].dims,Lt),An=U("inputVar",st[4].dataType,st[4].dims,Lt),Sn=K("y",st[0].dataType,Ht,Tt),wn=()=>{let tr="";if(vt)tr=`let cOffset = ${$t.length===1?"0u":wt==="NHWC"?`outputIndices[${$t.length-1}] / ${Tt}`:"outputIndices[1]"};`;else if(wt==="NCHW")tr=`
            ${Sn.indicesSet("outputIndices","0","0")}
            let cOffset = ${Sn.indicesToOffset("outputIndices")};`;else{tr=`var cIndices = ${jt.type.indices}(0);
                       cIndices[0] = outputIndices[${$t.length-1}];`;for(let rr=1;rr<jt.rank;rr++)tr+=`cIndices[${rr}] = outputIndices[${rr}];`;tr+=`let cOffset = ${jt.indicesToOffset("cIndices")};`}return tr},In=tr=>`
  const epsilon = ${pt};
  ${tr.registerUniform("outputSize","u32").declareVariables(Gt,jt,qt,Kt,An,Sn)}
  ${tr.mainStart()}
  ${tr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${Sn.offsetToIndices(`global_idx * ${Tt}`)};
    ${wn()}
    let scale = ${jt.getByOffset("cOffset")};
    let bias = ${qt.getByOffset("cOffset")};
    let inputMean = ${Kt.getByOffset("cOffset")};
    let inputVar = ${An.getByOffset("cOffset")};
    let x = ${Gt.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${Sn.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${at.epsilon}_${at.format}_${vt}_${Tt}`,inputDependencies:Ct?["rank","type","type","type","type"]:void 0},getShaderSource:In,getRunData:()=>({outputs:[{dims:st[0].dims,dataType:st[0].dataType}],dispatchGroup:{x:Math.ceil(Ft/64)},programUniforms:Ct?[{type:12,data:Ft},...X($t)]:[{type:12,data:Ft}]})}},lp=st=>we(st),Us=(st,at)=>{let{inputs:pt,outputCount:vt}=st,wt=lp({...at,outputCount:vt});if(ke.webgpu.validateInputContent&&sp(pt,wt),at.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");st.compute(up(pt,wt))}}),dp,cp,Ns,Vs=j(()=>{xe(),_e(),dp=st=>{if(st[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(st[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(st[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(st[0].dims[2]!==st[1].dims[0])throw new Error("last dimension of input and bias are not the same")},cp=st=>{let at=st[0].dims,pt=st[0].dims[2],vt=M.size(at)/4,wt=st[0].dataType,$t=U("input",wt,at,4),Tt=U("bias",wt,[pt],4),Lt=U("residual",wt,at,4),Ft=K("output",wt,at,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:at,dataType:st[0].dataType}],dispatchGroup:{x:Math.ceil(vt/64)}}),getShaderSource:Ct=>`
  const channels = ${pt}u / 4;
  ${Ct.declareVariables($t,Tt,Lt,Ft)}

  ${Ct.mainStart()}
    ${Ct.guardAgainstOutOfBoundsWorkgroupSizes(vt)}
    let value = ${$t.getByOffset("global_idx")}
      + ${Tt.getByOffset("global_idx % channels")} + ${Lt.getByOffset("global_idx")};
    ${Ft.setByOffset("global_idx","value")}
  }`}},Ns=st=>{dp(st.inputs),st.compute(cp(st.inputs))}}),pp,Pe,Hs,Gs,Ls,Fs,qs,js,Ks,Ys,Xs,mp,Zs,Qs,Js,eu,Zn,tu,Qn,ru,nu,iu,ou,au,su,uu,lu,du,cu,pu,mu,fu,hu,gu,yu,bu,vu,ao,so,wu,$u,_u,Jn=j(()=>{ye(),xe(),Ze(),_e(),pp=(st,at,pt,vt,wt,$t)=>{let Tt=Math.ceil(at/4),Lt="";typeof wt=="string"?Lt=`${wt}(a)`:Lt=wt("a");let Ft=U("inputData",pt,[Tt],4),Ct=K("outputData",vt,[Tt],4);return`
      ${st.registerUniform("vec_size","u32").declareVariables(Ft,Ct)}

  ${$t??""}

  ${st.mainStart()}
    ${st.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${Ft.getByOffset("global_idx")};
    ${Ct.setByOffset("global_idx",Lt)}
  }`},Pe=(st,at,pt,vt,wt,$t=st.dataType)=>({name:at,shaderCache:{hint:wt,inputDependencies:["type"]},getShaderSource:Tt=>pp(Tt,M.size(st.dims),st.dataType,$t,pt,vt),getRunData:Tt=>({outputs:[{dims:st.dims,dataType:$t}],dispatchGroup:{x:Math.ceil(M.size(Tt[0].dims)/64/4)},programUniforms:[{type:12,data:Math.ceil(M.size(st.dims)/4)}]})}),Hs=st=>{st.compute(Pe(st.inputs[0],"Abs","abs"))},Gs=st=>{st.compute(Pe(st.inputs[0],"Acos","acos"))},Ls=st=>{st.compute(Pe(st.inputs[0],"Acosh","acosh"))},Fs=st=>{st.compute(Pe(st.inputs[0],"Asin","asin"))},qs=st=>{st.compute(Pe(st.inputs[0],"Asinh","asinh"))},js=st=>{st.compute(Pe(st.inputs[0],"Atan","atan"))},Ks=st=>{st.compute(Pe(st.inputs[0],"Atanh","atanh"))},Ys=st=>we(st),Xs=(st,at)=>{let pt;switch(at.to){case 10:pt="vec4<f16>";break;case 1:pt="vec4<f32>";break;case 12:pt="vec4<u32>";break;case 6:pt="vec4<i32>";break;case 9:pt="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${at.to}`)}st.compute(Pe(st.inputs[0],"Cast",pt,void 0,at.cacheKey,at.to))},mp=st=>{let at=st.length>=2&&st[1].data!==0?st[1].getFloat32Array()[0]:Ln,pt=st.length>=3&&st[2].data!==0?st[2].getFloat32Array()[0]:Fn;return we({min:at,max:pt})},Zs=(st,at)=>{let pt=st.inputs.length===1?at:mp(st.inputs),vt=rt(st.inputs[0].dataType);st.compute(Pe(st.inputs[0],"Clip",wt=>`clamp(${wt}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${vt}> = vec4(${vt}(${pt.min}));
    const clip_max_: vec4<${vt}> = vec4(${vt}(${pt.max}));
`,pt.cacheKey),{inputs:[0]})},Qs=st=>{st.compute(Pe(st.inputs[0],"Ceil","ceil"))},Js=st=>{st.compute(Pe(st.inputs[0],"Cos","cos"))},eu=st=>{st.compute(Pe(st.inputs[0],"Cosh","cosh"))},Zn=st=>we(st),tu=(st,at)=>{let pt=rt(st.inputs[0].dataType);st.compute(Pe(st.inputs[0],"Elu",vt=>`elu_vf32(${vt})`,`
  const elu_alpha_ = ${pt}(${at.alpha});

  fn elu_f32(a: ${pt}) -> ${pt} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${pt}>) -> vec4<${pt}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,at.cacheKey))},Qn=(st="f32")=>`
const r0: ${st} = 0.3275911;
const r1: ${st} = 0.254829592;
const r2: ${st} = -0.284496736;
const r3: ${st} = 1.421413741;
const r4: ${st} = -1.453152027;
const r5: ${st} = 1.061405429;

fn erf_vf32(v: vec4<${st}>) -> vec4<${st}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,ru=st=>{let at=rt(st.inputs[0].dataType);st.compute(Pe(st.inputs[0],"Erf",pt=>`erf_vf32(${pt})`,Qn(at)))},nu=st=>{st.compute(Pe(st.inputs[0],"Exp","exp"))},iu=st=>{st.compute(Pe(st.inputs[0],"Floor","floor"))},ou=st=>{let at=rt(st.inputs[0].dataType);st.compute(Pe(st.inputs[0],"Gelu",pt=>`0.5 * ${pt} * (1.0 + erf_vf32(${pt} * 0.7071067811865475))`,Qn(at)))},au=(st,at)=>{let pt=rt(st.inputs[0].dataType);st.compute(Pe(st.inputs[0],"LeakyRelu",vt=>`select(leaky_relu_alpha_ * ${vt}, ${vt}, ${vt} >= vec4<${pt}>(0.0))`,`const leaky_relu_alpha_ = ${pt}(${at.alpha});`,at.cacheKey))},su=st=>{st.compute(Pe(st.inputs[0],"Not",at=>`!${at}`))},uu=st=>{st.compute(Pe(st.inputs[0],"Neg",at=>`-${at}`))},lu=st=>{st.compute(Pe(st.inputs[0],"Reciprocal",at=>`1.0/${at}`))},du=st=>{let at=rt(st.inputs[0].dataType);st.compute(Pe(st.inputs[0],"Relu",pt=>`select(vec4<${at}>(0.0), ${pt}, ${pt} > vec4<${at}>(0.0))`))},cu=st=>{st.compute(Pe(st.inputs[0],"Sigmoid",at=>`(1.0 / (1.0 + exp(-${at})))`))},pu=st=>we(st),mu=(st,at)=>{let pt=rt(st.inputs[0].dataType);st.compute(Pe(st.inputs[0],"HardSigmoid",vt=>`max(vec4<${pt}>(0.0), min(vec4<${pt}>(1.0), ${at.alpha} * ${vt} + vec4<${pt}>(${at.beta})))`,void 0,at.cacheKey))},fu=st=>{st.compute(Pe(st.inputs[0],"Sin","sin"))},hu=st=>{st.compute(Pe(st.inputs[0],"Sinh","sinh"))},gu=st=>{st.compute(Pe(st.inputs[0],"Sqrt","sqrt"))},yu=st=>{st.compute(Pe(st.inputs[0],"Tan","tan"))},bu=st=>`sign(${st}) * (1 - exp(-2 * abs(${st}))) / (1 + exp(-2 * abs(${st})))`,vu=st=>{st.compute(Pe(st.inputs[0],"Tanh",bu))},ao=(st="f32")=>`
const fast_gelu_a: ${st} = 0.5;
const fast_gelu_b: ${st} = 0.7978845608028654;
const fast_gelu_c: ${st} = 0.035677408136300125;

fn tanh_v(v: vec4<${st}>) -> vec4<${st}> {
  return ${bu("v")};
}
`,so=st=>`(fast_gelu_a + fast_gelu_a * tanh_v(${st} * (fast_gelu_c * ${st} * ${st} + fast_gelu_b))) * ${st}`,wu=st=>{let at=rt(st.inputs[0].dataType);st.compute(Pe(st.inputs[0],"FastGelu",so,ao(at),void 0,st.inputs[0].dataType))},$u=(st,at)=>{let pt=rt(st.inputs[0].dataType);return st.compute(Pe(st.inputs[0],"ThresholdedRelu",vt=>`select(vec4<${pt}>(0.0), ${vt}, ${vt} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${pt}>(${at.alpha});`,at.cacheKey)),0},_u=st=>{st.compute(Pe(st.inputs[0],"Log","log"))}}),fp,hp,Su,Cu=j(()=>{xe(),_e(),Jn(),fp=st=>{if(st[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(st[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(st[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(st[0].dims[2]!==st[1].dims[0])throw new Error("last dimension of input and bias are not the same")},hp=st=>{let at=st[0].dims.slice();at[2]=at[2]/2;let pt=U("input",st[0].dataType,st[0].dims,4),vt=U("bias",st[0].dataType,[st[0].dims[2]],4),wt=K("output",st[0].dataType,at,4),$t=M.size(at)/4,Tt=De(st[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:at,dataType:st[0].dataType}],dispatchGroup:{x:Math.ceil($t/64)}}),getShaderSource:Lt=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${st[0].dims[2]/4/2}u;

  ${Lt.declareVariables(pt,vt,wt)}

  ${Qn(Tt)}

  ${Lt.mainStart()}
    ${Lt.guardAgainstOutOfBoundsWorkgroupSizes($t)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${wt.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},Su=st=>{fp(st.inputs),st.compute(hp(st.inputs))}}),gp,yp,Wt,Iu,Tu,Au,Eu,ku,Ou,Pu,Ru,zu,Bu,Du=j(()=>{ye(),xe(),_e(),gp=(st,at,pt,vt,wt,$t,Tt,Lt,Ft,Ct,Ht,Gt)=>{let jt,qt;typeof Lt=="string"?jt=qt=(In,tr)=>`${Lt}((${In}),(${tr}))`:typeof Lt=="function"?jt=qt=Lt:(jt=Lt.scalar,qt=Lt.vector);let Kt=K("outputData",Ht,vt.length,4),An=U("aData",Ft,at.length,4),Sn=U("bData",Ct,pt.length,4),wn;if(wt)if($t){let In=M.size(at)===1,tr=M.size(pt)===1,rr=at.length>0&&at[at.length-1]%4===0,Hr=pt.length>0&&pt[pt.length-1]%4===0;In||tr?wn=Kt.setByOffset("global_idx",qt(In?`${An.type.value}(${An.getByOffset("0")}.x)`:An.getByOffset("global_idx"),tr?`${Sn.type.value}(${Sn.getByOffset("0")}.x)`:Sn.getByOffset("global_idx"))):wn=`
            let outputIndices = ${Kt.offsetToIndices("global_idx * 4u")};
            let offsetA = ${An.broadcastedIndicesToOffset("outputIndices",Kt)};
            let offsetB = ${Sn.broadcastedIndicesToOffset("outputIndices",Kt)};
            ${Kt.setByOffset("global_idx",qt(Tt||rr?An.getByOffset("offsetA / 4u"):`${An.type.value}(${An.getByOffset("offsetA / 4u")}[offsetA % 4u])`,Tt||Hr?Sn.getByOffset("offsetB / 4u"):`${Sn.type.value}(${Sn.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else wn=Kt.setByOffset("global_idx",qt(An.getByOffset("global_idx"),Sn.getByOffset("global_idx")));else{if(!$t)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let In=(tr,rr,Hr="")=>{let qr=`aData[indexA${rr}][componentA${rr}]`,Zr=`bData[indexB${rr}][componentB${rr}]`;return`
            let outputIndices${rr} = ${Kt.offsetToIndices(`global_idx * 4u + ${rr}u`)};
            let offsetA${rr} = ${An.broadcastedIndicesToOffset(`outputIndices${rr}`,Kt)};
            let offsetB${rr} = ${Sn.broadcastedIndicesToOffset(`outputIndices${rr}`,Kt)};
            let indexA${rr} = offsetA${rr} / 4u;
            let indexB${rr} = offsetB${rr} / 4u;
            let componentA${rr} = offsetA${rr} % 4u;
            let componentB${rr} = offsetB${rr} % 4u;
            ${tr}[${rr}] = ${Hr}(${jt(qr,Zr)});
          `};Ht===9?wn=`
            var data = vec4<u32>(0);
            ${In("data",0,"u32")}
            ${In("data",1,"u32")}
            ${In("data",2,"u32")}
            ${In("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:wn=`
            ${In("outputData[global_idx]",0)}
            ${In("outputData[global_idx]",1)}
            ${In("outputData[global_idx]",2)}
            ${In("outputData[global_idx]",3)}
          `}return`
        ${st.registerUniform("vec_size","u32").declareVariables(An,Sn,Kt)}

        ${Gt??""}

        ${st.mainStart()}
        ${st.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${wn}
      }`},yp=(st,at,pt,vt,wt,$t,Tt=pt.dataType)=>{let Lt=!M.areEqual(pt.dims,vt.dims),Ft=pt.dims,Ct=M.size(pt.dims),Ht=!1,Gt=!1,jt=[Lt];if(Lt){let qt=zt.calcShape(pt.dims,vt.dims,!1);if(!qt)throw new Error("Can't perform binary op on the given tensors");Ft=qt,Ct=M.size(Ft);let Kt=M.size(pt.dims)===1,An=M.size(vt.dims)===1,Sn=pt.dims.length>0&&pt.dims[pt.dims.length-1]%4===0,wn=vt.dims.length>0&&vt.dims[vt.dims.length-1]%4===0;jt.push(Kt),jt.push(An),jt.push(Sn),jt.push(wn);let In=1;for(let tr=1;tr<Ft.length;tr++){let rr=pt.dims[pt.dims.length-tr]??1,Hr=vt.dims[vt.dims.length-tr]??1;if(rr===Hr)In*=rr;else break}In%4===0?(Gt=!0,Ht=!0):(Kt||An||Sn||wn)&&(Ht=!0)}else Ht=!0;return jt.push(Ht),{name:st,shaderCache:{hint:at+jt.map(qt=>qt.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:qt=>gp(qt,pt.dims,vt.dims,Ft,Ht,Lt,Gt,wt,pt.dataType,vt.dataType,Tt,$t),getRunData:()=>({outputs:[{dims:Ft,dataType:Tt}],dispatchGroup:{x:Math.ceil(Ct/64/4)},programUniforms:[{type:12,data:Math.ceil(M.size(Ft)/4)},...X(pt.dims,vt.dims,Ft)]})}},Wt=(st,at,pt,vt,wt,$t)=>{st.compute(yp(at,wt??"",st.inputs[0],st.inputs[1],pt,vt,$t))},Iu=st=>{Wt(st,"Add",(at,pt)=>`${at}+${pt}`)},Tu=st=>{Wt(st,"Div",(at,pt)=>`${at}/${pt}`)},Au=st=>{Wt(st,"Equal",{scalar:(at,pt)=>`u32(${at}==${pt})`,vector:(at,pt)=>`vec4<u32>(${at}==${pt})`},void 0,void 0,9)},Eu=st=>{Wt(st,"Mul",(at,pt)=>`${at}*${pt}`)},ku=st=>{let at=U("input",st.inputs[0].dataType,st.inputs[0].dims).type.value;Wt(st,"Pow",{scalar:(pt,vt)=>`pow_custom(${pt},${vt})`,vector:(pt,vt)=>`pow_vector_custom(${pt},${vt})`},`
    fn pow_custom(a : ${at}, b : ${at}) -> ${at} {
      if (b == ${at}(0.0)) {
        return ${at}(1.0);
      } else if (a < ${at}(0.0) && f32(b) != floor(f32(b))) {
        return ${at}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${at}(1.0), round(f32(abs(b) % ${at}(2.0))) != 1.0) * ${at}(${at==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${at}>, b : vec4<${at}>) -> vec4<${at}> {
      // TODO: implement vectorized pow
      return vec4<${at}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Ou=st=>{Wt(st,"Sub",(at,pt)=>`${at}-${pt}`)},Pu=st=>{Wt(st,"Greater",{scalar:(at,pt)=>`u32(${at}>${pt})`,vector:(at,pt)=>`vec4<u32>(${at}>${pt})`},void 0,void 0,9)},Ru=st=>{Wt(st,"Less",{scalar:(at,pt)=>`u32(${at}<${pt})`,vector:(at,pt)=>`vec4<u32>(${at}<${pt})`},void 0,void 0,9)},zu=st=>{Wt(st,"GreaterOrEqual",{scalar:(at,pt)=>`u32(${at}>=${pt})`,vector:(at,pt)=>`vec4<u32>(${at}>=${pt})`},void 0,void 0,9)},Bu=st=>{Wt(st,"LessOrEqual",{scalar:(at,pt)=>`u32(${at}<=${pt})`,vector:(at,pt)=>`vec4<u32>(${at}<=${pt})`},void 0,void 0,9)}}),kt,Ot,Pt,ei,Zt=j(()=>{ye(),xe(),kt=(st,at,pt="f32")=>{switch(st.activation){case"Relu":return`value = max(value, ${at}(0.0));`;case"Sigmoid":return`value = (${at}(1.0) / (${at}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${at}(${pt}(uniforms.clip_min)), ${at}(${pt}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${at}(0.0), min(${at}(1.0), ${pt}(uniforms.alpha) * value + ${pt}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${pt}(uniforms.alpha) * value, value, value >= ${at}(0.0));`;case"":return"";default:throw new Error(`Unsupported activation ${st.activation}`)}},Ot=(st,at)=>{st.activation==="Clip"?at.push({type:1,data:st.clipMax},{type:1,data:st.clipMin}):st.activation==="HardSigmoid"?at.push({type:1,data:st.alpha},{type:1,data:st.beta}):st.activation==="LeakyRelu"&&at.push({type:1,data:st.alpha})},Pt=(st,at)=>{st.activation==="Clip"?at.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):st.activation==="HardSigmoid"?at.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):st.activation==="LeakyRelu"&&at.push({name:"alpha",type:"f32"})},ei=st=>{let at=(st==null?void 0:st.activation)||"";if(at==="HardSigmoid"){let[pt,vt]=(st==null?void 0:st.activation_params)||[.2,.5];return{activation:at,alpha:pt,beta:vt}}else if(at==="Clip"){let[pt,vt]=(st==null?void 0:st.activation_params)||[Ln,Fn];return{activation:at,clipMax:vt,clipMin:pt}}else if(at==="LeakyRelu"){let[pt]=(st==null?void 0:st.activation_params)||[.01];return{activation:at,alpha:pt}}return{activation:at}}}),nt,ti,ri=j(()=>{nt=(st,at)=>{switch(st){case 1:return at;case 2:return`vec2<${at}>`;case 3:return`vec3<${at}>`;case 4:return`vec4<${at}>`;default:throw new Error(`${st}-component is not supported.`)}},ti=st=>`
      ${st?"value = value + getBiasByOutputCoords(coords);":""}
      `}),ni,uo=j(()=>{ni=st=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${st}.x), i32(${st}.y), i32(${st}.z), 1));
}
`}),vp,wp,rn,Mu,$p,nn,_p,ii,on=j(()=>{ye(),xe(),_e(),Zt(),ri(),vp=(st,at)=>st?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${at?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${at?", batchIndices":""});
        `,wp=(st,at)=>st?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${at===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${at===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${at===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,rn=(st,at,pt="f32",vt,wt=!1,$t=32,Tt=!1,Lt=32)=>{let Ft=at[1]*st[1],Ct=at[0]*st[0],Ht=wt?Ft:$t,Gt=wt?$t:Ft,jt=Ht/at[0],qt=$t/at[1];if(!((wt&&jt===4&&st[1]===4||!wt&&(jt===3||jt===4))&&Ht%at[0]===0&&$t%at[1]===0&&st[0]===4))throw new Error(`If transposeA ${wt} is true, innerElementSize ${jt} and workPerThread[1] ${st[1]} must be 4.
      Otherwise, innerElementSize ${jt} must be 3 or 4.
  tileAWidth ${Ht} must be divisible by workgroupSize[0]${at[0]}. tileInner ${$t} must be divisible by workgroupSize[1] ${at[1]}. colPerThread ${st[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${jt}<${pt}>, ${Ht/jt}>, ${Gt}>;
var<workgroup> mm_Bsub: array<array<vec4<${pt}>, ${Ct/st[0]}>, ${$t}>;

const rowPerThread = ${st[1]};
const colPerThread = ${st[0]};
const innerElementSize = ${jt};
const tileInner = ${$t};

@compute @workgroup_size(${at[0]}, ${at[1]}, ${at[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${Tt?"0":"i32(globalId.z)"};
  ${vt?`let batchIndices = ${vt.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${Ft};

  let num_tiles = ${Tt?`${Math.ceil(Lt/$t)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${Tt?`i32(globalId.z) * ${Lt}`:"0"};

  var acc: array<vec4<${pt}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${qt};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${vp(wt,vt)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${qt}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${vt?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${jt===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${wp(wt,jt)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Mu=(st,at)=>st?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${at?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${at?", batchIndices":""});
            `,$p=st=>st?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",nn=(st,at,pt="f32",vt,wt=!1,$t=32,Tt=!1,Lt=32,Ft=!1)=>{let Ct=st[1]*at[1],Ht=st[0]*at[0],Gt=wt?Ct:$t,jt=wt?$t:Ct;if(!(jt%at[1]===0&&Gt%at[0]===0&&$t%at[1]===0))throw new Error(`tileAHight ${jt} must be divisible by workgroupSize[1]${at[1]}, tileAWidth ${Gt} must be divisible by workgroupSize[0]${at[0]}, tileInner ${$t} must be divisible by workgroupSize[1]${at[1]}`);let qt=jt/at[1],Kt=Gt/at[0],An=$t/at[1],Sn=Ft?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${Ct};
    let globalColStart = i32(workgroupId.x) * ${Ht};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${jt}; inputRow = inputRow + ${at[1]}) {
        for (var inputCol = localCol; inputCol < ${Gt}; inputCol = inputCol + ${at[0]}) {
          ${Mu(wt,vt)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${$t}; inputRow = inputRow + ${at[1]}) {
            for (var inputCol = localCol; inputCol < ${Ht}; inputCol = inputCol + ${at[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${vt?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${pt}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${at[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${wt?`mm_Asub[k][localRow + innerRow * ${at[1]}];`:`mm_Asub[localRow + innerRow * ${at[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${at[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${at[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${Ct};

let tileRowA = i32(localId.y) * ${qt};
let tileColA = i32(localId.x) * ${Kt};
let tileRowB = i32(localId.y) * ${An};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${qt}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${Kt}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Mu(wt,vt)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${An}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${vt?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${pt}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${$p(wt)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${pt}, ${Gt}>, ${jt}>;
  var<workgroup> mm_Bsub : array<array<${pt}, ${Ht}>, ${$t}>;
  const rowPerThread = ${st[1]};
  const colPerThread = ${st[0]};
  const tileInner = ${$t};

@compute @workgroup_size(${at[0]}, ${at[1]}, ${at[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${Tt?"0":"i32(globalId.z)"};
    ${vt?`let batchIndices = ${vt.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${Tt?`${Math.ceil(Lt/$t)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${Tt?`i32(globalId.z) * ${Lt}`:"0"};

    var acc : array<array<${pt}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${Sn}
  }
`},_p=(st,at,pt,vt,wt,$t=!1)=>{let[Tt,Lt,Ft]=wt,[Ct,Ht,Gt,jt]=vt,qt=Pr(Tt,Ft),Kt=Pr(Lt,Ft),An=De(vt[0].type.tensor),Sn=()=>{let In=Ht.rank,tr=Ct.rank,rr=`var aIndices: ${Ht.type.indices};`;for(let Hr=In-2-1,qr=tr-1;Hr>=0;Hr--,qr--)rr+=`
aIndices[${Hr}] = ${tr>1?`batchIndices[${qr}]`:"batchIndices"};`;return qt.forEach(Hr=>{rr+=`
aIndices[${Hr}] = 0;`}),rr+=`
aIndices[${In-2}] = u32(row);
                   aIndices[${In-1}] = u32(colIn);`,rr},wn=()=>{let In=Gt.rank,tr=Ct.rank,rr=`var bIndices: ${Gt.type.indices};`;for(let Hr=In-2-1,qr=tr-1;Hr>=0;Hr--,qr--)rr+=`
bIndices[${Hr}] = ${tr>1?`batchIndices[${qr}]`:"batchIndices"};`;return Kt.forEach(Hr=>{rr+=`
bIndices[${Hr}] = 0;`}),rr+=`
bIndices[${In-2}] = u32(row);
                   bIndices[${In-1}] = u32(colIn);`,rr};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${Ct.type.indices}) -> ${nt(st,An)} {
      var value = ${nt(st,An)}(0.0);
      let col = colIn * ${st};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${Sn()}
        value = ${Ht.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${Ct.type.indices}) -> ${nt(st,An)} {
      var value = ${nt(st,An)}(0.0);
      let col = colIn * ${st};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${wn()}
        value = ${Gt.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${nt(st,An)}) {
      let col = colIn * ${st};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${at?`value = value + ${$t?"bias[colIn]":`${nt(st,An)}(bias[row])`};`:""}
        ${pt}
        ${jt.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},ii=(st,at,pt,vt,wt=!1)=>{let $t=st[0].dims,Tt=st[1].dims,Lt=$t.slice(0,-2),Ft=Tt.slice(0,-2),Ct=vt?vt.slice(0,-2):pt.slice(0,-2),Ht=M.size(Ct),Gt=$t[$t.length-2],jt=$t[$t.length-1],qt=Tt[Tt.length-1],Kt=jt%4===0&&qt%4===0,An=Gt<=8?[4,1,1]:[4,4,1],Sn=[8,8,1],wn=[Math.ceil(qt/Sn[0]/An[0]),Math.ceil(Gt/Sn[1]/An[1]),Math.ceil(Ht/Sn[2]/An[2])],In=Kt?4:1,tr=[...Lt,Gt,jt/In],rr=tr.length,Hr=[...Ft,jt,qt/In],qr=Hr.length,Zr=[Ht,Gt,qt/In],Bo=[{type:6,data:Gt},{type:6,data:qt},{type:6,data:jt}];Ot(at,Bo),Bo.push(...X(Ct,tr,Hr));let Xo=["rank","rank"],Kr=st.length>2;Kr&&(Bo.push(...X(st[2].dims)),Xo.push("rank")),Bo.push(...X(Zr));let ko=f0=>{let x0=Ct.length,l0=qn("batchDims",st[0].dataType,x0,1),T0=De(st[0].dataType),t0=U("a",st[0].dataType,rr,In),E0=U("b",st[1].dataType,qr,In),n0=K("result",st[0].dataType,Zr.length,In),m0=[t0,E0];if(Kr){let B0=wt?In:1;m0.push(U("bias",st[2].dataType,st[2].dims.length,B0))}let h0=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Pt(at,h0);let a0=De(n0.type.tensor),P0=kt(at,n0.type.value,a0),V0=_p(In,Kr,P0,[l0,t0,E0,n0],[Lt,Ft,Ct],wt);return`
  ${f0.registerUniforms(h0).registerInternalVariables(l0).declareVariables(...m0,n0)}
  ${V0}
  ${Kt?rn(An,Sn,T0,l0):nn(An,Sn,T0,l0)}
                   `};return{name:"MatMul",shaderCache:{hint:`${An};${at.activation};${Kt};${wt}`,inputDependencies:Xo},getRunData:()=>({outputs:[{dims:pt,dataType:st[0].dataType}],dispatchGroup:{x:wn[0],y:wn[1],z:wn[2]},programUniforms:Bo}),getShaderSource:ko}}}),xp,Uu,Wu=j(()=>{ye(),Xt(),_e(),Zt(),ri(),uo(),on(),xp=(st,at,pt,vt,wt=!1,$t,Tt=4,Lt=4,Ft=4,Ct="f32")=>{let Ht=Xo=>{switch(Xo){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${Ct}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Xo} is not supported.`)}},Gt=Xo=>{switch(Xo){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${Xo} is not supported.`)}},jt=st?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,qt=st?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,Kt=st?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",An=st?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",Sn=st?"row":"col",wn=st?"col":"row",In=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${st?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${Sn} / outWidth;
    let outCol = ${Sn} % outWidth;

    let WRow = ${wn} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${wn} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${wn} % inChannels;
    var resData = ${nt(Tt,Ct)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${Kt} && xCol >= 0 && xCol < ${An}) {
      ${jt}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${Ht(Tt)}
    }
    return resData;`,tr=st?at&&vt?`
    let col = colIn * ${Tt};
    ${In}`:`
    let col = colIn * ${Tt};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${In}
    }
    return ${nt(Tt,Ct)}(0.0);`:vt&&pt?`
    let col = colIn * ${Tt};
    ${In}`:`
    let col = colIn * ${Tt};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${In}
    }
    return ${nt(Tt,Ct)}(0.0);`,rr=`${Gt(Lt)}`,Hr=nt(Ft,Ct),qr=nt(st?Tt:Lt,Ct),Zr=nt(st?Lt:Tt,Ct),Bo=kt($t,Hr,Ct);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${qr} {
      ${st?tr:rr}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Zr} {
      ${st?rr:tr}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${Hr}) {
      let col = colIn * ${Ft};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${st?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${qt}
      ${ti(wt)}
      ${Bo}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},Uu=(st,at,pt,vt,wt,$t,Tt,Lt)=>{let Ft=at.format==="NHWC",Ct=Ft?st[0].dims[3]:st[0].dims[1],Ht=pt[0],Gt=Ft?pt[2]:pt[3],jt=Ft?pt[1]:pt[2],qt=Ft?pt[3]:pt[1],Kt=Ft&&(Ct%4===0||Ct%3===0)&&qt%4===0,An=Ft?qt:Gt*jt,Sn=Ft?Gt*jt:qt,wn=[8,8,1],In=vt<=8?[4,1,1]:[4,4,1],tr=[Math.ceil(An/wn[0]/In[0]),Math.ceil(Sn/wn[1]/In[1]),Math.ceil(Ht/wn[2]/In[2])];Ne("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${tr}`);let rr=Kt?Ft&&Ct%4!==0?3:4:1,Hr=wn[1]*In[1],qr=wn[0]*In[0],Zr=Math.max(wn[0]*rr,wn[1]),Bo=vt%Hr===0,Xo=wt%qr===0,Kr=$t%Zr===0,ko=Kt?[rr,4,4]:[1,1,1],f0=[{type:6,data:vt},{type:6,data:wt},{type:6,data:$t},{type:6,data:[at.pads[0],at.pads[1]]},{type:6,data:at.strides},{type:6,data:at.dilations}];Ot(at,f0),f0.push(...X(st[0].dims,st[1].dims));let x0=["rank","rank"];Tt&&(f0.push(...X(st[2].dims)),x0.push("rank")),f0.push(...X(pt));let l0=T0=>{let t0=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Pt(at,t0);let E0=Kt?4:1,n0=De(st[0].dataType),m0=`
      fn setOutputAtIndex(flatIndex : i32, value : ${Kt?`vec4<${n0}>`:n0}) {
        result[flatIndex] = ${Kt?`vec4<${n0}>`:n0}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${Kt?`vec4<${n0}>`:n0}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${Kt?"/ 4":""}, value);
      }`,h0=U("x",st[0].dataType,st[0].dims.length,rr===3?1:rr),a0=U("w",st[1].dataType,st[1].dims.length,E0),P0=[h0,a0],V0=K("result",st[0].dataType,pt.length,E0);if(Tt){let B0=U("bias",st[2].dataType,st[2].dims.length,E0);P0.push(B0),m0+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${Kt?`vec4<${n0}>`:n0} {
          return bias[coords.${Ft?"w":"y"}${Kt?"/ 4":""}];
        }`}return`
        ${ni("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${T0.registerUniforms(t0).declareVariables(...P0,V0)}
        ${m0}
        ${xp(Ft,Bo,Xo,Kr,Tt,at,ko[0],ko[1],ko[2],n0)}
        ${Kt?rn(In,wn,n0,void 0,!Ft,Zr):nn(In,wn,n0,void 0,!Ft,Zr,!1,void 0,Lt)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${at.cacheKey};${rr};${Kt};${Bo};${Xo};${Kr};${Hr};${qr};${Zr}`,inputDependencies:x0},getRunData:()=>({outputs:[{dims:pt,dataType:st[0].dataType}],dispatchGroup:{x:tr[0],y:tr[1],z:tr[2]},programUniforms:f0}),getShaderSource:l0}}}),lo,Nu,Vu=j(()=>{ye(),xe(),_e(),co(),Zt(),lo=(st,at,pt)=>{let vt=st.length>2,wt=vt?"value += b[output_channel];":"",$t=st[0].dims,Tt=st[1].dims,Lt=Tt[0]/at.group,Ft=at.format==="NHWC",Ct=oi($t,Tt,at.dilations,at.pads,at.strides,Ft),Ht=M.size(Ct),Gt=[{type:12,data:Ht},{type:12,data:at.dilations},{type:12,data:[at.strides[0],at.strides[1]]},{type:12,data:[at.pads[0],at.pads[1]]},{type:12,data:Lt}];Ot(at,Gt),Gt.push(...X($t,Tt));let jt=["rank","rank"];vt&&(Gt.push(...X(st[2].dims)),jt.push("rank")),Gt.push(...X(Ct));let qt=Kt=>{let An=K("output",st[0].dataType,Ct.length),Sn=De(An.type.tensor),wn=kt(at,An.type.value,Sn),In=U("x",st[0].dataType,$t.length),tr=U("w",st[1].dataType,Tt.length),rr=[In,tr];vt&&rr.push(U("b",st[2].dataType,st[2].dims.length));let Hr=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:at.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];return Pt(at,Hr),`
  ${Kt.registerUniforms(Hr).declareVariables(...rr,An)}

  ${Kt.mainStart()}
    ${Kt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${An.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${Ft?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${Ft?1:2}], outputIndices[${Ft?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel / uniforms.output_channels_per_group;

    var value: ${An.type.value} = ${An.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[${Ft?1:2}]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[${Ft?2:3}]) {
            continue;
          }

          let xVal = ${Ft?In.get("batch","xHeight","xWidth","input_channel"):In.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${tr.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${wt}
    ${wn}
    ${An.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:at.cacheKey,inputDependencies:jt},getRunData:()=>({outputs:[{dims:pt?pt(Ct):Ct,dataType:st[0].dataType}],dispatchGroup:{x:Math.ceil(Ht/64)},programUniforms:Gt}),getShaderSource:qt}},Nu=(st,at,pt)=>{let vt=st.length>2,wt=Ue(pt[3]),$t=Ue(pt[2]),Tt=M.size(pt)/wt/$t,Lt=[st[0].dims[0],st[0].dims[1],st[0].dims[2],st[0].dims[3]/wt],Ft=[st[1].dims[0],st[1].dims[1],st[1].dims[2],st[1].dims[3]/wt],Ct=[pt[0],pt[1],pt[2],pt[3]/wt],Ht=[{type:12,data:Tt},{type:6,data:[at.strides[0],at.strides[1]]},{type:6,data:[at.pads[0],at.pads[1]]}];Ot(at,Ht),Ht.push(...X(Lt,Ft,Ct));let Gt=($t-1)*at.strides[1]+Ft[1],jt=qt=>{let Kt=K("output",st[0].dataType,Ct.length,wt),An=De(Kt.type.tensor),Sn=kt(at,Kt.type.value,An),wn=U("x",st[0].dataType,Lt.length,wt),In=U("w",st[1].dataType,Ft.length,wt),tr=[wn,In];vt&&tr.push(U("b",st[2].dataType,st[2].dims,wt));let rr=vt?"value += b[output_channel];":"",Hr=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Pt(at,Hr),`
  ${qt.registerUniforms(Hr).declareVariables(...tr,Kt)}
  ${qt.mainStart()}
    ${qt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${$t}u;
    let col = (index1 % width1) * ${$t}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${wn.type.value}, ${Gt}>;
    var values: array<${Kt.type.value}, ${$t}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${Ft[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${Gt}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${wn.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${wn.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${Ft[1]}; w_width++) {
          let w_val = ${In.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${$t}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${$t}u; i++) {
      var value = values[i];
      ${rr}
      ${Sn}
      ${Kt.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${at.cacheKey};${wt};${$t};${Gt};${Ft[0]};${Ft[1]}`,inputDependencies:vt?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:pt,dataType:st[0].dataType}],dispatchGroup:{x:Math.ceil(Tt/64)},programUniforms:Ht}),getShaderSource:jt}}}),po,Sp,Hu,mo=j(()=>{ye(),xe(),on(),_e(),Zt(),po=(st,at,pt,vt,wt=!1)=>{let $t=st[0].dims,Tt=st[1].dims,Lt=$t[$t.length-2],Ft=Tt[Tt.length-1],Ct=$t[$t.length-1],Ht=Ue(Ft),Gt=Ue(Ct),jt=Ue(Lt),qt=M.size(pt)/Ht/jt,Kt=st.length>2,An=vt?vt.slice(0,-2):pt.slice(0,-2),Sn=[M.size(An),Lt,Ft],wn=[{type:12,data:qt},{type:12,data:Lt},{type:12,data:Ft},{type:12,data:Ct}];Ot(at,wn),wn.push(...X(An,$t,Tt)),Kt&&wn.push(...X(st[2].dims)),wn.push(...X(Sn));let In=tr=>{let rr=qn("batch_dims",st[0].dataType,An.length),Hr=U("a",st[0].dataType,$t.length,Gt),qr=U("b",st[1].dataType,Tt.length,Ht),Zr=K("output",st[0].dataType,Sn.length,Ht),Bo=De(Zr.type.tensor),Xo=kt(at,Zr.type.value,Bo),Kr=[Hr,qr],ko="";if(Kt){let m0=wt?Ht:1;Kr.push(U("bias",st[2].dataType,st[2].dims.length,m0)),ko=`${wt?`value += bias[col / ${m0}];`:`value += ${Zr.type.value}(bias[row + i]);`}`}let f0=$t.slice(0,-2),x0=Tt.slice(0,-2),l0=Pr(f0,An),T0=Pr(x0,An),t0=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];Pt(at,t0);let E0=(m0,h0)=>{let a0=m0.rank,P0=m0.name;if(a0===2)return`var ${P0}_indices = ${m0.type.indices}(0u, 0u);`;let V0=rr.rank,B0=`var ${P0}_indices: ${m0.type.indices};`;for(let W0=a0-2-1,K0=V0-1;W0>=0;W0--,K0--)B0+=`
${P0}_indices[${W0}] = ${V0>1?`batch_indices[${K0}]`:"batch_indices"};`;return h0.forEach(W0=>{B0+=`
${P0}_indices[${W0}] = 0;`}),B0+=`${P0}_indices[${a0-2}] = 0u;
                     ${P0}_indices[${a0-1}] = 0u;`,B0},n0=()=>{let m0=`var a_data: ${Hr.type.value};`;for(let h0=0;h0<Gt;h0++)m0+=`
              let b_data${h0} = b[(b_offset + (k + ${h0}) * uniforms.N + col) / ${Ht}];`;for(let h0=0;h0<jt;h0++){m0+=`a_data = a[(a_offset + (row + ${h0}) * uniforms.K + k) / ${Gt}];`;for(let a0=0;a0<Gt;a0++)m0+=`
            values[${h0}] = fma(${qr.type.value}(a_data${Gt===1?"":`[${a0}]`}), b_data${a0}, values[${h0}]);
`}return m0};return`
  ${tr.registerUniforms(t0).registerInternalVariables(rr).declareVariables(...Kr,Zr)}
  ${tr.mainStart()}
    ${tr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${Ht})) * ${Ht};
    var index1 = global_idx / (uniforms.N / ${Ht});
    let stride1 = uniforms.M / ${jt};
    let row = (index1 % stride1) * ${jt};
    let batch = index1 / stride1;

    ${pt.length===2?"":`let batch_indices = ${rr.offsetToIndices("batch")};`}
    ${E0(Hr,l0)}
    let a_offset = ${Hr.indicesToOffset("a_indices")};
    ${E0(qr,T0)}
    let b_offset = ${qr.indicesToOffset("b_indices")};
    var values: array<${Zr.type.value}, ${jt}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${Gt}) {
      ${n0()}
    }
    for (var i = 0u; i < ${jt}u; i++) {
      var value = values[i];
      ${ko}
      ${Xo}
      let cur_indices = ${Zr.type.indices}(batch, row + i, col);
      let offset = ${Zr.indicesToOffset("cur_indices")};
      ${Zr.setByOffset(`offset / ${Ht}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${at.activation};${Ht};${Gt};${jt};${wt}`,inputDependencies:Kt?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:pt,dataType:st[0].dataType}],dispatchGroup:{x:Math.ceil(qt/64)},programUniforms:wn}),getShaderSource:In}},Sp=st=>{if(!st||st.length!==2)throw new Error("MatMul requires 2 inputs.");if(st[0].dims[st[0].dims.length-1]!==st[1].dims[st[1].dims.length-2])throw new Error("shared dimension does not match.")},Hu=st=>{Sp(st.inputs);let at=zt.calcShape(st.inputs[0].dims,st.inputs[1].dims,!0);if(!at)throw new Error("Can't use matmul on the given tensors");let pt=at[at.length-1],vt=st.inputs[0].dims[st.inputs[0].dims.length-1];pt<8&&vt<8?st.compute(po(st.inputs,{activation:""},at)):st.compute(ii(st.inputs,{activation:""},at))}}),oi,fo,Cp,Gu,ho,Ip,Tp,go,co=j(()=>{xe(),Wu(),on(),Vu(),Zt(),mo(),Rr(),oi=(st,at,pt,vt,wt,$t)=>{let Tt=st[0],Lt=st.slice($t?1:2,$t?3:4),Ft=Lt.length,Ct=at[0],Ht=at.slice(2).map((jt,qt)=>jt+(jt-1)*(pt[qt]-1)),Gt=Lt.map((jt,qt)=>jt+vt[qt]+vt[qt+Ft]).map((jt,qt)=>Math.floor((jt-Ht[qt]+wt[qt])/wt[qt]));return Gt.splice(0,0,Tt),Gt.splice($t?3:1,0,Ct),Gt},fo=[2,3,1,0],Cp=(st,at)=>{if(!st||st.length!==2&&st.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(st[0].dims.length!==4&&st[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(st[0].dims.length!==st[1].dims.length)throw new Error("filter does not have same dimension as input");let pt=st[0].dims[at.format==="NHWC"?st[0].dims.length-1:1],vt=st[1].dims[1]*at.group;if(pt!==vt)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(st.length===3&&(st[2].dims.length!==1||st[1].dims[0]!==st[2].dims[0]))throw new Error("invalid bias");let wt=st[0].dims.length-2;if(at.dilations.length!==wt)throw new Error(`dilations should be ${wt}D`);if(at.strides.length!==wt)throw new Error(`strides should be ${wt}D`);if(at.pads.length!==wt*2)throw new Error(`pads should be ${wt*2}D`);if(at.kernelShape.length!==0&&at.kernelShape.length!==st[1].dims.length-2)throw new Error("invalid kernel shape")},Gu=(st,at)=>{let pt=st.kernelShape.slice();for(let $t=2;$t<at[1].dims.length;++$t)pt[$t-2]===0&&(pt[$t-2]=at[1].dims[$t]);let vt=st.pads.slice();pr.adjustPadsBasedOnAutoPad(at[0].dims,st.strides,st.dilations,pt,vt,st.format==="NHWC",st.autoPad);let wt=Object.assign({},st);return Object.assign(wt,{kernelShape:pt,pads:vt}),wt},ho=st=>{let at=ei(st),pt=st.format,vt=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][st.auto_pad],wt=st.dilations,$t=st.group,Tt=st.kernel_shape,Lt=st.pads,Ft=st.strides,Ct=st.w_is_const();return{autoPad:vt,format:pt,dilations:wt,group:$t,kernelShape:Tt,pads:Lt,strides:Ft,wIsConst:Ct,...at,cacheKey:`${st.format};${at.activation};`}},Ip=(st,at,pt)=>{let vt=Gu(pt,at),wt=pt.format==="NHWC";if(pt.group!==1){if(!st.adapterInfo.isArchitecture("ampere")&&wt&&at[1].dims[0]===pt.group&&at[1].dims[1]===1&&pt.dilations[0]===1&&pt.dilations[1]===1){let qr=oi(at[0].dims,at[1].dims,pt.dilations,vt.pads,pt.strides,wt),Zr=st.kernelCustomData.wT??st.compute(xt(at[1],fo),{inputs:[1],outputs:[pt.wIsConst?-2:-1]})[0];pt.wIsConst&&!st.kernelCustomData.wT&&(st.kernelCustomData.wT=Zr);let Bo=[at[0],Zr];at.length===3&&Bo.push(at[2]),st.compute(Nu(Bo,vt,qr),{inputs:Bo})}else st.compute(lo(at,vt));return}let $t=at.length===3,Tt=at[0].dims[wt?1:2],Lt=at[0].dims[wt?2:3],Ft=at[0].dims[wt?3:1],Ct=at[1].dims[2],Ht=at[1].dims[3],Gt=oi(at[0].dims,at[1].dims,pt.dilations,vt.pads,pt.strides,wt),jt=Gt[wt?1:2],qt=Gt[wt?2:3],Kt=Gt[wt?3:1],An=wt&&Ct===Tt&&Ht===Lt&&pt.pads[0]===0&&pt.pads[1]===0;if(An||Ct===1&&Ht===1&&pt.dilations[0]===1&&pt.dilations[1]===1&&pt.strides[0]===1&&pt.strides[1]===1&&pt.pads[0]===0&&pt.pads[1]===0){let qr=Gt[0],Zr,Bo,Xo,Kr=[];if(wt){let x0=st.kernelCustomData.wT??st.compute(xt(at[1],fo),{inputs:[1],outputs:[pt.wIsConst?-2:-1]})[0];if(pt.wIsConst&&!st.kernelCustomData.wT&&(st.kernelCustomData.wT=x0),An){let l0=Tt*Lt*Ft;Zr=at[0].reshape([1,qr,l0]),Bo=x0.reshape([1,l0,Kt]),Xo=[1,qr,Kt]}else Zr=at[0].reshape([qr,Tt*Lt,Ft]),Bo=x0.reshape([1,Ft,Kt]),Xo=[qr,jt*qt,Kt];Kr.push(Zr),Kr.push(Bo)}else Zr=at[0].reshape([qr,Ft,Tt*Lt]),Bo=at[1].reshape([1,Kt,Ft]),Xo=[qr,Kt,jt*qt],Kr.push(Bo),Kr.push(Zr);$t&&Kr.push(at[2]);let ko=Xo[2],f0=Kr[0].dims[Kr[0].dims.length-1];ko<8&&f0<8?st.compute(po(Kr,vt,Gt,Xo,wt),{inputs:Kr}):st.compute(ii(Kr,vt,Gt,Xo,wt),{inputs:Kr});return}let Sn=!0,wn=st.kernelCustomData.wT??st.compute(xt(at[1],fo),{inputs:[1],outputs:[pt.wIsConst?-2:-1]})[0];pt.wIsConst&&!st.kernelCustomData.wT&&(st.kernelCustomData.wT=wn);let In=[at[0],wn];$t&&In.push(at[2]);let tr=wt?jt*qt:Kt,rr=wt?Kt:jt*qt,Hr=Ct*Ht*Ft;st.compute(Uu(In,vt,Gt,tr,rr,Hr,$t,Sn),{inputs:In})},Tp=(st,at)=>{let pt=at.format==="NHWC",vt=[st.inputs[0].reshape(pt?[st.inputs[0].dims[0],1,st.inputs[0].dims[1],st.inputs[0].dims[2]]:[st.inputs[0].dims[0],st.inputs[0].dims[1],1,st.inputs[0].dims[2]]),st.inputs[1].reshape([st.inputs[1].dims[0],st.inputs[1].dims[1],1,st.inputs[1].dims[2]])];st.inputs.length===3&&vt.push(st.inputs[2]);let wt=[0,at.pads[0],0,at.pads[1]],$t=[1].concat(at.strides),Tt=[1].concat(at.dilations),Lt=[1].concat(at.kernelShape),Ft=Gu({...at,pads:wt,strides:$t,dilations:Tt,kernelShape:Lt},vt);st.compute(lo(vt,Ft,Ct=>pt?[Ct[0],Ct[2],Ct[3]]:[]))},go=(st,at)=>{Cp(st.inputs,at),st.inputs[0].dims.length===3?Tp(st,at):Ip(st,st.inputs,at)}}),Ap,Lu,Fu=j(()=>{ye(),Xt(),_e(),Zt(),ri(),uo(),on(),Ap=(st,at=!1,pt,vt,wt=4)=>{let $t=Sn=>{switch(Sn){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${vt}(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${Sn} is not supported.`)}},Tt=st?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,Lt=st?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,Ft=st?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",Ct=st?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",Ht=st?"row":"col",Gt=st?"col":"row",jt=`
      let inChannels = ${st?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let outWidth = ${st?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      let outRow = ${Ht} / outWidth;
      let outCol = ${Ht} % outWidth;

      let WRow = ${Gt} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${Gt} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${Ft}) || fract(xR) > 0.0) {
        return ${vt}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${Ct}) || fract(xC) > 0.0) {
        return ${vt}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${Gt} % inChannels;
      ${Tt}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${wt}];`,qt=st?`
      let col = colIn * ${wt};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${jt}
      }
      return ${vt}(0.0);`:`
      let col = colIn * ${wt};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${jt}
      }
      return ${vt}(0.0);`,Kt=`
      let col = colIn * ${wt};
      let inChannels = ${st?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${st?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${$t(wt)}
      }
      return ${vt}(0.0);
      `,An=kt(pt,vt);return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${vt} {
    ${st?qt:Kt}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${vt} {
    ${st?Kt:qt}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${vt}) {
    let col = colIn * ${wt};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${st?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${Lt}
      ${ti(at)}
      ${An}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${wt}] = value;
    }
  }`},Lu=(st,at,pt,vt,wt,$t,Tt,Lt)=>{let Ft=at.format==="NHWC",Ct=Ft?st[0].dims[3]:st[0].dims[1],Ht=pt[0],Gt=Ft?pt[2]:pt[3],jt=Ft?pt[1]:pt[2],qt=Ft?pt[3]:pt[1],Kt=Ft&&Ct%4===0&&Ct%3&&qt%4===0,An=Ft?qt:Gt*jt,Sn=Ft?Gt*jt:qt,wn=[8,8,1],In=vt<=8?[4,1,1]:[4,4,1],tr=[Math.ceil(An/wn[0]/In[0]),Math.ceil(Sn/wn[1]/In[1]),Math.ceil(Ht/wn[2]/In[2])];Ne("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${tr}`);let rr=Kt?4:1,Hr=Math.max(wn[0]*rr,wn[1]),qr=Kt?4:1,Zr=[at.kernelShape[Ft?1:2],at.kernelShape[Ft?2:3]],Bo=[Zr[0]+(at.dilations[0]<=1?0:(Zr[0]-1)*(at.dilations[0]-1)),Zr[1]+(at.dilations[1]<=1?0:(Zr[1]-1)*(at.dilations[1]-1))],Xo=[Bo[0]-1-Math.floor((at.pads[0]+at.pads[2])/2),Bo[1]-1-Math.floor((at.pads[1]+at.pads[3])/2)],Kr=[{type:6,data:vt},{type:6,data:wt},{type:6,data:$t},{type:6,data:at.strides},{type:6,data:at.dilations},{type:6,data:Zr},{type:6,data:Xo}];Ot(at,Kr),Kr.push(...X(st[0].dims,st[1].dims));let ko=["rank","rank"];Tt&&(Kr.push(...X(st[2].dims)),ko.push("rank")),Kr.push(...X(pt));let f0=x0=>{let l0=U("x",st[0].dataType,st[0].dims.length,qr),T0=U("w",st[1].dataType,st[1].dims.length,1),t0=K("result",st[0].dataType,pt.length,qr),E0=[l0,T0],n0="";if(Tt){let a0=U("bias",st[2].dataType,st[2].dims.length,qr);E0.push(a0),n0+=`
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${a0.type.value} {
            return bias[coords.${Ft?"w":"y"}${Kt?"/ 4":""}];
          }`}let m0=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:Zr.length},{name:"pads",type:"i32",length:Xo.length}];Pt(at,m0);let h0=De(st[0].dataType,1);if(h0!=="f16"&&h0!=="f32")throw new Error(`elemType ${h0} is not supported.`);return`
        ${ni("uniforms.result_strides")}
        ${x0.registerUniforms(m0).declareVariables(...E0,t0)};
        ${n0}
        ${Ap(Ft,Tt,at,l0.type.value,rr)}
        ${Kt?rn(In,wn,h0,void 0,!Ft,Hr):nn(In,wn,h0,void 0,!Ft,Hr,!1,void 0,Lt)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${at.cacheKey};${In};${wn};${Kt}`,inputDependencies:ko},getRunData:()=>({outputs:[{dims:pt,dataType:st[0].dataType}],dispatchGroup:{x:tr[0],y:tr[1],z:tr[2]},programUniforms:Kr}),getShaderSource:f0}}}),Ep,yo,qu=j(()=>{ye(),Xt(),xe(),_e(),Ep=(st,at,pt,vt,wt,$t=!1,Tt,Lt,Ft=!1)=>{let Ct=Ft?1:2,Ht=Ft?2:3,Gt=Ft?3:1,jt=$t?2:1,qt=`
  fn setOutputAtIndex(flatIndex : u32, value : ${$t?`vec4<${Tt}>`:Tt}) {
    result[flatIndex] = ${$t?`vec4<${Tt}>`:Tt}(value);
  }`;vt&&(qt+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${$t?`vec4<${Tt}>`:Tt} {
      return bias[coords.${Ft?"w":"y"}${$t?"/ 4":""}];
    }`);let Kt=$t?4:1,An=U("W",at[1].dataType,at[1].dims.length,Kt),Sn=U("Dy",at[0].dataType,at[0].dims.length,Kt),wn=[Sn,An];vt&&wn.push(U("bias",at[2].dataType,[pt[Gt]].length,Kt));let In=K("result",at[0].dataType,pt.length,Kt),tr=`{
        let batch: u32 = ${wt?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];
        let r = ${wt?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];
        let c = ${wt?"global_id.y":"workgroup_id.y"} * ${jt};
        let d1: u32 = ${wt?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${Tt}>, ${jt}>;
        for (var i = 0; i < ${jt}; i++) {
          dotProd[i] = vec4<${Tt}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${Tt}(dyCorner.x) + ${Tt}(wR)) / ${Tt}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${Tt}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${Tt}(dyCorner.y) + ${Tt}(wC)) / ${Tt}(uniforms.strides.y);
            let dyC2 = (${Tt}(dyCorner.y) + 1.0 + ${Tt}(wC)) / ${Tt}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${Tt}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${Tt}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${An.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${An.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${An.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${An.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Sn.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${Tt}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${Sn.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${Tt}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${Gt}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${An.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${An.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${An.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${An.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Sn.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${Tt}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${An.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${An.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${An.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${An.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Sn.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${Tt}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${jt}; i = i + 1) {
          let value = dotProd[i] + ${vt?"bias[c+i]":`vec4<${Tt}>(0.0)`};
          ${In.set("batch","r","c + i","d1","value")};
        }
      }`,rr=`
          let outputIndices = ${In.offsetToIndices("global_idx")};
          let batch = ${In.indicesGet("outputIndices",0)};
          let d1 = ${In.indicesGet("outputIndices",Gt)};
          let r = ${In.indicesGet("outputIndices",Ct)};
          let c = ${In.indicesGet("outputIndices",Ht)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${Tt}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${Tt}(dyRCorner) + ${Tt}(wR)) / ${Tt}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${Tt}(uniforms.Dy_shape[${Ct}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${Tt}(dyCCorner) + ${Tt}(wC)) / ${Tt}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${Tt}(uniforms.Dy_shape[${Ht}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${Ft?Sn.get("batch","idyR","idyC","inputChannel"):Sn.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${An.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${vt?"bias[d1]":`${Tt}(0.0)`};
          ${In.setByOffset("global_idx","value")};
        `;return`
  ${st.registerUniforms(Lt).declareVariables(...wn,In)}
  ${qt}

    ${st.mainStart()}
    ${st.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${$t?tr:rr}}`},yo=(st,at,pt)=>{let vt=st.length>2,wt=at.outputShape,$t=M.size(wt),Tt=[Math.ceil($t/64),1,1];Ne("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${Tt}`);let Lt=at.format==="NHWC",Ft=["rank","rank"],Ct=[at.strides[0],at.strides[1]],Ht=[at.kernelShape[Lt?1:2],at.kernelShape[Lt?2:3]],Gt=[at.dilations[0],at.dilations[1]],jt=[Ht[0]+(at.dilations[0]<=1?0:(at.kernelShape[Lt?1:2]-1)*(at.dilations[0]-1)),Ht[1]+(at.dilations[1]<=1?0:(at.kernelShape[Lt?2:3]-1)*(at.dilations[1]-1))],qt=[jt[0]-1-Math.floor((at.pads[0]+at.pads[2])/2),jt[1]-1-Math.floor(at.pads[1]+at.pads[3])/2],Kt=!1,An=at.group,Sn=st[1].dims,wn=Sn[0]/An,In=Sn[1],tr=[{type:12,data:$t},{type:12,data:Ct},{type:12,data:Ht},{type:12,data:Gt},{type:12,data:jt},{type:6,data:qt},{type:12,data:wn},{type:12,data:In},...X(st[0].dims,st[1].dims)];vt&&(tr.push(...X(st[2].dims)),Ft.push("rank")),tr.push(...X(wt));let rr=Tt[1]===1&&Tt[2]===1,Hr=qr=>{let Zr=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:Ct.length},{name:"filter_dims",type:"u32",length:Ht.length},{name:"dilations",type:"u32",length:Ht.length},{name:"effective_filter_dims",type:"u32",length:jt.length},{name:"pads",type:"i32",length:qt.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],Bo=De(st[0].dataType);return`${Ep(qr,st,wt,vt,rr,Kt,Bo,Zr,Lt)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${at.cacheKey};`,inputDependencies:Ft},getRunData:()=>({dispatchGroup:{x:Tt[0],y:Tt[1],z:Tt[2]},outputs:[{dims:pt?pt(wt):wt,dataType:st[0].dataType}],programUniforms:tr}),getShaderSource:Hr}}}),kp,Op,Pp,ju,Ku,Rp,zp,Bp,Dp,Yu,Xu=j(()=>{Fu(),qu(),Zt(),Rr(),kp=(st,at,pt,vt,wt,$t)=>(st-1)*at+pt+(vt-1)*wt+1-$t,Op=(st,at,pt,vt,wt)=>{let $t=Math.floor(st/2);at==="SAME_UPPER"?(pt[vt]=$t,pt[wt]=st-$t):at==="SAME_LOWER"&&(pt[vt]=st-$t,pt[wt]=$t)},Pp=(st,at,pt,vt,wt,$t,Tt,Lt,Ft,Ct)=>{let Ht=st.length-2,Gt=Ct.length===0;if(Ft.length===0)for(let Kt=0;Kt<Ht;++Kt)Ft.push(0);let jt=st[0],qt=at[Lt?3:1]*wt;for(let Kt=0,An=st.length-Ht-(Lt?1:0);Kt<Ht;++Kt,++An){let Sn=st[An],wn=Gt?Sn*Tt[Kt]:Ct[Kt],In=kp(Sn,Tt[Kt],$t[Kt],at[An],pt[Kt],wn);Op(In,vt,$t,Kt,Kt+Ht),Gt&&Ct.push(Tt[Kt]*(Sn-1)+Ft[Kt]+(at[An]-1)*pt[Kt]+1-$t[Kt]-$t[Kt+Ht])}Ct.splice(0,0,jt),Ct.splice(Lt?3:1,0,qt)},ju=(st,at)=>{let pt=st.kernelShape.slice();if(st.kernelShape.length===0||st.kernelShape.reduce((Gt,jt)=>Gt*jt,1)===0){pt.length=0;for(let Gt=2;Gt<at[1].dims.length;++Gt)pt.push(at[1].dims[Gt])}let vt=st.format==="NHWC";pt.splice(0,0,at[1].dims[0]),pt.splice(vt?3:1,0,at[1].dims[1]);let wt=st.pads.slice(),$t=st.outputShape.slice(),Tt=st.outputPadding.slice(),Lt=at[0].dims,Ft=st.dilations.slice();if(Ft.reduce((Gt,jt)=>Gt+jt,0)===0){let Gt=at[0].dims.length-2;Ft=new Array(Gt).fill(1)}let Ct=st.strides.slice();if(Ct.reduce((Gt,jt)=>Gt+jt,0)===0){let Gt=at[0].dims.length-2;Ct=new Array(Gt).fill(1)}Pp(Lt,pt,Ft,st.autoPad,st.group,wt,Ct,vt,Tt,$t);let Ht=Object.assign({},st);return Object.assign(Ht,{kernelShape:pt,pads:wt,outputPadding:Tt,outputShape:$t,dilations:Ft,strides:Ct}),Ht},Ku=st=>{let at=ei(st),pt=st.format,vt=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof st.autoPad>"u"?0:st.autoPad],wt=st.dilations,$t=st.group,Tt=st.kernelShape,Lt=st.pads,Ft=st.strides,Ct=st.wIsConst(),Ht=st.outputPadding,Gt=st.outputShape;return{autoPad:vt,format:pt,dilations:wt,group:$t,kernelShape:Tt,outputPadding:Ht,outputShape:Gt,pads:Lt,strides:Ft,wIsConst:Ct,...at,cacheKey:`${st.format};${at.activation};`}},Rp=(st,at)=>{if(!st||st.length!==2&&st.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(st[0].dims.length!==4&&st[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(st[0].dims.length!==st[1].dims.length)throw new Error("filter does not have same dimension as input");let pt=st[0].dims[at.format==="NHWC"?st[0].dims.length-1:1],vt=st[1].dims[0];if(pt!==vt)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let wt=st[1].dims[1]*at.group;if(st.length===3&&(st[2].dims.length!==1||st[2].dims[0]!==wt))throw new Error("invalid bias");let $t=st[0].dims.length-2;if(at.dilations.reduce((Tt,Lt)=>Tt+Lt,0)>0&&at.dilations.length!==$t)throw new Error(`dilations should be ${$t}D`);if(at.strides.reduce((Tt,Lt)=>Tt+Lt,0)>0&&at.strides.length!==$t)throw new Error(`strides should be ${$t}D`);if(at.pads.reduce((Tt,Lt)=>Tt+Lt,0)>0&&at.pads.length!==$t*2)throw new Error(`pads should be ${$t*2}D`);if(at.outputPadding.length!==$t&&at.outputPadding.length!==0)throw new Error(`output_padding should be ${$t}D`);if(at.kernelShape.reduce((Tt,Lt)=>Tt+Lt,0)>0&&at.kernelShape.length!==0&&at.kernelShape.length!==st[1].dims.length-2)throw new Error("invalid kernel shape");if(at.outputShape.length!==0&&at.outputShape.length!==st[0].dims.length-2)throw new Error("invalid output shape")},zp=[2,3,1,0],Bp=(st,at,pt)=>{let vt=ju(pt,at),wt=pt.format==="NHWC",$t=vt.outputShape,Tt=$t[wt?3:1],Lt=at[0].dims[wt?3:1];if(vt.group!==1||Tt===1&&Lt===1){st.compute(yo(at,vt));return}let Ft=$t[wt?1:2],Ct=$t[wt?2:3],Ht=at[1].dims[2],Gt=at[1].dims[3],jt=wt?Ft*Ct:Tt,qt=wt?Tt:Ft*Ct,Kt=Ht*Gt*Lt,An=!0,Sn=st.kernelCustomData.wT??st.compute(xt(at[1],zp),{inputs:[1],outputs:[pt.wIsConst?-2:-1]})[0];pt.wIsConst&&!st.kernelCustomData.wT&&(st.kernelCustomData.wT=Sn);let wn=[at[0],Sn],In=at.length===3;In&&(!wt&&at[2].dims.length===1?wn.push(at[2].reshape([at[2].dims[0],1,1])):wn.push(at[2])),st.compute(Lu(wn,vt,$t,jt,qt,Kt,In,An),{inputs:wn})},Dp=(st,at)=>{let pt=at.format==="NHWC",vt=[st.inputs[0].reshape(pt?[st.inputs[0].dims[0],1,st.inputs[0].dims[1],st.inputs[0].dims[2]]:[st.inputs[0].dims[0],st.inputs[0].dims[1],1,st.inputs[0].dims[2]]),st.inputs[1].reshape([st.inputs[1].dims[0],st.inputs[1].dims[1],1,st.inputs[1].dims[2]])];st.inputs.length===3&&vt.push(st.inputs[2]);let wt=at.kernelShape;(wt.length===0||wt[0]===0)&&(wt=[st.inputs[1].dims[2]]);let $t=at.dilations;($t.length===0||$t[0]===0)&&($t=[1]);let Tt=at.strides;(Tt.length===0||Tt[0]===0)&&(Tt=[1]);let Lt=at.pads;Lt.length===0&&(Lt=[0,0]),Lt=[0,Lt[0],0,Lt[1]],Tt=[1].concat(Tt),$t=[1].concat($t),wt=[1].concat(wt);let Ft=ju({...at,pads:Lt,strides:Tt,dilations:$t,kernelShape:wt},vt);st.compute(yo(vt,Ft,Ct=>pt?[Ct[0],Ct[2],Ct[3]]:[Ct[0],Ct[1],Ct[3]]))},Yu=(st,at)=>{Rp(st.inputs,at),st.inputs[0].dims.length===3?Dp(st,at):Bp(st,st.inputs,at)}}),Mp,Zu,Qu,Ju=j(()=>{ye(),xe(),Ze(),_e(),Mp=(st,at,pt,vt)=>{let wt=M.size(at),$t=at.length,Tt=U("input",st,$t),Lt=K("output",st,$t),Ft=pt.dataType===6?pt.getInt32Array()[0]:Number(pt.getBigInt64Array()[0]),Ct=M.normalizeAxis(Ft,$t),Ht=Gt=>{let jt=` i32(${Tt.indicesGet("inputIndices","uniforms.axis")}) `,qt=fe("uniforms.input_shape","uniforms.axis",$t),Kt=vt.reverse?jt+(vt.exclusive?" + 1":""):"0",An=vt.reverse?qt:jt+(vt.exclusive?"":" + 1");return`
                ${Gt.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(Tt,Lt)}
                ${Gt.mainStart()}
                  ${Gt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${Lt.offsetToIndices("global_idx")};
                  var sum = ${Lt.type.value}(0);
                  let first : i32 = ${Kt};
                  let last : i32 = ${An};
                  for (var i : i32 = first; i < last; i++) {
                    ${Tt.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${Tt.getByIndices("inputIndices")};
                  }
                  ${Lt.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:vt.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:at,dataType:st}],dispatchGroup:{x:Math.ceil(wt/64)},programUniforms:[{type:12,data:wt},{type:12,data:Ct},...X(at,at)]}),getShaderSource:Ht}},Zu=(st,at)=>{let pt=st.inputs[0].dims,vt=st.inputs[0].dataType,wt=st.inputs[1];st.compute(Mp(vt,pt,wt,at),{inputs:[0]})},Qu=st=>{let at=st.exclusive===1,pt=st.reverse===1;return we({exclusive:at,reverse:pt})}}),Up,Wp,Np,el,tl,rl=j(()=>{ye(),xe(),Ze(),_e(),Up=st=>{if(!st||st.length!==1)throw new Error("DepthToSpace requires 1 input.");if(st[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},Wp=(st,at,pt,vt)=>{let wt=[];wt.push(`fn perm(i: ${vt.type.indices}) -> ${pt.type.indices} {
    var a: ${pt.type.indices};`);for(let $t=0;$t<at;++$t)wt.push(pt.indicesSet("a",st[$t],`i[${$t}]`));return wt.push("return a;}"),wt.join(`
`)},Np=(st,at)=>{let pt,vt,wt,$t,Tt,Lt,Ft=at.format==="NHWC",Ct=at.blocksize,Ht=at.mode==="DCR";Ft?([pt,vt,wt,$t]=st.dims,Tt=Ht?[pt,vt,wt,Ct,Ct,$t/Ct**2]:[pt,vt,wt,$t/Ct**2,Ct,Ct],Lt=Ht?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([pt,vt,wt,$t]=[st.dims[0],st.dims[2],st.dims[3],st.dims[1]],Tt=Ht?[pt,Ct,Ct,$t/Ct**2,vt,wt]:[pt,$t/Ct**2,Ct,Ct,vt,wt],Lt=Ht?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let Gt=st.reshape(Tt),jt=Gt.dims.length,qt=st.dataType,Kt=U("a",qt,jt),An=K("output",qt,jt),Sn=wn=>`
  ${wn.registerUniform("output_size","u32").declareVariables(Kt,An)}

  ${Wp(Lt,jt,Kt,An)}

  ${wn.mainStart()}
    ${wn.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${An.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${An.setByOffset("global_idx",Kt.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${st.dims};${at.blocksize};${at.mode}`,inputDependencies:["rank"]},getRunData:wn=>{let In=Ft?[pt,vt*Ct,wt*Ct,$t/Ct**2]:[pt,$t/Ct**2,vt*Ct,wt*Ct],tr=M.size(In),rr=Gt.dims,Hr=M.sortBasedOnPerm(rr,Lt);return{outputs:[{dims:In,dataType:wn[0].dataType}],dispatchGroup:{x:Math.ceil(tr/64)},programUniforms:[{type:12,data:tr},...X(rr,Hr)]}},getShaderSource:Sn}},el=(st,at)=>{Up(st.inputs),st.compute(Np(st.inputs[0],at))},tl=st=>we({blocksize:st.blocksize,mode:st.mode,format:st.format})}),bo,ai,nl,Vp,Hp,vo,wo,il,Gp,ol,al,sl=j(()=>{ye(),xe(),Ze(),_e(),bo="[a-zA-Z]|\\.\\.\\.",ai="("+bo+")+",nl="^"+ai+"$",Vp="("+ai+",)*"+ai,Hp="^"+Vp+"$",vo=class{constructor(st=-1){this.symbolToIndices=new Map,this.inputIndex=st}addSymbol(st,at){let pt=this.symbolToIndices.get(st);pt===void 0?pt=[at]:pt.push(at),this.symbolToIndices.set(st,pt)}},wo=class{constructor(st,at){var wt;this.equation=at,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[pt,vt]=at.includes("->")?at.split("->",2):[at,""];if(!pt.match(RegExp(Hp)))throw new Error("Invalid LHS term");if(pt.split(",").forEach(($t,Tt)=>{let Lt=st[Tt].dims.slice();if(!$t.match(RegExp(nl)))throw new Error("Invalid LHS term");let Ft=this.processTerm($t,!0,Lt,Tt);this.lhs.push(Ft)}),vt==="")vt+=[...this.symbolToInfo.entries()].filter(([$t,Tt])=>Tt.count===1||$t==="...").map(([$t])=>$t).join("");else if(!vt.match(RegExp(ai)))throw new Error("Invalid RHS");(wt=vt.match(RegExp(bo,"g")))==null||wt.forEach($t=>{if($t==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let Tt=this.symbolToInfo.get($t);if(Tt===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(Tt.dimValue)}}),this.rhs=this.processTerm(vt,!1,this.outputDims)}addSymbol(st,at,pt){let vt=this.symbolToInfo.get(st);if(vt!==void 0){if(vt.dimValue!==at&&vt.count!==1)throw new Error("Dimension mismatch");vt.count++,vt.inputIndices.push(pt)}else vt={count:1,dimValue:at,inputIndices:[pt]};this.symbolToInfo.set(st,vt)}processTerm(st,at,pt,vt=-1){let wt=pt.length,$t=!1,Tt=[],Lt=0;if(!st.match(RegExp(nl))&&!at&&st!=="")throw new Error("Invalid LHS term");let Ft=st.match(RegExp(bo,"g")),Ct=new vo(vt);return Ft==null||Ft.forEach((Ht,Gt)=>{if(Ht==="..."){if($t)throw new Error("Only one ellipsis is allowed per input term");$t=!0;let jt=wt-Ft.length+1;if(jt<0)throw new Error("Ellipsis out of bounds");if(Tt=pt.slice(Lt,Lt+jt),this.hasEllipsis){if(this.ellipsisDims.length!==Tt.length||this.ellipsisDims.toString()!==Tt.toString())throw new Error("Ellipsis dimensions mismatch")}else if(at)this.hasEllipsis=!0,this.ellipsisDims=Tt;else throw new Error("Ellipsis must be specified in the LHS");for(let qt=0;qt<Tt.length;qt++){let Kt=String.fromCharCode(48+qt);Ct.addSymbol(Kt,Gt+qt),this.addSymbol(Kt,pt[Lt++],vt)}}else Ct.addSymbol(Ht,Gt+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(Ht,pt[Lt++],vt)}),Ct}},il=st=>st+"_max",Gp=(st,at,pt,vt)=>{let wt=st.map(Ct=>Ct.length).map((Ct,Ht)=>U(`input${Ht}`,at,Ct)),$t=M.size(vt),Tt=K("output",at,vt.length),Lt=[...pt.symbolToInfo.keys()].filter(Ct=>!pt.rhs.symbolToIndices.has(Ct)),Ft=Ct=>{let Ht=[],Gt="var prod = 1.0;",jt="var sum = 0.0;",qt="sum += prod;",Kt=[],An=[],Sn=[],wn=[],In=pt.symbolToInfo.size===pt.rhs.symbolToIndices.size;pt.symbolToInfo.forEach((rr,Hr)=>{var qr;if(pt.rhs.symbolToIndices.has(Hr)){let Zr=(qr=pt.rhs.symbolToIndices.get(Hr))==null?void 0:qr[0];Zr!==void 0&&pt.lhs.forEach((Bo,Xo)=>{if(rr.inputIndices.includes(Xo)){let Kr=Bo.symbolToIndices.get(Hr);if(Kr===void 0)throw new Error("Invalid symbol error");Kr.forEach(ko=>{Ht.push(`${wt[Xo].indicesSet(`input${Xo}Indices`,ko,Tt.indicesGet("outputIndices",Zr))}`)})}})}else pt.lhs.forEach((Zr,Bo)=>{if(rr.inputIndices.includes(Bo)){let Xo=Zr.symbolToIndices.get(Hr);if(Xo===void 0)throw new Error("Invalid symbol error");Xo.forEach(Kr=>{Kt.push(`${wt[Bo].indicesSet(`input${Bo}Indices`,Kr,`${Hr}`)}`)}),wn.push(`prod *= ${wt[Bo].getByIndices(`input${Bo}Indices`)};`)}}),An.push(`for(var ${Hr}: u32 = 0; ${Hr} < uniforms.${il(Hr)}; ${Hr}++) {`),Sn.push("}")});let tr=In?[...Ht,`let sum = ${wt.map((rr,Hr)=>rr.getByIndices(`input${Hr}Indices`)).join(" * ")};`]:[...Ht,jt,...An,...Kt,Gt,...wn,qt,...Sn];return`
            ${Ct.registerUniforms(Lt.map(rr=>({name:`${il(rr)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...wt,Tt)}

            ${Ct.mainStart()}
            ${Ct.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${Tt.offsetToIndices("global_idx")};
            ${wt.map((rr,Hr)=>`var input${Hr}Indices: ${wt[Hr].type.indices};`).join(`
`)}
            ${tr.join(`
`)};
            ${Tt.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:pt.equation,inputDependencies:st.map(()=>"rank")},getRunData:()=>{let Ct=Lt.filter(Gt=>pt.symbolToInfo.has(Gt)).map(Gt=>{var jt;return{type:12,data:((jt=pt.symbolToInfo.get(Gt))==null?void 0:jt.dimValue)||0}});Ct.push({type:12,data:$t});let Ht=st.map((Gt,jt)=>[...X(Gt)]).reduce((Gt,jt)=>Gt.concat(jt),Ct);return Ht.push(...X(vt)),{outputs:[{dims:vt,dataType:at}],dispatchGroup:{x:Math.ceil($t/64)},programUniforms:Ht}},getShaderSource:Ft}},ol=(st,at)=>{let pt=new wo(st.inputs,at.equation),vt=pt.outputDims,wt=st.inputs.map(($t,Tt)=>$t.dims);st.compute(Gp(wt,st.inputs[0].dataType,pt,vt))},al=st=>{let at=st.equation.replace(/\s+/g,"");return we({equation:at})}}),Lp,ul,Fp,qp,ll,dl=j(()=>{ye(),xe(),_e(),Lp=st=>{if(!st||st.length!==2)throw new Error("Expand requires 2 input.");let at=st[0].dims,pt=Array.from(st[1].getBigInt64Array(),Number),vt=pt.length<at.length?0:pt.length-at.length,wt=at.length<pt.length?0:at.length-pt.length;for(;vt<pt.length&&wt<at.length;++vt,++wt)if(pt[vt]!==at[wt]&&pt[vt]!==1&&at[wt]!==1)throw new Error("Expand requires shape to be broadcastable to input")},ul=(st,at)=>{let pt=st.length-at.length,vt=[];for(let wt=0;wt<pt;++wt)vt.push(st[wt]);for(let wt=0;wt<at.length;++wt)vt.push(at[wt]===1?st[wt+pt]:at[wt]);return vt},Fp=(st,at)=>st.length>at.length?ul(st,at):ul(at,st),qp=st=>{let at=st[0].dims,pt=Array.from(st[1].getBigInt64Array(),Number),vt=Fp(at,pt),wt=st[0].dataType,$t=wt===9?4:1,Tt=Math.ceil(M.size(vt)/$t),Lt=Ct=>{let Ht=U("input",wt,at.length,$t),Gt=K("output",wt,vt.length,$t),jt;if(wt===9){let qt=(Kt,An,Sn="")=>`
          let outputIndices${An} = ${Gt.offsetToIndices(`outputOffset + ${An}u`)};
          let offset${An} = ${Ht.broadcastedIndicesToOffset(`outputIndices${An}`,Gt)};
          let index${An} = offset${An} / 4u;
          let component${An} = offset${An} % 4u;
          ${Kt}[${An}] = ${Sn}(${Ht.getByOffset(`index${An}`)}[component${An}]);
        `;jt=`
        let outputOffset = global_idx * ${$t};
        var data = vec4<u32>(0);
        ${qt("data",0,"u32")}
        ${qt("data",1,"u32")}
        ${qt("data",2,"u32")}
        ${qt("data",3,"u32")}
        ${Gt.setByOffset("global_idx","data")}
      }`}else jt=`
        let outputIndices = ${Gt.offsetToIndices("global_idx")};
        let inputOffset = ${Ht.broadcastedIndicesToOffset("outputIndices",Gt)};
        ${Gt.setByOffset("global_idx",Ht.getByOffset("inputOffset"))}
      }`;return`
    ${Ct.registerUniform("vec_size","u32").declareVariables(Ht,Gt)}
    ${Ct.mainStart()}
    ${Ct.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${jt}`},Ft=[{type:12,data:Tt},...X(at,vt)];return{name:"Expand",shaderCache:{hint:`${vt.length}`,inputDependencies:["rank"]},getShaderSource:Lt,getRunData:()=>({outputs:[{dims:vt,dataType:st[0].dataType}],dispatchGroup:{x:Math.ceil(Tt/64)},programUniforms:Ft})}},ll=st=>{Lp(st.inputs),st.compute(qp(st.inputs),{inputs:[0]})}}),jp,cl,pl=j(()=>{ye(),xe(),_e(),Jn(),jp=st=>{let at=st[0].dataType,pt=M.size(st[0].dims),vt=M.size(st[1].dims),wt=vt%4===0,$t=Tt=>{let Lt=U("x",at,[1],4),Ft=U("bias",at,[1],4),Ct=K("y",at,[1],4),Ht=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],Gt=qt=>`
      let bias${qt}_offset: u32 = (global_idx * 4 + ${qt}) % uniforms.bias_size;
      let bias${qt} = ${Ft.getByOffset(`bias${qt}_offset / 4`)}[bias${qt}_offset % 4];`,jt=wt?`
      let bias = ${Ft.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${Gt(0)}${Gt(1)}${Gt(2)}${Gt(3)}
      let bias = ${Lt.type.value}(bias0, bias1, bias2, bias3);`;return`${Tt.registerUniforms(Ht).declareVariables(Lt,Ft,Ct)}

    ${ao(rt(at))}

    ${Tt.mainStart(mr)}
      ${Tt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${Lt.getByOffset("global_idx")};
      ${jt}
      let x_in = x + bias;
      ${Ct.setByOffset("global_idx",so("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${wt}`,inputDependencies:["type","type"]},getShaderSource:$t,getRunData:Tt=>({outputs:[{dims:Tt[0].dims,dataType:Tt[0].dataType}],programUniforms:[{type:12,data:Math.ceil(pt/4)},{type:12,data:vt}],dispatchGroup:{x:Math.ceil(pt/mr/4)}})}},cl=st=>{st.inputs.length<2||M.size(st.inputs[1].dims)===0?wu(st):st.compute(jp(st.inputs))}}),Kp,Yp,ml,fl,hl=j(()=>{ye(),xe(),Ze(),_e(),Kp=st=>{if(!st||st.length!==2)throw new Error("Gather requires 2 inputs.")},Yp=(st,at)=>{let pt=st[0].dims,vt=st[1].dims,wt=pt.length,$t=M.normalizeAxis(at.axis,wt),Tt=pt.slice(0);Tt.splice($t,1,...vt);let Lt=pt[$t],Ft=st[0].dataType===9?4:1,Ct=Math.ceil(M.size(Tt)/Ft),Ht=[{type:12,data:Ct},{type:6,data:Lt},{type:12,data:$t},...X(st[0].dims,st[1].dims,Tt)],Gt=jt=>{let qt=U("data",st[0].dataType,st[0].dims.length,Ft),Kt=U("inputIndices",st[1].dataType,st[1].dims.length),An=K("output",st[0].dataType,Tt.length,Ft),Sn=In=>{let tr=vt.length,rr=`var indicesIndices${In}  = ${Kt.type.indices}(0);`;for(let Hr=0;Hr<tr;Hr++)rr+=`${tr>1?`indicesIndices${In}[${Hr}]`:`indicesIndices${In}`} = ${Tt.length>1?`outputIndices${In}[uniforms.axis + ${Hr}]`:`outputIndices${In}`};`;rr+=`
          var idx${In} = ${Kt.getByIndices(`indicesIndices${In}`)};
          if (idx${In} < 0) {
            idx${In} = idx${In} + uniforms.axisDimLimit;
          }
          var dataIndices${In} : ${qt.type.indices};
        `;for(let Hr=0,qr=0;Hr<wt;Hr++)Hr===$t?(rr+=`${wt>1?`dataIndices${In}[${Hr}]`:`dataIndices${In}`} = u32(idx${In});`,qr+=tr):(rr+=`${wt>1?`dataIndices${In}[${Hr}]`:`dataIndices${In}`} = ${Tt.length>1?`outputIndices${In}[${qr}]`:`outputIndices${In}`};`,qr++);return rr},wn;if(st[0].dataType===9){let In=(tr,rr,Hr="")=>`
          let outputIndices${rr} = ${An.offsetToIndices(`outputOffset + ${rr}u`)};
          ${Sn(rr)};
          let offset${rr} = ${qt.indicesToOffset(`dataIndices${rr}`)};
          let index${rr} = offset${rr} / 4u;
          let component${rr} = offset${rr} % 4u;
          ${tr}[${rr}] = ${Hr}(${qt.getByOffset(`index${rr}`)}[component${rr}]);
        `;wn=`
        let outputOffset = global_idx * ${Ft};
        var value = vec4<u32>(0);
        ${In("value",0,"u32")}
        ${In("value",1,"u32")}
        ${In("value",2,"u32")}
        ${In("value",3,"u32")}
        ${An.setByOffset("global_idx","value")}
      `}else wn=`
      let outputIndices = ${An.offsetToIndices("global_idx")};
      ${Sn("")};
      let value = ${qt.getByIndices("dataIndices")};
      ${An.setByOffset("global_idx","value")};
      `;return`
      ${jt.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(qt,Kt,An)}
      ${jt.mainStart()}
        ${jt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${wn}
      }`};return{name:"Gather",shaderCache:{hint:at.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:Tt,dataType:st[0].dataType}],dispatchGroup:{x:Math.ceil(Ct/64)},programUniforms:Ht}),getShaderSource:Gt}},ml=st=>we({axis:st.axis}),fl=(st,at)=>{let pt=st.inputs;Kp(pt),st.compute(Yp(st.inputs,at))}}),Xp,Zp,gl,yl,bl=j(()=>{ye(),xe(),Ze(),_e(),Xp=st=>{if(!st||st.length!==2)throw new Error("GatherElements requires 2 inputs.");if(st[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(st[0].dims.length!==st[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},Zp=(st,at)=>{let pt=st[0].dims,vt=st[0].dataType,wt=pt.length,$t=st[1].dims,Tt=st[1].dataType,Lt=M.normalizeAxis(at.axis,wt),Ft=pt[Lt],Ct=$t.slice(0),Ht=M.size(Ct),Gt=U("input",vt,wt),jt=U("indicesInput",Tt,$t.length),qt=K("output",vt,Ct.length),Kt=[{type:12,data:Ht},{type:6,data:Ft},{type:12,data:Lt}];return Kt.push(...X(pt,$t,Ct)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:Ct,dataType:st[0].dataType}],dispatchGroup:{x:Math.ceil(Ht/64)},programUniforms:Kt}),getShaderSource:An=>`
      ${An.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(Gt,jt,qt)}
      ${An.mainStart()}
      ${An.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${qt.offsetToIndices("global_idx")};

      var idx = ${jt.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${Gt.type.indices}(outputIndices);
      ${Gt.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${Gt.getByIndices("inputIndices")};

      ${qt.setByOffset("global_idx","value")};
  }`}},gl=st=>we({axis:st.axis}),yl=(st,at)=>{let pt=st.inputs;Xp(pt),st.compute(Zp(st.inputs,at))}}),Qp,Jp,vl,wl,$l=j(()=>{ye(),xe(),_e(),Qp=st=>{if(!st)throw new Error("Input is missing");if(st.length<2||st.length>3)throw new Error("Invaid input number.");if(st.length===3&&st[2].dims.length>2)throw new Error("Invalid input shape of C");if(st[0].dataType!==st[1].dataType||st.length===3&&st[0].dataType!==st[2].dataType)throw new Error("Input types are mismatched")},Jp=(st,at)=>{let pt=st[0].dims.slice(),vt=st[1].dims.slice(),[wt,$t,Tt]=Gn.getShapeOfGemmResult(pt,at.transA,vt,at.transB,st.length===3?st[2].dims:void 0),Lt=[wt,$t];if(!Lt)throw new Error("Can't use gemm on the given tensors");let Ft=M.size(Lt),Ct=[{type:12,data:Ft},{type:12,data:wt},{type:12,data:$t},{type:12,data:Tt},{type:1,data:at.alpha},{type:1,data:at.beta}],Ht=["type","type"];st.length===3&&(Ct.push(...X(st[2].dims)),Ht.push("rank")),Ct.push(...X(Lt));let Gt=jt=>{let qt="";at.transA&&at.transB?qt="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":at.transA&&!at.transB?qt="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!at.transA&&at.transB?qt="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!at.transA&&!at.transB&&(qt="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let Kt=at.alpha===1?"":"value *= uniforms.alpha;",An=U("a",st[0].dataType,st[0].dims),Sn=U("b",st[1].dataType,st[1].dims),wn=An.type.value,In=null,tr=[An,Sn];st.length===3&&(In=U("c",st[2].dataType,st[2].dims.length),tr.push(In));let rr=K("output",st[0].dataType,Lt.length);tr.push(rr);let Hr=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${jt.registerUniforms(Hr).declareVariables(...tr)}

  ${jt.mainStart()}
    ${jt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${wn}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${qt}
    }

    ${Kt}
    ${In!=null?`let cOffset = ${In.broadcastedIndicesToOffset("vec2(m, n)",rr)}; value += ${wn}(uniforms.beta) * ${In.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`};return{name:"Gemm",shaderCache:{hint:`${at.cacheKey}`,inputDependencies:Ht},getRunData:()=>({outputs:[{dims:Lt,dataType:st[0].dataType}],dispatchGroup:{x:Math.ceil(Ft/64)},programUniforms:Ct}),getShaderSource:Gt}},vl=st=>{let at=st.transA,pt=st.transB,vt=st.alpha,wt=st.beta;return{transA:at,transB:pt,alpha:vt,beta:wt,cacheKey:`${st.transA};${st.transB};${st.alpha===1}`}},wl=(st,at)=>{Qp(st.inputs),st.compute(Jp(st.inputs,at))}}),em,tm,rm,_l,xl=j(()=>{ye(),xe(),_e(),em=(st,at)=>{let pt=st[0].dims,vt=pt,wt=2,$t=M.sizeToDimension(pt,wt),Tt=M.sizeFromDimension(pt,wt),Lt=Ue(Tt),Ft=Tt/Lt,Ct=[pt[0],pt[1],Ft],Ht=["rank","type","type"],Gt=[{type:12,data:Tt},{type:12,data:Ft}];Gt.push(...X(Ct,Ct));let jt=qt=>{let Kt=U("x",st[0].dataType,Ct.length,Lt),An=U("scale",st[1].dataType,st[1].dims),Sn=U("bias",st[2].dataType,st[2].dims),wn=K("output",st[0].dataType,Ct.length,Lt),In=[Kt,An,Sn,wn],tr=Kt.type.value,rr=Lt===1?"f32":`vec${Lt}<f32>`,Hr=64,qr=[{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}];return`
  var<workgroup> meanShared : f32;
  var<workgroup> squaredNormShared : f32;
  var<workgroup> workgroupShared : array<${rr}, ${Hr}>;
  const workgroupSize = ${Hr}u;
  ${qt.registerUniforms(qr).declareVariables(...In)}
  ${qt.mainStart(Hr)}
    let norm = global_idx / workgroupSize;
    let batch = norm / uniforms.x_shape[1];
    let channel = norm % uniforms.x_shape[1];
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial = ${rr}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      initial = initial + ${rr}(${Kt.get("batch","channel","h")});
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = ${Et("workgroupShared[0]",Lt)} / f32(uniforms.normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = ${rr}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let deviation =  ${rr}(${Kt.get("batch","channel","h")}) - ${rr}(meanShared);
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = ${Et("workgroupShared[0]",Lt)};
    }
    workgroupBarrier();

    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${at.epsilon}));
    let channelScale = invStdDev * f32(${An.getByOffset("channel")});
    let channelShift = f32(${Sn.getByOffset("channel")}) - meanShared * channelScale;
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let value = ${Kt.get("batch","channel","h")} * ${tr}(${rr}(channelScale)) + ${tr}(${rr}(channelShift));
      ${wn.set("batch","channel","h","value")};
    }
  }`};return{name:"InstanceNormalization",shaderCache:{hint:`${at.epsilon};${Lt}`,inputDependencies:Ht},getRunData:()=>({outputs:[{dims:vt,dataType:st[0].dataType}],dispatchGroup:{x:$t},programUniforms:Gt}),getShaderSource:jt}},tm=(st,at,pt,vt,wt,$t,Tt,Lt)=>{let Ft=Ue(Tt),Ct=64,Ht=Ft===1?"vec2f":`mat2x${Ft}f`,Gt=Ft===1?"f32":`vec${Ft}f`,jt=(qr,Zr)=>`${Ht}(${qr}, ${Zr})`,qt=wt*Tt/Ft,Kt=Math.ceil($t/Ct),An=["type"],Sn=[{type:12,data:Kt},{type:12,data:$t},{type:12,data:Math.floor(Tt/Ft)},{type:12,data:Math.floor($t*Tt/Ft)}],wn=qr=>{let Zr=U("input",at.dataType,at.dims,Ft);return`
  ${qr.declareVariables(Zr)}
  @group(0) @binding(1) var<storage, read_write> output : array<${Ht}>;
  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};
  @group(0) @binding(2) var<uniform> uniforms: Uniforms;

  ${qr.mainStart(Ct)}
    let currentImageNumber = global_idx / ${Ct} / uniforms.C;
    let currentChannelNumber = (global_idx / ${Ct}) % uniforms.C;
    let wgOffset = local_id.x * uniforms.wg_size;
    if (wgOffset >= uniforms.H) {
        return;
    }
    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);

    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;
    var sum = ${At("f32",Ft)};
    var squaredSum = ${At("f32",Ft)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${Gt}(input[offset + i * uniforms.C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${jt("sum","squaredSum")};
  }`},In=st.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${Ft}`,inputDependencies:An},getRunData:()=>({outputs:[{dims:[wt,Tt,Ct,2],dataType:1}],dispatchGroup:{x:wt*Tt/Ft},programUniforms:Sn}),getShaderSource:wn},{inputs:[at],outputs:[-1]})[0],tr=[{type:12,data:qt},{type:12,data:$t},{type:12,data:Math.floor(Tt/Ft)},{type:12,data:Math.floor(Ct*Tt/Ft)}],rr=["type","type","type"],Hr=qr=>{let Zr=U("scale",pt.dataType,pt.dims,Ft),Bo=U("bias",vt.dataType,vt.dims,Ft);return`
  @group(0) @binding(0) var<storage, read> input : array<${Ht}>;
  @group(0) @binding(1) var<storage, read> scale : array<${Zr.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${Bo.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${Ht}>;
  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};
  @group(0) @binding(4) var<uniform> uniforms: Uniforms;

  ${qr.mainStart()}
    ${qr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}
    let currentImageNumber = global_idx / uniforms.C;
    let currentChannelNumber = global_idx % uniforms.C;

    let offset = currentImageNumber * uniforms.image_size;
    var sum = ${At("f32",Ft)};
    var squaredSum = ${At("f32",Ft)};
    for (var i: u32 = 0; i < min(${Ct}, uniforms.H); i++) {
        let value = input[offset + i + currentChannelNumber * ${Ct}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(uniforms.H);
    squaredSum = squaredSum / f32(uniforms.H);
    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${Lt}));
    let channelScale = invStdDev * ${Gt}(scale[currentChannelNumber]);
    let channelShift = ${Gt}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${jt("channelScale","channelShift")};
  }`};return st.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${Ft};${Lt}`,inputDependencies:rr},getRunData:()=>({outputs:[{dims:[wt,Tt,2],dataType:1}],dispatchGroup:{x:Math.ceil(qt/64)},programUniforms:tr}),getShaderSource:Hr},{inputs:[In,pt,vt],outputs:[-1]})[0]},rm=(st,at,pt)=>{let vt=at[0].dims,wt=vt,$t=vt[0],Tt=vt[vt.length-1],Lt=M.sizeFromDimension(vt,1)/Tt,Ft=Ue(Tt),Ct=M.size(wt)/Ft,Ht=[{type:12,data:Lt},{type:12,data:Math.floor(Tt/Ft)}],Gt=["type","type"],jt=tm(st,at[0],at[1],at[2],$t,Lt,Tt,pt.epsilon),qt=Kt=>{let An=De(at[0].dataType),Sn=Ft===1?"vec2f":`mat2x${Ft}f`,wn=Ft===1?An:`vec${Ft}<${An}>`,In=U("input",at[0].dataType,at[0].dims,Ft),tr=K("output",at[0].dataType,wt,Ft);return`
  @group(0) @binding(0) var<storage, read> input : array<${In.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${Sn}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${tr.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${Kt.mainStart()}
    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);
    let currentChannelNumber = global_idx % uniforms.C;

    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${wn}(scale[0]), ${wn}(scale[1]));
  }`};st.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${Ft}`,inputDependencies:Gt},getRunData:()=>({outputs:[{dims:wt,dataType:at[0].dataType}],dispatchGroup:{x:Math.ceil(Ct/64)},programUniforms:Ht}),getShaderSource:qt},{inputs:[at[0],jt]})},_l=(st,at)=>{at.format==="NHWC"?rm(st,st.inputs,at):st.compute(em(st.inputs,at))}}),nm,im,Sl,Cl=j(()=>{ye(),xe(),_e(),nm=st=>{if(!st||st.length<2)throw new Error("layerNorm requires at least 2 inputs.")},im=(st,at,pt)=>{let vt=at.simplified,wt=st[0].dims,$t=st[1],Tt=!vt&&st[2],Lt=wt,Ft=M.normalizeAxis(at.axis,wt.length),Ct=M.sizeToDimension(wt,Ft),Ht=M.sizeFromDimension(wt,Ft),Gt=M.size($t.dims),jt=Tt?M.size(Tt.dims):0;if(Gt!==Ht||Tt&&jt!==Ht)throw new Error(`Size of X.shape()[axis:] == ${Ht}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${Gt} and bias size of ${jt}`);let qt=[];for(let Hr=0;Hr<wt.length;++Hr)Hr<Ft?qt.push(wt[Hr]):qt.push(1);let Kt=Ue(Ht),An=["type","type"],Sn=[{type:12,data:Ct},{type:1,data:Ht},{type:12,data:Math.floor(Ht/Kt)},{type:1,data:at.epsilon}];Tt&&An.push("type");let wn=pt>1,In=pt>2,tr=Hr=>{let qr=De(st[0].dataType),Zr=[U("x",st[0].dataType,st[0].dims,Kt),U("scale",$t.dataType,$t.dims,Kt)];Tt&&Zr.push(U("bias",Tt.dataType,Tt.dims,Kt)),Zr.push(K("output",st[0].dataType,Lt,Kt)),wn&&Zr.push(K("mean_data_output",1,qt)),In&&Zr.push(K("inv_std_output",1,qt));let Bo=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${Hr.registerUniforms(Bo).declareVariables(...Zr)}
  ${Hr.mainStart()}
    ${Hr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${At("f32",Kt)};
    var mean_square_vector = ${At("f32",Kt)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${fr(qr,Kt,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Et("mean_vector",Kt)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Et("mean_square_vector",Kt)} / uniforms.norm_size ${vt?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${fr(qr,Kt,"x[j + offset]")};
      let f32scale = ${fr(qr,Kt,"scale[j]")};
      output[j + offset] = ${Zr[0].type.value}((f32input ${vt?"":"- mean"}) * inv_std_dev * f32scale
        ${Tt?`+ ${fr(qr,Kt,"bias[j]")}`:""}
      );
    }

    ${wn?"mean_data_output[global_idx] = mean":""};
    ${In?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},rr=[{dims:Lt,dataType:st[0].dataType}];return wn&&rr.push({dims:qt,dataType:1}),In&&rr.push({dims:qt,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${Kt};${pt};${vt}`,inputDependencies:An},getRunData:()=>({outputs:rr,dispatchGroup:{x:Math.ceil(Ct/64)},programUniforms:Sn}),getShaderSource:tr}},Sl=(st,at)=>{nm(st.inputs),st.compute(im(st.inputs,at,st.outputCount))}}),om,am,Il,Tl,Al=j(()=>{ye(),xe(),Ze(),_e(),om=(st,at)=>{if(st.length<3||st.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let pt=st[0],vt=pt.dims.length;if(pt.dims[vt-1]!==at.k)throw new Error("The last dim of input shape does not match the k value");let wt=Math.floor((at.k+at.blockSize-1)/at.blockSize),$t=at.blockSize/8*at.bits,Tt=st[1];if(!M.areEqual(Tt.dims,[at.n,wt,$t]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let Lt=st[2].dims;if(M.size(Lt)!==at.n*wt)throw new Error("scales input size error.");if(st.length===4){let Ft=st[3].dims,Ct=at.bits>4?at.n*wt:at.n*Math.floor((wt+1)/2);if(M.size(Ft)!==Ct)throw new Error("zeroPoints input size error.")}},am=(st,at,pt,vt)=>{let wt=st[0].dims,$t=wt.length,Tt=Math.floor((at.k+at.blockSize-1)/at.blockSize),Lt=wt[$t-2],Ft=at.k,Ct=at.n,Ht=wt.slice(0,$t-2),Gt=M.size(Ht),jt=at.blockSize/8*at.bits/4,qt=st[0].dataType,Kt=Ue(Lt),An=Ue(at.k),Sn=Ue(jt),wn=cr(qt),In=Lt*Tt*wn,tr=Math.floor(vt/In),rr=Tt<=pt[0]&&tr>0,Hr=!rr||tr>=4?Ue(Ct):tr>=2&&Ue(Ct)>=2?2:1,qr=Ht.concat([Lt,Ct]),Zr=M.size(qr)/Hr/Kt,Bo=rr?[]:[{type:12,data:Zr},{type:12,data:at.blockSize}],Xo=[Gt,Lt,Ft/An],Kr=M.convertShape(st[1].dims).slice();Kr.splice(-1,1,jt/Sn),Bo.push(...X(Xo)),Bo.push(...X(Kr)),Bo.push(...X(st[2].dims)),st.length===4&&Bo.push(...X(M.convertShape(st[3].dims)));let ko=[Gt,Lt,Ct/Hr];Bo.push(...X(ko));let f0=x0=>{let l0=Xo.length,T0=U("a",st[0].dataType,l0,An),t0=U("b",12,Kr.length,Sn),E0=U("scales",st[2].dataType,st[2].dims.length),n0=[T0,t0,E0],m0=st.length===4?U("zero_points",12,st[3].dims.length):void 0;m0&&n0.push(m0);let h0=ko.length,a0=K("output",st[0].dataType,h0,Hr),P0=[{name:"output_size",type:"u32"},{name:"block_size",type:"u32"}],V0=De(st[0].dataType),B0=(()=>{switch(An){case 1:return`array<${V0}, 8>`;case 2:return`mat4x2<${V0}>`;case 4:return`mat2x4<${V0}>`;default:throw new Error(`${An}-component is not supported.`)}})(),W0=`
        for (var word: u32 = 0; word < ${jt}; word += ${Sn}) {
          ${t0.indicesSet("b_indices","2","word")};
          let b_data = ${t0.getByIndices("b_indices")};
          for (var i: u32 = 0; i < ${Sn}; i++) {
            let b_value: u32 = ${Sn===1?"b_data":"b_data[word + i]"};
            let b_mask: u32 = 0x0F0F0F0Fu;
            let b_value_lower: vec4<u32> = unpack4xU8(b_value & b_mask);
            let b_value_upper: vec4<u32> = unpack4xU8((b_value >> 4) & b_mask);
            let b_quantized_values = ${B0}(${Array.from({length:4},(Ty,$y)=>`${V0}(b_value_lower[${$y}]), ${V0}(b_value_upper[${$y}])`).join(", ")});
            let b_dequantized_values = ${An===1?`${B0}(${Array.from({length:8},(Ty,$y)=>`(b_quantized_values[${$y}] - zero_point) * scale`).join(", ")});`:`(b_quantized_values - ${B0}(${Array(8).fill("zero_point").join(",")})) * scale;`};
            // Number of B elements per 32-bit word is 32/bits = 32/4 = 8
            for (var m: u32 = 0; m < ${rr?Lt:Kt}u; m++) {
              ${T0.indicesSet("a_indices",l0-2,rr?"m":`row * ${Kt} + m`)};
              ${T0.indicesSet("a_indices",l0-1,"word_offset")};
              var input_offset = ${T0.indicesToOffset("a_indices")};
              var a_data: ${B0};
              for (var j: u32 = 0; j < ${8/An}; j++) {
                a_data[j] = ${T0.getByOffset("input_offset")};
                input_offset++;
              }
              ${rr?"workgroup_shared[workgroup_shared_offset + m]":"output_values[m]"}${Hr>1?"[c]":""} += ${Array.from({length:8/An},(Ty,$y)=>`${An===1?`a_data[${$y}] * b_dequantized_values[${$y}]`:`dot(a_data[${$y}], b_dequantized_values[${$y}])`}`).join(" + ")};
            }
            word_offset += ${8/An};
          }
        }`,K0=m0?`
          zero_point_offset += 4;
          if (zero_point_offset == 32) {
            zero_point_offset = 0;
            zero_point_index++;
            zero_point_word = ${m0.getByOffset("zero_point_index")};
          }`:"";return rr?`
        var<workgroup> workgroup_shared: array<${a0.type.value}, ${Lt*Tt}>;
        ${x0.declareVariables(...n0,a0)}
        ${x0.mainStart([Tt,1,1])}
          var a_indices: ${T0.type.indices};
          var block = local_id.x;
          var col = workgroup_id.y;
          var batch = workgroup_id.z;
          ${T0.indicesSet("a_indices","0","batch")};
          // Two zero points are packed into one byte when uniforms.bits is 4.
          for (var c: u32 = 0; c < ${Hr}; c++) {
            let col_times_components_plus_c = col * ${Hr} + c;
              ${m0?`
            var zero_point_bytes_per_col: u32 = (${Tt} + 1) / 2;
            var zero_point_byte_count: u32 = col_times_components_plus_c * zero_point_bytes_per_col + (block >> 0x1u);
            var zero_point_word_index: u32 = zero_point_byte_count >> 0x2u;
            var zero_point_byte_offset: u32 = zero_point_byte_count & 0x3u;
            var zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32 = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            var zero_point_word: u32 = ${m0.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;`:""}
            var b_indices: ${t0.type.indices};
            ${t0.indicesSet("b_indices","0","col_times_components_plus_c")};
            // The scale and zero points are computed per block.
            var scales_index = col_times_components_plus_c * ${Tt} + block;
            let scale = ${E0.getByOffset("scales_index")};
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${V0}(${m0?"(zero_point_word) & 0xFu":8});
            ${t0.indicesSet("b_indices","1","block")};
            var word_offset: u32 = block * ${at.blockSize/An};
            var workgroup_shared_offset: u32 = block * ${Lt};
            ${W0}
          }
          workgroupBarrier();
          if (local_id.x == 0u) {
            var output_indices: ${a0.type.indices};
            ${a0.indicesSet("output_indices","0","batch")};
            ${a0.indicesSet("output_indices",h0-1,"col")};
            ${a0.indicesSet("output_indices",h0-2,"0")};
            var output_offset = ${a0.indicesToOffset("output_indices")};
            for (var m: u32 = 0u; m < ${Lt}u; m++) {
              var output_value: ${a0.type.value} = ${a0.type.value}(0);
              var workgroup_shared_offset: u32 = m;
              for (var b: u32 = 0u; b < ${Tt}u; b++) {
                output_value += workgroup_shared[workgroup_shared_offset];
                workgroup_shared_offset += ${Lt};
              }
              ${a0.setByOffset("output_offset","output_value")};
              output_offset += ${Ct/Hr};
            }
          }
        }`:`
        ${x0.registerUniforms(P0).declareVariables(...n0,a0)}
        ${x0.mainStart()}
          ${x0.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var output_values: array<${a0.type.value}, ${Kt}>;
          var output_indices = ${a0.offsetToIndices("global_idx")};
          var col = ${a0.indicesGet("output_indices",h0-1)};
          var row = ${a0.indicesGet("output_indices",h0-2)};
          var a_indices: ${T0.type.indices} = output_indices;
          // Two zero points are packed into one byte because uniforms.bits <= 4.
          // zero_point_offset is either 0 or 4. It is bit offset within one byte.
          // TODO support zero_point_offset for bits > 4
          ${m0?`
          var zero_point_abs_offset = col * ${Hr} * ((${Tt} + 1) / 2);
          var zero_point_index: u32 = zero_point_abs_offset / 4;
          var zero_point_word: u32 = ${m0.getByOffset("zero_point_index")};
          var zero_point_offset: u32 = (zero_point_abs_offset % 4) * 8;`:""}
          var scale_index = col * ${Tt*Hr};
          var b_indices: ${t0.type.indices};
          for (var c: u32 = 0; c < ${Hr}; c++) {
            ${t0.indicesSet("b_indices","0",`col * ${Hr} + c`)};
            var block_offset: u32 = 0;
            for (var block: u32 = 0; block < ${Tt}; block++) {
              // The scale and zero points are computed per block.
              let scale = ${E0.getByOffset("scale_index")};
              // The default zero point is 8 for unsigned 4-bit quantization.
              let zero_point = ${V0}(${m0?"extractBits(zero_point_word, zero_point_offset, 4)":8});
              ${t0.indicesSet("b_indices","1","block")};
              var word_offset: u32 = block_offset;
              ${W0}
              scale_index++;
              ${K0}
              block_offset += uniforms.block_size / ${An};
            }
            // Drop the trailing 4 bits if the zero_poit_offset is not a byte boundary to align with the next byte.
            ${m0?`if (zero_point_offset % 8 > 0) {
                ${K0}
              }`:""}
            }
            for (var k: u32 = 0u; k < ${Kt}u; k++) {
              ${a0.indicesSet("output_indices",h0-2,`${Kt} * row + k`)};
              ${a0.setByIndices("output_indices","output_values[k]")}
            }
        }`};return{name:rr?"BlockwiseMatMulNBits":"MatMulNBits",shaderCache:{hint:`${at.cacheKey};${Lt};${qt};${st.length}`,inputDependencies:Array(st.length).fill("rank")},getRunData:()=>({outputs:[{dims:qr,dataType:qt}],name:rr?"BlockwiseMatMulNBits":"MatMulNBits",dispatchGroup:rr?{x:1,y:Math.ceil(Ct/Hr),z:Gt}:{x:Math.ceil(Zr/64)},programUniforms:Bo}),getShaderSource:f0}},Il=(st,at)=>{om(st.inputs,at);let pt=st.getMaxComputeWorkgroupSizes(),vt=st.getMaxComputeWorkgroupStoragesize();st.compute(am(st.inputs,at,pt,vt))},Tl=st=>we(st)}),lt,sm,kl,El,um,$o,Ol,Pl=j(()=>{ye(),xe(),Ze(),Hn(),oo(),_e(),Rr(),lt=(st,at)=>st.length>at&&st[at].dims.length>0&&M.size(st[at].dims)>0?st[at]:void 0,sm=(st,at)=>{let pt=st[0],vt=lt(st,1),wt=lt(st,2),$t=lt(st,3),Tt=lt(st,4),Lt=lt(st,5),Ft=lt(st,6),Ct=lt(st,7);if(pt.dims.length!==3&&pt.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let Ht=!1,Gt=pt.dims[0],jt=pt.dims[1],qt=pt.dims.length===3?Ht?pt.dims[2]/3:pt.dims[2]:at.numHeads*pt.dims[4],Kt=jt,An=0,Sn=0,wn=Math.floor(qt/at.numHeads);if(Ft&&Ct){if(Ft.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(Ft.dims[0]!==Gt||Ft.dims[1]!==at.numHeads||Ft.dims[3]!==wn)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(Ct.dims[0]!==Gt||Ct.dims[1]!==at.numHeads||Ct.dims[3]!==wn)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(Ft.dims[2]!==Ct.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(Ct.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');An=Ft.dims[2],Sn=Ft.dims[2]}else if(Ft||Ct)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let In;if(vt){if(pt.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(vt.dims.length<3||vt.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(pt.dims[0]!==vt.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(vt.dims.length===3){if(vt.dims[2]!==pt.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');In=2,Kt=vt.dims[1]}else if(vt.dims.length===5){if(vt.dims[2]!==at.numHeads||vt.dims[3]!==2||vt.dims[4]!==wn)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(wt)throw new Error('Expect "value" be none when "key" has packed kv format.');In=5,Kt=vt.dims[1]}else{if(vt.dims[1]!==at.numHeads||vt.dims[3]!==wn)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');In=0,Kt=vt.dims[2]}}else{if(pt.dims.length!==3&&pt.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(pt.dims.length===5&&(pt.dims[2]!==at.numHeads||pt.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');In=3}if($t){if($t.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(wt&&pt.dims.length===5&&pt.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let tr=0;if(Tt){tr=8;let Bo=Tt.dims;throw Bo.length===1?Bo[0]===Gt?tr=1:Bo[0]===3*Gt+2&&(tr=3):Bo.length===2&&Bo[0]===Gt&&Bo[1]===Kt&&(tr=5),tr===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)'):new Error("Mask not supported")}let rr=!1,Hr=qt;if(wt){if(wt.dims.length!==3&&wt.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(pt.dims[0]!==wt.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(wt.dims.length===3){if(Kt!==wt.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');Hr=wt.dims[2]}else{if(Kt!==wt.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');Hr=wt.dims[1]*wt.dims[3],rr=!0}}let qr=An+Kt,Zr=!1;if(Tt)throw new Error("Key padding mask is not supported");if(Lt){if(Lt.dims.length!==4)throw new Error('Input "relative_position_bias" is expected to have 4 dimensions');if(Lt.dims[0]!==Gt&&Lt.dims[0]!==1||Lt.dims[1]!==at.numHeads||Lt.dims[2]!==jt||Lt.dims[3]!==qr)throw new Error('Input "relative_position_bias" shape (batch_size, 1, sequence_length, kv_sequence_length)')}return{batchSize:Gt,sequenceLength:jt,pastSequenceLength:An,kvSequenceLength:Kt,totalSequenceLength:qr,maxSequenceLength:Sn,inputHiddenSize:0,hiddenSize:qt,vHiddenSize:Hr,headSize:wn,vHeadSize:Math.floor(Hr/at.numHeads),numHeads:at.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:at.maskFilterValue,maskType:tr,scale:at.scale,broadcastResPosBias:Zr,passPastInKv:rr,qkvFormat:In}},kl=st=>we({...st}),El=we({perm:[0,2,1,3]}),um=(st,at,pt,vt,wt,$t,Tt)=>{let Lt=[vt,wt,$t],Ft=M.size(Lt),Ct=[{type:12,data:Ft},{type:12,data:Tt},{type:12,data:$t}],Ht=Gt=>{let jt=K("qkv_with_bias",at.dataType,Lt),qt=U("qkv",at.dataType,Lt),Kt=U("bias",pt.dataType,Lt),An=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${Gt.registerUniforms(An).declareVariables(qt,Kt,jt)}
  ${Gt.mainStart()}
    ${Gt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return st.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:Lt,dataType:at.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(Ft/64)},programUniforms:Ct}),getShaderSource:Ht},{inputs:[at,pt],outputs:[-1]})[0]},$o=(st,at,pt,vt,wt,$t,Tt,Lt)=>{let Ft=$t;if(Tt){if(vt===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return Ft=um(st,$t,Tt,at,vt,pt*wt,Lt),Ft=Ft.reshape([at,vt,pt,wt]),st.compute(xt(Ft,El.perm),{inputs:[Ft],outputs:[-1]})[0]}else return $t.dims.length===3&&(Ft=$t.reshape([at,vt,pt,wt])),st.compute(xt(Ft,El.perm),{inputs:[Ft],outputs:[-1]})[0]},Ol=(st,at)=>{let pt=sm(st.inputs,at),vt=st.inputs[0],wt=lt(st.inputs,1),$t=lt(st.inputs,2),Tt=lt(st.inputs,3),Lt=lt(st.inputs,4),Ft=lt(st.inputs,5),Ct=lt(st.inputs,6),Ht=lt(st.inputs,7);if(vt.dims.length===5)throw new Error("Packed QKV is not implemented");if((wt==null?void 0:wt.dims.length)===5)throw new Error("Packed KV is not implemented");let Gt=wt&&$t&&wt.dims.length===4&&$t.dims.length===4,jt=$o(st,pt.batchSize,pt.numHeads,pt.sequenceLength,pt.headSize,vt,Tt,0);if(Gt)return Xn(st,jt,wt,$t,Lt,void 0,Ct,Ht,Ft,pt,at);if(!wt||!$t)throw new Error("key and value must be provided");let qt=$o(st,pt.batchSize,pt.numHeads,pt.kvSequenceLength,pt.headSize,wt,Tt,pt.hiddenSize),Kt=$o(st,pt.batchSize,pt.numHeads,pt.kvSequenceLength,pt.vHeadSize,$t,Tt,2*pt.hiddenSize);Xn(st,jt,qt,Kt,Lt,void 0,Ct,Ht,Ft,pt,at)}}),lm,dm,cm,pm,mm,fm,hm,gm,Rl,zl=j(()=>{ye(),xe(),_e(),lm=st=>{if(!st||st.length<1)throw new Error("Too few inputs");if(st[0].dataType!==1&&st[0].dataType!==10)throw new Error("Input type must be float or float16.");if(st.length>=2){let at=st[0].dims.length*2===st[1].dims[0];if(st.length===4&&(at=st[3].dims[0]*2===st[1].dims[0]),!at)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},dm=(st,at,pt)=>{let vt="";for(let wt=at-1;wt>=0;--wt)vt+=`
            k = i32(${st.indicesGet("indices",wt)}) - ${fe("uniforms.pads",wt,pt)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${fe("uniforms.x_shape",wt,at)})) {
              break;
            }
            offset += k * i32(${fe("uniforms.x_strides",wt,at)});
        `;return`
          value = ${st.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${vt}
            value = x[offset];
          }
      `},cm=(st,at,pt)=>{let vt="";for(let wt=at-1;wt>=0;--wt)vt+=`
                k = i32(${st.indicesGet("indices",wt)}) - ${fe("uniforms.pads",wt,pt)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${fe("uniforms.x_shape",wt,at)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${fe("uniforms.x_shape",wt,at)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${fe("uniforms.x_strides",wt,at)});
            `;return`
              var offset = 0;
              var k = 0;
              ${vt}
              value = x[offset];
          `},pm=(st,at,pt)=>{let vt="";for(let wt=at-1;wt>=0;--wt)vt+=`
                k = i32(${st.indicesGet("indices",wt)}) - ${fe("uniforms.pads",wt,pt)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${fe("uniforms.x_shape",wt,at)})) {
                  k = i32(${fe("uniforms.x_shape",wt,at)}) - 1;
                }
                offset += k * i32(${fe("uniforms.x_strides",wt,at)});
            `;return`
              var offset = 0;
              var k = 0;
              ${vt}
              value = x[offset];
          `},mm=(st,at,pt)=>{let vt="";for(let wt=at-1;wt>=0;--wt)vt+=`
                k = i32(${st.indicesGet("indices",wt)}) - ${fe("uniforms.pads",wt,pt)};
                if (k < 0)  {
                  k += i32(${fe("uniforms.x_shape",wt,at)}]);
                }
                if (k >= i32(${fe("uniforms.x_shape",wt,at)})) {
                  k -= i32(${fe("uniforms.x_shape",wt,at)});
                }
                offset += k * i32(${fe("uniforms.x_strides",wt,at)});
            `;return`
              var offset = 0;
              var k = 0;
              ${vt}
              value = x[offset];
          `},fm=(st,at,pt)=>{switch(pt.mode){case 0:return dm(st,at,pt.pads.length);case 1:return cm(st,at,pt.pads.length);case 2:return pm(st,at,pt.pads.length);case 3:return mm(st,at,pt.pads.length);default:throw new Error("Invalid mode")}},hm=(st,at)=>{let pt=M.padShape(st[0].dims.slice(),at.pads),vt=st[0].dims,wt=M.size(pt),$t=[{type:12,data:wt},{type:6,data:at.pads}];at.mode===0&&$t.push({type:st[0].dataType,data:at.value}),$t.push(...X(st[0].dims,pt));let Tt=["rank"],Lt=Ft=>{let Ct=K("output",st[0].dataType,pt.length),Ht=U("x",st[0].dataType,vt.length),Gt=Ht.type.value,jt=fm(Ct,vt.length,at),qt=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:at.pads.length}];return at.mode===0&&qt.push({name:"constant_value",type:Gt}),`
            ${Ft.registerUniforms(qt).declareVariables(Ht,Ct)}
            ${Ft.mainStart()}
            ${Ft.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${Ct.offsetToIndices("global_idx")};

            var value = ${Gt}(0);
            ${jt}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${at.mode}`,inputDependencies:Tt},getRunData:()=>({outputs:[{dims:pt,dataType:st[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(pt)/64)},programUniforms:$t}),getShaderSource:Lt}},gm=(st,at)=>{if(st.length>1){let pt=st[1].getBigInt64Array(),vt=st.length>=3&&st[2].data?st[2].getFloat32Array()[0]:0,wt=st[0].dims.length,$t=new Int32Array(2*wt).fill(0);if(st.length>=4){let Lt=st[3].getBigInt64Array();for(let Ft=0;Ft<Lt.length;Ft++)$t[Number(Lt[Ft])]=Number(pt[Ft]),$t[Number(Lt[Ft])+wt]=Number(pt[Ft+Lt.length])}else pt.forEach((Lt,Ft)=>$t[Number(Ft)]=Number(Lt));let Tt=[];return $t.forEach(Lt=>Tt.push(Lt)),{mode:at.mode,value:vt,pads:Tt}}else return at},Rl=(st,at)=>{lm(st.inputs);let pt=gm(st.inputs,at);st.compute(hm(st.inputs,pt),{inputs:[0]})}}),si,Bl,Dl,Ml,Ul,ym,bm,Wl,Nl,Vl,Hl,Gl,Ll,Fl,ql,jl,Kl,Yl,Xl,Zl=j(()=>{_t(),ye(),xe(),_e(),si=st=>{if(ke.webgpu.validateInputContent&&(!st||st.length!==1))throw new Error("Pool ops requires 1 input.")},Bl=(st,at,pt)=>{let vt=at.format==="NHWC",wt=st.dims.slice();vt&&wt.splice(1,0,wt.pop());let $t=Object.hasOwnProperty.call(at,"dilations"),Tt=at.kernelShape.slice(),Lt=at.strides.slice(),Ft=$t?at.dilations.slice():[],Ct=at.pads.slice();pr.adjustPoolAttributes(pt,wt,Tt,Lt,Ft,Ct);let Ht=pr.computePoolOutputShape(pt,wt,Lt,Ft,Tt,Ct,at.autoPad),Gt=Object.assign({},at);$t?Object.assign(Gt,{kernelShape:Tt,strides:Lt,pads:Ct,dilations:Ft,cacheKey:at.cacheKey}):Object.assign(Gt,{kernelShape:Tt,strides:Lt,pads:Ct,cacheKey:at.cacheKey});let jt=Ht.slice();return jt.push(jt.splice(1,1)[0]),[Gt,vt?jt:Ht]},Dl=(st,at)=>{let pt=at.format==="NHWC",vt=M.size(st),wt=M.size(at.kernelShape),$t=[{type:12,data:vt},{type:12,data:wt}],Tt=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(at.kernelShape.length<=2){let Lt=at.kernelShape[at.kernelShape.length-1],Ft=at.strides[at.strides.length-1],Ct=at.pads[at.pads.length/2-1],Ht=at.pads[at.pads.length-1],Gt=!!(Ct+Ht);$t.push({type:12,data:Lt},{type:12,data:Ft},{type:12,data:Ct},{type:12,data:Ht}),Tt.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let jt=!1;if(at.kernelShape.length===2){let qt=at.kernelShape[at.kernelShape.length-2],Kt=at.strides[at.strides.length-2],An=at.pads[at.pads.length/2-2],Sn=at.pads[at.pads.length-2];jt=!!(An+Sn),$t.push({type:12,data:qt},{type:12,data:Kt},{type:12,data:An},{type:12,data:Sn}),Tt.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[$t,Tt,!0,Gt,jt]}else{if(pt)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let Lt=M.computeStrides(at.kernelShape);$t.push({type:12,data:Lt},{type:12,data:at.pads},{type:12,data:at.strides}),Tt.push({name:"kernelStrides",type:"u32",length:Lt.length},{name:"pads",type:"u32",length:at.pads.length},{name:"strides",type:"u32",length:at.strides.length});let Ft=at.pads.reduce((Ct,Ht)=>Ct+Ht);return[$t,Tt,!!Ft,!1,!1]}},Ml=(st,at,pt,vt,wt,$t,Tt,Lt,Ft,Ct,Ht,Gt)=>{let jt=wt.format==="NHWC",qt=at.type.value,Kt=K("output",at.type.tensor,vt);if(wt.kernelShape.length<=2){let An="",Sn="",wn="",In=pt-(jt?2:1);if(Ht?An=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${In}] = indices[${In}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${In}] < 0 || xIndices[${In}]
                      >= uniforms.x_shape[${In}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${at.indicesToOffset("xIndices")}];
                  ${$t}
                }`:An=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${In}] = indices[${In}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${at.indicesToOffset("xIndices")}];
                  ${$t}
                }`,wt.kernelShape.length===2){let tr=pt-(jt?3:2);Gt?Sn=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${tr}] = indices[${tr}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${tr}] < 0 || xIndices[${tr}] >= uniforms.x_shape[${tr}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:Sn=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${tr}] = indices[${tr}] * uniforms.sh - uniforms.phStart + j;
                `,wn=`
              }
            `}return`
            ${st.registerUniforms(Ft).declareVariables(at,Kt)}

            ${st.mainStart()}
              ${st.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${Kt.offsetToIndices("global_idx")};
              var xIndices = ${Kt.offsetToIndices("global_idx")};

              var value = ${qt}(${Lt});
              var pad = 0;
              ${Sn}
              ${An}
              ${wn}
              ${Tt}

              output[global_idx] = value;
            }`}else{if(jt)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let An=wt.kernelShape.length,Sn=wt.pads.length,wn="";return Ct?wn=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${at.indicesToOffset("xIndices")}];
                ${$t}
              }`:wn=`
              }
              let x_val = x[${at.indicesToOffset("xIndices")}];
              ${$t}
            `,`
            ${st.registerUniforms(Ft).declareVariables(at,Kt)}

            ${st.mainStart()}
              ${st.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${Kt.offsetToIndices("global_idx")};
              var xIndices = ${Kt.offsetToIndices("global_idx")};

              var offsets: array<u32, ${An}>;

              var value = ${qt}(${Lt});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${An-1}u; j++) {
                  offsets[j] = offset / ${fe("uniforms.kernelStrides","j",An)};
                  offset -= offsets[j] * ${fe("uniforms.kernelStrides","j",An)};
                }
                offsets[${An-1}] = offset;

                isPad = false;
                for (var j = ${pt-An}u; j < ${pt}u; j++) {
                  xIndices[j] = indices[j] * ${fe("uniforms.strides",`j - ${pt-An}u`,An)}
                    + offsets[j - ${pt-An}u] - ${fe("uniforms.pads","j - 2u",Sn)};
                  ${wn}
              }
              ${Tt}

              output[global_idx] = value;
            }`}},Ul=st=>`${st.format};${st.ceilMode};${st.autoPad};${st.kernelShape.length}`,ym=st=>`${Ul(st)};${st.countIncludePad}`,bm=st=>`${Ul(st)};${st.storageOrder};${st.dilations}`,Wl=st=>({format:st.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][st.auto_pad],ceilMode:st.ceil_mode,kernelShape:st.kernel_shape,strides:st.strides,pads:st.pads}),Nl=(st,at,pt,vt)=>{let[wt,$t]=Bl(at,vt,pt),Tt=U("x",at.dataType,at.dims.length),Lt=Tt.type.value,Ft="value += x_val;",Ct="";wt.countIncludePad?Ct+=`value /= ${Lt}(uniforms.kernelSize);`:Ct+=`value /= ${Lt}(i32(uniforms.kernelSize) - pad);`;let[Ht,Gt,jt,qt,Kt]=Dl($t,wt);Ht.push(...X(at.dims,$t));let An=["rank"];return{name:st,shaderCache:{hint:`${vt.cacheKey};${jt};${qt};${Kt}`,inputDependencies:An},getRunData:()=>({outputs:[{dims:$t,dataType:at.dataType}],dispatchGroup:{x:Math.ceil(M.size($t)/64)},programUniforms:Ht}),getShaderSource:Sn=>Ml(Sn,Tt,at.dims.length,$t.length,wt,Ft,Ct,0,Gt,jt,qt,Kt)}},Vl=st=>{let at=st.count_include_pad!==0,pt=Wl(st);if(pt.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let vt={countIncludePad:at,...pt,cacheKey:""};return{...vt,cacheKey:ym(vt)}},Hl=(st,at)=>{si(st.inputs),st.compute(Nl("AveragePool",st.inputs[0],!1,at))},Gl={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Ll=st=>{let at=st.format;return{format:at,...Gl,cacheKey:at}},Fl=(st,at)=>{si(st.inputs),st.compute(Nl("GlobalAveragePool",st.inputs[0],!0,at))},ql=(st,at,pt,vt)=>{let[wt,$t]=Bl(at,vt,pt),Tt=`
      value = max(x_val, value);
    `,Lt="",Ft=U("x",at.dataType,at.dims.length),Ct=["rank"],[Ht,Gt,jt,qt,Kt]=Dl($t,wt);return Ht.push(...X(at.dims,$t)),{name:st,shaderCache:{hint:`${vt.cacheKey};${jt};${qt};${Kt}`,inputDependencies:Ct},getRunData:()=>({outputs:[{dims:$t,dataType:at.dataType}],dispatchGroup:{x:Math.ceil(M.size($t)/64)},programUniforms:Ht}),getShaderSource:An=>Ml(An,Ft,at.dims.length,$t.length,wt,Tt,Lt,at.dataType===10?-65504:-1e5,Gt,jt,qt,Kt)}},jl=(st,at)=>{si(st.inputs),st.compute(ql("MaxPool",st.inputs[0],!1,at))},Kl=st=>{let at=st.storage_order,pt=st.dilations,vt=Wl(st);if(at!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(vt.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let wt={storageOrder:at,dilations:pt,...vt,cacheKey:""};return{...wt,cacheKey:bm(wt)}},Yl=st=>{let at=st.format;return{format:at,...Gl,cacheKey:at}},Xl=(st,at)=>{si(st.inputs),st.compute(ql("GlobalMaxPool",st.inputs[0],!0,at))}}),wm,$m,Ql,Jl=j(()=>{_t(),ye(),_e(),wm=(st,at,pt)=>{let vt=st===at,wt=st<at&&pt<0,$t=st>at&&pt>0;if(vt||wt||$t)throw new Error("Range these inputs' contents are invalid.")},$m=(st,at,pt,vt)=>{let wt=Math.abs(Math.ceil((at-st)/pt)),$t=[wt],Tt=wt,Lt=[{type:12,data:Tt},{type:vt,data:st},{type:vt,data:pt},...X($t)],Ft=Ct=>{let Ht=K("output",vt,$t.length),Gt=Ht.type.value,jt=[{name:"outputSize",type:"u32"},{name:"start",type:Gt},{name:"delta",type:Gt}];return`
        ${Ct.registerUniforms(jt).declareVariables(Ht)}
        ${Ct.mainStart()}
        ${Ct.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${Gt}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${vt}`},getShaderSource:Ft,getRunData:()=>({outputs:[{dims:$t,dataType:vt}],dispatchGroup:{x:Math.ceil(Tt/64)},programUniforms:Lt})}},Ql=st=>{let at=0,pt=0,vt=0;st.inputs[0].dataType===6?(at=st.inputs[0].getInt32Array()[0],pt=st.inputs[1].getInt32Array()[0],vt=st.inputs[2].getInt32Array()[0]):st.inputs[0].dataType===1&&(at=st.inputs[0].getFloat32Array()[0],pt=st.inputs[1].getFloat32Array()[0],vt=st.inputs[2].getFloat32Array()[0]),ke.webgpu.validateInputContent&&wm(at,pt,vt),st.compute($m(at,pt,vt,st.inputs[0].dataType),{inputs:[]})}}),_m,xm,Sm,Cm,Im,Tm,Am,Em,km,Om,Pm,ed,Rm,zm,Bm,Dm,Mm,td,rd,nd=j(()=>{ye(),xe(),Ze(),_e(),_m=(st,at)=>{if(st.every(pt=>pt>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),st.length>0){if(at.mode==="linear"){if(!(st.length===2||st.length===3||st.length===4&&st[0]===1&&st[1]===1||st.length===4&&st[0]===1&&st[3]===1||st.length===5&&st[0]===1&&st[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(at.mode==="cubic"&&!(st.length===2||st.length===4&&st[0]===1&&st[1]===1||st.length===4&&st[0]===1&&st[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},xm=(st,at,pt)=>{at.every(wt=>wt>=0&&wt<pt||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let vt=new Array(pt).fill(1);return at.forEach((wt,$t)=>vt[wt]=st[$t]),vt},Sm=(st,at,pt,vt,wt,$t)=>{let[Tt,Lt,Ft]=pt>10?[1,2,3]:[-1,st.length>1?1:-1,-1],Ct=st[0].dims.length;if(Tt>0&&st.length>Tt&&st[Tt].dims.length>0)st[Tt].getFloat32Array().forEach(Ht=>$t.push(Ht));else if(at.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(Lt>0&&st.length>Lt&&st[Lt].dims.length>0){if(st[Lt].getFloat32Array().forEach(Ht=>vt.push(Ht)),vt.length!==0&&vt.length!==Ct&&pt>=18&&vt.length!==at.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");_m(vt,at),at.axes.length>0&&xm(vt,at.axes,Ct).forEach((Ht,Gt)=>vt[Gt]=Ht)}if(Ft>0&&st.length>Ft&&(st[Ft].getBigInt64Array().forEach(Ht=>wt.push(Number(Ht))),wt.length!==Ct||pt>=18&&wt.length===at.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(at.axes.length>0){if(vt.length!==at.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(wt.length!==at.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof vt<"u"&&typeof wt<"u"&&vt.length>0&&wt.length>Ct)throw new Error("Resize requires only of scales or sizes to be specified")},Cm=(st,at)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${at} { `+(()=>{switch(st){case"asymmetric":return`return ${at}(xResized) / ${at}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${at}(xResized) + 0.5) / ${at}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${at}(xResized) + 0.5) / ${at}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${at}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${at}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${at}(lengthResized - 1);
                    return whole + fract;
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${at}(roiStart) * ${at}(lengthOriginal - 1) +
                        (${at}(xResized) * ${at}(roiEnd - roiStart) * ${at}(lengthOriginal - 1)) /
                        ${at}(lengthResized - 1);
                  } else {
                    return 0.5 * ${at}(roiStart + roiEnd) * ${at}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${at}xScale * ${at}(lengthResized);
                  const adjustment = ${at}(lengthResized) / outputWidth;
                  const center = ${at}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${at}(xResized) + 0.5) / ${at}(xScale)) - 0.5;`;case"half_pixel":return`return ((${at}(xResized) + 0.5) / ${at}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${st} is not supported`)}})()+"}",Im=(st,at,pt)=>`fn getNearestPixelFromOriginal(xOriginal: ${pt}, isDownSample: bool) -> ${pt} {`+(()=>{switch(st){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(at<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${st} is not supported`)}})()+"}",Tm=(st,at,pt)=>{let vt=new Array(pt).fill(0).concat(new Array(pt).fill(1)),wt=st.length===0?vt:st.slice();return at.length>0?(at.forEach(($t,Tt)=>{vt[$t]=wt[Tt],vt[Tt+pt]=wt[at.length+Tt]}),vt):wt},Am=(st,at,pt,vt)=>{let wt=[];if(pt.length>0)if(vt.length>0){if(st.forEach($t=>wt.push($t)),Math.max(...vt)>st.length)throw new Error("axes is out of bound");vt.forEach(($t,Tt)=>wt[$t]=pt[Tt])}else pt.forEach($t=>wt.push($t));else{if(at.length===0)throw new Error("Resize requires either scales or sizes.");wt=st.map(($t,Tt)=>Math.round($t*at[Tt]))}return wt},Em=(st,at,pt)=>{let vt=(()=>{switch(pt.keepAspectRatioPolicy){case"not_larger":return pt.axes.length>0?Math.min(...pt.axes.map($t=>at[$t]),Number.MAX_VALUE):Math.min(...at,Number.MAX_VALUE);case"not_smaller":return pt.axes.length>0?Math.max(...pt.axes.map($t=>at[$t]),Number.MIN_VALUE):Math.max(...at,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${pt.keepAspectRatioPolicy} is not supported`)}})();at.fill(1,0,at.length);let wt=st.slice();return pt.axes.length>0?(pt.axes.forEach($t=>at[$t]=vt),pt.axes.forEach($t=>wt[$t]=Math.round(st[$t]*at[$t]))):(at.fill(vt,0,at.length),wt.forEach(($t,Tt)=>wt[Tt]=Math.round($t*at[Tt]))),wt},km=(st,at,pt,vt,wt)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${st.type.indices}) -> array<${st.type.value}, ${pt.length}> {
      var original_indices: array<${st.type.value}, ${pt.length}>;
      for (var i:u32 = 0; i < ${pt.length}; i++) {
        var output_index = ${st.indicesGet("output_indices","i")};
        var scale = ${fe("uniforms.scales","i",vt)};
        var roi_low = ${fe("uniforms.roi","i",wt)};
        var roi_hi = ${fe("uniforms.roi",`i + ${at.length}`,wt)};
        if (scale == 1.0) {
          original_indices[i] = ${st.type.value}(output_index);
        } else {
          var input_shape_i = ${fe("uniforms.input_shape","i",at.length)};
          var output_shape_i = ${fe("uniforms.output_shape","i",pt.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,Om=(st,at,pt,vt,wt,$t,Tt)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${at.type.indices}) -> ${st.type.indices} {
      var input_indices: ${st.type.indices};
      for (var i:u32 = 0; i < ${vt.length}; i++) {
        var output_index = ${at.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${fe("uniforms.scales","i",wt)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${fe("uniforms.roi","i",$t)};
          var roi_hi = ${fe("uniforms.roi",`i + ${pt.length}`,$t)};
          var input_shape_i = ${fe("uniforms.input_shape","i",pt.length)};
          var output_shape_i = ${fe("uniforms.output_shape","i",vt.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${Tt} || (original_idx >= 0 && original_idx < ${at.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${at.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${st.indicesSet("input_indices","i"," input_index")}
      }
      return input_indices;
    }`,Pm=(st,at)=>`
    fn checkInputIndices(input_indices: ${st.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${at.length}; i++) {
        var input_index = ${st.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${fe("uniforms.input_shape","i",at.length)}) {
          return false;
        }
      }
      return true;
    }`,ed=(st,at,pt,vt)=>st.rank>vt?`
    ${st.indicesSet("input_indices",at,"channel")};
    ${st.indicesSet("input_indices",pt,"batch")};
`:"",Rm=(st,at,pt,vt,wt)=>{let[$t,Tt,Lt,Ft]=pt.length===2?[-1,0,1,-1]:[0,2,3,1],Ct=st.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${Ct} {
      var input_indices: ${st.type.indices};
      ${st.indicesSet("input_indices",Tt,`max(0, min(row, ${pt[Tt]} - 1))`)};
      ${st.indicesSet("input_indices",Lt,`max(0, min(col, ${pt[Lt]} - 1))`)};
      ${ed(st,Ft,$t,2)}
      return ${st.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${at.type.indices}) -> ${Ct} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${Ct} = originalIndices[${Tt}];
      var col:${Ct} = originalIndices[${Lt}];
      ${vt?`if (row < 0 || row > (${pt[Tt]} - 1) || col < 0 || col > (${pt[Lt]} - 1)) {
        return ${wt};
      }`:""};
      row = max(0, min(row, ${pt[Tt]} - 1));
      col = max(0, min(col, ${pt[Lt]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${pt.length>2?`u32(originalIndices[${Ft}])`:"0"};
      var batch: u32 =  ${pt.length>2?`u32(originalIndices[${$t}])`:"0"};
      var x11: ${Ct} = getInputValue(batch, channel, row1, col1);
      var x12: ${Ct} = getInputValue(batch, channel, row1, col2);
      var x21: ${Ct} = getInputValue(batch, channel, row2, col1);
      var x22: ${Ct} = getInputValue(batch, channel, row2, col2);
      var dx1: ${Ct} = abs(row - ${Ct}(row1));
      var dx2: ${Ct} = abs(${Ct}(row2) - row);
      var dy1: ${Ct} = abs(col - ${Ct}(col1));
      var dy2: ${Ct} = abs(${Ct}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},zm=(st,at,pt,vt,wt,$t,Tt,Lt,Ft,Ct)=>{let Ht=pt.length===2,[Gt,jt]=Ht?[0,1]:[2,3],qt=st.type.value,Kt=An=>{let Sn=An===Gt?"row":"col";return`
      fn ${Sn}CubicInterpolation(input_indices: ${st.type.indices}, output_indices: ${at.type.indices}) -> ${qt} {
        var output_index = ${at.indicesGet("output_indices",An)};
        var originalIdx: ${qt} = getOriginalCoordinateFromResizedCoordinate(output_index, ${wt[An]},
        ${vt[An]}, ${pt[An]}, ${$t[An]}, ${$t[An]} + ${pt.length});
        var fractOriginalIdx: ${qt} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${Lt} && (originalIdx < 0 || originalIdx > (${pt[An]} - 1))) {
          return ${Ft};
        }
        var data: array<${qt}, 4> = array<${qt}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${Sn}: ${qt} = originalIdx + ${qt}(i);
          if (${Sn} < 0 || ${Sn} >= ${pt[An]}) {
            ${Ct?`coefs[i + 1] = 0.0;
                        continue;`:Lt?`return ${Ft};`:`${Sn} = max(0, min(${Sn}, ${pt[An]} - 1));`};
          }
        var input_indices_copy: ${st.type.indices} = input_indices;
          ${st.indicesSet("input_indices_copy",An,`u32(${Sn})`)};
          data[i + 1] = ${An===Gt?st.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${Kt(Gt)};
    ${Kt(jt)};
  fn getCubicInterpolationCoefs(s: ${qt}) -> array<${qt}, 4> {
    var absS = abs(s);
    var coeffs: array<${qt}, 4> = array<${qt}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${qt} = 1.0 - absS;
    var twoMinusAbsS: ${qt} = 2.0 - absS;
    var onePlusAbsS: ${qt} = 1.0 + absS;
    coeffs[0] = ((${Tt} * onePlusAbsS - 5 * ${Tt}) * onePlusAbsS + 8 * ${Tt}) * onePlusAbsS - 4 * ${Tt};
    coeffs[1] = ((${Tt} + 2) * absS - (${Tt} + 3)) * absS * absS + 1;
    coeffs[2] = ((${Tt} + 2) * oneMinusAbsS - (${Tt} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${Tt} * twoMinusAbsS - 5 * ${Tt}) * twoMinusAbsS + 8 * ${Tt}) * twoMinusAbsS - 4 * ${Tt};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${qt}, 4>, coefs: array<${qt}, 4>) -> ${qt} {
    var coefsSum: ${qt} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${at.type.indices}) -> ${qt} {
    var input_indices: ${st.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},Bm=(st,at,pt,vt,wt)=>{let[$t,Tt,Lt,Ft,Ct]=pt.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],Ht=st.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${Ht} {
      var input_indices: ${st.type.indices};
      ${st.indicesSet("input_indices",Tt,`max(0, min(depth, ${pt[Tt]} - 1))`)};
      ${st.indicesSet("input_indices",Lt,`max(0, min(height, ${pt[Lt]} - 1))`)};
      ${st.indicesSet("input_indices",Ft,`max(0, min(width, ${pt[Ft]} - 1))`)};
      ${ed(st,Ct,$t,3)}
      return ${st.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${at.type.indices}) -> ${Ht} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${Ht} = originalIndices[${Tt}];
      var height:${Ht} = originalIndices[${Lt}];
      var width:${Ht} = originalIndices[${Ft}];
      ${vt?`if (depth < 0 || depth > (${pt[Tt]} - 1) || height < 0 || height > (${pt[Lt]} - 1) || width < 0 || (width > ${pt[Ft]} - 1)) {
      return ${wt};
        }`:""};

    depth = max(0, min(depth, ${pt[Tt]} - 1));
      height = max(0, min(height, ${pt[Lt]} - 1));
      width = max(0, min(width, ${pt[Ft]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${pt.length>3?`u32(originalIndices[${Ct}])`:"0"};
      var batch: u32 =  ${pt.length>3?`u32(originalIndices[${$t}])`:"0"};

      var x111: ${Ht} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${Ht} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${Ht} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${Ht} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${Ht} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${Ht} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${Ht} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${Ht} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${Ht} = abs(depth - ${Ht}(depth1));
      var dx2: ${Ht} = abs(${Ht}(depth2) - depth);
      var dy1: ${Ht} = abs(height - ${Ht}(height1));
      var dy2: ${Ht} = abs(${Ht}(height2) - height);
      var dz1: ${Ht} = abs(width - ${Ht}(width1));
      var dz2: ${Ht} = abs(${Ht}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},Dm=(st,at,pt,vt,wt,$t)=>{let Tt=st.dims,Lt=Tm($t,at.axes,Tt.length),Ft=Am(Tt,vt,wt,at.axes),Ct=vt.slice();vt.length===0&&(Ct=Tt.map((In,tr)=>In===0?1:Ft[tr]/In),at.keepAspectRatioPolicy!=="stretch"&&(Ft=Em(Tt,Ct,at)));let Ht=K("output",st.dataType,Ft.length),Gt=U("input",st.dataType,Tt.length),jt=M.size(Ft),qt=Tt.length===Ft.length&&Tt.every((In,tr)=>In===Ft[tr]),Kt=at.coordinateTransformMode==="tf_crop_and_resize",An=at.extrapolationValue,Sn=Gt.type.value,wn=In=>`
      ${qt?"":`
      ${Cm(at.coordinateTransformMode,Sn)};
      ${(()=>{switch(at.mode){case"nearest":return`
              ${Pm(Gt,Tt)};
              ${Im(at.nearestMode,pt,Sn)};
              ${Om(Gt,Ht,Tt,Ft,Ct.length,Lt.length,Kt)};
              `;case"linear":return`
              ${km(Ht,Tt,Ft,Ct.length,Lt.length)};
              ${(()=>{if(Tt.length===2||Tt.length===4)return`${Rm(Gt,Ht,Tt,Kt,An)}`;if(Tt.length===3||Tt.length===5)return`${Bm(Gt,Ht,Tt,Kt,An)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(Tt.length===2||Tt.length===4)return`${zm(Gt,Ht,Tt,Ft,Ct,Lt,at.cubicCoeffA,Kt,at.extrapolationValue,at.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${In.registerUniform("output_size","u32").registerUniform("scales","f32",Ct.length).registerUniform("roi","f32",Lt.length).declareVariables(Gt,Ht)}
      ${In.mainStart()}
        ${In.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${qt?"output[global_idx] = input[global_idx];":`
        let output_indices = ${Ht.offsetToIndices("global_idx")};
        var input_indices: ${Gt.type.indices};
        ${(()=>{switch(at.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${Gt.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${at.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${Tt.length===2||Tt.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${at.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${at.cacheKey}|${pt}|${Ct.length>0?Ct:""}|${wt.length>0?wt:""}|${Lt.length>0?Lt:""}|${qt}|${Tt}`,inputDependencies:["rank"]},getShaderSource:wn,getRunData:()=>({outputs:[{dims:Ft,dataType:st.dataType}],dispatchGroup:{x:Math.ceil(jt/64)},programUniforms:[{type:12,data:jt},{type:1,data:Ct},{type:1,data:Lt},...X(Tt,Ft)]})}},Mm=st=>{let at=st.customDataBuffer;return new Uint32Array(at,at.byteOffset,1)[0]},td=(st,at)=>{let pt=[],vt=[],wt=[],$t=Mm(st);if(at.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");Sm(st.inputs,at,$t,pt,vt,wt),st.compute(Dm(st.inputs[0],at,$t,pt,vt,wt),{inputs:[0]})},rd=st=>{let at=st.antialias,pt=st.axes,vt=st.coordinateTransformMode,wt=st.cubicCoeffA,$t=st.excludeOutside!==0,Tt=st.extrapolationValue,Lt=st.keepAspectRatioPolicy,Ft=st.mode,Ct=st.nearestMode===""?"simple":st.nearestMode;return we({antialias:at,axes:pt,coordinateTransformMode:vt,cubicCoeffA:wt,excludeOutside:$t,extrapolationValue:Tt,keepAspectRatioPolicy:Lt,mode:Ft,nearestMode:Ct})}}),Um,Wm,id,od=j(()=>{ye(),xe(),Ze(),_e(),Um=(st,at)=>{let[pt,vt,wt,$t]=st,{numHeads:Tt,rotaryEmbeddingDim:Lt}=at;if(pt.dims.length!==3&&pt.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${pt.dims.length}`);if(!M.areEqual(vt.dims,[])&&!M.areEqual(vt.dims,[1])&&vt.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${vt.dims.length}`);if(wt.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${wt.dims.length}`);if($t.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${$t.dims.length}`);if(!M.areEqual(wt.dims,$t.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(Lt>0&&Tt===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let Ft=pt.dims[0],Ct=pt.dims[pt.dims.length-2],Ht=wt.dims[0],Gt=M.sizeFromDimension(pt.dims,1)/Ct,jt=Lt===0?wt.dims[1]*2:Gt/Tt;if(Lt>jt)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(vt.dims.length===2){if(Ft!==vt.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${vt.dims[0]}`);if(Ct!==vt.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${vt.dims[1]}`)}if(jt/2!==wt.dims[1]&&Lt/2!==wt.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${wt.dims[1]}`);if(Ct>Ht)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},Wm=(st,at)=>{let{interleaved:pt,numHeads:vt,rotaryEmbeddingDim:wt,scale:$t}=at,Tt=st[0].dims[0],Lt=M.sizeFromDimension(st[0].dims,1),Ft=st[0].dims[st[0].dims.length-2],Ct=Lt/Ft,Ht=st[2].dims[1],Gt=wt===0?Ht*2:Ct/vt,jt=new Array(Tt,Ft,Ct/Gt,Gt-Ht),qt=M.computeStrides(jt),Kt=[{type:1,data:$t},{type:12,data:jt},{type:12,data:qt},...st[0].dims.length===3?new Array({type:12,data:[Lt,Ct,Gt,1]}):[],...st[0].dims.length===4?new Array({type:12,data:[Lt,Gt,Ft*Gt,1]}):[],...X(st[0].dims,st[1].dims,st[2].dims,st[3].dims,st[0].dims)],An=Sn=>{let wn=U("input",st[0].dataType,st[0].dims.length),In=U("position_ids",st[1].dataType,st[1].dims.length),tr=U("cos_cache",st[2].dataType,st[2].dims.length),rr=U("sin_cache",st[3].dataType,st[3].dims.length),Hr=K("output",st[0].dataType,st[0].dims.length);return Sn.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:jt.length},{name:"global_strides",type:"u32",length:qt.length},{name:"input_output_strides",type:"u32",length:qt.length}]),`
        ${Sn.declareVariables(wn,In,tr,rr,Hr)}

        ${Sn.mainStart(mr)}
          let half_rotary_emb_dim = uniforms.${tr.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${Sn.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${In.broadcastedIndicesToOffset("bsnh.xy",K("",In.type.tensor,2))};
            let position_id =
                u32(${In.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${pt});
            let j = i + select(half_rotary_emb_dim, 1, ${pt});
            let re = ${wn.getByOffset("i")} * ${tr.get("position_id","bsnh[3]")} -
                ${wn.getByOffset("j")} * ${rr.get("position_id","bsnh[3]")};
            ${Hr.setByOffset("i","re")}
            let im = ${wn.getByOffset("i")} * ${rr.get("position_id","bsnh[3]")} +
                ${wn.getByOffset("j")} * ${tr.get("position_id","bsnh[3]")};
            ${Hr.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${Hr.setByOffset("k",wn.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:we({interleaved:pt}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:An,getRunData:()=>({outputs:[{dims:st[0].dims,dataType:st[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(jt)/mr)},programUniforms:Kt})}},id=(st,at)=>{Um(st.inputs,at),st.compute(Wm(st.inputs,at))}}),Nm,Vm,ad,sd=j(()=>{ye(),xe(),_e(),Nm=st=>{if(!st||st.length<3)throw new Error("layerNorm requires at least 3 inputs.");let at=st[0],pt=st[1],vt=st[2];if(at.dataType!==pt.dataType||at.dataType!==vt.dataType)throw new Error("All inputs must have the same data type");if(at.dims.length!==3&&at.dims.length!==2)throw new Error("Input must be 2D or 3D");if(pt.dims.length!==3&&pt.dims.length!==2)throw new Error("Skip must be 2D or 3D");let wt=at.dims[at.dims.length-1],$t=at.dims[at.dims.length-2];if(pt.dims[pt.dims.length-1]!==wt)throw new Error("Skip must have the same hidden size as input");if(pt.dims[pt.dims.length-2]!==$t)throw new Error("Skip must have the same sequence length as input");if(vt.dims.length!==1)throw new Error("Gamma must be 1D");if(vt.dims[vt.dims.length-1]!==wt)throw new Error("Gamma must have the same hidden size as input");if(st.length>3){let Tt=st[3];if(Tt.dims.length!==1)throw new Error("Beta must be 1D");if(Tt.dims[Tt.dims.length-1]!==wt)throw new Error("Beta must have the same hidden size as input")}if(st.length>4){let Tt=st[4];if(Tt.dims.length!==1)throw new Error("Bias must be 1D");if(Tt.dims[Tt.dims.length-1]!==wt)throw new Error("Bias must have the same hidden size as input")}},Vm=(st,at,pt,vt)=>{let wt=at.simplified,$t=st[0].dims,Tt=M.size($t),Lt=$t,Ft=Tt,Ct=$t.slice(-1)[0],Ht=vt?$t.slice(0,-1).concat(1):[],Gt=!wt&&st.length>3,jt=st.length>4,qt=vt&&pt>1,Kt=vt&&pt>2,An=pt>3,Sn=Ue(Ct),wn=[{type:12,data:Ft},{type:12,data:Sn},{type:12,data:Ct},{type:1,data:at.epsilon}],In=rr=>{let Hr=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],qr=[U("x",st[0].dataType,st[0].dims,Sn),U("skip",st[1].dataType,st[1].dims,Sn),U("gamma",st[2].dataType,st[2].dims,Sn)];Gt&&qr.push(U("beta",st[3].dataType,st[3].dims,Sn)),jt&&qr.push(U("bias",st[4].dataType,st[4].dims,Sn)),qr.push(K("output",st[0].dataType,Lt,Sn)),qt&&qr.push(K("mean_output",1,Ht)),Kt&&qr.push(K("inv_std_output",1,Ht)),An&&qr.push(K("input_skip_bias_sum",st[0].dataType,Lt,Sn));let Zr=De(st[0].dataType);return`

      ${rr.registerUniforms(Hr).declareVariables(...qr)}

      ${rr.mainStart()}
        ${rr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size / uniforms.hidden_size")}
        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        let offset = global_idx * hidden_size_vectorized;
        var sum = ${At("f32",Sn)};
        var squareSum = ${At("f32",Sn)};
        for (var i: u32 = 0; i < hidden_size_vectorized; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${jt?"bias[i]":Zr+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${An?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${fr(Zr,Sn,"value")};
          sum += f32_value;
          squareSum += f32_value * f32_value;
        }
        let mean = ${Et("sum",Sn)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Et("squareSum",Sn)} / f32(uniforms.hidden_size) ${wt?"":"- mean * mean"} + uniforms.epsilon);
        ${qt?"mean_output[global_idx] = mean;":""}
        ${Kt?"inv_std_output[global_idx] = inv_std_dev;":""}
        for (var i: u32 = 0; i < hidden_size_vectorized; i++) {
          output[offset + i] = (output[offset + i] ${wt?"":`- ${Zr}(mean)`}) * ${Zr}(inv_std_dev) * gamma[i] ${Gt?"+ beta[i]":""};
        }
      }`},tr=[{dims:Lt,dataType:st[0].dataType}];return pt>1&&tr.push({dims:Ht,dataType:1}),pt>2&&tr.push({dims:Ht,dataType:1}),pt>3&&tr.push({dims:$t,dataType:st[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${Sn};${qt};${Kt};${An}`,inputDependencies:st.map((rr,Hr)=>"type")},getShaderSource:In,getRunData:()=>({outputs:tr,dispatchGroup:{x:Math.ceil(Ft/Ct/64)},programUniforms:wn})}},ad=(st,at)=>{Nm(st.inputs);let pt=[0];st.outputCount>1&&pt.push(-3),st.outputCount>2&&pt.push(-3),st.outputCount>3&&pt.push(3),st.compute(Vm(st.inputs,at,st.outputCount,!1),{outputs:pt})}}),Hm,ui,Gm,ud,Lm,Fm,ld,dd,cd=j(()=>{ye(),xe(),Ze(),_e(),Hm=(st,at)=>{if(!st||st.length<1)throw new Error("too few inputs");if(at.axes.length!==0){if(at.axes.length!==at.starts.length||at.axes.length!==at.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(at.starts.length!==at.ends.length)throw new Error("starts and ends must have the same length");st.slice(1).forEach((pt,vt)=>{if(st[vt+1].dataType!==6&&st[vt+1].dataType!==7)throw new Error(`Input ${vt} must be an array of int32 or int64`)})},ui=(st,at)=>{let pt=[];if(st.length>at)if(st[at].dataType===7)st[at].getBigInt64Array().forEach(vt=>pt.push(Number(vt)));else if(st[at].dataType===6)st[at].getInt32Array().forEach(vt=>pt.push(Number(vt)));else throw new Error(`Input ${at} must be an array of int32 or int64`);return pt},Gm=(st,at)=>{if(st.length>1){let pt=ui(st,1),vt=ui(st,2),wt=ui(st,3);return wt.length===0&&(wt=[...Array(st[0].dims.length).keys()]),we({starts:pt,ends:vt,axes:wt})}else return at},ud=(st,at,pt,vt,wt)=>{let $t=st;return st<0&&($t+=pt[vt[at]]),wt[at]<0?Math.max(0,Math.min($t,pt[vt[at]]-1)):Math.max(0,Math.min($t,pt[vt[at]]))},Lm=(st,at,pt)=>`fn calculateInputIndices(output_indices: ${at.type.indices}) -> ${st.type.indices} {
          var input_indices: ${st.type.indices};
          var carry = 0u;
          for (var i = ${pt.length}; i >= 0; i--) {
            let input_shape_i = ${fe("uniforms.input_shape","i",pt.length)};
            let steps_i = ${fe("uniforms.steps","i",pt.length)};
            let signs_i = ${fe("uniforms.signs","i",pt.length)};
            let starts_i = ${fe("uniforms.starts","i",pt.length)};
            var output_index = ${at.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${st.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,Fm=(st,at)=>{let pt=st[0].dims,vt=M.size(pt),wt=at.axes.length>0?M.normalizeAxes(at.axes,pt.length):[...Array(pt.length).keys()],$t=ui(st,4);$t.forEach(wn=>wn!==0||(()=>{throw new Error("step cannot be 0")})),$t.length===0&&($t=Array(wt.length).fill(1));let Tt=at.starts.map((wn,In)=>ud(wn,In,pt,wt,$t)),Lt=at.ends.map((wn,In)=>ud(wn,In,pt,wt,$t));if(wt.length!==Tt.length||wt.length!==Lt.length)throw new Error("start, ends and axes should have the same number of elements");if(wt.length!==pt.length)for(let wn=0;wn<pt.length;++wn)wt.includes(wn)||(Tt.splice(wn,0,0),Lt.splice(wn,0,pt[wn]),$t.splice(wn,0,1));let Ft=$t.map(wn=>Math.sign(wn));$t.forEach((wn,In,tr)=>{if(wn<0){let rr=(Lt[In]-Tt[In])/wn,Hr=Tt[In],qr=Hr+rr*$t[In];Tt[In]=qr,Lt[In]=Hr,tr[In]=-wn}});let Ct=pt.slice(0);wt.forEach((wn,In)=>{Ct[wn]=Math.ceil((Lt[wn]-Tt[wn])/$t[wn])});let Ht={dims:Ct,dataType:st[0].dataType},Gt=K("output",st[0].dataType,Ct.length),jt=U("input",st[0].dataType,st[0].dims.length),qt=M.size(Ct),Kt=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:Tt.length},{name:"signs",type:"i32",length:Ft.length},{name:"steps",type:"u32",length:$t.length}],An=[{type:12,data:qt},{type:12,data:Tt},{type:6,data:Ft},{type:12,data:$t},...X(st[0].dims,Ct)],Sn=wn=>`
      ${wn.registerUniforms(Kt).declareVariables(jt,Gt)}
        ${Lm(jt,Gt,pt)}
        ${wn.mainStart()}
          ${wn.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${Gt.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${Gt.setByOffset("global_idx",jt.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${Ft.length}_${Tt.length}_${$t.length}`,inputDependencies:["rank"]},getShaderSource:Sn,getRunData:()=>({outputs:[Ht],dispatchGroup:{x:Math.ceil(vt/64)},programUniforms:An})}},ld=(st,at)=>{Hm(st.inputs,at);let pt=Gm(st.inputs,at);st.compute(Fm(st.inputs,pt),{inputs:[0]})},dd=st=>{let at=st.starts,pt=st.ends,vt=st.axes;return we({starts:at,ends:pt,axes:vt})}}),qm,jm,pd,md,fd=j(()=>{ye(),xe(),Ze(),_e(),qm=st=>{if(!st||st.length!==1)throw new Error("Softmax op requires 1 input.")},jm=(st,at)=>{let pt=st.dims,vt=M.size(pt),wt=64,$t=at.axis;if($t<0&&($t=pt.length+$t),$t<pt.length-1)throw new Error("softmax only supports last axis for now.");let Tt=pt[$t],Lt=vt/Tt,Ft=Ue(Tt),Ct=Tt/Ft,Ht=(Sn,wn)=>wn===4?`max(max(${Sn}.x, ${Sn}.y), max(${Sn}.z, ${Sn}.w))`:wn===2?`max(${Sn}.x, ${Sn}.y)`:wn===3?`max(max(${Sn}.x, ${Sn}.y), ${Sn}.z)`:Sn,Gt=U("x",st.dataType,st.dims,Ft),jt=K("result",st.dataType,st.dims,Ft),qt=Gt.type.value,Kt=De(st.dataType)==="f32"?`var threadMax = ${qt}(-3.402823e+38f);`:`var threadMax = ${qt}(-65504.0h);`,An=Sn=>`
      var<workgroup> rowMaxShared : ${qt};
      var<workgroup> rowSumShared : ${qt};
      var<workgroup> threadShared : array<${qt}, ${wt}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${qt} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${qt}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${Sn.registerUniform("packedCols","i32").declareVariables(Gt,jt)}
      ${Sn.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${wt};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${Kt}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${qt}(${Ht("threadShared[0]",Ft)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${qt}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${qt}(${Et("threadShared[0]",Ft)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;return{name:"Softmax",shaderCache:{hint:`${Ft}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:pt,dataType:st.dataType}],dispatchGroup:{x:Lt},programUniforms:[{type:6,data:Ct}]}),getShaderSource:An}},pd=(st,at)=>{qm(st.inputs),st.compute(jm(st.inputs[0],at))},md=st=>we({axis:st.axis})}),Km,Ym,Xm,Zm,Qm,hd,gd,yd=j(()=>{ye(),xe(),Ze(),_e(),Km=st=>{if(!st||st.length<1)throw new Error("too few inputs")},Ym=(st,at)=>{let pt=[],vt=at.numOutputs;return st[1].dims[0]>0&&(st[1].getBigInt64Array().forEach(wt=>pt.push(Number(wt))),vt=pt.length),we({numOutputs:vt,axis:at.axis,splitSizes:pt})},Xm=st=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${st}u; i += 1u ) {
    if (index < ${fe("uniforms.size_in_split_axis","i",st)}) {
        return i;
    }
    }
    return ${st}u;
}`,Zm=st=>{let at=st.length,pt=[];for(let vt=0;vt<at;++vt){let wt=st[vt].setByIndices("indices","input[global_idx]");at===1?pt.push(wt):vt===0?pt.push(`if (output_number == ${vt}u) { ${wt} }`):vt===at-1?pt.push(`else { ${wt} }`):pt.push(`else if (output_number == ${vt}) { ${wt} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${st[0].type.indices}, global_idx: u32) {
        ${pt.join(`
`)}
      }`},Qm=(st,at)=>{let pt=st[0].dims,vt=M.size(pt),wt=st[0].dataType,$t=M.normalizeAxis(at.axis,pt.length),Tt=new Array(at.numOutputs),Lt=U("input",wt,pt.length),Ft=new Array(at.numOutputs),Ct=[],Ht=[],Gt=0,jt=[{type:12,data:vt}];for(let Kt=0;Kt<at.numOutputs;Kt++){Gt+=at.splitSizes[Kt],Ft[Kt]=Gt;let An=pt.slice();An[at.axis]=at.splitSizes[Kt],Ht.push(An),Tt[Kt]=K(`output${Kt}`,wt,An.length),Ct.push({dims:Ht[Kt],dataType:st[0].dataType})}jt.push({type:12,data:Ft},...X(pt,...Ht));let qt=Kt=>`
  ${Kt.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",Ft.length).declareVariables(Lt,...Tt)}
  ${Xm(Ft.length)}
  ${Zm(Tt)}

  ${Kt.mainStart()}
    ${Kt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${Lt.offsetToIndices("global_idx")};
    var index = ${Lt.indicesGet("indices",$t)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${fe("uniforms.size_in_split_axis","output_number - 1u",Ft.length)};
      ${Lt.indicesSet("indices",$t,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:at.cacheKey,inputDependencies:["rank"]},getShaderSource:qt,getRunData:()=>({outputs:Ct,dispatchGroup:{x:Math.ceil(vt/64)},programUniforms:jt})}},hd=(st,at)=>{Km(st.inputs);let pt=st.inputs.length===1?at:Ym(st.inputs,at);st.compute(Qm(st.inputs,pt),{inputs:[0]})},gd=st=>{let at=st.axis,pt=st.splitSizes,vt=st.numOutputs<0?pt.length:st.numOutputs;if(vt!==pt.length)throw new Error("numOutputs and splitSizes lengh must be equal");return we({axis:at,numOutputs:vt,splitSizes:pt})}}),bd,Jm,ef,tf,vd,wd=j(()=>{ye(),xe(),_e(),bd=st=>Array.from(st.getBigInt64Array(),Number),Jm=st=>{if(!st||st.length!==2)throw new Error("Tile requires 2 inputs.");if(st[0].dataType!==1&&st[0].dataType!==6&&st[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(st[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(st[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(bd(st[1]).length!==st[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},ef=(st,at)=>{let pt=[];for(let vt=0;vt<st.length;++vt)pt.push(st[vt]*at[vt]);return pt},tf=st=>{let at=st[0].dims,pt=bd(st[1]),vt=ef(at,pt),wt=M.size(vt),$t=st[0].dataType,Tt=U("input",$t,at.length),Lt=K("output",$t,vt.length),Ft=Ct=>`
      const inputShape = ${Tt.indices(...at)};
      ${Ct.registerUniform("output_size","u32").declareVariables(Tt,Lt)}
      ${Ct.mainStart()}
      ${Ct.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${Lt.offsetToIndices("global_idx")};
      var input_indices: ${Tt.type.indices};
      for (var i = 0; i < ${at.length}; i++) {
        let input_dim_i = ${Tt.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${Lt.indicesGet("output_indices","i")}  % input_dim_i;

        ${Tt.indicesSet("input_indices","i","input_dim_value")}
      }
      ${Lt.setByOffset("global_idx",Tt.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${pt}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:vt,dataType:st[0].dataType}],dispatchGroup:{x:Math.ceil(wt/64)},programUniforms:[{type:12,data:wt},...X(st[0].dims,vt)]}),getShaderSource:Ft}},vd=st=>{Jm(st.inputs),st.compute(tf(st.inputs),{inputs:[0]})}}),rf,nf,$d,_d=j(()=>{ye(),xe(),_e(),rf=(st,at,pt,vt,wt)=>{let $t=K("output_data",wt,pt.length,4),Tt=U("a_data",at[1].dataType,at[1].dims.length,4),Lt=U("b_data",at[2].dataType,at[2].dims.length,4),Ft=U("c_data",at[0].dataType,at[0].dims.length,4),Ct,Ht=(Gt,jt,qt)=>`select(${jt}, ${Gt}, ${qt})`;if(!vt)Ct=$t.setByOffset("global_idx",Ht(Tt.getByOffset("global_idx"),Lt.getByOffset("global_idx"),Ft.getByOffset("global_idx")));else{let Gt=(jt,qt,Kt="")=>{let An=`a_data[index_a${qt}][component_a${qt}]`,Sn=`b_data[index_b${qt}][component_b${qt}]`,wn=`bool(c_data[index_c${qt}] & (0xffu << (component_c${qt} * 8)))`;return`
            let output_indices${qt} = ${$t.offsetToIndices(`global_idx * 4u + ${qt}u`)};
            let offset_a${qt} = ${Tt.broadcastedIndicesToOffset(`output_indices${qt}`,$t)};
            let offset_b${qt} = ${Lt.broadcastedIndicesToOffset(`output_indices${qt}`,$t)};
            let offset_c${qt} = ${Ft.broadcastedIndicesToOffset(`output_indices${qt}`,$t)};
            let index_a${qt} = offset_a${qt} / 4u;
            let index_b${qt} = offset_b${qt} / 4u;
            let index_c${qt} = offset_c${qt} / 4u;
            let component_a${qt} = offset_a${qt} % 4u;
            let component_b${qt} = offset_b${qt} % 4u;
            let component_c${qt} = offset_c${qt} % 4u;
            ${jt}[${qt}] = ${Kt}(${Ht(An,Sn,wn)});
          `};wt===9?Ct=`
            var data = vec4<u32>(0);
            ${Gt("data",0,"u32")}
            ${Gt("data",1,"u32")}
            ${Gt("data",2,"u32")}
            ${Gt("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:Ct=`
            ${Gt("output_data[global_idx]",0)}
            ${Gt("output_data[global_idx]",1)}
            ${Gt("output_data[global_idx]",2)}
            ${Gt("output_data[global_idx]",3)}
          `}return`
        ${st.registerUniform("vec_size","u32").declareVariables(Ft,Tt,Lt,$t)}
        ${st.mainStart()}
        ${st.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${Ct}
      }`},nf=st=>{let at=st[1].dims,pt=st[2].dims,vt=st[0].dims,wt=st[1].dataType,$t=!(M.areEqual(at,pt)&&M.areEqual(pt,vt)),Tt=at,Lt=M.size(at);if($t){let Ct=zt.calcShape(zt.calcShape(at,pt,!1),vt,!1);if(!Ct)throw new Error("Can't perform where op on the given tensors");Tt=Ct,Lt=M.size(Tt)}let Ft=Math.ceil(Lt/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:Ct=>rf(Ct,st,Tt,$t,wt),getRunData:()=>({outputs:[{dims:Tt,dataType:wt}],dispatchGroup:{x:Math.ceil(Lt/64/4)},programUniforms:[{type:12,data:Ft},...X(vt,at,pt,Tt)]})}},$d=st=>{st.compute(nf(st.inputs))}}),xd,Sd=j(()=>{zs(),oo(),Ws(),Vs(),Cu(),Du(),io(),co(),Xu(),Ju(),rl(),sl(),dl(),pl(),hl(),bl(),$l(),xl(),Cl(),mo(),Al(),Pl(),zl(),Zl(),Jl(),jn(),nd(),od(),sd(),cd(),fd(),yd(),wd(),Rr(),Jn(),_d(),xd=new Map([["Abs",[Hs]],["Acos",[Gs]],["Acosh",[Ls]],["Add",[Iu]],["ArgMax",[Rs,no]],["ArgMin",[Ps,no]],["Asin",[Fs]],["Asinh",[qs]],["Atan",[js]],["Atanh",[Ks]],["Attention",[Ms]],["AveragePool",[Hl,Vl]],["BatchNormalization",[Us]],["BiasAdd",[Ns]],["BiasSplitGelu",[Su]],["Cast",[Xs,Ys]],["Ceil",[Qs]],["Clip",[Zs]],["Concat",[Bs,Ds]],["Conv",[go,ho]],["ConvTranspose",[Yu,Ku]],["Cos",[Js]],["Cosh",[eu]],["CumSum",[Zu,Qu]],["DepthToSpace",[el,tl]],["Div",[Tu]],["Einsum",[ol,al]],["Elu",[tu,Zn]],["Equal",[Au]],["Erf",[ru]],["Exp",[nu]],["Expand",[ll]],["FastGelu",[cl]],["Floor",[iu]],["FusedConv",[go,ho]],["Gather",[fl,ml]],["GatherElements",[yl,gl]],["Gelu",[ou]],["Gemm",[wl,vl]],["GlobalAveragePool",[Fl,Ll]],["GlobalMaxPool",[Xl,Yl]],["Greater",[Pu]],["GreaterOrEqual",[zu]],["HardSigmoid",[mu,pu]],["InstanceNormalization",[_l]],["LayerNormalization",[Sl]],["LeakyRelu",[au,Zn]],["Less",[Ru]],["LessOrEqual",[Bu]],["Log",[_u]],["MatMul",[Hu]],["MatMulNBits",[Il,Tl]],["MaxPool",[jl,Kl]],["Mul",[Eu]],["MultiHeadAttention",[Ol,kl]],["Neg",[uu]],["Not",[su]],["Pad",[Rl]],["Pow",[ku]],["Range",[Ql]],["Reciprocal",[lu]],["ReduceMin",[Is]],["ReduceMean",[$s]],["ReduceMax",[Cs]],["ReduceSum",[As]],["ReduceProd",[Ts]],["ReduceL1",[_s]],["ReduceL2",[xs]],["ReduceLogSum",[ks]],["ReduceLogSumExp",[Ss]],["ReduceSumSquare",[Es]],["Relu",[du]],["Resize",[td,rd]],["RotaryEmbedding",[id]],["Sigmoid",[cu]],["Sin",[fu]],["Sinh",[hu]],["Slice",[ld,dd]],["SkipLayerNormalization",[ad]],["Split",[hd,gd]],["Sqrt",[gu]],["Softmax",[pd,md]],["Sub",[Ou]],["Tan",[yu]],["Tanh",[vu]],["ThresholdedRelu",[$u,Zn]],["Tile",[vd]],["Transpose",[us,ls]],["Where",[$d]]])}),li,Cd=j(()=>{_t(),Xt(),_e(),li=class{constructor(st){this.backend=st,this.repo=new Map,this.attributesBound=!1}getArtifact(st){return this.repo.get(st)}setArtifact(st,at){this.repo.set(st,at)}run(st,at,pt,vt,wt){yt(st.programInfo.name);let $t=this.backend.device,Tt=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let Lt=[];for(let Ct of at)Lt.push({binding:Lt.length,resource:{buffer:Ct.buffer}});for(let Ct of pt)Lt.push({binding:Lt.length,resource:{buffer:Ct.buffer}});wt&&Lt.push({binding:Lt.length,resource:wt});let Ft=$t.createBindGroup({layout:st.computePipeline.getBindGroupLayout(0),entries:Lt,label:st.programInfo.name});if(this.backend.sessionStatus==="capturing"){let Ct={kernelId:this.backend.currentKernelId,computePipeline:st.computePipeline,bindGroup:Ft,dispatchGroup:vt};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(Ct)}Tt.setPipeline(st.computePipeline),Tt.setBindGroup(0,Ft),Tt.dispatchWorkgroups(...vt),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),ut(st.programInfo.name)}dispose(){}build(st,at){yt(st.name);let pt=this.backend.device,vt=[];pt.features.has("shader-f16")&&vt.push("enable f16;");let wt=as(at,this.backend.device.limits),$t=st.getShaderSource(wt),Tt=`${vt.join(`
`)}
${wt.additionalImplementations}
${$t}`,Lt=pt.createShaderModule({code:Tt,label:st.name});Ne("verbose",()=>`[WebGPU] ${st.name} shader code: ${Tt}`);let Ft=pt.createComputePipeline({compute:{module:Lt,entryPoint:"main"},layout:"auto",label:st.name});return ut(st.name),{programInfo:st,computePipeline:Ft,uniformVariablesInfo:wt.variablesInfo}}normalizeDispatchGroupSize(st){let at=typeof st=="number"?st:st.x,pt=typeof st=="number"?1:st.y||1,vt=typeof st=="number"?1:st.z||1,wt=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(at<=wt&&pt<=wt&&vt<=wt)return[at,pt,vt];let $t=at*pt*vt,Tt=Math.ceil(Math.sqrt($t));if(Tt>wt){if(Tt=Math.ceil(Math.cbrt($t)),Tt>wt)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[Tt,Tt,Tt]}else return[Tt,Tt,1]}}}),of,af,_o,di,Id=j(()=>{_t(),ye(),Xt(),es(),os(),Sd(),Cd(),of=(st,at)=>{if(at.length!==st.length)throw new Error(`inputDependencies length ${at.length} is not equal to inputTensors length ${st.length}.`);let pt=[];for(let vt=0;vt<st.length;++vt){let wt=st[vt].dataType;switch(at[vt]){case"none":{pt.push("");break}case"type":{pt.push(`${wt}`);break}case"rank":{let $t=st[vt].dims.length;pt.push(`${wt};${$t}`);break}case"dims":{let $t=st[vt].dims.join(",");pt.push(`${wt};${$t}`);break}default:throw new Error(`unsupported input dependency: ${at[vt]}`)}}return pt.join("|")},af=(st,at,pt)=>{var wt,$t;let vt=st.name;return(wt=st.shaderCache)!=null&&wt.hint&&(vt+="["+st.shaderCache.hint+"]"),vt+=":"+pt+`:${of(at,(($t=st.shaderCache)==null?void 0:$t.inputDependencies)??new Array(at.length).fill("dims"))}`,vt},_o=class{constructor(st){st&&(this.architecture=st.architecture,this.vendor=st.vendor)}isArchitecture(st){return this.architecture===st}isVendor(st){return this.vendor===st}},di=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let st=this.kernelCustomData.get(this.currentKernelId);return st||(st={},this.kernelCustomData.set(this.currentKernelId,st)),st}async initialize(st,at){this.env=st;let pt=[],vt={requiredLimits:{maxComputeWorkgroupStorageSize:at.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:at.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:at.limits.maxStorageBufferBindingSize,maxBufferSize:at.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:at.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:at.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:at.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:at.limits.maxComputeWorkgroupSizeZ},requiredFeatures:pt};at.features.has("chromium-experimental-timestamp-query-inside-passes")?pt.push("chromium-experimental-timestamp-query-inside-passes"):at.features.has("timestamp-query")&&pt.push("timestamp-query"),at.features.has("shader-f16")&&pt.push("shader-f16"),this.device=await at.requestDevice(vt),this.adapterInfo=new _o(await at.requestAdapterInfo()),this.gpuDataManager=is(this),this.programManager=new li(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Qa(st.logLevel,!!st.debug),this.device.onuncapturederror=wt=>{wt.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${wt.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:at,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let st=this.getCommandEncoder(),at={};this.queryType==="at-passes"&&(at.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=st.beginComputePass(at)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;yt(),this.endComputePass();let st;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),st=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(st,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,st,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&st.mapAsync(GPUMapMode.READ).then(()=>{var vt;let at=new BigUint64Array(st.getMappedRange()),pt=this.pendingQueries.get(st);for(let wt=0;wt<at.length/2;wt++){let $t=pt[wt],Tt=$t.kernelId,Lt=this.kernels.get(Tt),Ft=Lt.kernelType,Ct=Lt.kernelName,Ht=$t.programName,Gt=$t.inputTensorViews,jt=$t.outputTensorViews,qt=at[wt*2],Kt=at[wt*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=qt);let An=Number(qt-this.queryTimeBase),Sn=Number(Kt-this.queryTimeBase);if(!Number.isSafeInteger(An)||!Number.isSafeInteger(Sn))throw new RangeError("incorrect timestamp range");if((vt=this.env.webgpu.profiling)!=null&&vt.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:Gt.map(wn=>({dims:wn.dims,dataType:Yt(wn.dataType)})),outputsMetadata:jt.map(wn=>({dims:wn.dims,dataType:Yt(wn.dataType)})),kernelId:Tt,kernelType:Ft,kernelName:Ct,programName:Ht,startTime:An,endTime:Sn});else{let wn="";Gt.forEach((tr,rr)=>{wn+=`input[${rr}]: [${tr.dims}] | ${Yt(tr.dataType)}, `});let In="";jt.forEach((tr,rr)=>{In+=`output[${rr}]: [${tr.dims}] | ${Yt(tr.dataType)}, `}),console.log(`[profiling] kernel "${Tt}|${Ft}|${Ct}|${Ht}" ${wn}${In}execution time: ${Sn-An} ns`)}Bn("GPU",`${Ht}::${qt}::${Kt}`)}st.unmap(),this.pendingQueries.delete(st)}),ut()}run(st,at,pt,vt,wt,$t){yt(st.name);let Tt=[];for(let In=0;In<at.length;++In){let tr=at[In].data;if(tr===0)continue;let rr=this.gpuDataManager.get(tr);if(!rr)throw new Error(`no GPU data for input: ${tr}`);Tt.push(rr)}let{outputs:Lt,dispatchGroup:Ft,programUniforms:Ct}=st.getRunData(at),Ht=pt.length===0?Lt.map((In,tr)=>tr):pt;if(Ht.length!==Lt.length)throw new Error(`Output size ${Ht.length} must be equal to ${Lt.length}.`);let Gt=[],jt=[];for(let In=0;In<Lt.length;++In){if(!Number.isInteger(Ht[In])||Ht[In]<-3||Ht[In]>=$t)throw new Error(`Invalid output index: ${Ht[In]}`);if(Ht[In]===-3)continue;let tr=Ht[In]===-1,rr=Ht[In]===-2,Hr=tr||rr?wt(Lt[In].dataType,Lt[In].dims):vt(Ht[In],Lt[In].dataType,Lt[In].dims);if(Gt.push(Hr),Hr.data===0)continue;let qr=this.gpuDataManager.get(Hr.data);if(!qr)throw new Error(`no GPU data for output: ${Hr.data}`);if(tr&&this.temporaryData.push(qr),rr){let Zr=this.kernelPersistentData.get(this.currentKernelId);Zr||(Zr=[],this.kernelPersistentData.set(this.currentKernelId,Zr)),Zr.push(qr)}jt.push(qr)}if(Tt.length!==at.length||jt.length!==Gt.length){if(jt.length===0)return ut(st.name),Gt;throw new Error(`Program ${st.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let qt;if(Ct){let In=0,tr=[];Ct.forEach(Zr=>{let Bo=typeof Zr.data=="number"?[Zr.data]:Zr.data;if(Bo.length===0)return;let Xo=Zr.type===10?2:4,Kr,ko;Zr.type===10?(ko=Bo.length>4?16:Bo.length>2?8:Bo.length*Xo,Kr=Bo.length>4?16:Xo*Bo.length):(ko=Bo.length<=2?Bo.length*Xo:16,Kr=16),In=Math.ceil(In/ko)*ko,tr.push(In);let f0=Zr.type===10?8:4;In+=Bo.length>4?Math.ceil(Bo.length/f0)*Kr:Bo.length*Xo});let rr=16;In=Math.ceil(In/rr)*rr;let Hr=new ArrayBuffer(In);Ct.forEach((Zr,Bo)=>{let Xo=tr[Bo],Kr=typeof Zr.data=="number"?[Zr.data]:Zr.data;if(Zr.type===6)new Int32Array(Hr,Xo,Kr.length).set(Kr);else if(Zr.type===12)new Uint32Array(Hr,Xo,Kr.length).set(Kr);else if(Zr.type===10)new Uint16Array(Hr,Xo,Kr.length).set(Kr);else if(Zr.type===1)new Float32Array(Hr,Xo,Kr.length).set(Kr);else throw new Error(`Unsupported uniform type: ${Yt(Zr.type)}`)});let qr=this.gpuDataManager.create(In,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(qr.buffer,0,Hr,0,In),this.gpuDataManager.release(qr.id),qt={offset:0,size:In,buffer:qr.buffer}}let Kt=this.programManager.normalizeDispatchGroupSize(Ft),An=Kt[1]===1&&Kt[2]===1,Sn=af(st,at,An),wn=this.programManager.getArtifact(Sn);if(wn||(wn=this.programManager.build(st,Kt),this.programManager.setArtifact(Sn,wn),Ne("info",()=>`[artifact] key: ${Sn}, programName: ${st.name}`)),Ct&&wn.uniformVariablesInfo){if(Ct.length!==wn.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${wn.uniformVariablesInfo.length}, got ${Ct.length} in program "${wn.programInfo.name}".`);for(let In=0;In<Ct.length;In++){let tr=Ct[In],rr=tr.type,Hr=typeof tr.data=="number"?1:tr.data.length,[qr,Zr]=wn.uniformVariablesInfo[In];if(rr!==qr||Hr!==Zr)throw new Error(`Uniform variable ${In} mismatch: expect type ${qr} with size ${Zr}, got type ${rr} with size ${Hr} in program "${wn.programInfo.name}".`)}}if(Ne("info",()=>`[ProgramManager] run "${st.name}" (key=${Sn}) with ${Kt[0]}x${Kt[1]}x${Kt[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let In={kernelId:this.currentKernelId,programName:wn.programInfo.name,inputTensorViews:at,outputTensorViews:Gt};this.pendingKernels.push(In),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(In)}return this.programManager.run(wn,Tt,jt,Kt,qt),ut(st.name),Gt}upload(st,at){this.gpuDataManager.upload(st,at)}memcpy(st,at){this.gpuDataManager.memcpy(st,at)}async download(st,at){await this.gpuDataManager.download(st,at)}alloc(st){return this.gpuDataManager.create(st).id}free(st){return this.gpuDataManager.release(st)}createKernel(st,at,pt,vt){let wt=xd.get(st);if(!wt)throw new Error(`kernel not implemented: ${st}`);let $t={kernelType:st,kernelName:vt,kernelEntry:wt[0],attributes:[wt[1],pt]};this.kernels.set(at,$t)}releaseKernel(st){let at=this.kernelPersistentData.get(st);if(at){for(let pt of at)this.gpuDataManager.release(pt.id);this.kernelPersistentData.delete(st)}this.kernelCustomData.delete(st),this.kernels.delete(st)}computeKernel(st,at,pt){let vt=this.kernels.get(st);if(!vt)throw new Error(`kernel not created: ${st}`);let wt=vt.kernelType,$t=vt.kernelName,Tt=vt.kernelEntry,Lt=vt.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${wt}] ${$t}" is not allowed to be called recursively`);this.currentKernelId=st,Lt[0]&&(Lt[1]=Lt[0](Lt[1]),Lt[0]=void 0),Ne("info",()=>`[WebGPU] Start to run kernel "[${wt}] ${$t}"...`);let Ft=this.env.debug;this.temporaryData=[];try{return Ft&&this.device.pushErrorScope("validation"),Tt(at,Lt[1]),0}catch(Ct){return pt.push(Promise.resolve(`[WebGPU] Kernel "[${wt}] ${$t}" failed. ${Ct}`)),1}finally{Ft&&pt.push(this.device.popErrorScope().then(Ct=>Ct?`GPU validation error for kernel "[${wt}] ${$t}": ${Ct.message}`:null));for(let Ct of this.temporaryData)this.gpuDataManager.release(Ct.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(st,at,pt,vt){let wt=this.sessionExternalDataMapping.get(st);wt||(wt=new Map,this.sessionExternalDataMapping.set(st,wt));let $t=wt.get(at),Tt=this.gpuDataManager.registerExternalBuffer(pt,vt,$t==null?void 0:$t[1]);return wt.set(at,[Tt,pt]),Tt}unregisterBuffers(st){let at=this.sessionExternalDataMapping.get(st);at&&(at.forEach(pt=>this.gpuDataManager.unregisterExternalBuffer(pt[1])),this.sessionExternalDataMapping.delete(st))}getBuffer(st){let at=this.gpuDataManager.get(st);if(!at)throw new Error(`no GPU data for buffer: ${st}`);return at.buffer}createDownloader(st,at,pt){return async()=>{let vt=await Xi(this,st,at);return Ja(vt.buffer,pt)}}writeTimestamp(st){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,st)}setQueryType(){var st;this.queryType="none",(((st=this.env.webgpu.profiling)==null?void 0:st.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Ne("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Ne("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Ne("info","replay"),this.sessionStatus="replaying";let st=this.capturedCommandList.get(this.currentSessionId),at=this.capturedPendingKernels.get(this.currentSessionId),pt=st.length;this.pendingKernels=[];for(let vt=0;vt<pt;vt++){let wt=this.getComputePassEncoder(),$t=st[vt];this.writeTimestamp(this.pendingDispatchNumber*2),wt.setPipeline($t.computePipeline),wt.setBindGroup(0,$t.bindGroup),wt.dispatchWorkgroups(...$t.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(at[vt]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onReleaseSession(st){this.unregisterBuffers(st),this.capturedCommandList.has(st)&&this.capturedCommandList.delete(st),this.capturedPendingKernels.has(st)&&this.capturedPendingKernels.delete(st),this.gpuDataManager.onReleaseSession(st)}onRunStart(st){this.currentSessionId=st,this.setQueryType()}}}),Td={};kr(Td,{init:()=>sf});var an,xo,sf,Ad=j(()=>{ye(),Id(),Xt(),xe(),an=class YE{constructor(at,pt,vt,wt){this.module=at,this.dataType=pt,this.data=vt,this.dims=wt}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let at=M.size(this.dims);return at===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,at)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let at=M.size(this.dims);return at===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,at)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let at=M.size(this.dims);return at===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,at)}reshape(at){if(M.size(at)!==M.size(this.dims))throw new Error("Invalid new shape");return new YE(this.module,this.dataType,this.data,at)}},xo=class{constructor(st,at,pt){this.module=st,this.backend=at,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=at.adapterInfo;let vt=st.HEAPU32,wt=pt>>>2;this.opKernelContext=vt[wt++];let $t=vt[wt++];this.outputCount=vt[wt++],this.customDataOffset=vt[wt++],this.customDataSize=vt[wt++];let Tt=[];for(let Lt=0;Lt<$t;Lt++){let Ft=vt[wt++],Ct=vt[wt++],Ht=vt[wt++],Gt=[];for(let jt=0;jt<Ht;jt++)Gt.push(vt[wt++]);Tt.push(new an(st,Ft,Ct,Gt))}this.inputs=Tt}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}getMaxComputeWorkgroupSizes(){return[this.backend.device.limits.maxComputeWorkgroupSizeX,this.backend.device.limits.maxComputeWorkgroupSizeY,this.backend.device.limits.maxComputeWorkgroupSizeZ]}getMaxComputeWorkgroupStoragesize(){return this.backend.device.limits.maxComputeWorkgroupStorageSize}compute(st,at){var Tt;let pt=((Tt=at==null?void 0:at.inputs)==null?void 0:Tt.map(Lt=>typeof Lt=="number"?this.inputs[Lt]:Lt))??this.inputs,vt=(at==null?void 0:at.outputs)??[],wt=(Lt,Ft,Ct)=>new an(this.module,Ft,this.output(Lt,Ct),Ct),$t=(Lt,Ft)=>{let Ct=cr(Lt);if(!Ct)throw new Error(`Unsupported data type: ${Lt}`);let Ht=Ct*M.size(Ft),Gt=Ht>0?this.backend.gpuDataManager.create(Ht).id:0;return new an(this.module,Lt,Gt,Ft)};return this.backend.run(st,pt,vt,wt,$t,this.outputCount)}output(st,at){let pt=this.module.stackSave();try{let vt=this.module.stackAlloc((1+at.length)*4),wt=vt>>2;this.module.HEAPU32[wt++]=at.length;for(let $t=0;$t<at.length;$t++)this.module.HEAPU32[wt++]=at[$t];return this.module._JsepOutput(this.opKernelContext,st,vt)}catch(vt){throw new Error(`Failed to generate kernel's output[${st}] with dims [${at}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${vt}`)}finally{this.module.stackRestore(pt)}}},sf=async(st,at,pt,vt)=>{let wt=at.jsepInit;if(!wt)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(st==="webgpu"){let $t=new di;await $t.initialize(pt,vt),wt("webgpu",[$t,Tt=>$t.alloc(Tt),Tt=>$t.free(Tt),(Tt,Lt,Ft,Ct=!1)=>{if(Ct)Ne("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Tt}, dst=${Lt}, size=${Ft}`),$t.memcpy(Tt,Lt);else{Ne("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Tt}, gpuDataId=${Lt}, size=${Ft}`);let Ht=at.HEAPU8.subarray(Tt>>>0,(Tt>>>0)+Ft);$t.upload(Lt,Ht)}},async(Tt,Lt,Ft)=>{Ne("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${Tt}, dataOffset=${Lt}, size=${Ft}`),await $t.download(Tt,()=>at.HEAPU8.subarray(Lt>>>0,(Lt>>>0)+Ft))},(Tt,Lt,Ft)=>$t.createKernel(Tt,Lt,Ft,at.UTF8ToString(at._JsepGetNodeName(Lt))),Tt=>$t.releaseKernel(Tt),(Tt,Lt,Ft,Ct)=>{Ne("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${Ft}, kernel=${Tt}, contextDataOffset=${Lt}`);let Ht=new xo(at,$t,Lt);return $t.computeKernel(Tt,Ht,Ct)},()=>$t.captureBegin(),()=>$t.captureEnd(),()=>$t.replay()])}else wt("webnn")}}),uf,kd,Od,hr,lf,So,Pd,Rd,Ed,zd,Bd,Dd,Md=j(()=>{ja(),Ya(),ye(),Or(),Wn(),qi(),uf=(st,at)=>{Fe()._OrtInit(st,at)!==0&&We("Can't initialize onnxruntime.")},kd=async st=>{uf(st.wasm.numThreads,en(st.logLevel))},Od=async(st,at)=>{{let pt=(Ad(),sr(Td)).init;if(at==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let vt=st.webgpu.adapter;if(vt){if(typeof vt.limits!="object"||typeof vt.features!="object"||typeof vt.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let wt=st.webgpu.powerPreference;if(wt!==void 0&&wt!=="low-power"&&wt!=="high-performance")throw new Error(`Invalid powerPreference setting: "${wt}"`);let $t=st.webgpu.forceFallbackAdapter;if($t!==void 0&&typeof $t!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${$t}"`);if(vt=await navigator.gpu.requestAdapter({powerPreference:wt,forceFallbackAdapter:$t}),!vt)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}if(!st.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");await pt("webgpu",Fe(),st,vt)}if(at==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await pt("webnn",Fe(),st)}}},hr=new Map,lf=st=>{let at=Fe(),pt=at.stackSave();try{let vt=at.stackAlloc(8);return at._OrtGetInputOutputCount(st,vt,vt+4)!==0&&We("Can't get session input/output count."),[at.HEAP32[vt/4],at.HEAP32[vt/4+1]]}finally{at.stackRestore(pt)}},So=st=>{let at=Fe(),pt=at._malloc(st.byteLength);if(pt===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${st.byteLength}.`);return at.HEAPU8.set(st,pt),[pt,st.byteLength]},Pd=async(st,at)=>{var Gt,jt;let pt,vt,wt=Fe();Array.isArray(st)?[pt,vt]=st:st.buffer===wt.HEAPU8.buffer?[pt,vt]=[st.byteOffset,st.byteLength]:[pt,vt]=So(st);let $t=0,Tt=0,Lt=0,Ft=[],Ct=[],Ht=[];try{if([Tt,Ft]=Ka(at),(at==null?void 0:at.externalData)&&wt.mountExternalData){let rr=[];for(let Hr of at.externalData){let qr=typeof Hr=="string"?Hr:Hr.path;rr.push(tn(typeof Hr=="string"?Hr:Hr.data).then(Zr=>{wt.mountExternalData(qr,Zr)}))}await Promise.all(rr)}$t=await wt._OrtCreateSession(pt,vt,Tt),$t===0&&We("Can't create a session.");let[qt,Kt]=lf($t),An=!!(at!=null&&at.enableGraphCapture),Sn=[],wn=[],In=[];for(let rr=0;rr<qt;rr++){let Hr=wt._OrtGetInputName($t,rr);Hr===0&&We("Can't get an input name."),Ct.push(Hr),Sn.push(wt.UTF8ToString(Hr))}for(let rr=0;rr<Kt;rr++){let Hr=wt._OrtGetOutputName($t,rr);Hr===0&&We("Can't get an output name."),Ht.push(Hr);let qr=wt.UTF8ToString(Hr);wn.push(qr);{if(An&&(at==null?void 0:at.preferredOutputLocation)===void 0){In.push("gpu-buffer");continue}let Zr=typeof(at==null?void 0:at.preferredOutputLocation)=="string"?at.preferredOutputLocation:((Gt=at==null?void 0:at.preferredOutputLocation)==null?void 0:Gt[qr])??"cpu";if(Zr!=="cpu"&&Zr!=="cpu-pinned"&&Zr!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${Zr}.`);if(An&&Zr!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${Zr}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);In.push(Zr)}}let tr=null;return In.some(rr=>rr==="gpu-buffer")&&(Lt=wt._OrtCreateBinding($t),Lt===0&&We("Can't create IO binding."),tr={handle:Lt,outputPreferredLocations:In,outputPreferredLocationsEncoded:In.map(rr=>Fi(rr))}),hr.set($t,[$t,Ct,Ht,tr,An,!1]),[$t,Sn,wn]}catch(qt){throw Ct.forEach(Kt=>wt._OrtFree(Kt)),Ht.forEach(Kt=>wt._OrtFree(Kt)),Lt!==0&&wt._OrtReleaseBinding(Lt),$t!==0&&wt._OrtReleaseSession($t),qt}finally{wt._free(pt),Tt!==0&&wt._OrtReleaseSessionOptions(Tt),Ft.forEach(qt=>wt._free(qt)),(jt=wt.unmountExternalData)==null||jt.call(wt)}},Rd=st=>{var Ft;let at=Fe(),pt=hr.get(st);if(!pt)throw new Error(`cannot release session. invalid session id: ${st}`);let[vt,wt,$t,Tt,Lt]=pt;Tt&&(Lt&&at._OrtClearBoundOutputs(Tt.handle),at._OrtReleaseBinding(Tt.handle)),(Ft=at.jsepOnReleaseSession)==null||Ft.call(at,st),wt.forEach(Ct=>at._OrtFree(Ct)),$t.forEach(Ct=>at._OrtFree(Ct)),at._OrtReleaseSession(vt),hr.delete(st)},Ed=(st,at,pt,vt,wt,$t=!1)=>{if(!st){at.push(0);return}let Tt=Fe(),Lt=st[0],Ft=st[1],Ct=st[3],Ht,Gt;if(Lt==="string"&&Ct==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if($t&&Ct!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${wt} when enableGraphCapture is true.`);if(Ct==="gpu-buffer"){let Kt=st[2].gpuBuffer,An=cr(Li(Lt));Gt=Ft.reduce((wn,In)=>wn*In,1)*An;let Sn=Tt.jsepRegisterBuffer;if(!Sn)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');Ht=Sn(vt,wt,Kt,Gt)}else{let Kt=st[2];if(Array.isArray(Kt)){Gt=4*Kt.length,Ht=Tt._malloc(Gt),pt.push(Ht);let An=Ht/4;for(let Sn=0;Sn<Kt.length;Sn++){if(typeof Kt[Sn]!="string")throw new TypeError(`tensor data at index ${Sn} is not a string`);Tt.HEAPU32[An++]=qe(Kt[Sn],pt)}}else Gt=Kt.byteLength,Ht=Tt._malloc(Gt),pt.push(Ht),Tt.HEAPU8.set(new Uint8Array(Kt.buffer,Kt.byteOffset,Gt),Ht)}let jt=Tt.stackSave(),qt=Tt.stackAlloc(4*Ft.length);try{let Kt=qt/4;Ft.forEach(Sn=>Tt.HEAP32[Kt++]=Sn);let An=Tt._OrtCreateTensor(Li(Lt),Ht,Gt,qt,Ft.length,Fi(Ct));An===0&&We(`Can't create tensor for input/output. session=${vt}, index=${wt}.`),at.push(An)}finally{Tt.stackRestore(jt)}},zd=async(st,at,pt,vt,wt,$t)=>{var Kr,ko;let Tt=Fe(),Lt=hr.get(st);if(!Lt)throw new Error(`cannot run inference. invalid session id: ${st}`);let Ft=Lt[0],Ct=Lt[1],Ht=Lt[2],Gt=Lt[3],jt=Lt[4],qt=Lt[5],Kt=at.length,An=vt.length,Sn=0,wn=[],In=[],tr=[],rr=[],Hr=Tt.stackSave(),qr=Tt.stackAlloc(Kt*4),Zr=Tt.stackAlloc(Kt*4),Bo=Tt.stackAlloc(An*4),Xo=Tt.stackAlloc(An*4);try{[Sn,wn]=qa($t);for(let n0=0;n0<Kt;n0++)Ed(pt[n0],In,rr,st,at[n0],jt);for(let n0=0;n0<An;n0++)Ed(wt[n0],tr,rr,st,Kt+vt[n0],jt);let f0=qr/4,x0=Zr/4,l0=Bo/4,T0=Xo/4;for(let n0=0;n0<Kt;n0++)Tt.HEAPU32[f0++]=In[n0],Tt.HEAPU32[x0++]=Ct[at[n0]];for(let n0=0;n0<An;n0++)Tt.HEAPU32[l0++]=tr[n0],Tt.HEAPU32[T0++]=Ht[vt[n0]];if(Gt&&!qt){let{handle:n0,outputPreferredLocations:m0,outputPreferredLocationsEncoded:h0}=Gt;if(Ct.length!==Kt)throw new Error(`input count from feeds (${Kt}) is expected to be always equal to model's input count (${Ct.length}).`);for(let a0=0;a0<Kt;a0++){let P0=at[a0];await Tt._OrtBindInput(n0,Ct[P0],In[a0])!==0&&We(`Can't bind input[${a0}] for session=${st}.`)}for(let a0=0;a0<An;a0++){let P0=vt[a0];(Kr=wt[a0])!=null&&Kr[3]?Tt._OrtBindOutput(n0,Ht[P0],tr[a0],0)!==0&&We(`Can't bind pre-allocated output[${a0}] for session=${st}.`):Tt._OrtBindOutput(n0,Ht[P0],0,h0[P0])!==0&&We(`Can't bind output[${a0}] to ${m0[a0]} for session=${st}.`)}hr.set(st,[Ft,Ct,Ht,Gt,jt,!0])}(ko=Tt.jsepOnRunStart)==null||ko.call(Tt,Ft);let t0;Gt?t0=await Tt._OrtRunWithBinding(Ft,Gt.handle,An,Bo,Sn):t0=await Tt._OrtRun(Ft,Zr,qr,Kt,Xo,An,Bo,Sn),t0!==0&&We("failed to call OrtRun().");let E0=[];for(let n0=0;n0<An;n0++){let m0=Tt.HEAPU32[Bo/4+n0];if(m0===tr[n0]){E0.push(wt[n0]);continue}let h0=Tt.stackSave(),a0=Tt.stackAlloc(4*4),P0=!1,V0,B0=0;try{Tt._OrtGetTensorData(m0,a0,a0+4,a0+8,a0+12)!==0&&We(`Can't access output tensor data on index ${n0}.`);let W0=a0/4,K0=Tt.HEAPU32[W0++];B0=Tt.HEAPU32[W0++];let Ty=Tt.HEAPU32[W0++],$y=Tt.HEAPU32[W0++],My=[];for(let _0=0;_0<$y;_0++)My.push(Tt.HEAPU32[Ty/4+_0]);Tt._OrtFree(Ty);let Wy=My.reduce((_0,ay)=>_0*ay,1);V0=Yt(K0);let Ey=Gt==null?void 0:Gt.outputPreferredLocations[vt[n0]];if(V0==="string"){if(Ey==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let _0=[],ay=B0/4;for(let J0=0;J0<Wy;J0++){let yy=Tt.HEAPU32[ay++],uy=J0===Wy-1?void 0:Tt.HEAPU32[ay]-yy;_0.push(Tt.UTF8ToString(yy,uy))}E0.push([V0,My,_0,"cpu"])}else if(Ey==="gpu-buffer"&&Wy>0){let _0=Tt.jsepGetBuffer;if(!_0)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let ay=_0(B0),J0=cr(K0);if(J0===void 0||!Vn(V0))throw new Error(`Unsupported data type: ${V0}`);P0=!0,E0.push([V0,My,{gpuBuffer:ay,download:Tt.jsepCreateDownloader(ay,Wy*J0,V0),dispose:()=>{Tt._OrtReleaseTensor(m0)}},"gpu-buffer"])}else{let _0=Nn(V0),ay=new _0(Wy);new Uint8Array(ay.buffer,ay.byteOffset,ay.byteLength).set(Tt.HEAPU8.subarray(B0,B0+ay.byteLength)),E0.push([V0,My,ay,"cpu"])}}finally{Tt.stackRestore(h0),V0==="string"&&B0&&Tt._free(B0),P0||Tt._OrtReleaseTensor(m0)}}return Gt&&!jt&&(Tt._OrtClearBoundOutputs(Gt.handle),hr.set(st,[Ft,Ct,Ht,Gt,jt,!1])),E0}finally{Tt.stackRestore(Hr),In.forEach(f0=>Tt._OrtReleaseTensor(f0)),tr.forEach(f0=>Tt._OrtReleaseTensor(f0)),rr.forEach(f0=>Tt._free(f0)),Sn!==0&&Tt._OrtReleaseRunOptions(Sn),wn.forEach(f0=>Tt._free(f0))}},Bd=st=>{let at=Fe(),pt=hr.get(st);if(!pt)throw new Error("invalid session id");let vt=pt[0],wt=at._OrtEndProfiling(vt);wt===0&&We("Can't get an profile file name."),at._OrtFree(wt)},Dd=st=>{let at=[];for(let pt of st){let vt=pt[2];!Array.isArray(vt)&&"buffer"in vt&&at.push(vt.buffer)}return at}}),Ud=Er((st,at)=>{at.exports='/*!\n * ONNX Runtime Web v1.18.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var ao=Object.defineProperty;var nl=Object.getOwnPropertyDescriptor;var ol=Object.getOwnPropertyNames;var il=Object.prototype.hasOwnProperty;var Y=(e,t)=>()=>(e&&(t=e(e=0)),t);var Wr=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),gn=(e,t)=>{for(var r in t)ao(e,r,{get:t[r],enumerable:!0})},al=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of ol(t))!il.call(e,i)&&i!==r&&ao(e,i,{get:()=>t[i],enumerable:!(o=nl(t,i))||o.enumerable});return e};var wr=e=>al(ao({},"__esModule",{value:!0}),e);var so={};gn(so,{createReadStream:()=>Ai,readFile:()=>sl,readFileSync:()=>ul});var sl,ul,Ai,uo=Y(()=>{sl=void 0,ul=void 0,Ai=void 0});var lo={};gn(lo,{join:()=>dl});var dl,co=Y(()=>{dl=void 0});var Ei=Wr((Ti,po)=>{"use strict";var Ii=(()=>{var e=typeof document<"u"?document.currentScript?.src:void 0;return typeof __filename<"u"&&(e||=__filename),function(t={}){var r=t,o,i,u=new Promise((s,m)=>{o=s,i=m});r.mountExternalData=(s,m)=>{(r.eb||(r.eb=new Map)).set(s,m)},r.unmountExternalData=()=>{delete r.eb};let a=()=>{let s=(g,$,T)=>(...B)=>{let H=dt,q=$?.();B=g(...B);let te=$?.();return q!==te&&(g=te,T(q),$=T=null),dt!=H?tn():B},m=g=>async(...$)=>{try{if(r.cb)throw Error("Session already started");let T=r.cb={xb:$[0],errors:[]},B=await g(...$);if(r.cb!==T)throw Error("Session mismatch");r.kb?.flush();let H=T.errors;if(0<H.length){let q=await Promise.all(H);if(q=q.filter(te=>te),0<q.length)throw Error(q.join(`\n`))}return B}finally{r.cb=null}};r._OrtCreateSession=s(r._OrtCreateSession,()=>r._OrtCreateSession,g=>r._OrtCreateSession=g),r._OrtRun=m(s(r._OrtRun,()=>r._OrtRun,g=>r._OrtRun=g)),r._OrtRunWithBinding=m(s(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,g=>r._OrtRunWithBinding=g)),r._OrtBindInput=s(r._OrtBindInput,()=>r._OrtBindInput,g=>r._OrtBindInput=g),a=void 0};r.jsepInit=(s,m)=>{if(a?.(),s==="webgpu"){[r.kb,r.pb,r.tb,r.lb,r.sb,r.Ra,r.ub,r.wb,r.qb,r.rb,r.vb]=m;let g=r.kb;r.jsepRegisterBuffer=($,T,B,H)=>g.registerBuffer($,T,B,H),r.jsepGetBuffer=$=>g.getBuffer($),r.jsepCreateDownloader=($,T,B)=>g.createDownloader($,T,B),r.jsepOnReleaseSession=$=>{g.onReleaseSession($)},r.jsepOnRunStart=$=>g.onRunStart($)}};var c=Object.assign({},r),p="./this.program",h=(s,m)=>{throw m},d=typeof window=="object",y=typeof importScripts=="function",w=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",_="",v,S,A;if(w){var I=(uo(),wr(so)),x=(co(),wr(lo));_=y?x.dirname(_)+"/":__dirname+"/",v=(s,m)=>(s=Ke(s)?new URL(s):x.normalize(s),I.readFileSync(s,m?void 0:"utf8")),A=s=>(s=v(s,!0),s.buffer||(s=new Uint8Array(s)),s),S=(s,m,g,$=!0)=>{s=Ke(s)?new URL(s):x.normalize(s),I.readFile(s,$?void 0:"utf8",(T,B)=>{T?g(T):m($?B.buffer:B)})},!r.thisProgram&&1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),h=(s,m)=>{throw process.exitCode=s,m}}else(d||y)&&(y?_=self.location.href:typeof document<"u"&&document.currentScript&&(_=document.currentScript.src),e&&(_=e),_.startsWith("blob:")?_="":_=_.substr(0,_.replace(/[?#].*/,"").lastIndexOf("/")+1),v=s=>{var m=new XMLHttpRequest;return m.open("GET",s,!1),m.send(null),m.responseText},y&&(A=s=>{var m=new XMLHttpRequest;return m.open("GET",s,!1),m.responseType="arraybuffer",m.send(null),new Uint8Array(m.response)}),S=(s,m,g)=>{var $=new XMLHttpRequest;$.open("GET",s,!0),$.responseType="arraybuffer",$.onload=()=>{$.status==200||$.status==0&&$.response?m($.response):g()},$.onerror=g,$.send(null)});var E=console.log.bind(console),P=console.error.bind(console);Object.assign(r,c),c=null;var O,R=!1,L,N,K,Q,he,W,se,Ce,We,ee,ae;function Ae(){var s=O.buffer;r.HEAP8=N=new Int8Array(s),r.HEAP16=Q=new Int16Array(s),r.HEAPU8=K=new Uint8Array(s),r.HEAPU16=he=new Uint16Array(s),r.HEAP32=W=new Int32Array(s),r.HEAPU32=se=new Uint32Array(s),r.HEAPF32=Ce=new Float32Array(s),r.HEAPF64=ae=new Float64Array(s),r.HEAP64=We=new BigInt64Array(s),r.HEAPU64=ee=new BigUint64Array(s)}var me=[],ie=[],ue=[],le=0,qe=null,G=null;function ne(s){throw s="Aborted("+s+")",P(s),R=!0,L=1,s=new WebAssembly.RuntimeError(s+". Build with -sASSERTIONS for more info."),i(s),s}var xe=s=>s.startsWith("data:application/octet-stream;base64,"),Ke=s=>s.startsWith("file://"),Be;if(Be="ort-wasm-simd.wasm",!xe(Be)){var Ge=Be;Be=r.locateFile?r.locateFile(Ge,_):_+Ge}function Ut(s){if(A)return A(s);throw"both async and sync fetching of the wasm failed"}function Ne(s){if(d||y){if(typeof fetch=="function"&&!Ke(s))return fetch(s,{credentials:"same-origin"}).then(m=>{if(!m.ok)throw`failed to load wasm binary file at \'${s}\'`;return m.arrayBuffer()}).catch(()=>Ut(s));if(S)return new Promise((m,g)=>{S(s,$=>m(new Uint8Array($)),g)})}return Promise.resolve().then(()=>Ut(s))}function Ye(s,m,g){return Ne(s).then($=>WebAssembly.instantiate($,m)).then(g,$=>{P(`failed to asynchronously prepare wasm: ${$}`),ne($)})}function mt(s,m){var g=Be;return typeof WebAssembly.instantiateStreaming!="function"||xe(g)||Ke(g)||w||typeof fetch!="function"?Ye(g,s,m):fetch(g,{credentials:"same-origin"}).then($=>WebAssembly.instantiateStreaming($,s).then(m,function(T){return P(`wasm streaming compile failed: ${T}`),P("falling back to ArrayBuffer instantiation"),Ye(g,s,m)}))}var Rt={824920:(s,m,g,$)=>{if(typeof r>"u"||!r.eb)return 1;if(s=je(s>>>0),s.startsWith("./")&&(s=s.substring(2)),s=r.eb.get(s),!s)return 2;if(m>>>=0,g>>>=0,m+g>s.byteLength)return 3;try{return K.set(s.subarray(m,m+g),$>>>0>>>0),0}catch{return 4}},825421:()=>{r.qb()},825452:()=>{r.rb()},825481:()=>{r.vb()},825506:s=>r.pb(s),825539:s=>r.tb(s),825571:(s,m,g)=>{r.lb(s,m,g,!0)},825610:(s,m,g)=>{r.lb(s,m,g)},825643:s=>{r.Ra("Abs",s,void 0)},825694:s=>{r.Ra("Neg",s,void 0)},825745:s=>{r.Ra("Floor",s,void 0)},825798:s=>{r.Ra("Ceil",s,void 0)},825850:s=>{r.Ra("Reciprocal",s,void 0)},825908:s=>{r.Ra("Sqrt",s,void 0)},825960:s=>{r.Ra("Exp",s,void 0)},826011:s=>{r.Ra("Erf",s,void 0)},826062:s=>{r.Ra("Sigmoid",s,void 0)},826117:(s,m,g)=>{r.Ra("HardSigmoid",s,{alpha:m,beta:g})},826196:s=>{r.Ra("Log",s,void 0)},826247:s=>{r.Ra("Sin",s,void 0)},826298:s=>{r.Ra("Cos",s,void 0)},826349:s=>{r.Ra("Tan",s,void 0)},826400:s=>{r.Ra("Asin",s,void 0)},826452:s=>{r.Ra("Acos",s,void 0)},826504:s=>{r.Ra("Atan",s,void 0)},826556:s=>{r.Ra("Sinh",s,void 0)},826608:s=>{r.Ra("Cosh",s,void 0)},826660:s=>{r.Ra("Asinh",s,void 0)},826713:s=>{r.Ra("Acosh",s,void 0)},826766:s=>{r.Ra("Atanh",s,void 0)},826819:s=>{r.Ra("Tanh",s,void 0)},826871:s=>{r.Ra("Not",s,void 0)},826922:(s,m,g)=>{r.Ra("Clip",s,{min:m,max:g})},826991:s=>{r.Ra("Clip",s,void 0)},827043:(s,m)=>{r.Ra("Elu",s,{alpha:m})},827101:s=>{r.Ra("Relu",s,void 0)},827153:(s,m)=>{r.Ra("LeakyRelu",s,{alpha:m})},827217:(s,m)=>{r.Ra("ThresholdedRelu",s,{alpha:m})},827287:(s,m)=>{r.Ra("Cast",s,{to:m})},827345:s=>{r.Ra("Add",s,void 0)},827396:s=>{r.Ra("Sub",s,void 0)},827447:s=>{r.Ra("Mul",s,void 0)},827498:s=>{r.Ra("Div",s,void 0)},827549:s=>{r.Ra("Pow",s,void 0)},827600:s=>{r.Ra("Equal",s,void 0)},827653:s=>{r.Ra("Greater",s,void 0)},827708:s=>{r.Ra("GreaterOrEqual",s,void 0)},827770:s=>{r.Ra("Less",s,void 0)},827822:s=>{r.Ra("LessOrEqual",s,void 0)},827881:(s,m,g,$,T)=>{r.Ra("ReduceMean",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828040:(s,m,g,$,T)=>{r.Ra("ReduceMax",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828198:(s,m,g,$,T)=>{r.Ra("ReduceMin",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828356:(s,m,g,$,T)=>{r.Ra("ReduceProd",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828515:(s,m,g,$,T)=>{r.Ra("ReduceSum",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828673:(s,m,g,$,T)=>{r.Ra("ReduceL1",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828830:(s,m,g,$,T)=>{r.Ra("ReduceL2",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828987:(s,m,g,$,T)=>{r.Ra("ReduceLogSum",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},829148:(s,m,g,$,T)=>{r.Ra("ReduceSumSquare",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},829312:(s,m,g,$,T)=>{r.Ra("ReduceLogSumExp",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},829476:s=>{r.Ra("Where",s,void 0)},829529:(s,m,g)=>{r.Ra("Transpose",s,{perm:m?Array.from(W.subarray(m>>>0,g>>>0)):[]})},829637:(s,m,g,$)=>{r.Ra("DepthToSpace",s,{blocksize:m,mode:je(g),format:$?"NHWC":"NCHW"})},829770:(s,m,g,$)=>{r.Ra("DepthToSpace",s,{blocksize:m,mode:je(g),format:$?"NHWC":"NCHW"})},829903:(s,m,g,$,T,B,H,q,te,X,de,Ee,Oe,D,be)=>{r.Ra("ConvTranspose",s,{format:te?"NHWC":"NCHW",autoPad:m,dilations:[g],group:$,kernelShape:[T],pads:[B,H],strides:[q],wIsConst:()=>!!N[X>>>0],outputPadding:de?Array.from(W.subarray(de>>>0,Ee>>>0)):[],outputShape:Oe?Array.from(W.subarray(Oe>>>0,D>>>0)):[],activation:je(be)})},830304:(s,m,g,$,T,B,H,q,te,X,de,Ee,Oe,D)=>{r.Ra("ConvTranspose",s,{format:q?"NHWC":"NCHW",autoPad:m,dilations:Array.from(W.subarray(g>>>0,(g>>>0)+2>>>0)),group:$,kernelShape:Array.from(W.subarray(T>>>0,(T>>>0)+2>>>0)),pads:Array.from(W.subarray(B>>>0,(B>>>0)+4>>>0)),strides:Array.from(W.subarray(H>>>0,(H>>>0)+2>>>0)),wIsConst:()=>!!N[te>>>0],outputPadding:X?Array.from(W.subarray(X>>>0,de>>>0)):[],outputShape:Ee?Array.from(W.subarray(Ee>>>0,Oe>>>0)):[],activation:je(D)})},830869:(s,m,g,$,T,B,H,q,te,X,de,Ee,Oe,D,be)=>{r.Ra("ConvTranspose",s,{format:te?"NHWC":"NCHW",autoPad:m,dilations:[g],group:$,kernelShape:[T],pads:[B,H],strides:[q],wIsConst:()=>!!N[X>>>0],outputPadding:de?Array.from(W.subarray(de>>>0,Ee>>>0)):[],outputShape:Oe?Array.from(W.subarray(Oe>>>0,D>>>0)):[],activation:je(be)})},831270:(s,m,g,$,T,B,H,q,te,X,de,Ee,Oe,D)=>{r.Ra("ConvTranspose",s,{format:q?"NHWC":"NCHW",autoPad:m,dilations:Array.from(W.subarray(g>>>0,(g>>>0)+2>>>0)),group:$,kernelShape:Array.from(W.subarray(T>>>0,(T>>>0)+2>>>0)),pads:Array.from(W.subarray(B>>>0,(B>>>0)+4>>>0)),strides:Array.from(W.subarray(H>>>0,(H>>>0)+2>>>0)),wIsConst:()=>!!N[te>>>0],outputPadding:X?Array.from(W.subarray(X>>>0,de>>>0)):[],outputShape:Ee?Array.from(W.subarray(Ee>>>0,Oe>>>0)):[],activation:je(D)})},831835:(s,m)=>{r.Ra("GlobalAveragePool",s,{format:m?"NHWC":"NCHW"})},831926:(s,m,g,$,T,B,H,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("AveragePool",s,{format:Ie?"NHWC":"NCHW",auto_pad:m,ceil_mode:g,count_include_pad:$,storage_order:T,dilations:[B,H],kernel_shape:[q,te],pads:[X,de,Ee,Oe],strides:[D,be]})},832210:(s,m)=>{r.Ra("GlobalAveragePool",s,{format:m?"NHWC":"NCHW"})},832301:(s,m,g,$,T,B,H,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("AveragePool",s,{format:Ie?"NHWC":"NCHW",auto_pad:m,ceil_mode:g,count_include_pad:$,storage_order:T,dilations:[B,H],kernel_shape:[q,te],pads:[X,de,Ee,Oe],strides:[D,be]})},832585:(s,m)=>{r.Ra("GlobalMaxPool",s,{format:m?"NHWC":"NCHW"})},832672:(s,m,g,$,T,B,H,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("MaxPool",s,{format:Ie?"NHWC":"NCHW",auto_pad:m,ceil_mode:g,count_include_pad:$,storage_order:T,dilations:[B,H],kernel_shape:[q,te],pads:[X,de,Ee,Oe],strides:[D,be]})},832952:(s,m)=>{r.Ra("GlobalMaxPool",s,{format:m?"NHWC":"NCHW"})},833039:(s,m,g,$,T,B,H,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("MaxPool",s,{format:Ie?"NHWC":"NCHW",auto_pad:m,ceil_mode:g,count_include_pad:$,storage_order:T,dilations:[B,H],kernel_shape:[q,te],pads:[X,de,Ee,Oe],strides:[D,be]})},833319:(s,m,g,$,T)=>{r.Ra("Gemm",s,{alpha:m,beta:g,transA:$,transB:T})},833423:s=>{r.Ra("MatMul",s,void 0)},833477:(s,m,g,$)=>{r.Ra("ArgMax",s,{keepDims:!!m,selectLastIndex:!!g,axis:$})},833585:(s,m,g,$)=>{r.Ra("ArgMin",s,{keepDims:!!m,selectLastIndex:!!g,axis:$})},833693:(s,m)=>{r.Ra("Softmax",s,{axis:m})},833756:(s,m)=>{r.Ra("Concat",s,{axis:m})},833816:(s,m,g,$,T)=>{r.Ra("Split",s,{axis:m,numOutputs:g,splitSizes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},833956:s=>{r.Ra("Expand",s,void 0)},834010:(s,m)=>{r.Ra("Gather",s,{axis:Number(m)})},834081:(s,m)=>{r.Ra("GatherElements",s,{axis:Number(m)})},834160:(s,m,g,$,T,B,H,q,te,X,de)=>{r.Ra("Resize",s,{antialias:m,axes:g?Array.from(W.subarray(g>>>0,$>>>0)):[],coordinateTransformMode:je(T),cubicCoeffA:B,excludeOutside:H,extrapolationValue:q,keepAspectRatioPolicy:je(te),mode:je(X),nearestMode:je(de)})},834506:(s,m,g,$,T,B,H)=>{r.Ra("Slice",s,{starts:m?Array.from(W.subarray(m>>>0,g>>>0)):[],ends:$?Array.from(W.subarray($>>>0,T>>>0)):[],axes:B?Array.from(W.subarray(B>>>0,H>>>0)):[]})},834722:s=>{r.Ra("Tile",s,void 0)},834774:(s,m,g,$)=>{r.Ra("LayerNormalization",s,{axis:m,epsilon:g,simplified:!!$})},834885:(s,m,g)=>{r.Ra("InstanceNormalization",s,{epsilon:m,format:g?"NHWC":"NCHW"})},834999:(s,m,g)=>{r.Ra("InstanceNormalization",s,{epsilon:m,format:g?"NHWC":"NCHW"})},835113:s=>{r.Ra("Range",s,void 0)},835166:(s,m)=>{r.Ra("Einsum",s,{equation:je(m)})},835247:(s,m,g,$,T)=>{r.Ra("Pad",s,{mode:m,value:g,pads:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},835374:(s,m,g,$,T,B)=>{r.Ra("BatchNormalization",s,{epsilon:m,momentum:g,spatial:!!T,trainingMode:!!$,format:B?"NHWC":"NCHW"})},835543:(s,m,g,$,T,B)=>{r.Ra("BatchNormalization",s,{epsilon:m,momentum:g,spatial:!!T,trainingMode:!!$,format:B?"NHWC":"NCHW"})},835712:(s,m,g)=>{r.Ra("CumSum",s,{exclusive:Number(m),reverse:Number(g)})},835809:(s,m,g,$,T,B,H,q,te)=>{r.Ra("Attention",s,{numHeads:m,isUnidirectional:g,maskFilterValue:$,scale:T,doRotary:B,qkvHiddenSizes:H?Array.from(W.subarray(Number(q)>>>0,Number(q)+H>>>0)):[],pastPresentShareBuffer:!!te})},836081:s=>{r.Ra("BiasAdd",s,void 0)},836136:s=>{r.Ra("BiasSplitGelu",s,void 0)},836197:s=>{r.Ra("FastGelu",s,void 0)},836253:(s,m,g,$,T,B,H,q,te,X,de,Ee,Oe)=>{r.Ra("Conv",s,{format:te?"NHWC":"NCHW",auto_pad:m,dilations:[g],group:$,kernel_shape:[T],pads:B?Array.from(W.subarray(B>>>0,H>>>0)):[],strides:[q],w_is_const:()=>!!N[X>>>0],activation:je(de),activation_params:Ee?Array.from(Ce.subarray(Ee>>>0,Oe>>>0)):[]})},836623:(s,m,g,$,T,B,H,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("Conv",s,{format:Ee?"NHWC":"NCHW",auto_pad:m,dilations:[g,$],group:T,kernel_shape:[B,H],pads:q?Array.from(W.subarray(q>>>0,te>>>0)):[],strides:[X,de],w_is_const:()=>!!N[Oe>>>0],activation:je(D),activation_params:be?Array.from(Ce.subarray(be>>>0,Ie>>>0)):[]})},837014:s=>{r.Ra("Gelu",s,void 0)},837066:(s,m,g,$,T,B)=>{r.Ra("MatMulNBits",s,{k:m,n:g,accuracyLevel:$,bits:T,blockSize:B})},837193:(s,m,g,$,T,B)=>{r.Ra("MultiHeadAttention",s,{numHeads:m,isUnidirectional:g,maskFilterValue:$,scale:T,doRotary:B})},837352:(s,m,g,$,T)=>{r.Ra("RotaryEmbedding",s,{interleaved:!!m,numHeads:g,rotaryEmbeddingDim:$,scale:T})},837491:(s,m,g)=>{r.Ra("SkipLayerNormalization",s,{epsilon:m,simplified:!!g})},837593:(s,m,g)=>{r.Ra("SkipLayerNormalization",s,{epsilon:m,simplified:!!g})},837695:(s,m,g,$)=>{r.Ra("LayerNormalization",s,{axis:m,epsilon:g,simplified:!!$})},837806:s=>{r.ub(s)},837840:(s,m)=>r.wb(s,m,r.cb.xb,r.cb.errors)};function qt(s){this.name="ExitStatus",this.message=`Program terminated with exit(${s})`,this.status=s}class Vt{constructor(m){this.hb=m-24}}var sr=0,jt=0,xr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Kt=(s,m,g)=>{m>>>=0;var $=m+g;for(g=m;s[g]&&!(g>=$);)++g;if(16<g-m&&s.buffer&&xr)return xr.decode(s.subarray(m,g));for($="";m<g;){var T=s[m++];if(T&128){var B=s[m++]&63;if((T&224)==192)$+=String.fromCharCode((T&31)<<6|B);else{var H=s[m++]&63;T=(T&240)==224?(T&15)<<12|B<<6|H:(T&7)<<18|B<<12|H<<6|s[m++]&63,65536>T?$+=String.fromCharCode(T):(T-=65536,$+=String.fromCharCode(55296|T>>10,56320|T&1023))}}else $+=String.fromCharCode(T)}return $},je=(s,m)=>(s>>>=0)?Kt(K,s,m):"",Wt=s=>{for(var m=0,g=0;g<s.length;++g){var $=s.charCodeAt(g);127>=$?m++:2047>=$?m+=2:55296<=$&&57343>=$?(m+=4,++g):m+=3}return m},at=(s,m,g,$)=>{if(g>>>=0,!(0<$))return 0;var T=g;$=g+$-1;for(var B=0;B<s.length;++B){var H=s.charCodeAt(B);if(55296<=H&&57343>=H){var q=s.charCodeAt(++B);H=65536+((H&1023)<<10)|q&1023}if(127>=H){if(g>=$)break;m[g++>>>0]=H}else{if(2047>=H){if(g+1>=$)break;m[g++>>>0]=192|H>>6}else{if(65535>=H){if(g+2>=$)break;m[g++>>>0]=224|H>>12}else{if(g+3>=$)break;m[g++>>>0]=240|H>>18,m[g++>>>0]=128|H>>12&63}m[g++>>>0]=128|H>>6&63}m[g++>>>0]=128|H&63}}return m[g>>>0]=0,g-T},Cr,ft=s=>{for(var m="";K[s>>>0];)m+=Cr[K[s++>>>0]];return m},ur={},Ar={},Ir={},st;function Tr(s,m,g={}){var $=m.name;if(!s)throw new st(`type "${$}" must have a positive integer typeid pointer`);if(Ar.hasOwnProperty(s)){if(g.nb)return;throw new st(`Cannot register type \'${$}\' twice`)}Ar[s]=m,delete Ir[s],ur.hasOwnProperty(s)&&(m=ur[s],delete ur[s],m.forEach(T=>T()))}function ht(s,m,g={}){if(!("argPackAdvance"in m))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Tr(s,m,g)}var bt=(s,m,g)=>{switch(m){case 1:return g?$=>N[$>>>0]:$=>K[$>>>0];case 2:return g?$=>Q[$>>>1>>>0]:$=>he[$>>>1>>>0];case 4:return g?$=>W[$>>>2>>>0]:$=>se[$>>>2>>>0];case 8:return g?$=>We[$>>>3]:$=>ee[$>>>3];default:throw new TypeError(`invalid integer width (${m}): ${s}`)}},Er=[],Te=[];function dr(s){s>>>=0,9<s&&--Te[s+1]===0&&(Te[s]=void 0,Er.push(s))}var Xe=s=>{if(!s)throw new st("Cannot use deleted val. handle = "+s);return Te[s]},ut=s=>{switch(s){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let m=Er.pop()||Te.length;return Te[m]=s,Te[m+1]=1,m}};function lr(s){return this.fromWireType(se[s>>>2>>>0])}var Fn={name:"emscripten::val",fromWireType:s=>{var m=Xe(s);return dr(s),m},toWireType:(s,m)=>ut(m),argPackAdvance:8,readValueFromPointer:lr,bb:null},ge=(s,m)=>{switch(m){case 4:return function(g){return this.fromWireType(Ce[g>>>2>>>0])};case 8:return function(g){return this.fromWireType(ae[g>>>3>>>0])};default:throw new TypeError(`invalid float width (${m}): ${s}`)}},Yt=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,jr=(s,m)=>{for(var g=s>>1,$=g+m/2;!(g>=$)&&he[g>>>0];)++g;if(g<<=1,32<g-s&&Yt)return Yt.decode(K.subarray(s>>>0,g>>>0));for(g="",$=0;!($>=m/2);++$){var T=Q[s+2*$>>>1>>>0];if(T==0)break;g+=String.fromCharCode(T)}return g},qn=(s,m,g)=>{if(g??=2147483647,2>g)return 0;g-=2;var $=m;g=g<2*s.length?g/2:s.length;for(var T=0;T<g;++T)Q[m>>>1>>>0]=s.charCodeAt(T),m+=2;return Q[m>>>1>>>0]=0,m-$},Kr=s=>2*s.length,jn=(s,m)=>{for(var g=0,$="";!(g>=m/4);){var T=W[s+4*g>>>2>>>0];if(T==0)break;++g,65536<=T?(T-=65536,$+=String.fromCharCode(55296|T>>10,56320|T&1023)):$+=String.fromCharCode(T)}return $},Yr=(s,m,g)=>{if(m>>>=0,g??=2147483647,4>g)return 0;var $=m;g=$+g-4;for(var T=0;T<s.length;++T){var B=s.charCodeAt(T);if(55296<=B&&57343>=B){var H=s.charCodeAt(++T);B=65536+((B&1023)<<10)|H&1023}if(W[m>>>2>>>0]=B,m+=4,m+4>g)break}return W[m>>>2>>>0]=0,m-$},Zr=s=>{for(var m=0,g=0;g<s.length;++g){var $=s.charCodeAt(g);55296<=$&&57343>=$&&++g,m+=4}return m},cr=(s,m)=>{var g=Ar[s];if(g===void 0)throw s=Mr(s),g=ft(s),rt(s),new st(`${m} has unknown type ${g}`);return g},Pr=(s,m,g)=>{var $=[];return s=s.toWireType($,g),$.length&&(se[m>>>2>>>0]=ut($)),s},He=s=>{try{s()}catch(m){ne(m)}},Xr=s=>{if(!R)try{s();try{L=L=s=L,r.onExit?.(s),R=!0,h(s,new qt(s))}catch(m){m instanceof qt||m=="unwind"||h(1,m)}}catch(m){m instanceof qt||m=="unwind"||h(1,m)}};function Qr(){var s=pe,m={};for(let[g,$]of Object.entries(s))m[g]=typeof $=="function"?(...T)=>{Zt.push(g);try{return $(...T)}finally{R||(Zt.pop(),dt&&gt===1&&Zt.length===0&&(gt=0,He(dn),typeof Fibers<"u"&&Fibers.Db()))}}:$;return m}var gt=0,dt=null,Bt=0,Zt=[],kr={},Or={},Jr=0,pr=null,en=[];function tn(){return new Promise((s,m)=>{pr={resolve:s,reject:m}})}function rn(){var s=Nt(65548),m=s+12;se[s>>>2>>>0]=m,se[s+4>>>2>>>0]=m+65536,m=Zt[0];var g=kr[m];return g===void 0&&(g=Jr++,kr[m]=g,Or[g]=m),W[s+8>>>2>>>0]=g,s}function nn(s){if(!R){if(gt===0){var m=!1,g=!1;s(($=0)=>{if(!R&&(Bt=$,m=!0,g)){gt=2,He(()=>vt(dt)),typeof Browser<"u"&&Browser.ib.mb&&Browser.ib.resume(),$=!1;try{var T=(0,pe[Or[W[dt+8>>>2>>>0]]])()}catch(q){T=q,$=!0}var B=!1;if(!dt){var H=pr;H&&(pr=null,($?H.reject:H.resolve)(T),B=!0)}if($&&!B)throw T}}),g=!0,m||(gt=1,dt=rn(),typeof Browser<"u"&&Browser.ib.mb&&Browser.ib.pause(),He(()=>Jt(dt)))}else gt===2?(gt=0,He(ct),rt(dt),dt=null,en.forEach(Xr)):ne(`invalid state: ${gt}`);return Bt}}function Rr(s){return nn(m=>{s().then(m)})}var Xt=[],on={},nt=s=>{var m=on[s];return m===void 0?ft(s):m},mr=()=>typeof globalThis=="object"?globalThis:Function("return this")(),Br=s=>{var m=Xt.length;return Xt.push(s),m},Kn=(s,m)=>{for(var g=Array(s),$=0;$<s;++$)g[$]=cr(se[m+4*$>>>2>>>0],"parameter "+$);return g},wt=(s,m)=>Object.defineProperty(m,"name",{value:s});function Yn(s){var m=Function;if(!(m instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof m} which is not a function`);var g=wt(m.name||"unknownFunctionName",function(){});return g.prototype=m.prototype,g=new g,s=m.apply(g,s),s instanceof Object?s:g}var Je=s=>s%4===0&&(s%100!==0||s%400===0),Dr=[0,31,60,91,121,152,182,213,244,274,305,335],fr=[0,31,59,90,120,151,181,212,243,273,304,334],lt=[],hr=(s,m)=>{lt.length=0;for(var g;g=K[s++>>>0];){var $=g!=105;$&=g!=112,m+=$&&m%8?4:0,lt.push(g==112?se[m>>>2>>>0]:g==106?We[m>>>3]:g==105?W[m>>>2>>>0]:ae[m>>>3>>>0]),m+=$?8:4}return lt},Qe={},ot=()=>{if(!Qt){var s={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"},m;for(m in Qe)Qe[m]===void 0?delete s[m]:s[m]=Qe[m];var g=[];for(m in s)g.push(`${m}=${s[m]}`);Qt=g}return Qt},Qt,Zn=[null,[],[]],an=[31,29,31,30,31,30,31,31,30,31,30,31],zr=[31,28,31,30,31,30,31,31,30,31,30,31];function Xn(s){var m=Array(Wt(s)+1);return at(s,m,0,m.length),m}function sn(s,m,g,$){function T(D,be,Ie){for(D=typeof D=="number"?D.toString():D||"";D.length<be;)D=Ie[0]+D;return D}function B(D,be){return T(D,be,"0")}function H(D,be){function Ie(Mt){return 0>Mt?-1:0<Mt?1:0}var zt;return(zt=Ie(D.getFullYear()-be.getFullYear()))===0&&(zt=Ie(D.getMonth()-be.getMonth()))===0&&(zt=Ie(D.getDate()-be.getDate())),zt}function q(D){switch(D.getDay()){case 0:return new Date(D.getFullYear()-1,11,29);case 1:return D;case 2:return new Date(D.getFullYear(),0,3);case 3:return new Date(D.getFullYear(),0,2);case 4:return new Date(D.getFullYear(),0,1);case 5:return new Date(D.getFullYear()-1,11,31);case 6:return new Date(D.getFullYear()-1,11,30)}}function te(D){var be=D.$a;for(D=new Date(new Date(D.ab+1900,0,1).getTime());0<be;){var Ie=D.getMonth(),zt=(Je(D.getFullYear())?an:zr)[Ie];if(be>zt-D.getDate())be-=zt-D.getDate()+1,D.setDate(1),11>Ie?D.setMonth(Ie+1):(D.setMonth(0),D.setFullYear(D.getFullYear()+1));else{D.setDate(D.getDate()+be);break}}return Ie=new Date(D.getFullYear()+1,0,4),be=q(new Date(D.getFullYear(),0,4)),Ie=q(Ie),0>=H(be,D)?0>=H(Ie,D)?D.getFullYear()+1:D.getFullYear():D.getFullYear()-1}s>>>=0,m>>>=0,g>>>=0,$>>>=0;var X=se[$+40>>>2>>>0];$={Ab:W[$>>>2>>>0],zb:W[$+4>>>2>>>0],fb:W[$+8>>>2>>>0],jb:W[$+12>>>2>>>0],gb:W[$+16>>>2>>>0],ab:W[$+20>>>2>>>0],Va:W[$+24>>>2>>>0],$a:W[$+28>>>2>>>0],Cb:W[$+32>>>2>>>0],yb:W[$+36>>>2>>>0],Bb:X?je(X):""},g=je(g),X={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var de in X)g=g.replace(new RegExp(de,"g"),X[de]);var Ee="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Oe="January February March April May June July August September October November December".split(" ");X={"%a":D=>Ee[D.Va].substring(0,3),"%A":D=>Ee[D.Va],"%b":D=>Oe[D.gb].substring(0,3),"%B":D=>Oe[D.gb],"%C":D=>B((D.ab+1900)/100|0,2),"%d":D=>B(D.jb,2),"%e":D=>T(D.jb,2," "),"%g":D=>te(D).toString().substring(2),"%G":te,"%H":D=>B(D.fb,2),"%I":D=>(D=D.fb,D==0?D=12:12<D&&(D-=12),B(D,2)),"%j":D=>{for(var be=0,Ie=0;Ie<=D.gb-1;be+=(Je(D.ab+1900)?an:zr)[Ie++]);return B(D.jb+be,3)},"%m":D=>B(D.gb+1,2),"%M":D=>B(D.zb,2),"%n":()=>`\n`,"%p":D=>0<=D.fb&&12>D.fb?"AM":"PM","%S":D=>B(D.Ab,2),"%t":()=>"	","%u":D=>D.Va||7,"%U":D=>B(Math.floor((D.$a+7-D.Va)/7),2),"%V":D=>{var be=Math.floor((D.$a+7-(D.Va+6)%7)/7);if(2>=(D.Va+371-D.$a-2)%7&&be++,be)be==53&&(Ie=(D.Va+371-D.$a)%7,Ie==4||Ie==3&&Je(D.ab)||(be=1));else{be=52;var Ie=(D.Va+7-D.$a-1)%7;(Ie==4||Ie==5&&Je(D.ab%400-1))&&be++}return B(be,2)},"%w":D=>D.Va,"%W":D=>B(Math.floor((D.$a+7-(D.Va+6)%7)/7),2),"%y":D=>(D.ab+1900).toString().substring(2),"%Y":D=>D.ab+1900,"%z":D=>{D=D.yb;var be=0<=D;return D=Math.abs(D)/60,(be?"+":"-")+("0000"+(D/60*100+D%60)).slice(-4)},"%Z":D=>D.Bb,"%%":()=>"%"},g=g.replace(/%%/g,"\\0\\0");for(de in X)g.includes(de)&&(g=g.replace(new RegExp(de,"g"),X[de]($)));return g=g.replace(/\\0\\0/g,"%"),de=Xn(g),de.length>m?0:(N.set(de,s>>>0),de.length-1)}for(var un=Array(256),gr=0;256>gr;++gr)un[gr]=String.fromCharCode(gr);Cr=un,st=r.BindingError=class extends Error{constructor(s){super(s),this.name="BindingError"}},r.InternalError=class extends Error{constructor(s){super(s),this.name="InternalError"}},Te.push(0,1,void 0,1,null,1,!0,1,!1,1),r.count_emval_handles=()=>Te.length/2-5-Er.length;var Qn={ia:function(s,m,g){return Rr(async()=>{await r.sb(s,m,g)})},a:function(s,m,g){s>>>=0;var $=new Vt(s);throw se[$.hb+16>>>2>>>0]=0,se[$.hb+4>>>2>>>0]=m>>>0,se[$.hb+8>>>2>>>0]=g>>>0,sr=s,jt++,sr},y:function(){return 0},ea:function(){},R:function(){},T:function(){},ga:function(){return 0},ca:function(){},Z:function(){},ba:function(){},G:function(){},S:function(){},P:function(){},da:function(){},Q:function(){},C:function(s,m,g){m=ft(m>>>0),ht(s>>>0,{name:m,fromWireType:$=>$,toWireType:function($,T){if(typeof T!="bigint"&&typeof T!="number")throw T===null?T="null":($=typeof T,T=$==="object"||$==="array"||$==="function"?T.toString():""+T),new TypeError(`Cannot convert "${T}" to ${this.name}`);return typeof T=="number"&&(T=BigInt(T)),T},argPackAdvance:8,readValueFromPointer:bt(m,g>>>0,m.indexOf("u")==-1),bb:null})},K:function(s,m,g,$){m=ft(m>>>0),ht(s>>>0,{name:m,fromWireType:function(T){return!!T},toWireType:function(T,B){return B?g:$},argPackAdvance:8,readValueFromPointer:function(T){return this.fromWireType(K[T>>>0])},bb:null})},J:function(s){return ht(s>>>0,Fn)},B:function(s,m,g){m=ft(m>>>0),ht(s>>>0,{name:m,fromWireType:$=>$,toWireType:($,T)=>T,argPackAdvance:8,readValueFromPointer:ge(m,g>>>0),bb:null})},s:function(s,m,g,$,T){if(s>>>=0,g>>>=0,m=ft(m>>>0),T===-1&&(T=4294967295),T=q=>q,$===0){var B=32-8*g;T=q=>q<<B>>>B}var H=m.includes("unsigned")?function(q,te){return te>>>0}:function(q,te){return te};ht(s,{name:m,fromWireType:T,toWireType:H,argPackAdvance:8,readValueFromPointer:bt(m,g,$!==0),bb:null})},o:function(s,m,g){function $(B){return new T(N.buffer,se[B+4>>>2>>>0],se[B>>>2>>>0])}var T=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][m];g=ft(g>>>0),ht(s>>>0,{name:g,fromWireType:$,argPackAdvance:8,readValueFromPointer:$},{nb:!0})},D:function(s,m){m=ft(m>>>0);var g=m==="std::string";ht(s>>>0,{name:m,fromWireType:function($){var T=se[$>>>2>>>0],B=$+4;if(g)for(var H=B,q=0;q<=T;++q){var te=B+q;if(q==T||K[te>>>0]==0){if(H=je(H,te-H),X===void 0)var X=H;else X+=String.fromCharCode(0),X+=H;H=te+1}}else{for(X=Array(T),q=0;q<T;++q)X[q]=String.fromCharCode(K[B+q>>>0]);X=X.join("")}return rt($),X},toWireType:function($,T){T instanceof ArrayBuffer&&(T=new Uint8Array(T));var B=typeof T=="string";if(!(B||T instanceof Uint8Array||T instanceof Uint8ClampedArray||T instanceof Int8Array))throw new st("Cannot pass non-string to std::string");var H=g&&B?Wt(T):T.length,q=Nt(4+H+1),te=q+4;if(se[q>>>2>>>0]=H,g&&B)at(T,K,te,H+1);else if(B)for(B=0;B<H;++B){var X=T.charCodeAt(B);if(255<X)throw rt(te),new st("String has UTF-16 code units that do not fit in 8 bits");K[te+B>>>0]=X}else for(B=0;B<H;++B)K[te+B>>>0]=T[B];return $!==null&&$.push(rt,q),q},argPackAdvance:8,readValueFromPointer:lr,bb($){rt($)}})},x:function(s,m,g){if(m>>>=0,g>>>=0,g=ft(g),m===2)var $=jr,T=qn,B=Kr,H=q=>he[q>>>1>>>0];else m===4&&($=jn,T=Yr,B=Zr,H=q=>se[q>>>2>>>0]);ht(s>>>0,{name:g,fromWireType:q=>{for(var te=se[q>>>2>>>0],X,de=q+4,Ee=0;Ee<=te;++Ee){var Oe=q+4+Ee*m;(Ee==te||H(Oe)==0)&&(de=$(de,Oe-de),X===void 0?X=de:(X+=String.fromCharCode(0),X+=de),de=Oe+m)}return rt(q),X},toWireType:(q,te)=>{if(typeof te!="string")throw new st(`Cannot pass non-string to C++ string type ${g}`);var X=B(te),de=Nt(4+X+m);return se[de>>>2>>>0]=X/m,T(te,de+4,X+m),q!==null&&q.push(rt,de),de},argPackAdvance:8,readValueFromPointer:lr,bb(q){rt(q)}})},L:function(s,m){m=ft(m>>>0),ht(s>>>0,{ob:!0,name:m,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},ha:()=>1,u:function(s,m,g){return m>>>=0,g>>>=0,s=Xe(s>>>0),m=cr(m,"emval::as"),Pr(m,g,s)},w:function(s){return s>>>=0,Rr(()=>(s=Xe(s),s.then(ut)))},n:function(s,m,g,$){return g>>>=0,$>>>=0,s=Xt[s>>>0],m=Xe(m>>>0),s(null,m,g,$)},j:function(s,m,g,$,T){return g>>>=0,$>>>=0,T>>>=0,s=Xt[s>>>0],m=Xe(m>>>0),g=nt(g),s(m,m[g],$,T)},b:dr,A:function(s,m){return m>>>=0,s=Xe(s>>>0),m=Xe(m),s==m},m:function(s){return s>>>=0,s===0?ut(mr()):(s=nt(s),ut(mr()[s]))},i:function(s,m,g){m=Kn(s,m>>>0);var $=m.shift();s--;var T=`return function (obj, func, destructorsRef, args) {\n`,B=0,H=[];g===0&&H.push("obj");for(var q=["retType"],te=[$],X=0;X<s;++X)H.push("arg"+X),q.push("argType"+X),te.push(m[X]),T+=`  var arg${X} = argType${X}.readValueFromPointer(args${B?"+"+B:""});\n`,B+=m[X].argPackAdvance;return T+=`  var rv = ${g===1?"new func":"func.call"}(${H.join(", ")});\n`,$.ob||(q.push("emval_returnValue"),te.push(Pr),T+=`  return emval_returnValue(retType, destructorsRef, rv);\n`),q.push(T+`};\n`),s=Yn(q)(...te),g=`methodCaller<(${m.map(de=>de.name).join(", ")}) => ${$.name}>`,Br(wt(g,s))},r:function(s,m){return m>>>=0,s=Xe(s>>>0),m=Xe(m),ut(s[m])},e:function(s){s>>>=0,9<s&&(Te[s+1]+=1)},t:function(){return ut([])},l:function(s){s=Xe(s>>>0);for(var m=Array(s.length),g=0;g<s.length;g++)m[g]=s[g];return ut(m)},f:function(s){return ut(nt(s>>>0))},k:function(){return ut({})},h:function(s){s>>>=0;for(var m=Xe(s);m.length;){var g=m.pop();m.pop()(g)}dr(s)},g:function(s,m,g){m>>>=0,g>>>=0,s=Xe(s>>>0),m=Xe(m),g=Xe(g),s[m]=g},c:function(s,m){return m>>>=0,s=cr(s>>>0,"_emval_take_value"),s=s.readValueFromPointer(m),ut(s)},W:function(s,m){s=-9007199254740992>s||9007199254740992<s?NaN:Number(s),m>>>=0,s=new Date(1e3*s),W[m>>>2>>>0]=s.getUTCSeconds(),W[m+4>>>2>>>0]=s.getUTCMinutes(),W[m+8>>>2>>>0]=s.getUTCHours(),W[m+12>>>2>>>0]=s.getUTCDate(),W[m+16>>>2>>>0]=s.getUTCMonth(),W[m+20>>>2>>>0]=s.getUTCFullYear()-1900,W[m+24>>>2>>>0]=s.getUTCDay(),W[m+28>>>2>>>0]=(s.getTime()-Date.UTC(s.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},X:function(s,m){s=-9007199254740992>s||9007199254740992<s?NaN:Number(s),m>>>=0,s=new Date(1e3*s),W[m>>>2>>>0]=s.getSeconds(),W[m+4>>>2>>>0]=s.getMinutes(),W[m+8>>>2>>>0]=s.getHours(),W[m+12>>>2>>>0]=s.getDate(),W[m+16>>>2>>>0]=s.getMonth(),W[m+20>>>2>>>0]=s.getFullYear()-1900,W[m+24>>>2>>>0]=s.getDay(),W[m+28>>>2>>>0]=(Je(s.getFullYear())?Dr:fr)[s.getMonth()]+s.getDate()-1|0,W[m+36>>>2>>>0]=-(60*s.getTimezoneOffset());var g=new Date(s.getFullYear(),6,1).getTimezoneOffset(),$=new Date(s.getFullYear(),0,1).getTimezoneOffset();W[m+32>>>2>>>0]=(g!=$&&s.getTimezoneOffset()==Math.min($,g))|0},Y:function(s){s>>>=0;var m=new Date(W[s+20>>>2>>>0]+1900,W[s+16>>>2>>>0],W[s+12>>>2>>>0],W[s+8>>>2>>>0],W[s+4>>>2>>>0],W[s>>>2>>>0],0),g=W[s+32>>>2>>>0],$=m.getTimezoneOffset(),T=new Date(m.getFullYear(),6,1).getTimezoneOffset(),B=new Date(m.getFullYear(),0,1).getTimezoneOffset(),H=Math.min(B,T);return 0>g?W[s+32>>>2>>>0]=+(T!=B&&H==$):0<g!=(H==$)&&(T=Math.max(B,T),m.setTime(m.getTime()+6e4*((0<g?H:T)-$))),W[s+24>>>2>>>0]=m.getDay(),W[s+28>>>2>>>0]=(Je(m.getFullYear())?Dr:fr)[m.getMonth()]+m.getDate()-1|0,W[s>>>2>>>0]=m.getSeconds(),W[s+4>>>2>>>0]=m.getMinutes(),W[s+8>>>2>>>0]=m.getHours(),W[s+12>>>2>>>0]=m.getDate(),W[s+16>>>2>>>0]=m.getMonth(),W[s+20>>>2>>>0]=m.getYear(),s=m.getTime(),BigInt(isNaN(s)?-1:s/1e3)},U:function(){return-52},V:function(){},N:function(s,m,g,$){g>>>=0,$>>>=0;var T=new Date().getFullYear(),B=new Date(T,0,1),H=new Date(T,6,1);T=B.getTimezoneOffset();var q=H.getTimezoneOffset();se[s>>>0>>>2>>>0]=60*Math.max(T,q),W[m>>>0>>>2>>>0]=+(T!=q),s=te=>te.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],B=s(B),H=s(H),q<T?(at(B,K,g,17),at(H,K,$,17)):(at(B,K,$,17),at(H,K,g,17))},v:()=>{ne("")},d:function(s,m,g){return s>>>=0,m=hr(m>>>0,g>>>0),Rt[s](...m)},I:function(s,m,g){return s>>>=0,m=hr(m>>>0,g>>>0),Rt[s](...m)},H:()=>Date.now(),O:function(){return 4294901760},q:()=>performance.now(),M:function(s){s>>>=0;var m=K.length;if(4294901760<s)return!1;for(var g=1;4>=g;g*=2){var $=m*(1+.2/g);$=Math.min($,s+100663296);var T=Math;$=Math.max(s,$);e:{T=(T.min.call(T,4294901760,$+(65536-$%65536)%65536)-O.buffer.byteLength+65535)/65536;try{O.grow(T),Ae();var B=1;break e}catch{}B=void 0}if(B)return!0}return!1},$:function(s,m){s>>>=0,m>>>=0;var g=0;return ot().forEach(($,T)=>{var B=m+g;for(T=se[s+4*T>>>2>>>0]=B,B=0;B<$.length;++B)N[T++>>>0]=$.charCodeAt(B);N[T>>>0]=0,g+=$.length+1}),0},aa:function(s,m){s>>>=0,m>>>=0;var g=ot();se[s>>>2>>>0]=g.length;var $=0;return g.forEach(T=>$+=T.length+1),se[m>>>2>>>0]=$,0},z:()=>52,F:function(){return 52},_:function(){return 70},E:function(s,m,g,$){m>>>=0,g>>>=0,$>>>=0;for(var T=0,B=0;B<g;B++){var H=se[m>>>2>>>0],q=se[m+4>>>2>>>0];m+=8;for(var te=0;te<q;te++){var X=K[H+te>>>0],de=Zn[s];X===0||X===10?((s===1?E:P)(Kt(de,0)),de.length=0):de.push(X)}T+=q}return se[$>>>2>>>0]=T,0},fa:sn,p:function(s,m,g,$){return sn(s>>>0,m>>>0,g>>>0,$>>>0)}},pe=function(){function s(g){return pe=g.exports,pe=Qr(),pe=ln(),O=pe.ja,Ae(),ie.unshift(pe.ka),le--,le==0&&(qe!==null&&(clearInterval(qe),qe=null),G&&(g=G,G=null,g())),pe}var m={a:Qn};if(le++,r.instantiateWasm)try{return r.instantiateWasm(m,s)}catch(g){P(`Module.instantiateWasm callback failed with error: ${g}`),i(g)}return mt(m,function(g){s(g.instance)}).catch(i),{}}(),Mr=s=>(Mr=pe.la)(s);r._OrtInit=(s,m)=>(r._OrtInit=pe.ma)(s,m),r._OrtGetLastError=(s,m)=>(r._OrtGetLastError=pe.na)(s,m),r._OrtCreateSessionOptions=(s,m,g,$,T,B,H,q,te,X)=>(r._OrtCreateSessionOptions=pe.oa)(s,m,g,$,T,B,H,q,te,X),r._OrtAppendExecutionProvider=(s,m)=>(r._OrtAppendExecutionProvider=pe.pa)(s,m),r._OrtAddFreeDimensionOverride=(s,m,g)=>(r._OrtAddFreeDimensionOverride=pe.qa)(s,m,g),r._OrtAddSessionConfigEntry=(s,m,g)=>(r._OrtAddSessionConfigEntry=pe.ra)(s,m,g),r._OrtReleaseSessionOptions=s=>(r._OrtReleaseSessionOptions=pe.sa)(s),r._OrtCreateSession=(s,m,g)=>(r._OrtCreateSession=pe.ta)(s,m,g),r._OrtReleaseSession=s=>(r._OrtReleaseSession=pe.ua)(s),r._OrtGetInputOutputCount=(s,m,g)=>(r._OrtGetInputOutputCount=pe.va)(s,m,g),r._OrtGetInputName=(s,m)=>(r._OrtGetInputName=pe.wa)(s,m),r._OrtGetOutputName=(s,m)=>(r._OrtGetOutputName=pe.xa)(s,m),r._OrtFree=s=>(r._OrtFree=pe.ya)(s),r._OrtCreateTensor=(s,m,g,$,T,B)=>(r._OrtCreateTensor=pe.za)(s,m,g,$,T,B),r._OrtGetTensorData=(s,m,g,$,T)=>(r._OrtGetTensorData=pe.Aa)(s,m,g,$,T),r._OrtReleaseTensor=s=>(r._OrtReleaseTensor=pe.Ba)(s),r._OrtCreateRunOptions=(s,m,g,$)=>(r._OrtCreateRunOptions=pe.Ca)(s,m,g,$),r._OrtAddRunConfigEntry=(s,m,g)=>(r._OrtAddRunConfigEntry=pe.Da)(s,m,g),r._OrtReleaseRunOptions=s=>(r._OrtReleaseRunOptions=pe.Ea)(s),r._OrtCreateBinding=s=>(r._OrtCreateBinding=pe.Fa)(s),r._OrtBindInput=(s,m,g)=>(r._OrtBindInput=pe.Ga)(s,m,g),r._OrtBindOutput=(s,m,g,$)=>(r._OrtBindOutput=pe.Ha)(s,m,g,$),r._OrtClearBoundOutputs=s=>(r._OrtClearBoundOutputs=pe.Ia)(s),r._OrtReleaseBinding=s=>(r._OrtReleaseBinding=pe.Ja)(s),r._OrtRunWithBinding=(s,m,g,$,T)=>(r._OrtRunWithBinding=pe.Ka)(s,m,g,$,T),r._OrtRun=(s,m,g,$,T,B,H,q)=>(r._OrtRun=pe.La)(s,m,g,$,T,B,H,q),r._OrtEndProfiling=s=>(r._OrtEndProfiling=pe.Ma)(s),r._JsepOutput=(s,m,g)=>(r._JsepOutput=pe.Na)(s,m,g),r._JsepGetNodeName=s=>(r._JsepGetNodeName=pe.Oa)(s);var Nt=r._malloc=s=>(Nt=r._malloc=pe.Pa)(s),rt=r._free=s=>(rt=r._free=pe.Qa)(s),yr=s=>(yr=pe.Sa)(s),br=s=>(br=pe.Ta)(s),Ur=()=>(Ur=pe.Ua)(),Jt=s=>(Jt=pe.Wa)(s),dn=()=>(dn=pe.Xa)(),vt=s=>(vt=pe.Ya)(s),ct=()=>(ct=pe.Za)();r.___start_em_js=837952,r.___stop_em_js=838113;function ln(){var s=pe;s=Object.assign({},s);var m=g=>$=>g($)>>>0;return s.la=m(s.la),s.Pa=m(s.Pa),s.Ta=m(s.Ta),s.Ua=(g=>()=>g()>>>0)(s.Ua),s}r.stackSave=()=>Ur(),r.stackRestore=s=>yr(s),r.stackAlloc=s=>br(s),r.UTF8ToString=je,r.stringToUTF8=(s,m,g)=>at(s,K,m,g),r.lengthBytesUTF8=Wt;var Dt;G=function s(){Dt||Vr(),Dt||(G=s)};function Vr(){if(!(0<le)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;){var s=r.preRun.shift();me.unshift(s)}for(;0<me.length;)me.shift()(r);if(!(0<le||Dt||(Dt=!0,r.calledRun=!0,R))){for(;0<ie.length;)ie.shift()(r);for(o(r);0<ue.length;)ue.shift()(r)}}}return Vr(),u}})();typeof Ti=="object"&&typeof po=="object"?po.exports=Ii:typeof define=="function"&&define.amd&&define([],()=>Ii)});var Pi=Wr(()=>{});var ki=Wr(()=>{});var Oi={};gn(Oi,{cpus:()=>ll});var ll,Ri=Y(()=>{ll=void 0});var zi=Wr((Di,mo)=>{"use strict";var Bi=(()=>{var e=typeof document<"u"?document.currentScript?.src:void 0;return typeof __filename<"u"&&(e||=__filename),function(t={}){function r(){return ae.buffer!=ue.buffer&&Ne(),ue}function o(){return ae.buffer!=ue.buffer&&Ne(),le}function i(){return ae.buffer!=ue.buffer&&Ne(),qe}function u(){return ae.buffer!=ue.buffer&&Ne(),G}function a(){return ae.buffer!=ue.buffer&&Ne(),ne}function c(){return ae.buffer!=ue.buffer&&Ne(),xe}function p(){return ae.buffer!=ue.buffer&&Ne(),Ke}function h(){return ae.buffer!=ue.buffer&&Ne(),Ut}var d=t,y,w,_=new Promise((n,l)=>{y=n,w=l});d.mountExternalData=(n,l)=>{(d.Db||(d.Db=new Map)).set(n,l)},d.unmountExternalData=()=>{delete d.Db};let v=()=>{let n=(f,b,C)=>(...k)=>{let V=ct,F=b?.();k=f(...k);let re=b?.();return F!==re&&(f=re,C(F),b=C=null),ct!=V?T():k},l=f=>async(...b)=>{try{if(d.Cb)throw Error("Session already started");let C=d.Cb={ec:b[0],errors:[]},k=await f(...b);if(d.Cb!==C)throw Error("Session mismatch");d.Kb?.flush();let V=C.errors;if(0<V.length){let F=await Promise.all(V);if(F=F.filter(re=>re),0<F.length)throw Error(F.join(`\n`))}return k}finally{d.Cb=null}};d._OrtCreateSession=n(d._OrtCreateSession,()=>d._OrtCreateSession,f=>d._OrtCreateSession=f),d._OrtRun=l(n(d._OrtRun,()=>d._OrtRun,f=>d._OrtRun=f)),d._OrtRunWithBinding=l(n(d._OrtRunWithBinding,()=>d._OrtRunWithBinding,f=>d._OrtRunWithBinding=f)),d._OrtBindInput=n(d._OrtBindInput,()=>d._OrtBindInput,f=>d._OrtBindInput=f),v=void 0};d.jsepInit=(n,l)=>{if(v?.(),n==="webgpu"){[d.Kb,d.Wb,d.$b,d.Lb,d.Zb,d.ob,d.ac,d.cc,d.Xb,d.Yb,d.bc]=l;let f=d.Kb;d.jsepRegisterBuffer=(b,C,k,V)=>f.registerBuffer(b,C,k,V),d.jsepGetBuffer=b=>f.getBuffer(b),d.jsepCreateDownloader=(b,C,k)=>f.createDownloader(b,C,k),d.jsepOnReleaseSession=b=>{f.onReleaseSession(b)},d.jsepOnRunStart=b=>f.onRunStart(b)}};var S=Object.assign({},d),A="./this.program",I=(n,l)=>{throw l},x=typeof window=="object",E=typeof importScripts=="function",P=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",O=d.ENVIRONMENT_IS_PTHREAD||!1,R="";function L(n){return d.locateFile?d.locateFile(n,R):R+n}var N,K,Q;if(P){var he=(uo(),wr(so)),W=(co(),wr(lo));R=E?W.dirname(R)+"/":__dirname+"/",N=(n,l)=>(n=Wt(n)?new URL(n):W.normalize(n),he.readFileSync(n,l?void 0:"utf8")),Q=n=>(n=N(n,!0),n.buffer||(n=new Uint8Array(n)),n),K=(n,l,f,b=!0)=>{n=Wt(n)?new URL(n):W.normalize(n),he.readFile(n,b?void 0:"utf8",(C,k)=>{C?f(C):l(b?k.buffer:k)})},!d.thisProgram&&1<process.argv.length&&(A=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),I=(n,l)=>{throw process.exitCode=n,l},global.Worker=Pi().Worker}else(x||E)&&(E?R=self.location.href:typeof document<"u"&&document.currentScript&&(R=document.currentScript.src),typeof e<"u"&&e&&(R=e),R.startsWith("blob:")?R="":R=R.substr(0,R.replace(/[?#].*/,"").lastIndexOf("/")+1),P||(N=n=>{var l=new XMLHttpRequest;return l.open("GET",n,!1),l.send(null),l.responseText},E&&(Q=n=>{var l=new XMLHttpRequest;return l.open("GET",n,!1),l.responseType="arraybuffer",l.send(null),new Uint8Array(l.response)}),K=(n,l,f)=>{var b=new XMLHttpRequest;b.open("GET",n,!0),b.responseType="arraybuffer",b.onload=()=>{b.status==200||b.status==0&&b.response?l(b.response):f()},b.onerror=f,b.send(null)}));P&&typeof performance>"u"&&(global.performance=ki().performance);var se=console.log.bind(console),Ce=console.error.bind(console);P&&(se=(...n)=>he.writeSync(1,n.join(" ")+`\n`),Ce=(...n)=>he.writeSync(2,n.join(" ")+`\n`));var We=se,ee=Ce;Object.assign(d,S),S=null;var ae,Ae,me=!1,ie,ue,le,qe,G,ne,xe,Ke,Be,Ge,Ut;function Ne(){var n=ae.buffer;d.HEAP8=ue=new Int8Array(n),d.HEAP16=qe=new Int16Array(n),d.HEAPU8=le=new Uint8Array(n),d.HEAPU16=G=new Uint16Array(n),d.HEAP32=ne=new Int32Array(n),d.HEAPU32=xe=new Uint32Array(n),d.HEAPF32=Ke=new Float32Array(n),d.HEAPF64=Ut=new Float64Array(n),d.HEAP64=Be=new BigInt64Array(n),d.HEAPU64=Ge=new BigUint64Array(n)}var Ye=16777216;if(O)ae=d.wasmMemory;else if(d.wasmMemory)ae=d.wasmMemory;else if(ae=new WebAssembly.Memory({initial:Ye/65536,maximum:65536,shared:!0}),!(ae.buffer instanceof SharedArrayBuffer))throw ee("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),P&&ee("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Ne(),Ye=ae.buffer.byteLength;var mt=[],Rt=[],qt=[],Vt=0,sr=null,jt=null;function xr(){if(Vt--,Vt==0&&(sr!==null&&(clearInterval(sr),sr=null),jt)){var n=jt;jt=null,n()}}function Kt(n){throw n="Aborted("+n+")",ee(n),me=!0,ie=1,n=new WebAssembly.RuntimeError(n+". Build with -sASSERTIONS for more info."),w(n),n}var je=n=>n.startsWith("data:application/octet-stream;base64,"),Wt=n=>n.startsWith("file://"),at;at="ort-wasm-simd-threaded.wasm",je(at)||(at=L(at));function Cr(n){if(Q)return Q(n);throw"both async and sync fetching of the wasm failed"}function ft(n){if(x||E){if(typeof fetch=="function"&&!Wt(n))return fetch(n,{credentials:"same-origin"}).then(l=>{if(!l.ok)throw`failed to load wasm binary file at \'${n}\'`;return l.arrayBuffer()}).catch(()=>Cr(n));if(K)return new Promise((l,f)=>{K(n,b=>l(new Uint8Array(b)),f)})}return Promise.resolve().then(()=>Cr(n))}function ur(n,l,f){return ft(n).then(b=>WebAssembly.instantiate(b,l)).then(f,b=>{ee(`failed to asynchronously prepare wasm: ${b}`),Kt(b)})}function Ar(n,l){var f=at;return typeof WebAssembly.instantiateStreaming!="function"||je(f)||Wt(f)||P||typeof fetch!="function"?ur(f,n,l):fetch(f,{credentials:"same-origin"}).then(b=>WebAssembly.instantiateStreaming(b,n).then(l,function(C){return ee(`wasm streaming compile failed: ${C}`),ee("falling back to ArrayBuffer instantiation"),ur(f,n,l)}))}var Ir={826468:(n,l,f,b)=>{if(typeof d>"u"||!d.Db)return 1;if(n=He(n>>>0),n.startsWith("./")&&(n=n.substring(2)),n=d.Db.get(n),!n)return 2;if(l>>>=0,f>>>=0,b>>>=0,l+f>n.byteLength)return 3;try{return o().set(n.subarray(l,l+f),b>>>0),0}catch{return 4}},826969:()=>{d.Xb()},827e3:()=>{d.Yb()},827029:()=>{d.bc()},827054:n=>d.Wb(n),827087:n=>d.$b(n),827119:(n,l,f)=>{d.Lb(n,l,f,!0)},827158:(n,l,f)=>{d.Lb(n,l,f)},827191:n=>{d.ob("Abs",n,void 0)},827242:n=>{d.ob("Neg",n,void 0)},827293:n=>{d.ob("Floor",n,void 0)},827346:n=>{d.ob("Ceil",n,void 0)},827398:n=>{d.ob("Reciprocal",n,void 0)},827456:n=>{d.ob("Sqrt",n,void 0)},827508:n=>{d.ob("Exp",n,void 0)},827559:n=>{d.ob("Erf",n,void 0)},827610:n=>{d.ob("Sigmoid",n,void 0)},827665:(n,l,f)=>{d.ob("HardSigmoid",n,{alpha:l,beta:f})},827744:n=>{d.ob("Log",n,void 0)},827795:n=>{d.ob("Sin",n,void 0)},827846:n=>{d.ob("Cos",n,void 0)},827897:n=>{d.ob("Tan",n,void 0)},827948:n=>{d.ob("Asin",n,void 0)},828e3:n=>{d.ob("Acos",n,void 0)},828052:n=>{d.ob("Atan",n,void 0)},828104:n=>{d.ob("Sinh",n,void 0)},828156:n=>{d.ob("Cosh",n,void 0)},828208:n=>{d.ob("Asinh",n,void 0)},828261:n=>{d.ob("Acosh",n,void 0)},828314:n=>{d.ob("Atanh",n,void 0)},828367:n=>{d.ob("Tanh",n,void 0)},828419:n=>{d.ob("Not",n,void 0)},828470:(n,l,f)=>{d.ob("Clip",n,{min:l,max:f})},828539:n=>{d.ob("Clip",n,void 0)},828591:(n,l)=>{d.ob("Elu",n,{alpha:l})},828649:n=>{d.ob("Relu",n,void 0)},828701:(n,l)=>{d.ob("LeakyRelu",n,{alpha:l})},828765:(n,l)=>{d.ob("ThresholdedRelu",n,{alpha:l})},828835:(n,l)=>{d.ob("Cast",n,{to:l})},828893:n=>{d.ob("Add",n,void 0)},828944:n=>{d.ob("Sub",n,void 0)},828995:n=>{d.ob("Mul",n,void 0)},829046:n=>{d.ob("Div",n,void 0)},829097:n=>{d.ob("Pow",n,void 0)},829148:n=>{d.ob("Equal",n,void 0)},829201:n=>{d.ob("Greater",n,void 0)},829256:n=>{d.ob("GreaterOrEqual",n,void 0)},829318:n=>{d.ob("Less",n,void 0)},829370:n=>{d.ob("LessOrEqual",n,void 0)},829429:(n,l,f,b,C)=>{d.ob("ReduceMean",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},829588:(n,l,f,b,C)=>{d.ob("ReduceMax",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},829746:(n,l,f,b,C)=>{d.ob("ReduceMin",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},829904:(n,l,f,b,C)=>{d.ob("ReduceProd",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830063:(n,l,f,b,C)=>{d.ob("ReduceSum",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830221:(n,l,f,b,C)=>{d.ob("ReduceL1",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830378:(n,l,f,b,C)=>{d.ob("ReduceL2",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830535:(n,l,f,b,C)=>{d.ob("ReduceLogSum",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830696:(n,l,f,b,C)=>{d.ob("ReduceSumSquare",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830860:(n,l,f,b,C)=>{d.ob("ReduceLogSumExp",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},831024:n=>{d.ob("Where",n,void 0)},831077:(n,l,f)=>{d.ob("Transpose",n,{perm:l?Array.from(a().subarray(l>>>0,f>>>0)):[]})},831185:(n,l,f,b)=>{d.ob("DepthToSpace",n,{blocksize:l,mode:He(f),format:b?"NHWC":"NCHW"})},831318:(n,l,f,b)=>{d.ob("DepthToSpace",n,{blocksize:l,mode:He(f),format:b?"NHWC":"NCHW"})},831451:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we)=>{d.ob("ConvTranspose",n,{format:re?"NHWC":"NCHW",autoPad:l,dilations:[f],group:b,kernelShape:[C],pads:[k,V],strides:[F],wIsConst:()=>!!r()[J>>>0],outputPadding:ce?Array.from(a().subarray(ce>>>0,Re>>>0)):[],outputShape:ze?Array.from(a().subarray(ze>>>0,z>>>0)):[],activation:He(we)})},831852:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z)=>{d.ob("ConvTranspose",n,{format:F?"NHWC":"NCHW",autoPad:l,dilations:Array.from(a().subarray(f>>>0,(f>>>0)+2>>>0)),group:b,kernelShape:Array.from(a().subarray(C>>>0,(C>>>0)+2>>>0)),pads:Array.from(a().subarray(k>>>0,(k>>>0)+4>>>0)),strides:Array.from(a().subarray(V>>>0,(V>>>0)+2>>>0)),wIsConst:()=>!!r()[re>>>0],outputPadding:J?Array.from(a().subarray(J>>>0,ce>>>0)):[],outputShape:Re?Array.from(a().subarray(Re>>>0,ze>>>0)):[],activation:He(z)})},832417:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we)=>{d.ob("ConvTranspose",n,{format:re?"NHWC":"NCHW",autoPad:l,dilations:[f],group:b,kernelShape:[C],pads:[k,V],strides:[F],wIsConst:()=>!!r()[J>>>0],outputPadding:ce?Array.from(a().subarray(ce>>>0,Re>>>0)):[],outputShape:ze?Array.from(a().subarray(ze>>>0,z>>>0)):[],activation:He(we)})},832818:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z)=>{d.ob("ConvTranspose",n,{format:F?"NHWC":"NCHW",autoPad:l,dilations:Array.from(a().subarray(f>>>0,(f>>>0)+2>>>0)),group:b,kernelShape:Array.from(a().subarray(C>>>0,(C>>>0)+2>>>0)),pads:Array.from(a().subarray(k>>>0,(k>>>0)+4>>>0)),strides:Array.from(a().subarray(V>>>0,(V>>>0)+2>>>0)),wIsConst:()=>!!r()[re>>>0],outputPadding:J?Array.from(a().subarray(J>>>0,ce>>>0)):[],outputShape:Re?Array.from(a().subarray(Re>>>0,ze>>>0)):[],activation:He(z)})},833383:(n,l)=>{d.ob("GlobalAveragePool",n,{format:l?"NHWC":"NCHW"})},833474:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("AveragePool",n,{format:Pe?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:C,dilations:[k,V],kernel_shape:[F,re],pads:[J,ce,Re,ze],strides:[z,we]})},833758:(n,l)=>{d.ob("GlobalAveragePool",n,{format:l?"NHWC":"NCHW"})},833849:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("AveragePool",n,{format:Pe?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:C,dilations:[k,V],kernel_shape:[F,re],pads:[J,ce,Re,ze],strides:[z,we]})},834133:(n,l)=>{d.ob("GlobalMaxPool",n,{format:l?"NHWC":"NCHW"})},834220:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("MaxPool",n,{format:Pe?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:C,dilations:[k,V],kernel_shape:[F,re],pads:[J,ce,Re,ze],strides:[z,we]})},834500:(n,l)=>{d.ob("GlobalMaxPool",n,{format:l?"NHWC":"NCHW"})},834587:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("MaxPool",n,{format:Pe?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:C,dilations:[k,V],kernel_shape:[F,re],pads:[J,ce,Re,ze],strides:[z,we]})},834867:(n,l,f,b,C)=>{d.ob("Gemm",n,{alpha:l,beta:f,transA:b,transB:C})},834971:n=>{d.ob("MatMul",n,void 0)},835025:(n,l,f,b)=>{d.ob("ArgMax",n,{keepDims:!!l,selectLastIndex:!!f,axis:b})},835133:(n,l,f,b)=>{d.ob("ArgMin",n,{keepDims:!!l,selectLastIndex:!!f,axis:b})},835241:(n,l)=>{d.ob("Softmax",n,{axis:l})},835304:(n,l)=>{d.ob("Concat",n,{axis:l})},835364:(n,l,f,b,C)=>{d.ob("Split",n,{axis:l,numOutputs:f,splitSizes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},835504:n=>{d.ob("Expand",n,void 0)},835558:(n,l)=>{d.ob("Gather",n,{axis:Number(l)})},835629:(n,l)=>{d.ob("GatherElements",n,{axis:Number(l)})},835708:(n,l,f,b,C,k,V,F,re,J,ce)=>{d.ob("Resize",n,{antialias:l,axes:f?Array.from(a().subarray(f>>>0,b>>>0)):[],coordinateTransformMode:He(C),cubicCoeffA:k,excludeOutside:V,extrapolationValue:F,keepAspectRatioPolicy:He(re),mode:He(J),nearestMode:He(ce)})},836054:(n,l,f,b,C,k,V)=>{d.ob("Slice",n,{starts:l?Array.from(a().subarray(l>>>0,f>>>0)):[],ends:b?Array.from(a().subarray(b>>>0,C>>>0)):[],axes:k?Array.from(a().subarray(k>>>0,V>>>0)):[]})},836270:n=>{d.ob("Tile",n,void 0)},836322:(n,l,f,b)=>{d.ob("LayerNormalization",n,{axis:l,epsilon:f,simplified:!!b})},836433:(n,l,f)=>{d.ob("InstanceNormalization",n,{epsilon:l,format:f?"NHWC":"NCHW"})},836547:(n,l,f)=>{d.ob("InstanceNormalization",n,{epsilon:l,format:f?"NHWC":"NCHW"})},836661:n=>{d.ob("Range",n,void 0)},836714:(n,l)=>{d.ob("Einsum",n,{equation:He(l)})},836795:(n,l,f,b,C)=>{d.ob("Pad",n,{mode:l,value:f,pads:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},836922:(n,l,f,b,C,k)=>{d.ob("BatchNormalization",n,{epsilon:l,momentum:f,spatial:!!C,trainingMode:!!b,format:k?"NHWC":"NCHW"})},837091:(n,l,f,b,C,k)=>{d.ob("BatchNormalization",n,{epsilon:l,momentum:f,spatial:!!C,trainingMode:!!b,format:k?"NHWC":"NCHW"})},837260:(n,l,f)=>{d.ob("CumSum",n,{exclusive:Number(l),reverse:Number(f)})},837357:(n,l,f,b,C,k,V,F,re)=>{d.ob("Attention",n,{numHeads:l,isUnidirectional:f,maskFilterValue:b,scale:C,doRotary:k,qkvHiddenSizes:V?Array.from(a().subarray(Number(F)>>>0,Number(F)+V>>>0)):[],pastPresentShareBuffer:!!re})},837629:n=>{d.ob("BiasAdd",n,void 0)},837684:n=>{d.ob("BiasSplitGelu",n,void 0)},837745:n=>{d.ob("FastGelu",n,void 0)},837801:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze)=>{d.ob("Conv",n,{format:re?"NHWC":"NCHW",auto_pad:l,dilations:[f],group:b,kernel_shape:[C],pads:k?Array.from(a().subarray(k>>>0,V>>>0)):[],strides:[F],w_is_const:()=>!!r()[J>>>0],activation:He(ce),activation_params:Re?Array.from(p().subarray(Re>>>0,ze>>>0)):[]})},838171:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("Conv",n,{format:Re?"NHWC":"NCHW",auto_pad:l,dilations:[f,b],group:C,kernel_shape:[k,V],pads:F?Array.from(a().subarray(F>>>0,re>>>0)):[],strides:[J,ce],w_is_const:()=>!!r()[ze>>>0],activation:He(z),activation_params:we?Array.from(p().subarray(we>>>0,Pe>>>0)):[]})},838562:n=>{d.ob("Gelu",n,void 0)},838614:(n,l,f,b,C,k)=>{d.ob("MatMulNBits",n,{k:l,n:f,accuracyLevel:b,bits:C,blockSize:k})},838741:(n,l,f,b,C,k)=>{d.ob("MultiHeadAttention",n,{numHeads:l,isUnidirectional:f,maskFilterValue:b,scale:C,doRotary:k})},838900:(n,l,f,b,C)=>{d.ob("RotaryEmbedding",n,{interleaved:!!l,numHeads:f,rotaryEmbeddingDim:b,scale:C})},839039:(n,l,f)=>{d.ob("SkipLayerNormalization",n,{epsilon:l,simplified:!!f})},839141:(n,l,f)=>{d.ob("SkipLayerNormalization",n,{epsilon:l,simplified:!!f})},839243:(n,l,f,b)=>{d.ob("LayerNormalization",n,{axis:l,epsilon:f,simplified:!!b})},839354:n=>{d.ac(n)},839388:(n,l)=>d.cc(n,l,d.Cb.ec,d.Cb.errors)};function st(n){this.name="ExitStatus",this.message=`Program terminated with exit(${n})`,this.status=n}var Tr=n=>{n.terminate(),n.onmessage=()=>{}},ht=n=>{ge.xb.length==0&&(lr(),ge.Mb(ge.xb[0]));var l=ge.xb.pop();if(!l)return 6;ge.yb.push(l),ge.ub[n.wb]=l,l.wb=n.wb;var f={cmd:"run",start_routine:n.fc,arg:n.Rb,pthread_ptr:n.wb};return P&&l.unref(),l.postMessage(f,n.mc),0},bt=0,Er=n=>{var l=io();return n=n(),fn(l),n},Te=(n,l,...f)=>Er(()=>{for(var b=2*f.length,C=oo(8*b),k=C>>>3,V=0;V<f.length;V++){var F=f[V];typeof F=="bigint"?(Be[k+2*V]=1n,Be[k+2*V+1]=F):(Be[k+2*V]=0n,h()[k+2*V+1>>>0]=F)}return gi(n,0,b,C,l)});function dr(n){if(O)return Te(0,1,n);ie=n,0<bt||(ge.hc(),d.onExit?.(n),me=!0),I(n,new st(n))}var Xe=n=>{if(ie=n,O)throw jr(n),"unwind";dr(n)};function ut(){for(var n=d.numThreads;n--;)lr();mt.unshift(()=>{Vt++,Fn(()=>xr())})}function lr(){var n=L("ort-wasm-simd-threaded.worker.js");n=new Worker(n),ge.xb.push(n)}function Fn(n){O?n():Promise.all(ge.xb.map(ge.Mb)).then(n)}var ge={xb:[],yb:[],Qb:[],ub:{},Gb(){O?(ge.receiveObjectTransfer=ge.dc,ge.threadInitTLS=ge.Pb,ge.setExitStatus=ge.Ob):ut()},Ob:n=>ie=n,pc:["$terminateWorker"],hc:()=>{for(var n of ge.yb)Tr(n);for(n of ge.xb)Tr(n);ge.xb=[],ge.yb=[],ge.ub=[]},Nb:n=>{var l=n.wb;delete ge.ub[l],ge.xb.push(n),ge.yb.splice(ge.yb.indexOf(n),1),n.wb=0,ro(l)},dc(){},Pb(){ge.Qb.forEach(n=>n())},Mb:n=>new Promise(l=>{n.onmessage=k=>{k=k.data;var V=k.cmd;if(k.targetThread&&k.targetThread!=pn()){var F=ge.ub[k.targetThread];F?F.postMessage(k,k.transferList):ee(`Internal error! Worker sent a message "${V}" to target pthread ${k.targetThread}, but that thread no longer exists!`)}else V==="checkMailbox"?rt():V==="spawnThread"?ht(k):V==="cleanupThread"?ge.Nb(ge.ub[k.thread]):V==="killThread"?(k=k.thread,V=ge.ub[k],delete ge.ub[k],Tr(V),ro(k),ge.yb.splice(ge.yb.indexOf(V),1),V.wb=0):V==="cancelThread"?ge.ub[k.thread].postMessage({cmd:"cancel"}):V==="loaded"?(n.loaded=!0,P&&!n.wb&&n.unref(),l(n)):V==="alert"?alert(`Thread ${k.threadId}: ${k.text}`):k.target==="setimmediate"?n.postMessage(k):V==="callHandler"?d[k.handler](...k.args):V&&ee(`worker sent an unknown command ${V}`)},n.onerror=k=>{throw ee(`worker sent an error! ${k.filename}:${k.lineno}: ${k.message}`),k},P&&(n.on("message",k=>n.onmessage({data:k})),n.on("error",k=>n.onerror(k)));var f=[],b=["onExit"],C;for(C of b)d.hasOwnProperty(C)&&f.push(C);n.postMessage({cmd:"load",handlers:f,urlOrBlob:d.mainScriptUrlOrBlob||e,wasmMemory:ae,wasmModule:Ae})})};d.PThread=ge;var Yt=n=>{for(;0<n.length;)n.shift()(d)};d.establishStackSpace=()=>{var n=pn(),l=c()[n+52>>>2>>>0];n=c()[n+56>>>2>>>0],bi(l,l-n),fn(l)};function jr(n){if(O)return Te(1,0,n);Xe(n)}d.invokeEntryPoint=(n,l)=>{bt=0,n=wi(n,l),0<bt?ge.Ob(n):no(n)};class qn{constructor(l){this.Ib=l-24}Gb(l,f){c()[this.Ib+16>>>2>>>0]=0,c()[this.Ib+4>>>2>>>0]=l,c()[this.Ib+8>>>2>>>0]=f}}var Kr=0,jn=0;function Yr(n,l,f,b){return O?Te(2,1,n,l,f,b):Zr(n,l,f,b)}function Zr(n,l,f,b){if(n>>>=0,l>>>=0,f>>>=0,b>>>=0,typeof SharedArrayBuffer>"u")return ee("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var C=[];return O&&C.length===0?Yr(n,l,f,b):(n={fc:f,wb:n,Rb:b,mc:C},O?(n.oc="spawnThread",postMessage(n,C),0):ht(n))}var cr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Pr=(n,l,f)=>{l>>>=0;var b=l+f;for(f=l;n[f]&&!(f>=b);)++f;if(16<f-l&&n.buffer&&cr)return cr.decode(n.buffer instanceof SharedArrayBuffer?n.slice(l,f):n.subarray(l,f));for(b="";l<f;){var C=n[l++];if(C&128){var k=n[l++]&63;if((C&224)==192)b+=String.fromCharCode((C&31)<<6|k);else{var V=n[l++]&63;C=(C&240)==224?(C&15)<<12|k<<6|V:(C&7)<<18|k<<12|V<<6|n[l++]&63,65536>C?b+=String.fromCharCode(C):(C-=65536,b+=String.fromCharCode(55296|C>>10,56320|C&1023))}}else b+=String.fromCharCode(C)}return b},He=(n,l)=>(n>>>=0)?Pr(o(),n,l):"";function Xr(n,l,f){return O?Te(3,1,n,l,f):0}function Qr(n,l){if(O)return Te(4,1,n,l)}var gt=n=>{for(var l=0,f=0;f<n.length;++f){var b=n.charCodeAt(f);127>=b?l++:2047>=b?l+=2:55296<=b&&57343>=b?(l+=4,++f):l+=3}return l},dt=(n,l,f,b)=>{if(f>>>=0,!(0<b))return 0;var C=f;b=f+b-1;for(var k=0;k<n.length;++k){var V=n.charCodeAt(k);if(55296<=V&&57343>=V){var F=n.charCodeAt(++k);V=65536+((V&1023)<<10)|F&1023}if(127>=V){if(f>=b)break;l[f++>>>0]=V}else{if(2047>=V){if(f+1>=b)break;l[f++>>>0]=192|V>>6}else{if(65535>=V){if(f+2>=b)break;l[f++>>>0]=224|V>>12}else{if(f+3>=b)break;l[f++>>>0]=240|V>>18,l[f++>>>0]=128|V>>12&63}l[f++>>>0]=128|V>>6&63}l[f++>>>0]=128|V&63}}return l[f>>>0]=0,f-C},Bt=(n,l,f)=>dt(n,o(),l,f);function Zt(n,l){if(O)return Te(5,1,n,l)}function kr(n,l,f){if(O)return Te(6,1,n,l,f)}function Or(n,l,f){return O?Te(7,1,n,l,f):0}function Jr(n,l){if(O)return Te(8,1,n,l)}function pr(n,l,f){if(O)return Te(9,1,n,l,f)}function en(n,l,f,b){if(O)return Te(10,1,n,l,f,b)}function tn(n,l,f,b){if(O)return Te(11,1,n,l,f,b)}function rn(n,l,f,b){if(O)return Te(12,1,n,l,f,b)}function nn(n){if(O)return Te(13,1,n)}function Rr(n,l){if(O)return Te(14,1,n,l)}function Xt(n,l,f){if(O)return Te(15,1,n,l,f)}var on,nt=n=>{for(var l="";o()[n>>>0];)l+=on[o()[n++>>>0]];return l},mr={},Br={},Kn={},wt;function Yn(n,l,f={}){var b=l.name;if(!n)throw new wt(`type "${b}" must have a positive integer typeid pointer`);if(Br.hasOwnProperty(n)){if(f.Ub)return;throw new wt(`Cannot register type \'${b}\' twice`)}Br[n]=l,delete Kn[n],mr.hasOwnProperty(n)&&(l=mr[n],delete mr[n],l.forEach(C=>C()))}function Je(n,l,f={}){if(!("argPackAdvance"in l))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Yn(n,l,f)}var Dr=(n,l,f)=>{switch(l){case 1:return f?b=>r()[b>>>0]:b=>o()[b>>>0];case 2:return f?b=>i()[b>>>1>>>0]:b=>u()[b>>>1>>>0];case 4:return f?b=>a()[b>>>2>>>0]:b=>c()[b>>>2>>>0];case 8:return f?b=>Be[b>>>3]:b=>Ge[b>>>3];default:throw new TypeError(`invalid integer width (${l}): ${n}`)}},fr=[],lt=[];function hr(n){n>>>=0,9<n&&--lt[n+1]===0&&(lt[n]=void 0,fr.push(n))}var Qe=n=>{if(!n)throw new wt("Cannot use deleted val. handle = "+n);return lt[n]},ot=n=>{switch(n){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let l=fr.pop()||lt.length;return lt[l]=n,lt[l+1]=1,l}};function Qt(n){return this.fromWireType(c()[n>>>2>>>0])}var Zn={name:"emscripten::val",fromWireType:n=>{var l=Qe(n);return hr(n),l},toWireType:(n,l)=>ot(l),argPackAdvance:8,readValueFromPointer:Qt,Bb:null},an=(n,l)=>{switch(l){case 4:return function(f){return this.fromWireType(p()[f>>>2>>>0])};case 8:return function(f){return this.fromWireType(h()[f>>>3>>>0])};default:throw new TypeError(`invalid float width (${l}): ${n}`)}},zr=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Xn=(n,l)=>{for(var f=n>>1,b=f+l/2;!(f>=b)&&u()[f>>>0];)++f;if(f<<=1,32<f-n&&zr)return zr.decode(o().slice(n,f));for(f="",b=0;!(b>=l/2);++b){var C=i()[n+2*b>>>1>>>0];if(C==0)break;f+=String.fromCharCode(C)}return f},sn=(n,l,f)=>{if(f??=2147483647,2>f)return 0;f-=2;var b=l;f=f<2*n.length?f/2:n.length;for(var C=0;C<f;++C){var k=n.charCodeAt(C);i()[l>>>1>>>0]=k,l+=2}return i()[l>>>1>>>0]=0,l-b},un=n=>2*n.length,gr=(n,l)=>{for(var f=0,b="";!(f>=l/4);){var C=a()[n+4*f>>>2>>>0];if(C==0)break;++f,65536<=C?(C-=65536,b+=String.fromCharCode(55296|C>>10,56320|C&1023)):b+=String.fromCharCode(C)}return b},Qn=(n,l,f)=>{if(l>>>=0,f??=2147483647,4>f)return 0;var b=l;f=b+f-4;for(var C=0;C<n.length;++C){var k=n.charCodeAt(C);if(55296<=k&&57343>=k){var V=n.charCodeAt(++C);k=65536+((k&1023)<<10)|V&1023}if(a()[l>>>2>>>0]=k,l+=4,l+4>f)break}return a()[l>>>2>>>0]=0,l-b},pe=n=>{for(var l=0,f=0;f<n.length;++f){var b=n.charCodeAt(f);55296<=b&&57343>=b&&++f,l+=4}return l},Mr=n=>{if(!me)try{if(n(),!(0<bt))try{O?no(ie):Xe(ie)}catch(l){l instanceof st||l=="unwind"||I(1,l)}}catch(l){l instanceof st||l=="unwind"||I(1,l)}};function Nt(n){n>>>=0,typeof Atomics.nc=="function"&&(Atomics.nc(a(),n>>>2,n).value.then(rt),n+=128,Atomics.store(a(),n>>>2,1))}d.__emscripten_thread_mailbox_await=Nt;var rt=()=>{var n=pn();n&&(Nt(n),Mr(yi))};d.checkMailbox=rt;var yr=[],br=(n,l)=>{var f=Br[n];if(f===void 0)throw n=fi(n),f=nt(n),At(n),new wt(`${l} has unknown type ${f}`);return f},Ur=(n,l,f)=>{var b=[];return n=n.toWireType(b,f),b.length&&(c()[l>>>2>>>0]=ot(b)),n},Jt=n=>{try{n()}catch(l){Kt(l)}};function dn(){var n=oe,l={};for(let[f,b]of Object.entries(n))l[f]=typeof b=="function"?(...C)=>{Dt.push(f);try{return b(...C)}finally{me||(Dt.pop(),ct&&vt===1&&Dt.length===0&&(vt=0,bt+=1,Jt($i),typeof Fibers<"u"&&Fibers.rc()))}}:b;return l}var vt=0,ct=null,ln=0,Dt=[],Vr={},s={},m=0,g=null,$=[];function T(){return new Promise((n,l)=>{g={resolve:n,reject:l}})}function B(){var n=mn(65548),l=n+12;c()[n>>>2>>>0]=l,c()[n+4>>>2>>>0]=l+65536,l=Dt[0];var f=Vr[l];return f===void 0&&(f=m++,Vr[l]=f,s[f]=l),l=f,a()[n+8>>>2>>>0]=l,n}function H(){var n=a()[ct+8>>>2>>>0];return n=oe[s[n]],--bt,n()}function q(n){if(!me){if(vt===0){var l=!1,f=!1;n((b=0)=>{if(!me&&(ln=b,l=!0,f)){vt=2,Jt(()=>_i(ct)),typeof Browser<"u"&&Browser.Hb.Tb&&Browser.Hb.resume(),b=!1;try{var C=H()}catch(F){C=F,b=!0}var k=!1;if(!ct){var V=g;V&&(g=null,(b?V.reject:V.resolve)(C),k=!0)}if(b&&!k)throw C}}),f=!0,l||(vt=1,ct=B(),typeof Browser<"u"&&Browser.Hb.Tb&&Browser.Hb.pause(),Jt(()=>vi(ct)))}else vt===2?(vt=0,Jt(Si),At(ct),ct=null,$.forEach(Mr)):Kt(`invalid state: ${vt}`);return ln}}function te(n){return q(l=>{n().then(l)})}var X=[],de={},Ee=n=>{var l=de[n];return l===void 0?nt(n):l},Oe=()=>typeof globalThis=="object"?globalThis:Function("return this")(),D=n=>{var l=X.length;return X.push(n),l},be=(n,l)=>{for(var f=Array(n),b=0;b<n;++b)f[b]=br(c()[l+4*b>>>2>>>0],"parameter "+b);return f},Ie=(n,l)=>Object.defineProperty(l,"name",{value:n});function zt(n){var l=Function;if(!(l instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof l} which is not a function`);var f=Ie(l.name||"unknownFunctionName",function(){});return f.prototype=l.prototype,f=new f,n=l.apply(f,n),n instanceof Object?n:f}var Mt=n=>n%4===0&&(n%100!==0||n%400===0),Qo=[0,31,60,91,121,152,182,213,244,274,305,335],Jo=[0,31,59,90,120,151,181,212,243,273,304,334];function ei(n,l,f,b,C,k,V){return O?Te(16,1,n,l,f,b,C,k,V):-52}function ti(n,l,f,b,C,k){if(O)return Te(17,1,n,l,f,b,C,k)}var Jn=[],ri=(n,l)=>{Jn.length=0;for(var f;f=o()[n++>>>0];){var b=f!=105;b&=f!=112,l+=b&&l%8?4:0,Jn.push(f==112?c()[l>>>2>>>0]:f==106?Be[l>>>3]:f==105?a()[l>>>2>>>0]:h()[l>>>3>>>0]),l+=b?8:4}return Jn},eo={},ni=()=>{if(!to){var n={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:A||"./this.program"},l;for(l in eo)eo[l]===void 0?delete n[l]:n[l]=eo[l];var f=[];for(l in n)f.push(`${l}=${n[l]}`);to=f}return to},to;function oi(n,l){if(O)return Te(18,1,n,l);n>>>=0,l>>>=0;var f=0;return ni().forEach((b,C)=>{var k=l+f;for(C=c()[n+4*C>>>2>>>0]=k,k=0;k<b.length;++k)r()[C++>>>0]=b.charCodeAt(k);r()[C>>>0]=0,f+=b.length+1}),0}function ii(n,l){if(O)return Te(19,1,n,l);n>>>=0,l>>>=0;var f=ni();c()[n>>>2>>>0]=f.length;var b=0;return f.forEach(C=>b+=C.length+1),c()[l>>>2>>>0]=b,0}function ai(n){return O?Te(20,1,n):52}function si(n,l,f,b){return O?Te(21,1,n,l,f,b):52}function ui(n,l,f,b){return O?Te(22,1,n,l,f,b):70}var Xd=[null,[],[]];function di(n,l,f,b){if(O)return Te(23,1,n,l,f,b);l>>>=0,f>>>=0,b>>>=0;for(var C=0,k=0;k<f;k++){var V=c()[l>>>2>>>0],F=c()[l+4>>>2>>>0];l+=8;for(var re=0;re<F;re++){var J=o()[V+re>>>0],ce=Xd[n];J===0||J===10?((n===1?We:ee)(Pr(ce,0)),ce.length=0):ce.push(J)}C+=F}return c()[b>>>2>>>0]=C,0}var li=[31,29,31,30,31,30,31,31,30,31,30,31],ci=[31,28,31,30,31,30,31,31,30,31,30,31];function Qd(n){var l=Array(gt(n)+1);return dt(n,l,0,l.length),l}var Jd=(n,l)=>{r().set(n,l>>>0)};function pi(n,l,f,b){function C(z,we,Pe){for(z=typeof z=="number"?z.toString():z||"";z.length<we;)z=Pe[0]+z;return z}function k(z,we){return C(z,we,"0")}function V(z,we){function Pe(Ci){return 0>Ci?-1:0<Ci?1:0}var er;return(er=Pe(z.getFullYear()-we.getFullYear()))===0&&(er=Pe(z.getMonth()-we.getMonth()))===0&&(er=Pe(z.getDate()-we.getDate())),er}function F(z){switch(z.getDay()){case 0:return new Date(z.getFullYear()-1,11,29);case 1:return z;case 2:return new Date(z.getFullYear(),0,3);case 3:return new Date(z.getFullYear(),0,2);case 4:return new Date(z.getFullYear(),0,1);case 5:return new Date(z.getFullYear()-1,11,31);case 6:return new Date(z.getFullYear()-1,11,30)}}function re(z){var we=z.zb;for(z=new Date(new Date(z.Ab+1900,0,1).getTime());0<we;){var Pe=z.getMonth(),er=(Mt(z.getFullYear())?li:ci)[Pe];if(we>er-z.getDate())we-=er-z.getDate()+1,z.setDate(1),11>Pe?z.setMonth(Pe+1):(z.setMonth(0),z.setFullYear(z.getFullYear()+1));else{z.setDate(z.getDate()+we);break}}return Pe=new Date(z.getFullYear()+1,0,4),we=F(new Date(z.getFullYear(),0,4)),Pe=F(Pe),0>=V(we,z)?0>=V(Pe,z)?z.getFullYear()+1:z.getFullYear():z.getFullYear()-1}n>>>=0,l>>>=0,f>>>=0,b>>>=0;var J=c()[b+40>>>2>>>0];b={kc:a()[b>>>2>>>0],jc:a()[b+4>>>2>>>0],Eb:a()[b+8>>>2>>>0],Jb:a()[b+12>>>2>>>0],Fb:a()[b+16>>>2>>>0],Ab:a()[b+20>>>2>>>0],vb:a()[b+24>>>2>>>0],zb:a()[b+28>>>2>>>0],qc:a()[b+32>>>2>>>0],ic:a()[b+36>>>2>>>0],lc:J?He(J):""},f=He(f),J={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ce in J)f=f.replace(new RegExp(ce,"g"),J[ce]);var Re="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ze="January February March April May June July August September October November December".split(" ");J={"%a":z=>Re[z.vb].substring(0,3),"%A":z=>Re[z.vb],"%b":z=>ze[z.Fb].substring(0,3),"%B":z=>ze[z.Fb],"%C":z=>k((z.Ab+1900)/100|0,2),"%d":z=>k(z.Jb,2),"%e":z=>C(z.Jb,2," "),"%g":z=>re(z).toString().substring(2),"%G":re,"%H":z=>k(z.Eb,2),"%I":z=>(z=z.Eb,z==0?z=12:12<z&&(z-=12),k(z,2)),"%j":z=>{for(var we=0,Pe=0;Pe<=z.Fb-1;we+=(Mt(z.Ab+1900)?li:ci)[Pe++]);return k(z.Jb+we,3)},"%m":z=>k(z.Fb+1,2),"%M":z=>k(z.jc,2),"%n":()=>`\n`,"%p":z=>0<=z.Eb&&12>z.Eb?"AM":"PM","%S":z=>k(z.kc,2),"%t":()=>"	","%u":z=>z.vb||7,"%U":z=>k(Math.floor((z.zb+7-z.vb)/7),2),"%V":z=>{var we=Math.floor((z.zb+7-(z.vb+6)%7)/7);if(2>=(z.vb+371-z.zb-2)%7&&we++,we)we==53&&(Pe=(z.vb+371-z.zb)%7,Pe==4||Pe==3&&Mt(z.Ab)||(we=1));else{we=52;var Pe=(z.vb+7-z.zb-1)%7;(Pe==4||Pe==5&&Mt(z.Ab%400-1))&&we++}return k(we,2)},"%w":z=>z.vb,"%W":z=>k(Math.floor((z.zb+7-(z.vb+6)%7)/7),2),"%y":z=>(z.Ab+1900).toString().substring(2),"%Y":z=>z.Ab+1900,"%z":z=>{z=z.ic;var we=0<=z;return z=Math.abs(z)/60,(we?"+":"-")+("0000"+(z/60*100+z%60)).slice(-4)},"%Z":z=>z.lc,"%%":()=>"%"},f=f.replace(/%%/g,"\\0\\0");for(ce in J)f.includes(ce)&&(f=f.replace(new RegExp(ce,"g"),J[ce](b)));return f=f.replace(/\\0\\0/g,"%"),ce=Qd(f),ce.length>l?0:(Jd(ce,n),ce.length-1)}ge.Gb();for(var mi=Array(256),cn=0;256>cn;++cn)mi[cn]=String.fromCharCode(cn);on=mi,wt=d.BindingError=class extends Error{constructor(n){super(n),this.name="BindingError"}},d.InternalError=class extends Error{constructor(n){super(n),this.name="InternalError"}},lt.push(0,1,void 0,1,null,1,!0,1,!1,1),d.count_emval_handles=()=>lt.length/2-5-fr.length;var el=[dr,jr,Yr,Xr,Qr,Zt,kr,Or,Jr,pr,en,tn,rn,nn,Rr,Xt,ei,ti,oi,ii,ai,si,ui,di],tl={ua:function(n,l,f){return te(async()=>{await d.Zb(n,l,f)})},b:function(n,l,f){throw n>>>=0,new qn(n).Gb(l>>>0,f>>>0),Kr=n,jn++,Kr},ia:function(n){hi(n>>>0,!E,1,!x,131072,!1),ge.Pb()},G:function(n){n>>>=0,O?postMessage({cmd:"cleanupThread",thread:n}):ge.Nb(ge.ub[n])},_:Zr,A:Xr,pa:Qr,W:Zt,Y:kr,qa:Or,na:Jr,fa:pr,ma:en,K:tn,X:rn,U:nn,oa:Rr,V:Xt,E:function(n,l,f){n>>>=0,f>>>=0,l=nt(l>>>0),Je(n,{name:l,fromWireType:b=>b,toWireType:function(b,C){if(typeof C!="bigint"&&typeof C!="number")throw C===null?C="null":(b=typeof C,C=b==="object"||b==="array"||b==="function"?C.toString():""+C),new TypeError(`Cannot convert "${C}" to ${this.name}`);return typeof C=="number"&&(C=BigInt(C)),C},argPackAdvance:8,readValueFromPointer:Dr(l,f,l.indexOf("u")==-1),Bb:null})},O:function(n,l,f,b){n>>>=0,l=nt(l>>>0),Je(n,{name:l,fromWireType:function(C){return!!C},toWireType:function(C,k){return k?f:b},argPackAdvance:8,readValueFromPointer:function(C){return this.fromWireType(o()[C>>>0])},Bb:null})},N:function(n){return Je(n>>>0,Zn)},D:function(n,l,f){n>>>=0,f>>>=0,l=nt(l>>>0),Je(n,{name:l,fromWireType:b=>b,toWireType:(b,C)=>C,argPackAdvance:8,readValueFromPointer:an(l,f),Bb:null})},t:function(n,l,f,b,C){if(n>>>=0,f>>>=0,l=nt(l>>>0),C===-1&&(C=4294967295),C=F=>F,b===0){var k=32-8*f;C=F=>F<<k>>>k}var V=l.includes("unsigned")?function(F,re){return re>>>0}:function(F,re){return re};Je(n,{name:l,fromWireType:C,toWireType:V,argPackAdvance:8,readValueFromPointer:Dr(l,f,b!==0),Bb:null})},p:function(n,l,f){function b(k){var V=c()[k>>>2>>>0];return k=c()[k+4>>>2>>>0],new C(r().buffer,k,V)}n>>>=0;var C=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][l];f=nt(f>>>0),Je(n,{name:f,fromWireType:b,argPackAdvance:8,readValueFromPointer:b},{Ub:!0})},F:function(n,l){n>>>=0,l=nt(l>>>0);var f=l==="std::string";Je(n,{name:l,fromWireType:function(b){var C=c()[b>>>2>>>0],k=b+4;if(f)for(var V=k,F=0;F<=C;++F){var re=k+F;if(F==C||o()[re>>>0]==0){if(V=He(V,re-V),J===void 0)var J=V;else J+=String.fromCharCode(0),J+=V;V=re+1}}else{for(J=Array(C),F=0;F<C;++F)J[F]=String.fromCharCode(o()[k+F>>>0]);J=J.join("")}return At(b),J},toWireType:function(b,C){C instanceof ArrayBuffer&&(C=new Uint8Array(C));var k=typeof C=="string";if(!(k||C instanceof Uint8Array||C instanceof Uint8ClampedArray||C instanceof Int8Array))throw new wt("Cannot pass non-string to std::string");var V=f&&k?gt(C):C.length,F=mn(4+V+1),re=F+4;if(c()[F>>>2>>>0]=V,f&&k)Bt(C,re,V+1);else if(k)for(k=0;k<V;++k){var J=C.charCodeAt(k);if(255<J)throw At(re),new wt("String has UTF-16 code units that do not fit in 8 bits");o()[re+k>>>0]=J}else for(k=0;k<V;++k)o()[re+k>>>0]=C[k];return b!==null&&b.push(At,F),F},argPackAdvance:8,readValueFromPointer:Qt,Bb(b){At(b)}})},z:function(n,l,f){if(n>>>=0,l>>>=0,f>>>=0,f=nt(f),l===2)var b=Xn,C=sn,k=un,V=F=>u()[F>>>1>>>0];else l===4&&(b=gr,C=Qn,k=pe,V=F=>c()[F>>>2>>>0]);Je(n,{name:f,fromWireType:F=>{for(var re=c()[F>>>2>>>0],J,ce=F+4,Re=0;Re<=re;++Re){var ze=F+4+Re*l;(Re==re||V(ze)==0)&&(ce=b(ce,ze-ce),J===void 0?J=ce:(J+=String.fromCharCode(0),J+=ce),ce=ze+l)}return At(F),J},toWireType:(F,re)=>{if(typeof re!="string")throw new wt(`Cannot pass non-string to C++ string type ${f}`);var J=k(re),ce=mn(4+J+l);return c()[ce>>>2>>>0]=J/l,C(re,ce+4,J+l),F!==null&&F.push(At,ce),ce},argPackAdvance:8,readValueFromPointer:Qt,Bb(F){At(F)}})},P:function(n,l){n>>>=0,l=nt(l>>>0),Je(n,{Vb:!0,name:l,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},ta:()=>1,S:function(n,l){n>>>=0,n==l>>>0?setTimeout(rt):O?postMessage({targetThread:n,cmd:"checkMailbox"}):(n=ge.ub[n])&&n.postMessage({cmd:"checkMailbox"})},$:function(n,l,f,b,C){l>>>=0,f>>>=0,b/=2,yr.length=b,C=C>>>0>>>3;for(var k=0;k<b;k++)yr[k]=Be[C+2*k]?Be[C+2*k+1]:h()[C+2*k+1>>>0];return n=l?Ir[l]:el[n],ge.Sb=f,f=n(...yr),ge.Sb=0,f},ha:Nt,sa:function(n){P&&ge.ub[n>>>0].ref()},w:function(n,l,f){return l>>>=0,f>>>=0,n=Qe(n>>>0),l=br(l,"emval::as"),Ur(l,f,n)},y:function(n){return n>>>=0,te(()=>(n=Qe(n),n.then(ot)))},o:function(n,l,f,b){return f>>>=0,b>>>=0,n=X[n>>>0],l=Qe(l>>>0),n(null,l,f,b)},k:function(n,l,f,b,C){return f>>>=0,b>>>=0,C>>>=0,n=X[n>>>0],l=Qe(l>>>0),f=Ee(f),n(l,l[f],b,C)},c:hr,C:function(n,l){return l>>>=0,n=Qe(n>>>0),l=Qe(l),n==l},n:function(n){return n>>>=0,n===0?ot(Oe()):(n=Ee(n),ot(Oe()[n]))},j:function(n,l,f){l=be(n,l>>>0);var b=l.shift();n--;var C=`return function (obj, func, destructorsRef, args) {\n`,k=0,V=[];f===0&&V.push("obj");for(var F=["retType"],re=[b],J=0;J<n;++J)V.push("arg"+J),F.push("argType"+J),re.push(l[J]),C+=`  var arg${J} = argType${J}.readValueFromPointer(args${k?"+"+k:""});\n`,k+=l[J].argPackAdvance;return C+=`  var rv = ${f===1?"new func":"func.call"}(${V.join(", ")});\n`,b.Vb||(F.push("emval_returnValue"),re.push(Ur),C+=`  return emval_returnValue(retType, destructorsRef, rv);\n`),F.push(C+`};\n`),n=zt(F)(...re),f=`methodCaller<(${l.map(ce=>ce.name).join(", ")}) => ${b.name}>`,D(Ie(f,n))},s:function(n,l){return l>>>=0,n=Qe(n>>>0),l=Qe(l),ot(n[l])},d:function(n){n>>>=0,9<n&&(lt[n+1]+=1)},v:function(){return ot([])},m:function(n){n=Qe(n>>>0);for(var l=Array(n.length),f=0;f<n.length;f++)l[f]=n[f];return ot(l)},g:function(n){return ot(Ee(n>>>0))},l:function(){return ot({})},i:function(n){n>>>=0;for(var l=Qe(n);l.length;){var f=l.pop();l.pop()(f)}hr(n)},h:function(n,l,f){l>>>=0,f>>>=0,n=Qe(n>>>0),l=Qe(l),f=Qe(f),n[l]=f},e:function(n,l){return l>>>=0,n=br(n>>>0,"_emval_take_value"),n=n.readValueFromPointer(l),ot(n)},ca:function(n,l){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n),l>>>=0,n=new Date(1e3*n),a()[l>>>2>>>0]=n.getUTCSeconds(),a()[l+4>>>2>>>0]=n.getUTCMinutes(),a()[l+8>>>2>>>0]=n.getUTCHours(),a()[l+12>>>2>>>0]=n.getUTCDate(),a()[l+16>>>2>>>0]=n.getUTCMonth(),a()[l+20>>>2>>>0]=n.getUTCFullYear()-1900,a()[l+24>>>2>>>0]=n.getUTCDay(),n=(n.getTime()-Date.UTC(n.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[l+28>>>2>>>0]=n},da:function(n,l){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n),l>>>=0,n=new Date(1e3*n),a()[l>>>2>>>0]=n.getSeconds(),a()[l+4>>>2>>>0]=n.getMinutes(),a()[l+8>>>2>>>0]=n.getHours(),a()[l+12>>>2>>>0]=n.getDate(),a()[l+16>>>2>>>0]=n.getMonth(),a()[l+20>>>2>>>0]=n.getFullYear()-1900,a()[l+24>>>2>>>0]=n.getDay();var f=(Mt(n.getFullYear())?Qo:Jo)[n.getMonth()]+n.getDate()-1|0;a()[l+28>>>2>>>0]=f,a()[l+36>>>2>>>0]=-(60*n.getTimezoneOffset()),f=new Date(n.getFullYear(),6,1).getTimezoneOffset();var b=new Date(n.getFullYear(),0,1).getTimezoneOffset();n=(f!=b&&n.getTimezoneOffset()==Math.min(b,f))|0,a()[l+32>>>2>>>0]=n},ea:function(n){n>>>=0;var l=new Date(a()[n+20>>>2>>>0]+1900,a()[n+16>>>2>>>0],a()[n+12>>>2>>>0],a()[n+8>>>2>>>0],a()[n+4>>>2>>>0],a()[n>>>2>>>0],0),f=a()[n+32>>>2>>>0],b=l.getTimezoneOffset(),C=new Date(l.getFullYear(),6,1).getTimezoneOffset(),k=new Date(l.getFullYear(),0,1).getTimezoneOffset(),V=Math.min(k,C);return 0>f?a()[n+32>>>2>>>0]=+(C!=k&&V==b):0<f!=(V==b)&&(C=Math.max(k,C),l.setTime(l.getTime()+6e4*((0<f?V:C)-b))),a()[n+24>>>2>>>0]=l.getDay(),f=(Mt(l.getFullYear())?Qo:Jo)[l.getMonth()]+l.getDate()-1|0,a()[n+28>>>2>>>0]=f,a()[n>>>2>>>0]=l.getSeconds(),a()[n+4>>>2>>>0]=l.getMinutes(),a()[n+8>>>2>>>0]=l.getHours(),a()[n+12>>>2>>>0]=l.getDate(),a()[n+16>>>2>>>0]=l.getMonth(),a()[n+20>>>2>>>0]=l.getYear(),n=l.getTime(),BigInt(isNaN(n)?-1:n/1e3)},aa:ei,ba:ti,R:function(n,l,f,b){n>>>=0,l>>>=0,f>>>=0,b>>>=0;var C=new Date().getFullYear(),k=new Date(C,0,1),V=new Date(C,6,1);C=k.getTimezoneOffset();var F=V.getTimezoneOffset(),re=Math.max(C,F);c()[n>>>2>>>0]=60*re,a()[l>>>2>>>0]=+(C!=F),n=J=>J.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],k=n(k),V=n(V),F<C?(Bt(k,f,17),Bt(V,b,17)):(Bt(k,b,17),Bt(V,f,17))},q:()=>{Kt("")},f:function(n,l,f){return n>>>=0,l=ri(l>>>0,f>>>0),Ir[n](...l)},M:function(n,l,f){return n>>>=0,l=ri(l>>>0,f>>>0),Ir[n](...l)},H:()=>{},L:()=>Date.now(),ra:()=>{throw bt+=1,"unwind"},T:function(){return 4294901760},u:()=>performance.timeOrigin+performance.now(),x:()=>P?(Ri(),wr(Oi)).cpus().length:navigator.hardwareConcurrency,Q:function(n){n>>>=0;var l=o().length;if(n<=l||4294901760<n)return!1;for(var f=1;4>=f;f*=2){var b=l*(1+.2/f);b=Math.min(b,n+100663296);var C=Math;b=Math.max(n,b);e:{C=(C.min.call(C,4294901760,b+(65536-b%65536)%65536)-ae.buffer.byteLength+65535)/65536;try{ae.grow(C),Ne();var k=1;break e}catch{}k=void 0}if(k)return!0}return!1},ja:oi,la:ii,Z:Xe,B:ai,J:si,ga:ui,I:di,a:ae||d.wasmMemory,ka:pi,r:function(n,l,f,b){return pi(n>>>0,l>>>0,f>>>0,b>>>0)}},oe=function(){function n(f,b){return oe=f.exports,oe=dn(),oe=rl(),ge.Qb.push(oe.cb),Rt.unshift(oe.va),Ae=b,xr(),oe}var l={a:tl};if(Vt++,d.instantiateWasm)try{return d.instantiateWasm(l,n)}catch(f){ee(`Module.instantiateWasm callback failed with error: ${f}`),w(f)}return Ar(l,function(f){n(f.instance,f.module)}).catch(w),{}}(),fi=n=>(fi=oe.wa)(n);d.__embind_initialize_bindings=()=>(d.__embind_initialize_bindings=oe.xa)(),d._OrtInit=(n,l)=>(d._OrtInit=oe.ya)(n,l),d._OrtGetLastError=(n,l)=>(d._OrtGetLastError=oe.za)(n,l),d._OrtCreateSessionOptions=(n,l,f,b,C,k,V,F,re,J)=>(d._OrtCreateSessionOptions=oe.Aa)(n,l,f,b,C,k,V,F,re,J),d._OrtAppendExecutionProvider=(n,l)=>(d._OrtAppendExecutionProvider=oe.Ba)(n,l),d._OrtAddFreeDimensionOverride=(n,l,f)=>(d._OrtAddFreeDimensionOverride=oe.Ca)(n,l,f),d._OrtAddSessionConfigEntry=(n,l,f)=>(d._OrtAddSessionConfigEntry=oe.Da)(n,l,f),d._OrtReleaseSessionOptions=n=>(d._OrtReleaseSessionOptions=oe.Ea)(n),d._OrtCreateSession=(n,l,f)=>(d._OrtCreateSession=oe.Fa)(n,l,f),d._OrtReleaseSession=n=>(d._OrtReleaseSession=oe.Ga)(n),d._OrtGetInputOutputCount=(n,l,f)=>(d._OrtGetInputOutputCount=oe.Ha)(n,l,f),d._OrtGetInputName=(n,l)=>(d._OrtGetInputName=oe.Ia)(n,l),d._OrtGetOutputName=(n,l)=>(d._OrtGetOutputName=oe.Ja)(n,l),d._OrtFree=n=>(d._OrtFree=oe.Ka)(n),d._OrtCreateTensor=(n,l,f,b,C,k)=>(d._OrtCreateTensor=oe.La)(n,l,f,b,C,k),d._OrtGetTensorData=(n,l,f,b,C)=>(d._OrtGetTensorData=oe.Ma)(n,l,f,b,C),d._OrtReleaseTensor=n=>(d._OrtReleaseTensor=oe.Na)(n),d._OrtCreateRunOptions=(n,l,f,b)=>(d._OrtCreateRunOptions=oe.Oa)(n,l,f,b),d._OrtAddRunConfigEntry=(n,l,f)=>(d._OrtAddRunConfigEntry=oe.Pa)(n,l,f),d._OrtReleaseRunOptions=n=>(d._OrtReleaseRunOptions=oe.Qa)(n),d._OrtCreateBinding=n=>(d._OrtCreateBinding=oe.Ra)(n),d._OrtBindInput=(n,l,f)=>(d._OrtBindInput=oe.Sa)(n,l,f),d._OrtBindOutput=(n,l,f,b)=>(d._OrtBindOutput=oe.Ta)(n,l,f,b),d._OrtClearBoundOutputs=n=>(d._OrtClearBoundOutputs=oe.Ua)(n),d._OrtReleaseBinding=n=>(d._OrtReleaseBinding=oe.Va)(n),d._OrtRunWithBinding=(n,l,f,b,C)=>(d._OrtRunWithBinding=oe.Wa)(n,l,f,b,C),d._OrtRun=(n,l,f,b,C,k,V,F)=>(d._OrtRun=oe.Xa)(n,l,f,b,C,k,V,F),d._OrtEndProfiling=n=>(d._OrtEndProfiling=oe.Ya)(n),d._JsepOutput=(n,l,f)=>(d._JsepOutput=oe.Za)(n,l,f),d._JsepGetNodeName=n=>(d._JsepGetNodeName=oe._a)(n);var pn=d._pthread_self=()=>(pn=d._pthread_self=oe.$a)(),mn=d._malloc=n=>(mn=d._malloc=oe.ab)(n),At=d._free=n=>(At=d._free=oe.bb)(n);d.__emscripten_tls_init=()=>(d.__emscripten_tls_init=oe.cb)();var hi=d.__emscripten_thread_init=(n,l,f,b,C,k)=>(hi=d.__emscripten_thread_init=oe.eb)(n,l,f,b,C,k);d.__emscripten_thread_crashed=()=>(d.__emscripten_thread_crashed=oe.fb)();var gi=(n,l,f,b,C)=>(gi=oe.gb)(n,l,f,b,C),ro=n=>(ro=oe.hb)(n),no=d.__emscripten_thread_exit=n=>(no=d.__emscripten_thread_exit=oe.ib)(n),yi=()=>(yi=oe.jb)(),bi=(n,l)=>(bi=oe.kb)(n,l),fn=n=>(fn=oe.lb)(n),oo=n=>(oo=oe.mb)(n),io=()=>(io=oe.nb)(),wi=d.dynCall_ii=(n,l)=>(wi=d.dynCall_ii=oe.pb)(n,l),vi=n=>(vi=oe.qb)(n),$i=()=>($i=oe.rb)(),_i=n=>(_i=oe.sb)(n),Si=()=>(Si=oe.tb)();d.___start_em_js=839500,d.___stop_em_js=839661;function rl(){var n=oe;n=Object.assign({},n);var l=b=>C=>b(C)>>>0,f=b=>()=>b()>>>0;return n.wa=l(n.wa),n.$a=f(n.$a),n.ab=l(n.ab),n.emscripten_main_runtime_thread_id=f(n.emscripten_main_runtime_thread_id),n.mb=l(n.mb),n.nb=f(n.nb),n}d.wasmMemory=ae,d.stackSave=()=>io(),d.stackRestore=n=>fn(n),d.stackAlloc=n=>oo(n),d.keepRuntimeAlive=()=>0<bt,d.UTF8ToString=He,d.stringToUTF8=Bt,d.lengthBytesUTF8=gt,d.ExitStatus=st,d.PThread=ge;var hn;jt=function n(){hn||xi(),hn||(jt=n)};function xi(){if(!(0<Vt))if(O)y(d),O||Yt(Rt),startWorker(d);else{if(d.preRun)for(typeof d.preRun=="function"&&(d.preRun=[d.preRun]);d.preRun.length;)mt.unshift(d.preRun.shift());Yt(mt),0<Vt||hn||(hn=!0,d.calledRun=!0,me||(O||Yt(Rt),y(d),O||Yt(qt)))}}return xi(),_}})();typeof Di=="object"&&typeof mo=="object"?mo.exports=Bi:typeof define=="function"&&define.amd&&define([],()=>Bi)});var Mi=Wr((gm,cl)=>{cl.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(...e){var a=e.join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,a+`\\n`);return}console.error(a)}function threadAlert(...e){var a=e.join(" ");postMessage({cmd:"alert",text:a,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,a)=>{var r=Module.wasmModule;Module.wasmModule=null;var t=new WebAssembly.Instance(r,e);return a(t)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let r=[];self.onmessage=t=>r.push(t),self.startWorker=t=>{Module=t,postMessage({cmd:"loaded"});for(let s of r)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const t of e.data.handlers)Module[t]=(...s)=>{postMessage({cmd:"callHandler",handler:t,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var a=URL.createObjectURL(e.data.urlOrBlob);importScripts(a),URL.revokeObjectURL(a)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(r){if(r!="unwind")throw r}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(r){throw Module.__emscripten_thread_crashed?.(),r}}self.onmessage=handleMessage;\\n\'});var go,Gt,tr,bn,Gr,Hi,yo,ye=Y(()=>{"use strict";go=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Gt=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},tr=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],bn=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Gr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Hi=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool",yo=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var wn=Y(()=>{"use strict"});var Fi=Y(()=>{"use strict";wn()});var qi,ji=Y(()=>{"use strict";qi="1.18.0"});var Ki,pt,bo=Y(()=>{"use strict";ji();Ki="warning",pt={wasm:{},webgl:{},webgpu:{},versions:{common:qi},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Ki=e}},get logLevel(){return Ki}};Object.defineProperty(pt,"logLevel",{enumerable:!0})});var vr,Yi=Y(()=>{"use strict";bo();vr=pt});var Zi=Y(()=>{"use strict"});var Xi=Y(()=>{"use strict";vn()});var Ji=Y(()=>{"use strict"});var ea=Y(()=>{"use strict";vn()});var vn=Y(()=>{"use strict";Zi();Xi();Ji();ea()});var $n=Y(()=>{"use strict";vn()});var wo,ta,rr,Ht,vo=Y(()=>{"use strict";bo();wo=(e,t)=>{(typeof pt.trace>"u"?!pt.wasm.trace:!pt.trace)||console.timeStamp(`${e}::ORT::${t}`)},ta=(e,t)=>{let r=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],o=!1;for(let i=0;i<r.length;i++){if(o&&!r[i].includes("TRACE_FUNC")){let u=`FUNC_${e}::${r[i].trim().split(" ")[1]}`;t&&(u+=`::${t}`),wo("CPU",u);return}r[i].includes("TRACE_FUNC")&&(o=!0)}},rr=e=>{(typeof pt.trace>"u"?!pt.wasm.trace:!pt.trace)||ta("BEGIN",e)},Ht=e=>{(typeof pt.trace>"u"?!pt.wasm.trace:!pt.trace)||ta("END",e)}});var ra=Y(()=>{"use strict";wn();$n();vo()});var na=Y(()=>{"use strict";ra()});var oa=Y(()=>{"use strict"});var ia=Y(()=>{"use strict"});var aa=Y(()=>{"use strict"});var sa=Y(()=>{"use strict"});var ua=Y(()=>{"use strict";wn();$n()});var da=Y(()=>{"use strict";ua()});var $r=Y(()=>{"use strict";Fi();Yi();na();$n();oa();ia();vo();aa();sa();da()});var _l,Sl,la,ca,pa,xl,Ve,Lt=Y(()=>{"use strict";ye();_l=["V","I","W","E","F"],Sl=(e,t)=>{console.log(`[${_l[e]},${new Date().toISOString()}]${t}`)},pa=(e,t)=>{la=e,ca=t},xl=(e,t)=>{let r=Gr(e),o=Gr(la);r>=o&&Sl(r,typeof t=="function"?t():t)},Ve=(...e)=>{ca&&xl(...e)}});var ma,fa=Y(()=>{"use strict";ye();ma=(e,t)=>new(bn(t))(e)});var _n=Y(()=>{"use strict"});var ha,$o,_o,Cl,Al,ga,xo,So,ba,wa=Y(()=>{"use strict";Lt();_n();ha=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),$o=[],_o=e=>Math.ceil(e/16)*16,Cl=e=>{for(let t=0;t<$o.length;t++){let r=$o[t];if(e<=r)return r}return Math.ceil(e/16)*16},Al=1,ga=()=>Al++,xo=async(e,t,r,o)=>{let i=_o(r),u=e.device.createBuffer({size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let a=e.getCommandEncoder();e.endComputePass(),a.copyBufferToBuffer(t,0,u,0,i),e.flush(),await u.mapAsync(GPUMapMode.READ);let c=u.getMappedRange();if(o){let p=o();return p.set(new Uint8Array(c,0,r)),p}else return new Uint8Array(c.slice(0,r))}finally{u.destroy()}},So=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map,this.capturedPendingBuffers=new Map;for(let[r]of ha)$o.push(r),this.freeBuffers.set(r,[]),this.freeUniformBuffers.set(r,[])}upload(t,r){let o=r.buffer,i=r.byteOffset,u=r.byteLength,a=_o(u),c=this.storageCache.get(t);if(!c)throw new Error("gpu data for uploading does not exist");if(c.originalSize!==u)throw new Error(`inconsistent data size. gpu data size=${c.originalSize}, data size=${u}`);let p=this.backend.device.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),h=p.getMappedRange();new Uint8Array(h).set(new Uint8Array(o,i,u)),p.unmap();let d=this.backend.getCommandEncoder();this.backend.endComputePass(),d.copyBufferToBuffer(p,0,c.gpuData.buffer,0,a),Ve("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(p)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let i=this.storageCache.get(r);if(!i)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==i.originalSize)throw new Error("inconsistent source and destination gpu data size");let u=_o(o.originalSize),a=this.backend.getCommandEncoder();this.backend.endComputePass(),a.copyBufferToBuffer(o.gpuData.buffer,0,i.gpuData.buffer,0,u)}registerExternalBuffer(t,r,o){let i;if(o){if(i=this.externalBuffers.get(o),i===void 0)throw new Error("previous buffer is not registered");if(t===o)return Ve("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${i}, buffer is the same, skip.`),i;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!`);this.externalBuffers.delete(o)}else i=ga();return this.storageCache.set(i,{gpuData:{id:i,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,i),Ve("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${i}, registered.`),i}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Ve("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Cl(t),i,u=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,a=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(u||a){let h=(u?this.freeBuffers:this.freeUniformBuffers).get(o);h?h.length>0?i=h.pop():i=this.backend.device.createBuffer({size:o,usage:r}):i=this.backend.device.createBuffer({size:o,usage:r})}else i=this.backend.device.createBuffer({size:o,usage:r});let c={id:ga(),type:0,buffer:i};return this.storageCache.set(c.id,{gpuData:c,originalSize:t}),Ve("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${c.id}`),c}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Ve("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await xo(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let t of this.buffersPending){let r=ha.get(t.size);if((t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let o=this.freeBuffers.get(t.size)||[];r===void 0||o.length>=r?t.destroy():o.push(t)}else if((t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let o=this.freeUniformBuffers.get(t.size)||[];r===void 0||o.length>=r?t.destroy():o.push(t)}else t.destroy()}this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let r of this.buffersPending)t.push(r);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onReleaseSession(t){let r=this.capturedPendingBuffers.get(t);r&&(r.forEach(o=>{o.destroy()}),this.capturedPendingBuffers.delete(t))}},ba=(...e)=>new So(...e)});var Co,ve,Ze=Y(()=>{"use strict";Co=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},ve=e=>new Co(e)});var Ao,It,M,nr,Sn,xn,Cn,Se=Y(()=>{"use strict";Ao=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},It=class{static calcShape(t,r,o=!1){let i=t.length,u=r.length;if(i===0)return r;if(u===0)return t;let a=Math.max(t.length,r.length),c=new Array(a);if(o){if(i<2||u<2)return;let p=Ao.calcMatMulShape([t[i-2],t[i-1]],[r[u-2],r[u-1]]);if(p===void 0)return;[c[a-2],c[a-1]]=p}for(let p=o?3:1;p<=a;p++){let h=i-p<0?1:t[i-p],d=u-p<0?1:r[u-p];if(h!==d&&h>1&&d>1)return;let y=Math.max(h,d);if(h&&d)c[a-p]=Math.max(h,d);else{if(y>1)return;c[a-p]=0}}return c}static isValidBroadcast(t,r){let o=t.length,i=r.length;if(o>i)return!1;for(let u=1;u<=o;u++)if(t[o-u]!==1&&t[o-u]!==r[i-u])return!1;return!0}},M=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,r=4){let o=t.length;if(o===0)return[];let i=new Array(o),u=o-1;for(;u>=0;){if(t[u]%r===0){i[u]=t[u]/r;break}if(r%t[u]!==0)throw new Error("cannot convert shape");i[u]=1,r/=t[u],u--}for(u--;u>=0;u--)i[u]=t[u];return i}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let i=1;for(let u=r;u<o;u++){if(t[u]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");i*=t[u]}return i}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let i=r-3;i>=0;--i)o[i]=o[i+1]*t[i+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((i,u)=>i+r[u]+r[u+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,i)=>o===r[i])}},nr=class e{static adjustPoolAttributes(t,r,o,i,u,a){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let c=0;c<r.length-2;c++)c>=o.length?o.push(r[c+2]):o[c]=r[c+2];for(let c=0;c<o.length;c++)if(c<i.length){if(i[c]<0)throw new Error("strides should be greater than or equal to 1")}else i.push(1);for(let c=0;c<o.length;c++)if(c<u.length){if(u[c]<0)throw new Error("dilations should be greater than or equal to 1")}else u.push(1);for(let c=0;c<o.length*2;c++)if(c<a.length){if(a[c]<0)throw new Error("pad should be greater than or equal to 1")}else a.push(0);for(let c=0;c<o.length;c++){if(o[c]<=0)throw new Error("kernel shapes need to be greater than 0");if(a[c]>=o[c]||a[c+o.length]>=o[c])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,i,u,a,c){if(c){if(u.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(i.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let p=0;p<t.length-2;p++)e.adjustPadAndReturnShape(t[p+(a?1:2)],r[p],o[p],i[p],u,p,p+t.length-2,c)}}static computePoolOutputShape(t,r,o,i,u,a,c){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let p=[r[0],r[1]];return e.computeShapeHelper(t,r,p,o,i,u,a,c),p}static computeConvOutputShape(t,r,o,i,u,a,c){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let p=[t[0],r[0]];return e.computeShapeHelper(!1,t,p,o,i,u,a,c),p}static computeShapeHelper(t,r,o,i,u,a,c,p){if(t)for(let h=0;h<r.length-2;h++)o.push(1);else for(let h=0;h<r.length-2;h++)o.push(e.adjustPadAndReturnShape(r[h+2],i[h],u[h],a[h],c,h,h+r.length-2,p))}static adjustPadAndReturnShape(t,r,o,i,u,a,c,p){let h=o*(i-1)+1;if(p&&p!=="NOTSET")switch(p){case"VALID":return u[a]=0,u[c]=0,Math.floor((t-h)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let y=((t+r-1)/r-1)*r+i-t;return u[a]=Math.floor(p==="SAME_LOWER"?(y+1)/2:y/2),u[c]=y-u[a],Math.floor((t+y-i)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+u[a]+u[c]-h)/r+1)}},Sn=class{static getShapeOfGemmResult(t,r,o,i,u){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let a,c,p;r?(a=t[1],c=t[0]):(a=t[0],c=t[1]);let h=-1;if(i?(p=o[0],h=1):(p=o[1],h=0),o[h]!==c)throw new Error("dimension mismatch");if(a<=0||p<=0||c<=0)throw new Error("invalid shape specified");if(u&&!It.isValidBroadcast(u,[a,p]))throw new Error("gemm: invalid bias shape for broadcast");return[a,p,c]}},xn=-34028234663852886e22,Cn=34028234663852886e22});var or,To,De,et,Z,Me,$t,ir,_t,fe,Eo,U,j,An,Io,va,_r,_e=Y(()=>{"use strict";ye();Se();or=64,To=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},De=(e,t=1)=>{let r=To(e,t);return typeof r=="string"?r:r[0]},et=(e,t=1)=>{let r=To(e,t);return typeof r=="string"?r:r[1]},Z=(...e)=>{let t=[];return e.forEach(r=>{r.length!==0&&t.push({type:12,data:r},{type:12,data:M.computeStrides(r)})}),t},Me=e=>e%4===0?4:e%2===0?2:1,$t=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,ir=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}<f32>(${r})`,_t=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,fe=(e,t,r,o)=>e.startsWith("uniforms.")&&r>4?typeof t=="string"?o==="f16"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:o==="f16"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,Eo=(e,t,r,o,i)=>{let u=typeof r=="number",a=u?r:r.length,c=[...new Array(a).keys()],p=a<2?"u32":a<=4?`vec${a}<u32>`:`array<u32, ${a}>`,h=To(t,i),d=typeof h=="string"?h:h[1],y=typeof h=="string"?h:h[0],w={indices:p,value:d,storage:y,tensor:t},_=G=>typeof G=="string"?G:`${G}u`,v={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},S=u?"uniforms.":"",A=`${S}${e}_shape`,I=`${S}${e}_strides`,x="";for(let G=0;G<a-1;G++)x+=`\n    let dim${G} = current / ${fe(I,G,a)};\n    let rest${G} = current % ${fe(I,G,a)};\n    indices[${G}] = dim${G};\n    current = rest${G};\n    `;x+=`indices[${a-1}] = current;`;let E=a<2?"":`\n  fn o2i_${e}(offset: u32) -> ${w.indices} {\n    var indices: ${w.indices};\n    var current = offset;\n    ${x}\n    return indices;\n  }`,P=G=>(v.offsetToIndices=!0,a<2?G:`o2i_${e}(${G})`),O=[];if(a>=2)for(let G=a-1;G>=0;G--)O.push(`${fe(I,G,a)} * (indices[${G}])`);let R=a<2?"":`\n  fn i2o_${e}(indices: ${w.indices}) -> u32 {\n    return ${O.join("+")};\n  }`,L=G=>(v.indicesToOffset=!0,a<2?G:`i2o_${e}(${G})`),N=(...G)=>a===0?"0u":`${w.indices}(${G.map(_).join(",")})`,K=(G,ne)=>a<2?`${G}`:`${fe(G,ne,a)}`,Q=(G,ne,xe)=>a<2?`${G}=${xe};`:`${fe(G,ne,a)}=${xe};`,he={},W=(G,ne)=>{v.broadcastedIndicesToOffset=!0;let xe=`${ne.name}broadcastedIndicesTo${e}Offset`;if(xe in he)return`${xe}(${G})`;let Ke=[];for(let Be=a-1;Be>=0;Be--){let Ge=ne.indicesGet("outputIndices",Be+ne.rank-a);Ke.push(`${K(I,Be)} * (${Ge} % ${K(A,Be)})`)}return he[xe]=`fn ${xe}(outputIndices: ${ne.type.indices}) -> u32 {\n             return ${Ke.length>0?Ke.join("+"):"0u"};\n           }`,`${xe}(${G})`},se=(G,ne)=>(()=>{if(w.storage===w.value)return`${e}[${G}]=${ne};`;if(w.storage==="vec2<u32>"&&w.value==="i32")return`${e}[${G}]=vec2<u32>(u32(${ne}), select(0u, 0xFFFFFFFFu, ${ne} < 0));`;if(w.storage==="vec2<u32>"&&w.value==="u32")return`${e}[${G}]=vec2<u32>(u32(${ne}), 0u);`;if(w.storage==="u32"&&w.value==="vec4<bool>")return`${e}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${ne}));`;throw new Error(`not supported combination of storage type ${w.storage} and value type ${w.value} yet`)})(),Ce=G=>(()=>{if(w.storage===w.value)return`${e}[${G}]`;if(w.storage==="vec2<u32>"&&w.value==="i32")return`i32(${e}[${G}].x)`;if(w.storage==="vec2<u32>"&&w.value==="u32")return`u32(${e}[${G}].x)`;if(w.storage==="u32"&&w.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${G}] & 0xFFu), bool(${e}[${G}] & 0xFF00u), bool(${e}[${G}] & 0xFF0000u), bool(${e}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${w.storage} and value type ${w.value} yet`)})(),We=a<2?"":`\n  fn get_${e}ByIndices(indices: ${w.indices}) -> ${d} {\n    return ${Ce(`i2o_${e}(indices)`)};\n  }`,ee=a<2?"":(()=>{let G=c.map(xe=>`d${xe}: u32`).join(", "),ne=c.map(xe=>`d${xe}`).join(", ");return`\n  fn get_${e}(${G}) -> ${d} {\n    return get_${e}ByIndices(${N(ne)});\n  }`})(),ae=(...G)=>{if(G.length!==a)throw new Error(`indices length must be ${a}`);let ne=G.map(_).join(",");return a===0?Ce("0u"):a===1?Ce(ne[0]):(v.get=!0,v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}(${ne})`)},Ae=G=>a<2?Ce(G):(v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}ByIndices(${G})`),me=a<2?"":`\n  fn set_${e}ByIndices(indices: ${w.indices}, value: ${d}) {\n    ${se(`i2o_${e}(indices)`,"value")}\n  }`,ie=a<2?"":(()=>{let G=c.map(xe=>`d${xe}: u32`).join(", "),ne=c.map(xe=>`d${xe}`).join(", ");return`\n  fn set_${e}(${G}, value: ${d}) {\n    set_${e}ByIndices(${N(ne)}, value);\n  }`})();return{impl:()=>{let G=[],ne=!1;return v.offsetToIndices&&(G.push(E),ne=!0),v.indicesToOffset&&(G.push(R),ne=!0),v.broadcastedIndicesToOffset&&(Object.values(he).forEach(xe=>G.push(xe)),ne=!0),v.set&&(G.push(ie),ne=!0),v.setByIndices&&(G.push(me),ne=!0),v.get&&(G.push(ee),ne=!0),v.getByIndices&&(G.push(We),ne=!0),!u&&ne&&G.unshift(`const ${A} = ${w.indices}(${r.join(",")});`,`const ${I} = ${w.indices}(${M.computeStrides(r).join(",")});`),G.join(`\n`)},type:w,offsetToIndices:P,indicesToOffset:L,broadcastedIndicesToOffset:W,indices:N,indicesGet:K,indicesSet:Q,set:(...G)=>{if(G.length!==a+1)throw new Error(`indices length must be ${a}`);let ne=G[a];if(typeof ne!="string")throw new Error("value must be string");let xe=G.slice(0,a).map(_).join(",");return a===0?se("0u",ne):a===1?se(xe[0],ne):(v.set=!0,v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}(${xe}, ${ne})`)},setByOffset:se,setByIndices:(G,ne)=>a<2?se(G,ne):(v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}ByIndices(${G}, ${ne});`),get:ae,getByOffset:Ce,getByIndices:Ae,usage:o,name:e,strides:I,shape:A,rank:a}},U=(e,t,r,o=1)=>Eo(e,t,r,"input",o),j=(e,t,r,o=1)=>Eo(e,t,r,"output",o),An=(e,t,r,o=1)=>Eo(e,t,r,"internal",o),Io=class{constructor(t,r){this.normalizedDispatchGroup=t;this.limits=r;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=or){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],i=typeof t=="number"?1:t[2];if(r>this.limits.maxComputeWorkgroupSizeX||o>this.limits.maxComputeWorkgroupSizeY||i>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${r}, ${o}, ${i}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(r*o*i>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${r}, ${o}, ${i}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let u=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,a=u?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,c=u?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*o*i}u + local_idx;`;return`@compute @workgroup_size(${r}, ${o}, ${i})\n  fn main(${a}) {\n    ${c}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,r){if(t.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);let o=t.usage==="input"?"read":"read_write",i=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${i}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(r=>this.registerInternalVariable(r)),this}registerUniform(t,r,o=1){return this.uniforms.push({name:t,type:r,length:o}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o,length:i}of this.uniforms)if(i&&i>4)o==="f16"?t.push(`@align(16) ${r}:array<mat2x4<${o}>, ${Math.ceil(i/8)}>`):t.push(`${r}:array<vec4<${o}>, ${Math.ceil(i/4)}>`);else{let u=i==null||i===1?o:`vec${i}<${o}>`;t.push(`${r}:${u}`)}return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}get variablesInfo(){if(this.uniforms.length===0)return;let t=r=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(r)];return this.uniforms.map(r=>[t(r.type),r.length??1])}},va=(e,t)=>new Io(e,t),_r=(e,t)=>{let r=e.length,o=[];for(let i=0;i<r;i++){let u=r-1-i,a=e[u]||1;(t[t.length-1-i]||1)>1&&a===1&&o.unshift(u)}return o}});var Il,$a,Tl,El,yt,_a,Sa,Sr=Y(()=>{"use strict";ye();Se();Ze();_e();Il=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},$a=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Tl=(e,t)=>M.sortBasedOnPerm(e,$a(e.length,t)),El=(e,t,r,o)=>{let i=[];i.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let u=0;u<t;++u)i.push(r.indicesSet("a",e[u],`i[${u}]`));return i.push("return a;}"),i.join(`\n`)},yt=(e,t)=>{let r=e.dataType,o=e.dims.length,i=$a(o,t),u=Tl(e.dims,i),a=j("output",r,u.length),c=U("a",r,o),p=h=>`\n  ${h.registerUniform("output_size","u32").declareVariables(c,a)}\n\n  ${El(i,o,c,a)}\n\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${a.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${a.setByOffset("global_idx",c.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:h=>{let d=M.size(u);return{outputs:[{dims:u,dataType:h[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},...Z(h[0].dims,u)]}},getShaderSource:p}},_a=(e,t)=>{Il(e.inputs),e.compute(yt(e.inputs[0],t.perm))},Sa=e=>ve({perm:e.perm})});var Pl,kl,Ol,Rl,Bl,Dl,zl,Ml,Ul,Vl,Tt,xa,Ca,Aa,Ia,Ta,Ea,Pa,ka,Oa,Ra,Ba=Y(()=>{"use strict";ye();Se();_e();In();Sr();Pl={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},kl={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Ol={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Rl={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Bl=(e,t)=>{let r=[];for(let o=t-e;o<t;++o)r.push(o);return r},Dl=(e,t)=>{let r=[],o=e.length;for(let u=0;u<o;u++)t.indexOf(u)===-1&&r.push(e[u]);let i=t.map(u=>e[u]);return[r,i]},zl=(e,t)=>{let r=e.length+t.length,o=[],i=0;for(let u=0;u<r;u++)t.indexOf(u)===-1?o.push(e[i++]):o.push(1);return o},Ml=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},Ul=(e,t)=>{let r=[];if(!Ml(e,t)){for(let o=0;o<t;++o)e.indexOf(o)===-1&&r.push(o);e.forEach(o=>r.push(o))}return r},Vl=(e,t,r,o,i,u,a)=>{let c=r[0].dims,p=M.size(u),h=M.size(a),d=U("_A",r[0].dataType,c),y=j("output",i,u),w=32,_=`\n          var<workgroup> aBestValues : array<f32, ${w}>;\n       `;return{name:e,shaderCache:t,getShaderSource:S=>`\n        ${S.registerUniform("reduceSize","u32").declareVariables(d,y)}\n        ${_}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${S.mainStart(w)}\n\n          let outputIndex = global_idx / ${w};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${Ol[o]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${w}) {\n           let candidate = f32(${d.getByOffset("offset + k")});\n           bestValue = ${Pl[o]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${w}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${kl[o]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${y.setByOffset("outputIndex",`${o==="mean"?`${y.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${y.type.storage}(${Rl[o]})`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:p},programUniforms:[{type:12,data:h}]})}},Tt=(e,t,r,o)=>{let i=e.inputs.length===1?r:Po(e.inputs,r),u=i.axes;u.length===0&&!i.noopWithEmptyAxes&&(u=e.inputs[0].dims.map((_,v)=>v));let a=M.normalizeAxes(u,e.inputs[0].dims.length),c=a,p=e.inputs[0],h=Ul(c,e.inputs[0].dims.length);h.length>0&&(p=e.compute(yt(e.inputs[0],h),{inputs:[0],outputs:[-1]})[0],c=Bl(c.length,p.dims.length));let[d,y]=Dl(p.dims,c),w=d;i.keepDims&&(w=zl(d,a)),e.compute(Vl(t,{hint:i.cacheKey,inputDependencies:["type"]},[p],o,e.inputs[0].dataType,w,y),{inputs:[p]})},xa=(e,t)=>{Tt(e,"ReduceMeanShared",t,"mean")},Ca=(e,t)=>{Tt(e,"ReduceL1Shared",t,"l1")},Aa=(e,t)=>{Tt(e,"ReduceL2Shared",t,"l2")},Ia=(e,t)=>{Tt(e,"ReduceLogSumExpShared",t,"logSumExp")},Ta=(e,t)=>{Tt(e,"ReduceMaxShared",t,"max")},Ea=(e,t)=>{Tt(e,"ReduceMinShared",t,"min")},Pa=(e,t)=>{Tt(e,"ReduceProdShared",t,"prod")},ka=(e,t)=>{Tt(e,"ReduceSumShared",t,"sum")},Oa=(e,t)=>{Tt(e,"ReduceSumSquareShared",t,"sumSquare")},Ra=(e,t)=>{Tt(e,"ReduceLogSumShared",t,"logSum")}});var Et,Wl,Tn,Po,Pt,Nl,Gl,Hl,Ll,Fl,ql,jl,Kl,Yl,Zl,kt,Da,za,Ma,Ua,Va,Wa,Na,Ga,Ha,La,In=Y(()=>{"use strict";ye();Se();Ze();_e();Ba();Et=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Wl=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],Tn=(e,t,r,o,i,u,a=!1,c=!1)=>{let p=[],h=r[0].dims,d=h.length,y=M.normalizeAxes(i,d),w=!c&&y.length===0;h.forEach((A,I)=>{w||y.indexOf(I)>=0?a&&p.push(1):p.push(A)});let _=p.length,v=M.size(p);return{name:e,shaderCache:t,getShaderSource:A=>{let I=[],x=U("_A",r[0].dataType,d),E=j("output",u,_),P=o(x,E,y),O=P[2];for(let R=0,L=0;R<d;R++)w||y.indexOf(R)>=0?(a&&L++,O=`for(var j${R}: u32 = 0; j${R} < ${h[R]}; j${R}++) {\n                  ${P[2].includes("last_index")?`let last_index = j${R};`:""}\n                  ${x.indicesSet("input_indices",R,`j${R}`)}\n                  ${O}\n                }`):(I.push(`${x.indicesSet("input_indices",R,E.indicesGet("output_indices",L))};`),L++);return`\n\n        ${A.registerUniform("output_size","u32").declareVariables(x,E)}\n\n        ${A.mainStart()}\n          ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${x.type.indices};\n          let output_indices = ${E.offsetToIndices("global_idx")};\n\n          ${I.join(`\n`)}\n          ${P[0]}       // init ops for reduce max/min\n          ${P[1]}\n          ${O}\n          ${P[3]}\n          ${P.length===4?E.setByOffset("global_idx","value"):P.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:p,dataType:u}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:[{type:12,data:v},...Z(h,p)]})}},Po=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),ve({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},Pt=(e,t,r,o)=>{let i=e.inputs,u=i.length===1?r:Po(i,r);e.compute(Tn(t,{hint:u.cacheKey,inputDependencies:["rank"]},[i[0]],u.noopWithEmptyAxes&&u.axes.length===0?Wl:o,u.axes,i[0].dataType,u.keepDims,u.noopWithEmptyAxes),{inputs:[0]})},Nl=(e,t)=>{Et(e.inputs),Pt(e,"ReduceLogSum",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,"value = log(value);"])},Gl=(e,t)=>{Et(e.inputs),Pt(e,"ReduceL1",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += abs(${o.getByIndices("input_indices")});`,""])},Hl=(e,t)=>{Et(e.inputs),Pt(e,"ReduceL2",t,(o,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Ll=(e,t)=>{Et(e.inputs),Pt(e,"ReduceLogSumExp",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += exp(${o.getByIndices("input_indices")});`,"value = log(value);"])},Fl=(e,t)=>{Et(e.inputs),Pt(e,"ReduceMax",t,(o,i,u)=>{let a=[];for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&a.push(o.indicesSet("input_indices",c,0));return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = max(value, ${o.getByIndices("input_indices")});`,""]})},ql=(e,t)=>{Et(e.inputs),Pt(e,"ReduceMean",t,(o,i,u)=>{let a=1;for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&(a*=e.inputs[0].dims[c]);return["var sum = f32(0);","",`sum += f32(${o.getByIndices("input_indices")});`,`let value = ${i.type.value}(sum / ${a});`]})},jl=(e,t)=>{Et(e.inputs),Pt(e,"ReduceMin",t,(o,i,u)=>{let a=[];for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&a.push(`input_indices[${c}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = min(value, ${o.getByIndices("input_indices")});`,""]})},Kl=(e,t)=>{Et(e.inputs),Pt(e,"ReduceProd",t,(o,i)=>[`var value = ${i.type.storage}(1);`,"",`value *= ${o.getByIndices("input_indices")};`,""])},Yl=(e,t)=>{Et(e.inputs),Pt(e,"ReduceSum",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,""])},Zl=(e,t)=>{Et(e.inputs),Pt(e,"ReduceSumSquare",t,(o,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += t * t;`,""])},kt=(e,t,r)=>{if(t.length===0)return r;let o=1,i=1;for(let u=0;u<t.length;u++)t.indexOf(u)===-1?o*=e[u]:i*=e[u];return i<32&&o>1024},Da=(e,t)=>{kt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ql(e,t):xa(e,t)},za=(e,t)=>{kt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Gl(e,t):Ca(e,t)},Ma=(e,t)=>{kt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Hl(e,t):Aa(e,t)},Ua=(e,t)=>{kt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ll(e,t):Ia(e,t)},Va=(e,t)=>{kt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Fl(e,t):Ta(e,t)},Wa=(e,t)=>{kt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?jl(e,t):Ea(e,t)},Na=(e,t)=>{kt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Kl(e,t):Pa(e,t)},Ga=(e,t)=>{kt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Yl(e,t):ka(e,t)},Ha=(e,t)=>{kt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Zl(e,t):Oa(e,t)},La=(e,t)=>{kt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Nl(e,t):Ra(e,t)}});var Fa,qa,ja,ko,Ka=Y(()=>{"use strict";ye();Ze();In();Fa=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},qa=(e,t)=>{Fa(e.inputs);let r=(o,i,u)=>{let a=[];for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&a.push(`input_indices[${c}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",i.setByOffset("global_idx","best_index")]};e.compute(Tn("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},ja=(e,t)=>{Fa(e.inputs);let r=(o,i,u)=>{let a=[];for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&a.push(`input_indices[${c}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",i.setByOffset("global_idx","best_index")]};e.compute(Tn("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},ko=e=>ve(e)});var Xl,Ql,Jl,En,Ya,Za,Oo=Y(()=>{"use strict";ye();Se();Ze();_e();Xl=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let r=0,o=e[r],i=o.dataType,u=o.dims.length;e.forEach((a,c)=>{if(c!==r){if(a.dataType!==i)throw new Error("input tensors should be one type");if(a.dims.length!==u)throw new Error("input tensors should have the same shape");a.dims.forEach((p,h)=>{if(h!==t&&p!==o.dims[h])throw new Error("non concat dimensions must match")})}})},Ql=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Jl=(e,t)=>{let r=e.length,o=[];for(let i=0;i<r;++i){let u=t.setByOffset("global_idx",e[i].getByIndices("indices"));r===1?o.push(u):i===0?o.push(`if (inputIndex == ${i}u) { ${u} }`):i===r-1?o.push(`else { ${u} }`):o.push(`else if (inputIndex == ${i}) { ${u} }`)}return o.join(`\n`)},En=(e,t,r,o)=>{let i=M.size(r),u=new Array(e.length),a=new Array(e.length),c=0,p=[],h=[],d=[{type:12,data:i}];for(let S=0;S<e.length;++S)c+=e[S].dims[t],u[S]=c,h.push(e[S].dims.length),a[S]=U(`input${S}`,o,h[S]),p.push("rank"),d.push({type:12,data:u[S]});for(let S=0;S<e.length;++S)d.push(...Z(e[S].dims));d.push(...Z(r));let y=j("output",o,r.length),w=y.indicesGet("indices",t),_=Array.from(Array(u.length).keys()).map(S=>`uniforms.sizeInConcatAxis${S}`).join(","),v=S=>`\n\n  ${(()=>{S.registerUniform("outputSize","u32");for(let A=0;A<e.length;A++)S.registerUniform(`sizeInConcatAxis${A}`,"u32");return S.declareVariables(...a,y)})()}\n\n  ${Ql(u.length,_)}\n\n  ${S.mainStart()}\n    ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${y.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${w});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${u.length}u>(${_});\n      ${w} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Jl(a,y)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:r,dataType:o}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:d}),getShaderSource:v}},Ya=(e,t)=>{let r=e.inputs,o=r[0].dims,i=M.normalizeAxis(t.axis,o.length);Xl(r,i);let u=o.slice();u[i]=r.reduce((c,p)=>c+(p.dims.length>i?p.dims[i]:0),0);let a=r.filter(c=>M.size(c.dims)>0);e.compute(En(a,i,u,r[0].dataType),{inputs:a})},Za=e=>ve({axis:e.axis})});var ec,tc,rc,nc,Pn,oc,Xa,Ro=Y(()=>{"use strict";ye();_n();_e();Oo();ec=(e,t)=>{let r=e[0],o=e[1],i=e[2],u=e[3],a=e[4],c=e[5];if(a&&c)throw new Error("Attention cannot have both past and relative_position_bias");if(r.dims.length!==3)throw new Error(\'Input "input" must have 3 dimensions\');let p=r.dims[0],h=r.dims[1],d=r.dims[2];if(i.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimensions\');if(o.dims.length!==2)throw new Error(\'Input "weights" is expected to have 2 dimensions\');if(o.dims[0]!==d)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(i.dims[0]!==o.dims[1])throw new Error(\'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"\');let y=i.dims[0]/3,w=y,_=w;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let E of t.qkvHiddenSizes)if(E%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");y=t.qkvHiddenSizes[0],w=t.qkvHiddenSizes[1],_=t.qkvHiddenSizes[2]}let v=h;if(y!==w)throw new Error("qkv_hidden_sizes first element should be same as the second");if(i.dims[0]!==y+w+_)throw new Error(\'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes\');let S=0;if(a){if(w!==_)throw new Error(\'Input "past" expect k_hidden_size == v_hidden_size\');if(a.dims.length!==5)throw new Error(\'Input "past" must have 5 dimensions\');if(a.dims[0]!==2)throw new Error(\'Input "past" first dimension must be 2\');if(a.dims[1]!==p)throw new Error(\'Input "past" second dimension must be batch_size\');if(a.dims[2]!==t.numHeads)throw new Error(\'Input "past" third dimension must be num_heads\');if(a.dims[4]!==w/t.numHeads)throw new Error(\'Input "past" fifth dimension must be k_hidden_size / num_heads\');t.pastPresentShareBuffer||(S=a.dims[3])}let A=v+S,I=-1,x=0;if(u)throw new Error("Mask not supported");if(a)throw new Error("past is not supported");return{batchSize:p,sequenceLength:h,pastSequenceLength:S,kvSequenceLength:v,totalSequenceLength:A,maxSequenceLength:I,inputHiddenSize:d,hiddenSize:y,vHiddenSize:_,headSize:Math.floor(y/t.numHeads),vHeadSize:Math.floor(_/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:x,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},tc=(e,t,r,o)=>{let i=Me(o),u=64,a=o/i;a<u?u=1:a/8<64&&(u=Math.ceil(a/8));let c=Math.ceil(o/i/u),p=[{type:t.dataType,data:1/o},{type:12,data:a},{type:12,data:c}],h=De(t.dataType,i),d=et(1,i),y=w=>{let _=j("x",t.dataType,t.dims,i),S=[{name:"d_inv",type:et(t.dataType)},{name:"d_comp",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`\n  var<workgroup> thread_max: array<f32, ${u}>;\n  var<workgroup> thread_sum: array<f32, ${u}>;\n  ${w.registerUniforms(S).declareVariables(_)}\n  ${w.mainStart([u,1,1])}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = workgroup_id.x * uniforms.d_comp + local_offset;\n\n    var thread_max_vector = ${d}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n      thread_max_vector = max(${d}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(i){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${i}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${u}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${d}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n      sum_vector += exp(${d}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(i){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${i}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${u}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n        x[offset + i] = ${_.type.value}(uniforms.d_inv);\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n        var f32input = ${d}(x[offset + i]);\n        x[offset + i] = ${_.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${u};${h};${i}`},getShaderSource:y,getRunData:()=>({outputs:[],dispatchGroup:{x:r},programUniforms:p})}},rc=(e,t,r,o,i,u,a)=>{let c=a+i.kvSequenceLength,p=[i.batchSize,i.numHeads,i.sequenceLength,c],h=u.scale===0?1/Math.sqrt(i.headSize):u.scale,d=Me(i.headSize),y=i.headSize/d,w=12,_={x:Math.ceil(c/w),y:Math.ceil(i.sequenceLength/w),z:i.batchSize*i.numHeads},v=[{type:12,data:i.sequenceLength},{type:12,data:y},{type:12,data:c},{type:12,data:i.numHeads},{type:1,data:h}],S=o?["type","type","type"]:["type","type"],A=I=>{let x=U("q",t.dataType,t.dims,d),E=U("key",r.dataType,r.dims,d),P=[x,E];o&&P.push(U("relative_position_bias",o.dataType,o.dims));let O=j("output",t.dataType,p),R=et(1,d),L=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"alpha",type:"f32"}];return`\n  const TILE_SIZE = ${w}u;\n\n  var<workgroup> tileQ: array<${x.type.storage}, ${w*w}>;\n  var<workgroup> tileK: array<${x.type.storage}, ${w*w}>;\n  ${I.registerUniforms(L).declareVariables(...P,O)}\n  ${I.mainStart([w,w,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;\n    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;\n\n    var value = ${R}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n        value += ${R}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = headIdx * uniforms.M * uniforms.N;\n    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(d){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${d}`)}})()};\n        output[outputIdx] = ${O.type.value} (sum * uniforms.alpha) + ${o?"relative_position_bias[outputIdx]":"0.0"};\n    }\n  }`};return{name:"AttentionProbs",shaderCache:{hint:`${d}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:p,dataType:t.dataType,gpuDataType:0}],dispatchGroup:_,programUniforms:v}),getShaderSource:A}},nc=(e,t,r,o,i)=>{let u=i+o.kvSequenceLength,a=[o.batchSize,o.sequenceLength,o.vHiddenSize],c=12,p={x:Math.ceil(o.vHeadSize/c),y:Math.ceil(o.sequenceLength/c),z:o.batchSize*o.numHeads},h=[{type:12,data:o.sequenceLength},{type:12,data:u},{type:12,data:o.vHeadSize},{type:12,data:o.numHeads},{type:12,data:o.vHiddenSize}];return{name:"AttentionScore",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType,gpuDataType:0}],dispatchGroup:p,programUniforms:h}),getShaderSource:w=>{let _=U("probs",t.dataType,t.dims),v=U("v",r.dataType,r.dims),S=j("output",t.dataType,a),A=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"}];return`\n  const TILE_SIZE = ${c}u;\n  var<workgroup> tileQ: array<${_.type.value}, ${c*c}>;\n  var<workgroup> tileK: array<${_.type.value}, ${c*c}>;\n  ${w.registerUniforms(A).declareVariables(_,v,S)}\n  ${w.mainStart([c,c,1])}\n   let headIdx = workgroup_id.z;\n   let m = global_id.y;\n   let n = global_id.x;\n\n   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;\n   let offsetB = headIdx * (uniforms.N * uniforms.K) + n;\n\n   var value = ${_.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n     if (m < uniforms.M && w + local_id.x < uniforms.K) {\n       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n     }\n     if (n < uniforms.N && w + local_id.y < uniforms.K) {\n       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * uniforms.N];\n     }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + currentBatchHeadNumber * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`}}},Pn=(e,t,r,o,i,u,a,c,p,h,d)=>{let y=e.outputCount>1,w=e.outputCount>2,_=y&&w?h.pastSequenceLength:0,v=_+h.kvSequenceLength,S=[h.batchSize,h.numHeads,v,h.headSize],A=a?[a,r]:[r],I=y?e.compute(En(A,2,S,r.dataType),{inputs:A,outputs:[1]})[0]:r,x=[h.batchSize,h.numHeads,v,h.headSize],E=c?[c,o]:[o],P=w?e.compute(En(E,2,x,o.dataType),{inputs:E,outputs:[2]})[0]:o,O=[t,I];p&&O.push(p);let R=e.compute(rc(e,t,I,p,h,d,_),{inputs:O,outputs:[-1]})[0];e.compute(tc(e,R,h.batchSize*h.numHeads*h.sequenceLength,v),{inputs:[R],outputs:[]});let L=[R,P];e.compute(nc(e,R,P,h,_),{inputs:L,outputs:[0]})},oc=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],o=t.sequenceLength,i=t.inputHiddenSize,u=t.headSize,a=12,c={x:Math.ceil(t.headSize/a),y:Math.ceil(t.sequenceLength/a),z:t.batchSize*t.numHeads},p=[e.inputs[0],e.inputs[1],e.inputs[2]],h=[{type:12,data:o},{type:12,data:i},{type:12,data:u},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],d=y=>{let w=j("output_q",p[0].dataType,r),_=j("output_k",p[0].dataType,r),v=j("output_v",p[0].dataType,r),S=U("input",p[0].dataType,p[0].dims),A=U("weight",p[1].dataType,p[1].dims),I=U("bias",p[2].dataType,p[2].dims),x=S.type.storage,E=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`\n  const TILE_SIZE = ${a}u;\n  var<workgroup> tileInput: array<${x}, ${a*a}>;\n  var<workgroup> tileWeightQ: array<${x}, ${a*a}>;\n  var<workgroup> tileWeightK: array<${x}, ${a*a}>;\n  var<workgroup> tileWeightV: array<${x}, ${a*a}>;\n  ${y.registerUniforms(E).declareVariables(S,A,I,w,_,v)}\n  ${y.mainStart([a,a,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${x}(0);\n    var valueK = ${x}(0);\n    var valueV = ${x}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`};return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:c,programUniforms:h}),getShaderSource:d},{inputs:p,outputs:[-1,-1,-1]})},Xa=(e,t)=>{let r=ec(e.inputs,t),[o,i,u]=oc(e,r);return Pn(e,o,i,u,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t)}});var ic,ac,sc,Qa,Ja=Y(()=>{"use strict";$r();ye();Se();Ze();_e();ic=(e,t)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let r=(o,i,u)=>{let a=i.length;if(a!==o.length)throw new Error(`${u}: num dimensions != ${a}`);i.forEach((c,p)=>{if(c!==o[p])throw new Error(`${u}: dim[${p}] do not match`)})};if(e[0].dims.length>1){let o=t.format==="NHWC"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,o,"Invalid input scale"),r(e[2].dims,o,"Invalid input B"),r(e[3].dims,o,"Invalid input mean"),r(e[4].dims,o,"Invalid input var")}else r(e[1].dims,[1],"Invalid input scale"),r(e[2].dims,[1],"Invalid input B"),r(e[3].dims,[1],"Invalid input mean"),r(e[4].dims,[1],"Invalid input var")},ac=(e,t)=>{let{epsilon:r,spatial:o,format:i}=t,u=e[0].dims,a=o?Me(u[u.length-1]):1,c=i==="NHWC"&&u.length>1?a:1,p=M.size(u)/a,h=o,d=h?u.length:u,y=U("x",e[0].dataType,e[0].dims,a),w=U("scale",e[1].dataType,e[1].dims,c),_=U("bias",e[2].dataType,e[2].dims,c),v=U("inputMean",e[3].dataType,e[3].dims,c),S=U("inputVar",e[4].dataType,e[4].dims,c),A=j("y",e[0].dataType,d,a),I=()=>{let E="";if(o)E=`let cOffset = ${u.length===1?"0u":i==="NHWC"?`outputIndices[${u.length-1}] / ${a}`:"outputIndices[1]"};`;else if(i==="NCHW")E=`\n            ${A.indicesSet("outputIndices","0","0")}\n            let cOffset = ${A.indicesToOffset("outputIndices")};`;else{E=`var cIndices = ${w.type.indices}(0);\n                       cIndices[0] = outputIndices[${u.length-1}];`;for(let P=1;P<w.rank;P++)E+=`cIndices[${P}] = outputIndices[${P}];`;E+=`let cOffset = ${w.indicesToOffset("cIndices")};`}return E},x=E=>`\n  const epsilon = ${r};\n  ${E.registerUniform("outputSize","u32").declareVariables(y,w,_,v,S,A)}\n  ${E.mainStart()}\n  ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${A.offsetToIndices(`global_idx * ${a}`)};\n    ${I()}\n    let scale = ${w.getByOffset("cOffset")};\n    let bias = ${_.getByOffset("cOffset")};\n    let inputMean = ${v.getByOffset("cOffset")};\n    let inputVar = ${S.getByOffset("cOffset")};\n    let x = ${y.getByOffset("global_idx")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${A.setByOffset("global_idx","value")}\n  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${o}_${a}`,inputDependencies:h?["rank","type","type","type","type"]:void 0},getShaderSource:x,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:h?[{type:12,data:p},...Z(u)]:[{type:12,data:p}]})}},sc=e=>ve(e),Qa=(e,t)=>{let{inputs:r,outputCount:o}=e,i=sc({...t,outputCount:o});if(vr.webgpu.validateInputContent&&ic(r,i),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(ac(r,i))}});var uc,dc,es,ts=Y(()=>{"use strict";Se();_e();uc=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},dc=e=>{let t=e[0].dims,r=e[0].dims[2],o=M.size(t)/4,i=e[0].dataType,u=U("input",i,t,4),a=U("bias",i,[r],4),c=U("residual",i,t,4),p=j("output",i,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:d=>`\n  const channels = ${r}u / 4;\n  ${d.declareVariables(u,a,c,p)}\n\n  ${d.mainStart()}\n    ${d.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let value = ${u.getByOffset("global_idx")}\n      + ${a.getByOffset("global_idx % channels")} + ${c.getByOffset("global_idx")};\n    ${p.setByOffset("global_idx","value")}\n  }`}},es=e=>{uc(e.inputs),e.compute(dc(e.inputs))}});var lc,ke,rs,ns,os,is,as,ss,us,ds,ls,cc,cs,ps,ms,fs,kn,hs,On,gs,ys,bs,ws,vs,$s,_s,Ss,xs,Cs,As,Is,Ts,Es,Ps,ks,Os,Rs,Bo,Do,Bs,Ds,zs,Rn=Y(()=>{"use strict";ye();Se();Ze();_e();lc=(e,t,r,o,i,u)=>{let a=Math.ceil(t/4),c="";typeof i=="string"?c=`${i}(a)`:c=i("a");let p=U("inputData",r,[a],4),h=j("outputData",o,[a],4);return`\n      ${e.registerUniform("vec_size","u32").declareVariables(p,h)}\n\n  ${u??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${p.getByOffset("global_idx")};\n    ${h.setByOffset("global_idx",c)}\n  }`},ke=(e,t,r,o,i,u=e.dataType)=>({name:t,shaderCache:{hint:i,inputDependencies:["type"]},getShaderSource:a=>lc(a,M.size(e.dims),e.dataType,u,r,o),getRunData:a=>({outputs:[{dims:e.dims,dataType:u}],dispatchGroup:{x:Math.ceil(M.size(a[0].dims)/64/4)},programUniforms:[{type:12,data:Math.ceil(M.size(e.dims)/4)}]})}),rs=e=>{e.compute(ke(e.inputs[0],"Abs","abs"))},ns=e=>{e.compute(ke(e.inputs[0],"Acos","acos"))},os=e=>{e.compute(ke(e.inputs[0],"Acosh","acosh"))},is=e=>{e.compute(ke(e.inputs[0],"Asin","asin"))},as=e=>{e.compute(ke(e.inputs[0],"Asinh","asinh"))},ss=e=>{e.compute(ke(e.inputs[0],"Atan","atan"))},us=e=>{e.compute(ke(e.inputs[0],"Atanh","atanh"))},ds=e=>ve(e),ls=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(ke(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},cc=e=>{let t=e.length>=2&&e[1].data!==0?e[1].getFloat32Array()[0]:xn,r=e.length>=3&&e[2].data!==0?e[2].getFloat32Array()[0]:Cn;return ve({min:t,max:r})},cs=(e,t)=>{let r=e.inputs.length===1?t:cc(e.inputs),o=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Clip",i=>`clamp(${i}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${o}> = vec4(${o}(${r.min}));\n    const clip_max_: vec4<${o}> = vec4(${o}(${r.max}));\n`,r.cacheKey),{inputs:[0]})},ps=e=>{e.compute(ke(e.inputs[0],"Ceil","ceil"))},ms=e=>{e.compute(ke(e.inputs[0],"Cos","cos"))},fs=e=>{e.compute(ke(e.inputs[0],"Cosh","cosh"))},kn=e=>ve(e),hs=(e,t)=>{let r=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Elu",o=>`elu_vf32(${o})`,`\n  const elu_alpha_ = ${r}(${t.alpha});\n\n  fn elu_f32(a: ${r}) -> ${r} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},On=(e="f32")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,gs=e=>{let t=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,On(t)))},ys=e=>{e.compute(ke(e.inputs[0],"Exp","exp"))},bs=e=>{e.compute(ke(e.inputs[0],"Floor","floor"))},ws=e=>{let t=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,On(t)))},vs=(e,t)=>{let r=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"LeakyRelu",o=>`select(leaky_relu_alpha_ * ${o}, ${o}, ${o} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},$s=e=>{e.compute(ke(e.inputs[0],"Not",t=>`!${t}`))},_s=e=>{e.compute(ke(e.inputs[0],"Neg",t=>`-${t}`))},Ss=e=>{e.compute(ke(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},xs=e=>{let t=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Relu",r=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},Cs=e=>{e.compute(ke(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},As=e=>ve(e),Is=(e,t)=>{let r=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"HardSigmoid",o=>`max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${t.alpha} * ${o} + vec4<${r}>(${t.beta})))`,void 0,t.cacheKey))},Ts=e=>{e.compute(ke(e.inputs[0],"Sin","sin"))},Es=e=>{e.compute(ke(e.inputs[0],"Sinh","sinh"))},Ps=e=>{e.compute(ke(e.inputs[0],"Sqrt","sqrt"))},ks=e=>{e.compute(ke(e.inputs[0],"Tan","tan"))},Os=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,Rs=e=>{e.compute(ke(e.inputs[0],"Tanh",Os))},Bo=(e="f32")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${Os("v")};\n}\n`,Do=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,Bs=e=>{let t=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"FastGelu",Do,Bo(t),void 0,e.inputs[0].dataType))},Ds=(e,t)=>{let r=et(e.inputs[0].dataType);return e.compute(ke(e.inputs[0],"ThresholdedRelu",o=>`select(vec4<${r}>(0.0), ${o}, ${o} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},zs=e=>{e.compute(ke(e.inputs[0],"Log","log"))}});var pc,mc,Us,Vs=Y(()=>{"use strict";Se();_e();Rn();pc=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},mc=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=U("input",e[0].dataType,e[0].dims,4),o=U("bias",e[0].dataType,[e[0].dims[2]],4),i=j("output",e[0].dataType,t,4),u=M.size(t)/4,a=De(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:p=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${p.declareVariables(r,o,i)}\n\n  ${On(a)}\n\n  ${p.mainStart()}\n    ${p.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${i.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Us=e=>{pc(e.inputs),e.compute(mc(e.inputs))}});var fc,hc,Ot,Ws,Ns,Gs,Hs,Ls,Fs,qs,js,Ks,Ys,Zs=Y(()=>{"use strict";ye();Se();_e();fc=(e,t,r,o,i,u,a,c,p,h,d,y)=>{let w,_;typeof c=="string"?w=_=(x,E)=>`${c}((${x}),(${E}))`:typeof c=="function"?w=_=c:(w=c.scalar,_=c.vector);let v=j("outputData",d,o.length,4),S=U("aData",p,t.length,4),A=U("bData",h,r.length,4),I;if(i)if(u){let x=M.size(t)===1,E=M.size(r)===1,P=t.length>0&&t[t.length-1]%4===0,O=r.length>0&&r[r.length-1]%4===0;x||E?I=v.setByOffset("global_idx",_(x?`${S.type.value}(${S.getByOffset("0")}.x)`:S.getByOffset("global_idx"),E?`${A.type.value}(${A.getByOffset("0")}.x)`:A.getByOffset("global_idx"))):I=`\n            let outputIndices = ${v.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${S.broadcastedIndicesToOffset("outputIndices",v)};\n            let offsetB = ${A.broadcastedIndicesToOffset("outputIndices",v)};\n            ${v.setByOffset("global_idx",_(a||P?S.getByOffset("offsetA / 4u"):`${S.type.value}(${S.getByOffset("offsetA / 4u")}[offsetA % 4u])`,a||O?A.getByOffset("offsetB / 4u"):`${A.type.value}(${A.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else I=v.setByOffset("global_idx",_(S.getByOffset("global_idx"),A.getByOffset("global_idx")));else{if(!u)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let x=(E,P,O="")=>{let R=`aData[indexA${P}][componentA${P}]`,L=`bData[indexB${P}][componentB${P}]`;return`\n            let outputIndices${P} = ${v.offsetToIndices(`global_idx * 4u + ${P}u`)};\n            let offsetA${P} = ${S.broadcastedIndicesToOffset(`outputIndices${P}`,v)};\n            let offsetB${P} = ${A.broadcastedIndicesToOffset(`outputIndices${P}`,v)};\n            let indexA${P} = offsetA${P} / 4u;\n            let indexB${P} = offsetB${P} / 4u;\n            let componentA${P} = offsetA${P} % 4u;\n            let componentB${P} = offsetB${P} % 4u;\n            ${E}[${P}] = ${O}(${w(R,L)});\n          `};d===9?I=`\n            var data = vec4<u32>(0);\n            ${x("data",0,"u32")}\n            ${x("data",1,"u32")}\n            ${x("data",2,"u32")}\n            ${x("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:I=`\n            ${x("outputData[global_idx]",0)}\n            ${x("outputData[global_idx]",1)}\n            ${x("outputData[global_idx]",2)}\n            ${x("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(S,A,v)}\n\n        ${y??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${I}\n      }`},hc=(e,t,r,o,i,u,a=r.dataType)=>{let c=!M.areEqual(r.dims,o.dims),p=r.dims,h=M.size(r.dims),d=!1,y=!1,w=[c];if(c){let _=It.calcShape(r.dims,o.dims,!1);if(!_)throw new Error("Can\'t perform binary op on the given tensors");p=_,h=M.size(p);let v=M.size(r.dims)===1,S=M.size(o.dims)===1,A=r.dims.length>0&&r.dims[r.dims.length-1]%4===0,I=o.dims.length>0&&o.dims[o.dims.length-1]%4===0;w.push(v),w.push(S),w.push(A),w.push(I);let x=1;for(let E=1;E<p.length;E++){let P=r.dims[r.dims.length-E]??1,O=o.dims[o.dims.length-E]??1;if(P===O)x*=P;else break}x%4===0?(y=!0,d=!0):(v||S||A||I)&&(d=!0)}else d=!0;return w.push(d),{name:e,shaderCache:{hint:t+w.map(_=>_.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:_=>fc(_,r.dims,o.dims,p,d,c,y,i,r.dataType,o.dataType,a,u),getRunData:()=>({outputs:[{dims:p,dataType:a}],dispatchGroup:{x:Math.ceil(h/64/4)},programUniforms:[{type:12,data:Math.ceil(M.size(p)/4)},...Z(r.dims,o.dims,p)]})}},Ot=(e,t,r,o,i,u)=>{e.compute(hc(t,i??"",e.inputs[0],e.inputs[1],r,o,u))},Ws=e=>{Ot(e,"Add",(t,r)=>`${t}+${r}`)},Ns=e=>{Ot(e,"Div",(t,r)=>`${t}/${r}`)},Gs=e=>{Ot(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Hs=e=>{Ot(e,"Mul",(t,r)=>`${t}*${r}`)},Ls=e=>{let t=U("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;Ot(e,"Pow",{scalar:(o,i)=>`pow_custom(${o},${i})`,vector:(o,i)=>`pow_vector_custom(${o},${i})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Fs=e=>{Ot(e,"Sub",(t,r)=>`${t}-${r}`)},qs=e=>{Ot(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},js=e=>{Ot(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Ks=e=>{Ot(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Ys=e=>{Ot(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var St,xt,Ct,Bn,Ft=Y(()=>{"use strict";ye();Se();St=(e,t,r="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${r}(uniforms.clip_min)), ${t}(${r}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${r}(uniforms.alpha) * value + ${r}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${r}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},xt=(e,t)=>{e.activation==="Clip"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation==="HardSigmoid"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation==="LeakyRelu"&&t.push({type:1,data:e.alpha})},Ct=(e,t)=>{e.activation==="Clip"?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):e.activation==="HardSigmoid"?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):e.activation==="LeakyRelu"&&t.push({name:"alpha",type:"f32"})},Bn=e=>{let t=e?.activation||"";if(t==="HardSigmoid"){let[r,o]=e?.activation_params||[.2,.5];return{activation:t,alpha:r,beta:o}}else if(t==="Clip"){let[r,o]=e?.activation_params||[xn,Cn];return{activation:t,clipMax:o,clipMin:r}}else if(t==="LeakyRelu"){let[r]=e?.activation_params||[.01];return{activation:t,alpha:r}}return{activation:t}}});var tt,Dn,zn=Y(()=>{"use strict";tt=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Dn=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `});var Mn,zo=Y(()=>{"use strict";Mn=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var yc,bc,Hr,Xs,wc,Lr,vc,Un,Fr=Y(()=>{"use strict";ye();Se();_e();Ft();zn();yc=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,bc=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,Hr=(e,t,r="f32",o,i=!1,u=32,a=!1,c=32)=>{let p=t[1]*e[1],h=t[0]*e[0],d=i?p:u,y=i?u:p,w=d/t[0],_=u/t[1];if(!((i&&w===4&&e[1]===4||!i&&(w===3||w===4))&&d%t[0]===0&&u%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${i} is true, innerElementSize ${w} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${w} must be 3 or 4.\n  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${u} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${w}<${r}>, ${d/w}>, ${y}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${h/e[0]}>, ${u}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${w};\nconst tileInner = ${u};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${a?"0":"i32(globalId.z)"};\n  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${p};\n\n  let num_tiles = ${a?`${Math.ceil(c/u)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n  var kStart = ${a?`i32(globalId.z) * ${c}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${_};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${yc(i,o)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${w===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${bc(i,w)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Xs=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,wc=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Lr=(e,t,r="f32",o,i=!1,u=32,a=!1,c=32,p=!1)=>{let h=e[1]*t[1],d=e[0]*t[0],y=i?h:u,w=i?u:h;if(!(w%t[1]===0&&y%t[0]===0&&u%t[1]===0))throw new Error(`tileAHight ${w} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${y} must be divisible by workgroupSize[0]${t[0]}, tileInner ${u} must be divisible by workgroupSize[1]${t[1]}`);let _=w/t[1],v=y/t[0],S=u/t[1],A=p?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${h};\n    let globalColStart = i32(workgroupId.x) * ${d};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${w}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${y}; inputCol = inputCol + ${t[0]}) {\n          ${Xs(i,o)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${u}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${o?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${i?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${h};\n\nlet tileRowA = i32(localId.y) * ${_};\nlet tileColA = i32(localId.x) * ${v};\nlet tileRowB = i32(localId.y) * ${S};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${v}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Xs(i,o)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${S}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${o?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${wc(i)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${y}>, ${w}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${d}>, ${u}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${u};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${a?"0":"i32(globalId.z)"};\n    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n    let num_tiles = ${a?`${Math.ceil(c/u)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n    var kStart = ${a?`i32(globalId.z) * ${c}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${A}\n  }\n`},vc=(e,t,r,o,i,u=!1)=>{let[a,c,p]=i,[h,d,y,w]=o,_=_r(a,p),v=_r(c,p),S=De(o[0].type.tensor),A=()=>{let E=d.rank,P=h.rank,O=`var aIndices: ${d.type.indices};`;for(let R=E-2-1,L=P-1;R>=0;R--,L--)O+=`\naIndices[${R}] = ${P>1?`batchIndices[${L}]`:"batchIndices"};`;return _.forEach(R=>{O+=`\naIndices[${R}] = 0;`}),O+=`\naIndices[${E-2}] = u32(row);\n                   aIndices[${E-1}] = u32(colIn);`,O},I=()=>{let E=y.rank,P=h.rank,O=`var bIndices: ${y.type.indices};`;for(let R=E-2-1,L=P-1;R>=0;R--,L--)O+=`\nbIndices[${R}] = ${P>1?`batchIndices[${L}]`:"batchIndices"};`;return v.forEach(R=>{O+=`\nbIndices[${R}] = 0;`}),O+=`\nbIndices[${E-2}] = u32(row);\n                   bIndices[${E-1}] = u32(colIn);`,O};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${h.type.indices}) -> ${tt(e,S)} {\n      var value = ${tt(e,S)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        ${A()}\n        value = ${d.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${h.type.indices}) -> ${tt(e,S)} {\n      var value = ${tt(e,S)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        ${I()}\n        value = ${y.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${tt(e,S)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${u?"bias[colIn]":`${tt(e,S)}(bias[row])`};`:""}\n        ${r}\n        ${w.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Un=(e,t,r,o,i=!1)=>{let u=e[0].dims,a=e[1].dims,c=u.slice(0,-2),p=a.slice(0,-2),h=o?o.slice(0,-2):r.slice(0,-2),d=M.size(h),y=u[u.length-2],w=u[u.length-1],_=a[a.length-1],v=w%4===0&&_%4===0,S=y<=8?[4,1,1]:[4,4,1],A=[8,8,1],I=[Math.ceil(_/A[0]/S[0]),Math.ceil(y/A[1]/S[1]),Math.ceil(d/A[2]/S[2])],x=v?4:1,E=[...c,y,w/x],P=E.length,O=[...p,w,_/x],R=O.length,L=[d,y,_/x],N=[{type:6,data:y},{type:6,data:_},{type:6,data:w}];xt(t,N),N.push(...Z(h,E,O));let K=["rank","rank"],Q=e.length>2;Q&&(N.push(...Z(e[2].dims)),K.push("rank")),N.push(...Z(L));let he=W=>{let se=h.length,Ce=An("batchDims",e[0].dataType,se,1),We=De(e[0].dataType),ee=U("a",e[0].dataType,P,x),ae=U("b",e[1].dataType,R,x),Ae=j("result",e[0].dataType,L.length,x),me=[ee,ae];if(Q){let G=i?x:1;me.push(U("bias",e[2].dataType,e[2].dims.length,G))}let ie=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Ct(t,ie);let ue=De(Ae.type.tensor),le=St(t,Ae.type.value,ue),qe=vc(x,Q,le,[Ce,ee,ae,Ae],[c,p,h],i);return`\n  ${W.registerUniforms(ie).registerInternalVariables(Ce).declareVariables(...me,Ae)}\n  ${qe}\n  ${v?Hr(S,A,We,Ce):Lr(S,A,We,Ce)}\n                   `};return{name:"MatMul",shaderCache:{hint:`${S};${t.activation};${v};${i}`,inputDependencies:K},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:I[0],y:I[1],z:I[2]},programUniforms:N}),getShaderSource:he}}});var $c,Qs,Js=Y(()=>{"use strict";ye();Lt();_e();Ft();zn();zo();Fr();$c=(e,t,r,o,i=!1,u,a=4,c=4,p=4,h="f32")=>{let d=Q=>{switch(Q){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${h}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Q} is not supported.`)}},y=Q=>{switch(Q){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${Q} is not supported.`)}},w=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,_=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,v=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",S=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",A=e?"row":"col",I=e?"col":"row",x=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${A} / outWidth;\n    let outCol = ${A} % outWidth;\n\n    let WRow = ${I} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${I} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${I} % inChannels;\n    var resData = ${tt(a,h)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${v} && xCol >= 0 && xCol < ${S}) {\n      ${w}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${d(a)}\n    }\n    return resData;`,E=e?t&&o?`\n    let col = colIn * ${a};\n    ${x}`:`\n    let col = colIn * ${a};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${x}\n    }\n    return ${tt(a,h)}(0.0);`:o&&r?`\n    let col = colIn * ${a};\n    ${x}`:`\n    let col = colIn * ${a};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${x}\n    }\n    return ${tt(a,h)}(0.0);`,P=`${y(c)}`,O=tt(p,h),R=e?tt(a,h):tt(c,h),L=e?tt(c,h):tt(a,h),N=St(u,O,h);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${R} {\n      ${e?E:P}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${L} {\n      ${e?P:E}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${O}) {\n      let col = colIn * ${p};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${_}\n      ${Dn(i)}\n      ${N}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Qs=(e,t,r,o,i,u,a,c)=>{let p=t.format==="NHWC",h=p?e[0].dims[3]:e[0].dims[1],d=r[0],y=p?r[2]:r[3],w=p?r[1]:r[2],_=p?r[3]:r[1],v=p&&(h%4===0||h%3===0)&&_%4===0,S=p?_:y*w,A=p?y*w:_,I=[8,8,1],x=o<=8?[4,1,1]:[4,4,1],E=[Math.ceil(S/I[0]/x[0]),Math.ceil(A/I[1]/x[1]),Math.ceil(d/I[2]/x[2])];Ve("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${E}`);let P=v?p&&h%4!==0?3:4:1,O=I[1]*x[1],R=I[0]*x[0],L=Math.max(I[0]*P,I[1]),N=o%O===0,K=i%R===0,Q=u%L===0,he=v?[P,4,4]:[1,1,1],W=[{type:6,data:o},{type:6,data:i},{type:6,data:u},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];xt(t,W),W.push(...Z(e[0].dims,e[1].dims));let se=["rank","rank"];a&&(W.push(...Z(e[2].dims)),se.push("rank")),W.push(...Z(r));let Ce=We=>{let ee=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Ct(t,ee);let ae=v?4:1,Ae=De(e[0].dataType),me=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${v?`vec4<${Ae}>`:Ae}) {\n        result[flatIndex] = ${v?`vec4<${Ae}>`:Ae}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${v?`vec4<${Ae}>`:Ae}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${v?"/ 4":""}, value);\n      }`,ie=U("x",e[0].dataType,e[0].dims.length,P===3?1:P),ue=U("w",e[1].dataType,e[1].dims.length,ae),le=[ie,ue],qe=j("result",e[0].dataType,r.length,ae);if(a){let G=U("bias",e[2].dataType,e[2].dims.length,ae);le.push(G),me+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?`vec4<${Ae}>`:Ae} {\n          return bias[coords.${p?"w":"y"}${v?"/ 4":""}];\n        }`}return`\n        ${Mn("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${We.registerUniforms(ee).declareVariables(...le,qe)}\n        ${me}\n        ${$c(p,N,K,Q,a,t,he[0],he[1],he[2],Ae)}\n        ${v?Hr(x,I,Ae,void 0,!p,L):Lr(x,I,Ae,void 0,!p,L,!1,void 0,c)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${P};${v};${N};${K};${Q};${O};${R};${L}`,inputDependencies:se},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]},programUniforms:W}),getShaderSource:Ce}}});var Mo,eu,tu=Y(()=>{"use strict";ye();Se();_e();Uo();Ft();Mo=(e,t,r)=>{let o=e.length>2,i=o?"value += b[output_channel];":"",u=e[0].dims,a=e[1].dims,c=a[0]/t.group,p=t.format==="NHWC",h=Vn(u,a,t.dilations,t.pads,t.strides,p),d=M.size(h),y=[{type:12,data:d},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:c}];xt(t,y),y.push(...Z(u,a));let w=["rank","rank"];o&&(y.push(...Z(e[2].dims)),w.push("rank")),y.push(...Z(h));let _=v=>{let S=j("output",e[0].dataType,h.length),A=De(S.type.tensor),I=St(t,S.type.value,A),x=U("x",e[0].dataType,u.length),E=U("w",e[1].dataType,a.length),P=[x,E];o&&P.push(U("b",e[2].dataType,e[2].dims.length));let O=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];return Ct(t,O),`\n  ${v.registerUniforms(O).declareVariables(...P,S)}\n\n  ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let outputIndices = ${S.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${p?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${p?1:2}], outputIndices[${p?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel / uniforms.output_channels_per_group;\n\n    var value: ${S.type.value} = ${S.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[${p?1:2}]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[${p?2:3}]) {\n            continue;\n          }\n\n          let xVal = ${p?x.get("batch","xHeight","xWidth","input_channel"):x.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${E.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${i}\n    ${I}\n    ${S.setByOffset("global_idx","value")}\n  }`};return{name:"GroupedConv",shaderCache:{hint:t.cacheKey,inputDependencies:w},getRunData:()=>({outputs:[{dims:r?r(h):h,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:y}),getShaderSource:_}},eu=(e,t,r)=>{let o=e.length>2,i=Me(r[3]),u=Me(r[2]),a=M.size(r)/i/u,c=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/i],p=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/i],h=[r[0],r[1],r[2],r[3]/i],d=[{type:12,data:a},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];xt(t,d),d.push(...Z(c,p,h));let y=(u-1)*t.strides[1]+p[1],w=_=>{let v=j("output",e[0].dataType,h.length,i),S=De(v.type.tensor),A=St(t,v.type.value,S),I=U("x",e[0].dataType,c.length,i),x=U("w",e[1].dataType,p.length,i),E=[I,x];o&&E.push(U("b",e[2].dataType,e[2].dims,i));let P=o?"value += b[output_channel];":"",O=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Ct(t,O),`\n  ${_.registerUniforms(O).declareVariables(...E,v)}\n  ${_.mainStart()}\n    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${u}u;\n    let col = (index1 % width1) * ${u}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${I.type.value}, ${y}>;\n    var values: array<${v.type.value}, ${u}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w\'s height/width.\n    for (var w_height: u32 = 0u; w_height < ${p[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${y}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${I.get("batch","u32(x_height)","u32(x_width)","input_channel")};\n          } else {\n            x_vals[i] = ${I.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${p[1]}; w_width++) {\n          let w_val = ${x.get("w_height","w_width","0","output_channel")};\n          for (var i = 0u; i < ${u}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${u}u; i++) {\n      var value = values[i];\n      ${P}\n      ${A}\n      ${v.set("batch","row","col + i","output_channel","value")};\n    }\n  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${i};${u};${y};${p[0]};${p[1]}`,inputDependencies:o?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:d}),getShaderSource:w}}});var Vo,_c,ru,Wo=Y(()=>{"use strict";ye();Se();Fr();_e();Ft();Vo=(e,t,r,o,i=!1)=>{let u=e[0].dims,a=e[1].dims,c=u[u.length-2],p=a[a.length-1],h=u[u.length-1],d=Me(p),y=Me(h),w=Me(c),_=M.size(r)/d/w,v=e.length>2,S=o?o.slice(0,-2):r.slice(0,-2),I=[M.size(S),c,p],x=[{type:12,data:_},{type:12,data:c},{type:12,data:p},{type:12,data:h}];xt(t,x),x.push(...Z(S,u,a)),v&&x.push(...Z(e[2].dims)),x.push(...Z(I));let E=P=>{let O=An("batch_dims",e[0].dataType,S.length),R=U("a",e[0].dataType,u.length,y),L=U("b",e[1].dataType,a.length,d),N=j("output",e[0].dataType,I.length,d),K=De(N.type.tensor),Q=St(t,N.type.value,K),he=[R,L],W="";if(v){let ie=i?d:1;he.push(U("bias",e[2].dataType,e[2].dims.length,ie)),W=`${i?`value += bias[col / ${ie}];`:`value += ${N.type.value}(bias[row + i]);`}`}let se=u.slice(0,-2),Ce=a.slice(0,-2),We=_r(se,S),ee=_r(Ce,S),ae=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];Ct(t,ae);let Ae=(ie,ue)=>{let le=ie.rank,qe=ie.name;if(le===2)return`var ${qe}_indices = ${ie.type.indices}(0u, 0u);`;let G=O.rank,ne=`var ${qe}_indices: ${ie.type.indices};`;for(let xe=le-2-1,Ke=G-1;xe>=0;xe--,Ke--)ne+=`\n${qe}_indices[${xe}] = ${G>1?`batch_indices[${Ke}]`:"batch_indices"};`;return ue.forEach(xe=>{ne+=`\n${qe}_indices[${xe}] = 0;`}),ne+=`${qe}_indices[${le-2}] = 0u;\n                     ${qe}_indices[${le-1}] = 0u;`,ne},me=()=>{let ie=`var a_data: ${R.type.value};`;for(let ue=0;ue<y;ue++)ie+=`\n              let b_data${ue} = b[(b_offset + (k + ${ue}) * uniforms.N + col) / ${d}];`;for(let ue=0;ue<w;ue++){ie+=`a_data = a[(a_offset + (row + ${ue}) * uniforms.K + k) / ${y}];`;for(let le=0;le<y;le++)ie+=`\n            values[${ue}] = fma(${L.type.value}(a_data${y===1?"":`[${le}]`}), b_data${le}, values[${ue}]);\n`}return ie};return`\n  ${P.registerUniforms(ae).registerInternalVariables(O).declareVariables(...he,N)}\n  ${P.mainStart()}\n    ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let col = (global_idx % (uniforms.N / ${d})) * ${d};\n    var index1 = global_idx / (uniforms.N / ${d});\n    let stride1 = uniforms.M / ${w};\n    let row = (index1 % stride1) * ${w};\n    let batch = index1 / stride1;\n\n    ${r.length===2?"":`let batch_indices = ${O.offsetToIndices("batch")};`}\n    ${Ae(R,We)}\n    let a_offset = ${R.indicesToOffset("a_indices")};\n    ${Ae(L,ee)}\n    let b_offset = ${L.indicesToOffset("b_indices")};\n    var values: array<${N.type.value}, ${w}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${y}) {\n      ${me()}\n    }\n    for (var i = 0u; i < ${w}u; i++) {\n      var value = values[i];\n      ${W}\n      ${Q}\n      let cur_indices = ${N.type.indices}(batch, row + i, col);\n      let offset = ${N.indicesToOffset("cur_indices")};\n      ${N.setByOffset(`offset / ${d}`,"value")};\n    }\n  }\n  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${d};${y};${w};${i}`,inputDependencies:v?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:x}),getShaderSource:E}},_c=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},ru=e=>{_c(e.inputs);let t=It.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");let r=t[t.length-1],o=e.inputs[0].dims[e.inputs[0].dims.length-1];r<8&&o<8?e.compute(Vo(e.inputs,{activation:""},t)):e.compute(Un(e.inputs,{activation:""},t))}});var Vn,No,Sc,nu,Go,xc,Cc,Ho,Uo=Y(()=>{"use strict";Se();Js();Fr();tu();Ft();Wo();Sr();Vn=(e,t,r,o,i,u)=>{let a=e[0],c=e.slice(u?1:2,u?3:4),p=c.length,h=t[0],y=t.slice(2).map((v,S)=>v+(v-1)*(r[S]-1)),_=c.map((v,S)=>v+o[S]+o[S+p]).map((v,S)=>Math.floor((v-y[S]+i[S])/i[S]));return _.splice(0,0,a),_.splice(u?3:1,0,h),_},No=[2,3,1,0],Sc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let i=e[0].dims.length-2;if(t.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(t.strides.length!==i)throw new Error(`strides should be ${i}D`);if(t.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},nu=(e,t)=>{let r=e.kernelShape.slice();for(let u=2;u<t[1].dims.length;++u)r[u-2]===0&&(r[u-2]=t[1].dims[u]);let o=e.pads.slice();nr.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let i=Object.assign({},e);return Object.assign(i,{kernelShape:r,pads:o}),i},Go=e=>{let t=Bn(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],i=e.dilations,u=e.group,a=e.kernel_shape,c=e.pads,p=e.strides,h=e.w_is_const();return{autoPad:o,format:r,dilations:i,group:u,kernelShape:a,pads:c,strides:p,wIsConst:h,...t,cacheKey:`${e.format};${t.activation};`}},xc=(e,t,r)=>{let o=nu(r,t),i=r.format==="NHWC";if(r.group!==1){if(!e.adapterInfo.isArchitecture("ampere")&&i&&t[1].dims[0]===r.group&&t[1].dims[1]===1&&r.dilations[0]===1&&r.dilations[1]===1){let L=Vn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,i),N=e.kernelCustomData.wT??e.compute(yt(t[1],No),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=N);let K=[t[0],N];t.length===3&&K.push(t[2]),e.compute(eu(K,o,L),{inputs:K})}else e.compute(Mo(t,o));return}let u=t.length===3,a=t[0].dims[i?1:2],c=t[0].dims[i?2:3],p=t[0].dims[i?3:1],h=t[1].dims[2],d=t[1].dims[3],y=Vn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,i),w=y[i?1:2],_=y[i?2:3],v=y[i?3:1],S=i&&h===a&&d===c&&r.pads[0]===0&&r.pads[1]===0;if(S||h===1&&d===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let R=y[0],L,N,K,Q=[];if(i){let se=e.kernelCustomData.wT??e.compute(yt(t[1],No),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=se),S){let Ce=a*c*p;L=t[0].reshape([1,R,Ce]),N=se.reshape([1,Ce,v]),K=[1,R,v]}else L=t[0].reshape([R,a*c,p]),N=se.reshape([1,p,v]),K=[R,w*_,v];Q.push(L),Q.push(N)}else L=t[0].reshape([R,p,a*c]),N=t[1].reshape([1,v,p]),K=[R,v,w*_],Q.push(N),Q.push(L);u&&Q.push(t[2]);let he=K[2],W=Q[0].dims[Q[0].dims.length-1];he<8&&W<8?e.compute(Vo(Q,o,y,K,i),{inputs:Q}):e.compute(Un(Q,o,y,K,i),{inputs:Q});return}let A=!0,I=e.kernelCustomData.wT??e.compute(yt(t[1],No),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let x=[t[0],I];u&&x.push(t[2]);let E=i?w*_:v,P=i?v:w*_,O=h*d*p;e.compute(Qs(x,o,y,E,P,O,u,A),{inputs:x})},Cc=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let i=[0,t.pads[0],0,t.pads[1]],u=[1].concat(t.strides),a=[1].concat(t.dilations),c=[1].concat(t.kernelShape),p=nu({...t,pads:i,strides:u,dilations:a,kernelShape:c},o);e.compute(Mo(o,p,h=>r?[h[0],h[2],h[3]]:[]))},Ho=(e,t)=>{Sc(e.inputs,t),e.inputs[0].dims.length===3?Cc(e,t):xc(e,e.inputs,t)}});var Ac,ou,iu=Y(()=>{"use strict";ye();Lt();_e();Ft();zn();zo();Fr();Ac=(e,t=!1,r,o,i=4)=>{let u=I=>{switch(I){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];\n            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];\n            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];\n            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];\n            return ${o}(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${I} is not supported.`)}},a=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,c=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,p=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",h=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",d=e?"row":"col",y=e?"col":"row",w=`\n      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      let outRow = ${d} / outWidth;\n      let outCol = ${d} % outWidth;\n\n      let WRow = ${y} / (uniforms.filter_dims[1] * inChannels);\n      let WCol = ${y} / inChannels % uniforms.filter_dims[1];\n      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(${p}) || fract(xR) > 0.0) {\n        return ${o}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${h}) || fract(xC) > 0.0) {\n        return ${o}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${y} % inChannels;\n      ${a}\n      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${i}];`,_=e?`\n      let col = colIn * ${i};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n        ${w}\n      }\n      return ${o}(0.0);`:`\n      let col = colIn * ${i};\n      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n        ${w}\n      }\n      return ${o}(0.0);`,v=`\n      let col = colIn * ${i};\n      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};\n      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);\n      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];\n      if (${e?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${u(i)}\n      }\n      return ${o}(0.0);\n      `,S=St(r,o);return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${o} {\n    ${e?_:v}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${o} {\n    ${e?v:_}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${o}) {\n    let col = colIn * ${i};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n      var value = valueInput;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${c}\n      ${Dn(t)}\n      ${S}\n      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${i}] = value;\n    }\n  }`},ou=(e,t,r,o,i,u,a,c)=>{let p=t.format==="NHWC",h=p?e[0].dims[3]:e[0].dims[1],d=r[0],y=p?r[2]:r[3],w=p?r[1]:r[2],_=p?r[3]:r[1],v=p&&h%4===0&&h%3&&_%4===0,S=p?_:y*w,A=p?y*w:_,I=[8,8,1],x=o<=8?[4,1,1]:[4,4,1],E=[Math.ceil(S/I[0]/x[0]),Math.ceil(A/I[1]/x[1]),Math.ceil(d/I[2]/x[2])];Ve("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${E}`);let P=v?4:1,O=Math.max(I[0]*P,I[1]),R=v?4:1,L=[t.kernelShape[p?1:2],t.kernelShape[p?2:3]],N=[L[0]+(t.dilations[0]<=1?0:(L[0]-1)*(t.dilations[0]-1)),L[1]+(t.dilations[1]<=1?0:(L[1]-1)*(t.dilations[1]-1))],K=[N[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),N[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],Q=[{type:6,data:o},{type:6,data:i},{type:6,data:u},{type:6,data:t.strides},{type:6,data:t.dilations},{type:6,data:L},{type:6,data:K}];xt(t,Q),Q.push(...Z(e[0].dims,e[1].dims));let he=["rank","rank"];a&&(Q.push(...Z(e[2].dims)),he.push("rank")),Q.push(...Z(r));let W=se=>{let Ce=U("x",e[0].dataType,e[0].dims.length,R),We=U("w",e[1].dataType,e[1].dims.length,1),ee=j("result",e[0].dataType,r.length,R),ae=[Ce,We],Ae="";if(a){let ue=U("bias",e[2].dataType,e[2].dims.length,R);ae.push(ue),Ae+=`\n          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${ue.type.value} {\n            return bias[coords.${p?"w":"y"}${v?"/ 4":""}];\n          }`}let me=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:L.length},{name:"pads",type:"i32",length:K.length}];Ct(t,me);let ie=De(e[0].dataType,1);if(ie!=="f16"&&ie!=="f32")throw new Error(`elemType ${ie} is not supported.`);return`\n        ${Mn("uniforms.result_strides")}\n        ${se.registerUniforms(me).declareVariables(...ae,ee)};\n        ${Ae}\n        ${Ac(p,a,t,Ce.type.value,P)}\n        ${v?Hr(x,I,ie,void 0,!p,O):Lr(x,I,ie,void 0,!p,O,!1,void 0,c)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${t.cacheKey};${x};${I};${v}`,inputDependencies:he},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]},programUniforms:Q}),getShaderSource:W}}});var Ic,Lo,au=Y(()=>{"use strict";ye();Lt();Se();_e();Ic=(e,t,r,o,i,u=!1,a,c,p=!1)=>{let h=p?1:2,d=p?2:3,y=p?3:1,w=u?2:1,_=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${a}>`:a}) {\n    result[flatIndex] = ${u?`vec4<${a}>`:a}(value);\n  }`;o&&(_+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${a}>`:a} {\n      return bias[coords.${p?"w":"y"}${u?"/ 4":""}];\n    }`);let v=u?4:1,S=U("W",t[1].dataType,t[1].dims.length,v),A=U("Dy",t[0].dataType,t[0].dims.length,v),I=[A,S];o&&I.push(U("bias",t[2].dataType,[r[y]].length,v));let x=j("result",t[0].dataType,r.length,v),E=`{\n        let batch: u32 = ${i?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];\n        let r = ${i?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];\n        let c = ${i?"global_id.y":"workgroup_id.y"} * ${w};\n        let d1: u32 = ${i?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${a}>, ${w}>;\n        for (var i = 0; i < ${w}; i++) {\n          dotProd[i] = vec4<${a}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {\n          var dyR = (${a}(dyCorner.x) + ${a}(wR)) / ${a}(uniforms.strides.x);\n          let wRPerm = uniforms.filter_dims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${a}(uniforms.Dy_shape[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {\n            let dyC = (${a}(dyCorner.y) + ${a}(wC)) / ${a}(uniforms.strides.y);\n            let dyC2 = (${a}(dyCorner.y) + 1.0 + ${a}(wC)) / ${a}(uniforms.strides.y);\n            let wCPerm = uniforms.filter_dims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${a}(uniforms.Dy_shape[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${a}(uniforms.Dy_shape[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = uniforms.Dy_shape[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${A.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${a}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${A.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${a}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = uniforms.Dy_shape[${y}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${A.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${a}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = uniforms.Dy_shape[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${A.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${a}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${w}; i = i + 1) {\n          let value = dotProd[i] + ${o?"bias[c+i]":`vec4<${a}>(0.0)`};\n          ${x.set("batch","r","c + i","d1","value")};\n        }\n      }`,P=`\n          let outputIndices = ${x.offsetToIndices("global_idx")};\n          let batch = ${x.indicesGet("outputIndices",0)};\n          let d1 = ${x.indicesGet("outputIndices",y)};\n          let r = ${x.indicesGet("outputIndices",h)};\n          let c = ${x.indicesGet("outputIndices",d)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / uniforms.output_channels_per_group;\n          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = ${a}(0.0);\n          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n            if (wR % uniforms.dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${a}(dyRCorner) + ${a}(wR)) / ${a}(uniforms.strides[0]);\n            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n            if (dyR < 0.0 || dyR >= ${a}(uniforms.Dy_shape[${h}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n              if (wC % uniforms.dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${a}(dyCCorner) + ${a}(wC)) / ${a}(uniforms.strides.y);\n              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n              if (dyC < 0.0 || dyC >= ${a}(uniforms.Dy_shape[${d}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * uniforms.input_channels_per_group;\n              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {\n                let xValue = ${p?A.get("batch","idyR","idyC","inputChannel"):A.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${S.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${o?"bias[d1]":`${a}(0.0)`};\n          ${x.setByOffset("global_idx","value")};\n        `;return`\n  ${e.registerUniforms(c).declareVariables(...I,x)}\n  ${_}\n\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};\n  ${u?E:P}}`},Lo=(e,t,r)=>{let o=e.length>2,i=t.outputShape,u=M.size(i),a=[Math.ceil(u/64),1,1];Ve("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${a}`);let c=t.format==="NHWC",p=["rank","rank"],h=[t.strides[0],t.strides[1]],d=[t.kernelShape[c?1:2],t.kernelShape[c?2:3]],y=[t.dilations[0],t.dilations[1]],w=[d[0]+(t.dilations[0]<=1?0:(t.kernelShape[c?1:2]-1)*(t.dilations[0]-1)),d[1]+(t.dilations[1]<=1?0:(t.kernelShape[c?2:3]-1)*(t.dilations[1]-1))],_=[w[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),w[1]-1-Math.floor(t.pads[1]+t.pads[3])/2],v=!1,S=t.group,A=e[1].dims,I=A[0]/S,x=A[1],E=[{type:12,data:u},{type:12,data:h},{type:12,data:d},{type:12,data:y},{type:12,data:w},{type:6,data:_},{type:12,data:I},{type:12,data:x},...Z(e[0].dims,e[1].dims)];o&&(E.push(...Z(e[2].dims)),p.push("rank")),E.push(...Z(i));let P=a[1]===1&&a[2]===1,O=R=>{let L=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:h.length},{name:"filter_dims",type:"u32",length:d.length},{name:"dilations",type:"u32",length:d.length},{name:"effective_filter_dims",type:"u32",length:w.length},{name:"pads",type:"i32",length:_.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],N=De(e[0].dataType);return`${Ic(R,e,i,o,P,v,N,L,c)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};`,inputDependencies:p},getRunData:()=>({dispatchGroup:{x:a[0],y:a[1],z:a[2]},outputs:[{dims:r?r(i):i,dataType:e[0].dataType}],programUniforms:E}),getShaderSource:O}}});var Tc,Ec,Pc,su,uu,kc,Oc,Rc,Bc,du,lu=Y(()=>{"use strict";iu();au();Ft();Sr();Tc=(e,t,r,o,i,u)=>(e-1)*t+r+(o-1)*i+1-u,Ec=(e,t,r,o,i)=>{let u=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=u,r[i]=e-u):t==="SAME_LOWER"&&(r[o]=e-u,r[i]=u)},Pc=(e,t,r,o,i,u,a,c,p,h)=>{let d=e.length-2,y=h.length===0;if(p.length===0)for(let v=0;v<d;++v)p.push(0);let w=e[0],_=t[c?3:1]*i;for(let v=0,S=e.length-d-(c?1:0);v<d;++v,++S){let A=e[S],I=y?A*a[v]:h[v],x=Tc(A,a[v],u[v],t[S],r[v],I);Ec(x,o,u,v,v+d),y&&h.push(a[v]*(A-1)+p[v]+(t[S]-1)*r[v]+1-u[v]-u[v+d])}h.splice(0,0,w),h.splice(c?3:1,0,_)},su=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((y,w)=>y*w,1)===0){r.length=0;for(let y=2;y<t[1].dims.length;++y)r.push(t[1].dims[y])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let i=e.pads.slice(),u=e.outputShape.slice(),a=e.outputPadding.slice(),c=t[0].dims,p=e.dilations.slice();if(p.reduce((y,w)=>y+w,0)===0){let y=t[0].dims.length-2;p=new Array(y).fill(1)}let h=e.strides.slice();if(h.reduce((y,w)=>y+w,0)===0){let y=t[0].dims.length-2;h=new Array(y).fill(1)}Pc(c,r,p,e.autoPad,e.group,i,h,o,a,u);let d=Object.assign({},e);return Object.assign(d,{kernelShape:r,pads:i,outputPadding:a,outputShape:u,dilations:p,strides:h}),d},uu=e=>{let t=Bn(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],i=e.dilations,u=e.group,a=e.kernelShape,c=e.pads,p=e.strides,h=e.wIsConst(),d=e.outputPadding,y=e.outputShape;return{autoPad:o,format:r,dilations:i,group:u,kernelShape:a,outputPadding:d,outputShape:y,pads:c,strides:p,wIsConst:h,...t,cacheKey:`${e.format};${t.activation};`}},kc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let i=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==i))throw new Error("invalid bias");let u=e[0].dims.length-2;if(t.dilations.reduce((d,y)=>d+y,0)>0&&t.dilations.length!==u)throw new Error(`dilations should be ${u}D`);if(t.strides.reduce((d,y)=>d+y,0)>0&&t.strides.length!==u)throw new Error(`strides should be ${u}D`);if(t.pads.reduce((d,y)=>d+y,0)>0&&t.pads.length!==u*2)throw new Error(`pads should be ${u*2}D`);if(t.outputPadding.length!==u&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${u}D`);if(t.kernelShape.reduce((d,y)=>d+y,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Oc=[2,3,1,0],Rc=(e,t,r)=>{let o=su(r,t),i=r.format==="NHWC",u=o.outputShape,a=u[i?3:1],c=t[0].dims[i?3:1];if(o.group!==1||a===1&&c===1){e.compute(Lo(t,o));return}let p=u[i?1:2],h=u[i?2:3],d=t[1].dims[2],y=t[1].dims[3],w=i?p*h:a,_=i?a:p*h,v=d*y*c,S=!0,A=e.kernelCustomData.wT??e.compute(yt(t[1],Oc),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let I=[t[0],A],x=t.length===3;x&&(!i&&t[2].dims.length===1?I.push(t[2].reshape([t[2].dims[0],1,1])):I.push(t[2])),e.compute(ou(I,o,u,w,_,v,x,S),{inputs:I})},Bc=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let i=t.kernelShape;(i.length===0||i[0]===0)&&(i=[e.inputs[1].dims[2]]);let u=t.dilations;(u.length===0||u[0]===0)&&(u=[1]);let a=t.strides;(a.length===0||a[0]===0)&&(a=[1]);let c=t.pads;c.length===0&&(c=[0,0]),c=[0,c[0],0,c[1]],a=[1].concat(a),u=[1].concat(u),i=[1].concat(i);let p=su({...t,pads:c,strides:a,dilations:u,kernelShape:i},o);e.compute(Lo(o,p,h=>r?[h[0],h[2],h[3]]:[h[0],h[1],h[3]]))},du=(e,t)=>{kc(e.inputs,t),e.inputs[0].dims.length===3?Bc(e,t):Rc(e,e.inputs,t)}});var Dc,cu,pu,mu=Y(()=>{"use strict";ye();Se();Ze();_e();Dc=(e,t,r,o)=>{let i=M.size(t),u=t.length,a=U("input",e,u),c=j("output",e,u),p=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),h=M.normalizeAxis(p,u),d=y=>{let w=` i32(${a.indicesGet("inputIndices","uniforms.axis")}) `,_=fe("uniforms.input_shape","uniforms.axis",u),v=o.reverse?w+(o.exclusive?" + 1":""):"0",S=o.reverse?_:w+(o.exclusive?"":" + 1");return`\n                ${y.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(a,c)}\n                ${y.mainStart()}\n                  ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${c.offsetToIndices("global_idx")};\n                  var sum = ${c.type.value}(0);\n                  let first : i32 = ${v};\n                  let last : i32 = ${S};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${a.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${a.getByIndices("inputIndices")};\n                  }\n                  ${c.setByOffset("global_idx","sum")};\n                }`};return{name:"CumSum",shaderCache:{hint:o.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},{type:12,data:h},...Z(t,t)]}),getShaderSource:d}},cu=(e,t)=>{let r=e.inputs[0].dims,o=e.inputs[0].dataType,i=e.inputs[1];e.compute(Dc(o,r,i,t),{inputs:[0]})},pu=e=>{let t=e.exclusive===1,r=e.reverse===1;return ve({exclusive:t,reverse:r})}});var zc,Mc,Uc,fu,hu,gu=Y(()=>{"use strict";ye();Se();Ze();_e();zc=e=>{if(!e||e.length!==1)throw new Error("DepthToSpace requires 1 input.");if(e[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},Mc=(e,t,r,o)=>{let i=[];i.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let u=0;u<t;++u)i.push(r.indicesSet("a",e[u],`i[${u}]`));return i.push("return a;}"),i.join(`\n`)},Uc=(e,t)=>{let r,o,i,u,a,c,p=t.format==="NHWC",h=t.blocksize,d=t.mode==="DCR";p?([r,o,i,u]=e.dims,a=d?[r,o,i,h,h,u/h**2]:[r,o,i,u/h**2,h,h],c=d?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([r,o,i,u]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],a=d?[r,h,h,u/h**2,o,i]:[r,u/h**2,h,h,o,i],c=d?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let y=e.reshape(a),w=y.dims.length,_=e.dataType,v=U("a",_,w),S=j("output",_,w),A=I=>`\n  ${I.registerUniform("output_size","u32").declareVariables(v,S)}\n\n  ${Mc(c,w,v,S)}\n\n  ${I.mainStart()}\n    ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${S.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${S.setByOffset("global_idx",v.getByIndices("aIndices"))}\n  }`;return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:I=>{let x=p?[r,o*h,i*h,u/h**2]:[r,u/h**2,o*h,i*h],E=M.size(x),P=y.dims,O=M.sortBasedOnPerm(P,c);return{outputs:[{dims:x,dataType:I[0].dataType}],dispatchGroup:{x:Math.ceil(E/64)},programUniforms:[{type:12,data:E},...Z(P,O)]}},getShaderSource:A}},fu=(e,t)=>{zc(e.inputs),e.compute(Uc(e.inputs[0],t))},hu=e=>ve({blocksize:e.blocksize,mode:e.mode,format:e.format})});var Fo,Wn,yu,Vc,Wc,qo,jo,bu,Nc,wu,vu,$u=Y(()=>{"use strict";ye();Se();Ze();_e();Fo="[a-zA-Z]|\\\\.\\\\.\\\\.",Wn="("+Fo+")+",yu="^"+Wn+"$",Vc="("+Wn+",)*"+Wn,Wc="^"+Vc+"$",qo=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},jo=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,i]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(Wc)))throw new Error("Invalid LHS term");if(o.split(",").forEach((c,p)=>{let h=t[p].dims.slice();if(!c.match(RegExp(yu)))throw new Error("Invalid LHS term");let d=this.processTerm(c,!0,h,p);this.lhs.push(d)}),i==="")i+=[...this.symbolToInfo.entries()].filter(([c,p])=>p.count===1||c==="...").map(([c])=>c).join("");else if(!i.match(RegExp(Wn)))throw new Error("Invalid RHS");i.match(RegExp(Fo,"g"))?.forEach(c=>{if(c==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let p=this.symbolToInfo.get(c);if(p===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(p.dimValue)}}),this.rhs=this.processTerm(i,!1,this.outputDims)}addSymbol(t,r,o){let i=this.symbolToInfo.get(t);if(i!==void 0){if(i.dimValue!==r&&i.count!==1)throw new Error("Dimension mismatch");i.count++,i.inputIndices.push(o)}else i={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,i)}processTerm(t,r,o,i=-1){let u=o.length,a=!1,c=[],p=0;if(!t.match(RegExp(yu))&&!r&&t!=="")throw new Error("Invalid LHS term");let h=t.match(RegExp(Fo,"g")),d=new qo(i);return h?.forEach((y,w)=>{if(y==="..."){if(a)throw new Error("Only one ellipsis is allowed per input term");a=!0;let _=u-h.length+1;if(_<0)throw new Error("Ellipsis out of bounds");if(c=o.slice(p,p+_),this.hasEllipsis){if(this.ellipsisDims.length!==c.length||this.ellipsisDims.toString()!==c.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=c;else throw new Error("Ellipsis must be specified in the LHS");for(let v=0;v<c.length;v++){let S=String.fromCharCode("0".charCodeAt(0)+v);d.addSymbol(S,w+v),this.addSymbol(S,o[p++],i)}}else d.addSymbol(y,w+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(y,o[p++],i)}),d}},bu=e=>e+"_max",Nc=(e,t,r,o)=>{let u=e.map(d=>d.length).map((d,y)=>U(`input${y}`,t,d)),a=M.size(o),c=j("output",t,o.length),p=[...r.symbolToInfo.keys()].filter(d=>!r.rhs.symbolToIndices.has(d)),h=d=>{let y=[],w="var prod = 1.0;",_="var sum = 0.0;",v="sum += prod;",S=[],A=[],I=[],x=[],E=r.symbolToInfo.size===r.rhs.symbolToIndices.size;r.symbolToInfo.forEach((O,R)=>{if(r.rhs.symbolToIndices.has(R)){let L=r.rhs.symbolToIndices.get(R)?.[0];L!==void 0&&r.lhs.forEach((N,K)=>{if(O.inputIndices.includes(K)){let Q=N.symbolToIndices.get(R);if(Q===void 0)throw new Error("Invalid symbol error");Q.forEach(he=>{y.push(`${u[K].indicesSet(`input${K}Indices`,he,c.indicesGet("outputIndices",L))}`)})}})}else r.lhs.forEach((L,N)=>{if(O.inputIndices.includes(N)){let K=L.symbolToIndices.get(R);if(K===void 0)throw new Error("Invalid symbol error");K.forEach(Q=>{S.push(`${u[N].indicesSet(`input${N}Indices`,Q,`${R}`)}`)}),x.push(`prod *= ${u[N].getByIndices(`input${N}Indices`)};`)}}),A.push(`for(var ${R}: u32 = 0; ${R} < uniforms.${bu(R)}; ${R}++) {`),I.push("}")});let P=E?[...y,`let sum = ${u.map((O,R)=>O.getByIndices(`input${R}Indices`)).join(" * ")};`]:[...y,_,...A,...S,w,...x,v,...I];return`\n            ${d.registerUniforms(p.map(O=>({name:`${bu(O)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...u,c)}\n\n            ${d.mainStart()}\n            ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${c.offsetToIndices("global_idx")};\n            ${u.map((O,R)=>`var input${R}Indices: ${u[R].type.indices};`).join(`\n`)}\n            ${P.join(`\n`)};\n            ${c.setByOffset("global_idx","sum")};\n          }`};return{name:"Einsum",shaderCache:{hint:r.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let d=p.filter(w=>r.symbolToInfo.has(w)).map(w=>({type:12,data:r.symbolToInfo.get(w)?.dimValue||0}));d.push({type:12,data:a});let y=e.map((w,_)=>[...Z(w)]).reduce((w,_)=>w.concat(_),d);return y.push(...Z(o)),{outputs:[{dims:o,dataType:t}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:y}},getShaderSource:h}},wu=(e,t)=>{let r=new jo(e.inputs,t.equation),o=r.outputDims,i=e.inputs.map((u,a)=>u.dims);e.compute(Nc(i,e.inputs[0].dataType,r,o))},vu=e=>{let t=e.equation.replace(/\\s+/g,"");return ve({equation:t})}});var Gc,_u,Hc,Lc,Su,xu=Y(()=>{"use strict";ye();Se();_e();Gc=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,i=t.length<r.length?0:t.length-r.length;for(;o<r.length&&i<t.length;++o,++i)if(r[o]!==t[i]&&r[o]!==1&&t[i]!==1)throw new Error("Expand requires shape to be broadcastable to input")},_u=(e,t)=>{let r=e.length-t.length,o=[];for(let i=0;i<r;++i)o.push(e[i]);for(let i=0;i<t.length;++i)o.push(t[i]===1?e[i+r]:t[i]);return o},Hc=(e,t)=>e.length>t.length?_u(e,t):_u(t,e),Lc=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=Hc(t,r),i=e[0].dataType,u=i===9?4:1,a=Math.ceil(M.size(o)/u),c=h=>{let d=U("input",i,t.length,u),y=j("output",i,o.length,u),w;if(i===9){let _=(v,S,A="")=>`\n          let outputIndices${S} = ${y.offsetToIndices(`outputOffset + ${S}u`)};\n          let offset${S} = ${d.broadcastedIndicesToOffset(`outputIndices${S}`,y)};\n          let index${S} = offset${S} / 4u;\n          let component${S} = offset${S} % 4u;\n          ${v}[${S}] = ${A}(${d.getByOffset(`index${S}`)}[component${S}]);\n        `;w=`\n        let outputOffset = global_idx * ${u};\n        var data = vec4<u32>(0);\n        ${_("data",0,"u32")}\n        ${_("data",1,"u32")}\n        ${_("data",2,"u32")}\n        ${_("data",3,"u32")}\n        ${y.setByOffset("global_idx","data")}\n      }`}else w=`\n        let outputIndices = ${y.offsetToIndices("global_idx")};\n        let inputOffset = ${d.broadcastedIndicesToOffset("outputIndices",y)};\n        ${y.setByOffset("global_idx",d.getByOffset("inputOffset"))}\n      }`;return`\n    ${h.registerUniform("vec_size","u32").declareVariables(d,y)}\n    ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${w}`},p=[{type:12,data:a},...Z(t,o)];return{name:"Expand",shaderCache:{hint:`${o.length}`,inputDependencies:["rank"]},getShaderSource:c,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p})}},Su=e=>{Gc(e.inputs),e.compute(Lc(e.inputs),{inputs:[0]})}});var Fc,Cu,Au=Y(()=>{"use strict";ye();Se();_e();Rn();Fc=e=>{let t=e[0].dataType,r=M.size(e[0].dims),o=M.size(e[1].dims),i=o%4===0,u=a=>{let c=U("x",t,[1],4),p=U("bias",t,[1],4),h=j("y",t,[1],4),d=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],y=_=>`\n      let bias${_}_offset: u32 = (global_idx * 4 + ${_}) % uniforms.bias_size;\n      let bias${_} = ${p.getByOffset(`bias${_}_offset / 4`)}[bias${_}_offset % 4];`,w=i?`\n      let bias = ${p.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${y(0)}${y(1)}${y(2)}${y(3)}\n      let bias = ${c.type.value}(bias0, bias1, bias2, bias3);`;return`${a.registerUniforms(d).declareVariables(c,p,h)}\n\n    ${Bo(et(t))}\n\n    ${a.mainStart(or)}\n      ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}\n\n      let x = ${c.getByOffset("global_idx")};\n      ${w}\n      let x_in = x + bias;\n      ${h.setByOffset("global_idx",Do("x_in"))}\n    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${i}`,inputDependencies:["type","type"]},getShaderSource:u,getRunData:a=>({outputs:[{dims:a[0].dims,dataType:a[0].dataType}],programUniforms:[{type:12,data:Math.ceil(r/4)},{type:12,data:o}],dispatchGroup:{x:Math.ceil(r/or/4)}})}},Cu=e=>{e.inputs.length<2||M.size(e.inputs[1].dims)===0?Bs(e):e.compute(Fc(e.inputs))}});var qc,jc,Iu,Tu,Eu=Y(()=>{"use strict";ye();Se();Ze();_e();qc=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},jc=(e,t)=>{let r=e[0].dims,o=e[1].dims,i=r.length,u=M.normalizeAxis(t.axis,i),a=r.slice(0);a.splice(u,1,...o);let c=r[u],p=e[0].dataType===9?4:1,h=Math.ceil(M.size(a)/p),d=[{type:12,data:h},{type:6,data:c},{type:12,data:u},...Z(e[0].dims,e[1].dims,a)],y=w=>{let _=U("data",e[0].dataType,e[0].dims.length,p),v=U("inputIndices",e[1].dataType,e[1].dims.length),S=j("output",e[0].dataType,a.length,p),A=x=>{let E=o.length,P=`var indicesIndices${x}  = ${v.type.indices}(0);`;for(let O=0;O<E;O++)P+=`${E>1?`indicesIndices${x}[${O}]`:`indicesIndices${x}`} = ${a.length>1?`outputIndices${x}[uniforms.axis + ${O}]`:`outputIndices${x}`};`;P+=`\n          var idx${x} = ${v.getByIndices(`indicesIndices${x}`)};\n          if (idx${x} < 0) {\n            idx${x} = idx${x} + uniforms.axisDimLimit;\n          }\n          var dataIndices${x} : ${_.type.indices};\n        `;for(let O=0,R=0;O<i;O++)O===u?(P+=`${i>1?`dataIndices${x}[${O}]`:`dataIndices${x}`} = u32(idx${x});`,R+=E):(P+=`${i>1?`dataIndices${x}[${O}]`:`dataIndices${x}`} = ${a.length>1?`outputIndices${x}[${R}]`:`outputIndices${x}`};`,R++);return P},I;if(e[0].dataType===9){let x=(E,P,O="")=>`\n          let outputIndices${P} = ${S.offsetToIndices(`outputOffset + ${P}u`)};\n          ${A(P)};\n          let offset${P} = ${_.indicesToOffset(`dataIndices${P}`)};\n          let index${P} = offset${P} / 4u;\n          let component${P} = offset${P} % 4u;\n          ${E}[${P}] = ${O}(${_.getByOffset(`index${P}`)}[component${P}]);\n        `;I=`\n        let outputOffset = global_idx * ${p};\n        var value = vec4<u32>(0);\n        ${x("value",0,"u32")}\n        ${x("value",1,"u32")}\n        ${x("value",2,"u32")}\n        ${x("value",3,"u32")}\n        ${S.setByOffset("global_idx","value")}\n      `}else I=`\n      let outputIndices = ${S.offsetToIndices("global_idx")};\n      ${A("")};\n      let value = ${_.getByIndices("dataIndices")};\n      ${S.setByOffset("global_idx","value")};\n      `;return`\n      ${w.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(_,v,S)}\n      ${w.mainStart()}\n        ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${I}\n      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:d}),getShaderSource:y}},Iu=e=>ve({axis:e.axis}),Tu=(e,t)=>{let r=e.inputs;qc(r),e.compute(jc(e.inputs,t))}});var Kc,Yc,Pu,ku,Ou=Y(()=>{"use strict";ye();Se();Ze();_e();Kc=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Yc=(e,t)=>{let r=e[0].dims,o=e[0].dataType,i=r.length,u=e[1].dims,a=e[1].dataType,c=M.normalizeAxis(t.axis,i),p=r[c],h=u.slice(0),d=M.size(h),y=U("input",o,i),w=U("indicesInput",a,u.length),_=j("output",o,h.length),v=[{type:12,data:d},{type:6,data:p},{type:12,data:c}];return v.push(...Z(r,u,h)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:h,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:v}),getShaderSource:I=>`\n      ${I.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(y,w,_)}\n      ${I.mainStart()}\n      ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${_.offsetToIndices("global_idx")};\n\n      var idx = ${w.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${y.type.indices}(outputIndices);\n      ${y.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${y.getByIndices("inputIndices")};\n\n      ${_.setByOffset("global_idx","value")};\n  }`}},Pu=e=>ve({axis:e.axis}),ku=(e,t)=>{let r=e.inputs;Kc(r),e.compute(Yc(e.inputs,t))}});var Zc,Xc,Ru,Bu,Du=Y(()=>{"use strict";ye();Se();_e();Zc=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Xc=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[i,u,a]=Sn.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),c=[i,u];if(!c)throw new Error("Can\'t use gemm on the given tensors");let p=M.size(c),h=[{type:12,data:p},{type:12,data:i},{type:12,data:u},{type:12,data:a},{type:1,data:t.alpha},{type:1,data:t.beta}],d=["type","type"];e.length===3&&(h.push(...Z(e[2].dims)),d.push("rank")),h.push(...Z(c));let y=w=>{let _="";t.transA&&t.transB?_="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":t.transA&&!t.transB?_="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!t.transA&&t.transB?_="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!t.transA&&!t.transB&&(_="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let v=t.alpha===1?"":"value *= uniforms.alpha;",S=U("a",e[0].dataType,e[0].dims),A=U("b",e[1].dataType,e[1].dims),I=S.type.value,x=null,E=[S,A];e.length===3&&(x=U("c",e[2].dataType,e[2].dims.length),E.push(x));let P=j("output",e[0].dataType,c.length);E.push(P);let O=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`\n  ${w.registerUniforms(O).declareVariables(...E)}\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${I}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${_}\n    }\n\n    ${v}\n    ${(()=>x!=null?`let cOffset = ${x.broadcastedIndicesToOffset("vec2(m, n)",P)}; value += ${I}(uniforms.beta) * ${x.getByOffset("cOffset")};`:"")()}\n    output[global_idx] = value;\n  }`};return{name:"Gemm",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:c,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:h}),getShaderSource:y}},Ru=e=>{let t=e.transA,r=e.transB,o=e.alpha,i=e.beta;return{transA:t,transB:r,alpha:o,beta:i,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},Bu=(e,t)=>{Zc(e.inputs),e.compute(Xc(e.inputs,t))}});var Qc,Jc,ep,zu,Mu=Y(()=>{"use strict";ye();Se();_e();Qc=(e,t)=>{let r=e[0].dims,o=r,i=2,u=M.sizeToDimension(r,i),a=M.sizeFromDimension(r,i),c=Me(a),p=a/c,h=[r[0],r[1],p],d=["rank","type","type"],y=[{type:12,data:a},{type:12,data:p}];y.push(...Z(h,h));let w=_=>{let v=U("x",e[0].dataType,h.length,c),S=U("scale",e[1].dataType,e[1].dims),A=U("bias",e[2].dataType,e[2].dims),I=j("output",e[0].dataType,h.length,c),x=[v,S,A,I],E=v.type.value,P=c===1?"f32":`vec${c}<f32>`,O=64,R=[{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}];return`\n  var<workgroup> meanShared : f32;\n  var<workgroup> squaredNormShared : f32;\n  var<workgroup> workgroupShared : array<${P}, ${O}>;\n  const workgroupSize = ${O}u;\n  ${_.registerUniforms(R).declareVariables(...x)}\n  ${_.mainStart(O)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / uniforms.x_shape[1];\n    let channel = norm % uniforms.x_shape[1];\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial = ${P}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      initial = initial + ${P}(${v.get("batch","channel","h")});\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = ${_t("workgroupShared[0]",c)} / f32(uniforms.normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = ${P}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let deviation =  ${P}(${v.get("batch","channel","h")}) - ${P}(meanShared);\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = ${_t("workgroupShared[0]",c)};\n    }\n    workgroupBarrier();\n\n    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${t.epsilon}));\n    let channelScale = invStdDev * f32(${S.getByOffset("channel")});\n    let channelShift = f32(${A.getByOffset("channel")}) - meanShared * channelScale;\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let value = ${v.get("batch","channel","h")} * ${E}(${P}(channelScale)) + ${E}(${P}(channelShift));\n      ${I.set("batch","channel","h","value")};\n    }\n  }`};return{name:"InstanceNormalization",shaderCache:{hint:`${t.epsilon};${c}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:u},programUniforms:y}),getShaderSource:w}},Jc=(e,t,r,o,i,u,a,c)=>{let p=Me(a),h=64,d=p===1?"vec2f":`mat2x${p}f`,y=p===1?"f32":`vec${p}f`,w=(R,L)=>`${d}(${R}, ${L})`,_=i*a/p,v=Math.ceil(u/h),S=["type"],A=[{type:12,data:v},{type:12,data:u},{type:12,data:Math.floor(a/p)},{type:12,data:Math.floor(u*a/p)}],I=R=>{let L=U("input",t.dataType,t.dims,p);return`\n  ${R.declareVariables(L)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${d}>;\n  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};\n  @group(0) @binding(2) var<uniform> uniforms: Uniforms;\n\n  ${R.mainStart(h)}\n    let currentImageNumber = global_idx / ${h} / uniforms.C;\n    let currentChannelNumber = (global_idx / ${h}) % uniforms.C;\n    let wgOffset = local_id.x * uniforms.wg_size;\n    if (wgOffset >= uniforms.H) {\n        return;\n    }\n    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);\n\n    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;\n    var sum = ${$t("f32",p)};\n    var squaredSum = ${$t("f32",p)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${y}(input[offset + i * uniforms.C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${w("sum","squaredSum")};\n  }`},x=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${p}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:[i,a,h,2],dataType:1}],dispatchGroup:{x:i*a/p},programUniforms:A}),getShaderSource:I},{inputs:[t],outputs:[-1]})[0],E=[{type:12,data:_},{type:12,data:u},{type:12,data:Math.floor(a/p)},{type:12,data:Math.floor(h*a/p)}],P=["type","type","type"],O=R=>{let L=U("scale",r.dataType,r.dims,p),N=U("bias",o.dataType,o.dims,p);return`\n  @group(0) @binding(0) var<storage, read> input : array<${d}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${L.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${N.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${d}>;\n  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};\n  @group(0) @binding(4) var<uniform> uniforms: Uniforms;\n\n  ${R.mainStart()}\n    ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}\n    let currentImageNumber = global_idx / uniforms.C;\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let offset = currentImageNumber * uniforms.image_size;\n    var sum = ${$t("f32",p)};\n    var squaredSum = ${$t("f32",p)};\n    for (var i: u32 = 0; i < min(${h}, uniforms.H); i++) {\n        let value = input[offset + i + currentChannelNumber * ${h}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(uniforms.H);\n    squaredSum = squaredSum / f32(uniforms.H);\n    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${c}));\n    let channelScale = invStdDev * ${y}(scale[currentChannelNumber]);\n    let channelShift = ${y}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${w("channelScale","channelShift")};\n  }`};return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${p};${c}`,inputDependencies:P},getRunData:()=>({outputs:[{dims:[i,a,2],dataType:1}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:E}),getShaderSource:O},{inputs:[x,r,o],outputs:[-1]})[0]},ep=(e,t,r)=>{let o=t[0].dims,i=o,u=o[0],a=o[o.length-1],c=M.sizeFromDimension(o,1)/a,p=Me(a),h=M.size(i)/p,d=[{type:12,data:c},{type:12,data:Math.floor(a/p)}],y=["type","type"],w=Jc(e,t[0],t[1],t[2],u,c,a,r.epsilon),_=v=>{let S=De(t[0].dataType),A=p===1?"vec2f":`mat2x${p}f`,I=p===1?S:`vec${p}<${S}>`,x=U("input",t[0].dataType,t[0].dims,p),E=j("output",t[0].dataType,i,p);return`\n  @group(0) @binding(0) var<storage, read> input : array<${x.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${A}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${E.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${v.mainStart()}\n    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${I}(scale[0]), ${I}(scale[1]));\n  }`};e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${p}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:i,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:d}),getShaderSource:_},{inputs:[t[0],w]})},zu=(e,t)=>{t.format==="NHWC"?ep(e,e.inputs,t):e.compute(Qc(e.inputs,t))}});var tp,rp,Uu,Vu=Y(()=>{"use strict";ye();Se();_e();tp=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},rp=(e,t,r)=>{let o=t.simplified,i=e[0].dims,u=e[1],a=!o&&e[2],c=i,p=M.normalizeAxis(t.axis,i.length),h=M.sizeToDimension(i,p),d=M.sizeFromDimension(i,p),y=M.size(u.dims),w=a?M.size(a.dims):0;if(y!==d||a&&w!==d)throw new Error(`Size of X.shape()[axis:] == ${d}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${y} and bias size of ${w}`);let _=[];for(let O=0;O<i.length;++O)O<p?_.push(i[O]):_.push(1);let v=Me(d),S=["type","type"],A=[{type:12,data:h},{type:1,data:d},{type:12,data:Math.floor(d/v)},{type:1,data:t.epsilon}];a&&S.push("type");let I=r>1,x=r>2,E=O=>{let R=De(e[0].dataType),L=[U("x",e[0].dataType,e[0].dims,v),U("scale",u.dataType,u.dims,v)];a&&L.push(U("bias",a.dataType,a.dims,v)),L.push(j("output",e[0].dataType,c,v)),I&&L.push(j("mean_data_output",1,_)),x&&L.push(j("inv_std_output",1,_));let N=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`\n  ${O.registerUniforms(N).declareVariables(...L)}\n  ${O.mainStart()}\n    ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${$t("f32",v)};\n    var mean_square_vector = ${$t("f32",v)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${ir(R,v,"x[h + offset]")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${_t("mean_vector",v)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${_t("mean_square_vector",v)} / uniforms.norm_size ${o?"":"- mean * mean"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${ir(R,v,"x[j + offset]")};\n      let f32scale = ${ir(R,v,"scale[j]")};\n      output[j + offset] = ${L[0].type.value}((f32input ${o?"":"- mean"}) * inv_std_dev * f32scale\n        ${a?`+ ${ir(R,v,"bias[j]")}`:""}\n      );\n    }\n\n    ${I?"mean_data_output[global_idx] = mean":""};\n    ${x?"inv_std_output[global_idx] = inv_std_dev":""};\n  }`},P=[{dims:c,dataType:e[0].dataType}];return I&&P.push({dims:_,dataType:1}),x&&P.push({dims:_,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${v};${r};${o}`,inputDependencies:S},getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(h/64)},programUniforms:A}),getShaderSource:E}},Uu=(e,t)=>{tp(e.inputs),e.compute(rp(e.inputs,t,e.outputCount))}});var np,op,Wu,Nu,Gu=Y(()=>{"use strict";ye();Se();Ze();_e();np=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let r=e[0],o=r.dims.length;if(r.dims[o-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let i=Math.floor((t.k+t.blockSize-1)/t.blockSize),u=t.blockSize/8*t.bits,a=e[1];if(!M.areEqual(a.dims,[t.n,i,u]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let p=e[2].dims;if(M.size(p)!==t.n*i)throw new Error("scales input size error.");if(e.length===4){let d=e[3].dims,y=t.bits>4?t.n*i:t.n*Math.floor((i+1)/2);if(M.size(d)!==y)throw new Error("zeroPoints input size error.")}},op=(e,t,r,o)=>{let i=e[0].dims,u=i.length,a=Math.floor((t.k+t.blockSize-1)/t.blockSize),c=i[u-2],p=t.k,h=t.n,d=i.slice(0,u-2),y=M.size(d),_=t.blockSize/8*t.bits/4,v=e[0].dataType,S=Me(c),A=Me(t.k),I=Me(_),x=tr(v),E=c*a*x,P=Math.floor(o/E),O=a<=r[0]&&P>0,R=!O||P>=4?Me(h):P>=2&&Me(h)>=2?2:1,L=d.concat([c,h]),N=M.size(L)/R/S,K=O?[]:[{type:12,data:N},{type:12,data:t.blockSize}],Q=[y,c,p/A],he=M.convertShape(e[1].dims).slice();he.splice(-1,1,_/I),K.push(...Z(Q)),K.push(...Z(he)),K.push(...Z(e[2].dims)),e.length===4&&K.push(...Z(M.convertShape(e[3].dims)));let W=[y,c,h/R];K.push(...Z(W));let se=Ce=>{let We=Q.length,ee=U("a",e[0].dataType,We,A),ae=U("b",12,he.length,I),Ae=U("scales",e[2].dataType,e[2].dims.length),me=[ee,ae,Ae],ie=e.length===4?U("zero_points",12,e[3].dims.length):void 0;ie&&me.push(ie);let ue=W.length,le=j("output",e[0].dataType,ue,R),qe=[{name:"output_size",type:"u32"},{name:"block_size",type:"u32"}],G=De(e[0].dataType),ne=(()=>{switch(A){case 1:return`array<${G}, 8>`;case 2:return`mat4x2<${G}>`;case 4:return`mat2x4<${G}>`;default:throw new Error(`${A}-component is not supported.`)}})(),xe=`\n        for (var word: u32 = 0; word < ${_}; word += ${I}) {\n          ${ae.indicesSet("b_indices","2","word")};\n          let b_data = ${ae.getByIndices("b_indices")};\n          for (var i: u32 = 0; i < ${I}; i++) {\n            let b_value: u32 = ${I===1?"b_data":"b_data[word + i]"};\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            let b_value_lower: vec4<u32> = unpack4xU8(b_value & b_mask);\n            let b_value_upper: vec4<u32> = unpack4xU8((b_value >> 4) & b_mask);\n            let b_quantized_values = ${ne}(${Array.from({length:4},(Be,Ge)=>`${G}(b_value_lower[${Ge}]), ${G}(b_value_upper[${Ge}])`).join(", ")});\n            let b_dequantized_values = ${(()=>A===1?`${ne}(${Array.from({length:8},(Be,Ge)=>`(b_quantized_values[${Ge}] - zero_point) * scale`).join(", ")});`:`(b_quantized_values - ${ne}(${Array(8).fill("zero_point").join(",")})) * scale;`)()};\n            // Number of B elements per 32-bit word is 32/bits = 32/4 = 8\n            for (var m: u32 = 0; m < ${O?c:S}u; m++) {\n              ${ee.indicesSet("a_indices",We-2,O?"m":`row * ${S} + m`)};\n              ${ee.indicesSet("a_indices",We-1,"word_offset")};\n              var input_offset = ${ee.indicesToOffset("a_indices")};\n              var a_data: ${ne};\n              for (var j: u32 = 0; j < ${8/A}; j++) {\n                a_data[j] = ${ee.getByOffset("input_offset")};\n                input_offset++;\n              }\n              ${O?"workgroup_shared[workgroup_shared_offset + m]":"output_values[m]"}${R>1?"[c]":""} += ${Array.from({length:8/A},(Be,Ge)=>`${A===1?`a_data[${Ge}] * b_dequantized_values[${Ge}]`:`dot(a_data[${Ge}], b_dequantized_values[${Ge}])`}`).join(" + ")};\n            }\n            word_offset += ${8/A};\n          }\n        }`,Ke=ie?`\n          zero_point_offset += 4;\n          if (zero_point_offset == 32) {\n            zero_point_offset = 0;\n            zero_point_index++;\n            zero_point_word = ${ie.getByOffset("zero_point_index")};\n          }`:"";return O?`\n        var<workgroup> workgroup_shared: array<${le.type.value}, ${c*a}>;\n        ${Ce.declareVariables(...me,le)}\n        ${Ce.mainStart([a,1,1])}\n          var a_indices: ${ee.type.indices};\n          var block = local_id.x;\n          var col = workgroup_id.y;\n          var batch = workgroup_id.z;\n          ${ee.indicesSet("a_indices","0","batch")};\n          // Two zero points are packed into one byte when uniforms.bits is 4.\n          for (var c: u32 = 0; c < ${R}; c++) {\n            let col_times_components_plus_c = col * ${R} + c;\n              ${ie?`\n            var zero_point_bytes_per_col: u32 = (${a} + 1) / 2;\n            var zero_point_byte_count: u32 = col_times_components_plus_c * zero_point_bytes_per_col + (block >> 0x1u);\n            var zero_point_word_index: u32 = zero_point_byte_count >> 0x2u;\n            var zero_point_byte_offset: u32 = zero_point_byte_count & 0x3u;\n            var zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32 = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            var zero_point_word: u32 = ${ie.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;`:""}\n            var b_indices: ${ae.type.indices};\n            ${ae.indicesSet("b_indices","0","col_times_components_plus_c")};\n            // The scale and zero points are computed per block.\n            var scales_index = col_times_components_plus_c * ${a} + block;\n            let scale = ${Ae.getByOffset("scales_index")};\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${G}(${ie?"(zero_point_word) & 0xFu":8});\n            ${ae.indicesSet("b_indices","1","block")};\n            var word_offset: u32 = block * ${t.blockSize/A};\n            var workgroup_shared_offset: u32 = block * ${c};\n            ${xe}\n          }\n          workgroupBarrier();\n          if (local_id.x == 0u) {\n            var output_indices: ${le.type.indices};\n            ${le.indicesSet("output_indices","0","batch")};\n            ${le.indicesSet("output_indices",ue-1,"col")};\n            ${le.indicesSet("output_indices",ue-2,"0")};\n            var output_offset = ${le.indicesToOffset("output_indices")};\n            for (var m: u32 = 0u; m < ${c}u; m++) {\n              var output_value: ${le.type.value} = ${le.type.value}(0);\n              var workgroup_shared_offset: u32 = m;\n              for (var b: u32 = 0u; b < ${a}u; b++) {\n                output_value += workgroup_shared[workgroup_shared_offset];\n                workgroup_shared_offset += ${c};\n              }\n              ${le.setByOffset("output_offset","output_value")};\n              output_offset += ${h/R};\n            }\n          }\n        }`:`\n        ${Ce.registerUniforms(qe).declareVariables(...me,le)}\n        ${Ce.mainStart()}\n          ${Ce.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var output_values: array<${le.type.value}, ${S}>;\n          var output_indices = ${le.offsetToIndices("global_idx")};\n          var col = ${le.indicesGet("output_indices",ue-1)};\n          var row = ${le.indicesGet("output_indices",ue-2)};\n          var a_indices: ${ee.type.indices} = output_indices;\n          // Two zero points are packed into one byte because uniforms.bits <= 4.\n          // zero_point_offset is either 0 or 4. It is bit offset within one byte.\n          // TODO support zero_point_offset for bits > 4\n          ${ie?`\n          var zero_point_abs_offset = col * ${R} * ((${a} + 1) / 2);\n          var zero_point_index: u32 = zero_point_abs_offset / 4;\n          var zero_point_word: u32 = ${ie.getByOffset("zero_point_index")};\n          var zero_point_offset: u32 = (zero_point_abs_offset % 4) * 8;`:""}\n          var scale_index = col * ${a*R};\n          var b_indices: ${ae.type.indices};\n          for (var c: u32 = 0; c < ${R}; c++) {\n            ${ae.indicesSet("b_indices","0",`col * ${R} + c`)};\n            var block_offset: u32 = 0;\n            for (var block: u32 = 0; block < ${a}; block++) {\n              // The scale and zero points are computed per block.\n              let scale = ${Ae.getByOffset("scale_index")};\n              // The default zero point is 8 for unsigned 4-bit quantization.\n              let zero_point = ${G}(${ie?"extractBits(zero_point_word, zero_point_offset, 4)":8});\n              ${ae.indicesSet("b_indices","1","block")};\n              var word_offset: u32 = block_offset;\n              ${xe}\n              scale_index++;\n              ${Ke}\n              block_offset += uniforms.block_size / ${A};\n            }\n            // Drop the trailing 4 bits if the zero_poit_offset is not a byte boundary to align with the next byte.\n            ${ie?`if (zero_point_offset % 8 > 0) {\n                ${Ke}\n              }`:""}\n            }\n            for (var k: u32 = 0u; k < ${S}u; k++) {\n              ${le.indicesSet("output_indices",ue-2,`${S} * row + k`)};\n              ${le.setByIndices("output_indices","output_values[k]")}\n            }\n        }`};return{name:O?"BlockwiseMatMulNBits":"MatMulNBits",shaderCache:{hint:`${t.cacheKey};${c};${v};${e.length}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:L,dataType:v}],name:O?"BlockwiseMatMulNBits":"MatMulNBits",dispatchGroup:O?{x:1,y:Math.ceil(h/R),z:y}:{x:Math.ceil(N/64)},programUniforms:K}),getShaderSource:se}},Wu=(e,t)=>{np(e.inputs,t);let r=e.getMaxComputeWorkgroupSizes(),o=e.getMaxComputeWorkgroupStoragesize();e.compute(op(e.inputs,t,r,o))},Nu=e=>ve(e)});var it,ip,Lu,Hu,ap,Ko,Fu,qu=Y(()=>{"use strict";ye();Se();Ze();_n();Ro();_e();Sr();it=(e,t)=>e.length>t&&e[t].dims.length>0&&M.size(e[t].dims)>0?e[t]:void 0,ip=(e,t)=>{let r=e[0],o=it(e,1),i=it(e,2),u=it(e,3),a=it(e,4),c=it(e,5),p=it(e,6),h=it(e,7);if(r.dims.length!==3&&r.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let d=!1,y=r.dims[0],w=r.dims[1],_=r.dims.length===3?d?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],v=w,S=0,A=0,I=Math.floor(_/t.numHeads);if(p&&h){if(p.dims.length!==4)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(p.dims[0]!==y||p.dims[1]!==t.numHeads||p.dims[3]!==I)throw new Error(\'Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)\');if(h.dims[0]!==y||h.dims[1]!==t.numHeads||h.dims[3]!==I)throw new Error(\'Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)\');if(p.dims[2]!==h.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)\');if(h.dims.length!==4)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');S=p.dims[2],A=p.dims[2]}else if(p||h)throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');let x;if(o){if(r.dims.length!==3)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(o.dims.length<3||o.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(r.dims[0]!==o.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(o.dims.length===3){if(o.dims[2]!==r.dims[2])throw new Error(\'Input "query" and "key" shall have same dim 2 (hidden_size)\');x=2,v=o.dims[1]}else if(o.dims.length===5){if(o.dims[2]!==t.numHeads||o.dims[3]!==2||o.dims[4]!==I)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(i)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');x=5,v=o.dims[1]}else{if(o.dims[1]!==t.numHeads||o.dims[3]!==I)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');x=0,v=o.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\'Input "query" is expected to have 3 or 5 dimensions when key is empty\');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');x=3}if(u){if(u.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimension\');if(i&&r.dims.length===5&&r.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let E=0;if(a){E=8;let N=a.dims;throw N.length===1?N[0]===y?E=1:N[0]===3*y+2&&(E=3):N.length===2&&N[0]===y&&N[1]===v&&(E=5),E===8?new Error(\'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)\'):new Error("Mask not supported")}let P=!1,O=_;if(i){if(i.dims.length!==3&&i.dims.length!==4)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(r.dims[0]!==i.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(i.dims.length===3){if(v!==i.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');O=i.dims[2]}else{if(v!==i.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)\');O=i.dims[1]*i.dims[3],P=!0}}let R=S+v,L=!1;if(a)throw new Error("Key padding mask is not supported");if(c){if(c.dims.length!==4)throw new Error(\'Input "relative_position_bias" is expected to have 4 dimensions\');if(c.dims[0]!==y&&c.dims[0]!==1||c.dims[1]!==t.numHeads||c.dims[2]!==w||c.dims[3]!==R)throw new Error(\'Input "relative_position_bias" shape (batch_size, 1, sequence_length, kv_sequence_length)\')}return{batchSize:y,sequenceLength:w,pastSequenceLength:S,kvSequenceLength:v,totalSequenceLength:R,maxSequenceLength:A,inputHiddenSize:0,hiddenSize:_,vHiddenSize:O,headSize:I,vHeadSize:Math.floor(O/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:E,scale:t.scale,broadcastResPosBias:L,passPastInKv:P,qkvFormat:x}},Lu=e=>ve({...e}),Hu=ve({perm:[0,2,1,3]}),ap=(e,t,r,o,i,u,a)=>{let c=[o,i,u],p=M.size(c),h=[{type:12,data:p},{type:12,data:a},{type:12,data:u}],d=y=>{let w=j("qkv_with_bias",t.dataType,c),_=U("qkv",t.dataType,c),v=U("bias",r.dataType,c),S=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`\n  ${y.registerUniforms(S).declareVariables(_,v,w)}\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`};return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:c,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:h}),getShaderSource:d},{inputs:[t,r],outputs:[-1]})[0]},Ko=(e,t,r,o,i,u,a,c)=>{let p=u;if(a){if(o===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return p=ap(e,u,a,t,o,r*i,c),p=p.reshape([t,o,r,i]),e.compute(yt(p,Hu.perm),{inputs:[p],outputs:[-1]})[0]}else return u.dims.length===3&&(p=u.reshape([t,o,r,i])),e.compute(yt(p,Hu.perm),{inputs:[p],outputs:[-1]})[0]},Fu=(e,t)=>{let r=ip(e.inputs,t),o=e.inputs[0],i=it(e.inputs,1),u=it(e.inputs,2),a=it(e.inputs,3),c=it(e.inputs,4),p=it(e.inputs,5),h=it(e.inputs,6),d=it(e.inputs,7);if(o.dims.length===5)throw new Error("Packed QKV is not implemented");if(i?.dims.length===5)throw new Error("Packed KV is not implemented");let y=i&&u&&i.dims.length===4&&u.dims.length===4,w=Ko(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,o,a,0);if(y)return Pn(e,w,i,u,c,void 0,h,d,p,r,t);if(!i||!u)throw new Error("key and value must be provided");let _=Ko(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,i,a,r.hiddenSize),v=Ko(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,u,a,2*r.hiddenSize);Pn(e,w,_,v,c,void 0,h,d,p,r,t)}});var sp,up,dp,lp,cp,pp,mp,fp,ju,Ku=Y(()=>{"use strict";ye();Se();_e();sp=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},up=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n            k = i32(${e.indicesGet("indices",i)}) - ${fe("uniforms.pads",i,r)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${fe("uniforms.x_shape",i,t)})) {\n              break;\n            }\n            offset += k * i32(${fe("uniforms.x_strides",i,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${o}\n            value = x[offset];\n          }\n      `},dp=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n                k = i32(${e.indicesGet("indices",i)}) - ${fe("uniforms.pads",i,r)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${fe("uniforms.x_shape",i,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${fe("uniforms.x_shape",i,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${fe("uniforms.x_strides",i,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},lp=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n                k = i32(${e.indicesGet("indices",i)}) - ${fe("uniforms.pads",i,r)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${fe("uniforms.x_shape",i,t)})) {\n                  k = i32(${fe("uniforms.x_shape",i,t)}) - 1;\n                }\n                offset += k * i32(${fe("uniforms.x_strides",i,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},cp=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n                k = i32(${e.indicesGet("indices",i)}) - ${fe("uniforms.pads",i,r)};\n                if (k < 0)  {\n                  k += i32(${fe("uniforms.x_shape",i,t)}]);\n                }\n                if (k >= i32(${fe("uniforms.x_shape",i,t)})) {\n                  k -= i32(${fe("uniforms.x_shape",i,t)});\n                }\n                offset += k * i32(${fe("uniforms.x_strides",i,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},pp=(e,t,r)=>{switch(r.mode){case 0:return up(e,t,r.pads.length);case 1:return dp(e,t,r.pads.length);case 2:return lp(e,t,r.pads.length);case 3:return cp(e,t,r.pads.length);default:throw new Error("Invalid mode")}},mp=(e,t)=>{let r=M.padShape(e[0].dims.slice(),t.pads),o=e[0].dims,i=M.size(r),u=[{type:12,data:i},{type:6,data:t.pads}];t.mode===0&&u.push({type:e[0].dataType,data:t.value}),u.push(...Z(e[0].dims,r));let a=["rank"],c=p=>{let h=j("output",e[0].dataType,r.length),d=U("x",e[0].dataType,o.length),y=d.type.value,w=pp(h,o.length,t),_=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return t.mode===0&&_.push({name:"constant_value",type:y}),`\n            ${p.registerUniforms(_).declareVariables(d,h)}\n            ${p.mainStart()}\n            ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n            let indices = ${h.offsetToIndices("global_idx")};\n\n            var value = ${y}(0);\n            ${w}\n            output[global_idx] = value;\n        }`};return{name:"Pad",shaderCache:{hint:`${t.mode}`,inputDependencies:a},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(r)/64)},programUniforms:u}),getShaderSource:c}},fp=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,i=e[0].dims.length,u=new Int32Array(2*i).fill(0);if(e.length>=4){let c=e[3].getBigInt64Array();for(let p=0;p<c.length;p++)u[Number(c[p])]=Number(r[p]),u[Number(c[p])+i]=Number(r[p+c.length])}else r.forEach((c,p)=>u[Number(p)]=Number(c));let a=[];return u.forEach(c=>a.push(c)),{mode:t.mode,value:o,pads:a}}else return t},ju=(e,t)=>{sp(e.inputs);let r=fp(e.inputs,t);e.compute(mp(e.inputs,r),{inputs:[0]})}});var Nn,Yu,Zu,Xu,Qu,hp,gp,Ju,ed,td,rd,nd,od,id,ad,sd,ud,dd,ld,cd=Y(()=>{"use strict";$r();ye();Se();_e();Nn=e=>{if(vr.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},Yu=(e,t,r)=>{let o=t.format==="NHWC",i=e.dims.slice();o&&i.splice(1,0,i.pop());let u=Object.hasOwnProperty.call(t,"dilations"),a=t.kernelShape.slice(),c=t.strides.slice(),p=u?t.dilations.slice():[],h=t.pads.slice();nr.adjustPoolAttributes(r,i,a,c,p,h);let d=nr.computePoolOutputShape(r,i,c,p,a,h,t.autoPad),y=Object.assign({},t);u?Object.assign(y,{kernelShape:a,strides:c,pads:h,dilations:p,cacheKey:t.cacheKey}):Object.assign(y,{kernelShape:a,strides:c,pads:h,cacheKey:t.cacheKey});let w=d.slice();return w.push(w.splice(1,1)[0]),[y,o?w:d]},Zu=(e,t)=>{let r=t.format==="NHWC",o=M.size(e),i=M.size(t.kernelShape),u=[{type:12,data:o},{type:12,data:i}],a=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let c=t.kernelShape[t.kernelShape.length-1],p=t.strides[t.strides.length-1],h=t.pads[t.pads.length/2-1],d=t.pads[t.pads.length-1],y=!!(h+d);u.push({type:12,data:c},{type:12,data:p},{type:12,data:h},{type:12,data:d}),a.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let w=!1;if(t.kernelShape.length===2){let _=t.kernelShape[t.kernelShape.length-2],v=t.strides[t.strides.length-2],S=t.pads[t.pads.length/2-2],A=t.pads[t.pads.length-2];w=!!(S+A),u.push({type:12,data:_},{type:12,data:v},{type:12,data:S},{type:12,data:A}),a.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[u,a,!0,y,w]}else{if(r)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let c=M.computeStrides(t.kernelShape);u.push({type:12,data:c},{type:12,data:t.pads},{type:12,data:t.strides}),a.push({name:"kernelStrides",type:"u32",length:c.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let p=t.pads.reduce((h,d)=>h+d);return[u,a,!!p,!1,!1]}},Xu=(e,t,r,o,i,u,a,c,p,h,d,y)=>{let w=i.format==="NHWC",_=t.type.value,v=j("output",t.type.tensor,o);if(i.kernelShape.length<=2){let S="",A="",I="",x=r-(w?2:1);if(d?S=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${x}] = indices[${x}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${x}] < 0 || xIndices[${x}]\n                      >= uniforms.x_shape[${x}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${u}\n                }`:S=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${x}] = indices[${x}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${u}\n                }`,i.kernelShape.length===2){let P=r-(w?3:2);y?A=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${P}] = indices[${P}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${P}] < 0 || xIndices[${P}] >= uniforms.x_shape[${P}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:A=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${P}] = indices[${P}] * uniforms.sh - uniforms.phStart + j;\n                `,I=`\n              }\n            `}return`\n            ${e.registerUniforms(p).declareVariables(t,v)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${v.offsetToIndices("global_idx")};\n              var xIndices = ${v.offsetToIndices("global_idx")};\n\n              var value = ${_}(${c});\n              var pad = 0;\n              ${A}\n              ${S}\n              ${I}\n              ${a}\n\n              output[global_idx] = value;\n            }`}else{if(w)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let S=i.kernelShape.length,A=i.pads.length,I="";return h?I=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${u}\n              }`:I=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${u}\n            `,`\n            ${e.registerUniforms(p).declareVariables(t,v)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${v.offsetToIndices("global_idx")};\n              var xIndices = ${v.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${S}>;\n\n              var value = ${_}(${c});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${S-1}u; j++) {\n                  offsets[j] = offset / ${fe("uniforms.kernelStrides","j",S)};\n                  offset -= offsets[j] * ${fe("uniforms.kernelStrides","j",S)};\n                }\n                offsets[${S-1}] = offset;\n\n                isPad = false;\n                for (var j = ${r-S}u; j < ${r}u; j++) {\n                  xIndices[j] = indices[j] * ${fe("uniforms.strides",`j - ${r-S}u`,S)}\n                    + offsets[j - ${r-S}u] - ${fe("uniforms.pads","j - 2u",A)};\n                  ${I}\n              }\n              ${a}\n\n              output[global_idx] = value;\n            }`}},Qu=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,hp=e=>`${Qu(e)};${e.countIncludePad}`,gp=e=>`${Qu(e)};${e.storageOrder};${e.dilations}`,Ju=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),ed=(e,t,r,o)=>{let[i,u]=Yu(t,o,r),a=U("x",t.dataType,t.dims.length),c=a.type.value,p="value += x_val;",h="";i.countIncludePad?h+=`value /= ${c}(uniforms.kernelSize);`:h+=`value /= ${c}(i32(uniforms.kernelSize) - pad);`;let[d,y,w,_,v]=Zu(u,i);d.push(...Z(t.dims,u));let S=["rank"];return{name:e,shaderCache:{hint:`${o.cacheKey};${w};${_};${v}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(M.size(u)/64)},programUniforms:d}),getShaderSource:A=>Xu(A,a,t.dims.length,u.length,i,p,h,0,y,w,_,v)}},td=e=>{let t=e.count_include_pad!==0,r=Ju(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let o={countIncludePad:t,...r,cacheKey:""};return{...o,cacheKey:hp(o)}},rd=(e,t)=>{Nn(e.inputs),e.compute(ed("AveragePool",e.inputs[0],!1,t))},nd={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},od=e=>{let t=e.format;return{format:t,...nd,cacheKey:t}},id=(e,t)=>{Nn(e.inputs),e.compute(ed("GlobalAveragePool",e.inputs[0],!0,t))},ad=(e,t,r,o)=>{let[i,u]=Yu(t,o,r),a=`\n      value = max(x_val, value);\n    `,c="",p=U("x",t.dataType,t.dims.length),h=["rank"],[d,y,w,_,v]=Zu(u,i);return d.push(...Z(t.dims,u)),{name:e,shaderCache:{hint:`${o.cacheKey};${w};${_};${v}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(M.size(u)/64)},programUniforms:d}),getShaderSource:S=>Xu(S,p,t.dims.length,u.length,i,a,c,t.dataType===10?-65504:-1e5,y,w,_,v)}},sd=(e,t)=>{Nn(e.inputs),e.compute(ad("MaxPool",e.inputs[0],!1,t))},ud=e=>{let t=e.storage_order,r=e.dilations,o=Ju(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let i={storageOrder:t,dilations:r,...o,cacheKey:""};return{...i,cacheKey:gp(i)}},dd=e=>{let t=e.format;return{format:t,...nd,cacheKey:t}},ld=(e,t)=>{Nn(e.inputs),e.compute(ad("GlobalMaxPool",e.inputs[0],!0,t))}});var bp,wp,pd,md=Y(()=>{"use strict";$r();ye();_e();bp=(e,t,r)=>{let o=e===t,i=e<t&&r<0,u=e>t&&r>0;if(o||i||u)throw new Error("Range these inputs\' contents are invalid.")},wp=(e,t,r,o)=>{let i=Math.abs(Math.ceil((t-e)/r)),u=[i],a=i,c=[{type:12,data:a},{type:o,data:e},{type:o,data:r},...Z(u)],p=h=>{let d=j("output",o,u.length),y=d.type.value,w=[{name:"outputSize",type:"u32"},{name:"start",type:y},{name:"delta",type:y}];return`\n        ${h.registerUniforms(w).declareVariables(d)}\n        ${h.mainStart()}\n        ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        output[global_idx] = uniforms.start + ${y}(global_idx) * uniforms.delta;\n      }`};return{name:"Range",shaderCache:{hint:`${o}`},getShaderSource:p,getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:c})}},pd=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),vr.webgpu.validateInputContent&&bp(t,r,o),e.compute(wp(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var vp,$p,_p,Sp,xp,Cp,Ap,Ip,Tp,Ep,Pp,fd,kp,Op,Rp,Bp,Dp,hd,gd,yd=Y(()=>{"use strict";ye();Se();Ze();_e();vp=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},$p=(e,t,r)=>{t.every(i=>i>=0&&i<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((i,u)=>o[i]=e[u]),o},_p=(e,t,r,o,i,u)=>{let[a,c,p]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],h=e[0].dims.length;if(a>0&&e.length>a&&e[a].dims.length>0)e[a].getFloat32Array().forEach(d=>u.push(d));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(c>0&&e.length>c&&e[c].dims.length>0){if(e[c].getFloat32Array().forEach(d=>o.push(d)),o.length!==0&&o.length!==h&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");vp(o,t),t.axes.length>0&&$p(o,t.axes,h).forEach((d,y)=>o[y]=d)}if(p>0&&e.length>p&&(e[p].getBigInt64Array().forEach(d=>i.push(Number(d))),i.length!==h||r>=18&&i.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(i.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof o<"u"&&typeof i<"u"&&o.length>0&&i.length>h)throw new Error("Resize requires only of scales or sizes to be specified")},Sp=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`return ${t}(xResized) / ${t}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n                    // offset-by-one error later in floor().\n                    let whole = ${t}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\n                    let fract =\n                        ${t}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${t}(lengthResized - 1);\n                    return whole + fract;\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",xp=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Cp=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),i=e.length===0?o:e.slice();return t.length>0?(t.forEach((u,a)=>{o[u]=i[a],o[a+r]=i[t.length+a]}),o):i},Ap=(e,t,r,o)=>{let i=[];if(r.length>0)if(o.length>0){if(e.forEach(u=>i.push(u)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((u,a)=>i[u]=r[a])}else r.forEach(u=>i.push(u));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");i=e.map((u,a)=>Math.round(u*t[a]))}return i},Ip=(e,t,r)=>{let o=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map(u=>t[u]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map(u=>t[u]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let i=e.slice();return r.axes.length>0?(r.axes.forEach(u=>t[u]=o),r.axes.forEach(u=>i[u]=Math.round(e[u]*t[u]))):(t.fill(o,0,t.length),i.forEach((u,a)=>i[a]=Math.round(u*t[a]))),i},Tp=(e,t,r,o,i)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {\n      var original_indices: array<${e.type.value}, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${e.indicesGet("output_indices","i")};\n        var scale = ${fe("uniforms.scales","i",o)};\n        var roi_low = ${fe("uniforms.roi","i",i)};\n        var roi_hi = ${fe("uniforms.roi",`i + ${t.length}`,i)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${fe("uniforms.input_shape","i",t.length)};\n          var output_shape_i = ${fe("uniforms.output_shape","i",r.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,Ep=(e,t,r,o,i,u,a)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${o.length}; i++) {\n        var output_index = ${t.indicesGet("output_indices","i")};\n        var input_index: u32;\n        var scale = ${fe("uniforms.scales","i",i)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${fe("uniforms.roi","i",u)};\n          var roi_hi = ${fe("uniforms.roi",`i + ${r.length}`,u)};\n          var input_shape_i = ${fe("uniforms.input_shape","i",r.length)};\n          var output_shape_i = ${fe("uniforms.output_shape","i",o.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${a} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet("input_indices","i"," input_index")}\n      }\n      return input_indices;\n    }`,Pp=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${fe("uniforms.input_shape","i",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,fd=(e,t,r,o)=>e.rank>o?`\n    ${e.indicesSet("input_indices",t,"channel")};\n    ${e.indicesSet("input_indices",r,"batch")};\n`:"",kp=(e,t,r,o,i)=>{let[a,c,p,h]=r.length===2?[-1,0,1,-1]:[0,2,3,1],d=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${d} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",c,`max(0, min(row, ${r[c]} - 1))`)};\n      ${e.indicesSet("input_indices",p,`max(0, min(col, ${r[p]} - 1))`)};\n      ${fd(e,h,a,2)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${d} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${d} = originalIndices[${c}];\n      var col:${d} = originalIndices[${p}];\n      ${o?`if (row < 0 || row > (${r[c]} - 1) || col < 0 || col > (${r[p]} - 1)) {\n        return ${i};\n      }`:""};\n      row = max(0, min(row, ${r[c]} - 1));\n      col = max(0, min(col, ${r[p]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${r.length>2?`u32(originalIndices[${h}])`:"0"};\n      var batch: u32 =  ${r.length>2?`u32(originalIndices[${a}])`:"0"};\n      var x11: ${d} = getInputValue(batch, channel, row1, col1);\n      var x12: ${d} = getInputValue(batch, channel, row1, col2);\n      var x21: ${d} = getInputValue(batch, channel, row2, col1);\n      var x22: ${d} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${d} = abs(row - ${d}(row1));\n      var dx2: ${d} = abs(${d}(row2) - row);\n      var dy1: ${d} = abs(col - ${d}(col1));\n      var dy2: ${d} = abs(${d}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Op=(e,t,r,o,i,u,a,c,p,h)=>{let d=r.length===2,y=!0,[w,_]=d?[0,1]:y?[2,3]:[1,2],v=e.type.value,S=A=>{let I=A===w?"row":"col";return`\n      fn ${I}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${v} {\n        var output_index = ${t.indicesGet("output_indices",A)};\n        var originalIdx: ${v} = getOriginalCoordinateFromResizedCoordinate(output_index, ${i[A]},\n        ${o[A]}, ${r[A]}, ${u[A]}, ${u[A]} + ${r.length});\n        var fractOriginalIdx: ${v} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${c} && (originalIdx < 0 || originalIdx > (${r[A]} - 1))) {\n          return ${p};\n        }\n        var data: array<${v}, 4> = array<${v}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${I}: ${v} = originalIdx + ${v}(i);\n          if (${I} < 0 || ${I} >= ${r[A]}) {\n            ${(()=>h?`coefs[i + 1] = 0.0;\n                        continue;`:c?`return ${p};`:`${I} = max(0, min(${I}, ${r[A]} - 1));`)()};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet("input_indices_copy",A,`u32(${I})`)};\n          data[i + 1] = ${A===w?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${S(w)};\n    ${S(_)};\n  fn getCubicInterpolationCoefs(s: ${v}) -> array<${v}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${v}, 4> = array<${v}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${v} = 1.0 - absS;\n    var twoMinusAbsS: ${v} = 2.0 - absS;\n    var onePlusAbsS: ${v} = 1.0 + absS;\n    coeffs[0] = ((${a} * onePlusAbsS - 5 * ${a}) * onePlusAbsS + 8 * ${a}) * onePlusAbsS - 4 * ${a};\n    coeffs[1] = ((${a} + 2) * absS - (${a} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${a} + 2) * oneMinusAbsS - (${a} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${a} * twoMinusAbsS - 5 * ${a}) * twoMinusAbsS + 8 * ${a}) * twoMinusAbsS - 4 * ${a};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${v}, 4>, coefs: array<${v}, 4>) -> ${v} {\n    var coefsSum: ${v} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${v} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},Rp=(e,t,r,o,i)=>{let[a,c,p,h,d]=r.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],y=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${y} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",c,`max(0, min(depth, ${r[c]} - 1))`)};\n      ${e.indicesSet("input_indices",p,`max(0, min(height, ${r[p]} - 1))`)};\n      ${e.indicesSet("input_indices",h,`max(0, min(width, ${r[h]} - 1))`)};\n      ${fd(e,d,a,3)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${y} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${y} = originalIndices[${c}];\n      var height:${y} = originalIndices[${p}];\n      var width:${y} = originalIndices[${h}];\n      ${o?`if (depth < 0 || depth > (${r[c]} - 1) || height < 0 || height > (${r[p]} - 1) || width < 0 || (width > ${r[h]} - 1)) {\n      return ${i};\n        }`:""};\n\n    depth = max(0, min(depth, ${r[c]} - 1));\n      height = max(0, min(height, ${r[p]} - 1));\n      width = max(0, min(width, ${r[h]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${r.length>3?`u32(originalIndices[${d}])`:"0"};\n      var batch: u32 =  ${r.length>3?`u32(originalIndices[${a}])`:"0"};\n\n      var x111: ${y} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${y} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${y} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${y} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${y} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${y} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${y} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${y} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${y} = abs(depth - ${y}(depth1));\n      var dx2: ${y} = abs(${y}(depth2) - depth);\n      var dy1: ${y} = abs(height - ${y}(height1));\n      var dy2: ${y} = abs(${y}(height2) - height);\n      var dz1: ${y} = abs(width - ${y}(width1));\n      var dz2: ${y} = abs(${y}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},Bp=(e,t,r,o,i,u)=>{let a=e.dims,c=Cp(u,t.axes,a.length),p=Ap(a,o,i,t.axes),h=o.slice();o.length===0&&(h=a.map((x,E)=>x===0?1:p[E]/x),t.keepAspectRatioPolicy!=="stretch"&&(p=Ip(a,h,t)));let d=j("output",e.dataType,p.length),y=U("input",e.dataType,a.length),w=M.size(p),_=a.length===p.length&&a.every((x,E)=>x===p[E]),v=t.coordinateTransformMode==="tf_crop_and_resize",S=t.extrapolationValue,A=y.type.value,I=x=>`\n      ${_?"":`\n      ${Sp(t.coordinateTransformMode,A)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${Pp(y,a)};\n              ${xp(t.nearestMode,r,A)};\n              ${Ep(y,d,a,p,h.length,c.length,v)};\n              `;case"linear":return`\n              ${Tp(d,a,p,h.length,c.length)};\n              ${(()=>{if(a.length===2||a.length===4)return`${kp(y,d,a,v,S)}`;if(a.length===3||a.length===5)return`${Rp(y,d,a,v,S)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\n            `;case"cubic":return`\n            ${(()=>{if(a.length===2||a.length===4)return`${Op(y,d,a,p,h,c,t.cubicCoeffA,v,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${x.registerUniform("output_size","u32").registerUniform("scales","f32",h.length).registerUniform("roi","f32",c.length).declareVariables(y,d)}\n      ${x.mainStart()}\n        ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${_?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${d.offsetToIndices("global_idx")};\n        var input_indices: ${y.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${y.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return`output[global_idx] = ${a.length===2||a.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${h.length>0?h:""}|${i.length>0?i:""}|${c.length>0?c:""}|${_}|${a}`,inputDependencies:["rank"]},getShaderSource:I,getRunData:()=>({outputs:[{dims:p,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:[{type:12,data:w},{type:1,data:h},{type:1,data:c},...Z(a,p)]})}},Dp=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},hd=(e,t)=>{let r=[],o=[],i=[],u=Dp(e);if(t.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");_p(e.inputs,t,u,r,o,i),e.compute(Bp(e.inputs[0],t,u,r,o,i),{inputs:[0]})},gd=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,i=e.cubicCoeffA,u=e.excludeOutside!==0,a=e.extrapolationValue,c=e.keepAspectRatioPolicy,p=e.mode,h=e.nearestMode===""?"simple":e.nearestMode;return ve({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:i,excludeOutside:u,extrapolationValue:a,keepAspectRatioPolicy:c,mode:p,nearestMode:h})}});var zp,Mp,bd,wd=Y(()=>{"use strict";ye();Se();Ze();_e();zp=(e,t)=>{let[r,o,i,u]=e,{numHeads:a,rotaryEmbeddingDim:c}=t;if(r.dims.length!==3&&r.dims.length!==4)throw new Error(`Input \'x\' is expected to have 3 or 4 dimensions, got ${r.dims.length}`);if(!M.areEqual(o.dims,[])&&!M.areEqual(o.dims,[1])&&o.dims.length!==2)throw new Error(`Input \'position_ids\' is expected to have 0, 1, or 2 dimensions, got ${o.dims.length}`);if(i.dims.length!==2)throw new Error(`Input \'cos_cache\' is expected to have 2 dimensions, got ${i.dims.length}`);if(u.dims.length!==2)throw new Error(`Input \'sin_cache\' is expected to have 2 dimensions, got ${u.dims.length}`);if(!M.areEqual(i.dims,u.dims))throw new Error("Inputs \'cos_cache\' and \'sin_cache\' are expected to have the same shape");if(c>0&&a===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let p=r.dims[0],h=r.dims[r.dims.length-2],d=i.dims[0],y=M.sizeFromDimension(r.dims,1)/h,w=c===0?i.dims[1]*2:y/a;if(c>w)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(o.dims.length===2){if(p!==o.dims[0])throw new Error(`Input \'position_ids\' dimension 0 should be of size batch_size, got ${o.dims[0]}`);if(h!==o.dims[1])throw new Error(`Input \'position_ids\' dimension 1 should be of size sequence_length, got ${o.dims[1]}`)}if(w/2!==i.dims[1]&&c/2!==i.dims[1])throw new Error(`Input \'cos_cache\' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${i.dims[1]}`);if(h>d)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},Mp=(e,t)=>{let{interleaved:r,numHeads:o,rotaryEmbeddingDim:i,scale:u}=t,a=e[0].dims[0],c=M.sizeFromDimension(e[0].dims,1),p=e[0].dims[e[0].dims.length-2],h=c/p,d=e[2].dims[1],y=i===0?d*2:h/o,w=new Array(a,p,h/y,y-d),_=M.computeStrides(w),v=[{type:1,data:u},{type:12,data:w},{type:12,data:_},...e[0].dims.length===3?new Array({type:12,data:[c,h,y,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[c,y,p*y,1]}):[],...Z(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],S=A=>{let I=U("input",e[0].dataType,e[0].dims.length),x=U("position_ids",e[1].dataType,e[1].dims.length),E=U("cos_cache",e[2].dataType,e[2].dims.length),P=U("sin_cache",e[3].dataType,e[3].dims.length),O=j("output",e[0].dataType,e[0].dims.length);return A.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:w.length},{name:"global_strides",type:"u32",length:_.length},{name:"input_output_strides",type:"u32",length:_.length}]),`\n        ${A.declareVariables(I,x,E,P,O)}\n\n        ${A.mainStart(or)}\n          let half_rotary_emb_dim = uniforms.${E.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${A.guardAgainstOutOfBoundsWorkgroupSizes("size")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${x.broadcastedIndicesToOffset("bsnh.xy",j("",x.type.tensor,2))};\n            let position_id =\n                u32(${x.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${r});\n            let j = i + select(half_rotary_emb_dim, 1, ${r});\n            let re = ${I.getByOffset("i")} * ${E.get("position_id","bsnh[3]")} -\n                ${I.getByOffset("j")} * ${P.get("position_id","bsnh[3]")};\n            ${O.setByOffset("i","re")}\n            let im = ${I.getByOffset("i")} * ${P.get("position_id","bsnh[3]")} +\n                ${I.getByOffset("j")} * ${E.get("position_id","bsnh[3]")};\n            ${O.setByOffset("j","im")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${O.setByOffset("k",I.getByOffset("k"))}\n          }\n        }`};return{name:"RotaryEmbedding",shaderCache:{hint:ve({interleaved:r}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:S,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(w)/or)},programUniforms:v})}},bd=(e,t)=>{zp(e.inputs,t),e.compute(Mp(e.inputs,t))}});var Up,Vp,vd,$d=Y(()=>{"use strict";ye();Se();_e();Up=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let i=t.dims[t.dims.length-1],u=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==i)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==u)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==i)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let a=e[3];if(a.dims.length!==1)throw new Error("Beta must be 1D");if(a.dims[a.dims.length-1]!==i)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let a=e[4];if(a.dims.length!==1)throw new Error("Bias must be 1D");if(a.dims[a.dims.length-1]!==i)throw new Error("Bias must have the same hidden size as input")}},Vp=(e,t,r,o)=>{let i=t.simplified,u=e[0].dims,a=M.size(u),c=u,p=a,h=u.slice(-1)[0],d=o?u.slice(0,-1).concat(1):[],y=!i&&e.length>3,w=e.length>4,_=o&&r>1,v=o&&r>2,S=r>3,A=Me(h),I=[{type:12,data:p},{type:12,data:A},{type:12,data:h},{type:1,data:t.epsilon}],x=P=>{let O=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],R=[U("x",e[0].dataType,e[0].dims,A),U("skip",e[1].dataType,e[1].dims,A),U("gamma",e[2].dataType,e[2].dims,A)];y&&R.push(U("beta",e[3].dataType,e[3].dims,A)),w&&R.push(U("bias",e[4].dataType,e[4].dims,A)),R.push(j("output",e[0].dataType,c,A)),_&&R.push(j("mean_output",1,d)),v&&R.push(j("inv_std_output",1,d)),S&&R.push(j("input_skip_bias_sum",e[0].dataType,c,A));let L=De(e[0].dataType);return`\n\n      ${P.registerUniforms(O).declareVariables(...R)}\n\n      ${P.mainStart()}\n        ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size / uniforms.hidden_size")}\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        let offset = global_idx * hidden_size_vectorized;\n        var sum = ${$t("f32",A)};\n        var squareSum = ${$t("f32",A)};\n        for (var i: u32 = 0; i < hidden_size_vectorized; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${w?"bias[i]":L+"(0.0)"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${S?"input_skip_bias_sum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32_value = ${ir(L,A,"value")};\n          sum += f32_value;\n          squareSum += f32_value * f32_value;\n        }\n        let mean = ${_t("sum",A)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${_t("squareSum",A)} / f32(uniforms.hidden_size) ${i?"":"- mean * mean"} + uniforms.epsilon);\n        ${_?"mean_output[global_idx] = mean;":""}\n        ${v?"inv_std_output[global_idx] = inv_std_dev;":""}\n        for (var i: u32 = 0; i < hidden_size_vectorized; i++) {\n          output[offset + i] = (output[offset + i] ${i?"":`- ${L}(mean)`}) * ${L}(inv_std_dev) * gamma[i] ${y?"+ beta[i]":""};\n        }\n      }`},E=[{dims:c,dataType:e[0].dataType}];return r>1&&E.push({dims:d,dataType:1}),r>2&&E.push({dims:d,dataType:1}),r>3&&E.push({dims:u,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${A};${_};${v};${S}`,inputDependencies:e.map((P,O)=>"type")},getShaderSource:x,getRunData:()=>({outputs:E,dispatchGroup:{x:Math.ceil(p/h/64)},programUniforms:I})}},vd=(e,t)=>{Up(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(Vp(e.inputs,t,e.outputCount,!1),{outputs:o})}});var Wp,Gn,Np,_d,Gp,Hp,Sd,xd,Cd=Y(()=>{"use strict";ye();Se();Ze();_e();Wp=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},Gn=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Np=(e,t)=>{if(e.length>1){let r=Gn(e,1),o=Gn(e,2),i=Gn(e,3);return i.length===0&&(i=[...Array(e[0].dims.length).keys()]),ve({starts:r,ends:o,axes:i})}else return t},_d=(e,t,r,o,i)=>{let u=e;return e<0&&(u+=r[o[t]]),i[t]<0?Math.max(0,Math.min(u,r[o[t]]-1)):Math.max(0,Math.min(u,r[o[t]]))},Gp=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${fe("uniforms.input_shape","i",r.length)};\n            let steps_i = ${fe("uniforms.steps","i",r.length)};\n            let signs_i = ${fe("uniforms.signs","i",r.length)};\n            let starts_i = ${fe("uniforms.starts","i",r.length)};\n            var output_index = ${t.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,Hp=(e,t)=>{let r=e[0].dims,o=M.size(r),i=t.axes.length>0?M.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],u=Gn(e,4);u.forEach(I=>I!==0||(()=>{throw new Error("step cannot be 0")})),u.length===0&&(u=Array(i.length).fill(1));let a=t.starts.map((I,x)=>_d(I,x,r,i,u)),c=t.ends.map((I,x)=>_d(I,x,r,i,u));if(i.length!==a.length||i.length!==c.length)throw new Error("start, ends and axes should have the same number of elements");if(i.length!==r.length)for(let I=0;I<r.length;++I)i.includes(I)||(a.splice(I,0,0),c.splice(I,0,r[I]),u.splice(I,0,1));let p=u.map(I=>Math.sign(I));u.forEach((I,x,E)=>{if(I<0){let P=(c[x]-a[x])/I,O=a[x],R=O+P*u[x];a[x]=R,c[x]=O,E[x]=-I}});let h=r.slice(0);i.forEach((I,x)=>{h[I]=Math.ceil((c[I]-a[I])/u[I])});let d={dims:h,dataType:e[0].dataType},y=j("output",e[0].dataType,h.length),w=U("input",e[0].dataType,e[0].dims.length),_=M.size(h),v=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:a.length},{name:"signs",type:"i32",length:p.length},{name:"steps",type:"u32",length:u.length}],S=[{type:12,data:_},{type:12,data:a},{type:6,data:p},{type:12,data:u},...Z(e[0].dims,h)],A=I=>`\n      ${I.registerUniforms(v).declareVariables(w,y)}\n        ${Gp(w,y,r)}\n        ${I.mainStart()}\n          ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${y.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${y.setByOffset("global_idx",w.getByIndices("input_indices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${p.length}_${a.length}_${u.length}`,inputDependencies:["rank"]},getShaderSource:A,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:S})}},Sd=(e,t)=>{Wp(e.inputs,t);let r=Np(e.inputs,t);e.compute(Hp(e.inputs,r),{inputs:[0]})},xd=e=>{let t=e.starts,r=e.ends,o=e.axes;return ve({starts:t,ends:r,axes:o})}});var Lp,Fp,Ad,Id,Td=Y(()=>{"use strict";ye();Se();Ze();_e();Lp=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Fp=(e,t)=>{let r=e.dims,o=M.size(r),i=64,u=t.axis;if(u<0&&(u=r.length+u),u<r.length-1)throw new Error("softmax only supports last axis for now.");let a=r[u],c=o/a,p=Me(a),h=a/p,d=(A,I)=>I===4?`max(max(${A}.x, ${A}.y), max(${A}.z, ${A}.w))`:I===2?`max(${A}.x, ${A}.y)`:I===3?`max(max(${A}.x, ${A}.y), ${A}.z)`:A,y=U("x",e.dataType,e.dims,p),w=j("result",e.dataType,e.dims,p),_=y.type.value,v=De(e.dataType)==="f32"?`var threadMax = ${_}(-3.402823e+38f);`:`var threadMax = ${_}(-65504.0h);`,S=A=>`\n      var<workgroup> rowMaxShared : ${_};\n      var<workgroup> rowSumShared : ${_};\n      var<workgroup> threadShared : array<${_}, ${i}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${_} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${_}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${A.registerUniform("packedCols","i32").declareVariables(y,w)}\n      ${A.mainStart()}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${i};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${v}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${_}(${d("threadShared[0]",p)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${_}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${_}(${_t("threadShared[0]",p)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;return{name:"Softmax",shaderCache:{hint:`${p}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:c},programUniforms:[{type:6,data:h}]}),getShaderSource:S}},Ad=(e,t)=>{Lp(e.inputs),e.compute(Fp(e.inputs[0],t))},Id=e=>ve({axis:e.axis})});var qp,jp,Kp,Yp,Zp,Ed,Pd,kd=Y(()=>{"use strict";ye();Se();Ze();_e();qp=e=>{if(!e||e.length<1)throw new Error("too few inputs")},jp=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(i=>r.push(Number(i))),o=r.length),ve({numOutputs:o,axis:t.axis,splitSizes:r})},Kp=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${fe("uniforms.size_in_split_axis","i",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Yp=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let i=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(i):o===0?r.push(`if (output_number == ${o}u) { ${i} }`):o===t-1?r.push(`else { ${i} }`):r.push(`else if (output_number == ${o}) { ${i} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},Zp=(e,t)=>{let r=e[0].dims,o=M.size(r),i=e[0].dataType,u=M.normalizeAxis(t.axis,r.length),a=new Array(t.numOutputs),c=U("input",i,r.length),p=new Array(t.numOutputs),h=[],d=[],y=0,w=[{type:12,data:o}];for(let v=0;v<t.numOutputs;v++){y+=t.splitSizes[v],p[v]=y;let S=r.slice();S[t.axis]=t.splitSizes[v],d.push(S),a[v]=j(`output${v}`,i,S.length),h.push({dims:d[v],dataType:e[0].dataType})}w.push({type:12,data:p},...Z(r,...d));let _=v=>`\n  ${v.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",p.length).declareVariables(c,...a)}\n  ${Kp(p.length)}\n  ${Yp(a)}\n\n  ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${c.offsetToIndices("global_idx")};\n    var index = ${c.indicesGet("indices",u)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${fe("uniforms.size_in_split_axis","output_number - 1u",p.length)};\n      ${c.indicesSet("indices",u,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:_,getRunData:()=>({outputs:h,dispatchGroup:{x:Math.ceil(o/64)},programUniforms:w})}},Ed=(e,t)=>{qp(e.inputs);let r=e.inputs.length===1?t:jp(e.inputs,t);e.compute(Zp(e.inputs,r),{inputs:[0]})},Pd=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ve({axis:t,numOutputs:o,splitSizes:r})}});var Od,Xp,Qp,Jp,Rd,Bd=Y(()=>{"use strict";ye();Se();_e();Od=e=>Array.from(e.getBigInt64Array(),Number),Xp=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Od(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Qp=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},Jp=e=>{let t=e[0].dims,r=Od(e[1]),o=Qp(t,r),i=M.size(o),u=e[0].dataType,a=U("input",u,t.length),c=j("output",u,o.length),p=h=>`\n      const inputShape = ${a.indices(...t)};\n      ${h.registerUniform("output_size","u32").declareVariables(a,c)}\n      ${h.mainStart()}\n      ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${c.offsetToIndices("global_idx")};\n      var input_indices: ${a.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let input_dim_i = ${a.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${c.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${a.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${c.setByOffset("global_idx",a.getByIndices("input_indices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...Z(e[0].dims,o)]}),getShaderSource:p}},Rd=e=>{Xp(e.inputs),e.compute(Jp(e.inputs),{inputs:[0]})}});var em,tm,Dd,zd=Y(()=>{"use strict";ye();Se();_e();em=(e,t,r,o,i)=>{let u=j("output_data",i,r.length,4),a=U("a_data",t[1].dataType,t[1].dims.length,4),c=U("b_data",t[2].dataType,t[2].dims.length,4),p=U("c_data",t[0].dataType,t[0].dims.length,4),h,d=(y,w,_)=>`select(${w}, ${y}, ${_})`;if(!o)h=u.setByOffset("global_idx",d(a.getByOffset("global_idx"),c.getByOffset("global_idx"),p.getByOffset("global_idx")));else{let y=(w,_,v="")=>{let S=`a_data[index_a${_}][component_a${_}]`,A=`b_data[index_b${_}][component_b${_}]`,I=`bool(c_data[index_c${_}] & (0xffu << (component_c${_} * 8)))`;return`\n            let output_indices${_} = ${u.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offset_a${_} = ${a.broadcastedIndicesToOffset(`output_indices${_}`,u)};\n            let offset_b${_} = ${c.broadcastedIndicesToOffset(`output_indices${_}`,u)};\n            let offset_c${_} = ${p.broadcastedIndicesToOffset(`output_indices${_}`,u)};\n            let index_a${_} = offset_a${_} / 4u;\n            let index_b${_} = offset_b${_} / 4u;\n            let index_c${_} = offset_c${_} / 4u;\n            let component_a${_} = offset_a${_} % 4u;\n            let component_b${_} = offset_b${_} % 4u;\n            let component_c${_} = offset_c${_} % 4u;\n            ${w}[${_}] = ${v}(${d(S,A,I)});\n          `};i===9?h=`\n            var data = vec4<u32>(0);\n            ${y("data",0,"u32")}\n            ${y("data",1,"u32")}\n            ${y("data",2,"u32")}\n            ${y("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:h=`\n            ${y("output_data[global_idx]",0)}\n            ${y("output_data[global_idx]",1)}\n            ${y("output_data[global_idx]",2)}\n            ${y("output_data[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(p,a,c,u)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${h}\n      }`},tm=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,i=e[1].dataType,u=!(M.areEqual(t,r)&&M.areEqual(r,o)),a=t,c=M.size(t);if(u){let h=It.calcShape(It.calcShape(t,r,!1),o,!1);if(!h)throw new Error("Can\'t perform where op on the given tensors");a=h,c=M.size(a)}let p=Math.ceil(c/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:h=>em(h,e,a,u,i),getRunData:()=>({outputs:[{dims:a,dataType:i}],dispatchGroup:{x:Math.ceil(c/64/4)},programUniforms:[{type:12,data:p},...Z(o,t,r,a)]})}},Dd=e=>{e.compute(tm(e.inputs))}});var Md,Ud=Y(()=>{"use strict";Ka();Ro();Ja();ts();Vs();Zs();Oo();Uo();lu();mu();gu();$u();xu();Au();Eu();Ou();Du();Mu();Vu();Wo();Gu();qu();Ku();cd();md();In();yd();wd();$d();Cd();Td();kd();Bd();Sr();Rn();zd();Md=new Map([["Abs",[rs]],["Acos",[ns]],["Acosh",[os]],["Add",[Ws]],["ArgMax",[ja,ko]],["ArgMin",[qa,ko]],["Asin",[is]],["Asinh",[as]],["Atan",[ss]],["Atanh",[us]],["Attention",[Xa]],["AveragePool",[rd,td]],["BatchNormalization",[Qa]],["BiasAdd",[es]],["BiasSplitGelu",[Us]],["Cast",[ls,ds]],["Ceil",[ps]],["Clip",[cs]],["Concat",[Ya,Za]],["Conv",[Ho,Go]],["ConvTranspose",[du,uu]],["Cos",[ms]],["Cosh",[fs]],["CumSum",[cu,pu]],["DepthToSpace",[fu,hu]],["Div",[Ns]],["Einsum",[wu,vu]],["Elu",[hs,kn]],["Equal",[Gs]],["Erf",[gs]],["Exp",[ys]],["Expand",[Su]],["FastGelu",[Cu]],["Floor",[bs]],["FusedConv",[Ho,Go]],["Gather",[Tu,Iu]],["GatherElements",[ku,Pu]],["Gelu",[ws]],["Gemm",[Bu,Ru]],["GlobalAveragePool",[id,od]],["GlobalMaxPool",[ld,dd]],["Greater",[qs]],["GreaterOrEqual",[Ks]],["HardSigmoid",[Is,As]],["InstanceNormalization",[zu]],["LayerNormalization",[Uu]],["LeakyRelu",[vs,kn]],["Less",[js]],["LessOrEqual",[Ys]],["Log",[zs]],["MatMul",[ru]],["MatMulNBits",[Wu,Nu]],["MaxPool",[sd,ud]],["Mul",[Hs]],["MultiHeadAttention",[Fu,Lu]],["Neg",[_s]],["Not",[$s]],["Pad",[ju]],["Pow",[Ls]],["Range",[pd]],["Reciprocal",[Ss]],["ReduceMin",[Wa]],["ReduceMean",[Da]],["ReduceMax",[Va]],["ReduceSum",[Ga]],["ReduceProd",[Na]],["ReduceL1",[za]],["ReduceL2",[Ma]],["ReduceLogSum",[La]],["ReduceLogSumExp",[Ua]],["ReduceSumSquare",[Ha]],["Relu",[xs]],["Resize",[hd,gd]],["RotaryEmbedding",[bd]],["Sigmoid",[Cs]],["Sin",[Ts]],["Sinh",[Es]],["Slice",[Sd,xd]],["SkipLayerNormalization",[vd]],["Split",[Ed,Pd]],["Sqrt",[Ps]],["Softmax",[Ad,Id]],["Sub",[Fs]],["Tan",[ks]],["Tanh",[Rs]],["ThresholdedRelu",[Ds,kn]],["Tile",[Rd]],["Transpose",[_a,Sa]],["Where",[Dd]]])});var Hn,Vd=Y(()=>{"use strict";$r();Lt();_e();Hn=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,i,u){rr(t.programInfo.name);let a=this.backend.device,c=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let p=[];for(let d of r)p.push({binding:p.length,resource:{buffer:d.buffer}});for(let d of o)p.push({binding:p.length,resource:{buffer:d.buffer}});u&&p.push({binding:p.length,resource:u});let h=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:p,label:t.programInfo.name});if(this.backend.sessionStatus==="capturing"){let d={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:h,dispatchGroup:i};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(d)}c.setPipeline(t.computePipeline),c.setBindGroup(0,h),c.dispatchWorkgroups(...i),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Ht(t.programInfo.name)}dispose(){}build(t,r){rr(t.name);let o=this.backend.device,i=[];o.features.has("shader-f16")&&i.push("enable f16;");let u=va(r,this.backend.device.limits),a=t.getShaderSource(u),c=`${i.join(`\n`)}\n${u.additionalImplementations}\n${a}`,p=o.createShaderModule({code:c,label:t.name});Ve("verbose",()=>`[WebGPU] ${t.name} shader code: ${c}`);let h=o.createComputePipeline({compute:{module:p,entryPoint:"main"},layout:"auto",label:t.name});return Ht(t.name),{programInfo:t,computePipeline:h,uniformVariablesInfo:u.variablesInfo}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,i=typeof t=="number"?1:t.z||1,u=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=u&&o<=u&&i<=u)return[r,o,i];let a=r*o*i,c=Math.ceil(Math.sqrt(a));if(c>u){if(c=Math.ceil(Math.cbrt(a)),c>u)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[c,c,c]}else return[c,c,1]}}});var rm,nm,Yo,Ln,Wd=Y(()=>{"use strict";$r();ye();Lt();fa();wa();Ud();Vd();rm=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let i=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${i}`);break}case"rank":{let u=e[o].dims.length;r.push(`${i};${u}`);break}case"dims":{let u=e[o].dims.join(",");r.push(`${i};${u}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},nm=(e,t,r)=>{let o=e.name;return e.shaderCache?.hint&&(o+="["+e.shaderCache.hint+"]"),o+=":"+r+`:${rm(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,o},Yo=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},Ln=class{constructor(){this.currentSessionId=null;this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.maxDispatchNumber=16;this.pendingDispatchNumber=0;this.pendingKernels=[];this.pendingQueries=new Map;this.sessionStatus="default";this.capturedCommandList=new Map;this.capturedPendingKernels=new Map;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,r){this.env=t;let o=[],i={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("chromium-experimental-timestamp-query-inside-passes")?o.push("chromium-experimental-timestamp-query-inside-passes"):r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(i),this.adapterInfo=new Yo(await r.requestAdapterInfo()),this.gpuDataManager=ba(this),this.programManager=new Hn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,pa(t.logLevel,!!t.debug),this.device.onuncapturederror=u=>{u.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${u.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:r,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),r={};this.queryType==="at-passes"&&(r.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(r)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;rr(),this.endComputePass();let t;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&t.mapAsync(GPUMapMode.READ).then(()=>{let r=new BigUint64Array(t.getMappedRange()),o=this.pendingQueries.get(t);for(let i=0;i<r.length/2;i++){let u=o[i],a=u.kernelId,c=this.kernels.get(a),p=c.kernelType,h=c.kernelName,d=u.programName,y=u.inputTensorViews,w=u.outputTensorViews,_=r[i*2],v=r[i*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=_);let S=Number(_-this.queryTimeBase),A=Number(v-this.queryTimeBase);if(!Number.isSafeInteger(S)||!Number.isSafeInteger(A))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:y.map(I=>({dims:I.dims,dataType:Gt(I.dataType)})),outputsMetadata:w.map(I=>({dims:I.dims,dataType:Gt(I.dataType)})),kernelId:a,kernelType:p,kernelName:h,programName:d,startTime:S,endTime:A});else{let I="";y.forEach((E,P)=>{I+=`input[${P}]: [${E.dims}] | ${Gt(E.dataType)}, `});let x="";w.forEach((E,P)=>{x+=`output[${P}]: [${E.dims}] | ${Gt(E.dataType)}, `}),console.log(`[profiling] kernel "${a}|${p}|${h}|${d}" ${I}${x}execution time: ${A-S} ns`)}wo("GPU",`${d}::${_}::${v}`)}t.unmap(),this.pendingQueries.delete(t)}),Ht()}run(t,r,o,i,u,a){rr(t.name);let c=[];for(let E=0;E<r.length;++E){let P=r[E].data;if(P===0)continue;let O=this.gpuDataManager.get(P);if(!O)throw new Error(`no GPU data for input: ${P}`);c.push(O)}let{outputs:p,dispatchGroup:h,programUniforms:d}=t.getRunData(r),y=o.length===0?p.map((E,P)=>P):o;if(y.length!==p.length)throw new Error(`Output size ${y.length} must be equal to ${p.length}.`);let w=[],_=[];for(let E=0;E<p.length;++E){if(!Number.isInteger(y[E])||y[E]<-3||y[E]>=a)throw new Error(`Invalid output index: ${y[E]}`);if(y[E]===-3)continue;let P=y[E]===-1,O=y[E]===-2,R=P||O?u(p[E].dataType,p[E].dims):i(y[E],p[E].dataType,p[E].dims);if(w.push(R),R.data===0)continue;let L=this.gpuDataManager.get(R.data);if(!L)throw new Error(`no GPU data for output: ${R.data}`);if(P&&this.temporaryData.push(L),O){let N=this.kernelPersistentData.get(this.currentKernelId);N||(N=[],this.kernelPersistentData.set(this.currentKernelId,N)),N.push(L)}_.push(L)}if(c.length!==r.length||_.length!==w.length){if(_.length===0)return Ht(t.name),w;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let v;if(d){let E=0,P=[];d.forEach(N=>{let K=typeof N.data=="number"?[N.data]:N.data;if(K.length===0)return;let Q=N.type===10?2:4,he,W;N.type===10?(W=K.length>4?16:K.length>2?8:K.length*Q,he=K.length>4?16:Q*K.length):(W=K.length<=2?K.length*Q:16,he=16),E=Math.ceil(E/W)*W,P.push(E);let se=N.type===10?8:4;E+=K.length>4?Math.ceil(K.length/se)*he:K.length*Q});let O=16;E=Math.ceil(E/O)*O;let R=new ArrayBuffer(E);d.forEach((N,K)=>{let Q=P[K],he=typeof N.data=="number"?[N.data]:N.data;if(N.type===6)new Int32Array(R,Q,he.length).set(he);else if(N.type===12)new Uint32Array(R,Q,he.length).set(he);else if(N.type===10)new Uint16Array(R,Q,he.length).set(he);else if(N.type===1)new Float32Array(R,Q,he.length).set(he);else throw new Error(`Unsupported uniform type: ${Gt(N.type)}`)});let L=this.gpuDataManager.create(E,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(L.buffer,0,R,0,E),this.gpuDataManager.release(L.id),v={offset:0,size:E,buffer:L.buffer}}let S=this.programManager.normalizeDispatchGroupSize(h),A=S[1]===1&&S[2]===1,I=nm(t,r,A),x=this.programManager.getArtifact(I);if(x||(x=this.programManager.build(t,S),this.programManager.setArtifact(I,x),Ve("info",()=>`[artifact] key: ${I}, programName: ${t.name}`)),d&&x.uniformVariablesInfo){if(d.length!==x.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${x.uniformVariablesInfo.length}, got ${d.length} in program "${x.programInfo.name}".`);for(let E=0;E<d.length;E++){let P=d[E],O=P.type,R=typeof P.data=="number"?1:P.data.length,[L,N]=x.uniformVariablesInfo[E];if(O!==L||R!==N)throw new Error(`Uniform variable ${E} mismatch: expect type ${L} with size ${N}, got type ${O} with size ${R} in program "${x.programInfo.name}".`)}}if(Ve("info",()=>`[ProgramManager] run "${t.name}" (key=${I}) with ${S[0]}x${S[1]}x${S[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let E={kernelId:this.currentKernelId,programName:x.programInfo.name,inputTensorViews:r,outputTensorViews:w};this.pendingKernels.push(E),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(E)}return this.programManager.run(x,c,_,S,v),Ht(t.name),w}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,i){let u=Md.get(t);if(!u)throw new Error(`kernel not implemented: ${t}`);let a={kernelType:t,kernelName:i,kernelEntry:u[0],attributes:[u[1],o]};this.kernels.set(r,a)}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let i=this.kernels.get(t);if(!i)throw new Error(`kernel not created: ${t}`);let u=i.kernelType,a=i.kernelName,c=i.kernelEntry,p=i.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${u}] ${a}" is not allowed to be called recursively`);this.currentKernelId=t,p[0]&&(p[1]=p[0](p[1]),p[0]=void 0),Ve("info",()=>`[WebGPU] Start to run kernel "[${u}] ${a}"...`);let h=this.env.debug;this.temporaryData=[];try{return h&&this.device.pushErrorScope("validation"),c(r,p[1]),0}catch(d){return o.push(Promise.resolve(`[WebGPU] Kernel "[${u}] ${a}" failed. ${d}`)),1}finally{h&&o.push(this.device.popErrorScope().then(d=>d?`GPU validation error for kernel "[${u}] ${a}": ${d.message}`:null));for(let d of this.temporaryData)this.gpuDataManager.release(d.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,i){let u=this.sessionExternalDataMapping.get(t);u||(u=new Map,this.sessionExternalDataMapping.set(t,u));let a=u.get(r),c=this.gpuDataManager.registerExternalBuffer(o,i,a?.[1]);return u.set(r,[c,o]),c}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let i=await xo(this,t,r);return ma(i.buffer,o)}}writeTimestamp(t){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Ve("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Ve("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Ve("info","replay"),this.sessionStatus="replaying";let t=this.capturedCommandList.get(this.currentSessionId),r=this.capturedPendingKernels.get(this.currentSessionId),o=t.length;this.pendingKernels=[];for(let i=0;i<o;i++){let u=this.getComputePassEncoder(),a=t[i];this.writeTimestamp(this.pendingDispatchNumber*2),u.setPipeline(a.computePipeline),u.setBindGroup(0,a.bindGroup),u.dispatchWorkgroups(...a.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(r[i]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}});var Nd={};gn(Nd,{init:()=>om});var qr,Zo,om,Gd=Y(()=>{"use strict";ye();Wd();Lt();Se();qr=class e{constructor(t,r,o,i){this.module=t;this.dataType=r;this.data=o;this.dims=i}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(M.size(t)!==M.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Zo=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;this.adapterInfo=r.adapterInfo;let i=t.HEAPU32,u=o>>>2;this.opKernelContext=i[u++];let a=i[u++];this.outputCount=i[u++],this.customDataOffset=i[u++],this.customDataSize=i[u++];let c=[];for(let p=0;p<a;p++){let h=i[u++],d=i[u++],y=i[u++],w=[];for(let _=0;_<y;_++)w.push(i[u++]);c.push(new qr(t,h,d,w))}this.inputs=c}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}getMaxComputeWorkgroupSizes(){return[this.backend.device.limits.maxComputeWorkgroupSizeX,this.backend.device.limits.maxComputeWorkgroupSizeY,this.backend.device.limits.maxComputeWorkgroupSizeZ]}getMaxComputeWorkgroupStoragesize(){return this.backend.device.limits.maxComputeWorkgroupStorageSize}compute(t,r){let o=r?.inputs?.map(c=>typeof c=="number"?this.inputs[c]:c)??this.inputs,i=r?.outputs??[],u=(c,p,h)=>new qr(this.module,p,this.output(c,h),h),a=(c,p)=>{let h=tr(c);if(!h)throw new Error(`Unsupported data type: ${c}`);let d=h*M.size(p),y=d>0?this.backend.gpuDataManager.create(d).id:0;return new qr(this.module,c,y,p)};return this.backend.run(t,o,i,u,a,this.outputCount)}output(t,r){let o=this.module.stackSave();try{let i=this.module.stackAlloc((1+r.length)*4),u=i>>2;this.module.HEAPU32[u++]=r.length;for(let a=0;a<r.length;a++)this.module.HEAPU32[u++]=r[a];return this.module._JsepOutput(this.opKernelContext,t,i)}catch(i){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${i}`)}finally{this.module.stackRestore(o)}}},om=async(e,t,r,o)=>{let i=t.jsepInit;if(!i)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(e==="webgpu"){let u=new Ln;await u.initialize(r,o),i("webgpu",[u,a=>u.alloc(a),a=>u.free(a),(a,c,p,h=!1)=>{if(h)Ve("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${a}, dst=${c}, size=${p}`),u.memcpy(a,c);else{Ve("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${a}, gpuDataId=${c}, size=${p}`);let d=t.HEAPU8.subarray(a>>>0,(a>>>0)+p);u.upload(c,d)}},async(a,c,p)=>{Ve("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${c}, size=${p}`),await u.download(a,()=>t.HEAPU8.subarray(c>>>0,(c>>>0)+p))},(a,c,p)=>u.createKernel(a,c,p,t.UTF8ToString(t._JsepGetNodeName(c))),a=>u.releaseKernel(a),(a,c,p,h)=>{Ve("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${p}, kernel=${a}, contextDataOffset=${c}`);let d=new Zo(t,u,c);return u.computeKernel(a,d,h)},()=>u.captureBegin(),()=>u.captureEnd(),()=>u.replay()])}else i("webnn")}});var Vi;Vi=Ei();var pl=zi(),fo,ho=!1,yn=!1,Ui=!1,ml=e=>{if(e===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+e+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+e+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},fl=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},hl=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Wi=async e=>{if(ho)return Promise.resolve();if(yn)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Ui)throw new Error("previous call to \'initializeWebAssembly()\' failed.");yn=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,i=ml(r),u=o&&fl(),a=e.wasmPaths,c=typeof a=="string"?a:void 0,p=hl(u,i),h=typeof a=="object"?a[p]:void 0,d=!1,y=[];if(t>0&&y.push(new Promise(w=>{setTimeout(()=>{d=!0,w()},t)})),y.push(new Promise((w,_)=>{let v=i?pl:Vi,S={locateFile:(A,I)=>{if(i&&A.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Mi()],{type:"text/javascript"}));if(A.endsWith(".wasm")){if(h)return h;let x=c??I;return p==="ort-wasm-simd.wasm"?x+"ort-wasm-simd.jsep.wasm":p==="ort-wasm-simd-threaded.wasm"?x+"ort-wasm-simd-threaded.jsep.wasm":x+p}return I+A}};if(i)if(S.numThreads=r,typeof Blob>"u")S.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let A=`var ortWasmThreaded=${v.toString()};`;S.mainScriptUrlOrBlob=new Blob([A],{type:"text/javascript"})}v(S).then(A=>{yn=!1,ho=!0,fo=A,w()},A=>{yn=!1,Ui=!0,_(A)})})),await Promise.race(y),d)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Le=()=>{if(ho&&fo)return fo;throw new Error("WebAssembly is not initialized yet.")};var Fe=(e,t)=>{let r=Le(),o=r.lengthBytesUTF8(e)+1,i=r._malloc(o);return r.stringToUTF8(e,i,o),t.push(i),i},Nr=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([i,u])=>{let a=t?t+i:i;if(typeof u=="object")Nr(u,a+".",r,o);else if(typeof u=="string"||typeof u=="number")o(a,u.toString());else if(typeof u=="boolean")o(a,u?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof u}`)})},Ue=e=>{let t=Le(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let i=t.HEAP32[o/4],u=t.HEAPU32[o/4+1],a=u?t.UTF8ToString(u):"";throw new Error(`${e} ERROR_CODE: ${i}, ERROR_MESSAGE: ${a}`)}finally{t.stackRestore(r)}};var Ni=e=>{let t=Le(),r=0,o=[],i=e||{};try{if(e?.logSeverityLevel===void 0)i.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)i.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(i.terminate=!1);let u=0;return e?.tag!==void 0&&(u=Fe(e.tag,o)),r=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,u),r===0&&Ue("Can\'t create run options."),e?.extra!==void 0&&Nr(e.extra,"",new WeakSet,(a,c)=>{let p=Fe(a,o),h=Fe(c,o);t._OrtAddRunConfigEntry(r,p,h)!==0&&Ue(`Can\'t set a run config entry: ${a} - ${c}.`)}),[r,o]}catch(u){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(a=>t._free(a)),u}};var gl=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},yl=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},bl=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},wl=(e,t,r)=>{for(let o of t){let i=typeof o=="string"?o:o.name;switch(i){case"webnn":if(i="WEBNN",typeof o!="string"){let a=o;if(a?.deviceType){let c=Fe("deviceType",r),p=Fe(a.deviceType,r);Le()._OrtAddSessionConfigEntry(e,c,p)!==0&&Ue(`Can\'t set a session config entry: \'deviceType\' - ${a.deviceType}.`)}if(a?.numThreads){let c=a.numThreads;(typeof c!="number"||!Number.isInteger(c)||c<0)&&(c=0);let p=Fe("numThreads",r),h=Fe(c.toString(),r);Le()._OrtAddSessionConfigEntry(e,p,h)!==0&&Ue(`Can\'t set a session config entry: \'numThreads\' - ${a.numThreads}.`)}if(a?.powerPreference){let c=Fe("powerPreference",r),p=Fe(a.powerPreference,r);Le()._OrtAddSessionConfigEntry(e,c,p)!==0&&Ue(`Can\'t set a session config entry: \'powerPreference\' - ${a.powerPreference}.`)}}break;case"webgpu":if(i="JS",typeof o!="string"){let a=o;if(a?.preferredLayout){if(a.preferredLayout!=="NCHW"&&a.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${a.preferredLayout}`);let c=Fe("preferredLayout",r),p=Fe(a.preferredLayout,r);Le()._OrtAddSessionConfigEntry(e,c,p)!==0&&Ue(`Can\'t set a session config entry: \'preferredLayout\' - ${a.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${i}`)}let u=Fe(i,r);Le()._OrtAppendExecutionProvider(e,u)!==0&&Ue(`Can\'t append execution provider: ${i}.`)}},Gi=e=>{let t=Le(),r=0,o=[],i=e||{};bl(i);try{let u=gl(i.graphOptimizationLevel??"all"),a=yl(i.executionMode??"sequential"),c=typeof i.logId=="string"?Fe(i.logId,o):0,p=i.logSeverityLevel??2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);let h=i.logVerbosityLevel??0;if(!Number.isInteger(h)||h<0||h>4)throw new Error(`log verbosity level is not valid: ${h}`);let d=typeof i.optimizedModelFilePath=="string"?Fe(i.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(u,!!i.enableCpuMemArena,!!i.enableMemPattern,a,!!i.enableProfiling,0,c,p,h,d),r===0&&Ue("Can\'t create session options."),i.executionProviders&&wl(r,i.executionProviders,o),i.enableGraphCapture!==void 0){if(typeof i.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${i.enableGraphCapture}`);let y=Fe("enableGraphCapture",o),w=Fe(i.enableGraphCapture.toString(),o);t._OrtAddSessionConfigEntry(r,y,w)!==0&&Ue(`Can\'t set a session config entry: \'enableGraphCapture\' - ${i.enableGraphCapture}.`)}if(i.freeDimensionOverrides)for(let[y,w]of Object.entries(i.freeDimensionOverrides)){if(typeof y!="string")throw new Error(`free dimension override name must be a string: ${y}`);if(typeof w!="number"||!Number.isInteger(w)||w<0)throw new Error(`free dimension override value must be a non-negative integer: ${w}`);let _=Fe(y,o);t._OrtAddFreeDimensionOverride(r,_,w)!==0&&Ue(`Can\'t set a free dimension override: ${y} - ${w}.`)}return i.extra!==void 0&&Nr(i.extra,"",new WeakSet,(y,w)=>{let _=Fe(y,o),v=Fe(w,o);t._OrtAddSessionConfigEntry(r,_,v)!==0&&Ue(`Can\'t set a session config entry: ${y} - ${w}.`)}),[r,o]}catch(u){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(a=>t._free(a)),u}};ye();var Li=async e=>{if(typeof e=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(e))}catch(t){if(t.code==="ERR_FS_FILE_TOO_LARGE"){let r=(void 0)(e),o=[];for await(let i of r)o.push(i);return new Uint8Array(Buffer.concat(o))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let r=t.headers.get("Content-Length"),o=r?parseInt(r,10):0;if(o<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let i=t.body.getReader(),u;try{u=new ArrayBuffer(o)}catch(c){if(c instanceof RangeError){let p=Math.ceil(o/65536);u=new WebAssembly.Memory({initial:p,maximum:p}).buffer}else throw c}let a=0;for(;;){let{done:c,value:p}=await i.read();if(c)break;let h=p.byteLength;new Uint8Array(u,a,h).set(p),a+=h}return new Uint8Array(u,0,o)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)};var im=(e,t)=>{Le()._OrtInit(e,t)!==0&&Ue("Can\'t initialize onnxruntime.")},Ld=async e=>{im(e.wasm.numThreads,Gr(e.logLevel))},Fd=async(e,t)=>{{let r=(Gd(),wr(Nd)).init;if(t==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let o=e.webgpu.adapter;if(o){if(typeof o.limits!="object"||typeof o.features!="object"||typeof o.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let i=e.webgpu.powerPreference;if(i!==void 0&&i!=="low-power"&&i!=="high-performance")throw new Error(`Invalid powerPreference setting: "${i}"`);let u=e.webgpu.forceFallbackAdapter;if(u!==void 0&&typeof u!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${u}"`);if(o=await navigator.gpu.requestAdapter({powerPreference:i,forceFallbackAdapter:u}),!o)throw new Error(\'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.\')}if(!e.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");await r("webgpu",Le(),e,o)}if(t==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await r("webnn",Le(),e)}}},ar=new Map,am=e=>{let t=Le(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Ue("Can\'t get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},Xo=e=>{let t=Le(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},qd=async(e,t)=>{let r,o,i=Le();Array.isArray(e)?[r,o]=e:e.buffer===i.HEAPU8.buffer?[r,o]=[e.byteOffset,e.byteLength]:[r,o]=Xo(e);let u=0,a=0,c=0,p=[],h=[],d=[];try{if([a,p]=Gi(t),t?.externalData&&i.mountExternalData){let x=[];for(let E of t.externalData){let P=typeof E=="string"?E:E.path;x.push(Li(typeof E=="string"?E:E.data).then(O=>{i.mountExternalData(P,O)}))}await Promise.all(x)}u=await i._OrtCreateSession(r,o,a),u===0&&Ue("Can\'t create a session.");let[y,w]=am(u),_=!!t?.enableGraphCapture,v=[],S=[],A=[];for(let x=0;x<y;x++){let E=i._OrtGetInputName(u,x);E===0&&Ue("Can\'t get an input name."),h.push(E),v.push(i.UTF8ToString(E))}for(let x=0;x<w;x++){let E=i._OrtGetOutputName(u,x);E===0&&Ue("Can\'t get an output name."),d.push(E);let P=i.UTF8ToString(E);S.push(P);{if(_&&t?.preferredOutputLocation===void 0){A.push("gpu-buffer");continue}let O=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[P]??"cpu";if(O!=="cpu"&&O!=="cpu-pinned"&&O!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${O}.`);if(_&&O!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${O}. Only \'gpu-buffer\' location is supported when enableGraphCapture is true.`);A.push(O)}}let I=null;return A.some(x=>x==="gpu-buffer")&&(c=i._OrtCreateBinding(u),c===0&&Ue("Can\'t create IO binding."),I={handle:c,outputPreferredLocations:A,outputPreferredLocationsEncoded:A.map(x=>yo(x))}),ar.set(u,[u,h,d,I,_,!1]),[u,v,S]}catch(y){throw h.forEach(w=>i._OrtFree(w)),d.forEach(w=>i._OrtFree(w)),c!==0&&i._OrtReleaseBinding(c),u!==0&&i._OrtReleaseSession(u),y}finally{i._free(r),a!==0&&i._OrtReleaseSessionOptions(a),p.forEach(y=>i._free(y)),i.unmountExternalData?.()}},jd=e=>{let t=Le(),r=ar.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,i,u,a,c]=r;a&&(c&&t._OrtClearBoundOutputs(a.handle),t._OrtReleaseBinding(a.handle)),t.jsepOnReleaseSession?.(e),i.forEach(p=>t._OrtFree(p)),u.forEach(p=>t._OrtFree(p)),t._OrtReleaseSession(o),ar.delete(e)},Hd=(e,t,r,o,i,u=!1)=>{if(!e){t.push(0);return}let a=Le(),c=e[0],p=e[1],h=e[3],d,y;if(c==="string"&&h==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(u&&h!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${i} when enableGraphCapture is true.`);if(h==="gpu-buffer"){let v=e[2].gpuBuffer,S=tr(go(c));y=p.reduce((I,x)=>I*x,1)*S;let A=a.jsepRegisterBuffer;if(!A)throw new Error(\'Tensor location "gpu-buffer" is not supported without using WebGPU.\');d=A(o,i,v,y)}else{let v=e[2];if(Array.isArray(v)){y=4*v.length,d=a._malloc(y),r.push(d);let S=d/4;for(let A=0;A<v.length;A++){if(typeof v[A]!="string")throw new TypeError(`tensor data at index ${A} is not a string`);a.HEAPU32[S++]=Fe(v[A],r)}}else y=v.byteLength,d=a._malloc(y),r.push(d),a.HEAPU8.set(new Uint8Array(v.buffer,v.byteOffset,y),d)}let w=a.stackSave(),_=a.stackAlloc(4*p.length);try{let v=_/4;p.forEach(A=>a.HEAP32[v++]=A);let S=a._OrtCreateTensor(go(c),d,y,_,p.length,yo(h));S===0&&Ue(`Can\'t create tensor for input/output. session=${o}, index=${i}.`),t.push(S)}finally{a.stackRestore(w)}},Kd=async(e,t,r,o,i,u)=>{let a=Le(),c=ar.get(e);if(!c)throw new Error(`cannot run inference. invalid session id: ${e}`);let p=c[0],h=c[1],d=c[2],y=c[3],w=c[4],_=c[5],v=t.length,S=o.length,A=0,I=[],x=[],E=[],P=[],O=a.stackSave(),R=a.stackAlloc(v*4),L=a.stackAlloc(v*4),N=a.stackAlloc(S*4),K=a.stackAlloc(S*4);try{[A,I]=Ni(u);for(let ee=0;ee<v;ee++)Hd(r[ee],x,P,e,t[ee],w);for(let ee=0;ee<S;ee++)Hd(i[ee],E,P,e,v+o[ee],w);let Q=R/4,he=L/4,W=N/4,se=K/4;for(let ee=0;ee<v;ee++)a.HEAPU32[Q++]=x[ee],a.HEAPU32[he++]=h[t[ee]];for(let ee=0;ee<S;ee++)a.HEAPU32[W++]=E[ee],a.HEAPU32[se++]=d[o[ee]];if(y&&!_){let{handle:ee,outputPreferredLocations:ae,outputPreferredLocationsEncoded:Ae}=y;if(h.length!==v)throw new Error(`input count from feeds (${v}) is expected to be always equal to model\'s input count (${h.length}).`);for(let me=0;me<v;me++){let ie=t[me];await a._OrtBindInput(ee,h[ie],x[me])!==0&&Ue(`Can\'t bind input[${me}] for session=${e}.`)}for(let me=0;me<S;me++){let ie=o[me];i[me]?.[3]?a._OrtBindOutput(ee,d[ie],E[me],0)!==0&&Ue(`Can\'t bind pre-allocated output[${me}] for session=${e}.`):a._OrtBindOutput(ee,d[ie],0,Ae[ie])!==0&&Ue(`Can\'t bind output[${me}] to ${ae[me]} for session=${e}.`)}ar.set(e,[p,h,d,y,w,!0])}a.jsepOnRunStart?.(p);let Ce;y?Ce=await a._OrtRunWithBinding(p,y.handle,S,N,A):Ce=await a._OrtRun(p,L,R,v,K,S,N,A),Ce!==0&&Ue("failed to call OrtRun().");let We=[];for(let ee=0;ee<S;ee++){let ae=a.HEAPU32[N/4+ee];if(ae===E[ee]){We.push(i[ee]);continue}let Ae=a.stackSave(),me=a.stackAlloc(4*4),ie=!1,ue,le=0;try{a._OrtGetTensorData(ae,me,me+4,me+8,me+12)!==0&&Ue(`Can\'t access output tensor data on index ${ee}.`);let G=me/4,ne=a.HEAPU32[G++];le=a.HEAPU32[G++];let xe=a.HEAPU32[G++],Ke=a.HEAPU32[G++],Be=[];for(let Ne=0;Ne<Ke;Ne++)Be.push(a.HEAPU32[xe/4+Ne]);a._OrtFree(xe);let Ge=Be.reduce((Ne,Ye)=>Ne*Ye,1);ue=Gt(ne);let Ut=y?.outputPreferredLocations[o[ee]];if(ue==="string"){if(Ut==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ne=[],Ye=le/4;for(let mt=0;mt<Ge;mt++){let Rt=a.HEAPU32[Ye++],qt=mt===Ge-1?void 0:a.HEAPU32[Ye]-Rt;Ne.push(a.UTF8ToString(Rt,qt))}We.push([ue,Be,Ne,"cpu"])}else if(Ut==="gpu-buffer"&&Ge>0){let Ne=a.jsepGetBuffer;if(!Ne)throw new Error(\'preferredLocation "gpu-buffer" is not supported without using WebGPU.\');let Ye=Ne(le),mt=tr(ne);if(mt===void 0||!Hi(ue))throw new Error(`Unsupported data type: ${ue}`);ie=!0,We.push([ue,Be,{gpuBuffer:Ye,download:a.jsepCreateDownloader(Ye,Ge*mt,ue),dispose:()=>{a._OrtReleaseTensor(ae)}},"gpu-buffer"])}else{let Ne=bn(ue),Ye=new Ne(Ge);new Uint8Array(Ye.buffer,Ye.byteOffset,Ye.byteLength).set(a.HEAPU8.subarray(le,le+Ye.byteLength)),We.push([ue,Be,Ye,"cpu"])}}finally{a.stackRestore(Ae),ue==="string"&&le&&a._free(le),ie||a._OrtReleaseTensor(ae)}}return y&&!w&&(a._OrtClearBoundOutputs(y.handle),ar.set(e,[p,h,d,y,w,!1])),We}finally{a.stackRestore(O),x.forEach(Q=>a._OrtReleaseTensor(Q)),E.forEach(Q=>a._OrtReleaseTensor(Q)),P.forEach(Q=>a._free(Q)),A!==0&&a._OrtReleaseRunOptions(A),I.forEach(Q=>a._free(Q))}},Yd=e=>{let t=Le(),r=ar.get(e);if(!r)throw new Error("invalid session id");let o=r[0],i=t._OrtEndProfiling(o);i===0&&Ue("Can\'t get an profile file name."),t._OrtFree(i)},Zd=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t};self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case"init-wasm":Wi(r.wasm).then(()=>{Ld(r).then(()=>{postMessage({type:t})},o=>{postMessage({type:t,err:o})})},o=>{postMessage({type:t,err:o})});break;case"init-ep":{let{epName:o,env:i}=r;Fd(i,o).then(()=>{postMessage({type:t})},u=>{postMessage({type:t,err:u})});break}case"copy-from":{let{buffer:o}=r,i=Xo(o);postMessage({type:t,out:i});break}case"create":{let{model:o,options:i}=r;qd(o,i).then(u=>{postMessage({type:t,out:u})},u=>{postMessage({type:t,err:u})});break}case"release":jd(r),postMessage({type:t});break;case"run":{let{sessionId:o,inputIndices:i,inputs:u,outputIndices:a,options:c}=r;Kd(o,i,u,a,new Array(a.length).fill(null),c).then(p=>{p.some(h=>h[3]!=="cpu")?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:p},Zd([...u,...p]))},p=>{postMessage({type:t,err:p})});break}case"end-profiling":Yd(r),postMessage({type:t});break;default:}}catch(o){postMessage({type:t,err:o})}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'}),gr,St,sn,pi,mi,Co,Io,zr,Br,pf,ci,Wd,Nd,Vd,Hd,Gd,Ld,Fd,To=j(()=>{var st;_t(),Md(),Or(),gr=()=>!!ke.wasm.proxy&&typeof document<"u",sn=!1,pi=!1,mi=!1,Io=new Map,zr=(at,pt)=>{let vt=Io.get(at);vt?vt.push(pt):Io.set(at,[pt])},Br=()=>{if(sn||!pi||mi||!St)throw new Error("worker not ready")},pf=at=>{switch(at.data.type){case"init-wasm":sn=!1,at.data.err?(mi=!0,Co[1](at.data.err)):(pi=!0,Co[0]());break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let pt=Io.get(at.data.type);at.data.err?pt.shift()[1](at.data.err):pt.shift()[0](at.data.out);break}}},ci=typeof document<"u"?(st=document==null?void 0:document.currentScript)==null?void 0:st.src:void 0,Wd=async()=>{if(!pi){if(sn)throw new Error("multiple calls to 'initWasm()' detected.");if(mi)throw new Error("previous call to 'initWasm()' failed.");if(sn=!0,gr())return ke.wasm.wasmPaths===void 0&&ci&&ci.indexOf("blob:")!==0&&(ke.wasm.wasmPaths=ci.substr(0,+ci.lastIndexOf("/")+1)),new Promise((at,pt)=>{St==null||St.terminate();let vt=URL.createObjectURL(new Blob([Ud()],{type:"text/javascript"}));St=new Worker(vt,{name:"ort-wasm-proxy-worker"}),St.onerror=$t=>pt($t),St.onmessage=pf,URL.revokeObjectURL(vt),Co=[at,pt];let wt={type:"init-wasm",in:ke};St.postMessage(wt)});try{await Fa(ke.wasm),await kd(ke),pi=!0}catch(at){throw mi=!0,at}finally{sn=!1}}},Nd=async at=>{if(gr())return Br(),new Promise((pt,vt)=>{zr("init-ep",[pt,vt]);let wt={type:"init-ep",in:{epName:at,env:ke}};St.postMessage(wt)});await Od(ke,at)},Vd=async at=>gr()?(Br(),new Promise((pt,vt)=>{zr("copy-from",[pt,vt]);let wt={type:"copy-from",in:{buffer:at}};St.postMessage(wt,[at.buffer])})):So(at),Hd=async(at,pt)=>{if(gr()){if(pt!=null&&pt.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Br(),new Promise((vt,wt)=>{zr("create",[vt,wt]);let $t={type:"create",in:{model:at,options:{...pt}}},Tt=[];at instanceof Uint8Array&&Tt.push(at.buffer),St.postMessage($t,Tt)})}else return Pd(at,pt)},Gd=async at=>{if(gr())return Br(),new Promise((pt,vt)=>{zr("release",[pt,vt]);let wt={type:"release",in:at};St.postMessage(wt)});Rd(at)},Ld=async(at,pt,vt,wt,$t,Tt)=>{if(gr()){if(vt.some(Lt=>Lt[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if($t.some(Lt=>Lt))throw new Error("pre-allocated output tensor is not supported for proxy.");return Br(),new Promise((Lt,Ft)=>{zr("run",[Lt,Ft]);let Ct=vt,Ht={type:"run",in:{sessionId:at,inputIndices:pt,inputs:Ct,outputIndices:wt,options:Tt}};St.postMessage(Ht,Dd(Ct))})}else return zd(at,pt,vt,wt,$t,Tt)},Fd=async at=>{if(gr())return Br(),new Promise((pt,vt)=>{zr("end-profiling",[pt,vt]);let wt={type:"end-profiling",in:at};St.postMessage(wt)});Bd(at)}}),qd,mf,fi,jd=j(()=>{_t(),To(),ye(),qi(),qd=(st,at)=>{switch(st.location){case"cpu":return[st.type,st.dims,st.data,"cpu"];case"gpu-buffer":return[st.type,st.dims,{gpuBuffer:st.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${st.location} for ${at()}`)}},mf=st=>{switch(st[3]){case"cpu":return new tt(st[0],st[2],st[1]);case"gpu-buffer":{let at=st[0];if(!Vn(at))throw new Error(`not supported data type: ${at} for deserializing GPU tensor`);let{gpuBuffer:pt,download:vt,dispose:wt}=st[2];return tt.fromGpuBuffer(pt,{dataType:at,dims:st[1],download:vt,dispose:wt})}default:throw new Error(`invalid data location: ${st[3]}`)}},fi=class{async fetchModelAndCopyToWasmMemory(st){return Vd(await tn(st))}async loadModel(st,at){yt();let pt;typeof st=="string"?typeof process<"u"&&process.versions&&process.versions.node?pt=await tn(st):pt=await this.fetchModelAndCopyToWasmMemory(st):pt=st,[this.sessionId,this.inputNames,this.outputNames]=await Hd(pt,at),ut()}async dispose(){return Gd(this.sessionId)}async run(st,at,pt){yt();let vt=[],wt=[];Object.entries(st).forEach(Gt=>{let jt=Gt[0],qt=Gt[1],Kt=this.inputNames.indexOf(jt);if(Kt===-1)throw new Error(`invalid input '${jt}'`);vt.push(qt),wt.push(Kt)});let $t=[],Tt=[];Object.entries(at).forEach(Gt=>{let jt=Gt[0],qt=Gt[1],Kt=this.outputNames.indexOf(jt);if(Kt===-1)throw new Error(`invalid output '${jt}'`);$t.push(qt),Tt.push(Kt)});let Lt=vt.map((Gt,jt)=>qd(Gt,()=>`input "${this.inputNames[wt[jt]]}"`)),Ft=$t.map((Gt,jt)=>Gt?qd(Gt,()=>`output "${this.outputNames[Tt[jt]]}"`):null),Ct=await Ld(this.sessionId,wt,Lt,Tt,Ft,pt),Ht={};for(let Gt=0;Gt<Ct.length;Gt++)Ht[this.outputNames[Tt[Gt]]]=$t[Gt]??mf(Ct[Gt]);return ut(),Ht}startProfiling(){}endProfiling(){Fd(this.sessionId)}}}),ff,hi,Kd=j(()=>{_t(),To(),jd(),ff=()=>{if((typeof ke.wasm.initTimeout!="number"||ke.wasm.initTimeout<0)&&(ke.wasm.initTimeout=0),typeof ke.wasm.simd!="boolean"&&(ke.wasm.simd=!0),typeof ke.wasm.proxy!="boolean"&&(ke.wasm.proxy=!1),typeof ke.wasm.trace!="boolean"&&(ke.wasm.trace=!1),typeof ke.wasm.numThreads!="number"||!Number.isInteger(ke.wasm.numThreads)||ke.wasm.numThreads<=0){(typeof self<"u"&&!self.crossOriginIsolated||typeof process<"u"&&process.versions&&process.versions.node)&&(ke.wasm.numThreads=1);let st=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;ke.wasm.numThreads=Math.min(4,Math.ceil((st||1)/2))}},hi=class{async init(st){ff(),await Wd(),await Nd(st)}async createInferenceSessionHandler(st,at){let pt=new fi;return await pt.loadModel(st,at),Promise.resolve(pt)}}}),Yd={};kr(Yd,{wasmBackend:()=>hf});var hf,Xd=j(()=>{Kd(),hf=new hi});_t();_t();_t();var ka="1.18.0",h$=Bi;{let st=(Xd(),sr(Yd)).wasmBackend;lr("webgpu",st,5),lr("webnn",st,5),lr("cpu",st,10),lr("wasm",st,10)}Object.defineProperty(ke.versions,"web",{value:ka,enumerable:!0});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ort_gpu=Object.freeze(Object.defineProperty({__proto__:null,get InferenceSession(){return uc},get TRACE(){return Bn},get TRACE_FUNC_BEGIN(){return yt},get TRACE_FUNC_END(){return ut},get Tensor(){return tt},get TrainingSession(){return dc},default:h$,get env(){return ke},get registerBackend(){return lr}},Symbol.toStringTag,{value:"Module"}));var util;(function(st){st.assertEqual=wt=>wt;function at(wt){}st.assertIs=at;function pt(wt){throw new Error}st.assertNever=pt,st.arrayToEnum=wt=>{const $t={};for(const Tt of wt)$t[Tt]=Tt;return $t},st.getValidEnumValues=wt=>{const $t=st.objectKeys(wt).filter(Lt=>typeof wt[wt[Lt]]!="number"),Tt={};for(const Lt of $t)Tt[Lt]=wt[Lt];return st.objectValues(Tt)},st.objectValues=wt=>st.objectKeys(wt).map(function($t){return wt[$t]}),st.objectKeys=typeof Object.keys=="function"?wt=>Object.keys(wt):wt=>{const $t=[];for(const Tt in wt)Object.prototype.hasOwnProperty.call(wt,Tt)&&$t.push(Tt);return $t},st.find=(wt,$t)=>{for(const Tt of wt)if($t(Tt))return Tt},st.isInteger=typeof Number.isInteger=="function"?wt=>Number.isInteger(wt):wt=>typeof wt=="number"&&isFinite(wt)&&Math.floor(wt)===wt;function vt(wt,$t=" | "){return wt.map(Tt=>typeof Tt=="string"?`'${Tt}'`:Tt).join($t)}st.joinValues=vt,st.jsonStringifyReplacer=(wt,$t)=>typeof $t=="bigint"?$t.toString():$t})(util||(util={}));var objectUtil;(function(st){st.mergeShapes=(at,pt)=>({...at,...pt})})(objectUtil||(objectUtil={}));const ZodParsedType=util.arrayToEnum(["string","nan","number","integer","float","boolean","date","bigint","symbol","function","undefined","null","array","object","unknown","promise","void","never","map","set"]),getParsedType=st=>{switch(typeof st){case"undefined":return ZodParsedType.undefined;case"string":return ZodParsedType.string;case"number":return isNaN(st)?ZodParsedType.nan:ZodParsedType.number;case"boolean":return ZodParsedType.boolean;case"function":return ZodParsedType.function;case"bigint":return ZodParsedType.bigint;case"symbol":return ZodParsedType.symbol;case"object":return Array.isArray(st)?ZodParsedType.array:st===null?ZodParsedType.null:st.then&&typeof st.then=="function"&&st.catch&&typeof st.catch=="function"?ZodParsedType.promise:typeof Map<"u"&&st instanceof Map?ZodParsedType.map:typeof Set<"u"&&st instanceof Set?ZodParsedType.set:typeof Date<"u"&&st instanceof Date?ZodParsedType.date:ZodParsedType.object;default:return ZodParsedType.unknown}},ZodIssueCode=util.arrayToEnum(["invalid_type","invalid_literal","custom","invalid_union","invalid_union_discriminator","invalid_enum_value","unrecognized_keys","invalid_arguments","invalid_return_type","invalid_date","invalid_string","too_small","too_big","invalid_intersection_types","not_multiple_of","not_finite"]),quotelessJson=st=>JSON.stringify(st,null,2).replace(/"([^"]+)":/g,"$1:");class ZodError extends Error{constructor(at){super(),this.issues=[],this.addIssue=vt=>{this.issues=[...this.issues,vt]},this.addIssues=(vt=[])=>{this.issues=[...this.issues,...vt]};const pt=new.target.prototype;Object.setPrototypeOf?Object.setPrototypeOf(this,pt):this.__proto__=pt,this.name="ZodError",this.issues=at}get errors(){return this.issues}format(at){const pt=at||function($t){return $t.message},vt={_errors:[]},wt=$t=>{for(const Tt of $t.issues)if(Tt.code==="invalid_union")Tt.unionErrors.map(wt);else if(Tt.code==="invalid_return_type")wt(Tt.returnTypeError);else if(Tt.code==="invalid_arguments")wt(Tt.argumentsError);else if(Tt.path.length===0)vt._errors.push(pt(Tt));else{let Lt=vt,Ft=0;for(;Ft<Tt.path.length;){const Ct=Tt.path[Ft];Ft===Tt.path.length-1?(Lt[Ct]=Lt[Ct]||{_errors:[]},Lt[Ct]._errors.push(pt(Tt))):Lt[Ct]=Lt[Ct]||{_errors:[]},Lt=Lt[Ct],Ft++}}};return wt(this),vt}static assert(at){if(!(at instanceof ZodError))throw new Error(`Not a ZodError: ${at}`)}toString(){return this.message}get message(){return JSON.stringify(this.issues,util.jsonStringifyReplacer,2)}get isEmpty(){return this.issues.length===0}flatten(at=pt=>pt.message){const pt={},vt=[];for(const wt of this.issues)wt.path.length>0?(pt[wt.path[0]]=pt[wt.path[0]]||[],pt[wt.path[0]].push(at(wt))):vt.push(at(wt));return{formErrors:vt,fieldErrors:pt}}get formErrors(){return this.flatten()}}ZodError.create=st=>new ZodError(st);const errorMap=(st,at)=>{let pt;switch(st.code){case ZodIssueCode.invalid_type:st.received===ZodParsedType.undefined?pt="Required":pt=`Expected ${st.expected}, received ${st.received}`;break;case ZodIssueCode.invalid_literal:pt=`Invalid literal value, expected ${JSON.stringify(st.expected,util.jsonStringifyReplacer)}`;break;case ZodIssueCode.unrecognized_keys:pt=`Unrecognized key(s) in object: ${util.joinValues(st.keys,", ")}`;break;case ZodIssueCode.invalid_union:pt="Invalid input";break;case ZodIssueCode.invalid_union_discriminator:pt=`Invalid discriminator value. Expected ${util.joinValues(st.options)}`;break;case ZodIssueCode.invalid_enum_value:pt=`Invalid enum value. Expected ${util.joinValues(st.options)}, received '${st.received}'`;break;case ZodIssueCode.invalid_arguments:pt="Invalid function arguments";break;case ZodIssueCode.invalid_return_type:pt="Invalid function return type";break;case ZodIssueCode.invalid_date:pt="Invalid date";break;case ZodIssueCode.invalid_string:typeof st.validation=="object"?"includes"in st.validation?(pt=`Invalid input: must include "${st.validation.includes}"`,typeof st.validation.position=="number"&&(pt=`${pt} at one or more positions greater than or equal to ${st.validation.position}`)):"startsWith"in st.validation?pt=`Invalid input: must start with "${st.validation.startsWith}"`:"endsWith"in st.validation?pt=`Invalid input: must end with "${st.validation.endsWith}"`:util.assertNever(st.validation):st.validation!=="regex"?pt=`Invalid ${st.validation}`:pt="Invalid";break;case ZodIssueCode.too_small:st.type==="array"?pt=`Array must contain ${st.exact?"exactly":st.inclusive?"at least":"more than"} ${st.minimum} element(s)`:st.type==="string"?pt=`String must contain ${st.exact?"exactly":st.inclusive?"at least":"over"} ${st.minimum} character(s)`:st.type==="number"?pt=`Number must be ${st.exact?"exactly equal to ":st.inclusive?"greater than or equal to ":"greater than "}${st.minimum}`:st.type==="date"?pt=`Date must be ${st.exact?"exactly equal to ":st.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(st.minimum))}`:pt="Invalid input";break;case ZodIssueCode.too_big:st.type==="array"?pt=`Array must contain ${st.exact?"exactly":st.inclusive?"at most":"less than"} ${st.maximum} element(s)`:st.type==="string"?pt=`String must contain ${st.exact?"exactly":st.inclusive?"at most":"under"} ${st.maximum} character(s)`:st.type==="number"?pt=`Number must be ${st.exact?"exactly":st.inclusive?"less than or equal to":"less than"} ${st.maximum}`:st.type==="bigint"?pt=`BigInt must be ${st.exact?"exactly":st.inclusive?"less than or equal to":"less than"} ${st.maximum}`:st.type==="date"?pt=`Date must be ${st.exact?"exactly":st.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(st.maximum))}`:pt="Invalid input";break;case ZodIssueCode.custom:pt="Invalid input";break;case ZodIssueCode.invalid_intersection_types:pt="Intersection results could not be merged";break;case ZodIssueCode.not_multiple_of:pt=`Number must be a multiple of ${st.multipleOf}`;break;case ZodIssueCode.not_finite:pt="Number must be finite";break;default:pt=at.defaultError,util.assertNever(st)}return{message:pt}};let overrideErrorMap=errorMap;function setErrorMap(st){overrideErrorMap=st}function getErrorMap(){return overrideErrorMap}const makeIssue=st=>{const{data:at,path:pt,errorMaps:vt,issueData:wt}=st,$t=[...pt,...wt.path||[]],Tt={...wt,path:$t};if(wt.message!==void 0)return{...wt,path:$t,message:wt.message};let Lt="";const Ft=vt.filter(Ct=>!!Ct).slice().reverse();for(const Ct of Ft)Lt=Ct(Tt,{data:at,defaultError:Lt}).message;return{...wt,path:$t,message:Lt}},EMPTY_PATH=[];function addIssueToContext(st,at){const pt=getErrorMap(),vt=makeIssue({issueData:at,data:st.data,path:st.path,errorMaps:[st.common.contextualErrorMap,st.schemaErrorMap,pt,pt===errorMap?void 0:errorMap].filter(wt=>!!wt)});st.common.issues.push(vt)}class ParseStatus{constructor(){this.value="valid"}dirty(){this.value==="valid"&&(this.value="dirty")}abort(){this.value!=="aborted"&&(this.value="aborted")}static mergeArray(at,pt){const vt=[];for(const wt of pt){if(wt.status==="aborted")return INVALID;wt.status==="dirty"&&at.dirty(),vt.push(wt.value)}return{status:at.value,value:vt}}static async mergeObjectAsync(at,pt){const vt=[];for(const wt of pt){const $t=await wt.key,Tt=await wt.value;vt.push({key:$t,value:Tt})}return ParseStatus.mergeObjectSync(at,vt)}static mergeObjectSync(at,pt){const vt={};for(const wt of pt){const{key:$t,value:Tt}=wt;if($t.status==="aborted"||Tt.status==="aborted")return INVALID;$t.status==="dirty"&&at.dirty(),Tt.status==="dirty"&&at.dirty(),$t.value!=="__proto__"&&(typeof Tt.value<"u"||wt.alwaysSet)&&(vt[$t.value]=Tt.value)}return{status:at.value,value:vt}}}const INVALID=Object.freeze({status:"aborted"}),DIRTY=st=>({status:"dirty",value:st}),OK=st=>({status:"valid",value:st}),isAborted=st=>st.status==="aborted",isDirty=st=>st.status==="dirty",isValid=st=>st.status==="valid",isAsync=st=>typeof Promise<"u"&&st instanceof Promise;function __classPrivateFieldGet(st,at,pt,vt){if(typeof at=="function"?st!==at||!vt:!at.has(st))throw new TypeError("Cannot read private member from an object whose class did not declare it");return at.get(st)}function __classPrivateFieldSet(st,at,pt,vt,wt){if(typeof at=="function"?st!==at||!wt:!at.has(st))throw new TypeError("Cannot write private member to an object whose class did not declare it");return at.set(st,pt),pt}typeof SuppressedError=="function"&&SuppressedError;var errorUtil;(function(st){st.errToObj=at=>typeof at=="string"?{message:at}:at||{},st.toString=at=>typeof at=="string"?at:at==null?void 0:at.message})(errorUtil||(errorUtil={}));var _ZodEnum_cache,_ZodNativeEnum_cache;class ParseInputLazyPath{constructor(at,pt,vt,wt){this._cachedPath=[],this.parent=at,this.data=pt,this._path=vt,this._key=wt}get path(){return this._cachedPath.length||(this._key instanceof Array?this._cachedPath.push(...this._path,...this._key):this._cachedPath.push(...this._path,this._key)),this._cachedPath}}const handleResult=(st,at)=>{if(isValid(at))return{success:!0,data:at.value};if(!st.common.issues.length)throw new Error("Validation failed but no issues detected.");return{success:!1,get error(){if(this._error)return this._error;const pt=new ZodError(st.common.issues);return this._error=pt,this._error}}};function processCreateParams(st){if(!st)return{};const{errorMap:at,invalid_type_error:pt,required_error:vt,description:wt}=st;if(at&&(pt||vt))throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);return at?{errorMap:at,description:wt}:{errorMap:(Tt,Lt)=>{var Ft,Ct;const{message:Ht}=st;return Tt.code==="invalid_enum_value"?{message:Ht??Lt.defaultError}:typeof Lt.data>"u"?{message:(Ft=Ht??vt)!==null&&Ft!==void 0?Ft:Lt.defaultError}:Tt.code!=="invalid_type"?{message:Lt.defaultError}:{message:(Ct=Ht??pt)!==null&&Ct!==void 0?Ct:Lt.defaultError}},description:wt}}class ZodType{constructor(at){this.spa=this.safeParseAsync,this._def=at,this.parse=this.parse.bind(this),this.safeParse=this.safeParse.bind(this),this.parseAsync=this.parseAsync.bind(this),this.safeParseAsync=this.safeParseAsync.bind(this),this.spa=this.spa.bind(this),this.refine=this.refine.bind(this),this.refinement=this.refinement.bind(this),this.superRefine=this.superRefine.bind(this),this.optional=this.optional.bind(this),this.nullable=this.nullable.bind(this),this.nullish=this.nullish.bind(this),this.array=this.array.bind(this),this.promise=this.promise.bind(this),this.or=this.or.bind(this),this.and=this.and.bind(this),this.transform=this.transform.bind(this),this.brand=this.brand.bind(this),this.default=this.default.bind(this),this.catch=this.catch.bind(this),this.describe=this.describe.bind(this),this.pipe=this.pipe.bind(this),this.readonly=this.readonly.bind(this),this.isNullable=this.isNullable.bind(this),this.isOptional=this.isOptional.bind(this)}get description(){return this._def.description}_getType(at){return getParsedType(at.data)}_getOrReturnCtx(at,pt){return pt||{common:at.parent.common,data:at.data,parsedType:getParsedType(at.data),schemaErrorMap:this._def.errorMap,path:at.path,parent:at.parent}}_processInputParams(at){return{status:new ParseStatus,ctx:{common:at.parent.common,data:at.data,parsedType:getParsedType(at.data),schemaErrorMap:this._def.errorMap,path:at.path,parent:at.parent}}}_parseSync(at){const pt=this._parse(at);if(isAsync(pt))throw new Error("Synchronous parse encountered promise.");return pt}_parseAsync(at){const pt=this._parse(at);return Promise.resolve(pt)}parse(at,pt){const vt=this.safeParse(at,pt);if(vt.success)return vt.data;throw vt.error}safeParse(at,pt){var vt;const wt={common:{issues:[],async:(vt=pt==null?void 0:pt.async)!==null&&vt!==void 0?vt:!1,contextualErrorMap:pt==null?void 0:pt.errorMap},path:(pt==null?void 0:pt.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:at,parsedType:getParsedType(at)},$t=this._parseSync({data:at,path:wt.path,parent:wt});return handleResult(wt,$t)}async parseAsync(at,pt){const vt=await this.safeParseAsync(at,pt);if(vt.success)return vt.data;throw vt.error}async safeParseAsync(at,pt){const vt={common:{issues:[],contextualErrorMap:pt==null?void 0:pt.errorMap,async:!0},path:(pt==null?void 0:pt.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:at,parsedType:getParsedType(at)},wt=this._parse({data:at,path:vt.path,parent:vt}),$t=await(isAsync(wt)?wt:Promise.resolve(wt));return handleResult(vt,$t)}refine(at,pt){const vt=wt=>typeof pt=="string"||typeof pt>"u"?{message:pt}:typeof pt=="function"?pt(wt):pt;return this._refinement((wt,$t)=>{const Tt=at(wt),Lt=()=>$t.addIssue({code:ZodIssueCode.custom,...vt(wt)});return typeof Promise<"u"&&Tt instanceof Promise?Tt.then(Ft=>Ft?!0:(Lt(),!1)):Tt?!0:(Lt(),!1)})}refinement(at,pt){return this._refinement((vt,wt)=>at(vt)?!0:(wt.addIssue(typeof pt=="function"?pt(vt,wt):pt),!1))}_refinement(at){return new ZodEffects({schema:this,typeName:ZodFirstPartyTypeKind.ZodEffects,effect:{type:"refinement",refinement:at}})}superRefine(at){return this._refinement(at)}optional(){return ZodOptional.create(this,this._def)}nullable(){return ZodNullable.create(this,this._def)}nullish(){return this.nullable().optional()}array(){return ZodArray.create(this,this._def)}promise(){return ZodPromise.create(this,this._def)}or(at){return ZodUnion.create([this,at],this._def)}and(at){return ZodIntersection.create(this,at,this._def)}transform(at){return new ZodEffects({...processCreateParams(this._def),schema:this,typeName:ZodFirstPartyTypeKind.ZodEffects,effect:{type:"transform",transform:at}})}default(at){const pt=typeof at=="function"?at:()=>at;return new ZodDefault({...processCreateParams(this._def),innerType:this,defaultValue:pt,typeName:ZodFirstPartyTypeKind.ZodDefault})}brand(){return new ZodBranded({typeName:ZodFirstPartyTypeKind.ZodBranded,type:this,...processCreateParams(this._def)})}catch(at){const pt=typeof at=="function"?at:()=>at;return new ZodCatch({...processCreateParams(this._def),innerType:this,catchValue:pt,typeName:ZodFirstPartyTypeKind.ZodCatch})}describe(at){const pt=this.constructor;return new pt({...this._def,description:at})}pipe(at){return ZodPipeline.create(this,at)}readonly(){return ZodReadonly.create(this)}isOptional(){return this.safeParse(void 0).success}isNullable(){return this.safeParse(null).success}}const cuidRegex=/^c[^\s-]{8,}$/i,cuid2Regex=/^[0-9a-z]+$/,ulidRegex=/^[0-9A-HJKMNP-TV-Z]{26}$/,uuidRegex=/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,nanoidRegex=/^[a-z0-9_-]{21}$/i,durationRegex=/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,emailRegex=/^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,_emojiRegex="^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";let emojiRegex;const ipv4Regex=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,ipv6Regex=/^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,base64Regex=/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,dateRegexSource="((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",dateRegex=new RegExp(`^${dateRegexSource}$`);function timeRegexSource(st){let at="([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";return st.precision?at=`${at}\\.\\d{${st.precision}}`:st.precision==null&&(at=`${at}(\\.\\d+)?`),at}function timeRegex(st){return new RegExp(`^${timeRegexSource(st)}$`)}function datetimeRegex(st){let at=`${dateRegexSource}T${timeRegexSource(st)}`;const pt=[];return pt.push(st.local?"Z?":"Z"),st.offset&&pt.push("([+-]\\d{2}:?\\d{2})"),at=`${at}(${pt.join("|")})`,new RegExp(`^${at}$`)}function isValidIP(st,at){return!!((at==="v4"||!at)&&ipv4Regex.test(st)||(at==="v6"||!at)&&ipv6Regex.test(st))}class ZodString extends ZodType{_parse(at){if(this._def.coerce&&(at.data=String(at.data)),this._getType(at)!==ZodParsedType.string){const $t=this._getOrReturnCtx(at);return addIssueToContext($t,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.string,received:$t.parsedType}),INVALID}const vt=new ParseStatus;let wt;for(const $t of this._def.checks)if($t.kind==="min")at.data.length<$t.value&&(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{code:ZodIssueCode.too_small,minimum:$t.value,type:"string",inclusive:!0,exact:!1,message:$t.message}),vt.dirty());else if($t.kind==="max")at.data.length>$t.value&&(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{code:ZodIssueCode.too_big,maximum:$t.value,type:"string",inclusive:!0,exact:!1,message:$t.message}),vt.dirty());else if($t.kind==="length"){const Tt=at.data.length>$t.value,Lt=at.data.length<$t.value;(Tt||Lt)&&(wt=this._getOrReturnCtx(at,wt),Tt?addIssueToContext(wt,{code:ZodIssueCode.too_big,maximum:$t.value,type:"string",inclusive:!0,exact:!0,message:$t.message}):Lt&&addIssueToContext(wt,{code:ZodIssueCode.too_small,minimum:$t.value,type:"string",inclusive:!0,exact:!0,message:$t.message}),vt.dirty())}else if($t.kind==="email")emailRegex.test(at.data)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{validation:"email",code:ZodIssueCode.invalid_string,message:$t.message}),vt.dirty());else if($t.kind==="emoji")emojiRegex||(emojiRegex=new RegExp(_emojiRegex,"u")),emojiRegex.test(at.data)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{validation:"emoji",code:ZodIssueCode.invalid_string,message:$t.message}),vt.dirty());else if($t.kind==="uuid")uuidRegex.test(at.data)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{validation:"uuid",code:ZodIssueCode.invalid_string,message:$t.message}),vt.dirty());else if($t.kind==="nanoid")nanoidRegex.test(at.data)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{validation:"nanoid",code:ZodIssueCode.invalid_string,message:$t.message}),vt.dirty());else if($t.kind==="cuid")cuidRegex.test(at.data)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{validation:"cuid",code:ZodIssueCode.invalid_string,message:$t.message}),vt.dirty());else if($t.kind==="cuid2")cuid2Regex.test(at.data)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{validation:"cuid2",code:ZodIssueCode.invalid_string,message:$t.message}),vt.dirty());else if($t.kind==="ulid")ulidRegex.test(at.data)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{validation:"ulid",code:ZodIssueCode.invalid_string,message:$t.message}),vt.dirty());else if($t.kind==="url")try{new URL(at.data)}catch{wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{validation:"url",code:ZodIssueCode.invalid_string,message:$t.message}),vt.dirty()}else $t.kind==="regex"?($t.regex.lastIndex=0,$t.regex.test(at.data)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{validation:"regex",code:ZodIssueCode.invalid_string,message:$t.message}),vt.dirty())):$t.kind==="trim"?at.data=at.data.trim():$t.kind==="includes"?at.data.includes($t.value,$t.position)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{code:ZodIssueCode.invalid_string,validation:{includes:$t.value,position:$t.position},message:$t.message}),vt.dirty()):$t.kind==="toLowerCase"?at.data=at.data.toLowerCase():$t.kind==="toUpperCase"?at.data=at.data.toUpperCase():$t.kind==="startsWith"?at.data.startsWith($t.value)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{code:ZodIssueCode.invalid_string,validation:{startsWith:$t.value},message:$t.message}),vt.dirty()):$t.kind==="endsWith"?at.data.endsWith($t.value)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{code:ZodIssueCode.invalid_string,validation:{endsWith:$t.value},message:$t.message}),vt.dirty()):$t.kind==="datetime"?datetimeRegex($t).test(at.data)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{code:ZodIssueCode.invalid_string,validation:"datetime",message:$t.message}),vt.dirty()):$t.kind==="date"?dateRegex.test(at.data)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{code:ZodIssueCode.invalid_string,validation:"date",message:$t.message}),vt.dirty()):$t.kind==="time"?timeRegex($t).test(at.data)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{code:ZodIssueCode.invalid_string,validation:"time",message:$t.message}),vt.dirty()):$t.kind==="duration"?durationRegex.test(at.data)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{validation:"duration",code:ZodIssueCode.invalid_string,message:$t.message}),vt.dirty()):$t.kind==="ip"?isValidIP(at.data,$t.version)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{validation:"ip",code:ZodIssueCode.invalid_string,message:$t.message}),vt.dirty()):$t.kind==="base64"?base64Regex.test(at.data)||(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{validation:"base64",code:ZodIssueCode.invalid_string,message:$t.message}),vt.dirty()):util.assertNever($t);return{status:vt.value,value:at.data}}_regex(at,pt,vt){return this.refinement(wt=>at.test(wt),{validation:pt,code:ZodIssueCode.invalid_string,...errorUtil.errToObj(vt)})}_addCheck(at){return new ZodString({...this._def,checks:[...this._def.checks,at]})}email(at){return this._addCheck({kind:"email",...errorUtil.errToObj(at)})}url(at){return this._addCheck({kind:"url",...errorUtil.errToObj(at)})}emoji(at){return this._addCheck({kind:"emoji",...errorUtil.errToObj(at)})}uuid(at){return this._addCheck({kind:"uuid",...errorUtil.errToObj(at)})}nanoid(at){return this._addCheck({kind:"nanoid",...errorUtil.errToObj(at)})}cuid(at){return this._addCheck({kind:"cuid",...errorUtil.errToObj(at)})}cuid2(at){return this._addCheck({kind:"cuid2",...errorUtil.errToObj(at)})}ulid(at){return this._addCheck({kind:"ulid",...errorUtil.errToObj(at)})}base64(at){return this._addCheck({kind:"base64",...errorUtil.errToObj(at)})}ip(at){return this._addCheck({kind:"ip",...errorUtil.errToObj(at)})}datetime(at){var pt,vt;return typeof at=="string"?this._addCheck({kind:"datetime",precision:null,offset:!1,local:!1,message:at}):this._addCheck({kind:"datetime",precision:typeof(at==null?void 0:at.precision)>"u"?null:at==null?void 0:at.precision,offset:(pt=at==null?void 0:at.offset)!==null&&pt!==void 0?pt:!1,local:(vt=at==null?void 0:at.local)!==null&&vt!==void 0?vt:!1,...errorUtil.errToObj(at==null?void 0:at.message)})}date(at){return this._addCheck({kind:"date",message:at})}time(at){return typeof at=="string"?this._addCheck({kind:"time",precision:null,message:at}):this._addCheck({kind:"time",precision:typeof(at==null?void 0:at.precision)>"u"?null:at==null?void 0:at.precision,...errorUtil.errToObj(at==null?void 0:at.message)})}duration(at){return this._addCheck({kind:"duration",...errorUtil.errToObj(at)})}regex(at,pt){return this._addCheck({kind:"regex",regex:at,...errorUtil.errToObj(pt)})}includes(at,pt){return this._addCheck({kind:"includes",value:at,position:pt==null?void 0:pt.position,...errorUtil.errToObj(pt==null?void 0:pt.message)})}startsWith(at,pt){return this._addCheck({kind:"startsWith",value:at,...errorUtil.errToObj(pt)})}endsWith(at,pt){return this._addCheck({kind:"endsWith",value:at,...errorUtil.errToObj(pt)})}min(at,pt){return this._addCheck({kind:"min",value:at,...errorUtil.errToObj(pt)})}max(at,pt){return this._addCheck({kind:"max",value:at,...errorUtil.errToObj(pt)})}length(at,pt){return this._addCheck({kind:"length",value:at,...errorUtil.errToObj(pt)})}nonempty(at){return this.min(1,errorUtil.errToObj(at))}trim(){return new ZodString({...this._def,checks:[...this._def.checks,{kind:"trim"}]})}toLowerCase(){return new ZodString({...this._def,checks:[...this._def.checks,{kind:"toLowerCase"}]})}toUpperCase(){return new ZodString({...this._def,checks:[...this._def.checks,{kind:"toUpperCase"}]})}get isDatetime(){return!!this._def.checks.find(at=>at.kind==="datetime")}get isDate(){return!!this._def.checks.find(at=>at.kind==="date")}get isTime(){return!!this._def.checks.find(at=>at.kind==="time")}get isDuration(){return!!this._def.checks.find(at=>at.kind==="duration")}get isEmail(){return!!this._def.checks.find(at=>at.kind==="email")}get isURL(){return!!this._def.checks.find(at=>at.kind==="url")}get isEmoji(){return!!this._def.checks.find(at=>at.kind==="emoji")}get isUUID(){return!!this._def.checks.find(at=>at.kind==="uuid")}get isNANOID(){return!!this._def.checks.find(at=>at.kind==="nanoid")}get isCUID(){return!!this._def.checks.find(at=>at.kind==="cuid")}get isCUID2(){return!!this._def.checks.find(at=>at.kind==="cuid2")}get isULID(){return!!this._def.checks.find(at=>at.kind==="ulid")}get isIP(){return!!this._def.checks.find(at=>at.kind==="ip")}get isBase64(){return!!this._def.checks.find(at=>at.kind==="base64")}get minLength(){let at=null;for(const pt of this._def.checks)pt.kind==="min"&&(at===null||pt.value>at)&&(at=pt.value);return at}get maxLength(){let at=null;for(const pt of this._def.checks)pt.kind==="max"&&(at===null||pt.value<at)&&(at=pt.value);return at}}ZodString.create=st=>{var at;return new ZodString({checks:[],typeName:ZodFirstPartyTypeKind.ZodString,coerce:(at=st==null?void 0:st.coerce)!==null&&at!==void 0?at:!1,...processCreateParams(st)})};function floatSafeRemainder(st,at){const pt=(st.toString().split(".")[1]||"").length,vt=(at.toString().split(".")[1]||"").length,wt=pt>vt?pt:vt,$t=parseInt(st.toFixed(wt).replace(".","")),Tt=parseInt(at.toFixed(wt).replace(".",""));return $t%Tt/Math.pow(10,wt)}class ZodNumber extends ZodType{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte,this.step=this.multipleOf}_parse(at){if(this._def.coerce&&(at.data=Number(at.data)),this._getType(at)!==ZodParsedType.number){const $t=this._getOrReturnCtx(at);return addIssueToContext($t,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.number,received:$t.parsedType}),INVALID}let vt;const wt=new ParseStatus;for(const $t of this._def.checks)$t.kind==="int"?util.isInteger(at.data)||(vt=this._getOrReturnCtx(at,vt),addIssueToContext(vt,{code:ZodIssueCode.invalid_type,expected:"integer",received:"float",message:$t.message}),wt.dirty()):$t.kind==="min"?($t.inclusive?at.data<$t.value:at.data<=$t.value)&&(vt=this._getOrReturnCtx(at,vt),addIssueToContext(vt,{code:ZodIssueCode.too_small,minimum:$t.value,type:"number",inclusive:$t.inclusive,exact:!1,message:$t.message}),wt.dirty()):$t.kind==="max"?($t.inclusive?at.data>$t.value:at.data>=$t.value)&&(vt=this._getOrReturnCtx(at,vt),addIssueToContext(vt,{code:ZodIssueCode.too_big,maximum:$t.value,type:"number",inclusive:$t.inclusive,exact:!1,message:$t.message}),wt.dirty()):$t.kind==="multipleOf"?floatSafeRemainder(at.data,$t.value)!==0&&(vt=this._getOrReturnCtx(at,vt),addIssueToContext(vt,{code:ZodIssueCode.not_multiple_of,multipleOf:$t.value,message:$t.message}),wt.dirty()):$t.kind==="finite"?Number.isFinite(at.data)||(vt=this._getOrReturnCtx(at,vt),addIssueToContext(vt,{code:ZodIssueCode.not_finite,message:$t.message}),wt.dirty()):util.assertNever($t);return{status:wt.value,value:at.data}}gte(at,pt){return this.setLimit("min",at,!0,errorUtil.toString(pt))}gt(at,pt){return this.setLimit("min",at,!1,errorUtil.toString(pt))}lte(at,pt){return this.setLimit("max",at,!0,errorUtil.toString(pt))}lt(at,pt){return this.setLimit("max",at,!1,errorUtil.toString(pt))}setLimit(at,pt,vt,wt){return new ZodNumber({...this._def,checks:[...this._def.checks,{kind:at,value:pt,inclusive:vt,message:errorUtil.toString(wt)}]})}_addCheck(at){return new ZodNumber({...this._def,checks:[...this._def.checks,at]})}int(at){return this._addCheck({kind:"int",message:errorUtil.toString(at)})}positive(at){return this._addCheck({kind:"min",value:0,inclusive:!1,message:errorUtil.toString(at)})}negative(at){return this._addCheck({kind:"max",value:0,inclusive:!1,message:errorUtil.toString(at)})}nonpositive(at){return this._addCheck({kind:"max",value:0,inclusive:!0,message:errorUtil.toString(at)})}nonnegative(at){return this._addCheck({kind:"min",value:0,inclusive:!0,message:errorUtil.toString(at)})}multipleOf(at,pt){return this._addCheck({kind:"multipleOf",value:at,message:errorUtil.toString(pt)})}finite(at){return this._addCheck({kind:"finite",message:errorUtil.toString(at)})}safe(at){return this._addCheck({kind:"min",inclusive:!0,value:Number.MIN_SAFE_INTEGER,message:errorUtil.toString(at)})._addCheck({kind:"max",inclusive:!0,value:Number.MAX_SAFE_INTEGER,message:errorUtil.toString(at)})}get minValue(){let at=null;for(const pt of this._def.checks)pt.kind==="min"&&(at===null||pt.value>at)&&(at=pt.value);return at}get maxValue(){let at=null;for(const pt of this._def.checks)pt.kind==="max"&&(at===null||pt.value<at)&&(at=pt.value);return at}get isInt(){return!!this._def.checks.find(at=>at.kind==="int"||at.kind==="multipleOf"&&util.isInteger(at.value))}get isFinite(){let at=null,pt=null;for(const vt of this._def.checks){if(vt.kind==="finite"||vt.kind==="int"||vt.kind==="multipleOf")return!0;vt.kind==="min"?(pt===null||vt.value>pt)&&(pt=vt.value):vt.kind==="max"&&(at===null||vt.value<at)&&(at=vt.value)}return Number.isFinite(pt)&&Number.isFinite(at)}}ZodNumber.create=st=>new ZodNumber({checks:[],typeName:ZodFirstPartyTypeKind.ZodNumber,coerce:(st==null?void 0:st.coerce)||!1,...processCreateParams(st)});class ZodBigInt extends ZodType{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte}_parse(at){if(this._def.coerce&&(at.data=BigInt(at.data)),this._getType(at)!==ZodParsedType.bigint){const $t=this._getOrReturnCtx(at);return addIssueToContext($t,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.bigint,received:$t.parsedType}),INVALID}let vt;const wt=new ParseStatus;for(const $t of this._def.checks)$t.kind==="min"?($t.inclusive?at.data<$t.value:at.data<=$t.value)&&(vt=this._getOrReturnCtx(at,vt),addIssueToContext(vt,{code:ZodIssueCode.too_small,type:"bigint",minimum:$t.value,inclusive:$t.inclusive,message:$t.message}),wt.dirty()):$t.kind==="max"?($t.inclusive?at.data>$t.value:at.data>=$t.value)&&(vt=this._getOrReturnCtx(at,vt),addIssueToContext(vt,{code:ZodIssueCode.too_big,type:"bigint",maximum:$t.value,inclusive:$t.inclusive,message:$t.message}),wt.dirty()):$t.kind==="multipleOf"?at.data%$t.value!==BigInt(0)&&(vt=this._getOrReturnCtx(at,vt),addIssueToContext(vt,{code:ZodIssueCode.not_multiple_of,multipleOf:$t.value,message:$t.message}),wt.dirty()):util.assertNever($t);return{status:wt.value,value:at.data}}gte(at,pt){return this.setLimit("min",at,!0,errorUtil.toString(pt))}gt(at,pt){return this.setLimit("min",at,!1,errorUtil.toString(pt))}lte(at,pt){return this.setLimit("max",at,!0,errorUtil.toString(pt))}lt(at,pt){return this.setLimit("max",at,!1,errorUtil.toString(pt))}setLimit(at,pt,vt,wt){return new ZodBigInt({...this._def,checks:[...this._def.checks,{kind:at,value:pt,inclusive:vt,message:errorUtil.toString(wt)}]})}_addCheck(at){return new ZodBigInt({...this._def,checks:[...this._def.checks,at]})}positive(at){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!1,message:errorUtil.toString(at)})}negative(at){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!1,message:errorUtil.toString(at)})}nonpositive(at){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!0,message:errorUtil.toString(at)})}nonnegative(at){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!0,message:errorUtil.toString(at)})}multipleOf(at,pt){return this._addCheck({kind:"multipleOf",value:at,message:errorUtil.toString(pt)})}get minValue(){let at=null;for(const pt of this._def.checks)pt.kind==="min"&&(at===null||pt.value>at)&&(at=pt.value);return at}get maxValue(){let at=null;for(const pt of this._def.checks)pt.kind==="max"&&(at===null||pt.value<at)&&(at=pt.value);return at}}ZodBigInt.create=st=>{var at;return new ZodBigInt({checks:[],typeName:ZodFirstPartyTypeKind.ZodBigInt,coerce:(at=st==null?void 0:st.coerce)!==null&&at!==void 0?at:!1,...processCreateParams(st)})};class ZodBoolean extends ZodType{_parse(at){if(this._def.coerce&&(at.data=!!at.data),this._getType(at)!==ZodParsedType.boolean){const vt=this._getOrReturnCtx(at);return addIssueToContext(vt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.boolean,received:vt.parsedType}),INVALID}return OK(at.data)}}ZodBoolean.create=st=>new ZodBoolean({typeName:ZodFirstPartyTypeKind.ZodBoolean,coerce:(st==null?void 0:st.coerce)||!1,...processCreateParams(st)});class ZodDate extends ZodType{_parse(at){if(this._def.coerce&&(at.data=new Date(at.data)),this._getType(at)!==ZodParsedType.date){const $t=this._getOrReturnCtx(at);return addIssueToContext($t,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.date,received:$t.parsedType}),INVALID}if(isNaN(at.data.getTime())){const $t=this._getOrReturnCtx(at);return addIssueToContext($t,{code:ZodIssueCode.invalid_date}),INVALID}const vt=new ParseStatus;let wt;for(const $t of this._def.checks)$t.kind==="min"?at.data.getTime()<$t.value&&(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{code:ZodIssueCode.too_small,message:$t.message,inclusive:!0,exact:!1,minimum:$t.value,type:"date"}),vt.dirty()):$t.kind==="max"?at.data.getTime()>$t.value&&(wt=this._getOrReturnCtx(at,wt),addIssueToContext(wt,{code:ZodIssueCode.too_big,message:$t.message,inclusive:!0,exact:!1,maximum:$t.value,type:"date"}),vt.dirty()):util.assertNever($t);return{status:vt.value,value:new Date(at.data.getTime())}}_addCheck(at){return new ZodDate({...this._def,checks:[...this._def.checks,at]})}min(at,pt){return this._addCheck({kind:"min",value:at.getTime(),message:errorUtil.toString(pt)})}max(at,pt){return this._addCheck({kind:"max",value:at.getTime(),message:errorUtil.toString(pt)})}get minDate(){let at=null;for(const pt of this._def.checks)pt.kind==="min"&&(at===null||pt.value>at)&&(at=pt.value);return at!=null?new Date(at):null}get maxDate(){let at=null;for(const pt of this._def.checks)pt.kind==="max"&&(at===null||pt.value<at)&&(at=pt.value);return at!=null?new Date(at):null}}ZodDate.create=st=>new ZodDate({checks:[],coerce:(st==null?void 0:st.coerce)||!1,typeName:ZodFirstPartyTypeKind.ZodDate,...processCreateParams(st)});class ZodSymbol extends ZodType{_parse(at){if(this._getType(at)!==ZodParsedType.symbol){const vt=this._getOrReturnCtx(at);return addIssueToContext(vt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.symbol,received:vt.parsedType}),INVALID}return OK(at.data)}}ZodSymbol.create=st=>new ZodSymbol({typeName:ZodFirstPartyTypeKind.ZodSymbol,...processCreateParams(st)});class ZodUndefined extends ZodType{_parse(at){if(this._getType(at)!==ZodParsedType.undefined){const vt=this._getOrReturnCtx(at);return addIssueToContext(vt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.undefined,received:vt.parsedType}),INVALID}return OK(at.data)}}ZodUndefined.create=st=>new ZodUndefined({typeName:ZodFirstPartyTypeKind.ZodUndefined,...processCreateParams(st)});class ZodNull extends ZodType{_parse(at){if(this._getType(at)!==ZodParsedType.null){const vt=this._getOrReturnCtx(at);return addIssueToContext(vt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.null,received:vt.parsedType}),INVALID}return OK(at.data)}}ZodNull.create=st=>new ZodNull({typeName:ZodFirstPartyTypeKind.ZodNull,...processCreateParams(st)});class ZodAny extends ZodType{constructor(){super(...arguments),this._any=!0}_parse(at){return OK(at.data)}}ZodAny.create=st=>new ZodAny({typeName:ZodFirstPartyTypeKind.ZodAny,...processCreateParams(st)});class ZodUnknown extends ZodType{constructor(){super(...arguments),this._unknown=!0}_parse(at){return OK(at.data)}}ZodUnknown.create=st=>new ZodUnknown({typeName:ZodFirstPartyTypeKind.ZodUnknown,...processCreateParams(st)});class ZodNever extends ZodType{_parse(at){const pt=this._getOrReturnCtx(at);return addIssueToContext(pt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.never,received:pt.parsedType}),INVALID}}ZodNever.create=st=>new ZodNever({typeName:ZodFirstPartyTypeKind.ZodNever,...processCreateParams(st)});class ZodVoid extends ZodType{_parse(at){if(this._getType(at)!==ZodParsedType.undefined){const vt=this._getOrReturnCtx(at);return addIssueToContext(vt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.void,received:vt.parsedType}),INVALID}return OK(at.data)}}ZodVoid.create=st=>new ZodVoid({typeName:ZodFirstPartyTypeKind.ZodVoid,...processCreateParams(st)});class ZodArray extends ZodType{_parse(at){const{ctx:pt,status:vt}=this._processInputParams(at),wt=this._def;if(pt.parsedType!==ZodParsedType.array)return addIssueToContext(pt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.array,received:pt.parsedType}),INVALID;if(wt.exactLength!==null){const Tt=pt.data.length>wt.exactLength.value,Lt=pt.data.length<wt.exactLength.value;(Tt||Lt)&&(addIssueToContext(pt,{code:Tt?ZodIssueCode.too_big:ZodIssueCode.too_small,minimum:Lt?wt.exactLength.value:void 0,maximum:Tt?wt.exactLength.value:void 0,type:"array",inclusive:!0,exact:!0,message:wt.exactLength.message}),vt.dirty())}if(wt.minLength!==null&&pt.data.length<wt.minLength.value&&(addIssueToContext(pt,{code:ZodIssueCode.too_small,minimum:wt.minLength.value,type:"array",inclusive:!0,exact:!1,message:wt.minLength.message}),vt.dirty()),wt.maxLength!==null&&pt.data.length>wt.maxLength.value&&(addIssueToContext(pt,{code:ZodIssueCode.too_big,maximum:wt.maxLength.value,type:"array",inclusive:!0,exact:!1,message:wt.maxLength.message}),vt.dirty()),pt.common.async)return Promise.all([...pt.data].map((Tt,Lt)=>wt.type._parseAsync(new ParseInputLazyPath(pt,Tt,pt.path,Lt)))).then(Tt=>ParseStatus.mergeArray(vt,Tt));const $t=[...pt.data].map((Tt,Lt)=>wt.type._parseSync(new ParseInputLazyPath(pt,Tt,pt.path,Lt)));return ParseStatus.mergeArray(vt,$t)}get element(){return this._def.type}min(at,pt){return new ZodArray({...this._def,minLength:{value:at,message:errorUtil.toString(pt)}})}max(at,pt){return new ZodArray({...this._def,maxLength:{value:at,message:errorUtil.toString(pt)}})}length(at,pt){return new ZodArray({...this._def,exactLength:{value:at,message:errorUtil.toString(pt)}})}nonempty(at){return this.min(1,at)}}ZodArray.create=(st,at)=>new ZodArray({type:st,minLength:null,maxLength:null,exactLength:null,typeName:ZodFirstPartyTypeKind.ZodArray,...processCreateParams(at)});function deepPartialify(st){if(st instanceof ZodObject){const at={};for(const pt in st.shape){const vt=st.shape[pt];at[pt]=ZodOptional.create(deepPartialify(vt))}return new ZodObject({...st._def,shape:()=>at})}else return st instanceof ZodArray?new ZodArray({...st._def,type:deepPartialify(st.element)}):st instanceof ZodOptional?ZodOptional.create(deepPartialify(st.unwrap())):st instanceof ZodNullable?ZodNullable.create(deepPartialify(st.unwrap())):st instanceof ZodTuple?ZodTuple.create(st.items.map(at=>deepPartialify(at))):st}class ZodObject extends ZodType{constructor(){super(...arguments),this._cached=null,this.nonstrict=this.passthrough,this.augment=this.extend}_getCached(){if(this._cached!==null)return this._cached;const at=this._def.shape(),pt=util.objectKeys(at);return this._cached={shape:at,keys:pt}}_parse(at){if(this._getType(at)!==ZodParsedType.object){const Ct=this._getOrReturnCtx(at);return addIssueToContext(Ct,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.object,received:Ct.parsedType}),INVALID}const{status:vt,ctx:wt}=this._processInputParams(at),{shape:$t,keys:Tt}=this._getCached(),Lt=[];if(!(this._def.catchall instanceof ZodNever&&this._def.unknownKeys==="strip"))for(const Ct in wt.data)Tt.includes(Ct)||Lt.push(Ct);const Ft=[];for(const Ct of Tt){const Ht=$t[Ct],Gt=wt.data[Ct];Ft.push({key:{status:"valid",value:Ct},value:Ht._parse(new ParseInputLazyPath(wt,Gt,wt.path,Ct)),alwaysSet:Ct in wt.data})}if(this._def.catchall instanceof ZodNever){const Ct=this._def.unknownKeys;if(Ct==="passthrough")for(const Ht of Lt)Ft.push({key:{status:"valid",value:Ht},value:{status:"valid",value:wt.data[Ht]}});else if(Ct==="strict")Lt.length>0&&(addIssueToContext(wt,{code:ZodIssueCode.unrecognized_keys,keys:Lt}),vt.dirty());else if(Ct!=="strip")throw new Error("Internal ZodObject error: invalid unknownKeys value.")}else{const Ct=this._def.catchall;for(const Ht of Lt){const Gt=wt.data[Ht];Ft.push({key:{status:"valid",value:Ht},value:Ct._parse(new ParseInputLazyPath(wt,Gt,wt.path,Ht)),alwaysSet:Ht in wt.data})}}return wt.common.async?Promise.resolve().then(async()=>{const Ct=[];for(const Ht of Ft){const Gt=await Ht.key,jt=await Ht.value;Ct.push({key:Gt,value:jt,alwaysSet:Ht.alwaysSet})}return Ct}).then(Ct=>ParseStatus.mergeObjectSync(vt,Ct)):ParseStatus.mergeObjectSync(vt,Ft)}get shape(){return this._def.shape()}strict(at){return errorUtil.errToObj,new ZodObject({...this._def,unknownKeys:"strict",...at!==void 0?{errorMap:(pt,vt)=>{var wt,$t,Tt,Lt;const Ft=(Tt=($t=(wt=this._def).errorMap)===null||$t===void 0?void 0:$t.call(wt,pt,vt).message)!==null&&Tt!==void 0?Tt:vt.defaultError;return pt.code==="unrecognized_keys"?{message:(Lt=errorUtil.errToObj(at).message)!==null&&Lt!==void 0?Lt:Ft}:{message:Ft}}}:{}})}strip(){return new ZodObject({...this._def,unknownKeys:"strip"})}passthrough(){return new ZodObject({...this._def,unknownKeys:"passthrough"})}extend(at){return new ZodObject({...this._def,shape:()=>({...this._def.shape(),...at})})}merge(at){return new ZodObject({unknownKeys:at._def.unknownKeys,catchall:at._def.catchall,shape:()=>({...this._def.shape(),...at._def.shape()}),typeName:ZodFirstPartyTypeKind.ZodObject})}setKey(at,pt){return this.augment({[at]:pt})}catchall(at){return new ZodObject({...this._def,catchall:at})}pick(at){const pt={};return util.objectKeys(at).forEach(vt=>{at[vt]&&this.shape[vt]&&(pt[vt]=this.shape[vt])}),new ZodObject({...this._def,shape:()=>pt})}omit(at){const pt={};return util.objectKeys(this.shape).forEach(vt=>{at[vt]||(pt[vt]=this.shape[vt])}),new ZodObject({...this._def,shape:()=>pt})}deepPartial(){return deepPartialify(this)}partial(at){const pt={};return util.objectKeys(this.shape).forEach(vt=>{const wt=this.shape[vt];at&&!at[vt]?pt[vt]=wt:pt[vt]=wt.optional()}),new ZodObject({...this._def,shape:()=>pt})}required(at){const pt={};return util.objectKeys(this.shape).forEach(vt=>{if(at&&!at[vt])pt[vt]=this.shape[vt];else{let $t=this.shape[vt];for(;$t instanceof ZodOptional;)$t=$t._def.innerType;pt[vt]=$t}}),new ZodObject({...this._def,shape:()=>pt})}keyof(){return createZodEnum(util.objectKeys(this.shape))}}ZodObject.create=(st,at)=>new ZodObject({shape:()=>st,unknownKeys:"strip",catchall:ZodNever.create(),typeName:ZodFirstPartyTypeKind.ZodObject,...processCreateParams(at)});ZodObject.strictCreate=(st,at)=>new ZodObject({shape:()=>st,unknownKeys:"strict",catchall:ZodNever.create(),typeName:ZodFirstPartyTypeKind.ZodObject,...processCreateParams(at)});ZodObject.lazycreate=(st,at)=>new ZodObject({shape:st,unknownKeys:"strip",catchall:ZodNever.create(),typeName:ZodFirstPartyTypeKind.ZodObject,...processCreateParams(at)});class ZodUnion extends ZodType{_parse(at){const{ctx:pt}=this._processInputParams(at),vt=this._def.options;function wt($t){for(const Lt of $t)if(Lt.result.status==="valid")return Lt.result;for(const Lt of $t)if(Lt.result.status==="dirty")return pt.common.issues.push(...Lt.ctx.common.issues),Lt.result;const Tt=$t.map(Lt=>new ZodError(Lt.ctx.common.issues));return addIssueToContext(pt,{code:ZodIssueCode.invalid_union,unionErrors:Tt}),INVALID}if(pt.common.async)return Promise.all(vt.map(async $t=>{const Tt={...pt,common:{...pt.common,issues:[]},parent:null};return{result:await $t._parseAsync({data:pt.data,path:pt.path,parent:Tt}),ctx:Tt}})).then(wt);{let $t;const Tt=[];for(const Ft of vt){const Ct={...pt,common:{...pt.common,issues:[]},parent:null},Ht=Ft._parseSync({data:pt.data,path:pt.path,parent:Ct});if(Ht.status==="valid")return Ht;Ht.status==="dirty"&&!$t&&($t={result:Ht,ctx:Ct}),Ct.common.issues.length&&Tt.push(Ct.common.issues)}if($t)return pt.common.issues.push(...$t.ctx.common.issues),$t.result;const Lt=Tt.map(Ft=>new ZodError(Ft));return addIssueToContext(pt,{code:ZodIssueCode.invalid_union,unionErrors:Lt}),INVALID}}get options(){return this._def.options}}ZodUnion.create=(st,at)=>new ZodUnion({options:st,typeName:ZodFirstPartyTypeKind.ZodUnion,...processCreateParams(at)});const getDiscriminator=st=>st instanceof ZodLazy?getDiscriminator(st.schema):st instanceof ZodEffects?getDiscriminator(st.innerType()):st instanceof ZodLiteral?[st.value]:st instanceof ZodEnum?st.options:st instanceof ZodNativeEnum?util.objectValues(st.enum):st instanceof ZodDefault?getDiscriminator(st._def.innerType):st instanceof ZodUndefined?[void 0]:st instanceof ZodNull?[null]:st instanceof ZodOptional?[void 0,...getDiscriminator(st.unwrap())]:st instanceof ZodNullable?[null,...getDiscriminator(st.unwrap())]:st instanceof ZodBranded||st instanceof ZodReadonly?getDiscriminator(st.unwrap()):st instanceof ZodCatch?getDiscriminator(st._def.innerType):[];class ZodDiscriminatedUnion extends ZodType{_parse(at){const{ctx:pt}=this._processInputParams(at);if(pt.parsedType!==ZodParsedType.object)return addIssueToContext(pt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.object,received:pt.parsedType}),INVALID;const vt=this.discriminator,wt=pt.data[vt],$t=this.optionsMap.get(wt);return $t?pt.common.async?$t._parseAsync({data:pt.data,path:pt.path,parent:pt}):$t._parseSync({data:pt.data,path:pt.path,parent:pt}):(addIssueToContext(pt,{code:ZodIssueCode.invalid_union_discriminator,options:Array.from(this.optionsMap.keys()),path:[vt]}),INVALID)}get discriminator(){return this._def.discriminator}get options(){return this._def.options}get optionsMap(){return this._def.optionsMap}static create(at,pt,vt){const wt=new Map;for(const $t of pt){const Tt=getDiscriminator($t.shape[at]);if(!Tt.length)throw new Error(`A discriminator value for key \`${at}\` could not be extracted from all schema options`);for(const Lt of Tt){if(wt.has(Lt))throw new Error(`Discriminator property ${String(at)} has duplicate value ${String(Lt)}`);wt.set(Lt,$t)}}return new ZodDiscriminatedUnion({typeName:ZodFirstPartyTypeKind.ZodDiscriminatedUnion,discriminator:at,options:pt,optionsMap:wt,...processCreateParams(vt)})}}function mergeValues(st,at){const pt=getParsedType(st),vt=getParsedType(at);if(st===at)return{valid:!0,data:st};if(pt===ZodParsedType.object&&vt===ZodParsedType.object){const wt=util.objectKeys(at),$t=util.objectKeys(st).filter(Lt=>wt.indexOf(Lt)!==-1),Tt={...st,...at};for(const Lt of $t){const Ft=mergeValues(st[Lt],at[Lt]);if(!Ft.valid)return{valid:!1};Tt[Lt]=Ft.data}return{valid:!0,data:Tt}}else if(pt===ZodParsedType.array&&vt===ZodParsedType.array){if(st.length!==at.length)return{valid:!1};const wt=[];for(let $t=0;$t<st.length;$t++){const Tt=st[$t],Lt=at[$t],Ft=mergeValues(Tt,Lt);if(!Ft.valid)return{valid:!1};wt.push(Ft.data)}return{valid:!0,data:wt}}else return pt===ZodParsedType.date&&vt===ZodParsedType.date&&+st==+at?{valid:!0,data:st}:{valid:!1}}class ZodIntersection extends ZodType{_parse(at){const{status:pt,ctx:vt}=this._processInputParams(at),wt=($t,Tt)=>{if(isAborted($t)||isAborted(Tt))return INVALID;const Lt=mergeValues($t.value,Tt.value);return Lt.valid?((isDirty($t)||isDirty(Tt))&&pt.dirty(),{status:pt.value,value:Lt.data}):(addIssueToContext(vt,{code:ZodIssueCode.invalid_intersection_types}),INVALID)};return vt.common.async?Promise.all([this._def.left._parseAsync({data:vt.data,path:vt.path,parent:vt}),this._def.right._parseAsync({data:vt.data,path:vt.path,parent:vt})]).then(([$t,Tt])=>wt($t,Tt)):wt(this._def.left._parseSync({data:vt.data,path:vt.path,parent:vt}),this._def.right._parseSync({data:vt.data,path:vt.path,parent:vt}))}}ZodIntersection.create=(st,at,pt)=>new ZodIntersection({left:st,right:at,typeName:ZodFirstPartyTypeKind.ZodIntersection,...processCreateParams(pt)});class ZodTuple extends ZodType{_parse(at){const{status:pt,ctx:vt}=this._processInputParams(at);if(vt.parsedType!==ZodParsedType.array)return addIssueToContext(vt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.array,received:vt.parsedType}),INVALID;if(vt.data.length<this._def.items.length)return addIssueToContext(vt,{code:ZodIssueCode.too_small,minimum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),INVALID;!this._def.rest&&vt.data.length>this._def.items.length&&(addIssueToContext(vt,{code:ZodIssueCode.too_big,maximum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),pt.dirty());const $t=[...vt.data].map((Tt,Lt)=>{const Ft=this._def.items[Lt]||this._def.rest;return Ft?Ft._parse(new ParseInputLazyPath(vt,Tt,vt.path,Lt)):null}).filter(Tt=>!!Tt);return vt.common.async?Promise.all($t).then(Tt=>ParseStatus.mergeArray(pt,Tt)):ParseStatus.mergeArray(pt,$t)}get items(){return this._def.items}rest(at){return new ZodTuple({...this._def,rest:at})}}ZodTuple.create=(st,at)=>{if(!Array.isArray(st))throw new Error("You must pass an array of schemas to z.tuple([ ... ])");return new ZodTuple({items:st,typeName:ZodFirstPartyTypeKind.ZodTuple,rest:null,...processCreateParams(at)})};class ZodRecord extends ZodType{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(at){const{status:pt,ctx:vt}=this._processInputParams(at);if(vt.parsedType!==ZodParsedType.object)return addIssueToContext(vt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.object,received:vt.parsedType}),INVALID;const wt=[],$t=this._def.keyType,Tt=this._def.valueType;for(const Lt in vt.data)wt.push({key:$t._parse(new ParseInputLazyPath(vt,Lt,vt.path,Lt)),value:Tt._parse(new ParseInputLazyPath(vt,vt.data[Lt],vt.path,Lt)),alwaysSet:Lt in vt.data});return vt.common.async?ParseStatus.mergeObjectAsync(pt,wt):ParseStatus.mergeObjectSync(pt,wt)}get element(){return this._def.valueType}static create(at,pt,vt){return pt instanceof ZodType?new ZodRecord({keyType:at,valueType:pt,typeName:ZodFirstPartyTypeKind.ZodRecord,...processCreateParams(vt)}):new ZodRecord({keyType:ZodString.create(),valueType:at,typeName:ZodFirstPartyTypeKind.ZodRecord,...processCreateParams(pt)})}}class ZodMap extends ZodType{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(at){const{status:pt,ctx:vt}=this._processInputParams(at);if(vt.parsedType!==ZodParsedType.map)return addIssueToContext(vt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.map,received:vt.parsedType}),INVALID;const wt=this._def.keyType,$t=this._def.valueType,Tt=[...vt.data.entries()].map(([Lt,Ft],Ct)=>({key:wt._parse(new ParseInputLazyPath(vt,Lt,vt.path,[Ct,"key"])),value:$t._parse(new ParseInputLazyPath(vt,Ft,vt.path,[Ct,"value"]))}));if(vt.common.async){const Lt=new Map;return Promise.resolve().then(async()=>{for(const Ft of Tt){const Ct=await Ft.key,Ht=await Ft.value;if(Ct.status==="aborted"||Ht.status==="aborted")return INVALID;(Ct.status==="dirty"||Ht.status==="dirty")&&pt.dirty(),Lt.set(Ct.value,Ht.value)}return{status:pt.value,value:Lt}})}else{const Lt=new Map;for(const Ft of Tt){const Ct=Ft.key,Ht=Ft.value;if(Ct.status==="aborted"||Ht.status==="aborted")return INVALID;(Ct.status==="dirty"||Ht.status==="dirty")&&pt.dirty(),Lt.set(Ct.value,Ht.value)}return{status:pt.value,value:Lt}}}}ZodMap.create=(st,at,pt)=>new ZodMap({valueType:at,keyType:st,typeName:ZodFirstPartyTypeKind.ZodMap,...processCreateParams(pt)});class ZodSet extends ZodType{_parse(at){const{status:pt,ctx:vt}=this._processInputParams(at);if(vt.parsedType!==ZodParsedType.set)return addIssueToContext(vt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.set,received:vt.parsedType}),INVALID;const wt=this._def;wt.minSize!==null&&vt.data.size<wt.minSize.value&&(addIssueToContext(vt,{code:ZodIssueCode.too_small,minimum:wt.minSize.value,type:"set",inclusive:!0,exact:!1,message:wt.minSize.message}),pt.dirty()),wt.maxSize!==null&&vt.data.size>wt.maxSize.value&&(addIssueToContext(vt,{code:ZodIssueCode.too_big,maximum:wt.maxSize.value,type:"set",inclusive:!0,exact:!1,message:wt.maxSize.message}),pt.dirty());const $t=this._def.valueType;function Tt(Ft){const Ct=new Set;for(const Ht of Ft){if(Ht.status==="aborted")return INVALID;Ht.status==="dirty"&&pt.dirty(),Ct.add(Ht.value)}return{status:pt.value,value:Ct}}const Lt=[...vt.data.values()].map((Ft,Ct)=>$t._parse(new ParseInputLazyPath(vt,Ft,vt.path,Ct)));return vt.common.async?Promise.all(Lt).then(Ft=>Tt(Ft)):Tt(Lt)}min(at,pt){return new ZodSet({...this._def,minSize:{value:at,message:errorUtil.toString(pt)}})}max(at,pt){return new ZodSet({...this._def,maxSize:{value:at,message:errorUtil.toString(pt)}})}size(at,pt){return this.min(at,pt).max(at,pt)}nonempty(at){return this.min(1,at)}}ZodSet.create=(st,at)=>new ZodSet({valueType:st,minSize:null,maxSize:null,typeName:ZodFirstPartyTypeKind.ZodSet,...processCreateParams(at)});class ZodFunction extends ZodType{constructor(){super(...arguments),this.validate=this.implement}_parse(at){const{ctx:pt}=this._processInputParams(at);if(pt.parsedType!==ZodParsedType.function)return addIssueToContext(pt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.function,received:pt.parsedType}),INVALID;function vt(Lt,Ft){return makeIssue({data:Lt,path:pt.path,errorMaps:[pt.common.contextualErrorMap,pt.schemaErrorMap,getErrorMap(),errorMap].filter(Ct=>!!Ct),issueData:{code:ZodIssueCode.invalid_arguments,argumentsError:Ft}})}function wt(Lt,Ft){return makeIssue({data:Lt,path:pt.path,errorMaps:[pt.common.contextualErrorMap,pt.schemaErrorMap,getErrorMap(),errorMap].filter(Ct=>!!Ct),issueData:{code:ZodIssueCode.invalid_return_type,returnTypeError:Ft}})}const $t={errorMap:pt.common.contextualErrorMap},Tt=pt.data;if(this._def.returns instanceof ZodPromise){const Lt=this;return OK(async function(...Ft){const Ct=new ZodError([]),Ht=await Lt._def.args.parseAsync(Ft,$t).catch(qt=>{throw Ct.addIssue(vt(Ft,qt)),Ct}),Gt=await Reflect.apply(Tt,this,Ht);return await Lt._def.returns._def.type.parseAsync(Gt,$t).catch(qt=>{throw Ct.addIssue(wt(Gt,qt)),Ct})})}else{const Lt=this;return OK(function(...Ft){const Ct=Lt._def.args.safeParse(Ft,$t);if(!Ct.success)throw new ZodError([vt(Ft,Ct.error)]);const Ht=Reflect.apply(Tt,this,Ct.data),Gt=Lt._def.returns.safeParse(Ht,$t);if(!Gt.success)throw new ZodError([wt(Ht,Gt.error)]);return Gt.data})}}parameters(){return this._def.args}returnType(){return this._def.returns}args(...at){return new ZodFunction({...this._def,args:ZodTuple.create(at).rest(ZodUnknown.create())})}returns(at){return new ZodFunction({...this._def,returns:at})}implement(at){return this.parse(at)}strictImplement(at){return this.parse(at)}static create(at,pt,vt){return new ZodFunction({args:at||ZodTuple.create([]).rest(ZodUnknown.create()),returns:pt||ZodUnknown.create(),typeName:ZodFirstPartyTypeKind.ZodFunction,...processCreateParams(vt)})}}class ZodLazy extends ZodType{get schema(){return this._def.getter()}_parse(at){const{ctx:pt}=this._processInputParams(at);return this._def.getter()._parse({data:pt.data,path:pt.path,parent:pt})}}ZodLazy.create=(st,at)=>new ZodLazy({getter:st,typeName:ZodFirstPartyTypeKind.ZodLazy,...processCreateParams(at)});class ZodLiteral extends ZodType{_parse(at){if(at.data!==this._def.value){const pt=this._getOrReturnCtx(at);return addIssueToContext(pt,{received:pt.data,code:ZodIssueCode.invalid_literal,expected:this._def.value}),INVALID}return{status:"valid",value:at.data}}get value(){return this._def.value}}ZodLiteral.create=(st,at)=>new ZodLiteral({value:st,typeName:ZodFirstPartyTypeKind.ZodLiteral,...processCreateParams(at)});function createZodEnum(st,at){return new ZodEnum({values:st,typeName:ZodFirstPartyTypeKind.ZodEnum,...processCreateParams(at)})}class ZodEnum extends ZodType{constructor(){super(...arguments),_ZodEnum_cache.set(this,void 0)}_parse(at){if(typeof at.data!="string"){const pt=this._getOrReturnCtx(at),vt=this._def.values;return addIssueToContext(pt,{expected:util.joinValues(vt),received:pt.parsedType,code:ZodIssueCode.invalid_type}),INVALID}if(__classPrivateFieldGet(this,_ZodEnum_cache)||__classPrivateFieldSet(this,_ZodEnum_cache,new Set(this._def.values)),!__classPrivateFieldGet(this,_ZodEnum_cache).has(at.data)){const pt=this._getOrReturnCtx(at),vt=this._def.values;return addIssueToContext(pt,{received:pt.data,code:ZodIssueCode.invalid_enum_value,options:vt}),INVALID}return OK(at.data)}get options(){return this._def.values}get enum(){const at={};for(const pt of this._def.values)at[pt]=pt;return at}get Values(){const at={};for(const pt of this._def.values)at[pt]=pt;return at}get Enum(){const at={};for(const pt of this._def.values)at[pt]=pt;return at}extract(at,pt=this._def){return ZodEnum.create(at,{...this._def,...pt})}exclude(at,pt=this._def){return ZodEnum.create(this.options.filter(vt=>!at.includes(vt)),{...this._def,...pt})}}_ZodEnum_cache=new WeakMap;ZodEnum.create=createZodEnum;class ZodNativeEnum extends ZodType{constructor(){super(...arguments),_ZodNativeEnum_cache.set(this,void 0)}_parse(at){const pt=util.getValidEnumValues(this._def.values),vt=this._getOrReturnCtx(at);if(vt.parsedType!==ZodParsedType.string&&vt.parsedType!==ZodParsedType.number){const wt=util.objectValues(pt);return addIssueToContext(vt,{expected:util.joinValues(wt),received:vt.parsedType,code:ZodIssueCode.invalid_type}),INVALID}if(__classPrivateFieldGet(this,_ZodNativeEnum_cache)||__classPrivateFieldSet(this,_ZodNativeEnum_cache,new Set(util.getValidEnumValues(this._def.values))),!__classPrivateFieldGet(this,_ZodNativeEnum_cache).has(at.data)){const wt=util.objectValues(pt);return addIssueToContext(vt,{received:vt.data,code:ZodIssueCode.invalid_enum_value,options:wt}),INVALID}return OK(at.data)}get enum(){return this._def.values}}_ZodNativeEnum_cache=new WeakMap;ZodNativeEnum.create=(st,at)=>new ZodNativeEnum({values:st,typeName:ZodFirstPartyTypeKind.ZodNativeEnum,...processCreateParams(at)});class ZodPromise extends ZodType{unwrap(){return this._def.type}_parse(at){const{ctx:pt}=this._processInputParams(at);if(pt.parsedType!==ZodParsedType.promise&&pt.common.async===!1)return addIssueToContext(pt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.promise,received:pt.parsedType}),INVALID;const vt=pt.parsedType===ZodParsedType.promise?pt.data:Promise.resolve(pt.data);return OK(vt.then(wt=>this._def.type.parseAsync(wt,{path:pt.path,errorMap:pt.common.contextualErrorMap})))}}ZodPromise.create=(st,at)=>new ZodPromise({type:st,typeName:ZodFirstPartyTypeKind.ZodPromise,...processCreateParams(at)});class ZodEffects extends ZodType{innerType(){return this._def.schema}sourceType(){return this._def.schema._def.typeName===ZodFirstPartyTypeKind.ZodEffects?this._def.schema.sourceType():this._def.schema}_parse(at){const{status:pt,ctx:vt}=this._processInputParams(at),wt=this._def.effect||null,$t={addIssue:Tt=>{addIssueToContext(vt,Tt),Tt.fatal?pt.abort():pt.dirty()},get path(){return vt.path}};if($t.addIssue=$t.addIssue.bind($t),wt.type==="preprocess"){const Tt=wt.transform(vt.data,$t);if(vt.common.async)return Promise.resolve(Tt).then(async Lt=>{if(pt.value==="aborted")return INVALID;const Ft=await this._def.schema._parseAsync({data:Lt,path:vt.path,parent:vt});return Ft.status==="aborted"?INVALID:Ft.status==="dirty"||pt.value==="dirty"?DIRTY(Ft.value):Ft});{if(pt.value==="aborted")return INVALID;const Lt=this._def.schema._parseSync({data:Tt,path:vt.path,parent:vt});return Lt.status==="aborted"?INVALID:Lt.status==="dirty"||pt.value==="dirty"?DIRTY(Lt.value):Lt}}if(wt.type==="refinement"){const Tt=Lt=>{const Ft=wt.refinement(Lt,$t);if(vt.common.async)return Promise.resolve(Ft);if(Ft instanceof Promise)throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");return Lt};if(vt.common.async===!1){const Lt=this._def.schema._parseSync({data:vt.data,path:vt.path,parent:vt});return Lt.status==="aborted"?INVALID:(Lt.status==="dirty"&&pt.dirty(),Tt(Lt.value),{status:pt.value,value:Lt.value})}else return this._def.schema._parseAsync({data:vt.data,path:vt.path,parent:vt}).then(Lt=>Lt.status==="aborted"?INVALID:(Lt.status==="dirty"&&pt.dirty(),Tt(Lt.value).then(()=>({status:pt.value,value:Lt.value}))))}if(wt.type==="transform")if(vt.common.async===!1){const Tt=this._def.schema._parseSync({data:vt.data,path:vt.path,parent:vt});if(!isValid(Tt))return Tt;const Lt=wt.transform(Tt.value,$t);if(Lt instanceof Promise)throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");return{status:pt.value,value:Lt}}else return this._def.schema._parseAsync({data:vt.data,path:vt.path,parent:vt}).then(Tt=>isValid(Tt)?Promise.resolve(wt.transform(Tt.value,$t)).then(Lt=>({status:pt.value,value:Lt})):Tt);util.assertNever(wt)}}ZodEffects.create=(st,at,pt)=>new ZodEffects({schema:st,typeName:ZodFirstPartyTypeKind.ZodEffects,effect:at,...processCreateParams(pt)});ZodEffects.createWithPreprocess=(st,at,pt)=>new ZodEffects({schema:at,effect:{type:"preprocess",transform:st},typeName:ZodFirstPartyTypeKind.ZodEffects,...processCreateParams(pt)});class ZodOptional extends ZodType{_parse(at){return this._getType(at)===ZodParsedType.undefined?OK(void 0):this._def.innerType._parse(at)}unwrap(){return this._def.innerType}}ZodOptional.create=(st,at)=>new ZodOptional({innerType:st,typeName:ZodFirstPartyTypeKind.ZodOptional,...processCreateParams(at)});class ZodNullable extends ZodType{_parse(at){return this._getType(at)===ZodParsedType.null?OK(null):this._def.innerType._parse(at)}unwrap(){return this._def.innerType}}ZodNullable.create=(st,at)=>new ZodNullable({innerType:st,typeName:ZodFirstPartyTypeKind.ZodNullable,...processCreateParams(at)});class ZodDefault extends ZodType{_parse(at){const{ctx:pt}=this._processInputParams(at);let vt=pt.data;return pt.parsedType===ZodParsedType.undefined&&(vt=this._def.defaultValue()),this._def.innerType._parse({data:vt,path:pt.path,parent:pt})}removeDefault(){return this._def.innerType}}ZodDefault.create=(st,at)=>new ZodDefault({innerType:st,typeName:ZodFirstPartyTypeKind.ZodDefault,defaultValue:typeof at.default=="function"?at.default:()=>at.default,...processCreateParams(at)});class ZodCatch extends ZodType{_parse(at){const{ctx:pt}=this._processInputParams(at),vt={...pt,common:{...pt.common,issues:[]}},wt=this._def.innerType._parse({data:vt.data,path:vt.path,parent:{...vt}});return isAsync(wt)?wt.then($t=>({status:"valid",value:$t.status==="valid"?$t.value:this._def.catchValue({get error(){return new ZodError(vt.common.issues)},input:vt.data})})):{status:"valid",value:wt.status==="valid"?wt.value:this._def.catchValue({get error(){return new ZodError(vt.common.issues)},input:vt.data})}}removeCatch(){return this._def.innerType}}ZodCatch.create=(st,at)=>new ZodCatch({innerType:st,typeName:ZodFirstPartyTypeKind.ZodCatch,catchValue:typeof at.catch=="function"?at.catch:()=>at.catch,...processCreateParams(at)});class ZodNaN extends ZodType{_parse(at){if(this._getType(at)!==ZodParsedType.nan){const vt=this._getOrReturnCtx(at);return addIssueToContext(vt,{code:ZodIssueCode.invalid_type,expected:ZodParsedType.nan,received:vt.parsedType}),INVALID}return{status:"valid",value:at.data}}}ZodNaN.create=st=>new ZodNaN({typeName:ZodFirstPartyTypeKind.ZodNaN,...processCreateParams(st)});const BRAND=Symbol("zod_brand");class ZodBranded extends ZodType{_parse(at){const{ctx:pt}=this._processInputParams(at),vt=pt.data;return this._def.type._parse({data:vt,path:pt.path,parent:pt})}unwrap(){return this._def.type}}class ZodPipeline extends ZodType{_parse(at){const{status:pt,ctx:vt}=this._processInputParams(at);if(vt.common.async)return(async()=>{const $t=await this._def.in._parseAsync({data:vt.data,path:vt.path,parent:vt});return $t.status==="aborted"?INVALID:$t.status==="dirty"?(pt.dirty(),DIRTY($t.value)):this._def.out._parseAsync({data:$t.value,path:vt.path,parent:vt})})();{const wt=this._def.in._parseSync({data:vt.data,path:vt.path,parent:vt});return wt.status==="aborted"?INVALID:wt.status==="dirty"?(pt.dirty(),{status:"dirty",value:wt.value}):this._def.out._parseSync({data:wt.value,path:vt.path,parent:vt})}}static create(at,pt){return new ZodPipeline({in:at,out:pt,typeName:ZodFirstPartyTypeKind.ZodPipeline})}}class ZodReadonly extends ZodType{_parse(at){const pt=this._def.innerType._parse(at),vt=wt=>(isValid(wt)&&(wt.value=Object.freeze(wt.value)),wt);return isAsync(pt)?pt.then(wt=>vt(wt)):vt(pt)}unwrap(){return this._def.innerType}}ZodReadonly.create=(st,at)=>new ZodReadonly({innerType:st,typeName:ZodFirstPartyTypeKind.ZodReadonly,...processCreateParams(at)});function custom(st,at={},pt){return st?ZodAny.create().superRefine((vt,wt)=>{var $t,Tt;if(!st(vt)){const Lt=typeof at=="function"?at(vt):typeof at=="string"?{message:at}:at,Ft=(Tt=($t=Lt.fatal)!==null&&$t!==void 0?$t:pt)!==null&&Tt!==void 0?Tt:!0,Ct=typeof Lt=="string"?{message:Lt}:Lt;wt.addIssue({code:"custom",...Ct,fatal:Ft})}}):ZodAny.create()}const late={object:ZodObject.lazycreate};var ZodFirstPartyTypeKind;(function(st){st.ZodString="ZodString",st.ZodNumber="ZodNumber",st.ZodNaN="ZodNaN",st.ZodBigInt="ZodBigInt",st.ZodBoolean="ZodBoolean",st.ZodDate="ZodDate",st.ZodSymbol="ZodSymbol",st.ZodUndefined="ZodUndefined",st.ZodNull="ZodNull",st.ZodAny="ZodAny",st.ZodUnknown="ZodUnknown",st.ZodNever="ZodNever",st.ZodVoid="ZodVoid",st.ZodArray="ZodArray",st.ZodObject="ZodObject",st.ZodUnion="ZodUnion",st.ZodDiscriminatedUnion="ZodDiscriminatedUnion",st.ZodIntersection="ZodIntersection",st.ZodTuple="ZodTuple",st.ZodRecord="ZodRecord",st.ZodMap="ZodMap",st.ZodSet="ZodSet",st.ZodFunction="ZodFunction",st.ZodLazy="ZodLazy",st.ZodLiteral="ZodLiteral",st.ZodEnum="ZodEnum",st.ZodEffects="ZodEffects",st.ZodNativeEnum="ZodNativeEnum",st.ZodOptional="ZodOptional",st.ZodNullable="ZodNullable",st.ZodDefault="ZodDefault",st.ZodCatch="ZodCatch",st.ZodPromise="ZodPromise",st.ZodBranded="ZodBranded",st.ZodPipeline="ZodPipeline",st.ZodReadonly="ZodReadonly"})(ZodFirstPartyTypeKind||(ZodFirstPartyTypeKind={}));const instanceOfType=(st,at={message:`Input not instance of ${st.name}`})=>custom(pt=>pt instanceof st,at),stringType=ZodString.create,numberType=ZodNumber.create,nanType=ZodNaN.create,bigIntType=ZodBigInt.create,booleanType=ZodBoolean.create,dateType=ZodDate.create,symbolType=ZodSymbol.create,undefinedType=ZodUndefined.create,nullType=ZodNull.create,anyType=ZodAny.create,unknownType=ZodUnknown.create,neverType=ZodNever.create,voidType=ZodVoid.create,arrayType=ZodArray.create,objectType=ZodObject.create,strictObjectType=ZodObject.strictCreate,unionType=ZodUnion.create,discriminatedUnionType=ZodDiscriminatedUnion.create,intersectionType=ZodIntersection.create,tupleType=ZodTuple.create,recordType=ZodRecord.create,mapType=ZodMap.create,setType=ZodSet.create,functionType=ZodFunction.create,lazyType=ZodLazy.create,literalType=ZodLiteral.create,enumType=ZodEnum.create,nativeEnumType=ZodNativeEnum.create,promiseType=ZodPromise.create,effectsType=ZodEffects.create,optionalType=ZodOptional.create,nullableType=ZodNullable.create,preprocessType=ZodEffects.createWithPreprocess,pipelineType=ZodPipeline.create,ostring=()=>stringType().optional(),onumber=()=>numberType().optional(),oboolean=()=>booleanType().optional(),coerce={string:st=>ZodString.create({...st,coerce:!0}),number:st=>ZodNumber.create({...st,coerce:!0}),boolean:st=>ZodBoolean.create({...st,coerce:!0}),bigint:st=>ZodBigInt.create({...st,coerce:!0}),date:st=>ZodDate.create({...st,coerce:!0})},NEVER=INVALID;var z=Object.freeze({__proto__:null,defaultErrorMap:errorMap,setErrorMap,getErrorMap,makeIssue,EMPTY_PATH,addIssueToContext,ParseStatus,INVALID,DIRTY,OK,isAborted,isDirty,isValid,isAsync,get util(){return util},get objectUtil(){return objectUtil},ZodParsedType,getParsedType,ZodType,datetimeRegex,ZodString,ZodNumber,ZodBigInt,ZodBoolean,ZodDate,ZodSymbol,ZodUndefined,ZodNull,ZodAny,ZodUnknown,ZodNever,ZodVoid,ZodArray,ZodObject,ZodUnion,ZodDiscriminatedUnion,ZodIntersection,ZodTuple,ZodRecord,ZodMap,ZodSet,ZodFunction,ZodLazy,ZodLiteral,ZodEnum,ZodNativeEnum,ZodPromise,ZodEffects,ZodTransformer:ZodEffects,ZodOptional,ZodNullable,ZodDefault,ZodCatch,ZodNaN,BRAND,ZodBranded,ZodPipeline,ZodReadonly,custom,Schema:ZodType,ZodSchema:ZodType,late,get ZodFirstPartyTypeKind(){return ZodFirstPartyTypeKind},coerce,any:anyType,array:arrayType,bigint:bigIntType,boolean:booleanType,date:dateType,discriminatedUnion:discriminatedUnionType,effect:effectsType,enum:enumType,function:functionType,instanceof:instanceOfType,intersection:intersectionType,lazy:lazyType,literal:literalType,map:mapType,nan:nanType,nativeEnum:nativeEnumType,never:neverType,null:nullType,nullable:nullableType,number:numberType,object:objectType,oboolean,onumber,optional:optionalType,ostring,pipeline:pipelineType,preprocess:preprocessType,promise:promiseType,record:recordType,set:setType,strictObject:strictObjectType,string:stringType,symbol:symbolType,transformer:effectsType,tuple:tupleType,undefined:undefinedType,union:unionType,unknown:unknownType,void:voidType,NEVER,ZodIssueCode,quotelessJson,ZodError}),__create=Object.create,__defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty,__commonJS=(st,at)=>function(){return at||(0,st[__getOwnPropNames(st)[0]])((at={exports:{}}).exports,at),at.exports},__copyProps=(st,at,pt,vt)=>{if(at&&typeof at=="object"||typeof at=="function")for(let wt of __getOwnPropNames(at))!__hasOwnProp.call(st,wt)&&wt!==pt&&__defProp(st,wt,{get:()=>at[wt],enumerable:!(vt=__getOwnPropDesc(at,wt))||vt.enumerable});return st},__toESM=(st,at,pt)=>(pt=st!=null?__create(__getProtoOf(st)):{},__copyProps(!st||!st.__esModule?__defProp(pt,"default",{value:st,enumerable:!0}):pt,st)),require_lodash=__commonJS({"../../node_modules/lodash/lodash.js"(st,at){(function(){var pt,vt="4.17.21",wt=200,$t="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",Tt="Expected a function",Lt="Invalid `variable` option passed into `_.template`",Ft="__lodash_hash_undefined__",Ct=500,Ht="__lodash_placeholder__",Gt=1,jt=2,qt=4,Kt=1,An=2,Sn=1,wn=2,In=4,tr=8,rr=16,Hr=32,qr=64,Zr=128,Bo=256,Xo=512,Kr=30,ko="...",f0=800,x0=16,l0=1,T0=2,t0=3,E0=1/0,n0=9007199254740991,m0=17976931348623157e292,h0=NaN,a0=4294967295,P0=a0-1,V0=a0>>>1,B0=[["ary",Zr],["bind",Sn],["bindKey",wn],["curry",tr],["curryRight",rr],["flip",Xo],["partial",Hr],["partialRight",qr],["rearg",Bo]],W0="[object Arguments]",K0="[object Array]",Ty="[object AsyncFunction]",$y="[object Boolean]",My="[object Date]",Wy="[object DOMException]",Ey="[object Error]",_0="[object Function]",ay="[object GeneratorFunction]",J0="[object Map]",yy="[object Number]",uy="[object Null]",Dy="[object Object]",Fy="[object Promise]",qy="[object Proxy]",rv="[object RegExp]",y0="[object Set]",r0="[object String]",M0="[object Symbol]",G0="[object Undefined]",sy="[object WeakMap]",dy="[object WeakSet]",Vy="[object ArrayBuffer]",Xy="[object DataView]",hy="[object Float32Array]",Ly="[object Float64Array]",Py="[object Int8Array]",Sy="[object Int16Array]",Ev="[object Int32Array]",Qy="[object Uint8Array]",cy="[object Uint8ClampedArray]",C0="[object Uint16Array]",U0="[object Uint32Array]",xy=/\b__p \+= '';/g,o0=/\b(__p \+=) '' \+/g,v0=/(__e\(.*?\)|\b__t\)) \+\n'';/g,i0=/&(?:amp|lt|gt|quot|#39);/g,k0=/[&<>"']/g,$0=RegExp(i0.source),ty=RegExp(k0.source),my=/<%-([\s\S]+?)%>/g,ev=/<%([\s\S]+?)%>/g,vv=/<%=([\s\S]+?)%>/g,Tv=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Rv=/^\w*$/,Lv=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,Yv=/[\\^$.*+?()[\]{}|]/g,X0=RegExp(Yv.source),Pv=/^\s+/,Fv=/\s/,Jv=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,g1=/\{\n\/\* \[wrapped with (.+)\] \*/,_v=/,? & /,Y1=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,c_=/[()=,{}\[\]\/\s]/,Qo=/\\(\\)?/g,c0=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,D0=/\w*$/,Go=/^[-+]0x[0-9a-f]+$/i,g0=/^0b[01]+$/i,b0=/^\[object .+?Constructor\]$/,I0=/^0o[0-7]+$/i,A0=/^(?:0|[1-9]\d*)$/,Y0=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,ey=/($^)/,ny=/['\n\r\u2028\u2029\\]/g,ry="\\ud800-\\udfff",Ky="\\u0300-\\u036f",wy="\\ufe20-\\ufe2f",Ry="\\u20d0-\\u20ff",Hy=Ky+wy+Ry,uv="\\u2700-\\u27bf",dv="a-z\\xdf-\\xf6\\xf8-\\xff",pv="\\xac\\xb1\\xd7\\xf7",Zy="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",By="\\u2000-\\u206f",bv=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",fv="A-Z\\xc0-\\xd6\\xd8-\\xde",xv="\\ufe0e\\ufe0f",t1=pv+Zy+By+bv,u1="[']",c1="["+ry+"]",Gv="["+t1+"]",Ov="["+Hy+"]",jy="\\d+",Av="["+uv+"]",zy="["+dv+"]",n1="[^"+ry+t1+jy+uv+dv+fv+"]",m1="\\ud83c[\\udffb-\\udfff]",i1="(?:"+Ov+"|"+m1+")",S1="[^"+ry+"]",J1="(?:\\ud83c[\\udde6-\\uddff]){2}",d_="[\\ud800-\\udbff][\\udc00-\\udfff]",x1="["+fv+"]",m_="\\u200d",z1="(?:"+zy+"|"+n1+")",j1="(?:"+x1+"|"+n1+")",g_="(?:"+u1+"(?:d|ll|m|re|s|t|ve))?",q1="(?:"+u1+"(?:D|LL|M|RE|S|T|VE))?",No=i1+"?",ir="["+xv+"]?",jr="(?:"+m_+"(?:"+[S1,J1,d_].join("|")+")"+ir+No+")*",Ro="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",_g="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",d0=ir+No+jr,L0="(?:"+[Av,J1,d_].join("|")+")"+d0,by="(?:"+[S1+Ov+"?",Ov,J1,d_,c1].join("|")+")",ky=RegExp(u1,"g"),Oy=RegExp(Ov,"g"),Uy=RegExp(m1+"(?="+m1+")|"+by+d0,"g"),hv=RegExp([x1+"?"+zy+"+"+g_+"(?="+[Gv,x1,"$"].join("|")+")",j1+"+"+q1+"(?="+[Gv,x1+z1,"$"].join("|")+")",x1+"?"+z1+"+"+g_,x1+"+"+q1,_g,Ro,jy,L0].join("|"),"g"),Hv=RegExp("["+m_+ry+Hy+xv+"]"),Q0=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,q0=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],Yy=-1,av={};av[hy]=av[Ly]=av[Py]=av[Sy]=av[Ev]=av[Qy]=av[cy]=av[C0]=av[U0]=!0,av[W0]=av[K0]=av[Vy]=av[$y]=av[Xy]=av[My]=av[Ey]=av[_0]=av[J0]=av[yy]=av[Dy]=av[rv]=av[y0]=av[r0]=av[sy]=!1;var Zv={};Zv[W0]=Zv[K0]=Zv[Vy]=Zv[Xy]=Zv[$y]=Zv[My]=Zv[hy]=Zv[Ly]=Zv[Py]=Zv[Sy]=Zv[Ev]=Zv[J0]=Zv[yy]=Zv[Dy]=Zv[rv]=Zv[y0]=Zv[r0]=Zv[M0]=Zv[Qy]=Zv[cy]=Zv[C0]=Zv[U0]=!0,Zv[Ey]=Zv[_0]=Zv[sy]=!1;var M1={:"A",:"A",:"A",:"A",:"A",:"A",:"a",:"a",:"a",:"a",:"a",:"a",:"C",:"c",:"D",:"d",:"E",:"E",:"E",:"E",:"e",:"e",:"e",:"e",:"I",:"I",:"I",:"I",:"i",:"i",:"i",:"i",:"N",:"n",:"O",:"O",:"O",:"O",:"O",:"O",:"o",:"o",:"o",:"o",:"o",:"o",:"U",:"U",:"U",:"U",:"u",:"u",:"u",:"u",:"Y",:"y",:"y",:"Ae",:"ae",:"Th",:"th",:"ss",:"A",:"A",:"A",:"a",:"a",:"a",:"C",:"C",:"C",:"C",:"c",:"c",:"c",:"c",:"D",:"D",:"d",:"d",:"E",:"E",:"E",:"E",:"E",:"e",:"e",:"e",:"e",:"e",:"G",:"G",:"G",:"G",:"g",:"g",:"g",:"g",:"H",:"H",:"h",:"h",:"I",:"I",:"I",:"I",:"I",:"i",:"i",:"i",:"i",:"i",:"J",:"j",:"K",:"k",:"k",:"L",:"L",:"L",:"L",:"L",:"l",:"l",:"l",:"l",:"l",:"N",:"N",:"N",:"N",:"n",:"n",:"n",:"n",:"O",:"O",:"O",:"o",:"o",:"o",:"R",:"R",:"R",:"r",:"r",:"r",:"S",:"S",:"S",:"S",:"s",:"s",:"s",:"s",:"T",:"T",:"T",:"t",:"t",:"t",:"U",:"U",:"U",:"U",:"U",:"U",:"u",:"u",:"u",:"u",:"u",:"u",:"W",:"w",:"Y",:"y",:"Y",:"Z",:"Z",:"Z",:"z",:"z",:"z",:"IJ",:"ij",:"Oe",:"oe",:"'n",:"s"},R_={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},Gx={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},sw={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Ow=parseFloat,Dw=parseInt,y_=typeof global=="object"&&global&&global.Object===Object&&global,Bw=typeof self=="object"&&self&&self.Object===Object&&self,_1=y_||Bw||Function("return this")(),Vx=typeof st=="object"&&st&&!st.nodeType&&st,I1=Vx&&typeof at=="object"&&at&&!at.nodeType&&at,wx=I1&&I1.exports===Vx,cx=wx&&y_.process,R1=function(){try{var F0=I1&&I1.require&&I1.require("util").types;return F0||cx&&cx.binding&&cx.binding("util")}catch{}}(),Hx=R1&&R1.isArrayBuffer,lw=R1&&R1.isDate,uw=R1&&R1.isMap,Wx=R1&&R1.isRegExp,jx=R1&&R1.isSet,dx=R1&&R1.isTypedArray;function y1(F0,vy,oy){switch(oy.length){case 0:return F0.call(vy);case 1:return F0.call(vy,oy[0]);case 2:return F0.call(vy,oy[0],oy[1]);case 3:return F0.call(vy,oy[0],oy[1],oy[2])}return F0.apply(vy,oy)}function x_(F0,vy,oy,lv){for(var Nv=-1,Vv=F0==null?0:F0.length;++Nv<Vv;){var b1=F0[Nv];vy(lv,b1,oy(b1),F0)}return lv}function w1(F0,vy){for(var oy=-1,lv=F0==null?0:F0.length;++oy<lv&&vy(F0[oy],oy,F0)!==!1;);return F0}function $x(F0,vy){for(var oy=F0==null?0:F0.length;oy--&&vy(F0[oy],oy,F0)!==!1;);return F0}function kw(F0,vy){for(var oy=-1,lv=F0==null?0:F0.length;++oy<lv;)if(!vy(F0[oy],oy,F0))return!1;return!0}function G1(F0,vy){for(var oy=-1,lv=F0==null?0:F0.length,Nv=0,Vv=[];++oy<lv;){var b1=F0[oy];vy(b1,oy,F0)&&(Vv[Nv++]=b1)}return Vv}function ov(F0,vy){var oy=F0==null?0:F0.length;return!!oy&&p_(F0,vy,0)>-1}function fx(F0,vy,oy){for(var lv=-1,Nv=F0==null?0:F0.length;++lv<Nv;)if(oy(vy,F0[lv]))return!0;return!1}function f1(F0,vy){for(var oy=-1,lv=F0==null?0:F0.length,Nv=Array(lv);++oy<lv;)Nv[oy]=vy(F0[oy],oy,F0);return Nv}function Q1(F0,vy){for(var oy=-1,lv=vy.length,Nv=F0.length;++oy<lv;)F0[Nv+oy]=vy[oy];return F0}function f_(F0,vy,oy,lv){var Nv=-1,Vv=F0==null?0:F0.length;for(lv&&Vv&&(oy=F0[++Nv]);++Nv<Vv;)oy=vy(oy,F0[Nv],Nv,F0);return oy}function Lw(F0,vy,oy,lv){var Nv=F0==null?0:F0.length;for(lv&&Nv&&(oy=F0[--Nv]);Nv--;)oy=vy(oy,F0[Nv],Nv,F0);return oy}function Sx(F0,vy){for(var oy=-1,lv=F0==null?0:F0.length;++oy<lv;)if(vy(F0[oy],oy,F0))return!0;return!1}var Ex=K1("length");function cw(F0){return F0.split("")}function Nw(F0){return F0.match(Y1)||[]}function dw(F0,vy,oy){var lv;return oy(F0,function(Nv,Vv,b1){if(vy(Nv,Vv,b1))return lv=Vv,!1}),lv}function U_(F0,vy,oy,lv){for(var Nv=F0.length,Vv=oy+(lv?1:-1);lv?Vv--:++Vv<Nv;)if(vy(F0[Vv],Vv,F0))return Vv;return-1}function p_(F0,vy,oy){return vy===vy?fw(F0,vy,oy):U_(F0,Tx,oy)}function Y_(F0,vy,oy,lv){for(var Nv=oy-1,Vv=F0.length;++Nv<Vv;)if(lv(F0[Nv],vy))return Nv;return-1}function Tx(F0){return F0!==F0}function Ax(F0,vy){var oy=F0==null?0:F0.length;return oy?e_(F0,vy)/oy:h0}function K1(F0){return function(vy){return vy==null?pt:vy[F0]}}function Z1(F0){return function(vy){return F0==null?pt:F0[vy]}}function z_(F0,vy,oy,lv,Nv){return Nv(F0,function(Vv,b1,Dv){oy=lv?(lv=!1,Vv):vy(oy,Vv,b1,Dv)}),oy}function G_(F0,vy){var oy=F0.length;for(F0.sort(vy);oy--;)F0[oy]=F0[oy].value;return F0}function e_(F0,vy){for(var oy,lv=-1,Nv=F0.length;++lv<Nv;){var Vv=vy(F0[lv]);Vv!==pt&&(oy=oy===pt?Vv:oy+Vv)}return oy}function P_(F0,vy){for(var oy=-1,lv=Array(F0);++oy<F0;)lv[oy]=vy(oy);return lv}function Ir(F0,vy){return f1(vy,function(oy){return[oy,F0[oy]]})}function Yr(F0){return F0&&F0.slice(0,pw(F0)+1).replace(Pv,"")}function zo(F0){return function(vy){return F0(vy)}}function s0(F0,vy){return f1(vy,function(oy){return F0[oy]})}function w0(F0,vy){return F0.has(vy)}function O0(F0,vy){for(var oy=-1,lv=F0.length;++oy<lv&&p_(vy,F0[oy],0)>-1;);return oy}function fy(F0,vy){for(var oy=F0.length;oy--&&p_(vy,F0[oy],0)>-1;);return oy}function Iy(F0,vy){for(var oy=F0.length,lv=0;oy--;)F0[oy]===vy&&++lv;return lv}var sv=Z1(M1),Jy=Z1(R_);function wv(F0){return"\\"+sw[F0]}function a1(F0,vy){return F0==null?pt:F0[vy]}function r1(F0){return Hv.test(F0)}function iy(F0){return Q0.test(F0)}function Mv(F0){for(var vy,oy=[];!(vy=F0.next()).done;)oy.push(vy.value);return oy}function Qv(F0){var vy=-1,oy=Array(F0.size);return F0.forEach(function(lv,Nv){oy[++vy]=[Nv,lv]}),oy}function v_(F0,vy){return function(oy){return F0(vy(oy))}}function __(F0,vy){for(var oy=-1,lv=F0.length,Nv=0,Vv=[];++oy<lv;){var b1=F0[oy];(b1===vy||b1===Ht)&&(F0[oy]=Ht,Vv[Nv++]=oy)}return Vv}function Fw(F0){var vy=-1,oy=Array(F0.size);return F0.forEach(function(lv){oy[++vy]=lv}),oy}function w$(F0){var vy=-1,oy=Array(F0.size);return F0.forEach(function(lv){oy[++vy]=[lv,lv]}),oy}function fw(F0,vy,oy){for(var lv=oy-1,Nv=F0.length;++lv<Nv;)if(F0[lv]===vy)return lv;return-1}function $$(F0,vy,oy){for(var lv=oy+1;lv--;)if(F0[lv]===vy)return lv;return lv}function J_(F0){return r1(F0)?Q_(F0):Ex(F0)}function $1(F0){return r1(F0)?k2(F0):cw(F0)}function pw(F0){for(var vy=F0.length;vy--&&Fv.test(F0.charAt(vy)););return vy}var hw=Z1(Gx);function Q_(F0){for(var vy=Uy.lastIndex=0;Uy.test(F0);)++vy;return vy}function k2(F0){return F0.match(Uy)||[]}function mw(F0){return F0.match(hv)||[]}var S$=function F0(vy){vy=vy==null?_1:ex.defaults(_1.Object(),vy,ex.pick(_1,q0));var oy=vy.Array,lv=vy.Date,Nv=vy.Error,Vv=vy.Function,b1=vy.Math,Dv=vy.Object,V1=vy.RegExp,H1=vy.String,h_=vy.TypeError,Cx=oy.prototype,Uw=Vv.prototype,gw=Dv.prototype,k1=vy["__core-js_shared__"],yw=Uw.toString,d1=gw.hasOwnProperty,L2=0,tx=function(){var vn=/[^.]+$/.exec(k1&&k1.keys&&k1.keys.IE_PROTO||"");return vn?"Symbol(src)_1."+vn:""}(),w_=gw.toString,qx=yw.call(Dv),d2=_1._,f2=V1("^"+yw.call(d1).replace(Yv,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),zw=wx?vy.Buffer:pt,hx=vy.Symbol,Gw=vy.Uint8Array,N2=zw?zw.allocUnsafe:pt,Vw=v_(Dv.getPrototypeOf,Dv),F2=Dv.create,p2=gw.propertyIsEnumerable,Mx=Cx.splice,U2=hx?hx.isConcatSpreadable:pt,Ix=hx?hx.iterator:pt,nx=hx?hx.toStringTag:pt,vw=function(){try{var vn=l2(Dv,"defineProperty");return vn({},"",{}),vn}catch{}}(),Hw=vy.clearTimeout!==_1.clearTimeout&&vy.clearTimeout,E$=lv&&lv.now!==_1.Date.now&&lv.now,T$=vy.setTimeout!==_1.setTimeout&&vy.setTimeout,Ww=b1.ceil,jw=b1.floor,qw=Dv.getOwnPropertySymbols,A$=zw?zw.isBuffer:pt,z2=vy.isFinite,_S=Cx.join,C$=v_(Dv.keys,Dv),L1=b1.max,t_=b1.min,M$=lv.now,I$=vy.parseInt,G2=b1.random,R$=Cx.reverse,_w=l2(vy,"DataView"),Kw=l2(vy,"Map"),V2=l2(vy,"Promise"),bw=l2(vy,"Set"),Kx=l2(vy,"WeakMap"),Zx=l2(Dv,"create"),h2=Kx&&new Kx,Xx={},P$=u2(_w),O$=u2(Kw),D$=u2(V2),B$=u2(bw),rx=u2(Kx),Zw=hx?hx.prototype:pt,mx=Zw?Zw.valueOf:pt,xw=Zw?Zw.toString:pt;function u0(vn){if(B1(vn)&&!Wv(vn)&&!(vn instanceof Cv)){if(vn instanceof n_)return vn;if(d1.call(vn,"__wrapped__"))return dE(vn)}return new n_(vn)}var gx=function(){function vn(){}return function(Tn){if(!C1(Tn))return{};if(F2)return F2(Tn);vn.prototype=Tn;var or=new vn;return vn.prototype=pt,or}}();function Xw(){}function n_(vn,Tn){this.__wrapped__=vn,this.__actions__=[],this.__chain__=!!Tn,this.__index__=0,this.__values__=pt}u0.templateSettings={escape:my,evaluate:ev,interpolate:vv,variable:"",imports:{_:u0}},u0.prototype=Xw.prototype,u0.prototype.constructor=u0,n_.prototype=gx(Xw.prototype),n_.prototype.constructor=n_;function Cv(vn){this.__wrapped__=vn,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=a0,this.__views__=[]}function bS(){var vn=new Cv(this.__wrapped__);return vn.__actions__=s_(this.__actions__),vn.__dir__=this.__dir__,vn.__filtered__=this.__filtered__,vn.__iteratees__=s_(this.__iteratees__),vn.__takeCount__=this.__takeCount__,vn.__views__=s_(this.__views__),vn}function xS(){if(this.__filtered__){var vn=new Cv(this);vn.__dir__=-1,vn.__filtered__=!0}else vn=this.clone(),vn.__dir__*=-1;return vn}function $_(){var vn=this.__wrapped__.value(),Tn=this.__dir__,or=Wv(vn),Mo=Tn<0,e0=or?vn.length:0,p0=QE(0,e0,this.__views__),R0=p0.start,N0=p0.end,j0=N0-R0,Ay=Mo?N0:R0-1,Cy=this.__iteratees__,Ny=Cy.length,nv=0,yv=t_(j0,this.__takeCount__);if(!or||!Mo&&e0==j0&&yv==j0)return kx(vn,this.__actions__);var Bv=[];e:for(;j0--&&nv<yv;){Ay+=Tn;for(var e1=-1,kv=vn[Ay];++e1<Ny;){var o1=Cy[e1],l1=o1.iteratee,Z_=o1.type,I_=l1(kv);if(Z_==T0)kv=I_;else if(!I_){if(Z_==l0)continue e;break e}}Bv[nv++]=kv}return Bv}Cv.prototype=gx(Xw.prototype),Cv.prototype.constructor=Cv;function E1(vn){var Tn=-1,or=vn==null?0:vn.length;for(this.clear();++Tn<or;){var Mo=vn[Tn];this.set(Mo[0],Mo[1])}}function k$(){this.__data__=Zx?Zx(null):{},this.size=0}function L$(vn){var Tn=this.has(vn)&&delete this.__data__[vn];return this.size-=Tn?1:0,Tn}function N$(vn){var Tn=this.__data__;if(Zx){var or=Tn[vn];return or===Ft?pt:or}return d1.call(Tn,vn)?Tn[vn]:pt}function F$(vn){var Tn=this.__data__;return Zx?Tn[vn]!==pt:d1.call(Tn,vn)}function U$(vn,Tn){var or=this.__data__;return this.size+=this.has(vn)?0:1,or[vn]=Zx&&Tn===pt?Ft:Tn,this}E1.prototype.clear=k$,E1.prototype.delete=L$,E1.prototype.get=N$,E1.prototype.has=F$,E1.prototype.set=U$;function V_(vn){var Tn=-1,or=vn==null?0:vn.length;for(this.clear();++Tn<or;){var Mo=vn[Tn];this.set(Mo[0],Mo[1])}}function z$(){this.__data__=[],this.size=0}function H2(vn){var Tn=this.__data__,or=Px(Tn,vn);if(or<0)return!1;var Mo=Tn.length-1;return or==Mo?Tn.pop():Mx.call(Tn,or,1),--this.size,!0}function G$(vn){var Tn=this.__data__,or=Px(Tn,vn);return or<0?pt:Tn[or][1]}function V$(vn){return Px(this.__data__,vn)>-1}function m2(vn,Tn){var or=this.__data__,Mo=Px(or,vn);return Mo<0?(++this.size,or.push([vn,Tn])):or[Mo][1]=Tn,this}V_.prototype.clear=z$,V_.prototype.delete=H2,V_.prototype.get=G$,V_.prototype.has=V$,V_.prototype.set=m2;function O_(vn){var Tn=-1,or=vn==null?0:vn.length;for(this.clear();++Tn<or;){var Mo=vn[Tn];this.set(Mo[0],Mo[1])}}function H$(){this.size=0,this.__data__={hash:new E1,map:new(Kw||V_),string:new E1}}function W2(vn){var Tn=sS(this,vn).delete(vn);return this.size-=Tn?1:0,Tn}function W$(vn){return sS(this,vn).get(vn)}function j$(vn){return sS(this,vn).has(vn)}function g2(vn,Tn){var or=sS(this,vn),Mo=or.size;return or.set(vn,Tn),this.size+=or.size==Mo?0:1,this}O_.prototype.clear=H$,O_.prototype.delete=W2,O_.prototype.get=W$,O_.prototype.has=j$,O_.prototype.set=g2;function Rx(vn){var Tn=-1,or=vn==null?0:vn.length;for(this.__data__=new O_;++Tn<or;)this.add(vn[Tn])}function j2(vn){return this.__data__.set(vn,Ft),this}function q$(vn){return this.__data__.has(vn)}Rx.prototype.add=Rx.prototype.push=j2,Rx.prototype.has=q$;function N1(vn){var Tn=this.__data__=new V_(vn);this.size=Tn.size}function wS(){this.__data__=new V_,this.size=0}function $S(vn){var Tn=this.__data__,or=Tn.delete(vn);return this.size=Tn.size,or}function y2(vn){return this.__data__.get(vn)}function Yx(vn){return this.__data__.has(vn)}function SS(vn,Tn){var or=this.__data__;if(or instanceof V_){var Mo=or.__data__;if(!Kw||Mo.length<wt-1)return Mo.push([vn,Tn]),this.size=++or.size,this;or=this.__data__=new O_(Mo)}return or.set(vn,Tn),this.size=or.size,this}N1.prototype.clear=wS,N1.prototype.delete=$S,N1.prototype.get=y2,N1.prototype.has=Yx,N1.prototype.set=SS;function tv(vn,Tn){var or=Wv(vn),Mo=!or&&c2(vn),e0=!or&&!Mo&&Rw(vn),p0=!or&&!Mo&&!e0&&D2(vn),R0=or||Mo||e0||p0,N0=R0?P_(vn.length,H1):[],j0=N0.length;for(var Ay in vn)(Tn||d1.call(vn,Ay))&&!(R0&&(Ay=="length"||e0&&(Ay=="offset"||Ay=="parent")||p0&&(Ay=="buffer"||Ay=="byteLength"||Ay=="byteOffset")||rw(Ay,j0)))&&N0.push(Ay);return N0}function Yw(vn){var Tn=vn.length;return Tn?vn[ox(0,Tn-1)]:pt}function q2(vn,Tn){return lS(s_(vn),Ox(Tn,0,vn.length))}function K$(vn){return lS(s_(vn))}function K2(vn,Tn,or){(or!==pt&&!bx(vn[Tn],or)||or===pt&&!(Tn in vn))&&ix(vn,Tn,or)}function H_(vn,Tn,or){var Mo=vn[Tn];(!(d1.call(vn,Tn)&&bx(Mo,or))||or===pt&&!(Tn in vn))&&ix(vn,Tn,or)}function Px(vn,Tn){for(var or=vn.length;or--;)if(bx(vn[or][0],Tn))return or;return-1}function Z2(vn,Tn,or,Mo){return W_(vn,function(e0,p0,R0){Tn(Mo,e0,or(e0),R0)}),Mo}function X2(vn,Tn){return vn&&k_(Tn,u_(Tn),vn)}function Z$(vn,Tn){return vn&&k_(Tn,N_(Tn),vn)}function ix(vn,Tn,or){Tn=="__proto__"&&vw?vw(vn,Tn,{configurable:!0,enumerable:!0,value:or,writable:!0}):vn[Tn]=or}function v2(vn,Tn){for(var or=-1,Mo=Tn.length,e0=oy(Mo),p0=vn==null;++or<Mo;)e0[or]=p0?pt:GS(vn,Tn[or]);return e0}function Ox(vn,Tn,or){return vn===vn&&(or!==pt&&(vn=vn<=or?vn:or),Tn!==pt&&(vn=vn>=Tn?vn:Tn)),vn}function S_(vn,Tn,or,Mo,e0,p0){var R0,N0=Tn&Gt,j0=Tn&jt,Ay=Tn&qt;if(or&&(R0=e0?or(vn,Mo,e0,p0):or(vn)),R0!==pt)return R0;if(!C1(vn))return vn;var Cy=Wv(vn);if(Cy){if(R0=tT(vn),!N0)return s_(vn,R0)}else{var Ny=b_(vn),nv=Ny==_0||Ny==ay;if(Rw(vn))return c$(vn,N0);if(Ny==Dy||Ny==W0||nv&&!e0){if(R0=j0||nv?{}:nE(vn),!N0)return j0?oS(vn,Z$(R0,vn)):CS(vn,X2(R0,vn))}else{if(!Zv[Ny])return e0?vn:{};R0=nT(vn,Ny,N0)}}p0||(p0=new N1);var yv=p0.get(vn);if(yv)return yv;p0.set(vn,R0),RE(vn)?vn.forEach(function(kv){R0.add(S_(kv,Tn,or,kv,vn,p0))}):ME(vn)&&vn.forEach(function(kv,o1){R0.set(o1,S_(kv,Tn,or,o1,vn,p0))});var Bv=Ay?j0?s1:D1:j0?N_:u_,e1=Cy?pt:Bv(vn);return w1(e1||vn,function(kv,o1){e1&&(o1=kv,kv=vn[o1]),H_(R0,o1,S_(kv,Tn,or,o1,vn,p0))}),R0}function Y2(vn){var Tn=u_(vn);return function(or){return _2(or,vn,Tn)}}function _2(vn,Tn,or){var Mo=or.length;if(vn==null)return!Mo;for(vn=Dv(vn);Mo--;){var e0=or[Mo],p0=Tn[e0],R0=vn[e0];if(R0===pt&&!(e0 in vn)||!p0(R0))return!1}return!0}function J2(vn,Tn,or){if(typeof vn!="function")throw new h_(Tt);return m$(function(){vn.apply(pt,or)},Tn)}function Jx(vn,Tn,or,Mo){var e0=-1,p0=ov,R0=!0,N0=vn.length,j0=[],Ay=Tn.length;if(!N0)return j0;or&&(Tn=f1(Tn,zo(or))),Mo?(p0=fx,R0=!1):Tn.length>=wt&&(p0=w0,R0=!1,Tn=new Rx(Tn));e:for(;++e0<N0;){var Cy=vn[e0],Ny=or==null?Cy:or(Cy);if(Cy=Mo||Cy!==0?Cy:0,R0&&Ny===Ny){for(var nv=Ay;nv--;)if(Tn[nv]===Ny)continue e;j0.push(Cy)}else p0(Tn,Ny,Mo)||j0.push(Cy)}return j0}var W_=f$(E_),X$=f$($w,!0);function ES(vn,Tn){var or=!0;return W_(vn,function(Mo,e0,p0){return or=!!Tn(Mo,e0,p0),or}),or}function Jw(vn,Tn,or){for(var Mo=-1,e0=vn.length;++Mo<e0;){var p0=vn[Mo],R0=Tn(p0);if(R0!=null&&(N0===pt?R0===R0&&!K_(R0):or(R0,N0)))var N0=R0,j0=p0}return j0}function Y$(vn,Tn,or,Mo){var e0=vn.length;for(or=Xv(or),or<0&&(or=-or>e0?0:e0+or),Mo=Mo===pt||Mo>e0?e0:Xv(Mo),Mo<0&&(Mo+=e0),Mo=or>Mo?0:OE(Mo);or<Mo;)vn[or++]=Tn;return vn}function Q2(vn,Tn){var or=[];return W_(vn,function(Mo,e0,p0){Tn(Mo,e0,p0)&&or.push(Mo)}),or}function W1(vn,Tn,or,Mo,e0){var p0=-1,R0=vn.length;for(or||(or=iT),e0||(e0=[]);++p0<R0;){var N0=vn[p0];Tn>0&&or(N0)?Tn>1?W1(N0,Tn-1,or,Mo,e0):Q1(e0,N0):Mo||(e0[e0.length]=N0)}return e0}var ww=R2(),Qw=R2(!0);function E_(vn,Tn){return vn&&ww(vn,Tn,u_)}function $w(vn,Tn){return vn&&Qw(vn,Tn,u_)}function Qx(vn,Tn){return G1(Tn,function(or){return iw(vn[or])})}function j_(vn,Tn){Tn=Nx(Tn,vn);for(var or=0,Mo=Tn.length;vn!=null&&or<Mo;)vn=vn[zx(Tn[or++])];return or&&or==Mo?vn:pt}function b2(vn,Tn,or){var Mo=Tn(vn);return Wv(vn)?Mo:Q1(Mo,or(vn))}function X1(vn){return vn==null?vn===pt?G0:uy:nx&&nx in Dv(vn)?JE(vn):dT(vn)}function e2(vn,Tn){return vn>Tn}function J$(vn,Tn){return vn!=null&&d1.call(vn,Tn)}function e$(vn,Tn){return vn!=null&&Tn in Dv(vn)}function TS(vn,Tn,or){return vn>=t_(Tn,or)&&vn<L1(Tn,or)}function Sw(vn,Tn,or){for(var Mo=or?fx:ov,e0=vn[0].length,p0=vn.length,R0=p0,N0=oy(p0),j0=1/0,Ay=[];R0--;){var Cy=vn[R0];R0&&Tn&&(Cy=f1(Cy,zo(Tn))),j0=t_(Cy.length,j0),N0[R0]=!or&&(Tn||e0>=120&&Cy.length>=120)?new Rx(R0&&Cy):pt}Cy=vn[0];var Ny=-1,nv=N0[0];e:for(;++Ny<e0&&Ay.length<j0;){var yv=Cy[Ny],Bv=Tn?Tn(yv):yv;if(yv=or||yv!==0?yv:0,!(nv?w0(nv,Bv):Mo(Ay,Bv,or))){for(R0=p0;--R0;){var e1=N0[R0];if(!(e1?w0(e1,Bv):Mo(vn[R0],Bv,or)))continue e}nv&&nv.push(Bv),Ay.push(yv)}}return Ay}function t$(vn,Tn,or,Mo){return E_(vn,function(e0,p0,R0){Tn(Mo,or(e0),p0,R0)}),Mo}function v1(vn,Tn,or){Tn=Nx(Tn,vn),vn=aE(vn,Tn);var Mo=vn==null?vn:vn[zx(lx(Tn))];return Mo==null?pt:y1(Mo,vn,or)}function jv(vn){return B1(vn)&&X1(vn)==W0}function P1(vn){return B1(vn)&&X1(vn)==Vy}function O1(vn){return B1(vn)&&X1(vn)==My}function T1(vn,Tn,or,Mo,e0){return vn===Tn?!0:vn==null||Tn==null||!B1(vn)&&!B1(Tn)?vn!==vn&&Tn!==Tn:T_(vn,Tn,or,Mo,T1,e0)}function T_(vn,Tn,or,Mo,e0,p0){var R0=Wv(vn),N0=Wv(Tn),j0=R0?K0:b_(vn),Ay=N0?K0:b_(Tn);j0=j0==W0?Dy:j0,Ay=Ay==W0?Dy:Ay;var Cy=j0==Dy,Ny=Ay==Dy,nv=j0==Ay;if(nv&&Rw(vn)){if(!Rw(Tn))return!1;R0=!0,Cy=!1}if(nv&&!Cy)return p0||(p0=new N1),R0||D2(vn)?gv(vn,Tn,or,Mo,e0,p0):qv(vn,Tn,j0,or,Mo,e0,p0);if(!(or&Kt)){var yv=Cy&&d1.call(vn,"__wrapped__"),Bv=Ny&&d1.call(Tn,"__wrapped__");if(yv||Bv){var e1=yv?vn.value():vn,kv=Bv?Tn.value():Tn;return p0||(p0=new N1),e0(e1,kv,or,Mo,p0)}}return nv?(p0||(p0=new N1),zv(vn,Tn,or,Mo,e0,p0)):!1}function Ew(vn){return B1(vn)&&b_(vn)==J0}function A1(vn,Tn,or,Mo){var e0=or.length,p0=e0,R0=!Mo;if(vn==null)return!p0;for(vn=Dv(vn);e0--;){var N0=or[e0];if(R0&&N0[2]?N0[1]!==vn[N0[0]]:!(N0[0]in vn))return!1}for(;++e0<p0;){N0=or[e0];var j0=N0[0],Ay=vn[j0],Cy=N0[1];if(R0&&N0[2]){if(Ay===pt&&!(j0 in vn))return!1}else{var Ny=new N1;if(Mo)var nv=Mo(Ay,Cy,j0,vn,Tn,Ny);if(!(nv===pt?T1(Cy,Ay,Kt|An,Mo,Ny):nv))return!1}}return!0}function Tw(vn){if(!C1(vn)||aT(vn))return!1;var Tn=iw(vn)?f2:b0;return Tn.test(u2(vn))}function Aw(vn){return B1(vn)&&X1(vn)==rv}function x2(vn){return B1(vn)&&b_(vn)==y0}function n$(vn){return B1(vn)&&hS(vn.length)&&!!av[X1(vn)]}function Cw(vn){return typeof vn=="function"?vn:vn==null?F_:typeof vn=="object"?Wv(vn)?w2(vn[0],vn[1]):n2(vn):HE(vn)}function r_(vn){if(!p$(vn))return C$(vn);var Tn=[];for(var or in Dv(vn))d1.call(vn,or)&&or!="constructor"&&Tn.push(or);return Tn}function r$(vn){if(!C1(vn))return cT(vn);var Tn=p$(vn),or=[];for(var Mo in vn)Mo=="constructor"&&(Tn||!d1.call(vn,Mo))||or.push(Mo);return or}function t2(vn,Tn){return vn<Tn}function ew(vn,Tn){var or=-1,Mo=L_(vn)?oy(vn.length):[];return W_(vn,function(e0,p0,R0){Mo[++or]=Tn(e0,p0,R0)}),Mo}function n2(vn){var Tn=IS(vn);return Tn.length==1&&Tn[0][2]?iE(Tn[0][0],Tn[0][1]):function(or){return or===vn||A1(or,vn,Tn)}}function w2(vn,Tn){return PS(vn)&&rE(Tn)?iE(zx(vn),Tn):function(or){var Mo=GS(or,vn);return Mo===pt&&Mo===Tn?VS(or,vn):T1(Tn,Mo,Kt|An)}}function q_(vn,Tn,or,Mo,e0){vn!==Tn&&ww(Tn,function(p0,R0){if(e0||(e0=new N1),C1(p0))$2(vn,Tn,R0,or,q_,Mo,e0);else{var N0=Mo?Mo(DS(vn,R0),p0,R0+"",vn,Tn,e0):pt;N0===pt&&(N0=p0),K2(vn,R0,N0)}},N_)}function $2(vn,Tn,or,Mo,e0,p0,R0){var N0=DS(vn,or),j0=DS(Tn,or),Ay=R0.get(j0);if(Ay){K2(vn,or,Ay);return}var Cy=p0?p0(N0,j0,or+"",vn,Tn,R0):pt,Ny=Cy===pt;if(Ny){var nv=Wv(j0),yv=!nv&&Rw(j0),Bv=!nv&&!yv&&D2(j0);Cy=j0,nv||yv||Bv?Wv(N0)?Cy=N0:F1(N0)?Cy=s_(N0):yv?(Ny=!1,Cy=c$(j0,!0)):Bv?(Ny=!1,Cy=iS(j0,!0)):Cy=[]:g$(j0)||c2(j0)?(Cy=N0,c2(N0)?Cy=DE(N0):(!C1(N0)||iw(N0))&&(Cy=nE(j0))):Ny=!1}Ny&&(R0.set(j0,Cy),e0(Cy,j0,Mo,p0,R0),R0.delete(j0)),K2(vn,or,Cy)}function yx(vn,Tn){var or=vn.length;if(or)return Tn+=Tn<0?or:0,rw(Tn,or)?vn[Tn]:pt}function r2(vn,Tn,or){Tn.length?Tn=f1(Tn,function(p0){return Wv(p0)?function(R0){return j_(R0,p0.length===1?p0[0]:p0)}:p0}):Tn=[F_];var Mo=-1;Tn=f1(Tn,zo(Iv()));var e0=ew(vn,function(p0,R0,N0){var j0=f1(Tn,function(Ay){return Ay(p0)});return{criteria:j0,index:++Mo,value:p0}});return G_(e0,function(p0,R0){return I2(p0,R0,or)})}function i2(vn,Tn){return S2(vn,Tn,function(or,Mo){return VS(vn,Mo)})}function S2(vn,Tn,or){for(var Mo=-1,e0=Tn.length,p0={};++Mo<e0;){var R0=Tn[Mo],N0=j_(vn,R0);or(N0,R0)&&tw(p0,Nx(R0,vn),N0)}return p0}function E2(vn){return function(Tn){return j_(Tn,vn)}}function Mw(vn,Tn,or,Mo){var e0=Mo?Y_:p_,p0=-1,R0=Tn.length,N0=vn;for(vn===Tn&&(Tn=s_(Tn)),or&&(N0=f1(vn,zo(or)));++p0<R0;)for(var j0=0,Ay=Tn[p0],Cy=or?or(Ay):Ay;(j0=e0(N0,Cy,j0,Mo))>-1;)N0!==vn&&Mx.call(N0,j0,1),Mx.call(vn,j0,1);return vn}function i_(vn,Tn){for(var or=vn?Tn.length:0,Mo=or-1;or--;){var e0=Tn[or];if(or==Mo||e0!==p0){var p0=e0;rw(e0)?Mx.call(vn,e0,1):s$(vn,e0)}}return vn}function ox(vn,Tn){return vn+jw(G2()*(Tn-vn+1))}function D_(vn,Tn,or,Mo){for(var e0=-1,p0=L1(Ww((Tn-vn)/(or||1)),0),R0=oy(p0);p0--;)R0[Mo?p0:++e0]=vn,vn+=or;return R0}function Iw(vn,Tn){var or="";if(!vn||Tn<1||Tn>n0)return or;do Tn%2&&(or+=vn),Tn=jw(Tn/2),Tn&&(vn+=vn);while(Tn);return or}function Sv(vn,Tn){return BS(oE(vn,Tn,F_),vn+"")}function Q$(vn){return Yw(B2(vn))}function i$(vn,Tn){var or=B2(vn);return lS(or,Ox(Tn,0,or.length))}function tw(vn,Tn,or,Mo){if(!C1(vn))return vn;Tn=Nx(Tn,vn);for(var e0=-1,p0=Tn.length,R0=p0-1,N0=vn;N0!=null&&++e0<p0;){var j0=zx(Tn[e0]),Ay=or;if(j0==="__proto__"||j0==="constructor"||j0==="prototype")return vn;if(e0!=R0){var Cy=N0[j0];Ay=Mo?Mo(Cy,j0,N0):pt,Ay===pt&&(Ay=C1(Cy)?Cy:rw(Tn[e0+1])?[]:{})}H_(N0,j0,Ay),N0=N0[j0]}return vn}var eS=h2?function(vn,Tn){return h2.set(vn,Tn),vn}:F_,Dx=vw?function(vn,Tn){return vw(vn,"toString",{configurable:!0,enumerable:!1,value:WS(Tn),writable:!0})}:F_;function tS(vn){return lS(B2(vn))}function A_(vn,Tn,or){var Mo=-1,e0=vn.length;Tn<0&&(Tn=-Tn>e0?0:e0+Tn),or=or>e0?e0:or,or<0&&(or+=e0),e0=Tn>or?0:or-Tn>>>0,Tn>>>=0;for(var p0=oy(e0);++Mo<e0;)p0[Mo]=vn[Mo+Tn];return p0}function o$(vn,Tn){var or;return W_(vn,function(Mo,e0,p0){return or=Tn(Mo,e0,p0),!or}),!!or}function ax(vn,Tn,or){var Mo=0,e0=vn==null?Mo:vn.length;if(typeof Tn=="number"&&Tn===Tn&&e0<=V0){for(;Mo<e0;){var p0=Mo+e0>>>1,R0=vn[p0];R0!==null&&!K_(R0)&&(or?R0<=Tn:R0<Tn)?Mo=p0+1:e0=p0}return e0}return T2(vn,Tn,F_,or)}function T2(vn,Tn,or,Mo){var e0=0,p0=vn==null?0:vn.length;if(p0===0)return 0;Tn=or(Tn);for(var R0=Tn!==Tn,N0=Tn===null,j0=K_(Tn),Ay=Tn===pt;e0<p0;){var Cy=jw((e0+p0)/2),Ny=or(vn[Cy]),nv=Ny!==pt,yv=Ny===null,Bv=Ny===Ny,e1=K_(Ny);if(R0)var kv=Mo||Bv;else Ay?kv=Bv&&(Mo||nv):N0?kv=Bv&&nv&&(Mo||!yv):j0?kv=Bv&&nv&&!yv&&(Mo||!e1):yv||e1?kv=!1:kv=Mo?Ny<=Tn:Ny<Tn;kv?e0=Cy+1:p0=Cy}return t_(p0,P0)}function a$(vn,Tn){for(var or=-1,Mo=vn.length,e0=0,p0=[];++or<Mo;){var R0=vn[or],N0=Tn?Tn(R0):R0;if(!or||!bx(N0,j0)){var j0=N0;p0[e0++]=R0===0?0:R0}}return p0}function A2(vn){return typeof vn=="number"?vn:K_(vn)?h0:+vn}function o_(vn){if(typeof vn=="string")return vn;if(Wv(vn))return f1(vn,o_)+"";if(K_(vn))return xw?xw.call(vn):"";var Tn=vn+"";return Tn=="0"&&1/vn==-E0?"-0":Tn}function Bx(vn,Tn,or){var Mo=-1,e0=ov,p0=vn.length,R0=!0,N0=[],j0=N0;if(or)R0=!1,e0=fx;else if(p0>=wt){var Ay=Tn?null:l_(vn);if(Ay)return Fw(Ay);R0=!1,e0=w0,j0=new Rx}else j0=Tn?[]:N0;e:for(;++Mo<p0;){var Cy=vn[Mo],Ny=Tn?Tn(Cy):Cy;if(Cy=or||Cy!==0?Cy:0,R0&&Ny===Ny){for(var nv=j0.length;nv--;)if(j0[nv]===Ny)continue e;Tn&&j0.push(Ny),N0.push(Cy)}else e0(j0,Ny,or)||(j0!==N0&&j0.push(Ny),N0.push(Cy))}return N0}function s$(vn,Tn){return Tn=Nx(Tn,vn),vn=aE(vn,Tn),vn==null||delete vn[zx(lx(Tn))]}function l$(vn,Tn,or,Mo){return tw(vn,Tn,or(j_(vn,Tn)),Mo)}function o2(vn,Tn,or,Mo){for(var e0=vn.length,p0=Mo?e0:-1;(Mo?p0--:++p0<e0)&&Tn(vn[p0],p0,vn););return or?A_(vn,Mo?0:p0,Mo?p0+1:e0):A_(vn,Mo?p0+1:0,Mo?e0:p0)}function kx(vn,Tn){var or=vn;return or instanceof Cv&&(or=or.value()),f_(Tn,function(Mo,e0){return e0.func.apply(e0.thisArg,Q1([Mo],e0.args))},or)}function u$(vn,Tn,or){var Mo=vn.length;if(Mo<2)return Mo?Bx(vn[0]):[];for(var e0=-1,p0=oy(Mo);++e0<Mo;)for(var R0=vn[e0],N0=-1;++N0<Mo;)N0!=e0&&(p0[e0]=Jx(p0[e0]||R0,vn[N0],Tn,or));return Bx(W1(p0,1),Tn,or)}function Lx(vn,Tn,or){for(var Mo=-1,e0=vn.length,p0=Tn.length,R0={};++Mo<e0;){var N0=Mo<p0?Tn[Mo]:pt;or(R0,vn[Mo],N0)}return R0}function C2(vn){return F1(vn)?vn:[]}function a_(vn){return typeof vn=="function"?vn:F_}function Nx(vn,Tn){return Wv(vn)?vn:PS(vn,Tn)?[vn]:cE(h1(vn))}var nS=Sv;function Fx(vn,Tn,or){var Mo=vn.length;return or=or===pt?Mo:or,!Tn&&or>=Mo?vn:A_(vn,Tn,or)}var rS=Hw||function(vn){return _1.clearTimeout(vn)};function c$(vn,Tn){if(Tn)return vn.slice();var or=vn.length,Mo=N2?N2(or):new vn.constructor(or);return vn.copy(Mo),Mo}function M2(vn){var Tn=new vn.constructor(vn.byteLength);return new Gw(Tn).set(new Gw(vn)),Tn}function AS(vn,Tn){var or=Tn?M2(vn.buffer):vn.buffer;return new vn.constructor(or,vn.byteOffset,vn.byteLength)}function B_(vn){var Tn=new vn.constructor(vn.source,D0.exec(vn));return Tn.lastIndex=vn.lastIndex,Tn}function d$(vn){return mx?Dv(mx.call(vn)):{}}function iS(vn,Tn){var or=Tn?M2(vn.buffer):vn.buffer;return new vn.constructor(or,vn.byteOffset,vn.length)}function vx(vn,Tn){if(vn!==Tn){var or=vn!==pt,Mo=vn===null,e0=vn===vn,p0=K_(vn),R0=Tn!==pt,N0=Tn===null,j0=Tn===Tn,Ay=K_(Tn);if(!N0&&!Ay&&!p0&&vn>Tn||p0&&R0&&j0&&!N0&&!Ay||Mo&&R0&&j0||!or&&j0||!e0)return 1;if(!Mo&&!p0&&!Ay&&vn<Tn||Ay&&or&&e0&&!Mo&&!p0||N0&&or&&e0||!R0&&e0||!j0)return-1}return 0}function I2(vn,Tn,or){for(var Mo=-1,e0=vn.criteria,p0=Tn.criteria,R0=e0.length,N0=or.length;++Mo<R0;){var j0=vx(e0[Mo],p0[Mo]);if(j0){if(Mo>=N0)return j0;var Ay=or[Mo];return j0*(Ay=="desc"?-1:1)}}return vn.index-Tn.index}function Ux(vn,Tn,or,Mo){for(var e0=-1,p0=vn.length,R0=or.length,N0=-1,j0=Tn.length,Ay=L1(p0-R0,0),Cy=oy(j0+Ay),Ny=!Mo;++N0<j0;)Cy[N0]=Tn[N0];for(;++e0<R0;)(Ny||e0<p0)&&(Cy[or[e0]]=vn[e0]);for(;Ay--;)Cy[N0++]=vn[e0++];return Cy}function a2(vn,Tn,or,Mo){for(var e0=-1,p0=vn.length,R0=-1,N0=or.length,j0=-1,Ay=Tn.length,Cy=L1(p0-N0,0),Ny=oy(Cy+Ay),nv=!Mo;++e0<Cy;)Ny[e0]=vn[e0];for(var yv=e0;++j0<Ay;)Ny[yv+j0]=Tn[j0];for(;++R0<N0;)(nv||e0<p0)&&(Ny[yv+or[R0]]=vn[e0++]);return Ny}function s_(vn,Tn){var or=-1,Mo=vn.length;for(Tn||(Tn=oy(Mo));++or<Mo;)Tn[or]=vn[or];return Tn}function k_(vn,Tn,or,Mo){var e0=!or;or||(or={});for(var p0=-1,R0=Tn.length;++p0<R0;){var N0=Tn[p0],j0=Mo?Mo(or[N0],vn[N0],N0,or,vn):pt;j0===pt&&(j0=vn[N0]),e0?ix(or,N0,j0):H_(or,N0,j0)}return or}function CS(vn,Tn){return k_(vn,RS(vn),Tn)}function oS(vn,Tn){return k_(vn,eE(vn),Tn)}function s2(vn,Tn){return function(or,Mo){var e0=Wv(or)?x_:Z2,p0=Tn?Tn():{};return e0(or,vn,Iv(Mo,2),p0)}}function nw(vn){return Sv(function(Tn,or){var Mo=-1,e0=or.length,p0=e0>1?or[e0-1]:pt,R0=e0>2?or[2]:pt;for(p0=vn.length>3&&typeof p0=="function"?(e0--,p0):pt,R0&&M_(or[0],or[1],R0)&&(p0=e0<3?pt:p0,e0=1),Tn=Dv(Tn);++Mo<e0;){var N0=or[Mo];N0&&vn(Tn,N0,Mo,p0)}return Tn})}function f$(vn,Tn){return function(or,Mo){if(or==null)return or;if(!L_(or))return vn(or,Mo);for(var e0=or.length,p0=Tn?e0:-1,R0=Dv(or);(Tn?p0--:++p0<e0)&&Mo(R0[p0],p0,R0)!==!1;);return or}}function R2(vn){return function(Tn,or,Mo){for(var e0=-1,p0=Dv(Tn),R0=Mo(Tn),N0=R0.length;N0--;){var j0=R0[vn?N0:++e0];if(or(p0[j0],j0,p0)===!1)break}return Tn}}function MS(vn,Tn,or){var Mo=Tn&Sn,e0=xn(vn);function p0(){var R0=this&&this!==_1&&this instanceof p0?e0:vn;return R0.apply(Mo?or:this,arguments)}return p0}function aS(vn){return function(Tn){Tn=h1(Tn);var or=r1(Tn)?$1(Tn):pt,Mo=or?or[0]:Tn.charAt(0),e0=or?Fx(or,1).join(""):Tn.slice(1);return Mo[vn]()+e0}}function _n(vn){return function(Tn){return f_(GE(zE(Tn).replace(ky,"")),vn,"")}}function xn(vn){return function(){var Tn=arguments;switch(Tn.length){case 0:return new vn;case 1:return new vn(Tn[0]);case 2:return new vn(Tn[0],Tn[1]);case 3:return new vn(Tn[0],Tn[1],Tn[2]);case 4:return new vn(Tn[0],Tn[1],Tn[2],Tn[3]);case 5:return new vn(Tn[0],Tn[1],Tn[2],Tn[3],Tn[4]);case 6:return new vn(Tn[0],Tn[1],Tn[2],Tn[3],Tn[4],Tn[5]);case 7:return new vn(Tn[0],Tn[1],Tn[2],Tn[3],Tn[4],Tn[5],Tn[6])}var or=gx(vn.prototype),Mo=vn.apply(or,Tn);return C1(Mo)?Mo:or}}function nr(vn,Tn,or){var Mo=xn(vn);function e0(){for(var p0=arguments.length,R0=oy(p0),N0=p0,j0=O2(e0);N0--;)R0[N0]=arguments[N0];var Ay=p0<3&&R0[0]!==j0&&R0[p0-1]!==j0?[]:__(R0,j0);if(p0-=Ay.length,p0<or)return p1(vn,Tn,Uo,e0.placeholder,pt,R0,Ay,pt,pt,or-p0);var Cy=this&&this!==_1&&this instanceof e0?Mo:vn;return y1(Cy,this,R0)}return e0}function Lr(vn){return function(Tn,or,Mo){var e0=Dv(Tn);if(!L_(Tn)){var p0=Iv(or,3);Tn=u_(Tn),or=function(N0){return p0(e0[N0],N0,e0)}}var R0=vn(Tn,or,Mo);return R0>-1?e0[p0?Tn[R0]:R0]:pt}}function Xr(vn){return Kv(function(Tn){var or=Tn.length,Mo=or,e0=n_.prototype.thru;for(vn&&Tn.reverse();Mo--;){var p0=Tn[Mo];if(typeof p0!="function")throw new h_(Tt);if(e0&&!R0&&P2(p0)=="wrapper")var R0=new n_([],!0)}for(Mo=R0?Mo:or;++Mo<or;){p0=Tn[Mo];var N0=P2(p0),j0=N0=="wrapper"?sx(p0):pt;j0&&OS(j0[0])&&j0[1]==(Zr|tr|Hr|Bo)&&!j0[4].length&&j0[9]==1?R0=R0[P2(j0[0])].apply(R0,j0[3]):R0=p0.length==1&&OS(p0)?R0[N0]():R0.thru(p0)}return function(){var Ay=arguments,Cy=Ay[0];if(R0&&Ay.length==1&&Wv(Cy))return R0.plant(Cy).value();for(var Ny=0,nv=or?Tn[Ny].apply(this,Ay):Cy;++Ny<or;)nv=Tn[Ny].call(this,nv);return nv}})}function Uo(vn,Tn,or,Mo,e0,p0,R0,N0,j0,Ay){var Cy=Tn&Zr,Ny=Tn&Sn,nv=Tn&wn,yv=Tn&(tr|rr),Bv=Tn&Xo,e1=nv?pt:xn(vn);function kv(){for(var o1=arguments.length,l1=oy(o1),Z_=o1;Z_--;)l1[Z_]=arguments[Z_];if(yv)var I_=O2(kv),X_=Iy(l1,I_);if(Mo&&(l1=Ux(l1,Mo,e0,yv)),p0&&(l1=a2(l1,p0,R0,yv)),o1-=X_,yv&&o1<Ay){var U1=__(l1,I_);return p1(vn,Tn,Uo,kv.placeholder,or,l1,U1,N0,j0,Ay-o1)}var xx=Ny?or:this,aw=nv?xx[vn]:vn;return o1=l1.length,N0?l1=fT(l1,N0):Bv&&o1>1&&l1.reverse(),Cy&&j0<o1&&(l1.length=j0),this&&this!==_1&&this instanceof kv&&(aw=e1||xn(aw)),aw.apply(xx,l1)}return kv}function S0(vn,Tn){return function(or,Mo){return t$(or,vn,Tn(Mo),{})}}function z0(vn,Tn){return function(or,Mo){var e0;if(or===pt&&Mo===pt)return Tn;if(or!==pt&&(e0=or),Mo!==pt){if(e0===pt)return Mo;typeof or=="string"||typeof Mo=="string"?(or=o_(or),Mo=o_(Mo)):(or=A2(or),Mo=A2(Mo)),e0=vn(or,Mo)}return e0}}function gy(vn){return Kv(function(Tn){return Tn=f1(Tn,zo(Iv())),Sv(function(or){var Mo=this;return vn(Tn,function(e0){return y1(e0,Mo,or)})})})}function Gy(vn,Tn){Tn=Tn===pt?" ":o_(Tn);var or=Tn.length;if(or<2)return or?Iw(Tn,vn):Tn;var Mo=Iw(Tn,Ww(vn/J_(Tn)));return r1(Tn)?Fx($1(Mo),0,vn).join(""):Mo.slice(0,vn)}function cv(vn,Tn,or,Mo){var e0=Tn&Sn,p0=xn(vn);function R0(){for(var N0=-1,j0=arguments.length,Ay=-1,Cy=Mo.length,Ny=oy(Cy+j0),nv=this&&this!==_1&&this instanceof R0?p0:vn;++Ay<Cy;)Ny[Ay]=Mo[Ay];for(;j0--;)Ny[Ay++]=arguments[++N0];return y1(nv,e0?or:this,Ny)}return R0}function Uv(vn){return function(Tn,or,Mo){return Mo&&typeof Mo!="number"&&M_(Tn,or,Mo)&&(or=Mo=pt),Tn=ow(Tn),or===pt?(or=Tn,Tn=0):or=ow(or),Mo=Mo===pt?Tn<or?1:-1:ow(Mo),D_(Tn,or,Mo,vn)}}function $v(vn){return function(Tn,or){return typeof Tn=="string"&&typeof or=="string"||(Tn=ux(Tn),or=ux(or)),vn(Tn,or)}}function p1(vn,Tn,or,Mo,e0,p0,R0,N0,j0,Ay){var Cy=Tn&tr,Ny=Cy?R0:pt,nv=Cy?pt:R0,yv=Cy?p0:pt,Bv=Cy?pt:p0;Tn|=Cy?Hr:qr,Tn&=~(Cy?qr:Hr),Tn&In||(Tn&=~(Sn|wn));var e1=[vn,Tn,e0,yv,Ny,Bv,nv,N0,j0,Ay],kv=or.apply(pt,e1);return OS(vn)&&sE(kv,e1),kv.placeholder=Mo,lE(kv,vn,Tn)}function mv(vn){var Tn=b1[vn];return function(or,Mo){if(or=ux(or),Mo=Mo==null?0:t_(Xv(Mo),292),Mo&&z2(or)){var e0=(h1(or)+"e").split("e"),p0=Tn(e0[0]+"e"+(+e0[1]+Mo));return e0=(h1(p0)+"e").split("e"),+(e0[0]+"e"+(+e0[1]-Mo))}return Tn(or)}}var l_=bw&&1/Fw(new bw([,-0]))[1]==E0?function(vn){return new bw(vn)}:KS;function C_(vn){return function(Tn){var or=b_(Tn);return or==J0?Qv(Tn):or==y0?w$(Tn):Ir(Tn,vn(Tn))}}function Z0(vn,Tn,or,Mo,e0,p0,R0,N0){var j0=Tn&wn;if(!j0&&typeof vn!="function")throw new h_(Tt);var Ay=Mo?Mo.length:0;if(Ay||(Tn&=~(Hr|qr),Mo=e0=pt),R0=R0===pt?R0:L1(Xv(R0),0),N0=N0===pt?N0:Xv(N0),Ay-=e0?e0.length:0,Tn&qr){var Cy=Mo,Ny=e0;Mo=e0=pt}var nv=j0?pt:sx(vn),yv=[vn,Tn,or,Mo,e0,Cy,Ny,p0,R0,N0];if(nv&&uT(yv,nv),vn=yv[0],Tn=yv[1],or=yv[2],Mo=yv[3],e0=yv[4],N0=yv[9]=yv[9]===pt?j0?0:vn.length:L1(yv[9]-Ay,0),!N0&&Tn&(tr|rr)&&(Tn&=~(tr|rr)),!Tn||Tn==Sn)var Bv=MS(vn,Tn,or);else Tn==tr||Tn==rr?Bv=nr(vn,Tn,N0):(Tn==Hr||Tn==(Sn|Hr))&&!e0.length?Bv=cv(vn,Tn,or,Mo):Bv=Uo.apply(pt,yv);var e1=nv?eS:sE;return lE(e1(Bv,yv),vn,Tn)}function H0(vn,Tn,or,Mo){return vn===pt||bx(vn,gw[or])&&!d1.call(Mo,or)?Tn:vn}function ly(vn,Tn,or,Mo,e0,p0){return C1(vn)&&C1(Tn)&&(p0.set(Tn,vn),q_(vn,Tn,pt,ly,p0),p0.delete(Tn)),vn}function iv(vn){return g$(vn)?pt:vn}function gv(vn,Tn,or,Mo,e0,p0){var R0=or&Kt,N0=vn.length,j0=Tn.length;if(N0!=j0&&!(R0&&j0>N0))return!1;var Ay=p0.get(vn),Cy=p0.get(Tn);if(Ay&&Cy)return Ay==Tn&&Cy==vn;var Ny=-1,nv=!0,yv=or&An?new Rx:pt;for(p0.set(vn,Tn),p0.set(Tn,vn);++Ny<N0;){var Bv=vn[Ny],e1=Tn[Ny];if(Mo)var kv=R0?Mo(e1,Bv,Ny,Tn,vn,p0):Mo(Bv,e1,Ny,vn,Tn,p0);if(kv!==pt){if(kv)continue;nv=!1;break}if(yv){if(!Sx(Tn,function(o1,l1){if(!w0(yv,l1)&&(Bv===o1||e0(Bv,o1,or,Mo,p0)))return yv.push(l1)})){nv=!1;break}}else if(!(Bv===e1||e0(Bv,e1,or,Mo,p0))){nv=!1;break}}return p0.delete(vn),p0.delete(Tn),nv}function qv(vn,Tn,or,Mo,e0,p0,R0){switch(or){case Xy:if(vn.byteLength!=Tn.byteLength||vn.byteOffset!=Tn.byteOffset)return!1;vn=vn.buffer,Tn=Tn.buffer;case Vy:return!(vn.byteLength!=Tn.byteLength||!p0(new Gw(vn),new Gw(Tn)));case $y:case My:case yy:return bx(+vn,+Tn);case Ey:return vn.name==Tn.name&&vn.message==Tn.message;case rv:case r0:return vn==Tn+"";case J0:var N0=Qv;case y0:var j0=Mo&Kt;if(N0||(N0=Fw),vn.size!=Tn.size&&!j0)return!1;var Ay=R0.get(vn);if(Ay)return Ay==Tn;Mo|=An,R0.set(vn,Tn);var Cy=gv(N0(vn),N0(Tn),Mo,e0,p0,R0);return R0.delete(vn),Cy;case M0:if(mx)return mx.call(vn)==mx.call(Tn)}return!1}function zv(vn,Tn,or,Mo,e0,p0){var R0=or&Kt,N0=D1(vn),j0=N0.length,Ay=D1(Tn),Cy=Ay.length;if(j0!=Cy&&!R0)return!1;for(var Ny=j0;Ny--;){var nv=N0[Ny];if(!(R0?nv in Tn:d1.call(Tn,nv)))return!1}var yv=p0.get(vn),Bv=p0.get(Tn);if(yv&&Bv)return yv==Tn&&Bv==vn;var e1=!0;p0.set(vn,Tn),p0.set(Tn,vn);for(var kv=R0;++Ny<j0;){nv=N0[Ny];var o1=vn[nv],l1=Tn[nv];if(Mo)var Z_=R0?Mo(l1,o1,nv,Tn,vn,p0):Mo(o1,l1,nv,vn,Tn,p0);if(!(Z_===pt?o1===l1||e0(o1,l1,or,Mo,p0):Z_)){e1=!1;break}kv||(kv=nv=="constructor")}if(e1&&!kv){var I_=vn.constructor,X_=Tn.constructor;I_!=X_&&"constructor"in vn&&"constructor"in Tn&&!(typeof I_=="function"&&I_ instanceof I_&&typeof X_=="function"&&X_ instanceof X_)&&(e1=!1)}return p0.delete(vn),p0.delete(Tn),e1}function Kv(vn){return BS(oE(vn,pt,hE),vn+"")}function D1(vn){return b2(vn,u_,RS)}function s1(vn){return b2(vn,N_,eE)}var sx=h2?function(vn){return h2.get(vn)}:KS;function P2(vn){for(var Tn=vn.name+"",or=Xx[Tn],Mo=d1.call(Xx,Tn)?or.length:0;Mo--;){var e0=or[Mo],p0=e0.func;if(p0==null||p0==vn)return e0.name}return Tn}function O2(vn){var Tn=d1.call(u0,"placeholder")?u0:vn;return Tn.placeholder}function Iv(){var vn=u0.iteratee||jS;return vn=vn===jS?Cw:vn,arguments.length?vn(arguments[0],arguments[1]):vn}function sS(vn,Tn){var or=vn.__data__;return oT(Tn)?or[typeof Tn=="string"?"string":"hash"]:or.map}function IS(vn){for(var Tn=u_(vn),or=Tn.length;or--;){var Mo=Tn[or],e0=vn[Mo];Tn[or]=[Mo,e0,rE(e0)]}return Tn}function l2(vn,Tn){var or=a1(vn,Tn);return Tw(or)?or:pt}function JE(vn){var Tn=d1.call(vn,nx),or=vn[nx];try{vn[nx]=pt;var Mo=!0}catch{}var e0=w_.call(vn);return Mo&&(Tn?vn[nx]=or:delete vn[nx]),e0}var RS=qw?function(vn){return vn==null?[]:(vn=Dv(vn),G1(qw(vn),function(Tn){return p2.call(vn,Tn)}))}:ZS,eE=qw?function(vn){for(var Tn=[];vn;)Q1(Tn,RS(vn)),vn=Vw(vn);return Tn}:ZS,b_=X1;(_w&&b_(new _w(new ArrayBuffer(1)))!=Xy||Kw&&b_(new Kw)!=J0||V2&&b_(V2.resolve())!=Fy||bw&&b_(new bw)!=y0||Kx&&b_(new Kx)!=sy)&&(b_=function(vn){var Tn=X1(vn),or=Tn==Dy?vn.constructor:pt,Mo=or?u2(or):"";if(Mo)switch(Mo){case P$:return Xy;case O$:return J0;case D$:return Fy;case B$:return y0;case rx:return sy}return Tn});function QE(vn,Tn,or){for(var Mo=-1,e0=or.length;++Mo<e0;){var p0=or[Mo],R0=p0.size;switch(p0.type){case"drop":vn+=R0;break;case"dropRight":Tn-=R0;break;case"take":Tn=t_(Tn,vn+R0);break;case"takeRight":vn=L1(vn,Tn-R0);break}}return{start:vn,end:Tn}}function eT(vn){var Tn=vn.match(g1);return Tn?Tn[1].split(_v):[]}function tE(vn,Tn,or){Tn=Nx(Tn,vn);for(var Mo=-1,e0=Tn.length,p0=!1;++Mo<e0;){var R0=zx(Tn[Mo]);if(!(p0=vn!=null&&or(vn,R0)))break;vn=vn[R0]}return p0||++Mo!=e0?p0:(e0=vn==null?0:vn.length,!!e0&&hS(e0)&&rw(R0,e0)&&(Wv(vn)||c2(vn)))}function tT(vn){var Tn=vn.length,or=new vn.constructor(Tn);return Tn&&typeof vn[0]=="string"&&d1.call(vn,"index")&&(or.index=vn.index,or.input=vn.input),or}function nE(vn){return typeof vn.constructor=="function"&&!p$(vn)?gx(Vw(vn)):{}}function nT(vn,Tn,or){var Mo=vn.constructor;switch(Tn){case Vy:return M2(vn);case $y:case My:return new Mo(+vn);case Xy:return AS(vn,or);case hy:case Ly:case Py:case Sy:case Ev:case Qy:case cy:case C0:case U0:return iS(vn,or);case J0:return new Mo;case yy:case r0:return new Mo(vn);case rv:return B_(vn);case y0:return new Mo;case M0:return d$(vn)}}function rT(vn,Tn){var or=Tn.length;if(!or)return vn;var Mo=or-1;return Tn[Mo]=(or>1?"& ":"")+Tn[Mo],Tn=Tn.join(or>2?", ":" "),vn.replace(Jv,`{
/* [wrapped with `+Tn+`] */
`)}function iT(vn){return Wv(vn)||c2(vn)||!!(U2&&vn&&vn[U2])}function rw(vn,Tn){var or=typeof vn;return Tn=Tn??n0,!!Tn&&(or=="number"||or!="symbol"&&A0.test(vn))&&vn>-1&&vn%1==0&&vn<Tn}function M_(vn,Tn,or){if(!C1(or))return!1;var Mo=typeof Tn;return(Mo=="number"?L_(or)&&rw(Tn,or.length):Mo=="string"&&Tn in or)?bx(or[Tn],vn):!1}function PS(vn,Tn){if(Wv(vn))return!1;var or=typeof vn;return or=="number"||or=="symbol"||or=="boolean"||vn==null||K_(vn)?!0:Rv.test(vn)||!Tv.test(vn)||Tn!=null&&vn in Dv(Tn)}function oT(vn){var Tn=typeof vn;return Tn=="string"||Tn=="number"||Tn=="symbol"||Tn=="boolean"?vn!=="__proto__":vn===null}function OS(vn){var Tn=P2(vn),or=u0[Tn];if(typeof or!="function"||!(Tn in Cv.prototype))return!1;if(vn===or)return!0;var Mo=sx(or);return!!Mo&&vn===Mo[0]}function aT(vn){return!!tx&&tx in vn}var sT=k1?iw:XS;function p$(vn){var Tn=vn&&vn.constructor,or=typeof Tn=="function"&&Tn.prototype||gw;return vn===or}function rE(vn){return vn===vn&&!C1(vn)}function iE(vn,Tn){return function(or){return or==null?!1:or[vn]===Tn&&(Tn!==pt||vn in Dv(or))}}function lT(vn){var Tn=fS(vn,function(Mo){return or.size===Ct&&or.clear(),Mo}),or=Tn.cache;return Tn}function uT(vn,Tn){var or=vn[1],Mo=Tn[1],e0=or|Mo,p0=e0<(Sn|wn|Zr),R0=Mo==Zr&&or==tr||Mo==Zr&&or==Bo&&vn[7].length<=Tn[8]||Mo==(Zr|Bo)&&Tn[7].length<=Tn[8]&&or==tr;if(!(p0||R0))return vn;Mo&Sn&&(vn[2]=Tn[2],e0|=or&Sn?0:In);var N0=Tn[3];if(N0){var j0=vn[3];vn[3]=j0?Ux(j0,N0,Tn[4]):N0,vn[4]=j0?__(vn[3],Ht):Tn[4]}return N0=Tn[5],N0&&(j0=vn[5],vn[5]=j0?a2(j0,N0,Tn[6]):N0,vn[6]=j0?__(vn[5],Ht):Tn[6]),N0=Tn[7],N0&&(vn[7]=N0),Mo&Zr&&(vn[8]=vn[8]==null?Tn[8]:t_(vn[8],Tn[8])),vn[9]==null&&(vn[9]=Tn[9]),vn[0]=Tn[0],vn[1]=e0,vn}function cT(vn){var Tn=[];if(vn!=null)for(var or in Dv(vn))Tn.push(or);return Tn}function dT(vn){return w_.call(vn)}function oE(vn,Tn,or){return Tn=L1(Tn===pt?vn.length-1:Tn,0),function(){for(var Mo=arguments,e0=-1,p0=L1(Mo.length-Tn,0),R0=oy(p0);++e0<p0;)R0[e0]=Mo[Tn+e0];e0=-1;for(var N0=oy(Tn+1);++e0<Tn;)N0[e0]=Mo[e0];return N0[Tn]=or(R0),y1(vn,this,N0)}}function aE(vn,Tn){return Tn.length<2?vn:j_(vn,A_(Tn,0,-1))}function fT(vn,Tn){for(var or=vn.length,Mo=t_(Tn.length,or),e0=s_(vn);Mo--;){var p0=Tn[Mo];vn[Mo]=rw(p0,or)?e0[p0]:pt}return vn}function DS(vn,Tn){if(!(Tn==="constructor"&&typeof vn[Tn]=="function")&&Tn!="__proto__")return vn[Tn]}var sE=uE(eS),m$=T$||function(vn,Tn){return _1.setTimeout(vn,Tn)},BS=uE(Dx);function lE(vn,Tn,or){var Mo=Tn+"";return BS(vn,rT(Mo,pT(eT(Mo),or)))}function uE(vn){var Tn=0,or=0;return function(){var Mo=M$(),e0=x0-(Mo-or);if(or=Mo,e0>0){if(++Tn>=f0)return arguments[0]}else Tn=0;return vn.apply(pt,arguments)}}function lS(vn,Tn){var or=-1,Mo=vn.length,e0=Mo-1;for(Tn=Tn===pt?Mo:Tn;++or<Tn;){var p0=ox(or,e0),R0=vn[p0];vn[p0]=vn[or],vn[or]=R0}return vn.length=Tn,vn}var cE=lT(function(vn){var Tn=[];return vn.charCodeAt(0)===46&&Tn.push(""),vn.replace(Lv,function(or,Mo,e0,p0){Tn.push(e0?p0.replace(Qo,"$1"):Mo||or)}),Tn});function zx(vn){if(typeof vn=="string"||K_(vn))return vn;var Tn=vn+"";return Tn=="0"&&1/vn==-E0?"-0":Tn}function u2(vn){if(vn!=null){try{return yw.call(vn)}catch{}try{return vn+""}catch{}}return""}function pT(vn,Tn){return w1(B0,function(or){var Mo="_."+or[0];Tn&or[1]&&!ov(vn,Mo)&&vn.push(Mo)}),vn.sort()}function dE(vn){if(vn instanceof Cv)return vn.clone();var Tn=new n_(vn.__wrapped__,vn.__chain__);return Tn.__actions__=s_(vn.__actions__),Tn.__index__=vn.__index__,Tn.__values__=vn.__values__,Tn}function hT(vn,Tn,or){(or?M_(vn,Tn,or):Tn===pt)?Tn=1:Tn=L1(Xv(Tn),0);var Mo=vn==null?0:vn.length;if(!Mo||Tn<1)return[];for(var e0=0,p0=0,R0=oy(Ww(Mo/Tn));e0<Mo;)R0[p0++]=A_(vn,e0,e0+=Tn);return R0}function mT(vn){for(var Tn=-1,or=vn==null?0:vn.length,Mo=0,e0=[];++Tn<or;){var p0=vn[Tn];p0&&(e0[Mo++]=p0)}return e0}function gT(){var vn=arguments.length;if(!vn)return[];for(var Tn=oy(vn-1),or=arguments[0],Mo=vn;Mo--;)Tn[Mo-1]=arguments[Mo];return Q1(Wv(or)?s_(or):[or],W1(Tn,1))}var yT=Sv(function(vn,Tn){return F1(vn)?Jx(vn,W1(Tn,1,F1,!0)):[]}),vT=Sv(function(vn,Tn){var or=lx(Tn);return F1(or)&&(or=pt),F1(vn)?Jx(vn,W1(Tn,1,F1,!0),Iv(or,2)):[]}),_T=Sv(function(vn,Tn){var or=lx(Tn);return F1(or)&&(or=pt),F1(vn)?Jx(vn,W1(Tn,1,F1,!0),pt,or):[]});function bT(vn,Tn,or){var Mo=vn==null?0:vn.length;return Mo?(Tn=or||Tn===pt?1:Xv(Tn),A_(vn,Tn<0?0:Tn,Mo)):[]}function xT(vn,Tn,or){var Mo=vn==null?0:vn.length;return Mo?(Tn=or||Tn===pt?1:Xv(Tn),Tn=Mo-Tn,A_(vn,0,Tn<0?0:Tn)):[]}function wT(vn,Tn){return vn&&vn.length?o2(vn,Iv(Tn,3),!0,!0):[]}function $T(vn,Tn){return vn&&vn.length?o2(vn,Iv(Tn,3),!0):[]}function ST(vn,Tn,or,Mo){var e0=vn==null?0:vn.length;return e0?(or&&typeof or!="number"&&M_(vn,Tn,or)&&(or=0,Mo=e0),Y$(vn,Tn,or,Mo)):[]}function fE(vn,Tn,or){var Mo=vn==null?0:vn.length;if(!Mo)return-1;var e0=or==null?0:Xv(or);return e0<0&&(e0=L1(Mo+e0,0)),U_(vn,Iv(Tn,3),e0)}function pE(vn,Tn,or){var Mo=vn==null?0:vn.length;if(!Mo)return-1;var e0=Mo-1;return or!==pt&&(e0=Xv(or),e0=or<0?L1(Mo+e0,0):t_(e0,Mo-1)),U_(vn,Iv(Tn,3),e0,!0)}function hE(vn){var Tn=vn==null?0:vn.length;return Tn?W1(vn,1):[]}function ET(vn){var Tn=vn==null?0:vn.length;return Tn?W1(vn,E0):[]}function TT(vn,Tn){var or=vn==null?0:vn.length;return or?(Tn=Tn===pt?1:Xv(Tn),W1(vn,Tn)):[]}function AT(vn){for(var Tn=-1,or=vn==null?0:vn.length,Mo={};++Tn<or;){var e0=vn[Tn];Mo[e0[0]]=e0[1]}return Mo}function mE(vn){return vn&&vn.length?vn[0]:pt}function CT(vn,Tn,or){var Mo=vn==null?0:vn.length;if(!Mo)return-1;var e0=or==null?0:Xv(or);return e0<0&&(e0=L1(Mo+e0,0)),p_(vn,Tn,e0)}function MT(vn){var Tn=vn==null?0:vn.length;return Tn?A_(vn,0,-1):[]}var IT=Sv(function(vn){var Tn=f1(vn,C2);return Tn.length&&Tn[0]===vn[0]?Sw(Tn):[]}),RT=Sv(function(vn){var Tn=lx(vn),or=f1(vn,C2);return Tn===lx(or)?Tn=pt:or.pop(),or.length&&or[0]===vn[0]?Sw(or,Iv(Tn,2)):[]}),PT=Sv(function(vn){var Tn=lx(vn),or=f1(vn,C2);return Tn=typeof Tn=="function"?Tn:pt,Tn&&or.pop(),or.length&&or[0]===vn[0]?Sw(or,pt,Tn):[]});function OT(vn,Tn){return vn==null?"":_S.call(vn,Tn)}function lx(vn){var Tn=vn==null?0:vn.length;return Tn?vn[Tn-1]:pt}function DT(vn,Tn,or){var Mo=vn==null?0:vn.length;if(!Mo)return-1;var e0=Mo;return or!==pt&&(e0=Xv(or),e0=e0<0?L1(Mo+e0,0):t_(e0,Mo-1)),Tn===Tn?$$(vn,Tn,e0):U_(vn,Tx,e0,!0)}function BT(vn,Tn){return vn&&vn.length?yx(vn,Xv(Tn)):pt}var kT=Sv(gE);function gE(vn,Tn){return vn&&vn.length&&Tn&&Tn.length?Mw(vn,Tn):vn}function LT(vn,Tn,or){return vn&&vn.length&&Tn&&Tn.length?Mw(vn,Tn,Iv(or,2)):vn}function NT(vn,Tn,or){return vn&&vn.length&&Tn&&Tn.length?Mw(vn,Tn,pt,or):vn}var FT=Kv(function(vn,Tn){var or=vn==null?0:vn.length,Mo=v2(vn,Tn);return i_(vn,f1(Tn,function(e0){return rw(e0,or)?+e0:e0}).sort(vx)),Mo});function UT(vn,Tn){var or=[];if(!(vn&&vn.length))return or;var Mo=-1,e0=[],p0=vn.length;for(Tn=Iv(Tn,3);++Mo<p0;){var R0=vn[Mo];Tn(R0,Mo,vn)&&(or.push(R0),e0.push(Mo))}return i_(vn,e0),or}function kS(vn){return vn==null?vn:R$.call(vn)}function zT(vn,Tn,or){var Mo=vn==null?0:vn.length;return Mo?(or&&typeof or!="number"&&M_(vn,Tn,or)?(Tn=0,or=Mo):(Tn=Tn==null?0:Xv(Tn),or=or===pt?Mo:Xv(or)),A_(vn,Tn,or)):[]}function GT(vn,Tn){return ax(vn,Tn)}function VT(vn,Tn,or){return T2(vn,Tn,Iv(or,2))}function HT(vn,Tn){var or=vn==null?0:vn.length;if(or){var Mo=ax(vn,Tn);if(Mo<or&&bx(vn[Mo],Tn))return Mo}return-1}function WT(vn,Tn){return ax(vn,Tn,!0)}function jT(vn,Tn,or){return T2(vn,Tn,Iv(or,2),!0)}function qT(vn,Tn){var or=vn==null?0:vn.length;if(or){var Mo=ax(vn,Tn,!0)-1;if(bx(vn[Mo],Tn))return Mo}return-1}function KT(vn){return vn&&vn.length?a$(vn):[]}function ZT(vn,Tn){return vn&&vn.length?a$(vn,Iv(Tn,2)):[]}function XT(vn){var Tn=vn==null?0:vn.length;return Tn?A_(vn,1,Tn):[]}function YT(vn,Tn,or){return vn&&vn.length?(Tn=or||Tn===pt?1:Xv(Tn),A_(vn,0,Tn<0?0:Tn)):[]}function JT(vn,Tn,or){var Mo=vn==null?0:vn.length;return Mo?(Tn=or||Tn===pt?1:Xv(Tn),Tn=Mo-Tn,A_(vn,Tn<0?0:Tn,Mo)):[]}function QT(vn,Tn){return vn&&vn.length?o2(vn,Iv(Tn,3),!1,!0):[]}function eA(vn,Tn){return vn&&vn.length?o2(vn,Iv(Tn,3)):[]}var tA=Sv(function(vn){return Bx(W1(vn,1,F1,!0))}),nA=Sv(function(vn){var Tn=lx(vn);return F1(Tn)&&(Tn=pt),Bx(W1(vn,1,F1,!0),Iv(Tn,2))}),rA=Sv(function(vn){var Tn=lx(vn);return Tn=typeof Tn=="function"?Tn:pt,Bx(W1(vn,1,F1,!0),pt,Tn)});function iA(vn){return vn&&vn.length?Bx(vn):[]}function oA(vn,Tn){return vn&&vn.length?Bx(vn,Iv(Tn,2)):[]}function aA(vn,Tn){return Tn=typeof Tn=="function"?Tn:pt,vn&&vn.length?Bx(vn,pt,Tn):[]}function LS(vn){if(!(vn&&vn.length))return[];var Tn=0;return vn=G1(vn,function(or){if(F1(or))return Tn=L1(or.length,Tn),!0}),P_(Tn,function(or){return f1(vn,K1(or))})}function yE(vn,Tn){if(!(vn&&vn.length))return[];var or=LS(vn);return Tn==null?or:f1(or,function(Mo){return y1(Tn,pt,Mo)})}var sA=Sv(function(vn,Tn){return F1(vn)?Jx(vn,Tn):[]}),lA=Sv(function(vn){return u$(G1(vn,F1))}),uA=Sv(function(vn){var Tn=lx(vn);return F1(Tn)&&(Tn=pt),u$(G1(vn,F1),Iv(Tn,2))}),cA=Sv(function(vn){var Tn=lx(vn);return Tn=typeof Tn=="function"?Tn:pt,u$(G1(vn,F1),pt,Tn)}),dA=Sv(LS);function fA(vn,Tn){return Lx(vn||[],Tn||[],H_)}function pA(vn,Tn){return Lx(vn||[],Tn||[],tw)}var hA=Sv(function(vn){var Tn=vn.length,or=Tn>1?vn[Tn-1]:pt;return or=typeof or=="function"?(vn.pop(),or):pt,yE(vn,or)});function vE(vn){var Tn=u0(vn);return Tn.__chain__=!0,Tn}function mA(vn,Tn){return Tn(vn),vn}function uS(vn,Tn){return Tn(vn)}var gA=Kv(function(vn){var Tn=vn.length,or=Tn?vn[0]:0,Mo=this.__wrapped__,e0=function(p0){return v2(p0,vn)};return Tn>1||this.__actions__.length||!(Mo instanceof Cv)||!rw(or)?this.thru(e0):(Mo=Mo.slice(or,+or+(Tn?1:0)),Mo.__actions__.push({func:uS,args:[e0],thisArg:pt}),new n_(Mo,this.__chain__).thru(function(p0){return Tn&&!p0.length&&p0.push(pt),p0}))});function yA(){return vE(this)}function vA(){return new n_(this.value(),this.__chain__)}function _A(){this.__values__===pt&&(this.__values__=PE(this.value()));var vn=this.__index__>=this.__values__.length,Tn=vn?pt:this.__values__[this.__index__++];return{done:vn,value:Tn}}function bA(){return this}function xA(vn){for(var Tn,or=this;or instanceof Xw;){var Mo=dE(or);Mo.__index__=0,Mo.__values__=pt,Tn?e0.__wrapped__=Mo:Tn=Mo;var e0=Mo;or=or.__wrapped__}return e0.__wrapped__=vn,Tn}function wA(){var vn=this.__wrapped__;if(vn instanceof Cv){var Tn=vn;return this.__actions__.length&&(Tn=new Cv(this)),Tn=Tn.reverse(),Tn.__actions__.push({func:uS,args:[kS],thisArg:pt}),new n_(Tn,this.__chain__)}return this.thru(kS)}function $A(){return kx(this.__wrapped__,this.__actions__)}var SA=s2(function(vn,Tn,or){d1.call(vn,or)?++vn[or]:ix(vn,or,1)});function EA(vn,Tn,or){var Mo=Wv(vn)?kw:ES;return or&&M_(vn,Tn,or)&&(Tn=pt),Mo(vn,Iv(Tn,3))}function TA(vn,Tn){var or=Wv(vn)?G1:Q2;return or(vn,Iv(Tn,3))}var AA=Lr(fE),CA=Lr(pE);function MA(vn,Tn){return W1(cS(vn,Tn),1)}function IA(vn,Tn){return W1(cS(vn,Tn),E0)}function RA(vn,Tn,or){return or=or===pt?1:Xv(or),W1(cS(vn,Tn),or)}function _E(vn,Tn){var or=Wv(vn)?w1:W_;return or(vn,Iv(Tn,3))}function bE(vn,Tn){var or=Wv(vn)?$x:X$;return or(vn,Iv(Tn,3))}var PA=s2(function(vn,Tn,or){d1.call(vn,or)?vn[or].push(Tn):ix(vn,or,[Tn])});function OA(vn,Tn,or,Mo){vn=L_(vn)?vn:B2(vn),or=or&&!Mo?Xv(or):0;var e0=vn.length;return or<0&&(or=L1(e0+or,0)),mS(vn)?or<=e0&&vn.indexOf(Tn,or)>-1:!!e0&&p_(vn,Tn,or)>-1}var DA=Sv(function(vn,Tn,or){var Mo=-1,e0=typeof Tn=="function",p0=L_(vn)?oy(vn.length):[];return W_(vn,function(R0){p0[++Mo]=e0?y1(Tn,R0,or):v1(R0,Tn,or)}),p0}),BA=s2(function(vn,Tn,or){ix(vn,or,Tn)});function cS(vn,Tn){var or=Wv(vn)?f1:ew;return or(vn,Iv(Tn,3))}function kA(vn,Tn,or,Mo){return vn==null?[]:(Wv(Tn)||(Tn=Tn==null?[]:[Tn]),or=Mo?pt:or,Wv(or)||(or=or==null?[]:[or]),r2(vn,Tn,or))}var LA=s2(function(vn,Tn,or){vn[or?0:1].push(Tn)},function(){return[[],[]]});function NA(vn,Tn,or){var Mo=Wv(vn)?f_:z_,e0=arguments.length<3;return Mo(vn,Iv(Tn,4),or,e0,W_)}function FA(vn,Tn,or){var Mo=Wv(vn)?Lw:z_,e0=arguments.length<3;return Mo(vn,Iv(Tn,4),or,e0,X$)}function UA(vn,Tn){var or=Wv(vn)?G1:Q2;return or(vn,pS(Iv(Tn,3)))}function zA(vn){var Tn=Wv(vn)?Yw:Q$;return Tn(vn)}function GA(vn,Tn,or){(or?M_(vn,Tn,or):Tn===pt)?Tn=1:Tn=Xv(Tn);var Mo=Wv(vn)?q2:i$;return Mo(vn,Tn)}function VA(vn){var Tn=Wv(vn)?K$:tS;return Tn(vn)}function HA(vn){if(vn==null)return 0;if(L_(vn))return mS(vn)?J_(vn):vn.length;var Tn=b_(vn);return Tn==J0||Tn==y0?vn.size:r_(vn).length}function WA(vn,Tn,or){var Mo=Wv(vn)?Sx:o$;return or&&M_(vn,Tn,or)&&(Tn=pt),Mo(vn,Iv(Tn,3))}var jA=Sv(function(vn,Tn){if(vn==null)return[];var or=Tn.length;return or>1&&M_(vn,Tn[0],Tn[1])?Tn=[]:or>2&&M_(Tn[0],Tn[1],Tn[2])&&(Tn=[Tn[0]]),r2(vn,W1(Tn,1),[])}),dS=E$||function(){return _1.Date.now()};function qA(vn,Tn){if(typeof Tn!="function")throw new h_(Tt);return vn=Xv(vn),function(){if(--vn<1)return Tn.apply(this,arguments)}}function xE(vn,Tn,or){return Tn=or?pt:Tn,Tn=vn&&Tn==null?vn.length:Tn,Z0(vn,Zr,pt,pt,pt,pt,Tn)}function wE(vn,Tn){var or;if(typeof Tn!="function")throw new h_(Tt);return vn=Xv(vn),function(){return--vn>0&&(or=Tn.apply(this,arguments)),vn<=1&&(Tn=pt),or}}var NS=Sv(function(vn,Tn,or){var Mo=Sn;if(or.length){var e0=__(or,O2(NS));Mo|=Hr}return Z0(vn,Mo,Tn,or,e0)}),$E=Sv(function(vn,Tn,or){var Mo=Sn|wn;if(or.length){var e0=__(or,O2($E));Mo|=Hr}return Z0(Tn,Mo,vn,or,e0)});function SE(vn,Tn,or){Tn=or?pt:Tn;var Mo=Z0(vn,tr,pt,pt,pt,pt,pt,Tn);return Mo.placeholder=SE.placeholder,Mo}function EE(vn,Tn,or){Tn=or?pt:Tn;var Mo=Z0(vn,rr,pt,pt,pt,pt,pt,Tn);return Mo.placeholder=EE.placeholder,Mo}function TE(vn,Tn,or){var Mo,e0,p0,R0,N0,j0,Ay=0,Cy=!1,Ny=!1,nv=!0;if(typeof vn!="function")throw new h_(Tt);Tn=ux(Tn)||0,C1(or)&&(Cy=!!or.leading,Ny="maxWait"in or,p0=Ny?L1(ux(or.maxWait)||0,Tn):p0,nv="trailing"in or?!!or.trailing:nv);function yv(U1){var xx=Mo,aw=e0;return Mo=e0=pt,Ay=U1,R0=vn.apply(aw,xx),R0}function Bv(U1){return Ay=U1,N0=m$(o1,Tn),Cy?yv(U1):R0}function e1(U1){var xx=U1-j0,aw=U1-Ay,WE=Tn-xx;return Ny?t_(WE,p0-aw):WE}function kv(U1){var xx=U1-j0,aw=U1-Ay;return j0===pt||xx>=Tn||xx<0||Ny&&aw>=p0}function o1(){var U1=dS();if(kv(U1))return l1(U1);N0=m$(o1,e1(U1))}function l1(U1){return N0=pt,nv&&Mo?yv(U1):(Mo=e0=pt,R0)}function Z_(){N0!==pt&&rS(N0),Ay=0,Mo=j0=e0=N0=pt}function I_(){return N0===pt?R0:l1(dS())}function X_(){var U1=dS(),xx=kv(U1);if(Mo=arguments,e0=this,j0=U1,xx){if(N0===pt)return Bv(j0);if(Ny)return rS(N0),N0=m$(o1,Tn),yv(j0)}return N0===pt&&(N0=m$(o1,Tn)),R0}return X_.cancel=Z_,X_.flush=I_,X_}var KA=Sv(function(vn,Tn){return J2(vn,1,Tn)}),ZA=Sv(function(vn,Tn,or){return J2(vn,ux(Tn)||0,or)});function XA(vn){return Z0(vn,Xo)}function fS(vn,Tn){if(typeof vn!="function"||Tn!=null&&typeof Tn!="function")throw new h_(Tt);var or=function(){var Mo=arguments,e0=Tn?Tn.apply(this,Mo):Mo[0],p0=or.cache;if(p0.has(e0))return p0.get(e0);var R0=vn.apply(this,Mo);return or.cache=p0.set(e0,R0)||p0,R0};return or.cache=new(fS.Cache||O_),or}fS.Cache=O_;function pS(vn){if(typeof vn!="function")throw new h_(Tt);return function(){var Tn=arguments;switch(Tn.length){case 0:return!vn.call(this);case 1:return!vn.call(this,Tn[0]);case 2:return!vn.call(this,Tn[0],Tn[1]);case 3:return!vn.call(this,Tn[0],Tn[1],Tn[2])}return!vn.apply(this,Tn)}}function YA(vn){return wE(2,vn)}var JA=nS(function(vn,Tn){Tn=Tn.length==1&&Wv(Tn[0])?f1(Tn[0],zo(Iv())):f1(W1(Tn,1),zo(Iv()));var or=Tn.length;return Sv(function(Mo){for(var e0=-1,p0=t_(Mo.length,or);++e0<p0;)Mo[e0]=Tn[e0].call(this,Mo[e0]);return y1(vn,this,Mo)})}),FS=Sv(function(vn,Tn){var or=__(Tn,O2(FS));return Z0(vn,Hr,pt,Tn,or)}),AE=Sv(function(vn,Tn){var or=__(Tn,O2(AE));return Z0(vn,qr,pt,Tn,or)}),QA=Kv(function(vn,Tn){return Z0(vn,Bo,pt,pt,pt,Tn)});function eC(vn,Tn){if(typeof vn!="function")throw new h_(Tt);return Tn=Tn===pt?Tn:Xv(Tn),Sv(vn,Tn)}function tC(vn,Tn){if(typeof vn!="function")throw new h_(Tt);return Tn=Tn==null?0:L1(Xv(Tn),0),Sv(function(or){var Mo=or[Tn],e0=Fx(or,0,Tn);return Mo&&Q1(e0,Mo),y1(vn,this,e0)})}function nC(vn,Tn,or){var Mo=!0,e0=!0;if(typeof vn!="function")throw new h_(Tt);return C1(or)&&(Mo="leading"in or?!!or.leading:Mo,e0="trailing"in or?!!or.trailing:e0),TE(vn,Tn,{leading:Mo,maxWait:Tn,trailing:e0})}function rC(vn){return xE(vn,1)}function iC(vn,Tn){return FS(a_(Tn),vn)}function oC(){if(!arguments.length)return[];var vn=arguments[0];return Wv(vn)?vn:[vn]}function aC(vn){return S_(vn,qt)}function sC(vn,Tn){return Tn=typeof Tn=="function"?Tn:pt,S_(vn,qt,Tn)}function lC(vn){return S_(vn,Gt|qt)}function uC(vn,Tn){return Tn=typeof Tn=="function"?Tn:pt,S_(vn,Gt|qt,Tn)}function cC(vn,Tn){return Tn==null||_2(vn,Tn,u_(Tn))}function bx(vn,Tn){return vn===Tn||vn!==vn&&Tn!==Tn}var dC=$v(e2),fC=$v(function(vn,Tn){return vn>=Tn}),c2=jv(function(){return arguments}())?jv:function(vn){return B1(vn)&&d1.call(vn,"callee")&&!p2.call(vn,"callee")},Wv=oy.isArray,pC=Hx?zo(Hx):P1;function L_(vn){return vn!=null&&hS(vn.length)&&!iw(vn)}function F1(vn){return B1(vn)&&L_(vn)}function hC(vn){return vn===!0||vn===!1||B1(vn)&&X1(vn)==$y}var Rw=A$||XS,mC=lw?zo(lw):O1;function gC(vn){return B1(vn)&&vn.nodeType===1&&!g$(vn)}function yC(vn){if(vn==null)return!0;if(L_(vn)&&(Wv(vn)||typeof vn=="string"||typeof vn.splice=="function"||Rw(vn)||D2(vn)||c2(vn)))return!vn.length;var Tn=b_(vn);if(Tn==J0||Tn==y0)return!vn.size;if(p$(vn))return!r_(vn).length;for(var or in vn)if(d1.call(vn,or))return!1;return!0}function vC(vn,Tn){return T1(vn,Tn)}function _C(vn,Tn,or){or=typeof or=="function"?or:pt;var Mo=or?or(vn,Tn):pt;return Mo===pt?T1(vn,Tn,pt,or):!!Mo}function US(vn){if(!B1(vn))return!1;var Tn=X1(vn);return Tn==Ey||Tn==Wy||typeof vn.message=="string"&&typeof vn.name=="string"&&!g$(vn)}function bC(vn){return typeof vn=="number"&&z2(vn)}function iw(vn){if(!C1(vn))return!1;var Tn=X1(vn);return Tn==_0||Tn==ay||Tn==Ty||Tn==qy}function CE(vn){return typeof vn=="number"&&vn==Xv(vn)}function hS(vn){return typeof vn=="number"&&vn>-1&&vn%1==0&&vn<=n0}function C1(vn){var Tn=typeof vn;return vn!=null&&(Tn=="object"||Tn=="function")}function B1(vn){return vn!=null&&typeof vn=="object"}var ME=uw?zo(uw):Ew;function xC(vn,Tn){return vn===Tn||A1(vn,Tn,IS(Tn))}function wC(vn,Tn,or){return or=typeof or=="function"?or:pt,A1(vn,Tn,IS(Tn),or)}function $C(vn){return IE(vn)&&vn!=+vn}function SC(vn){if(sT(vn))throw new Nv($t);return Tw(vn)}function EC(vn){return vn===null}function TC(vn){return vn==null}function IE(vn){return typeof vn=="number"||B1(vn)&&X1(vn)==yy}function g$(vn){if(!B1(vn)||X1(vn)!=Dy)return!1;var Tn=Vw(vn);if(Tn===null)return!0;var or=d1.call(Tn,"constructor")&&Tn.constructor;return typeof or=="function"&&or instanceof or&&yw.call(or)==qx}var zS=Wx?zo(Wx):Aw;function AC(vn){return CE(vn)&&vn>=-n0&&vn<=n0}var RE=jx?zo(jx):x2;function mS(vn){return typeof vn=="string"||!Wv(vn)&&B1(vn)&&X1(vn)==r0}function K_(vn){return typeof vn=="symbol"||B1(vn)&&X1(vn)==M0}var D2=dx?zo(dx):n$;function CC(vn){return vn===pt}function MC(vn){return B1(vn)&&b_(vn)==sy}function IC(vn){return B1(vn)&&X1(vn)==dy}var RC=$v(t2),PC=$v(function(vn,Tn){return vn<=Tn});function PE(vn){if(!vn)return[];if(L_(vn))return mS(vn)?$1(vn):s_(vn);if(Ix&&vn[Ix])return Mv(vn[Ix]());var Tn=b_(vn),or=Tn==J0?Qv:Tn==y0?Fw:B2;return or(vn)}function ow(vn){if(!vn)return vn===0?vn:0;if(vn=ux(vn),vn===E0||vn===-E0){var Tn=vn<0?-1:1;return Tn*m0}return vn===vn?vn:0}function Xv(vn){var Tn=ow(vn),or=Tn%1;return Tn===Tn?or?Tn-or:Tn:0}function OE(vn){return vn?Ox(Xv(vn),0,a0):0}function ux(vn){if(typeof vn=="number")return vn;if(K_(vn))return h0;if(C1(vn)){var Tn=typeof vn.valueOf=="function"?vn.valueOf():vn;vn=C1(Tn)?Tn+"":Tn}if(typeof vn!="string")return vn===0?vn:+vn;vn=Yr(vn);var or=g0.test(vn);return or||I0.test(vn)?Dw(vn.slice(2),or?2:8):Go.test(vn)?h0:+vn}function DE(vn){return k_(vn,N_(vn))}function OC(vn){return vn?Ox(Xv(vn),-n0,n0):vn===0?vn:0}function h1(vn){return vn==null?"":o_(vn)}var DC=nw(function(vn,Tn){if(p$(Tn)||L_(Tn)){k_(Tn,u_(Tn),vn);return}for(var or in Tn)d1.call(Tn,or)&&H_(vn,or,Tn[or])}),BE=nw(function(vn,Tn){k_(Tn,N_(Tn),vn)}),gS=nw(function(vn,Tn,or,Mo){k_(Tn,N_(Tn),vn,Mo)}),BC=nw(function(vn,Tn,or,Mo){k_(Tn,u_(Tn),vn,Mo)}),kC=Kv(v2);function LC(vn,Tn){var or=gx(vn);return Tn==null?or:X2(or,Tn)}var NC=Sv(function(vn,Tn){vn=Dv(vn);var or=-1,Mo=Tn.length,e0=Mo>2?Tn[2]:pt;for(e0&&M_(Tn[0],Tn[1],e0)&&(Mo=1);++or<Mo;)for(var p0=Tn[or],R0=N_(p0),N0=-1,j0=R0.length;++N0<j0;){var Ay=R0[N0],Cy=vn[Ay];(Cy===pt||bx(Cy,gw[Ay])&&!d1.call(vn,Ay))&&(vn[Ay]=p0[Ay])}return vn}),FC=Sv(function(vn){return vn.push(pt,ly),y1(kE,pt,vn)});function UC(vn,Tn){return dw(vn,Iv(Tn,3),E_)}function zC(vn,Tn){return dw(vn,Iv(Tn,3),$w)}function GC(vn,Tn){return vn==null?vn:ww(vn,Iv(Tn,3),N_)}function VC(vn,Tn){return vn==null?vn:Qw(vn,Iv(Tn,3),N_)}function HC(vn,Tn){return vn&&E_(vn,Iv(Tn,3))}function WC(vn,Tn){return vn&&$w(vn,Iv(Tn,3))}function jC(vn){return vn==null?[]:Qx(vn,u_(vn))}function qC(vn){return vn==null?[]:Qx(vn,N_(vn))}function GS(vn,Tn,or){var Mo=vn==null?pt:j_(vn,Tn);return Mo===pt?or:Mo}function KC(vn,Tn){return vn!=null&&tE(vn,Tn,J$)}function VS(vn,Tn){return vn!=null&&tE(vn,Tn,e$)}var ZC=S0(function(vn,Tn,or){Tn!=null&&typeof Tn.toString!="function"&&(Tn=w_.call(Tn)),vn[Tn]=or},WS(F_)),XC=S0(function(vn,Tn,or){Tn!=null&&typeof Tn.toString!="function"&&(Tn=w_.call(Tn)),d1.call(vn,Tn)?vn[Tn].push(or):vn[Tn]=[or]},Iv),YC=Sv(v1);function u_(vn){return L_(vn)?tv(vn):r_(vn)}function N_(vn){return L_(vn)?tv(vn,!0):r$(vn)}function JC(vn,Tn){var or={};return Tn=Iv(Tn,3),E_(vn,function(Mo,e0,p0){ix(or,Tn(Mo,e0,p0),Mo)}),or}function QC(vn,Tn){var or={};return Tn=Iv(Tn,3),E_(vn,function(Mo,e0,p0){ix(or,e0,Tn(Mo,e0,p0))}),or}var eM=nw(function(vn,Tn,or){q_(vn,Tn,or)}),kE=nw(function(vn,Tn,or,Mo){q_(vn,Tn,or,Mo)}),tM=Kv(function(vn,Tn){var or={};if(vn==null)return or;var Mo=!1;Tn=f1(Tn,function(p0){return p0=Nx(p0,vn),Mo||(Mo=p0.length>1),p0}),k_(vn,s1(vn),or),Mo&&(or=S_(or,Gt|jt|qt,iv));for(var e0=Tn.length;e0--;)s$(or,Tn[e0]);return or});function nM(vn,Tn){return LE(vn,pS(Iv(Tn)))}var rM=Kv(function(vn,Tn){return vn==null?{}:i2(vn,Tn)});function LE(vn,Tn){if(vn==null)return{};var or=f1(s1(vn),function(Mo){return[Mo]});return Tn=Iv(Tn),S2(vn,or,function(Mo,e0){return Tn(Mo,e0[0])})}function iM(vn,Tn,or){Tn=Nx(Tn,vn);var Mo=-1,e0=Tn.length;for(e0||(e0=1,vn=pt);++Mo<e0;){var p0=vn==null?pt:vn[zx(Tn[Mo])];p0===pt&&(Mo=e0,p0=or),vn=iw(p0)?p0.call(vn):p0}return vn}function oM(vn,Tn,or){return vn==null?vn:tw(vn,Tn,or)}function aM(vn,Tn,or,Mo){return Mo=typeof Mo=="function"?Mo:pt,vn==null?vn:tw(vn,Tn,or,Mo)}var NE=C_(u_),FE=C_(N_);function sM(vn,Tn,or){var Mo=Wv(vn),e0=Mo||Rw(vn)||D2(vn);if(Tn=Iv(Tn,4),or==null){var p0=vn&&vn.constructor;e0?or=Mo?new p0:[]:C1(vn)?or=iw(p0)?gx(Vw(vn)):{}:or={}}return(e0?w1:E_)(vn,function(R0,N0,j0){return Tn(or,R0,N0,j0)}),or}function lM(vn,Tn){return vn==null?!0:s$(vn,Tn)}function uM(vn,Tn,or){return vn==null?vn:l$(vn,Tn,a_(or))}function cM(vn,Tn,or,Mo){return Mo=typeof Mo=="function"?Mo:pt,vn==null?vn:l$(vn,Tn,a_(or),Mo)}function B2(vn){return vn==null?[]:s0(vn,u_(vn))}function dM(vn){return vn==null?[]:s0(vn,N_(vn))}function fM(vn,Tn,or){return or===pt&&(or=Tn,Tn=pt),or!==pt&&(or=ux(or),or=or===or?or:0),Tn!==pt&&(Tn=ux(Tn),Tn=Tn===Tn?Tn:0),Ox(ux(vn),Tn,or)}function pM(vn,Tn,or){return Tn=ow(Tn),or===pt?(or=Tn,Tn=0):or=ow(or),vn=ux(vn),TS(vn,Tn,or)}function hM(vn,Tn,or){if(or&&typeof or!="boolean"&&M_(vn,Tn,or)&&(Tn=or=pt),or===pt&&(typeof Tn=="boolean"?(or=Tn,Tn=pt):typeof vn=="boolean"&&(or=vn,vn=pt)),vn===pt&&Tn===pt?(vn=0,Tn=1):(vn=ow(vn),Tn===pt?(Tn=vn,vn=0):Tn=ow(Tn)),vn>Tn){var Mo=vn;vn=Tn,Tn=Mo}if(or||vn%1||Tn%1){var e0=G2();return t_(vn+e0*(Tn-vn+Ow("1e-"+((e0+"").length-1))),Tn)}return ox(vn,Tn)}var mM=_n(function(vn,Tn,or){return Tn=Tn.toLowerCase(),vn+(or?UE(Tn):Tn)});function UE(vn){return HS(h1(vn).toLowerCase())}function zE(vn){return vn=h1(vn),vn&&vn.replace(Y0,sv).replace(Oy,"")}function gM(vn,Tn,or){vn=h1(vn),Tn=o_(Tn);var Mo=vn.length;or=or===pt?Mo:Ox(Xv(or),0,Mo);var e0=or;return or-=Tn.length,or>=0&&vn.slice(or,e0)==Tn}function yM(vn){return vn=h1(vn),vn&&ty.test(vn)?vn.replace(k0,Jy):vn}function vM(vn){return vn=h1(vn),vn&&X0.test(vn)?vn.replace(Yv,"\\$&"):vn}var _M=_n(function(vn,Tn,or){return vn+(or?"-":"")+Tn.toLowerCase()}),bM=_n(function(vn,Tn,or){return vn+(or?" ":"")+Tn.toLowerCase()}),xM=aS("toLowerCase");function wM(vn,Tn,or){vn=h1(vn),Tn=Xv(Tn);var Mo=Tn?J_(vn):0;if(!Tn||Mo>=Tn)return vn;var e0=(Tn-Mo)/2;return Gy(jw(e0),or)+vn+Gy(Ww(e0),or)}function $M(vn,Tn,or){vn=h1(vn),Tn=Xv(Tn);var Mo=Tn?J_(vn):0;return Tn&&Mo<Tn?vn+Gy(Tn-Mo,or):vn}function SM(vn,Tn,or){vn=h1(vn),Tn=Xv(Tn);var Mo=Tn?J_(vn):0;return Tn&&Mo<Tn?Gy(Tn-Mo,or)+vn:vn}function EM(vn,Tn,or){return or||Tn==null?Tn=0:Tn&&(Tn=+Tn),I$(h1(vn).replace(Pv,""),Tn||0)}function TM(vn,Tn,or){return(or?M_(vn,Tn,or):Tn===pt)?Tn=1:Tn=Xv(Tn),Iw(h1(vn),Tn)}function AM(){var vn=arguments,Tn=h1(vn[0]);return vn.length<3?Tn:Tn.replace(vn[1],vn[2])}var CM=_n(function(vn,Tn,or){return vn+(or?"_":"")+Tn.toLowerCase()});function MM(vn,Tn,or){return or&&typeof or!="number"&&M_(vn,Tn,or)&&(Tn=or=pt),or=or===pt?a0:or>>>0,or?(vn=h1(vn),vn&&(typeof Tn=="string"||Tn!=null&&!zS(Tn))&&(Tn=o_(Tn),!Tn&&r1(vn))?Fx($1(vn),0,or):vn.split(Tn,or)):[]}var IM=_n(function(vn,Tn,or){return vn+(or?" ":"")+HS(Tn)});function RM(vn,Tn,or){return vn=h1(vn),or=or==null?0:Ox(Xv(or),0,vn.length),Tn=o_(Tn),vn.slice(or,or+Tn.length)==Tn}function PM(vn,Tn,or){var Mo=u0.templateSettings;or&&M_(vn,Tn,or)&&(Tn=pt),vn=h1(vn),Tn=gS({},Tn,Mo,H0);var e0=gS({},Tn.imports,Mo.imports,H0),p0=u_(e0),R0=s0(e0,p0),N0,j0,Ay=0,Cy=Tn.interpolate||ey,Ny="__p += '",nv=V1((Tn.escape||ey).source+"|"+Cy.source+"|"+(Cy===vv?c0:ey).source+"|"+(Tn.evaluate||ey).source+"|$","g"),yv="//# sourceURL="+(d1.call(Tn,"sourceURL")?(Tn.sourceURL+"").replace(/\s/g," "):"lodash.templateSources["+ ++Yy+"]")+`
`;vn.replace(nv,function(kv,o1,l1,Z_,I_,X_){return l1||(l1=Z_),Ny+=vn.slice(Ay,X_).replace(ny,wv),o1&&(N0=!0,Ny+=`' +
__e(`+o1+`) +
'`),I_&&(j0=!0,Ny+=`';
`+I_+`;
__p += '`),l1&&(Ny+=`' +
((__t = (`+l1+`)) == null ? '' : __t) +
'`),Ay=X_+kv.length,kv}),Ny+=`';
`;var Bv=d1.call(Tn,"variable")&&Tn.variable;if(!Bv)Ny=`with (obj) {
`+Ny+`
}
`;else if(c_.test(Bv))throw new Nv(Lt);Ny=(j0?Ny.replace(xy,""):Ny).replace(o0,"$1").replace(v0,"$1;"),Ny="function("+(Bv||"obj")+`) {
`+(Bv?"":`obj || (obj = {});
`)+"var __t, __p = ''"+(N0?", __e = _.escape":"")+(j0?`, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`:`;
`)+Ny+`return __p
}`;var e1=VE(function(){return Vv(p0,yv+"return "+Ny).apply(pt,R0)});if(e1.source=Ny,US(e1))throw e1;return e1}function OM(vn){return h1(vn).toLowerCase()}function DM(vn){return h1(vn).toUpperCase()}function BM(vn,Tn,or){if(vn=h1(vn),vn&&(or||Tn===pt))return Yr(vn);if(!vn||!(Tn=o_(Tn)))return vn;var Mo=$1(vn),e0=$1(Tn),p0=O0(Mo,e0),R0=fy(Mo,e0)+1;return Fx(Mo,p0,R0).join("")}function kM(vn,Tn,or){if(vn=h1(vn),vn&&(or||Tn===pt))return vn.slice(0,pw(vn)+1);if(!vn||!(Tn=o_(Tn)))return vn;var Mo=$1(vn),e0=fy(Mo,$1(Tn))+1;return Fx(Mo,0,e0).join("")}function LM(vn,Tn,or){if(vn=h1(vn),vn&&(or||Tn===pt))return vn.replace(Pv,"");if(!vn||!(Tn=o_(Tn)))return vn;var Mo=$1(vn),e0=O0(Mo,$1(Tn));return Fx(Mo,e0).join("")}function NM(vn,Tn){var or=Kr,Mo=ko;if(C1(Tn)){var e0="separator"in Tn?Tn.separator:e0;or="length"in Tn?Xv(Tn.length):or,Mo="omission"in Tn?o_(Tn.omission):Mo}vn=h1(vn);var p0=vn.length;if(r1(vn)){var R0=$1(vn);p0=R0.length}if(or>=p0)return vn;var N0=or-J_(Mo);if(N0<1)return Mo;var j0=R0?Fx(R0,0,N0).join(""):vn.slice(0,N0);if(e0===pt)return j0+Mo;if(R0&&(N0+=j0.length-N0),zS(e0)){if(vn.slice(N0).search(e0)){var Ay,Cy=j0;for(e0.global||(e0=V1(e0.source,h1(D0.exec(e0))+"g")),e0.lastIndex=0;Ay=e0.exec(Cy);)var Ny=Ay.index;j0=j0.slice(0,Ny===pt?N0:Ny)}}else if(vn.indexOf(o_(e0),N0)!=N0){var nv=j0.lastIndexOf(e0);nv>-1&&(j0=j0.slice(0,nv))}return j0+Mo}function FM(vn){return vn=h1(vn),vn&&$0.test(vn)?vn.replace(i0,hw):vn}var UM=_n(function(vn,Tn,or){return vn+(or?" ":"")+Tn.toUpperCase()}),HS=aS("toUpperCase");function GE(vn,Tn,or){return vn=h1(vn),Tn=or?pt:Tn,Tn===pt?iy(vn)?mw(vn):Nw(vn):vn.match(Tn)||[]}var VE=Sv(function(vn,Tn){try{return y1(vn,pt,Tn)}catch(or){return US(or)?or:new Nv(or)}}),zM=Kv(function(vn,Tn){return w1(Tn,function(or){or=zx(or),ix(vn,or,NS(vn[or],vn))}),vn});function GM(vn){var Tn=vn==null?0:vn.length,or=Iv();return vn=Tn?f1(vn,function(Mo){if(typeof Mo[1]!="function")throw new h_(Tt);return[or(Mo[0]),Mo[1]]}):[],Sv(function(Mo){for(var e0=-1;++e0<Tn;){var p0=vn[e0];if(y1(p0[0],this,Mo))return y1(p0[1],this,Mo)}})}function VM(vn){return Y2(S_(vn,Gt))}function WS(vn){return function(){return vn}}function HM(vn,Tn){return vn==null||vn!==vn?Tn:vn}var WM=Xr(),jM=Xr(!0);function F_(vn){return vn}function jS(vn){return Cw(typeof vn=="function"?vn:S_(vn,Gt))}function qM(vn){return n2(S_(vn,Gt))}function KM(vn,Tn){return w2(vn,S_(Tn,Gt))}var ZM=Sv(function(vn,Tn){return function(or){return v1(or,vn,Tn)}}),XM=Sv(function(vn,Tn){return function(or){return v1(vn,or,Tn)}});function qS(vn,Tn,or){var Mo=u_(Tn),e0=Qx(Tn,Mo);or==null&&!(C1(Tn)&&(e0.length||!Mo.length))&&(or=Tn,Tn=vn,vn=this,e0=Qx(Tn,u_(Tn)));var p0=!(C1(or)&&"chain"in or)||!!or.chain,R0=iw(vn);return w1(e0,function(N0){var j0=Tn[N0];vn[N0]=j0,R0&&(vn.prototype[N0]=function(){var Ay=this.__chain__;if(p0||Ay){var Cy=vn(this.__wrapped__),Ny=Cy.__actions__=s_(this.__actions__);return Ny.push({func:j0,args:arguments,thisArg:vn}),Cy.__chain__=Ay,Cy}return j0.apply(vn,Q1([this.value()],arguments))})}),vn}function YM(){return _1._===this&&(_1._=d2),this}function KS(){}function JM(vn){return vn=Xv(vn),Sv(function(Tn){return yx(Tn,vn)})}var QM=gy(f1),e3=gy(kw),t3=gy(Sx);function HE(vn){return PS(vn)?K1(zx(vn)):E2(vn)}function n3(vn){return function(Tn){return vn==null?pt:j_(vn,Tn)}}var r3=Uv(),i3=Uv(!0);function ZS(){return[]}function XS(){return!1}function o3(){return{}}function a3(){return""}function s3(){return!0}function l3(vn,Tn){if(vn=Xv(vn),vn<1||vn>n0)return[];var or=a0,Mo=t_(vn,a0);Tn=Iv(Tn),vn-=a0;for(var e0=P_(Mo,Tn);++or<vn;)Tn(or);return e0}function u3(vn){return Wv(vn)?f1(vn,zx):K_(vn)?[vn]:s_(cE(h1(vn)))}function c3(vn){var Tn=++L2;return h1(vn)+Tn}var d3=z0(function(vn,Tn){return vn+Tn},0),f3=mv("ceil"),p3=z0(function(vn,Tn){return vn/Tn},1),h3=mv("floor");function m3(vn){return vn&&vn.length?Jw(vn,F_,e2):pt}function g3(vn,Tn){return vn&&vn.length?Jw(vn,Iv(Tn,2),e2):pt}function y3(vn){return Ax(vn,F_)}function v3(vn,Tn){return Ax(vn,Iv(Tn,2))}function _3(vn){return vn&&vn.length?Jw(vn,F_,t2):pt}function b3(vn,Tn){return vn&&vn.length?Jw(vn,Iv(Tn,2),t2):pt}var x3=z0(function(vn,Tn){return vn*Tn},1),w3=mv("round"),$3=z0(function(vn,Tn){return vn-Tn},0);function S3(vn){return vn&&vn.length?e_(vn,F_):0}function E3(vn,Tn){return vn&&vn.length?e_(vn,Iv(Tn,2)):0}return u0.after=qA,u0.ary=xE,u0.assign=DC,u0.assignIn=BE,u0.assignInWith=gS,u0.assignWith=BC,u0.at=kC,u0.before=wE,u0.bind=NS,u0.bindAll=zM,u0.bindKey=$E,u0.castArray=oC,u0.chain=vE,u0.chunk=hT,u0.compact=mT,u0.concat=gT,u0.cond=GM,u0.conforms=VM,u0.constant=WS,u0.countBy=SA,u0.create=LC,u0.curry=SE,u0.curryRight=EE,u0.debounce=TE,u0.defaults=NC,u0.defaultsDeep=FC,u0.defer=KA,u0.delay=ZA,u0.difference=yT,u0.differenceBy=vT,u0.differenceWith=_T,u0.drop=bT,u0.dropRight=xT,u0.dropRightWhile=wT,u0.dropWhile=$T,u0.fill=ST,u0.filter=TA,u0.flatMap=MA,u0.flatMapDeep=IA,u0.flatMapDepth=RA,u0.flatten=hE,u0.flattenDeep=ET,u0.flattenDepth=TT,u0.flip=XA,u0.flow=WM,u0.flowRight=jM,u0.fromPairs=AT,u0.functions=jC,u0.functionsIn=qC,u0.groupBy=PA,u0.initial=MT,u0.intersection=IT,u0.intersectionBy=RT,u0.intersectionWith=PT,u0.invert=ZC,u0.invertBy=XC,u0.invokeMap=DA,u0.iteratee=jS,u0.keyBy=BA,u0.keys=u_,u0.keysIn=N_,u0.map=cS,u0.mapKeys=JC,u0.mapValues=QC,u0.matches=qM,u0.matchesProperty=KM,u0.memoize=fS,u0.merge=eM,u0.mergeWith=kE,u0.method=ZM,u0.methodOf=XM,u0.mixin=qS,u0.negate=pS,u0.nthArg=JM,u0.omit=tM,u0.omitBy=nM,u0.once=YA,u0.orderBy=kA,u0.over=QM,u0.overArgs=JA,u0.overEvery=e3,u0.overSome=t3,u0.partial=FS,u0.partialRight=AE,u0.partition=LA,u0.pick=rM,u0.pickBy=LE,u0.property=HE,u0.propertyOf=n3,u0.pull=kT,u0.pullAll=gE,u0.pullAllBy=LT,u0.pullAllWith=NT,u0.pullAt=FT,u0.range=r3,u0.rangeRight=i3,u0.rearg=QA,u0.reject=UA,u0.remove=UT,u0.rest=eC,u0.reverse=kS,u0.sampleSize=GA,u0.set=oM,u0.setWith=aM,u0.shuffle=VA,u0.slice=zT,u0.sortBy=jA,u0.sortedUniq=KT,u0.sortedUniqBy=ZT,u0.split=MM,u0.spread=tC,u0.tail=XT,u0.take=YT,u0.takeRight=JT,u0.takeRightWhile=QT,u0.takeWhile=eA,u0.tap=mA,u0.throttle=nC,u0.thru=uS,u0.toArray=PE,u0.toPairs=NE,u0.toPairsIn=FE,u0.toPath=u3,u0.toPlainObject=DE,u0.transform=sM,u0.unary=rC,u0.union=tA,u0.unionBy=nA,u0.unionWith=rA,u0.uniq=iA,u0.uniqBy=oA,u0.uniqWith=aA,u0.unset=lM,u0.unzip=LS,u0.unzipWith=yE,u0.update=uM,u0.updateWith=cM,u0.values=B2,u0.valuesIn=dM,u0.without=sA,u0.words=GE,u0.wrap=iC,u0.xor=lA,u0.xorBy=uA,u0.xorWith=cA,u0.zip=dA,u0.zipObject=fA,u0.zipObjectDeep=pA,u0.zipWith=hA,u0.entries=NE,u0.entriesIn=FE,u0.extend=BE,u0.extendWith=gS,qS(u0,u0),u0.add=d3,u0.attempt=VE,u0.camelCase=mM,u0.capitalize=UE,u0.ceil=f3,u0.clamp=fM,u0.clone=aC,u0.cloneDeep=lC,u0.cloneDeepWith=uC,u0.cloneWith=sC,u0.conformsTo=cC,u0.deburr=zE,u0.defaultTo=HM,u0.divide=p3,u0.endsWith=gM,u0.eq=bx,u0.escape=yM,u0.escapeRegExp=vM,u0.every=EA,u0.find=AA,u0.findIndex=fE,u0.findKey=UC,u0.findLast=CA,u0.findLastIndex=pE,u0.findLastKey=zC,u0.floor=h3,u0.forEach=_E,u0.forEachRight=bE,u0.forIn=GC,u0.forInRight=VC,u0.forOwn=HC,u0.forOwnRight=WC,u0.get=GS,u0.gt=dC,u0.gte=fC,u0.has=KC,u0.hasIn=VS,u0.head=mE,u0.identity=F_,u0.includes=OA,u0.indexOf=CT,u0.inRange=pM,u0.invoke=YC,u0.isArguments=c2,u0.isArray=Wv,u0.isArrayBuffer=pC,u0.isArrayLike=L_,u0.isArrayLikeObject=F1,u0.isBoolean=hC,u0.isBuffer=Rw,u0.isDate=mC,u0.isElement=gC,u0.isEmpty=yC,u0.isEqual=vC,u0.isEqualWith=_C,u0.isError=US,u0.isFinite=bC,u0.isFunction=iw,u0.isInteger=CE,u0.isLength=hS,u0.isMap=ME,u0.isMatch=xC,u0.isMatchWith=wC,u0.isNaN=$C,u0.isNative=SC,u0.isNil=TC,u0.isNull=EC,u0.isNumber=IE,u0.isObject=C1,u0.isObjectLike=B1,u0.isPlainObject=g$,u0.isRegExp=zS,u0.isSafeInteger=AC,u0.isSet=RE,u0.isString=mS,u0.isSymbol=K_,u0.isTypedArray=D2,u0.isUndefined=CC,u0.isWeakMap=MC,u0.isWeakSet=IC,u0.join=OT,u0.kebabCase=_M,u0.last=lx,u0.lastIndexOf=DT,u0.lowerCase=bM,u0.lowerFirst=xM,u0.lt=RC,u0.lte=PC,u0.max=m3,u0.maxBy=g3,u0.mean=y3,u0.meanBy=v3,u0.min=_3,u0.minBy=b3,u0.stubArray=ZS,u0.stubFalse=XS,u0.stubObject=o3,u0.stubString=a3,u0.stubTrue=s3,u0.multiply=x3,u0.nth=BT,u0.noConflict=YM,u0.noop=KS,u0.now=dS,u0.pad=wM,u0.padEnd=$M,u0.padStart=SM,u0.parseInt=EM,u0.random=hM,u0.reduce=NA,u0.reduceRight=FA,u0.repeat=TM,u0.replace=AM,u0.result=iM,u0.round=w3,u0.runInContext=F0,u0.sample=zA,u0.size=HA,u0.snakeCase=CM,u0.some=WA,u0.sortedIndex=GT,u0.sortedIndexBy=VT,u0.sortedIndexOf=HT,u0.sortedLastIndex=WT,u0.sortedLastIndexBy=jT,u0.sortedLastIndexOf=qT,u0.startCase=IM,u0.startsWith=RM,u0.subtract=$3,u0.sum=S3,u0.sumBy=E3,u0.template=PM,u0.times=l3,u0.toFinite=ow,u0.toInteger=Xv,u0.toLength=OE,u0.toLower=OM,u0.toNumber=ux,u0.toSafeInteger=OC,u0.toString=h1,u0.toUpper=DM,u0.trim=BM,u0.trimEnd=kM,u0.trimStart=LM,u0.truncate=NM,u0.unescape=FM,u0.uniqueId=c3,u0.upperCase=UM,u0.upperFirst=HS,u0.each=_E,u0.eachRight=bE,u0.first=mE,qS(u0,function(){var vn={};return E_(u0,function(Tn,or){d1.call(u0.prototype,or)||(vn[or]=Tn)}),vn}(),{chain:!1}),u0.VERSION=vt,w1(["bind","bindKey","curry","curryRight","partial","partialRight"],function(vn){u0[vn].placeholder=u0}),w1(["drop","take"],function(vn,Tn){Cv.prototype[vn]=function(or){or=or===pt?1:L1(Xv(or),0);var Mo=this.__filtered__&&!Tn?new Cv(this):this.clone();return Mo.__filtered__?Mo.__takeCount__=t_(or,Mo.__takeCount__):Mo.__views__.push({size:t_(or,a0),type:vn+(Mo.__dir__<0?"Right":"")}),Mo},Cv.prototype[vn+"Right"]=function(or){return this.reverse()[vn](or).reverse()}}),w1(["filter","map","takeWhile"],function(vn,Tn){var or=Tn+1,Mo=or==l0||or==t0;Cv.prototype[vn]=function(e0){var p0=this.clone();return p0.__iteratees__.push({iteratee:Iv(e0,3),type:or}),p0.__filtered__=p0.__filtered__||Mo,p0}}),w1(["head","last"],function(vn,Tn){var or="take"+(Tn?"Right":"");Cv.prototype[vn]=function(){return this[or](1).value()[0]}}),w1(["initial","tail"],function(vn,Tn){var or="drop"+(Tn?"":"Right");Cv.prototype[vn]=function(){return this.__filtered__?new Cv(this):this[or](1)}}),Cv.prototype.compact=function(){return this.filter(F_)},Cv.prototype.find=function(vn){return this.filter(vn).head()},Cv.prototype.findLast=function(vn){return this.reverse().find(vn)},Cv.prototype.invokeMap=Sv(function(vn,Tn){return typeof vn=="function"?new Cv(this):this.map(function(or){return v1(or,vn,Tn)})}),Cv.prototype.reject=function(vn){return this.filter(pS(Iv(vn)))},Cv.prototype.slice=function(vn,Tn){vn=Xv(vn);var or=this;return or.__filtered__&&(vn>0||Tn<0)?new Cv(or):(vn<0?or=or.takeRight(-vn):vn&&(or=or.drop(vn)),Tn!==pt&&(Tn=Xv(Tn),or=Tn<0?or.dropRight(-Tn):or.take(Tn-vn)),or)},Cv.prototype.takeRightWhile=function(vn){return this.reverse().takeWhile(vn).reverse()},Cv.prototype.toArray=function(){return this.take(a0)},E_(Cv.prototype,function(vn,Tn){var or=/^(?:filter|find|map|reject)|While$/.test(Tn),Mo=/^(?:head|last)$/.test(Tn),e0=u0[Mo?"take"+(Tn=="last"?"Right":""):Tn],p0=Mo||/^find/.test(Tn);e0&&(u0.prototype[Tn]=function(){var R0=this.__wrapped__,N0=Mo?[1]:arguments,j0=R0 instanceof Cv,Ay=N0[0],Cy=j0||Wv(R0),Ny=function(o1){var l1=e0.apply(u0,Q1([o1],N0));return Mo&&nv?l1[0]:l1};Cy&&or&&typeof Ay=="function"&&Ay.length!=1&&(j0=Cy=!1);var nv=this.__chain__,yv=!!this.__actions__.length,Bv=p0&&!nv,e1=j0&&!yv;if(!p0&&Cy){R0=e1?R0:new Cv(this);var kv=vn.apply(R0,N0);return kv.__actions__.push({func:uS,args:[Ny],thisArg:pt}),new n_(kv,nv)}return Bv&&e1?vn.apply(this,N0):(kv=this.thru(Ny),Bv?Mo?kv.value()[0]:kv.value():kv)})}),w1(["pop","push","shift","sort","splice","unshift"],function(vn){var Tn=Cx[vn],or=/^(?:push|sort|unshift)$/.test(vn)?"tap":"thru",Mo=/^(?:pop|shift)$/.test(vn);u0.prototype[vn]=function(){var e0=arguments;if(Mo&&!this.__chain__){var p0=this.value();return Tn.apply(Wv(p0)?p0:[],e0)}return this[or](function(R0){return Tn.apply(Wv(R0)?R0:[],e0)})}}),E_(Cv.prototype,function(vn,Tn){var or=u0[Tn];if(or){var Mo=or.name+"";d1.call(Xx,Mo)||(Xx[Mo]=[]),Xx[Mo].push({name:Tn,func:or})}}),Xx[Uo(pt,wn).name]=[{name:"wrapper",func:pt}],Cv.prototype.clone=bS,Cv.prototype.reverse=xS,Cv.prototype.value=$_,u0.prototype.at=gA,u0.prototype.chain=yA,u0.prototype.commit=vA,u0.prototype.next=_A,u0.prototype.plant=xA,u0.prototype.reverse=wA,u0.prototype.toJSON=u0.prototype.valueOf=u0.prototype.value=$A,u0.prototype.first=u0.prototype.head,Ix&&(u0.prototype[Ix]=bA),u0},ex=S$();typeof define=="function"&&typeof define.amd=="object"&&define.amd?(_1._=ex,define(function(){return ex})):I1?((I1.exports=ex)._=ex,Vx._=ex):_1._=ex}).call(st)}}),import_lodash=__toESM(require_lodash());async function imageDecode(st){const at=MimeType.fromString(st.type);switch(at.type){case"image/x-alpha8":{const pt=parseInt(at.params.width),vt=parseInt(at.params.height);return ndarray4(new Uint8Array(await st.arrayBuffer()),[vt,pt,1])}case"image/x-rgba8":{const pt=parseInt(at.params.width),vt=parseInt(at.params.height);return ndarray4(new Uint8Array(await st.arrayBuffer()),[vt,pt,4])}case"application/octet-stream":case"image/png":case"image/jpeg":case"image/jpg":case"image/webp":{const pt=await createImageBitmap(st),vt=imageBitmapToImageData(pt);return ndarray4(new Uint8Array(vt.data),[vt.height,vt.width,4])}default:throw new Error(`Invalid format: ${at.type} with params: ${at.params}`)}}async function imageEncode(st,at=.8,pt="image/png"){const[vt,wt,$t]=st.shape;switch(pt){case"image/x-alpha8":case"image/x-rgba8":{const Ft=MimeType.create(pt,{width:wt.toString(),height:vt.toString()});return new Blob([st.data],{type:Ft.toString()})}case"image/png":case"image/jpeg":case"image/webp":{const Ft=new ImageData(new Uint8ClampedArray(st.data),wt,vt);var Tt=createCanvas(Ft.width,Ft.height),Lt=Tt.getContext("2d");return Lt.putImageData(Ft,0,0),Tt.convertToBlob({quality:at,type:pt})}default:throw new Error(`Invalid format: ${pt}`)}}var MimeType=class QS{constructor(at,pt){this.type="application/octet-stream",this.params={},this.type=at,this.params=pt}toString(){const at=[];for(const pt in this.params){const vt=this.params[pt];at.push(`${pt}=${vt}`)}return[this.type,...at].join(";")}static create(at,pt){return new QS(at,pt)}isIdentical(at){return this.type===at.type&&this.params===at.params}isEqual(at){return this.type===at.type}static fromString(at){const[pt,...vt]=at.split(";"),wt={};for(const $t of vt){const[Tt,Lt]=$t.split("=");wt[Tt.trim()]=Lt.trim()}return new QS(pt,wt)}};function isAbsoluteURI(st){return new RegExp("^(?:[a-z+]+:)?//","i").test(st)}function ensureAbsoluteURI(st,at){return isAbsoluteURI(st)?st:new URL(st,at).href}function imageBitmapToImageData(st){var at=createCanvas(st.width,st.height),pt=at.getContext("2d");return pt.drawImage(st,0,0),pt.getImageData(0,0,at.width,at.height)}function createTypeArray(st){if(typeof Uint8Array<"u")return new Uint8Array(st);if(typeof Uint8ClampedArray<"u")return new Uint8ClampedArray(st);if(typeof Uint16Array<"u")return new Uint16Array(st);if(typeof Uint32Array<"u")return new Uint32Array(st);if(typeof Float32Array<"u")return new Float32Array(st);if(typeof Float64Array<"u")return new Float64Array(st);throw new Error("TypedArray not supported")}function tensorResizeBilinear(st,at,pt,vt=!1){const[wt,$t,Tt]=st.shape;let Lt=$t/at,Ft=wt/pt;vt&&(Lt=Ft=Math.max(Lt,Ft)>1?Math.max(Lt,Ft):Math.min(Lt,Ft));const Ct=ndarray4(createTypeArray(Tt*at*pt),[pt,at,Tt]);for(let Ht=0;Ht<pt;Ht++)for(let Gt=0;Gt<at;Gt++){const jt=Gt*Lt,qt=Ht*Ft,Kt=Math.max(Math.floor(jt),0),An=Math.min(Math.ceil(jt),$t-1),Sn=Math.max(Math.floor(qt),0),wn=Math.min(Math.ceil(qt),wt-1),In=jt-Kt,tr=qt-Sn;for(let rr=0;rr<Tt;rr++){const Hr=st.get(Sn,Kt,rr),qr=st.get(Sn,An,rr),Zr=st.get(wn,Kt,rr),Bo=st.get(wn,An,rr),Xo=(1-In)*(1-tr)*Hr+In*(1-tr)*qr+(1-In)*tr*Zr+In*tr*Bo;Ct.set(Ht,Gt,rr,Xo)}}return Ct}function tensorHWCtoBCHW(st,at=[128,128,128],pt=[256,256,256]){var vt=st.data;const[wt,$t,Tt]=st.shape,Lt=wt*$t,Ft=new Float32Array(3*Lt);for(let Ct=0,Ht=0;Ct<vt.length;Ct+=4,Ht+=1)Ft[Ht]=(vt[Ct]-at[0])/pt[0],Ft[Ht+Lt]=(vt[Ct+1]-at[1])/pt[1],Ft[Ht+Lt+Lt]=(vt[Ct+2]-at[2])/pt[2];return ndarray4(Ft,[1,3,wt,$t])}async function imageSourceToImageData(st,at){return typeof st=="string"&&(st=ensureAbsoluteURI(st,at.publicPath),st=new URL(st)),st instanceof URL&&(st=await(await fetch(st,{})).blob()),(st instanceof ArrayBuffer||ArrayBuffer.isView(st))&&(st=new Blob([st])),st instanceof Blob&&(st=await imageDecode(st)),st}function convertFloat32ToUint8(st){const at=new Uint8Array(st.data.length);for(let pt=0;pt<st.data.length;pt++)at[pt]=st.data[pt]*255;return ndarray4(at,st.shape)}function createCanvas(st,at){let pt;if(typeof OffscreenCanvas<"u"?pt=new OffscreenCanvas(st,at):pt=document.createElement("canvas"),!pt)throw new Error("Canvas nor OffscreenCanvas are available in the current context.");return pt}async function loadAsUrl(st,at){return URL.createObjectURL(await loadAsBlob(st,at))}async function loadAsBlob(st,at){const pt=new URL("resources.json",at.publicPath),vt=await fetch(pt);if(!vt.ok)throw new Error("Resource metadata not found. Ensure that the config.publicPath is configured correctly.");const $t=(await vt.json())[st];if(!$t)throw new Error(`Resource ${st} not found. Ensure that the config.publicPath is configured correctly.`);const Tt=$t.chunks;let Lt=0;const Ft=Tt.map(async Gt=>{const jt=Gt.offsets[1]-Gt.offsets[0],qt=at.publicPath?new URL(Gt.hash,at.publicPath).toString():Gt.hash,An=await(await fetch(qt,at.fetchArgs)).blob();if(jt!==An.size)throw new Error(`Failed to fetch ${st} with size ${jt} but got ${An.size}`);return at.progress&&(Lt+=jt,at.progress(`fetch:${st}`,Lt,$t.size)),An}),Ct=await Promise.all(Ft),Ht=new Blob(Ct,{type:$t.mime});if(Ht.size!==$t.size)throw new Error(`Failed to fetch ${st} with size ${$t.size} but got ${Ht.size}`);return Ht}var simd=()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,10,1,8,0,65,0,253,15,253,98,11])),threads=()=>(async st=>{try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(st)}catch{return!1}})(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])),webgpu=()=>navigator.gpu!==void 0,maxNumThreads=()=>navigator.hardwareConcurrency??4;async function createOnnxSession(st,at){const pt=at.device==="gpu",vt=await threads(),wt=simd(),$t=at.proxyToWorker,Tt=[pt?"webgpu":"wasm"],Lt=pt?ort_gpu:ort_cpu;at.debug&&(console.debug("	Using Threads:",vt),console.debug("	Using SIMD:",wt),console.debug("	Using WebGPU:",pt),console.debug("	Proxy to Worker:",$t),Lt.env.debug=!0,Lt.env.logLevel="verbose"),Lt.env.wasm.numThreads=maxNumThreads(),Lt.env.wasm.simd=simd(),Lt.env.wasm.proxy=$t;const Ft={"ort-wasm-simd-threaded.wasm":vt&&wt,"ort-wasm-simd.wasm":!vt&&wt,"ort-wasm-threaded.wasm":!pt&&vt&&!wt,"ort-wasm.wasm":!pt&&!vt&&!wt},Ct={};for(const[jt,qt]of Object.entries(Ft))if(qt){const Kt=pt&&jt.includes("simd")?`/onnxruntime-web/${jt.replace(".wasm",".jsep.wasm")}`:`/onnxruntime-web/${jt}`;Ct[jt]=await loadAsUrl(Kt,at)}Lt.env.wasm.wasmPaths=Ct,at.debug&&console.debug("ort.env.wasm:",Lt.env.wasm);const Ht={executionProviders:Tt,graphOptimizationLevel:"all",executionMode:"parallel",enableCpuMemArena:!0};return await Lt.InferenceSession.create(st,Ht).catch(jt=>{throw new Error(`Failed to create session: "${jt}". Please check if the publicPath is set correctly.`)})}async function runOnnxSession(st,at,pt,vt){const $t=vt.device==="gpu"?ort_gpu:ort_cpu,Tt={};for(const[Ct,Ht]of at)Tt[Ct]=new $t.Tensor("float32",new Float32Array(Ht.data),Ht.shape);const Lt=await st.run(Tt,{}),Ft=[];for(const Ct of pt){const Ht=Lt[Ct],Gt=Ht.dims,jt=Ht.data,qt=ndarray4(jt,Gt);Ft.push(qt)}return Ft}var package_default={name:"@imgly/background-removal",version:"1.5.2",description:"Background Removal in the Browser",keywords:["background-removal","client-side","data-privacy","image-segmentation","image-matting","onnx"],repository:{type:"git",url:"git+https://github.com/imgly/background-removal-js.git"},license:"SEE LICENSE IN LICENSE.md",author:{name:"IMG.LY GmbH",email:"support@img.ly",url:"https://img.ly"},bugs:{email:"support@img.ly"},source:"./src/index.ts",main:"./dist/index.cjs",module:"./dist/index.mjs",types:"./dist/src/index.d.ts",exports:{".":{require:"./dist/index.cjs",import:"./dist/index.mjs",types:"./dist/src/index.d.ts"}},homepage:"https://img.ly/showcases/cesdk/web/background-removal",files:["LICENSE.md","README.md","CHANGELOG.md","ThirdPartyLicenses.json","dist/","bin/"],scripts:{start:"npm run watch",clean:"npx rimraf dist",test:"true",resources:"node ../../scripts/package-resources.mjs","changelog:create":"node ../../scripts/changelog/changelog-create.mjs","changelog:generate":"node ../../scripts/changelog/changelog-generate.mjs",build:"npm run clean && npm run types && npm run resources && npm run changelog:generate && node scripts/build.mjs",types:" npx tsc --declaration --emitDeclarationOnly --declarationDir dist --declarationMap",watch:"npm run clean && npm run resources && npm run changelog:generate && node scripts/watch.mjs","publish:latest":"npm publish --tag latest --access public","publish:next":"npm publish --tag next --access public","package:pack":"npm pack . --pack-destination ../../releases",lint:"npx prettier --write ."},dependencies:{"@types/lodash-es":"^4.17.12","@types/ndarray":"~1.0.14","@types/node":"~20.3.0","lodash-es":"^4.17.21",ndarray:"~1.0.0","onnxruntime-web":"~1.18.0",zod:"^3.23.8"},devDependencies:{assert:"~2.0.0",esbuild:"~0.18.0",glob:"~10.3.0","npm-dts":"~1.3.0",process:"~0.11.0","ts-loader":"~9.4.0",tslib:"~2.5.0",typescript:"~5.1.0",util:"~0.12.0",webpack:"~5.85.0","webpack-cli":"~5.1.0"},bundleDependencies:[]},ConfigSchema=z.object({publicPath:z.string().optional().describe("The public path to the wasm files and the onnx model.").default("https://staticimgly.com/@imgly/background-removal-data/${PACKAGE_VERSION}/dist/").transform(st=>st.replace("${PACKAGE_NAME}",package_default.name).replace("${PACKAGE_VERSION}",package_default.version)),debug:z.boolean().default(!1).describe("Whether to enable debug logging."),rescale:z.boolean().default(!0).describe("Whether to rescale the image."),device:z.enum(["cpu","gpu"]).default("cpu").describe("The device to run the model on."),proxyToWorker:z.boolean().default(!0).describe("Whether to proxy inference to a web worker."),fetchArgs:z.any().default({}).describe("Arguments to pass to fetch when loading the model."),progress:z.function().args(z.string(),z.number(),z.number()).returns(z.void()).describe("Progress callback.").optional(),model:z.preprocess(st=>{switch(st){case"large":return"isnet";case"small":return"isnet_quint8";case"medium":return"isnet_fp16";default:return st}},z.enum(["isnet","isnet_fp16","isnet_quint8"])).default("medium"),output:z.object({format:z.enum(["image/png","image/jpeg","image/webp","image/x-rgba8","image/x-alpha8"]).default("image/png"),quality:z.number().default(.8)}).default({})}).default({}).transform(st=>(st.debug&&console.log("Config:",st),st.debug&&!st.progress&&(st.progress=st.progress??((at,pt,vt)=>{console.debug(`Downloading ${at}: ${pt} of ${vt}`)}),crossOriginIsolated||st.debug&&console.debug("Cross-Origin-Isolated is not enabled. Performance will be degraded. Please see  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer.")),st.device=="gpu"&&(webgpu()||(st.debug&&console.debug("Switching to CPU for GPU not supported."),st.device="cpu")),st));function validateConfig(st){return ConfigSchema.parse(st??{})}async function initBase(st){st.debug&&console.debug("Loading model...",st.model);const at=st.model,vt=await(await loadAsBlob(`/models/${at}`,st)).arrayBuffer();return await createOnnxSession(vt,st)}async function initInference(st){st=validateConfig(st);const at=await initBase(st);return{config:st,session:{base:at}}}async function runInference(st,at,pt){const[wt,$t,Tt]=st.shape,Lt=!1;let Ft=tensorResizeBilinear(st,1024,1024,Lt);const Ct=tensorHWCtoBCHW(Ft);let Ht=await runOnnxSession(pt.base,[["input",Ct]],["output"],at),Gt=ndarray4(Ht[0].data,[1024,1024,1]),jt=convertFloat32ToUint8(Gt);return at.rescale?(jt=tensorResizeBilinear(jt,$t,wt,Lt),[jt,st]):[jt,Ft]}var init=(0,import_lodash.memoize)(initInference,st=>JSON.stringify(st));async function removeBackground(st,at){var jt,qt,Kt,An;const{config:pt,session:vt}=await init(at);pt.progress&&pt.progress("compute:decode",0,4);const wt=await imageSourceToImageData(st,pt);(jt=pt.progress)==null||jt.call(pt,"compute:inference",1,4);const[$t,Tt]=await runInference(wt,pt,vt);(qt=pt.progress)==null||qt.call(pt,"compute:mask",2,4);const Lt=Tt,[Ft,Ct]=Lt.shape,Ht=Ft*Ct;for(let Sn=0;Sn<Ht;Sn+=1)Lt.data[4*Sn+3]=$t.data[Sn];(Kt=pt.progress)==null||Kt.call(pt,"compute:encode",3,4);const Gt=await imageEncode(Lt,pt.output.quality,pt.output.format);return(An=pt.progress)==null||An.call(pt,"compute:encode",4,4),Gt}/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/function App(){const[st,at]=reactExports.useState(0),[pt,vt]=reactExports.useState(""),[wt,$t]=reactExports.useState(new Vector3(1,1,1)),Tt=async Ht=>{try{const Gt=await Lt(Ht);console.log("Upload Success:",Gt);const jt=await removeBackground(Ht),qt=URL.createObjectURL(jt),Kt=await Ft(qt);if(console.log("Prominent colors:",Kt),Kt&&Kt.length>0){const An=Ct(Kt.toString());at(An)}else console.error("No colors found")}catch(Gt){console.error("Error:",Gt)}},Lt=async Ht=>{const Gt=new FormData;Gt.append("image",Ht);const jt=await fetch("/upload",{method:"POST",body:Gt});if(!jt.ok)throw new Error("File upload failed");return jt.json()},Ft=async Ht=>{try{return await prominent(Ht,{amount:1,format:"hex"})}catch(Gt){throw Gt instanceof Error?new Error("Error extracting colors: "+Gt.message):new Error("Error extracting colors: Unknown error")}},Ct=Ht=>parseInt(Ht.slice(1),16);return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment,{children:[jsxRuntimeExports.jsx(Pane,{setParentHexColor:at,handleFileUpload:Tt,setParentScale:$t,setParentTexture:vt}),jsxRuntimeExports.jsx(ThreeScene,{hexColor:st,texture:pt,scale:wt})]})}client.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(React.StrictMode,{children:jsxRuntimeExports.jsx(App,{})}));
